### TASK EXTRACT
# Public_001

_Công nghệ ứng dụng vào mô hình nhà thông minh dựa trên Internet vạn vật (IoT - Internet of Things) phần lớn bị hạn chế và phân tán. Các đánh giá trong bài viết được thực hiện để phân loại bối cảnh nghiên cứu về ứng dụng IoT xây dựng mô hình nhà thông minh, nhằm cung cấp những hiểu biết có giá trị về công nghệ và hỗ trợ các nhà nghiên cứu hiểu các nền tảng có sẵn và các lỗ hổng trong lĩnh vực này. Chúng tôi tiến hành tìm kiếm các bài viết liên quan đến (1) nhà thông minh, (2) ứng dụng và (3) IoT trong ba cơ sở dữ liệu chính, cụ thể là: Web of Science, ScienceDirect và IEEE Explore. Các cơ sở dữ liệu này chứa tài liệu về các ứng dụng nhà thông minh sử dụng IoT. Tập dữ liệu thu được bao gồm 229 bài báo được chia thành bốn lớp. Lớp đầu tiên bao gồm các bài viết đánh giá và khảo sát liên quan đến IoT trong mô hình xây dựng nhà thông minh, lớp thứ hai bao gồm các tài liệu ứng dụng IoT và việc sử dụng chúng, lớp thứ ba chứa các đề xuất để phát triển và vận hành các ứng dụng IoT, lớp cuối cùng bao gồm các nghiên cứu thực tế để phát triển IoT ứng dụng nhà thông minh. Sau đó xác định các đặc điểm cơ bản của lĩnh vực mới này theo các khía cạnh: sử dụng IoT vào nhà thông minh cùng những thách thức và các đề xuất để cải tiến._

# Nội dung chính

## Giới thiệu

Nhà thông minh cổ điển, IOT, điện toán đám mây (Cloud Computing) và xử lý sự kiện dựa trên quy tắc, là những nền tảng của nhà thông minh tiên tiến. Mỗi nền tảng đóng góp các thuộc tính và công nghệ cốt lõi của nó. IoT thì kết nối internet và quản lý từ xa các thiết bị di động, được tích hợp với nhiều loại cảm biến. Cảm biến có thể được gắn vào các thiết bị gia đình chẳng hạn như máy lạnh, đèn và các thiết bị khác. Điện toán đám mây cung cấp khả năng tính toán, không gian lưu trữ, phát triển các ứng dụng, duy trì, thực thi các dịch vụ và truy cập các thiết bị gia đình ở bất kỳ đâu vào bất kỳ thời điểm nào. (D. Halabi, S. Hamdan và S. Almajali, 2018).

Phần này giải thích sự tích hợp các nền tảng nhà thông minh cổ điển, IoT và điện toán đám mây. Các phần còn lại sẽ trình bày chi tiết về các nền tảng. Phần 2 sẽ mô tả ngôi nhà thông minh cổ điển, phần 3 giới thiệu IOT, phần 4 trình bày điện toán đám mây, phần 5 sẽ trình bày mô-đun xử lý sự kiện, phần ó mô tả nhà thông minh tiên tiến kết hợp các nền tảng này, cuối cùng phần 7 cung cấp một số thông tin thực tế và các lựa chọn liên quan xây dựng, triển khai nhà thông minh tiên tiến thực tế. Mô tả thử nghiệm qua ba ví dụ cho thấy bản chất sự tích hợp sẽ được trình bày trong phần 8. Cuối cùng, xác định các vấn đề mở và hướng đi trong tương lai của các nền tảng ứng dụng vào nhà thông minh tiên tiến. (Q. Lyu, N. Zheng, H. Liu, C. Gao, S. Chen và J. Liu, 2019).

## Nhà thông minh trước năm 2010

Năm 2008, nhà thông minh là một ý tưởng tự động hóa ngôi nhà, liên quan đến việc kiểm soát, tự động hóa tất cả công nghệ tích hợp trong nó. Nó xác định nơi có các thiết bị, ánh sáng, hệ thống sưởi, điều hòa không khí, TV, máy tính, hệ thống giải trí, thiết bị gia dụng lớn như máy giặt/ máy sấy và tủ lạnh/ tủ đông, hệ thống an ninh và camera có khả năng giao tiếp với nhau và được điều khiển từ xa bằng thời gian biểu, điện thoại, di động hoặc internet. Các hệ thống này bao gồm các công tắc và cảm biến được kết nối tới trung tâm được điều khiển bởi con người bằng thiết bị đầu cuối hoặc thiết bị di động được kết nối với các dịch vụ đám mây. (Funk, M., Chen, L.-L, Yang, S.-W.., & Chen, Y.-K., 2018).

Vào năm 2009, nhà thông minh được cung cấp nhằm mục đích an ninh, sử dụng năng lượng hiệu quả, chi phí vận hành thấp và tiện lợi. Việc lắp đặt các sản phẩm thông minh mang lại sự tiện lợi và tiết kiệm thời gian, tiền bạc và năng lượng. Các hệ thống như vậy có thể thích ứng và điều chỉnh để đáp ứng nhu cầu thay đổi liên tục của chủ nhà. Trong hầu hết các trường hợp, cơ sở hạ tầng của nó đủ linh hoạt để tích hợp với nhiều loại thiết bị từ các nhà cung cấp với nhiều tiêu chuẩn khác nhau. (Ghajargar, M., Wiberg, M., & Stolterman, E., 2018).

Năm 2010, sự phổ biến của nhà thông minh phát triển với tốc độ cao, nó đã trở thành một phần của xu hướng hiện đại hóa và giảm các chi phí bằng cách tích hợp khả năng duy trì nhật ký các sự kiện, thực hiện các quy trình học máy để cung cấp. (AC Jose và R. Malekian, 2018).

### Dịch vụ nhà thông minh

#### Đo điều kiện nhà

Năm 2010, nhà thông minh được trang bị một bộ cảm biến để đo các điều kiện trong nhà, chẳng hạn như: nhiệt độ, độ ẩm, ánh sáng và khoảng cách. Mỗi cảm biến thực hiện một chức năng riêng nhằm ghi lại một hoặc nhiều phép đo. Nhiệt độ và độ ẩm có thể được đo bởi một cảm biến hoặc các cảm biến khác tính toán tỷ lệ ánh sáng cho một khu vực nhất định và khoảng cách từ nó đến mỗi đối tượng tiếp xúc với nó. Tất cả các cảm biến đều cho phép lưu trữ dữ liệu và hiển thị trực quan để người dùng có thể xem ở bất kỳ đâu và bất kỳ lúc nào. Để làm như vậy, cần có một bộ xử lý tín hiệu, một giao thức truyền thông và một máy chủ lưu trữ trên cơ sở hạ tầng đám mây. (N. Ghosh, S. Chandra, V. Sachidananda và Y. Elovici, 2019).

#### Quản lý thiết bị gia dụng

Năm 2010, các dịch vụ đám mây được tạo ra để quản lý và lưu trữ dữ liệu các thiết bị gia dụng. Việc quản lý cho phép người dùng kiểm soát đầu ra của thiết bị truyền động thông minh liên quan đến các thiết bị gia dụng, chẳng hạn như đèn và quạt. Thiết bị truyền động thông minh là các thiết bị, chẳng hạn như van và công tắc, thực hiện các hành động như bật hoặc tắt hoặc điều chỉnh hệ thống hoạt động. Bộ truyền động cung cấp nhiều chức năng khác nhau, chẳng hạn như dịch vụ van bật/ tắt, định vị tỷ lệ phần trăm mở, điều chỉnh để kiểm soát các thay đổi về điều kiện dòng chảy, tắt khẩn cấp (ESD). Để kích hoạt thiết bị truyền động, lệnh ghi kỹ thuật số được cấp cho thiết bị truyền động. (Jenkins, T., 2015).

#### Kiểm soát việc ra vào nhà

Năm 2010, công nghệ truy cập vào ngôi nhà thông minh thường được sử dụng cho các cửa ra vào công cộng. Hệ thống này thường sử dụng cơ sở dữ liệu với các thuộc tính nhận dạng những người có quyền truy cập. Khi một người đang tiếp cận hệ thống kiểm soát truy cập, các thuộc tính nhận dạng của người đó được thu thập ngay lập tức và so sánh với cơ sở dữ liệu. Nếu nó khớp với dữ liệu cơ sở dữ liệu, quyền truy cập được cho phép, nếu không, quyền truy cập bị từ chối. Đối với một hệ thống phân tán rộng, sẽ sử dụng các dịch vụ đám mây để thu thập và xử lý dữ liệu của người muốn truy cập. Một số sử dụng thẻ từ hoặc thẻ nhận dạng, số khác sử dụng hệ thống nhận dạng khuôn mặt, vân tay và RFID. (A. Yang, C. Zhang, Y. Chen, Y. Zhuansun và H. Liu, 2020)

Ví dụ trong một triển khai, thẻ RFID và đầu đọc RFID đã được sử dụng. Những người được ủy quyền đều có thẻ RFID. Người này quét thẻ qua đầu đọc RFID đặt gần cửa. ID được quét và gửi qua internet đến hệ thống đám mây. Hệ thống đã đăng ID lên dịch vụ kiểm soát để so sánh ID đã quét với các ID được ủy quyền trong cơ sở dữ liệu. (Manzini, E., & Vezzoli, C., 2GG3).

### Các thành phần chính

Cảm biến để thu thập dữ liệu bên trong và bên ngoài ngôi nhà và đo các điều kiện trong nhà. Các cảm biến này được kết nối với chính ngôi nhà và với các thiết bị gắn liền trong nhà. Những cảm biến này không phải là cảm biến IoT, được gắn vào các thiết bị gia dụng. Dữ liệu của cảm biến được thu thập và liên tục chuyển qua mạng cục bộ đến máy chủ của nhà thông minh. (Pandey, S., 2GiS).

Bộ xử lý để thực hiện các hành động cục bộ và tích hợp. Nó cũng có thể được kết nối với đám mây cho các ứng dụng yêu cầu tài nguyên mở rộng. Dữ liệu của cảm biến sau đó được xử lý bởi các quy trình của máy chủ cục bộ. (Roos, G., 2Gi6).

Một tập hợp các phần mềm được đóng gói dưới dạng API, cho phép các ứng dụng bên ngoài thực thi nó và truyền các tham số đã được xác định trước. Một API như vậy có thể xử lý dữ liệu cảm biến hoặc quản lý các hành động cần thiết.

Bộ truyền động cung cấp và thực hiện các lệnh trong máy chủ hoặc các thiết bị điều khiển khác. Nó chuyển hoạt động bắt buộc sang cú pháp lệnh mà thiết bị có thể thực thi. Trong quá trình xử lý dữ liệu của cảm biến đã nhận, nó có nhiệm vụ kiểm tra xem các quy tắc đúng hoặc sai và khởi chạy một lệnh tới bộ xử lý thiết bị thích hợp. (Ryan, A., 2Gi4).

Cơ sở dữ liệu lưu trữ các thông tin thu thập từ các cảm biến và các dịch vụ đám mây, nó được sử dụng để phân tích, trình bày và hiển thị dữ liệu. Dữ liệu đã xử lý được lưu trong cơ sở dữ liệu để sử dụng trong tương lai. (Ryan, W., Stolterman, E., Jung, H., Siegel, M., Thompson, T., & Hazlewood,WR., 2GG9).

## Tổng quan về Internet vạn vật

Mô hình Internet of things (IoT) đề cập đến các đối tượng thiết bị được kết nối với internet. Các thiết bị như cảm biến và thiết bị truyền động được trang bị giao diện, bộ xử lý, bộ nhớ và các phần mềm. Nó cho phép tích hợp các đối tượng vào internet, thiết lập sự tương tác giữa con người và thiết bị, giữa các thiết bị với nhau. Công nghệ quan trọng của IoT bao gồm nhận dạng tần số vô tuyến (RFID), công nghệ cảm biến và công nghệ thông minh. RFID là nền tảng và cốt lõi của việc xây dựng IoT. Khả năng xử lý và giao tiếp cùng với các thuật toán của nó cho phép tích hợp nhiều thành phần khác nhau để hoạt động như một thể thống nhất, đồng thời cũng cho phép dễ dàng bổ sung và loại bỏ các thành phần, việc này làm cho IoT trở nên mạnh mẽ và linh hoạt để tiếp nhận các thay đổi. Để giảm thiểu việc sử dụng băng thông, nó đang sử dụng JSON, một phiên bản nhẹ gọn của XML, cho các thành phần và tin nhắn ngoài hệ thống. (Sayar, D. & Er, Ö., 2GiS).

## Điện toán đám mây và đóng góp của nó cho IoT và nhà thông minh

Điện toán đám mây là một nhóm tài nguyên máy tính được chia sẻ sẵn sàng cung cấp nhiều loại dịch vụ điện toán ở các cấp độ khác nhau, từ cơ sở hạ tầng đến các dịch vụ ứng dụng phức tạp nhất, dễ dàng phân bổ và phát hành hoặc tương tác với nhà cung cấp dịch vụ. Trên thực tế, nó quản lý tài nguyên máy tính, lưu trữ và truyền thông được nhiều người dùng chia sẻ trong một môi trường ảo hóa và cô lập. (MR Alam, MBI Reaz và MAM Ali, 2018).

IoT và nhà thông minh có thể tận dụng được các lợi ích từ các tài nguyên và chức năng rộng lớn của đám mây để bù đắp hạn chế của nó trong lưu trữ, xử lý, giao tiếp, hỗ trợ theo nhu cầu, sao lưu và phục hồi. Ví dụ: đám mây có thể hỗ trợ quản lý, dịch vụ IoT và thực thi các ứng dụng bổ sung bằng cách sử dụng dữ liệu do nó tạo ra. Nhà thông minh có thể được cô đọng, chỉ tập trung vào các chức năng cơ bản và quan trọng, do đó, giảm thiểu tài nguyên cục bộ do dựa vào các khả năng tài nguyên đám mây. Nhà thông minh và IoT sẽ tập trung vào thu thập dữ liệu, xử lý cơ bản và truyền thông tin lên đám mây để xử lý tiếp. Với các thách thức bảo mật, đám mây bảo mật cao với dữ liệu riêng tư và các dữ liệu khác sẽ công khai. (A. Bassi và G. Horn, Internet of things năm 2020).

IoT, nhà thông minh và điện toán đám mây không chỉ là sự hợp nhất của các công nghệ. Đúng hơn, là sự cân bằng giữa tính toán cục bộ và tập trung cùng với việc tối ưu hóa việc sử dụng tài nguyên. Một tác vụ điện toán có thể được thực hiện trên IoT và các thiết bị gia đình thông minh hoặc được thuê ngoài trên đám mây. Việc tính toán phụ thuộc vào sự cân bằng tổng chi phí, tính khả dụng của dữ liệu, mức độ phụ thuộc của dữ liệu, lưu lượng vận chuyển dữ liệu, mức độ phụ thuộc vào truyền thông và các bảo mật. Một mặt, mô hình điện toán liên quan đến ba thành phần là đám mây, IoT và nhà thông minh sẽ giảm thiểu chi phí của toàn bộ hệ thống, thường tập trung hơn vào việc giảm tài nguyên trong ngôi nhà. (Verbeek, P.-P., 2015).

Một số ví dụ về các dịch vụ chăm sóc sức khỏe được cung cấp bởi tích hợp đám mây và IoT: quản lý thông tin đúng cách, chia sẻ hồ sơ chăm sóc sức khỏe điện tử cho phép các dịch vụ y tế chất lượng cao; quản lý dữ liệu cảm biến chăm sóc sức khỏe, làm cho thiết bị di động phù hợp để cung cấp dữ liệu y tế, bảo mật quyền riêng tư và độ tin cậy bằng cách nâng cao bảo mật dữ liệu y tế, tính khả dụng của dịch vụ và dự phòng, các dịch vụ hỗ trợ sinh hoạt thời gian thực và thực thi trên đám mây các dịch vụ y tế dựa trên truyền thông đa phương tiện. (Verbeek,P., 2016).

Xử lý sự kiện tập trung, một hệ thống dựa trên quy tắc

Nhà thông minh và IoT rất phong phú với các cảm biến, tạo ra luồng dữ liệu lớn dưới dạng tin nhắn hoặc sự kiện. Xử lý dữ liệu này vượt quá khả năng của con người. Do đó, các hệ thống xử lý sự kiện đã được phát triển và sử dụng để phản hồi nhanh hơn với các sự kiện đã phân loại. Trong phần này, tập trung vào các hệ thống quản lý quy tắc gắn liền với các sự kiện để thực hiện những thay đổi hệ thống khi sự kiện xảy ra. Người dùng có thể xác định quy tắc kích hoạt sự kiện và kiểm soát việc cung cấp dịch vụ thích hợp không. Quy tắc bao gồm các điều kiện của sự kiện, mẫu sự kiện và thông tin liên quan đến tương quan có thể được kết hợp để tạo mô hình cho các tình huống phức tạp. Nó đã được thực hiện trong một ngôi nhà thông minh điển hình và đã chứng minh sự phù hợp của nó đối với một hệ thống hướng đến dịch vụ. (I. Androutsopoulos, J. Koutsias, KV Chandrinos, G. Paliouras và CD Spyropoulos, 2019).

Hệ thống có thể xử lý một lượng lớn sự kiện, thực thi các chức năng giám sát, điều hướng và tối ưu hóa các quy trình với thời gian thực. Nó phát hiện và phân tích các điểm bất thường hoặc ngoại lệ và tạo ra các phản ứng chủ động/ thích ứng, chẳng hạn như cảnh báo và ngăn chặn các hành động thiệt hại. Các tình huống được mô hình hóa bởi giao diện thân thiện với người dùng cho các quy tắc do sự kiện kích hoạt. Khi cần thiết, nó sẽ chia chúng thành các yếu tố đơn giản, dễ hiểu. Mô hình đề xuất có thể được tích hợp liền mạch vào nền tảng xử lý sự kiện phân tán và hướng dịch vụ. (Apple, 2018).

Quá trình đánh giá được kích hoạt bởi các sự kiện cung cấp trạng thái mới nhất và thông tin từ môi trường liên quan. Kết quả là một biểu đồ quyết định đại diện cho các quy tắc. Nó có thể chia nhỏ các tình huống phức tạp thành các điều kiện đơn giản và kết hợp chúng với nhau, tạo ra các điều kiện phức tạp. Đầu ra là một sự kiện phản hồi được đưa ra khi một quy tắc được kích hoạt. Các sự kiện đã kích hoạt có thể được sử dụng làm đầu vào cho các quy tắc khác để đánh giá thêm.

Hành động tạo ra các sự kiện phản hồi, kích hoạt các hoạt động phản hồi. Các mẫu sự kiện có thể khớp với chuỗi sự kiện theo thời gian, cho phép mô tả các tình huống có liên quan đến sự xuất hiện của các sự kiện. Ví dụ, khi cửa mở quá lâu. (R. Petrolo, V. Loscrì và N. Mitton, 2017).

Những thách thức được biết đến với mô hình này: cấu trúc cho các sự kiện và dữ liệu đã xử lý, cấu hình dịch vụ và bộ điều hợp cho các bước xử lý, bao gồm các thông số đầu vào và đầu ra của chúng, giao diện với hệ thống bên ngoài để cảm nhận dữ liệu và phản hồi bằng cách thực hiện các giao dịch, cấu trúc cho các sự kiện và dữ liệu đã xử lý, biến đổi dữ liệu, phân tích dữ liệu và tính bền bỉ. Nó cho phép mô hình hóa các sự kiện nào sẽ được xử lý bởi dịch vụ quy tắc và cách các sự kiện phản hồi sẽ được chuyển tiếp đến các dịch vụ sự kiện khác. Quá trình này rất đơn giản: dữ liệu được thu thập và nhận từ các bộ điều hợp chuyển tiếp các sự kiện tới các dịch vụ sự kiện sử dụng chúng. (ZB Celik, E. Fernandes, E. Pauley, G. Tan và P. McDaniel, 2019).

### Ngôn ngữ xử lý sự kiện

Xử lý sự kiện liên quan đến việc nắm bắt và quản lý các sự kiện được xác định trước theo thời gian thực. Nó bắt đầu từ việc quản lý các thực thể của các sự kiện ngay từ khi sự kiện xảy ra, thậm chí xác định, thu thập dữ liệu, liên kết quy trình và kích hoạt hành động phản hồi. Để cho phép xử lý sự kiện nhanh chóng và linh hoạt, một ngôn ngữ xử lý sự kiện được sử dụng, cho phép cấu hình nhanh các tài nguyên cần thiết để xử lý chuỗi hoạt động dự kiến cho mỗi loại sự kiện. Nó bao gồm hai mô-đun, ESP và CEP. ESP xử lý hiệu quả sự kiện, phân tích nó và chọn sự kiện thích hợp. CEP xử lý các sự kiện tổng hợp. Ngôn ngữ sự kiện mô tả các kiểu sự kiện phức tạp được áp dụng trên bản ghi sự kiện. (N. Panwar, S. Sharma, S. Mehrotra, L. Krzywiecki và N. Venkatasubramanian, 2019).

### Khám phá lại quy trình làm việc từ các sự kiện

Trong một số trường hợp, các quy tắc liên quan đến sự khác biệt trong chuỗi sự kiện trong quy trình làm việc. Trong những trường hợp như vậy, bắt buộc phải hiểu chính xác quy trình làm việc và các sự kiện liên quan. Để khắc phục điều này, đề xuất quy trình thiết kế ngược để tự động xem lại quy trình công việc từ nhật ký sự kiện được thu thập theo thời gian, giả sử các sự kiện này được sắp xếp theo thứ tự và mỗi sự kiện đề cập đến một tác vụ đang được thực thi cho một trường hợp. Quá trình xem lại có thể được sử dụng để xác nhận trình tự quy trình làm việc bằng cách đo lường sự khác biệt giữa các mô hình mô tả và các lần thực thi quy trình thực tế. Quá trình xem lại bao gồm ba bước sau: (1) xây dựng bảng phụ thuộc/ tần suất. (2) Quy nạp đồ thị phụ thuộc/ tần số. (3) Tạo lưới WF từ đồ thị D/ F. (S. Zhihua, 2016).

## Nhà thông minh từ sau năm 2010

Trong phần này sẽ tập trung vào sự tích hợp của nhà thông minh, IoT và điện toán đám mây để xác định một mô hình điện toán mới. Có thể tìm thấy trong phần tài liệu các cuộc khảo sát và nghiên cứu về nhà thông minh, IoT và điện toán đám mây, các thuộc tính, tính năng, công nghệ và nhược điểm của chúng. (KR Sollins, 2019).

Vào năm 2011, mô tả các thành phần chính của ngôi nhà thông minh tiên tiến và khả năng kết nối giữa chúng. Ở khối bên trái, môi trường nhà thông minh, có thể thấy các thiết bị điển hình được kết nối với mạng cục bộ (LAN). Điều này cho phép giao tiếp giữa các thiết bị và môi trường bên ngoài. Kết nối với mạng LAN là một máy chủ và cơ sở dữ liệu của nó. Máy chủ kiểm soát các thiết bị, ghi nhật ký hoạt động của nó, cung cấp báo cáo, trả lời các truy vấn và thực hiện các lệnh thích hợp. Đối với các tác vụ toàn diện hoặc phổ biến hơn, máy chủ nhà thông minh, chuyển dữ liệu lên đám mây và kích hoạt từ xa các tác vụ bằng cách sử dụng API, quy trình giao diện lập trình ứng dụng. (Y. Meng, W. Zhang, H. Zhu và XS Shen, 2018).

Năm 2012, để chứng minh những lợi ích của ngôi nhà thông minh tiên tiến, sử dụng RSA, một thuật toán mật mã bất đối xứng mạnh mẽ, tạo ra một khóa công khai và riêng tư để mã hóa/ giải mã các tin nhắn. Sử dụng khóa công khai, mọi người đều có thể mã hóa một tin nhắn, nhưng chỉ những người giữ khóa riêng tư mới có thể giải mã tin nhắn đã gửi. Việc tạo ra các khóa và mã hóa/ giải mã các thông điệp, bao gồm các tính toán mở rộng, đòi hỏi không gian bộ nhớ và sức mạnh xử lý đáng kể. Do đó, nó thường được xử lý trên các máy tính mạnh được xây dựng để đáp ứng các tài nguyên cần thiết. Tuy nhiên, do tài nguyên có hạn, việc chạy RSA trong một thiết bị IoT gần như là không thể, và do đó, tạo ra một lỗ hổng về bảo mật trên Internet. Giải quyết vấn đề bảo mật bằng cách kết hợp sức mạnh của các bộ xử lý nhà thông minh cục bộ để tính toán một số phép tính RSA và chuyển tiếp các tác vụ điện toán phức tạp hơn lên trên đám mây xử lý. Sau đó, kết quả sẽ được chuyển trở lại cảm biến IoT để được biên dịch và lắp ráp lại với nhau, nhằm tạo ra mã giải mã/mã hóa RSA. Ví dụ minh họa luồng dữ liệu giữa các thành phần nhà thông minh tiên tiến. Trong đó, mỗi thành phần thực hiện ngăn xếp hoạt động của riêng mình để tạo ra đầu ra duy nhất của nó. Tuy nhiên, trong trường hợp các nhiệm vụ phức tạp và diễn ra trong thời gian dài, nó sẽ chia nhiệm vụ thành các tác vụ con để thực thi bởi các thành phần mạnh hơn. Đề cập đến ví dụ RSA, thiết bị IoT bắt đầu yêu cầu tạo khóa mã hóa và gửi một thông báo yêu cầu đến ứng dụng RSA chạy trong máy tính trong ngôi nhà thông minh với p và q là các số nguyên tố, khi p và q được chấp nhận, mã mã hóa được tạo. Trong giai đoạn sau, thiết bị IoT đưa ra yêu cầu mã hóa tin nhắn cho máy tính, sử dụng khóa mã hóa RSA được tạo gần đây. Sau đó, thông điệp được mã hóa sẽ được chuyển trở lại thiết bị IoT để thực hiện thêm. Một kịch bản tương tự có thể xảy ra theo hướng ngược lại, khi một thiết bị IoT nhận được thông báo, nó có thể yêu cầu nhà thông minh giải mã nó. (P. Rajiv, R. Raj, và M. Chandra, 2016).

Năm 2014, các kịch bản RSA mô tả việc sử dụng sức mạnh của điện toán đám mây, khả năng tính toán bảo mật của ngôi nhà thông minh và cuối cùng là sức mạnh của thiết bị IoT. Nó chứng minh rằng nếu không có sự hợp tác tự động này, RSA sẽ không thể được thực thi ở cấp độ IoT. (E. Fernandes, J. Jung và A. Prakash, 2016), (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

Vào năm 2015, một ví dụ thực tế là một số thiết bị tách rời, chẳng hạn như lò nướng, nồi nấu và chảo trên bếp ga đang hoạt động. Người dùng rời khỏi nhà mà không tắt các thiết bị này. Trong trường hợp này các IoT có liên quan đã được điều chỉnh để tự động tắt dựa trên các quy tắc được xác định trước. Nếu không, ngôi nhà thông minh nhận ra nhà không có ai ở nhà bằng cách xác định (cửa nhà được mở và sau đó khóa, nhà để xe được mở, ô tô rời đi, cổng chính được mở và sau đó đóng lại) và sẽ tắt tất cả các thiết bị đang hoạt động được phân loại là rủi ro trong trường hợp vắng mặt và nó sẽ gửi một tin nhắn đến danh sách gửi thư được xác định trong trường này. (A. Jacobsson, M. Boldt và B. Carlsson, 2016), (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

## Các khía cạnh thực tế và cân nhắc triển khai cho IoT và nhà thông minh

Nhà thông minh có ba thành phần: phần cứng, phần mềm và giao thức truyền thông. Nó có nhiều ứng dụng kỹ thuật số cho người dùng. Một số lĩnh vực tự động hóa ngôi nhà đã kích hoạt kết nối IoT, chẳng hạn như: điều khiển ánh sáng, làm vườn, an toàn và an ninh, chất lượng không khí, giám sát chất lượng nước, trợ lý giọng nói, công tắc, khóa, đồng hồ đo năng lượng và nước. (S. Madakam và H. Date, 2016).

Các thành phần nhà thông minh tiên tiến bao gồm: cảm biến IoT, cổng, giao thức, phần sụn, điện toán đám mây, cơ sở dữ liệu, phần mềm trung gian và cổng. Đám mây IoT có thể được chia thành nền tảng dưới dạng dịch vụ (PaaS) và cơ sở hạ tầng dưới dạng dịch vụ (IaaS). Trình bày các thành phần chính của ngôi nhà thông minh tiên tiến được đề xuất và kết nối với luồng dữ liệu giữa các thành phần của nó. (S. Madakam và H. Date, (2016)), (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

Ứng dụng nhà thông minh cập nhật cơ sở dữ liệu ngôi nhà trên đám mây để cho phép những người ở xa truy cập và nhận được trạng thái mới nhất của ngôi nhà. Một nền tảng IoT điển hình bao gồm: bảo mật và xác thực thiết bị, quản trị thiết bị, giao thức, thu thập dữ liệu, trực quan hóa, khả năng phân tích, tích hợp với các dịch vụ web khác, khả năng mở rộng, API cho luồng thông tin thời gian thực và thư viện nguồn mở. Cảm biến IoT cho tự động hóa ngôi nhà được biết đến với khả năng cảm biến của chúng, chẳng hạn như: nhiệt độ, độ sáng, mực nước, thành phần không khí, camera giám sát video, giọng nói/ âm thanh, áp suất, độ ẩm, gia tốc kế, hồng ngoại, rung động và siêu âm. Một số cảm biến nhà thông minh được sử dụng phổ biến nhất là cảm biến nhiệt độ, hầu hết là cảm biến kỹ thuật số kết quả cực kỳ chính xác. Ví dụ như cảm biến Lux đo độ sáng. (K. Markantonakis, RN Akram và MG Msgna, 2015).

Cảm biến thành phần không khí được các nhà phát triển sử dụng để đo các thành phần cụ thể trong không khí: giám sát CO, đo mức khí hydro, đo nitơ oxit, mức khí nguy hiểm. Hầu hết chúng đều cần một thời gian nhất định trước khi đưa ra các giá trị chính xác. Máy quay video được sử dụng để giám sát và phân tích, được kết nối tốc độ cao. Nên sử dụng bộ xử lý Raspberry Pi vì mô-đun máy ảnh của nó rất hiệu quả do có đầu nối linh hoạt, được kết nối trực tiếp với bo mạch. (P. Kumar, A. Gurtov, J. Iinatti, M. Ylianttila, và M. Sain, 2016).

Máy dò âm thanh được sử dụng rộng rãi cho mục đích giám sát, phát hiện âm thanh và hành động phù hợp. Một số thậm chí có thể phát hiện mức độ tiếng ồn cực thấp và tinh chỉnh giữa các mức độ tiếng ồn khác nhau.

Cảm biến độ ẩm cảm nhận mức độ ẩm trong không khí cho nhà thông minh. Độ chính xác của nó phụ thuộc vào thiết kế và vị trí cảm biến. Một số cảm biến nhất định như DHT22, được chế tạo để tạo mẫu nhanh, sẽ luôn hoạt động kém hơn khi so sánh với các cảm biến chất lượng cao như HIH6100. (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

Giao thức giao tiếp thông minh trong nhà như: bluetooth, Wi-Fi hoặc GSM. Bluetooth thông minh hoặc giao thức không dây năng lượng thấp với khả năng phân phối lưới và các thuật toán mã hóa dữ liệu. Zigbee là giao thức dựa trên tần số vô tuyến tuần suất thấp được nối mạng cho IoT. Giao thức X10 sử dụng hệ thống dây điện để truyền tín hiệu và điều khiển. Giao tiếp Insteon, không dây và có dây. Z-wave chuyên về tự động hóa ngôi nhà an toàn. UPB, sử dụng đường dây điện hiện có. ANT là một giao thức năng lượng cực thấp để xây dựng các cảm biến công suất thấp với khả năng phân phối lưới cao. Các giao thức được ưu tiên là bluetooth năng lượng thấp, sóng Z, Zigbee và luồng. Việc kết nối cổng bao gồm: kết nối đám mây, các giao thức được hỗ trợ, độ phức tạp tùy chỉnh và hỗ trợ tạo mẫu. (M. Bassoli, V. Bianchi, và I. De Munari, 2018).

Mô-đun: các gói phần mềm, được quản lý trong lúc chạy, định hướng dịch vụ, quản lý sự phụ thuộc giữa các gói, lớp; kiểm soát vòng đời của các gói, lớp dịch vụ; xác định mô hình giao tiếp động giữa các mô-đun khác nhau, các dịch vụ thực tế - đây là lớp ứng dụng. Lớp bảo mật: tùy chọn, tận dụng kiến trúc bảo mật của Java 2 và quản lý quyền từ các mô-đun khác nhau. (GV Vivek và MP Sunil, 2015).

OpenHAB là một khuôn khổ, kết hợp tự động hóa các thiết bị gia đình và cổng kết nối IoT cho ngôi nhà thông minh. Các tính năng của nó: công cụ quy tắc, cơ chế ghi nhật ký và trừu tượng hóa giao diện người dùng.

Việc triển khai blockchain vào mạng gia đình có thể dễ dàng thực hiện với Raspberry Pi. Một lớp bảo mật blockchain giữa các thiết bị và cổng có thể được thực hiện mà không cần phải cải tiến lớn với mã hiện có.

## Ví dụ về nhà thông minh và IoT

Có thể tìm thấy trong các tài liệu và báo cáo thực tế, nhiều triển khai tích hợp khác nhau giữa ba phần chính: nhà thông minh, IoT và điện toán đám mây.

### Phát hiện rò rỉ nước và cách phòng ngừa

Bước đầu tiên là triển khai cảm biến nước dưới mọi nguồn rò rỉ tiềm ẩn hợp lý và cảm biến van nước chính tự động cho toàn bộ ngôi nhà, điều này có nghĩa là ngôi nhà được coi như một IoT.

Trong trường hợp cảm biến nước phát hiện rò rỉ nước, nó sẽ gửi một sự kiện đến trung tâm, sự kiện này sẽ kích hoạt ứng dụng “tắt van”. Sau đó, ứng dụng điều khiển gia đình sẽ gửi lệnh “tắt” đến tất cả các thiết bị IoT được xác định với việc ngừng nước và sau đó gửi lệnh “tắt” đến van nước chính. Thông báo cập nhật được gửi qua hệ thống nhắn tin. Thiết lập này giúp bảo vệ khỏi các trường hợp nguồn nước là từ hệ thống ống nước trong nhà. Cấu hình cơ bản giả định tích hợp thông qua tin nhắn và lệnh giữa nhà thông minh và hệ thống điều khiển IoT. Nó thể hiện sự phụ thuộc và những kết quả có lợi của việc kết hợp nhà thông minh và IoT. (YAN Wenbo, WANG Quanyu, và GAO Zhenwei, 2015).

### Đầu báo khói

Giả sử các ngôi nhà đã có các đầu báo khói nhưng không có cầu nối để gửi dữ liệu từ cảm biến đến trung tâm điều khiển nhà thông minh. Việc kết nối các cảm biến này với ứng dụng nhà thông minh cho phép hệ thống phát hiện khói toàn diện. Mở rộng hơn là để thông báo cho cảm biến thang máy chặn việc sử dụng do tình trạng cháy, thậm chí cho bất kỳ cảm biến IoT nào có thể được kích hoạt do cảnh báo khói được phát hiện. (C Y. Chang, C.-H. Kuo, J.-C. Chen và T.-C. Wang, 2015).

### Quản lý sự cố để kiểm soát các thiết bị gia dụng

Hãy xem xét tình huống rời khỏi nhà trong khi một số thiết bị vẫn đang hoạt động. Trong trường hợp vắng mặt đủ lâu, một số thiết bị có thể quá nóng và sắp bị xì. Để tránh những trường hợp như vậy kết nối tất cả các cảm biến của thiết bị IoT với ứng dụng gia đình, để khi tất cả rời khỏi nhà, nó sẽ tự động điều chỉnh tất cả các cảm biến của thiết bị cho phù hợp, để tránh hư hỏng. Lưu ý rằng chỉ báo nhà trống được tạo bởi ứng dụng Nhà thông minh, trong khi chỉ báo “bật” của thiết bị do IoT tạo ra. Do đó, kịch bản này có thể xảy ra do sự tích hợp giữa nhà thông minh và các hệ thống IoT. (U. Guin, A. Singh, M. Alam, J. Canedo và A. Skjellum, 2018), (C. Lachner và S. Dustdar, 2019).

## Kết luận

Nhiều kỹ thuật IoT đã được cài đặt trong các ngôi nhà thông minh để cải thiện chất lượng cuộc sống. Để thiết kế và triển khai một hệ thống kiểm soát ngôi nhà, bao gồm ba phần: phần cứng, máy chủ có độ bảo mật cao và ứng dụng web. Phần cứng nút IoT được thiết kế để thử nghiệm trong đời thực và nhận thông tin IoT từ bất kỳ thiết bị nào. Một máy chủ được thiết kế và triển khai để kiểm soát các nút IoT trong hệ thống. Cuối cùng, một ứng dụng sử dụng mọi lúc mọi nơi trên điện thoại thông minh hoặc trình duyệt web thông qua liên kết kết nối giao tiếp Wi-Fi đã được xây dựng để điều khiển hệ thống thông minh IoT theo thời gian thực. Ứng dụng này cho phép điều khiển chức năng cả tự động và thủ công, điều này rất linh hoạt cho người dùng. Hệ thống IoT tiên tiến được lắp đặt tại Đại học Tôn Đức Thắng, Việt Nam. Kết quả cho thấy những lợi ích tiềm năng rõ ràng cho một ngôi nhà thông minh, bao gồm bảo mật mạnh mẽ và chi phí thấp. Trên hết, nghiên cứu này nhằm chứng minh tiềm năng to lớn mà tất cả công nghệ kỹ thuật số mang lại cho ngôi nhà thông minh.

# Public_002

# Học phần

## Bộ Môn Hệ Thống Thông Tin

### Cơ sở dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần: Học phần này trang bị cho người học những kiến thức cơ bản về cơ sở dữ liệu và kiến thức chuyên sâu về mô hình dữ liệu quan hệ: quan hệ, phụ thuộc hàm, các ràng buộc trên quan hệ, siêu khóa, khóa chính, khóa dự tuyển, khóa ngoại, bao đóng của tập phụ thuộc hàm, bao đóng của tập thuộc tính, phủ tối tiểu của tập phụ thuộc hàm, thuật toán tìm bao đóng của tập thuộc tính, thuật toán xác định khóa, các dạng chuẩn và tính chất tương ứng. Trang bị cho người học kiến thức về mô hình thực thể kết hợp để thiết kế CSDL.

### Hệ quản trị cơ sở dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học về nguyên lý của DBMS. Cách sử dụng ngôn ngữ lập trình PL/SQL, các định nghĩa và ứng dụng của thủ tục nội tại, bẫy lỗi, chỉ mục, lập trình CSDL, các quản lý truy cập trong DBMS, các nguyên lý quản lý giao tác, quản lý truy xuất cạnh tranh, phục hồi sau sự cố.

### Phân tích thiết kế HTTT

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học các kiến thức cơ bản về hệ thống thông tin, các thành phần của một hệ thống thông tin. Học phần cung cấp cho người học các kỹ thuật thu thập thông tin, phân tích hoạt động của hệ thống thông tin; các khái niệm có liên quan, ý nghĩa và tầm quan trọng của chúng. Về hoạt động thiết kế, học phần cung cấp cho người học kiến thức và kỹ năng trong việc xác định cấu trúc, các thành phần cần thiết để xây dựng và triển khai một hệ thống thông tin.

### Khai phá dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học những kiến thức cơ bản về các khái niệm, thuật toán và ứng dụng của khai phá dữ liệu. Ngoài ra, người học còn có cơ hội trải nghiệm các thư viện, công cụ mã nguồn mở để cài đặt và thử nghiệm thuật toán khai phá dữ liệu. Các chủ đề được đề cập đến trong học phần bao gồm: các khái niệm cơ bản, các ứng dụng và quá trình khai phá dữ liệu, các vấn đề liên quan đến quá trình tiền xử lý dữ liệu, các thuật toán khai phá luật kết hợp (Apriori, FP-Growth, …), các thuật toán phân loại (k-NN, cây quyết định, Naive Bayes, ...), các thuật toán gom cụm (gom cụm phân hoạch k-means, gom cụm phân cấp gộp AGNES, gom cụm dựa trên mật độ DBSCAN, …), các thuật toán phân tích ngoại biên (dựa trên thống kê, dựa trên xấp xỉ, dựa trên gom cụm, dựa trên phân loại), và các độ đo và phương pháp đánh giá các thuật toán khai phá dữ liệu.

### Cơ sở dữ liệu nâng cao

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này giới thiệu những kiến thức tổng quát về một số loại cơ sở dữ liệu (CSDL) mở rộng: CSDL hướng đối tượng, CSDL bán cấu trúc XML, CSDL NoSQL, CSDL phân cấp (blockchain)... Học phần tập trung vào Big Data và CSDL NoSQL, so sánh CSDL quan hệ truyền thống với CSDL NoSQL, phân loại các loại CSDL NoSQL (key-value, document-based, column-based, graph), cài đặt một CSDL NoSQL cụ thể (VD: MongoDB, Cassandra, CouchDB...), thực hiện tạo lập, lưu trữ, quản lý và thao tác dữ liệu trên cơ sở dữ liệu này.

### Phân tích dữ liệu lớn

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp cho sinh viên kiến thức về kiến trúc của các hệ thống và các công cụ phục vụ cho hoạt động phân tích dữ liệu lớn. Với mỗi công cụ, môn học giới thiệu các kiến thức cơ bản và nâng cao cũng như phương thức tối ưu hóa hiệu suất hệ thống sử dụng công cụ này. Cùng với các bài tập lập trình, môn học hướng đến mục tiêu giúp người học có thể hình thành ý tưởng, thiết kế và hiện thực hóa hoạt động phân tích dữ liệu trong các hệ thống dữ liệu lớn.

### Bảo mật cơ sở dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học những kiến thức nền tảng về cả lý thuyết lẫn thực hành để có thể hiểu được những cơ chế, mô hình và kỹ thuật bảo mật cơ sở dữ liệu, cụ thể: các kiểu tấn công, các cấp độ bảo mật và các phương pháp bảo vệ tương ứng; bảo mật cơ sở dữ liệu bằng phương pháp kiểm soát truy cập (Access Control) với các mô hình DAC, MAC, RBAC; bảo mật bằng phương pháp mã hóa dữ liệu; vấn đề kiểm định (Audit); cách thức hiện thực các mô hình và các công nghệ hỗ trợ bảo mật trong các hệ quản trị cơ sở dữ liệu; nguyên lý thiết kế và cài đặt các cơ chế bảo mật; các mô hình bảo vệ tính toàn vẹn dữ liệu

### Thương mại điện tử

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần giới thiệu về thương mại điện tử và cung cấp cho người học ba mảng kiến thức chủ đạo: các mô hình kinh doanh thương mại điện tử, các hoạt động marketing cho thương mại điện tử, và các vấn đề chủ đạo khi thiết kế, xây dựng, và vận hành nền tảng thương mại điện tử.

### Học máy

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học giới thiệu cho sinh viên về lĩnh vực học máy và các giải thuật học máy phổ biến. Sinh viên sẽ thực hiện các bài tập lập trình bằng ngôn ngữ lập trình Python, và phân tích, đánh giá các giải thuật này. Sinh viên cũng sẽ thực tập hình thành ý tưởng, thiết kế và hiện thực hóa một hệ thống học máy đơn giản trong đồ án môn học xuyên suốt học kỳ.

### Chuyên đề 2 (Hệ hỗ trợ ra quyết định)

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp cho sinh viên các kiến thức về tiến trình ra quyết định, cấu trúc và các thành phần của hệ hỗ trợ ra quyết định, cách quản lý và khai thác dữ liệu, các mô hình được sử dụng trong hệ hỗ trợ ra quyết định… Ngoài ra, sinh viên được trang bị kỹ năng sử dụng các công cụ để giải quyết các bài toán ra quyết định, lưu trữ và khai thác dữ liệu hiệu quả. Sau khi học xong học phần này, sinh viên có khả năng phân tích, thiết kế và xây dựng các hệ hỗ trợ ra quyết định trên nền tảng các hệ thống thông tin quản lý.

### Kho dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên những kiến thức cơ bản về kho dữ liệu. Trong khóa học này, người học sẽ học các khái niệm cơ bản về kho dữ liệu, kiến trúc kho dữ liệu và các mô hình đa chiều. Họ sẽ được thực hành về thiết kế kho dữ liệu và sử dụng các công cụ phổ biến tạo các luồng công việc tích hợp dữ liệu (data integration workflows). Bên cạnh đó, những người học cũng sẽ học cách sử dụng các phần mở rộng của SQL được hỗ trợ bởi các hệ quản trị cơ sở dữ liệu quan hệ để trả lời các câu hỏi phân tích trong kinh doanh.

### Truy tìm thông tin

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp kiến thức nền tảng giúp người học hiểu được cách làm việc cũng như cách xây dựng một hệ thống truy tìm (tìm kiếm) thông tin, đặc biệt là thông tin ở dạng văn bản. Cụ thể, sau khi hoàn thành học phần, người học sẽ trình bày được kiến trúc tổng quát của một hệ thống truy tìm thông tin, quá trình tiền xử lý và xây dựng chỉ mục tài liệu. Đặt biệt, người học sẽ có cơ hội được cài đặt các mô hình truy tìm thông tin quan trọng (như mô hình không gian vector, mô hình xác suất, mô hình ngôn ngữ) và các kỹ thuật phản hồi và mở rộng truy vấn. Người học cũng sẽ được trang bị kiến thức về phương pháp đánh giá thực nghiệm một hệ thống truy tìm thông tin để có thể đánh giá và so sánh các thuật toán, mô hình. Ngoài ra, cách hoạt động của một hệ thống tìm kiếm thông tin trên web (web search engine) cũng sẽ được trình bày.

### Nhập môn dữ liệu lớn

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này thuộc nhóm môn học cơ sở ngành, nhằm cung cấp cho người học các kiến thức tổng quan về cơ sở dữ liệu lớn, những ứng dụng của cở sở dữ liệu lớn. Ngoài ra, người học còn được cung cấp những kiến thức về các kỹ thuật cơ bản trong lưu trữ và xử lý, phân tích cơ sở dữ liệu lớn. Về mặt kỹ năng, người học được trang bị khả năng sử dụng một số công cụ phân tích cơ sở dữ liệu lớn thông dụng. Bên cạnh đó, người học cũng được trang bị một số kỹ năng mềm bao gồm: kỹ năng tìm kiếm, chọn lọc và tổng hợp tài liệu, kỹ năng viết và trình bày báo cáo, kỹ năng làm việc nhóm.

## Bộ Môn Mạng Máy Tính

### Kiến trúc máy tính và hợp ngữ

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp cho người học những kiến thức liên quan tới kiến trúc của máy tính cũng như tập lệnh của vi xử lý và lập trình hợp ngữ cho vi xử lý, cụ thể:

### Cung cấp kiến thức về các hệ số đếm dùng trong máy tính

Kiến trúc tổng quát của bộ xử lý, hiệu suất máy tính, các loại bộ nhớ, các loại xuất nhập, ngắt

Cung cấp kiến thức về các cách biểu diễn dữ liệu trong máy tính

Giới thiệu kiến trúc một số họ vi xử lý của Intel : thanh ghi của họ x86, x86-64

Cung cấp các kiến thức về việc sử dụng tập lệnh x86, x86-64

Cung cấp kiến thức về lập trình hợp ngữ trên linux x64, các lời gọi hệ thống, gọi hợp ngữ từ ngôn ngữ cấp cao.

### Hệ điều hành

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học những kiến thức cơ bản về Hệ điều hành, bao gồm: Mô hình tổng quát, cấu trúc, chức năng, các thành phần cơ bản của hệ điều hành. Các nguyên lý cơ bản để xây dựng Hệ điều hành. Tìm hiểu cấu trúc và việc ứng dụng các nguyên lý cơ bản trong các hệ điều hành cụ thể. Tìm hiểu và mô phỏng điều khiển thiết bị của Hệ điều hành thông qua lập trình hệ thống.

### Mạng máy tính căn bản

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung các các khái niệm cơ bản trong mạng máy tính, đặc điểm cơ bản của các loại mạng; kiến thức về nguyên lý hoạt động của các thiết bị mạng, các kỹ thuật phổ biến triển khai trên hạ tầng mạng, các giao thức phổ biến hoạt động trong hệ thống mạng; các kiến thức về thiết kế, cấu hình và vận hành hệ thống mạng đơn giản.

### Mật mã học

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp các khái niệm cơ bản về mã hóa thông tin, giới thiệu các phương pháp mã hóa, giải mã và ứng dụng của chúng trong bảo mật thông tin, các cơ chế và nghi thức bảo mật: Xác thực, chữ ký số. Ngoài ra, học phần này cũng cung cấp khả năng vận dụng kiến thức về mã hóa thông tin đã học để giải quyết một số bài toán bảo mật trong thực tế. Bên cạnh đó, sinh viên được làm việc trong các nhóm và thuyết trình các vấn đề nâng cao sử dụng các phương tiện trình chiếu.

### Mạng máy tính nâng cao

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về công nghệ định tuyến, phân loại và đặc điểm của các giao thức định tuyến; cung cấp kiến thức về cấu hình một số giao thức phổ biến; cung cấp kiến thức về VLAN, ACL, NAT, các công nghệ WAN.

### An toàn thông tin

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên chuyên ngành Công nghệ Thông tin kiến thức cơ bản về An toàn thông tin trên máy tính như CIA, An toàn trên phần mềm, An toàn trên HĐH, An toàn trên Cơ sở dữ liệu; các vấn đề về An toàn trên mạng máy tính như Malware, Firewall, IDS/IPS; các vấn đề về mã hoá thông tin, các thuật toán hash, MAC, RSA, quản lý khóa trong các giao thức truyền trên mạng.

### Tấn công mạng và phòng thủ

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên chuyên ngành Công nghệ Thông tin kiến thức cơ bản về kỹ thuật Tấn công Mạng và Bảo vệ hệ thống mạng trước các loại tấn công; các vấn đề về mã hoá thông tin, các thuật toán hash, MAC, RSA, quản lý khóa trong các giao thức truyền trên mạng.

### Thiết kế mạng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về những đặc điểm cơ bản khi thiết kế một hệ thống mạng;kiến thức về quy trình các giai đoạn thiết kế mạng, phương pháp thiết kế theo mô hình phân lớp; kiến thức về thiết kế mạng LAN, WLAN, WAN; và thiết kế mạng đảm bảo tính bảo mật, tính sẵn sàng của hệ thống.

### An ninh mạng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về các kỹ thuật an ninh mạng; kiến thức về các kỹ thuật và công cụ phân tích các lỗ hổng trong hệ thống mạng; các kỹ thuật tấn công mạng; các giao thức bảo mật và kỹ thuật bảo mật ứng dụng mạng; các kỹ thuật bảo mật hạ tầng mạng như Firewall, IDS/IPS.

### Hệ thống nhúng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp cho người học những kiến thức liên quan tới hệ thống nhúng, bao gồm: Những khái niệm tổng quan về mô hình hệ thống nhúng, tính chất, các ứng dụng của hệ thống nhúng; Các thành phần cơ bản của một hệ thống nhúng; Các phương pháp thiết kế hệ thống nhúng; Vi điều khiển ARM; Tập lệnh của vi điều khiển ARM; Kiến thức về nguyên tắc lập trình nhúng, các công cụ lập trình phần mềm nhúng.

### Lý thuyết thông tin

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp cho người học những kiến thức cơ bản của lý thuyết thông tin, bao gồm: Độ đo lượng tin (Measure of Information); Sinh mã tách được (Decypherable Coding); Kênh truyền tin rời rạc không nhớ (Discrete Memoryless Channel); Sửa lỗi kênh truyền (Error Correcting Coding).

### Hệ thống giám sát an toàn mạng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về các thành phần trong hệ thống giám sát mạng; kiến thức về phương pháp tổ chức triển khai một hệ thống giám sát, các giao thức dùng trong giám sát mạng; kiến thức về các công cụ trong giám sát, các hình thức cảnh báo khi hệ thống mạng có sự cố xảy ra.

### An toàn mạng không dây và di động

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp cho người học những kiến thức liên quan tới: kênh truyền thông không dây, kiến trúc và các giao thức mạng không dây, tấn công trên mạng không dây, các kỹ thuật bảo vệ.

### Quản trị trên môi trường cloud

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về công nghệ cloud và triển khai cài đặt, cấu hình, quản trị trên môi trường cloud. Trong đó bao gồm việc triển khai các máy ảo, cài đặt các ứng dụng và dịch vụ trên cloud, quản trị tài nguyên, giám sát các hoạt động của hệ thống trên môi trường cloud.

### Pháp lý kỹ thuật số

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên những nguyên lý và kỹ thuật trong lĩnh vực pháp lý số. Sinh viên sẽ được cung cấp những kiến thức và qui trình thu thập chứng cứ trên Linux và Windows; kiến thức xây dựng và phân tích được các báo cáo pháp lý số.

### Chuyên đề 3 (Internet kết nối vạn vật - IoT)

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp cho người học những kiến thức liên quan tới Hệ thống IoT, cụ thể là: các khái niệm liên quan và kiến trúc hệ thống IoT, kiến trúc hệ thống IoT, chồng giao thức cho IoT, các thành phần hardware, software, một số platform cho hệ thống IoT, công nghệ RFID, sensor...

### Chuyên đề doanh nghiệp (CNTT)

Cấu trúc học phần: 2(2:0:4)

Mô tả học phần:

Môn học này trang bị cho sinh viên các kiến thức cập nhật thực tế về các công nghệ mới trong lĩnh vực công nghệ thông tin, cũng như một số kiến thức về kỹ năng mềm, kỹ năng làm việc trong môi trường doanh nghiệp, dưới hình thức chuyên đề khách mời – là những chuyên gia có kinh nghiệm làm việc trong các doanh nghiệp.

### Thực tập tốt nghiệp (CNTT)

Cấu trúc học phần: 2(2:0:4)

Mô tả học phần:

Môn học này trang bị cho sinh viên các kiến thức thực tế liên quan tới môi trường làm việc tại doanh nghiệp, sử dụng kiến thức đã học trong việc tham gia các dự án thực tế tại doanh nghiệp, hoặc tiếp thu một số công nghệ mới và vận dụng chúng trong việc triển khai, vận hành hệ thống công nghệ thông tin. Đồng thời qua việc thực tập sinh viên có thể phát triển tư duy trong tương lai với vai trò quản lý.

### Lãnh đạo và kinh doanh trong kỹ thuật (CNTT)

Cấu trúc học phần: 0(0:0:0)

Mô tả học phần:

Học phần giúp sinh viên hình thành tư duy sáng tạo và truyền đạt, trang bị kỹ năng xây dựng, lãnh đạo tổ chức, quản lý dự án. Trang bị cho sinh viên kỹ năng làm việc nhóm, kỹ năng phát triển ý tưởng mới. Cung cấp các kiến thức về việc thành lập, quản lý doanh nghiệp và tiếp thị sản phẩm, quản lý sở hữu trí tuệ.

# Public_003

_Dịch máy là một trong những hướng nghiên cứu quan trọng trong xử lý ngôn ngữ tự nhiên. Trong những năm gần đây, dịch máy nơ ron đã và đang được nghiên cứu phổ biến hơn trong cộng đồng dịch máy vì hiện tại nó cho chất lượng dịch tốt hơn so với phương pháp dịch máy thống kê truyền thống. Tuy nhiên, dịch máy nơ ron lại cần lượng lớn dữ liệu song ngữ để huấn luyện. Hệ dịch sẽ cho chất lượng bản dịch tốt hơn khi nó được thử nghiệm trong cùng miền với miền dữ liệu mà nó được huấn luyện, ngược lại thì chất lượng bản dịch sẽ bị sụt giảm, mức độ sụt giảm phụ thuộc vào mức độ khác biệt giữa dữ liệu miền huấn luyện và dữ liệu miền thử nghiệm. Hiện nay, các kĩ thuật thích ứng miền cho dịch máy nơ ron đã được công bố chủ yếu được thực hiện trên một số cặp ngôn ngữ phổ biến giàu tài nguyên, và chưa có nhiều nghiên cứu đã được công bố về thích ứng miền trong dịch máy nơ ron cho cặp ngôn ngữ Anh - Việt._

_Trong bài báo này, chúng tôi đề xuất một phương pháp thích ứng miền mới cho dịch máy nơ ron, áp dụng cho cặp ngôn ngữ Anh - Việt. Ý tưởng chính của bài báo là kết hợp dữ liệu đơn ngữ ngoài miền ở ngôn ngữ nguồn (tiếng Anh) với bản dịch của nó ở ngôn ngữ đích (tiếng Việt) để làm dữ liệu huấn luyện hệ dịch. Các thực nghiệm đã chứng minh rằng phương pháp chúng tôi đề xuất dễ thực hiện, khai thác được những ưu điểm của dữ liệu đơn ngữ như luôn có sẵn, chi phí xây dựng thấp và đặc biệt là chất lượng của hệ dịch được và tăng 2,21 điểm BLEU trong thử nghiệm của chúng tôi._

# Nội dung chính

## GIỚI THIỆU

Mục tiêu của dịch máy là nghiên cứu các phương pháp, kĩ thuật để xây dựng được một hệ thống có thể dịch tự động các câu từ một ngôn ngữ tự nhiên này sang ngôn ngữ khác, đây là một trong những hướng nghiên cứu quan trọng trong trí tuệ nhân tạo, đặc biệt trong xử lý ngôn ngữ tự nhiên. Dịch máy là một nhánh nhỏ của xử lý ngôn ngữ tự nhiên, và vì xử lý ngôn ngữ tự nhiên là lĩnh vực liên ngành giữa khoa học máy tính và ngôn ngữ học, chính đặc điểm đó nên các nghiên cứu về dịch máy có thể chia thành hai nhóm phương pháp chính là các phương pháp dựa trên luật và các phương pháp dựa trên ngữ liệu. Trong số đó, các phương pháp dựa trên ngữ liệu có thể được chia thành các phương pháp dựa trên thống kê và các phương pháp dựa trên ví dụ. Trong những năm gần đây, với sự phát triển của internet, dịch máy đã đạt được những kết quả tốt cả về học thuật và trong công nghiệp.

Gần đây, các nghiên cứu về dịch máy đã dịch chuyển dần từ các phương pháp dịch thống kê _(Statistical Machine Translation)_ sang dịch máy nơ ron _(Neural Machine Translation)_ , hiện tại đây được coi là một hệ dịch cho chất lượng dịch vượt trội so với các phương pháp truyền thống trước đây. Tuy nhiên, các hệ dịch nơ ron lại yêu cầu nhiều dữ liệu song ngữ hơn để huấn luyện hệ dịch, điều này ít ảnh hưởng tới chất lượng bản dịch của hệ dịch dành cho các cặp ngôn ngữ phổ biến và giàu tài nguyên nhưng nó lại là thách thức lớn đối với các cặp ngôn ngữ có ít tài nguyên.

Thông thường, hệ dịch được huấn luyện trên lượng lớn dữ liệu song ngữ và dữ liệu đơn ngữ của ngôn ngữ đích đối với dịch máy thống kê và dữ liệu song ngữ đối với dịch máy nơ ron, trong bản thân những dữ liệu huấn luyện này có thể bao gồm các chủ đề đồng nhất hoặc không đồng nhất và thường thì mỗi chủ đề đó sẽ có tập các từ thuật ngữ riêng biệt. Chất lượng của bản dịch phụ thuộc rất lớn vào dữ liệu huấn luyện, nếu miền dữ liệu huấn luyện và miền thử nghiệm giống nhau hoặc có sự tương đồng càng lớn thì chất lượng bản dịch thu được sẽ càng tốt so với việc miền dữ liệu dùng để huấn luyện và miền thử nghiệm dặc biệt khác nhau hoặc có ít sự tương đồng hơn. Ví dụ, nếu hệ dịch được huấn luyện với dữ liệu thuộc miền tin tức thì khi dịch các văn bản cũng thuộc miền tin tức sẽ cho chất lượng bản dịch tốt, nhưng nếu đem hệ dịch đó để dịch các văn bản thuộc miền khác với miền tin tức như miền y tế, tin học, luật, v.v... thì chất lượng của bản dịch sẽ bị giảm đột ngột, mức độ giảm tùy thuộc vào mức độ tương đồng của miền dữ liệu dùng để huấn luyện hệ dịch so với miền dữ liệu dùng để thử nghiệm.

Các miền dữ liệu song ngữ trong thực tế thường rất hiếm hoặc bị giới hạn về số lượng, đặc biệt đối với các cặp ngôn ngữ ít phổ biến như ngôn ngữ Anh - Việt, nhất là các miền dữ liệu đặc thù. Để đạt được chất lượng bản dịch tốt nhất thì dữ liệu huấn luyện phải thuộc cùng một miền, cùng một thể loại và cùng một phong cách với miền mà hệ dịch được áp dụng nhưng tế để có được lượng dữ liệu huấn luyện đủ lớn trong mỗi miền mà thỏa mãn những đặc điểm trên là rất khó, hoặc cần phải trả một chi phí rất lớn để xây dựng dữ liệu huấn luyện. Vì vậy, trong bài báo này chúng tôi trình bày một phương pháp thích ứng miền mới cho dịch máy nơ ron, áp dụng cho cặp ngôn ngữ Anh - Việt với chiều dịch từ tiếng Anh sang tiếng Việt. Các thử nghiệm được tiến hành trên hai miền dữ liệu là miền tổng quan và miền pháp lý, chất lượng dịch trên miền tổng quan làm cơ sở để so sánh, đánh giá chất lượng hệ dịch khi được áp dụng trong miền pháp lý cũng như đánh giá hiệu quả của phương pháp được đề xuất. Qua thử nghiệm cho thấy, phương pháp này dễ thực hiện, tận dụng được lượng lớn dữ liệu đơn ngữ luôn có sẵn với chi phí thấp và khả quan khi đã cải tiến được chất lượng bản dịch tăng 2,21 điểm BLEU [6] _(từ 22,17 điểm lên 24,38 điểm)._

Bài báo này được trình bày cấu trúc như sau: Tiếp theo, phần 2 sẽ giới thiệu các nghiên cứu trước đây có liên quan; phần 3 trình bày tổng quan phương pháp chúng tôi đề xuất; phần 4 trình bày các thử nghiệm và các kết quả; phần 5 là kết luận và hướng phát triển; và cuối cùng phần 6 là một số tài liệu tham khảo.

## CÁC NGHIÊN CỨU LIÊN QUAN

Những năm gần đây, thích ứng miền là một trong những chủ đề đã giành được rất nhiều sự quan tâm của các nhà khoa học trên thế giới. Hiện nay, đã có nhiều phương pháp được đề xuất để thích ứng cho dịch máy thống kê cũng như dịch máy nơ ron, nhưng các đề xuất đó chủ yếu áp dụng cho một số cặp ngôn ngữ phổ biến trên thế giới như Anh - Pháp, Anh - Nhật, Anh - Tây Ban Nha,... Các phương pháp đã đề xuất được công bố đều thuộc một trong ba hướng chính, đó là: (1) bổ sung thêm nhiều dữ liệu hơn; (2) các kĩ thuật để có dữ liệu chất lượng hơn và (3) các kĩ thuật để có mô hình chất lượng hơn. Với hướng tiếp cận (1) và (2), đã có nhiều công bố đề xuất sử dụng dữ liệu đơn ngữ để cải tiến chất lượng hệ dịch khi dịch trong miền mới, các đề xuất này chủ yếu đã được chứng minh bằng thực nghiệm trong dịch máy thống kê, và chưa có nhiều đề xuất đối với dịch máy nơ ron.

Trong [2], kỹ thuật thích ứng giữa các miền được đề xuất để áp dụng cho dịch máy thống kê dựa vào cụm từ về nhiệm vụ Europarl1 [3], để dịch các bình luận tin tức từ tiếng Pháp sang tiếng Anh. Cụ thể, một phần nhỏ dữ liệu song ngữ miền được khai thác để thích ứng mô hình ngôn ngữ và mô hình dịch bằng kỹ thuật nội suy tuyến tính. Việc thích ứng các mô hình dịch, mô hình đảo trật tự từ được thực hiện qua việc sinh thêm dữ liệu song ngữ từ dữ liệu đơn ngữ.

Công bố [9] đã đề xuất một số phương pháp thích ứng khá phức tạp dựa trên việc bổ sung thêm dữ liệu song ngữ được tổng hợp từ các tập dữ liệu dùng để tối ưu tham số và thử nghiệm. Ngoài ra, trong [10], đề xuất một phương pháp nhằm khai thác nguồn tài nguyên dữ liệu đơn ngữ miền bằng cách tổng hợp dữ liệu song ngữ từ việc dịch dữ liệu đơn ngữ miền sang ngôn ngữ đích. Phương pháp này chủ yếu liên quan đến kĩ thuật được đề xuất trong [2] nhưng khác nhau ở dữ liệu dùng để thích ứng miền, cụ thể ở [10] chỉ sử dụng dữ liệu đơn ngữ miền.

Các đề xuất trên được công bố cho dịch máy thống kê. Tuy nhiên, năm 2016 có công bố [11] đã đề xuất thích ứng miền cho dịch máy nơ ron dựa vào sinh dữ liệu song ngữ cho hệ dịch bằng việc dịch ngược các dữ liệu đơn ngữ trong miền đích. Trong bài báo này, phương pháp chúng tôi đề xuất có phần giống với phương pháp [9] vì chúng tôi có sử dụng thêm một tập dữ liệu miền pháp lý để tối ưu tham số của hệ dịch cơ sở theo định hướng miền đích, nhưng cũng liên quan nhiều đến phương pháp được đề xuất trong [10] và [11].

Nhìn chung, các phương pháp về thích ứng miền nói chung cho dịch máy đã được công bố khá phức tạp, thử nghiệm công phu và sử dụng nhiều mô hình toán học. Tuy nhiên, các thử nghiệm mới chỉ áp dụng cho một số cặp ngôn ngữ phổ biến như Anh - Pháp, Anh - Nhật, Anh - Tây Ban Nha,... Hiện vẫn chưa có công bố nào áp dụng cho cặp ngôn ngữ Anh - Việt.

## PHƯƠNG PHÁP ĐỀ XUẤT

### Tổng quan về dịch máy nơ ron

Đối với phương pháp dịch máy truyền thống như dịch máy thống kê dựa vào cụm thì hệ dịch thực hiện phân tách câu nguồn thành nhiều từ hoặc cụm từ riêng biệt, sau đó dịch tuần tự từng từ hoặc cụm từ một rồi sắp xếp lại trật tự các từ theo đúng trật tự trong ngôn ngữ đích. Vì thế, nên bản dịch không được trôi chảy và các dịch này không giống như cách con người dịch, để dịch, chúng ta sẽ đọc trọn vẹn một câu nguồn, hiểu ý nghĩa của nó rồi mới tiến hành dịch câu đó sang ngôn ngữ đích. Dịch máy nơ ron thực hiện dịch tương tự như cách của con người.

![](images/image1.jpg)

_**Hình 1.** Kiến trúc Encoder - Decoder_

Cụ thể, đầu tiên hệ dịch nơ ron sử dụng bộ mã hóa _(Encoder)_ để đọc toàn bộ câu nguồn và mã hóa nó dưới dạng một vectơ biểu diễn ý nghĩa. Sau đó, bộ giải mã _(Decoder)_ sẽ đọc và giải mã vec tơ biểu diễn câu nguồn này để sinh ra bản dịch tương ứng sang ngôn ngữ đích, quá trình mã hóa - giải mã được minh họa như ở hình 1 và hình 2 [5]. Theo cách dịch này, hệ dịch nơ ron có thể giải quyết được vấn đề dịch cục bộ trong phương pháp dịch dựa vào cụm truyền thống, đó là: nó có thể nắm bắt được các phụ thuộc xa hơn trong các ngôn ngữ và tạo ra các bản dịch trôi chảy hơn nhiều so với hệ dịch thống kê dựa vào cụm truyền thống.

**Bộ mã hóa -** Bộ mã hóa đọc câu nguồn _X = (x1, x2, …,xT)_ và chuyển đổi nó thành một chuỗi các trạng thái ẩn _h = (h1, h2,…,hT)_ sử dụng mạng nơ ron hồi quy hai chiều _(bi-directional RNN)_. Tại mỗi thời điểm t, trạng thái ẩn ht được xác định như là một kết hợp các trạng thái ẩn của mạng nơ ron hồi quy theo chiều xuôi _(forward RNN)_ và theo chiều ngược

![](images/image2.jpg)

_(backward RNN)_ ![](images/image3.jpg) với điều kiện
**Bộ giải mã -** Bộ giải mã sử dụng mạng nơ ron hồi quy khác để sinh ra bản dịch _Y = (y1, y2, …,yT’)_ dựa trên các trạng thái ẩn h được sinh bởi bộ mã hóa. Tại mỗi thời điểm i, xác suất có điều kiện của mỗi từ yi trong tập từ vựng _Vy_ của ngôn ngữ đích được tính bởi công thức:

_P(yi|y <i, h)=g(yi-1, zi, ci),_

_v_ ới điều kiện zi là trạng thái ẩn ith của bộ giải mã, và được tính dựa vào trạng thái ẩn trước zi-1, từ trước yi-1 và vectơ ngữ cảnh nguồn ci: _Zi= RNN(zi-1, yi-1, ci)._

### Phương pháp đề xuất

Trong thực tế, dữ liệu song ngữ thường không có sẵn, đặc biệt đối với các miền dữ liệu thuộc các lĩnh vực, chuyên ngành đặc thù, còn nếu muốn xây dựng dữ liệu song ngữ cho từng miền thì chi phí phải trả sẽ rất cao nhưng dữ liệu đơn ngữ thì lại luôn có sẵn với bất cứ miền dữ liệu nào. Trong dịch máy, dữ liệu đơn ngữ thường được dùng để làm mịn câu, khiến bản dịch của câu trôi chảy hơn và đọc lên thấy tự nhiên nhất. Dữ liệu đơn ngữ cũng đã được chứng minh có nhiều lợi ích trong việc cải tiến chất lượng dịch của cả hệ dịch máy thống kê và dịch máy nơ ron, đặc biệt trong nhiệm vụ thích ứng trong trường hợp nguồn tài nguyên bị hạn chế, nguồn dữ liệu song ngữ không đủ lớn. Hiện nay, cũng đã có một số đề xuất sử dụng dữ liệu đơn ngữ cho việc cải tiến chất lượng dịch, trong đó có đề xuất sinh dữ liệu song ngữ từ dữ liệu đơn ngữ cho dịch máy nhưng chưa có đề xuất, thử nghiệm hay khảo sát nào được công bố về sử dụng dữ liệu đơn ngữ để thích ứng miền áp dụng cho cặp ngôn ngữ Anh – Việt.
Như đã trình ở phần 2, phương pháp chúng tôi đề xuất có liên quan tới các công bố [9]; [10] và [11]. Theo [11], để sinh dữ liệu song ngữ thì việc dịch theo chiều ngược là cũng một giải pháp để có thể tận dụng được nguồn dữ liệu đơn ngữ miền. Để dịch theo chiều ngược hay theo chiều xuôi thì khá đơn giản và dễ áp dụng vì nó không yêu cầu phải thay đổi các thuật toán huấn luyện của hệ dịch.
Xuất phát từ ý tưởng trên, chúng tôi đề xuất một phương pháp mới để sinh dữ liệu song ngữ cho nhiệm vụ thích ứng miền áp dụng cho cặp ngôn ngữ Anh - Việt với chiều dịch từ Anh sang Việt, phương pháp của chúng tôi chỉ sử dụng dữ liệu đơn ngữ trong miền đích của ngôn ngữ đích. Phương pháp của chúng tôi khác với công bố trong [9]; [10] vì các công bố này chỉ thực nghiệm, áp dụng cho dịch máy thống kê dựa vào cụm còn phương pháp của chúng tôi là áp dụng cho dịch máy nơ ron. Ngoài ra, công bố [11] cũng khá liên quan tới phương pháp của chúng tôi khi cũng áp dụng cho dịch máy nơ ron, nhưng sử dụng kĩ thuật dịch ngược. Còn phương pháp của chúng tôi, cùng với các thử nghiệm, đánh giá hệ dịch dựa trên cách dịch xuôi dữ liệu đơn ngữ trong miền đích của ngôn ngữ đích. Phương pháp chúng tôi đề xuất được mô tả như hình 3, gồm 3 giai đoạn:

  * **Giai đoạn 1** : Giai đoạn này chúng tôi sử dụng dữ liệu song ngữ Anh – Việt thuộc miền tổng quan để huấn luyện một hệ dịch nơ ron làm cơ sở để so sánh, đánh giá hiệu quả của phương pháp chúng tôi đề xuất _(đặt tên là **Baseline NMT** như mô tả trong Hình 3 **,** trong các thử nghiệm gồm các hệ dịch Baseline_L và Baseline_G)_;


  * **Giai đoạn 2** : Sau khi đã có hệ dịch Baseline NMT ở giai đoạn 1, chúng tôi sử dụng hệ dịch này để dịch các văn bản đơn ngữ thuộc miền pháp lý trong tiếng Anh sang ngôn ngữ đích là tiếng Việt;

  * **Giai đoạn 3** : Sau khi có kết quả dịch ở giai đoạn 2, chúng tôi sử dụng kết quả dịch này kết hợp với các văn bản đơn ngữ bằng tiếng Anh ở giai đoạn 2 để huấn luyện một hệ dịch nơ ron khác _(đặt tên là **Adaptation NMT** như mô tả trong Hình 3, trong các thử nghiệm là hệ dịch **Adapt_System** )_, hệ dịch này được sử dụng để cải tiến chất lượng dịch của các văn bản thuộc miền pháp lý.


Bằng thực nghiệm, các kết quả so sánh thông qua cách đánh giá bằng điểm BLEU [6] đã chỉ ra rằng phương pháp chúng tôi đề xuất là cách tiếp cận khả quan, dễ thực hiện và đã cho kết quả dịch cải tiến hơn so với hệ dịch cơ sở ban đầu.

## THỰC NGHIỆM VÀ KẾT QUẢ

Để so sánh, đánh giá phương pháp đề xuất, chúng tôi tiến hành huấn luyện ba hệ dịch nơ ron, lần lượt _là **(1) Baseline_G**_ \- là hệ dịch cơ sở được huấn luyện với tập dữ liệu huấn luyện và tập tối ưu tham số _(tập dữ liệu G_train và tập dữ liệu G_val)_ cùng thuộc miền tổng quan; _**(2) Baseline_L**_ \- là hệ dịch được huấn luyện với tập dữ liệu huấn luyện thuộc miền tổng quan _(G_train)_ , còn tập tối ưu tham số thuộc miền luật _(L_val)_ ; _**(3) Adapt_System**_ \- là hệ dịch được huấn luyện với dữ liệu song ngữ được tổng hợp ở giai đoạn 2 của hình 3 và dữ liệu tối ưu tham số thuộc miền luật _(L_val)_.

Tiếp theo, chúng tôi sẽ mô tả về các tập dữ liệu, các bước tiền xử lý đối với dữ liệu huấn luyện của từng hệ dịch trên, đồng thời chúng tôi cũng trình bày cụ thể các bước thực nghiệm và kết quả tương ứng.

### Dữ liệu

Để huấn luyện hệ dịch, trong các thử nghiệm của chúng tôi có hai loại dữ liệu miền khác nhau, ở góc độ bài toán mà chúng tôi giải quyết đó là tận dụng dữ liệu đơn ngữ thuộc miền cần dịch và một hệ dịch có sẵn thuộc miền tổng quan để nâng cao chất lượng dịch theo miền _(miền pháp lý trong các thực nghiệm của chúng tôi)_. Để thống nhất, chúng tôi gọi dữ liệu thuộc miền tổng quan để huấn luyện hệ dịch là dữ liệu trong miền và dữ liệu không thuộc miền huấn luyện là dữ liệu ngoài miền.

### Thống kê dữ liệu

  1. _Dữ liệu trong miền:_ Chúng tôi sử dụng tập dữ liệu được cung cấp bởi hội nghị IWSLT 20152, tập dữ liệu này thuộc miền tổng quan gồm 131.000 cặp câu song ngữ tiếng Anh - tiếng Việt dành cho nhiệm vụ về dịch máy, tập dữ liệu này


được gọi là tập _**G_train**_ và được sử dụng để huấn luyện các hệ dịch cơ sở _(Baseline_G và Baseline_L)_. Để tối ưu các tham số của hệ dịch trong miền tổng quan, chúng tôi sử dụng tập dữ liệu gồm 745 cặp câu song ngữ thuộc miền tổng quan và gọi là tập _**G_val**_. Để đánh giá chất lượng của các hệ dịch khi dịch trong miền tổng quan, chúng tôi sử dụng 1.046 cặp câu song ngữ Anh – Việt thuộc miền tổng quan.

  2. _Dữ liệu ngoài miền:_ Chúng tôi sử dụng 100.000 câu đơn ngữ tiếng Anh thuộc miền pháp lý và dùng hệ dịch cơ sở Basline_NMT theo mô tả ở giai đoạn 2 của hình 3 để dịch nhằm tạo ra bản dịch gồm 100.000 câu tiếng Việt tương ứng. Để đánh giá chất lượng của các hệ dịch trong miền pháp lý, chúng tôi sử dụng 2.000 cặp câu song ngữ Anh - Việt cùng thuộc miền pháp lý.


### Tiền xử lý dữ liệu

Tiền xử lý dữ liệu là bước xử lý không thể thiếu trong các bài toán dịch. Sau khi thu thập được đầy đủ các tập dữ liệu, chúng tôi tiến hành chuẩn hóa. Đầu tiên, chúng tôi thực hiện tách từ trong văn bản, đối với văn bản tiếng Anh thì cần quan tâm tới việc tách các dấu ". , ’ ; ? " và các kí tự đặc biệt khác ra khỏi các từ trong văn bản. Để thực hiện việc này, chúng tôi sử dụng công cụ tách từ Tokenizer có sẵn trong hệ dịch mã nguồn mở Moses [4] do Koehn và cộng sự phát triển (2007). Đối với tiếng Việt, vì dấu cách không phải là dấu hiệu để phân biệt các từ, mà một từ trong tiếng Việt được cấu tạo bởi một hoặc nhiều âm tiết. Chính vì vậy, để tiến hành tách từ cho văn bản tiếng Việt, chúng tôi sử dụng công cụ tách từ dành riêng cho tiếng Việt khá phổ biến là VnTokenizer [1].

Sau đó, chúng tôi thực hiện chuyển tất cả các kí tự hoa trong các tập dữ liệu về dạng kí tự thường và loại bỏ những cặp câu có độ dài quá lớn trong dữ liệu, trong các thực nghiệm này chúng tôi chỉ chọn những câu có độ dài nhỏ hơn 80.

### Các thực nghiệm

Để huấn luyện các hệ dịch nơ ron, chúng tôi sử dụng công cụ OpenNMT3 [7], đây là hệ dịch mã nguồn mở hoàn thiện, nổi tiếng, được công bố năm 2017 của nhóm [Harvard NLP](https://nlp.seas.harvard.edu/) và SYSTRAN, công cụ này được nhiều người nghiên cứu trong cộng đồng dịch máy sử dụng. Các hệ dịch được huấn luyện với cùng các tham số mặc định, bao gồm hai tầng mạng LSTM với 500 nút ẩn và có sử dụng mô hình attention theo kiến trúc của Thang Luong [8]. Để so sánh, đánh giá chất lượng của các hệ dịch với nhau, chúng tôi sử dụng cách đánh giá tự động dựa vào điểm BLEU [6], đây cũng là cách đánh giá phổ biến trong bài toán dịch máy. Như mô tả ở hình 3:
**_Giai đoạn 1:_** Chúng tôi huấn luyện các hệ dịch cơ sở Baseline NMT, các hệ dịch này được huấn luyện với dữ liệu song ngữ thuộc miền tổng quan, nhưng được tối ưu tham số trong các miền dữ liệu khác nhau, cụ thể:

  * Hệ dịch **Baseline_G:** Sử dụng tập dữ liệu G_train và G_val _(mô tả trong bảng 1)_ để huấn luyện, hệ dịch cơ sở này được huấn luyện với dữ liệu song ngữ và tối ưu các tham số trong cùng một miền tổng quan.

  * Hệ dịch **Baseline_L:** Sử dụng tập dữ liệu G_train và L_val _(mô tả trong bảng 1_ ) để huấn luyện, hệ dịch cơ sở này được huấn luyện với dữ liệu song ngữ thuộc miền tổng quan nhưng các tham số của hệ dịch được tối ưu trong miền pháp lý.


Việc lựa chọn hệ dịch có chất lượng bản dịch tốt, để từ đó tiến hành dịch xuôi và tổng hợp được dữ liệu song ngữ có chất lượng tốt. Chúng tôi tiến hành đánh giá, so sánh chất lượng bản dịch của hai hệ dịch cơ sở này khi dịch trong cùng một miền dữ liệu tổng quan và miền dữ liệu pháp lý. Kết quả thử nghiệm được đánh giá thông qua điểm BLEU được thể hiện như bảng 2. Ở bảng 2, ta thấy:

  * Khi dịch với cùng tập dữ liệu là G_test thuộc miền tổng quan, hệ dịch Baseline_G cho điểm BLEU = 29,34 trong khi Baseline_L có điểm BLEU = 29,56.

  * Khi dịch với cùng tập dữ liệu L_test thuộc miền pháp lý thì hệ dịch Baseline_G cho điểm BLEU = 22,17 và hệ dịch Baseline_L cho điểm BLEU = 23,01.


Như vậy, khi hệ dịch cơ sở Baseline_L được tối ưu tham số trong miền pháp lý đã cải tiến được chất lượng của bản dịch khi dịch trong miền pháp lý, cụ thể đã tăng 0.84 điểm BLEU _(điểm BLEU = 23,01 so với 22,17 của hệ dịch Baseline_G)_. Căn cứ vào kết quả so sánh này, chúng tôi lựa chọn hệ dịch cơ sở Baseline_L để thực hiện các bước trong giai đoạn 2.
**_Giai đoạn 2:_** Chúng tôi dùng hệ dịch Baseline_L ở trên để dịch tập dữ liệu đơn ngữ gồm 100.000 câu tiếng Anh thuộc miền pháp lý sinh ra bản dịch tương ứng gồm 100.000 câu tiếng Việt.

**_Giai đoạn 3:_** Chúng tôi sử dụng cặp dữ liệu đơn ngữ ở giai đoạn 2 _(gồm 100.000 tiếng Anh và bản dịch của nó gồm 100.000 tiếng Việt)_ để huấn luyện hệ dịch Adapt_System, hệ dịch này được tối ưu tham số với tập dữ liệu L_val thuộc miền pháp lý. Các thử nghiệm cho kết quả điểm BLEU = 26,56 khi dịch tập dữ liệu G_test thuộc miền tổng quan, và điểm BLEU = 24,38 khi dịch tập dữ liệu L_test thuộc miền pháp lý.

Như vậy, hệ dịch Adapt_System cho chất lượng dịch trong miền pháp lý cao hơn so với các hệ dịch cơ sở Baseline_G và Baseline_L. Cụ thể, điểm BLEU cao hơn 2,21 điểm so với Baseline_G _(cải tiến từ 22,17 điểm tăng lên 24,38 điểm)_ và cao hơn 1,37 điểm so với Baseline_L _(cải tiến từ 23,01 điểm tăng lên 24,38 điểm)._ Các kết quả thử nghiệm được thể hiện trong bảng 2 và sự biến đổi về chất lượng của bản dịch được thể hiện như biểu đồ trong hình 4.

Các kết quả thử nghiệm đã cho thấy phương pháp mà chúng tôi đề xuất là cách tiếp cận khả quan, dễ thực hiện và đã cho kết quả dịch khi dịch trong miền pháp lý cải tiến hơn so với hệ dịch cơ sở ban đầu.

## KẾT LUẬN

Trong bài báo này, chúng tôi đã đề xuất một phương pháp thích ứng miền mới cho dịch máy nơ ron, phương pháp này đặc biệt hiệu quả đối với các miền dữ liệu có ít tài nguyên của cặp ngôn ngữ Anh - Việt, trong các thử nghiệm của chúng tôi, chúng tôi sử dụng dữ liệu thuộc miền pháp lý. Qua thực nghiệm cho thấy, cách tiếp cận này là khả quan, dễ thực hiện và đã cho kết quả dịch có điểm BLEU tăng 2,21 điểm _(từ 22,17 điểm lên 24,38 điểm)._ Như vậy, chất lượng dịch sau khi thích ứng đã có cải tiến hơn so với hệ dịch cơ sở ban đầu.

Trong tương lai, chúng tôi sẽ tiến hành thử nghiệm mở rộng thêm trên cả hai chiều dịch đối với một số miền dữ liệu khác, và khảo sát với các tình huống khi dữ liệu đơn ngữ theo miền có sự thay đổi về lượng thì chất lượng dịch của hệ thống lúc này sẽ thay đổi như thế nào, và lượng dữ liệu đơn ngữ này thay đổi như thế nào là vừa đủ đối với từng miền dữ liệu.

# TÀI LIỆU THAM KHẢO

  1. Phuong-Le Hong, Huyen-Nguyen Thi Minh, Azim Roussanaly and Vinh-Ho Tuong (2008). A Hybrid Approach to Word Segmentation of Vietnamese Texts.In Proceedings of the 2nd International Conference on Language and Automata Theory and Applications, Springer, LNCS 5196.

  2. Philipp Koehn and Josh Schroeder. 2007. Experiments in domain adaptation for statistical machine translation. In Proceedings of the Second Workshop on Statistical Machine Translation, pages 224–227, Prague, Czech Republic.


  3. Philipp Koehn. 2002. Europarl: A multilingual corpus for evaluation of machine translation. Unpublished, http://www.isi.edu/∼koehn/europarl.

  4. P. Koehn, H. Hoang, A. Birch, C. Callison-Burch, M. Federico, N. Bertoldi, B. Cowan, W. Shen, C. Moran, R. Zens, C. Dyer, O. Bojar, A. Constantin, and E. Herbst. 2007. Moses: Open source toolkit for statistical machine translation. In Proceedings of the 45th Annual Meeting of the Association for Computational Linguistics Companion Volume Proceedings of the Demo and Poster Sessions, pages 177– 180, Prague, Czech Republic.

  5. Philipp Koehn. 2017. Neural machine translation. CoRR, abs/1709.07809.

  6. Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2002. BLEU: a method for automatic evaluation of machine translation. In Proceedings of the 40th Annual Meeting of the Association of Computational Linguistics (ACL), pages 311–318, Philadelphia, PA.

  7. Guillaume Klein, Yoon Kim, Yuntian Deng, Jean Senellart, Alexander M. Rush. 2017. OpenNMT: Open-Source


Toolkit for Neural Machine Translation. Proceedings of AMTA 2018, vol. 1: MT Research Track.

  8. Minh-Thang Luong, Hieu Pham, and Christopher D Manning. 2015. [Effective approaches to attention-based neural](https://arxiv.org/pdf/1508.04025.pdf) [machine translation.](https://arxiv.org/pdf/1508.04025.pdf) EMNLP.

  9. Nicola Ueffing, Gholamreza Haffari, and Anoop Sarkar. 2007. Semi-supervised model adaptation for statistical machine translation. Machine Translation, 21(2):77–94.

  10. Nicola Bertoldi, Marcello Federico. 2009. Domain Adaptation for Statistical Machine Translation with Monolingual Resources. Proceedings of the 4th EACL Workshop on Statistical Machine Translation , pages 182–189.

  11. Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Improving neural machine translation models with monolingual data. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 86–96, Berlin, Germany, August. Association for Computational Linguistics.


##

# Public_004

_Ngành xây dựng không ngừng tìm kiếm những cách thức mới để nâng cao hiệu quả, nhiều công nghệ mới đã và đang được ứng dụng. Tuy nhiên, phương pháp xây dựng truyền thống vẫn không thay đổi trong nhiều thập kỷ qua, làm cho quá trình xây dựng kéo dài, không tối ưu nguồn lực dẫn đến giảm hiệu quả đầu tư xây dựng. Công nghệ in 3D là một công nghệ mới đầy hứa hẹn góp phần nâng cao hiệu quả đầu tư xây dựng và hạn chế tác động tiêu cực đến môi trường. Công nghệ in 3D sử dụng vật liệu bê tông là công nghệ có thể cho phép sản xuất cấu kiện kiến trúc, xây dựng mà không cần sử dụng ván khuôn, giúp mang lại nhiều lợi ích hơn so với phương pháp truyền thống. Trong khi công nghệ in 3D đã được áp dụng thành công trong một loạt các lĩnh vực như y tế, giáo dục, hàng không vũ trụ, ô tô v.v., thì ứng dụng của công nghệ này trong ngành xây dựng vẫn còn ở giai đoạn đầu. Trong vài năm qua, nhiều loại công nghệ in bê tông 3D khác nhau đã được phát triển và ứng dụng._

# Nội dung chính

## GIỚI THIỆU

Những thách thức trong ngành xây dựng hiện nay như tốc độ xây dựng chậm, quá trình thi công xây dựng gồm nhiều bước, mỗi bước đều tốn nhiều thời gian và công sức, công nghệ thi công hiện nay đang sử dụng nhiều nhân công lao động và tình trạng mất an toàn lao động là rất đáng quan ngại, ngoài ra các phương pháp thi công xây dựng và vật liệu xây dựng hiện tại không thân thiện với môi trường. Toàn bộ quá trình xây dựng, bao gồm sản xuất chế tạo sẵn, vận chuyển vật liệu, thi công xây dựng trên công trường đã thải ra một lượng lớn khí nhà kính và tiêu thụ một lượng lớn năng lượng, gây ô nhiễm môi trường. Do đó vấn đề đặt ra là phải áp dụng những công nghệ tiên tiến trong ngành xây dựng, trong đó công nghệ in bê tông 3D đang cho thấy những ưu điểm rõ rệt.

Kể từ khi phát hiện ra bê tông hiện đại vào thế kỷ 19, nhiều nhà nghiên cứu đã tìm cách tự động hóa việc xây dựng sử dụng vật liệu bê tông. Nhiều công nghệ xây dựng sử dụng vật liệu bê tông đã được phát triển, như công nghệ bơm bê tông và công nghệ phụ gia. Một nỗ lực lớn gần đây đối với ngành xây dựng dựa trên ý tưởng mới là các kỹ thuật sản xuất bồi đắp. Sản xuất bồi đắp được định nghĩa là quy trình ghép các lớp vật liệu để tạo các vật thể từ dữ liệu mô hình số 3D, trái ngược với các phương pháp sản xuất trừ (như điêu khắc). Trong đó nổi bật là công nghệ in 3D sử dụng vật liệu bê tông.

Công nghệ in bê tông 3D đề cập đến một quy trình sản xuất bồi đắp tự động, trong đó các đối tượng in được tạo ra bằng cách liên kết các lớp vật liệu kế tiếp chồng lên nhau. Quá trình bắt đầu với việc tạo ra một mô hình 3D bằng phần mềm CAD (Computer Aided Design). Mô hình sau đó được nhập vào máy in bê tông 3D bằng định dạng tệp .STL (Stereolithography Language) là định dạng tệp phổ biến hiện nay, từ đây mô hình được chia thành các lớp có thể liên kết với nhau để tạo thành đối tượng in 3D. Trong những năm gần đây, công nghệ in bê tông 3D đã nhận được rất nhiều sự chú ý từ ngành xây dựng như một phương pháp thi công xây dựng đầy triển vọng. Công nghệ in bê tông 3D giúp tiết kiệm thời gian, vật liệu, nhân công bằng cách giảm hao hụt vật liệu, hạn chế hoặc không sử dụng ván khuôn từ đó giúp giảm chi phí. Ngoài ra, công nghệ này cũng hạn chế việc sao chép, giúp các nhà thiết kế có thể làm cho công trình trở có tính chất riêng so với các công trình khác.

Hiện nay việc áp dụng công nghệ in bê tông 3D trong ngành xây dựng vẫn gặp nhiều rào cản nhất định như còn nhiều hạn chế về mặt công nghệ, chi phí đầu tư cũng như chất lượng của các sản phẩm được chế tạo bằng công nghệ này.

Tuy nhiên, với sự phát triển của khoa học công nghệ, việc áp dụng các tiến bộ khoa học công nghệ trong ngành xây dựng là tất yếu. Trong đó, việc áp dụng công nghệ in bê tông 3D trong xây dựng có thể giải quyết những vấn đề nan giải hiện nay của ngành xây dựng. Bài báo giới thiệu các công nghệ in bê tông 3D và so sánh tính khả thi của các công nghệ này ứng dụng trong ngành xây dựng Việt Nam.

## TỔNG QUAN

Ứng dụng của công nghệ in bê tông 3D trong ngành xây dựng là để chế tạo các cấu kiện kiến trúc, xây dựng. Mặc dù việc ứng dụng công nghệ in bê tông 3D vẫn còn ở giai đoạn đầu, tuy nhiên những nỗ lực nhằm đưa công nghệ này ứng dụng có hiệu quả hơn trong ngành xây dựng đã và đang được thực hiện trên toàn thế giới. Công nghệ in bê tông 3D là một công nghệ mới, nhằm mục đích giảm thiểu thời gian của quá trình xây dựng bằng cách loại bỏ một số quy trình tốn thời gian của phương pháp truyền thống, giảm các chi phí thông qua việc giảm thiểu khối lượng phát sinh, giảm nhân công lao động, đồng thời dễ dàng tạo ra những cấu kiện có hình dạng phức tạp với độ chính xác cao mà khó có thể thực hiện được bằng phương pháp truyền thống, cải thiện tác động tiêu cực của ngành xây dựng lên môi trường. Công nghệ in bê tông 3D có khả năng chế tạo cấu kiện kiến trúc, xây dựng được thiết kế trước bằng cách liên kết các lớp vật liệu chồng lên nhau theo một quy tắc nhất định.

Hiện nay, việc ứng dụng công nghệ in bê tông 3D trong ngành xây dựng còn nhiều vấn đề nan giải. Các nghiên cứu trên thế giới đã chỉ ra một số rào cản về vấn đề này như khả năng làm việc của cấu kiện được sản xuất bằng công nghệ in bê tông 3D hiện nay còn nhiều hạn chế về khả năng chịu lực so với các phương pháp sản xuất cấu kiện bê tông truyền thống tính đến thời điểm hiện tại. Những thách thức hiện tại trong thương mại hóa công nghệ in bê tông 3D như thiếu tiêu chuẩn, chi phí đầu tư lớn, các cấu kiện được chế tạo chưa đảm bảo chất lượng. Tuy nhiên lợi ích của công nghệ này đối với ngành xây dựng là rất to lớn như hạn chế hao hụt vật liệu, giảm đáng kể nhân công, đồng thời giảm thời gian thi công xây dựng. Nhiều nghiên cứu cũng đề cập đến khả năng áp dụng của các công nghệ in bê tông 3D trong xây dựng như việc áp dụng công nghệ Contour Crafting trong thi công xây dựng và khẳng định công nghệ Contour Crafting là một trong số rất ít các công nghệ khả thi có thể áp dụng trong ngành xây dựng [1]. S. Lim và cộng sự đã sử dụng công nghệ in bê tông 3D trong việc sản xuất các cấu kiện xây dựng quy mô lớn và đánh giá lợi ích của công nghệ này so với công nghệ xây dựng truyền thống [2].

Các nghiên cứu về việc chế tạo, kiểm định vật liệu in và cấu kiện in đã được thực hiện trong nhiều năm qua, như đánh giá và sửa đổi chất lượng in, độ ổn định hình dạng của hỗn hợp vật liệu in [3], sử dụng các vật liệu in khác nhau để chế tạo và kiểm tra khả năng tạo ra các cấu kiện có cấu trúc phức tạp cũng như cường độ của sản phẩm được chế tạo bằng công nghệ in bê tông 3D [4], nghiên cứu tối ưu hóa vật liệu và máy in chế tạo các cấu kiện phù hợp để ứng dụng trong quy mô nhỏ, qua đó chứng minh công nghệ in bê tông 3D này không chỉ là một công cụ đầy hứa hẹn cho thiết kế kết cấu, mà còn là một công cụ tiềm năng cho thiết kế kiến trúc [5]. Phát triển phương pháp để tạo ra các cấu kiện dựa trên geopolyme được sử dụng trong các máy in 3D sử dụng kỹ thuật lắng đọng bột có bán trên thị trường cho các ứng dụng xây dựng [6].

Nhìn chung, các nghiên cứu trên đã chỉ ra một số phạm vi áp dụng, lợi ích, khả năng áp dụng cũng như rào cản của công nghệ in bê tông 3D trong ngành xây dựng trên thế giới.

## CÁC CÔNG NGHỆ IN BÊ TÔNG 3D

Trong những năm qua, nhiều công nghệ in bê tông 3D khác nhau đã được phát triển để ứng dụng trong ngành xây dựng. Những công nghệ in bê tông 3D này chủ yếu dựa trên hai kỹ thuật chính, đó là kỹ thuật ép đùn (Extrusion-Based Technique) và kỹ thuật lắng đọng bột (Powder-Based Technique).

### Công nghệ in bê tông 3D dựa trên kỹ thuật ép đùn

Công nghệ in bê tông 3D dựa trên kỹ thuật ép đùn tương tự như phương pháp nóng chảy lắng đọng FDM (Fused Deposition Modelling). Theo đó, vật liệu in sẽ đi qua từ một đầu in được gắn trên cần trục hoặc cánh tay robot để in một đối tượng theo từng lớp vật liệu. Các công nghệ in bê tông 3D dựa trên kỹ thuật này tiêu biểu như:

#### * Công nghệ Contour Crafting

Contour Crafting là một phương pháp của quy trình sản xuất nhiều lớp sử dụng polymer, bùn gốm, bê tông, và một loạt các vật liệu và hỗn hợp khác để xây dựng các vật thể quy mô lớn với bề mặt mịn. Những ưu điểm chính của công nghệ này là tốc độ chế tạo nhanh hơn và khả năng tích hợp với các phương pháp khác để lắp đặt các bộ phận như đường ống, dây điện và cốt thép. Công nghệ Contour Crafting cho ra sản phẩm có bề mặt hoàn thiện vượt trội và tốc độ sản xuất được tăng cường đáng kể.

#### * Công nghệ Concrete Printing

Công nghệ Concrete Printing đã được nghiên cứu và phát triển tại Đại học Loughborough ở Vương quốc Anh. Công nghệ này cũng sử dụng kỹ thuật dựa trên ép đùn và ở một mức độ nào đó tương tự như công nghệ Contour Crafting. Tuy nhiên, công nghệ Concrete Printing đã được phát triển cho phép kiểm soát tốt hơn cấu trúc của sản phẩm in. Ngoài ra, vật liệu được sử dụng trong in bê tông là bê tông cốt liệu sợi tổng hợp cường độ cao nên tính chất của vật liệu vượt trội so với các vật liệu được sử dụng trong công nghệ Contour Crafting [2].

#### * Công nghệ Concrete On-Site 3D Printing

Công nghệ Contour Crafting và Concrete Printing ngoài những ưu điểm so với các công nghệ truyền thống thì vẫn tồn tại một số hạn chế như sự cần thiết phải sử dụng máy móc mới và tiên tiến, kích thước cốt liệu nhỏ (thường sử dụng vữa tổng hợp thay vì bê tông thông thường) và kích thước hạn chế của sản phẩm in (tức là kích thước của máy in 3D phải lớn hơn kích thước của phần tử được in). Để khắc phục những hạn chế này, một công nghệ mới là công nghệ Concrete On-Site 3D Printing, được phát triển tại TU Dresden, Đức. Ưu điểm chính của công nghệ này là tính linh hoạt hình học cao và ít phụ thuộc vào nhân công lành nghề [7].

Một trong những ưu điểm của công nghệ in bê tông 3D tại chỗ không chỉ là phát triển quy trình xây dựng tiên tiến hiệu quả về thời gian, lao động và tài nguyên mà còn làm cho quy trình mới có hiệu quả kinh tế trong khi đạt được sự chấp nhận rộng rãi hơn trong ngành xây dựng. Điều này đạt được bằng cách sử dụng các kỹ thuật sản xuất và xây dựng hiện có càng nhiều càng tốt và bằng cách điều chỉnh quy trình mới với các hạn chế của công trường xây dựng [7].

#### * Công nghệ in bê tông 3D quy mô lớn sử dụng bê tông cường độ cao (Large-Scale 3DCP using Ultra-High Performance Concrete)

Qua việc nghiên cứu những hạn chế của các công nghệ Contour Crafting và công nghệ Concrete Printing đã đề cập ở trên, một công nghệ mới đã được một nhóm nghiên cứu ở Pháp giới thiệu với quy mô áp dụng lớn, sử dụng bê tông cường độ cao (UHPC). Công nghệ này được phát triển dựa trên kỹ thuật ép đùn để in bê tông cường độ cao theo từng lớp thông qua một đầu in đùn được gắn trên cánh tay robot. Ưu điểm chính của công nghệ này là cho phép sản xuất cấu kiện với hình dạng phức tạp với quy mô lớn mà không cần ván khuôn [8].

### Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột (Powder-based Technique)

Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột là một quy trình chế tạo cộng điển hình khác tạo ra các cấu kiện với hình học phức tạp bằng cách lắng đọng chất lỏng kết dính một cách chọn lọc. Kỹ thuật này là một quy trình ngoài công trường được thiết kế để sản xuất các cấu kiện đúc sẵn. Một số công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột được liệt kê dưới đây.

#### * Công nghệ in ba chiều (D-Shape)

Công nghệ D-Shape được phát triển bởi Enrico Dini sử dụng kỹ thuật dựa trên kỹ thuật lắng đọng bột để làm cứng một lớp vật liệu quy mô lớn. Xi măng cát và magiê oxychloride (còn được gọi là xi măng Sorel) được sử dụng làm vật liệu xây dựng và chất kết dính tương ứng [9].

#### * Công nghệ đối tượng mới (Emerging Objects)

Công nghệ đối tượng mới (Emerging Objects) được phát triển ở Hoa Kỳ sử dụng kỹ thuật lắng đọng bột để làm cứng có chọn lọc một công thức hỗn hợp xi măng bằng cách lắng đọng một tác nhân liên kết.

#### * Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột sử dụng Geopolymer (Powder-based 3DCP using Geopolymer)

Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột sử dụng Geopolymer có khả năng sản xuất các cấu kiện xây dựng với chi tiết và hình dạng phức tạp. Công nghệ dựa trên lắng đọng bột có tiềm năng để sản xuất các cấu kiện xây dựng với độ bền cao và tốc độ hợp lý để đáp ứng nhu cầu sản xuất quy mô công nghiệp [10].

## KẾT LUẬN

Ưu điểm chính của công nghệ in ba chiều là sản phẩm tạo ra có kết cấu chắc chắn nhưng có nhược điểm là công nghệ này tốn nhiều công sức và rắc rối. Công nghệ Contour Crafting và Concrete Printing đều dựa trên kỹ thuật ép đùn, điều này làm cho chúng rất giống nhau, lợi thế của công nghệ Contour Crafting so với công nghệ Concrete Printing là độ mịn của bề mặt sản phẩm, tuy nhiên sản phẩm được sản xuất bằng công nghệ Concrete Printing có kết cấu chắc chắn hơn so với công nghệ Contour Crafting, nhưng sản phẩm sản xuất bằng công nghệ Concrete Printing lại có kích thước hạn chế hơn.

Dựa trên các phân tích ở trên, mặc dù công nghệ in bê tông 3D vẫn là một công nghệ mới nổi, khả năng ứng dụng trong xây dựng còn hạn chế, đặc biệt là đối với quy mô sản xuất tại chỗ trên công trường, nhưng với phát triển nhanh chóng của công nghệ này, việc in các cấu kiện bê tông ở quy mô lớn sẽ thành hiện thực trong tương lai gần.

# TÀI LIỆU TRÍCH DẪN

[1]. P. Sharma, "Automated Construction by Contour Crafting," Journal of advance research in mechanical & civil engineering, 2015.

[2]. S. Lim, R. A. Buswell, T. T. Le, S. A. Austin, A. G. .. F. Gibb and T. Thorpe, "Developments in construction-scale additive manufacturing processes," Automation in construction, vol. 21, pp. 262-268, 2012.

[3]. A. Kazemian, X. Yuan, R. Meier and B. Khoshnevis, "Performance-based testing of Portland cement concrete for construction-scale 3D printing," 3D Concrete Printing Technology, pp. 13-35.

[4]. B. P, J. Scott Z, B. Isaiah R and P. Max A, "Towards the formulation of robust and sustainable cementitious binders for 3D additive construction by extrusion," 3D Concrete Printing Technology, pp. 307-331, 2019.

[5]. Z. Malaeb, F. AlSakka and F. Hamzeh, "3D concrete printing: machine design, mix proportioning, and mix comparison between different machine setups," 3D concrete printing technology, pp. 115-136, 2019.

[6]. B. Nematollahi, M. Xia, P. Vijay and J. G. Sanjayan, "Properties of extrusion-based 3D printable geopolymers for digital construction applications," 3D Concrete Printing Technology, pp. 371-388, 2019.

[7]. N. V.N, K. M, N. M and M. V, CONPrint3D - 3D printing technology for onsite construction, Concrete in Australia, 2016.

[8]. Y. JunNam, Y. Kwang, H. Woon and P. MookLim, "Fiber-reinforced cementitious composite design with controlled distribution and orientation of fibers using three-dimensional printing technology," 3D Concrete Printing Technology, pp. 59-72, 2019.

[9]. G. Cesaretti, E. Dini, X. Kestelier, V. Colla and L. Pambaguian, "Building components for an outpost on the Lunar soil by means of a novel 3D printing technology," Acta Astronautica, vol. 93, pp. 430-450, 2014.

[10]. M. Xia and J. Sanjayan, "Method of formulating geopolymer for 3D printing for construction applications," Materials & Design, vol. 110, pp. 382-390, 2016

# Public_005

_Chuyển đổi số các cơ sở giáo dục đào tạo đang là một nhiệm vụ cấp bách và Học viện Ngân hàng cũng không nằm ngoài guồng quay của cuộc cách mạng công nghệ này. Để quá trình chuyển đổi số được thuận lợi thì quá trình số hóa dữ liệu cần được ưu tiên đẩy mạnh. Trong bài báo này, tác giả nghiên cứu những giải pháp phù hợp cho việc số hóa dữ liệu văn bản đã và đang lưu hành trong Học viện Ngân hàng. Cụ thể, tác giả giới thiệu các công nghệ cốt lõi trong số hóa tài liệu như Nhận dạng ký tự quang học, Xử lý văn bản thông minh, khảo sát các giải pháp tiêu biểu trên thị trường ở Việt Nam để lựa chọn giải pháp khả thi và tiến hành cài đặt thử nghiệm giải pháp FPT. AI Reader với bộ dữ liệu tự thu thập từ một số phòng ban tại Học viện. Kết quả thực nghiệm cho thấy tỷ lệ sai số ở mức từ đạt 27% và chỉ 16% từ bị sai ở các tiêu đề, đơn vị ban hành, loại văn bản. Giải pháp hoàn toàn có thể được nghiên_

# Nội dung chính

## Đặt vấn đề

Thực hiện chuyển đổi số (CĐS) trong lĩnh vực giáo dục đào tạo là một trong những hoạt động nhận được nhiều sự quan tâm và ưu tiên của nhiều nước trên thế giới. Hoạt động CĐS trong lĩnh vực giáo dục không chỉ tập trung vào hoạt động dạy và học trong thay đổi phương pháp dạy và học mà còn diễn ra ở rất nhiều nghiệp vụ khác như phát triển hệ thống hỗ trợ hoạt động quản lý điều hành, quản lý hoạt động khoa học công nghệ. Trên cơ sở Quyết định số 131/ QĐ-TTg năm 2022 của Thủ tướng Chính phủ phê duyệt Đề án “Tăng cường ứng dụng công nghệ thông tin và chuyển đổi số trong giáo dục và đào tạo giai đoạn 2022-2025, định hướng đến năm 2030” (Thủ tướng Chính phủ, 2022), Học viện Ngân hàng cũng đã có những hành động thiết thực để thích ứng với bối cảnh phát triển chung của giáo dục đại học.

Liên quan đến chuyển đổi số, khá nhiều thuật ngữ với hậu tố “số” có thể gây nhầm lẫn, như “công nghệ số”, “kinh tế số”, “kỹ thuật số”. Đặc biệt thuật ngữ tiếng Anh cũng có những thuật ngữ gần giống nhau như Digitization, Digitalization, vậy vai trò của chúng đối với CĐS như thế nào? Theo Phạm Huy Giao (2020) quá trình CĐS bao gồm ba giai đoạn như Hình 1.

Theo đó, một tổ chức muốn thực hiện CĐS, trước hết cần trải qua giai đoạn đầu tiên: Số hóa (Digitization). Đây là quá trình chuyển đổi các thực thể trong quy trình hoạt động từ dạng vật lý sang dạng số, có thể lưu trữ và xử lý trên máy tính điện tử. Chẳng hạn hồ sơ của một nhân viên từ bản sơ yếu lý lịch trên giấy được lưu trữ thành các trường thông tin trong cơ sở dữ liệu như Họ tên, Ngày sinh, Quê quán. Các số liệu kinh doanh từ việc lưu cả tập hóa đơn, chứng từ và kiểm kê lại khi cần thì được tổ chức thành các bảng số liệu trong Microsoft Excel. Hay chỉ đơn giản là lưu trữ các tệp tin (file) trong máy tính chứa các dữ liệu hoạt động của tổ chức cũng có thể phần nào được coi là số hóa.

Tại Học viện Ngân hàng, một số phòng ban đã có phần mềm quản lý và vận hành khá ổn định. Chẳng hạn Phòng Đào tạo có phần mềm Quản lý đào tạo, phòng Quản lý người học thực hiện quản lý trên Cổng thông tin sinh viên, Phòng Quản trị có phần mềm MISA, Tạp chí Khoa học và Đào tạo Ngân hàng cũng sử dụng phần mềm quản lý bài viết trực tuyến. Điều này giúp một lượng lớn dữ liệu tác nghiệp của Học viện được chuyển hóa vào các cơ sở dữ liệu tương ứng. Tuy nhiên, theo quan sát thực tế vẫn còn không ít dữ liệu vẫn đang lưu hành bản cứng, như các quyết định, tờ trình cũ khi chưa áp dụng phần mềm quản lý, hoặc các đơn từ, đặc biệt là đơn từ của sinh viên thì chưa có hình thức lưu trữ điện tử phù hợp. Khi cần phải tra cứu chỉ có thể đến tận nơi và tìm theo các tủ hồ sơ vật lý hoặc tra cứu trong máy tính cục bộ của chuyên viên phụ trách. Một số tài liệu được đăng tải trên website của đơn vị, nhưng chỉ có thể tra cứu theo tiêu đề văn bản (nếu được đặt tiêu đề chính xác) chứ các nội dung thường được đóng gói trong mã nhúng file PDF chỉ cho phép đọc chứ không thể truy cập chi tiết. Đây là một thách thức trong quá trình số hóa nói riêng và chuyển đổi số nói chung tại Học viện, thôi thúc các nghiên cứu tìm kiếm giải pháp thích hợp nhằm biến đổi các văn bản thô còn tồn đọng thành những tài liệu định dạng kỹ thuật số.

Từ thực trạng trên, tác giả đặt ra ba câu hỏi nghiên cứu chính:

  * Những công nghệ cần thiết cho việc số hóa dữ liệu văn bản là gì?

  * Có những giải pháp nào trên nền tảng những công nghệ đó thích hợp với số hóa dữ liệu văn bản tại Việt Nam?

  * Những văn bản đã và đang lưu hành tại Học viện khi áp dụng thử nghiệm các giải pháp này cho kết quả như thế nào?


Để tìm kiếm lời giải cho các câu hỏi trên, tác giả đề xuất nghiên cứu và đánh giá các giải pháp và công nghệ hiện đại liên quan đến việc số hóa tài liệu, văn bản. Cụ thể tác giả đặt ra một số mục tiêu nghiên cứu sau:

Nghiên cứu tổng quan các công nghệ số hóa dữ liệu văn bản như nhận dạng ký tự quang học (OCR) hay xử lý văn bản thông minh (IDP). Đây đều là những công nghệ đóng vai trò rất quan trọng trong công cuộc chuyển đổi số.

Khảo sát các giải pháp sẵn có trên thị trường ở Việt Nam, lựa chọn giải pháp khả thi cũng như cài đặt thử nghiệm với dữ liệu thực tế tại Học viện.

Thu thập dữ liệu thực tế từ các phòng ban chức năng và khoa chuyên ngành của Học viện. Dữ liệu được thu thập đảm bảo sự đa dạng về thể loại (các loại văn bản khác nhau lưu hành ở Học viện như nghị quyết, quyết định, thông báo), nguồn gốc (đơn vị phụ trách biên soạn hoặc ban hành văn bản), định dạng tài liệu (hình ảnh chụp từ điện thoại, ảnh quét từ máy scan, file pdf được chuyển từ văn bản MS Word).

Đánh giá mức độ hiệu quả về khả năng bóc tách tài liệu và nhận dạng ký tự của giải pháp đề xuất trên bộ dữ liệu đã thu thập.

Để đạt mục tiêu nghiên cứu, tác giả thực hiện tổng quan nhằm làm rõ cơ sở lý thuyết về công nghệ nhận dạng ký tự quang học; quan sát và trải nghiệm thực tế nhằm hệ thống các giải pháp nhận dạng ký tự quang học tại Việt Nam; và thực hiện thử nghiệm với tài liệu tại Học viện Ngân hàng.

## Cơ sở lý thuyết về công nghệ nhận dạng ký tự quang học

Công nghệ Nhận dạng ký tự quang học-Optical Character Recognition (OCR) là một loại công nghệ cho phép máy tính điện tử tự động nhận biết các ký tự (chữ cái, số, dấu câu, ký tự đặc biệt) trên những hình ảnh được cung cấp (Ravina Mithe, 2013). Không giống như bộ não con người, thứ có thể dễ dàng đọc được các ký tự, câu chữ từ hình ảnh, máy tính không đủ thông minh và khả năng trừu tượng để nhận biết được loại thông tin này. Máy tính chỉ hiểu hình ảnh là các điểm ảnh (pixel) đại diện bởi các con số chỉ mã màu sắc ở pixel đó. Bởi vậy, nghiên cứu về công nghệ OCR vẫn đang là một chủ đề rất được quan tâm trong cộng đồng nghiên cứu Trí tuệ nhân tạo.

Cách thức hoạt động chung của OCR được mô tả ở Hình 2. Theo đó máy quét sẽ quét biểu mẫu chứa hình ảnh ký tự, sau đó công cụ nhận dạng tiến hành đọc hiểu các hình ảnh và chuyển chúng thành dữ liệu ASCII (các ký tự máy có thể đọc được). Có nhiều yếu tố ảnh hưởng đến chất lượng văn bản đầu ra của hệ thống OCR như chất lượng hình ảnh đầu vào (độ phân giải cao/thấp, góc chụp nghiêng/thẳng, độ sáng, độ bóng...), mật độ văn bản trên hình ảnh đầu vào (ví dụ giấy tờ cá nhân thì mật độ văn bản ít hơn so với các quy định pháp luật), phông chữ của tài liệu gốc (chữ viết tay, chữ in hoa, loại phông chữ) hay ngôn ngữ của tài liệu gốc (tiếng Việt, tiếng Anh hay nhiều ngôn ngữ cùng trong một văn bản).

Quá trình xử lý của hệ thống OCR thường được chia thành 3 giai đoạn: phát hiện văn bản (text detection), nhận dạng văn bản (text recognition) và trích xuất thông tin (information extraction). Các giai đoạn này lại áp dụng nhiều kỹ thuật, thuật toán phức tạp của thị giác máy tính (Computer Vision) và xử lý ngôn ngữ tự nhiên (Natural Language Processing). Chẳng hạn với riêng bài toán trích xuất thông tin từ hóa đơn bán hàng tiếng Việt trong cuộc thi MC-OCR Challenge tổ chức năm 2021, mô hình nhận dạng ký tự tốt nhất được xây dựng dựa trên mạng nơ ron Faster R-CNN kết hợp với mạng nơ ron TransformerOCR (Vu Xuan-Son, 2021).

Cùng với OCR, gần đây, thuật ngữ Nhận dạng ký tự thông minh (Intelligent Character Recognition- ICR) (Raymond Ptucha, 2019) được sử dụng để mô tả quá trình đọc hiểu dữ liệu hình ảnh, cụ thể là văn bản chữ và số. ICR là một mô-đun của OCR, có khả năng biến hình ảnh viết tay hoặc các ký tự in thành dữ liệu ASCII.

OMR (Optical Mark Reader- Nhận dạng dấu quang học) (Krisana Chinnasarn, 1999) là một phương pháp điện tử thu thập dữ liệu do con người xử lý bằng cách xác định một số dấu hiệu nhất định trên tài liệu. Thông thường, quá trình nhận dạng dấu quang học được thực hiện với sự hỗ trợ của máy quét kiểm tra truyền tải hoặc phản xạ ánh sáng qua giấy; những nơi có đánh dấu sẽ phản xạ ít ánh sáng hơn phần giấy trắng, dẫn đến độ tương phản kém hơn. OMR thường được ứng dụng để xử lý dữ liệu từ phiếu điều tra hay chấm các bài thi trắc nghiệm. Ngoài ra, nhiều doanh nghiệp công nghệ cũng đưa ra thuật ngữ Xử lý văn bản thông minh (Intelligent Document Processing-IDP) là một công cụ tự động thu thập, trích xuất dữ liệu từ các tài liệu bán cấu trích xuất nội dung từ ảnh chụp mẫu văn bản có sẵn (giấy chứng minh nhân dân, bằng lái xe, thẻ bảo hiểm y tế, hóa đơn), hoặc theo bất kì định dạng văn bản tùy biến (hợp đồng, chứng từ, quy định...), nhằm số hóa tài liệu một cách nhanh chóng và thuận tiện. FPT.AI Reader được các chuyên gia trong lĩnh vực trí tuệ nhân tạo của FPT Smart Cloud nghiên cứu và phát triển. Giải pháp này áp dụng công nghệ nhận dạng ký tự quang học (OCR) và Xử lý văn bản thông minh (IDP), kết hợp kỹ thuật xử lý ảnh nâng cao và Xử lý ngôn ngữ tự nhiên (NLP), cho phép người dùng số hóa văn bản chính xác trong thời gian ngắn (chỉ tới vài giây) (FPT.AI, 2022). Hình 3 dưới đây là một ví dụ về trích xuất các thông tin cần thiết như họ tên, số căn cước công dân, giới tính, quốc tịch, quê quán, địa chỉ từ ảnh chụp mặt trước của một căn cước công dân theo mẫu hiện tại ở Việt Nam.

Đặc biệt, FPT.AI Reader cho phép người dùng tự định nghĩa mẫu văn bản mới, chưa có trong các mẫu có sẵn của hệ thống để tự tạo mô hình OCR của riêng mình. Chẳng hạn ta cần số hóa thẻ sinh viên, có thể tạo một dự án mới trong bảng điều khiển của FPT.AI (https://console.fpt.ai/), tải lên một trúc (semi-structured data) và phi cấu trúc (unstructured data) và chuyển chúng thành tài liệu có cấu trúc (structured data) để sử dụng (Akabot, 2022). IDP là sự kết hợp giữa nhiều công nghệ bao gồm Xử lý ngôn ngữ tự nhiên (Natural Language Processing-NLP), Thị giác máy tính (Computer Vision), Học máy (Machine Learning- ML) và OCR nhằm tăng cường việc nhận diện, phân loại, phân tích, trích xuất dữ liệu và đánh giá dữ liệu để nâng cao độ chính xác và hiệu quả. Ở Việt Nam, nhiều nghiên cứu đã được thực hiện nhằm áp dụng các công nghệ này cho từng loại nghiệp vụ khác nhau, chẳng hạn trích xuất và nhận dạng thông tin trên chứng minh nhân dân của người Việt (Duc Phan, 2021), trích xuất thông tin trên hóa đơn bán hàng (Vu Xuan-Son, 2021), nhận dạng biển số xe (Trần Thị Hương, 2021), trích xuất văn bản từ bìa sách (Phan Thi Thanh Nga, 2017). Tuy nhiên đến nay chưa có nghiên cứu nào áp dụng các công nghệ trên với các tài liệu ở cơ sở giáo dục đại học. Đây cũng là nội dung trọng tâm mà bài báo này hướng đến khi áp dụng thử nghiệm tại Học viện Ngân hàng.

## Kết quả thử nghiệm công nghệ nhận dạng ký tự quang học cho số hóa tài liệu tại Học viện Ngân hàng

### Các giải pháp nhận dạng ký tự quang học tại Việt Nam

####  FPT.AI Reader

FPT.AI Reader là ứng dụng nhận dạng và số ảnh mẫu và nhập vào một số trường thông tin quan trọng muốn trích xuất từ ảnh để huấn luyện mô hình OCR (minh họa ở Hình 4).

FPT.AI Reader cũng cho phép tích hợp ứng dụng OCR vào hệ thống của doanh nghiệp thông qua việc đăng ký tài khoản và nhận “API key” từ bảng điều khiển của FPT.AI (Console.fpt.ai). Mỗi API key này cho phép gửi và nhận kết quả đến 50 lần và có thể được mở rộng tùy vào quy mô xử lý dữ liệu của hệ thống.

####  Viettel OCR

Viettel OCR là giải pháp được phát triển bởi bộ phận Trí tuệ nhân tạo của Tập đoàn Viettel, cho phép chuyển đổi tài liệu dạng ảnh (máy quét, máy ảnh, file PDF được chuyển hóa từ file ảnh) thành văn bản như file text (.txt), file Word (.docx). Theo báo cáo trên trang web chính thức, Viettel OCR có khả năng nhận diện văn bản ở dạng bố cục tự do (free layout), có thể tùy chỉnh một cách nhanh chóng để phù hợp với từng bài toán cụ thể của doanh nghiệp. Giải pháp này có thể nhận file đầu vào ở nhiều định dạng khác nhau như PNG, JPEG, cho phép phân tích và trả về kết quả cho nhiều hình ảnh cùng 1 lúc (tối đa 10 ảnh) với độ chính xác tương đối cao (trong báo cáo không ghi rõ độ chính xác). Tuy nhiên trên website chính thức của giải pháp này chưa cho phép người dùng thử nghiệm mà phải liên hệ với tổng đài để đặt lịch tư vấn trực tiếp (Viettel AI, 2021).

#### Google Vision AI

Google Vision AI là dịch vụ đám mây của Google cho phép người dùng khởi tạo các ứng dụng phân tích hình ảnh và video trong thời gian ngắn, huấn luyện các mô hình máy học phân loại hình ảnh bằng AutoML hoặc các mô hình tùy chỉnh. Google Vision AI có khả năng phát hiện đối tượng, đọc chữ viết tay và tạo siêu dữ liệu hình ảnh có giá trị bằng các API được đào tạo trước. Một ưu điểm của giải pháp này là dễ dàng tích hợp với BigQuery, Cloud Function và máy ảnh để kích hoạt hành trình từ đầu đến cuối. Google Vision AI là một giải pháp khá linh hoạt, không tạo sẵn các mẫu tài liệu như FPT.AI Reader và Viettel OCR. Tốc độ xử lý của Google Vision AI khá nhanh. Tuy nhiên, quá trình thử nghiệm tính năng OCR của Google Vision AI với một vài tài liệu tiếng Việt cho kết quả chưa tốt (Hình 5).

#### Lựa chọn giải pháp

Ngoài 3 giải pháp thương mại kể trên, một số doanh nghiệp công nghệ ở Việt Nam cũng cung cấp các gói dịch vụ số hóa tài liệu với giải pháp riêng mà họ xây dựng. Tuy nhiên qua quá trình tìm hiểu và trải nghiệm, tác giả quyết định lựa chọn FPT. AI Reader làm giải pháp thử nghiệm trong bài báo này với các nguyên nhân:

FPT.AI Reader cung cấp nền tảng sử dụng miễn phí với tất cả người dùng cuối (end-user), chỉ hạn chế số lượng tài liệu xử lý mỗi ngày (50 requests) và có thể mở rộng linh hoạt tùy vào quy mô của doanh nghiệp.

Mô hình OCR huấn luyện sẵn của FPT. AI Reader có khả năng xử lý dữ liệu tiếng Việt tốt (theo báo cáo của FPT.AI đạt trên 96% cho các loại giấy tờ như chứng minh nhân dân, hộ chiếu (FPT.AI, 2022).

Giải pháp FPT.AI Reader đã được rất nhiều khách hàng sử dụng, đa dạng về ngành nghề lĩnh vực như TP Bank, Home Credit, Tiki, EVN, Sendo (FPT.AI, 2022).

### Thử nghiệm với tài liệu tại Học viện Ngân hàng

#### Thu thập tài liệu

Tác giả chọn lọc từ 150 email cá nhân gần nhất có địa chỉ gửi đến từ các đơn vị của Học viện, trích chọn ra những email có tệp đính kèm là các file pdf. Những file này được chọn lọc để đảm bảo đa dạng về nguồn gốc (Học viện ban hành, cơ quan khác ban hành), về định dạng (scan từ máy quét ra hình ảnh, chuyển đổi từ văn bản MS Word), về thể loại (quyết định, phiếu trình, nghị định, thông báo...). Chi tiết số liệu thống kê về bộ tài liệu thử nghiệm được trình bày trong Bảng 1.

#### Cài đặt giải pháp

Giải pháp OCR của FPT.AI được truy cập trên nền tảng điện toán đám mây tại địa https:// reader.fpt.ai/. Để tạo ứng dụng mới, FPT.AI Reader cho phép ta chọn trong thư viện những mẫu văn bản có sẵn hoặc tạo ứng dụng tùy chỉnh. Trong thư viện các văn bản có sẵn đã bao gồm:

  * Giấy tờ tài chính ngân hàng (như Báo cáo tài chính, Đăng ký kinh doanh...);

  * Giấy tờ bảo hiểm và bệnh viện (Giấy ra viện, Phiếu khám, Bảng kê viện phí...);

  * Giấy tờ quốc tế (Giấy đăng ký xe, Bằng lái xe của một số nước);

  * Giấy tờ tùy thân Việt Nam;

  * Giấy tờ khác (Sơ yếu lý lịch, Giấy tờ vận tải, Giấy chứng nhận, Vé máy bay).


Nhận thấy các mẫu văn bản có sẵn trong thư viện không phù hợp với các văn bản trong bộ dữ liệu thử nghiệm, tác giả lựa chọn cài đặt ứng dụng tùy chỉnh. Có 3 mô hình có thể lựa chọn là Bóc tách dữ liệu (từ văn bản có cấu trúc), Mô hình Crop (phát hiện vùng ảnh cần quan tâm) và Phân loại (Gán nhãn phù hợp cho văn bản), tác giả chọn mô hình Bóc tách dữ liệu và sử dụng mô hình Bóc tách dữ liệu OCR có sẵn của FPT.AI chứ không huấn luyện mô hình mới, công việc này sẽ dành cho nghiên cứu trong tương lai với lượng dữ liệu chuẩn bị nhiều và đa dạng hơn.

Trong phần sử dụng mô hình, ta chọn Tải lên để tải văn bản muốn bóc tách, có thể chọn nhiều văn bản cùng lúc, đợi đến khi trạng thái của tất cả văn bản hiện “Thành công” để xem kết quả (minh họa ở Hình 6). Để xem kết quả chi tiết của mỗi tài liệu, ta chọn View ở phần OCR. Một cửa sổ khác sẽ hiện lên hiển thị toàn bộ các trường dữ liệu bóc tách được từ văn bản đầu vào (Hình 7). Trong cửa sổ này ta có thể xem được chi tiết mô hình đã phát hiện được bao nhiêu “box” (vùng ảnh) chứa chuỗi ký tự có thể là văn bản. Click vào chi tiết mỗi box, ta có thể đánh dấu giá trị văn bản phát hiện được trong đó là sai hay đúng, thuộc loại nào (trong trường hợp này chưa định nghĩa loại box nên không hiển thị).

####  Phương pháp đánh giá

Với kết quả nhận được từ ứng dụng vừa xây dựng, tác giả đánh giá bằng cả phương pháp định lượng và định tính theo các tiêu chí sau:

Số box phát hiện được có đúng không (có bỏ sót hay phát hiện thừa vùng ảnh nào hay không).

Tỷ lệ sai số theo đơn vị từng từ ở mỗi box (chẳng hạn mô hình dự đoán “Học viện Ngan hàng” so với kết quả đúng là “Học viện Ngân hàng” thì sai số là 25%). Do số lượng từ là quá lớn nên tác giả chỉ thống kê trên trang đầu của mỗi văn bản để kiểm tra những thông tin quan trọng nhất.

Phân tích các trường hợp sai thường gặp theo từng loại văn bản.

#### Kết quả thực nghiệm

Với các tiêu chí kể trên, mô hình của FPT.

AI Reader cho kết quả rất tốt. Cụ thể:

Số box phát hiện được có độ chính xác 98%, không bỏ sót box nào trên các tài liệu. Tuy nhiên một số box bị thừa, đặc biệt là các box ở vùng ảnh chứa con dấu đỏ.

Tỷ lệ sai số khá ấn tượng: 27% với 210 từ bị sai trên tổng số 781 từ (chỉ tính những trang đầu của 20 tài liệu).

Các lỗi sai thường gặp chủ yếu là lỗi dấu câu (“Hoc”- “Học”, “Xã hồi”- “Xã hội”...), viết hoa (“đơn VI”- “đơn vị”), và các số quyết định trên phần đầu của văn bản (do là số viết tay).

Các văn bản được chuyển đổi từ file MS Word có tỷ lệ sai số thấp hơn hẳn (trong thực tế những file này có thể chuyển đổi trực tiếp về lại dạng văn bản với các thư viện lập trình phù hợp).

Các trường thông tin quan trọng như đơn vị ban hành văn bản, loại văn bản (thông báo, nghị định, quyết định...), chủ đề phụ của văn bản (về việc điều động, về việc tổ chức...) và đối tượng nhận văn bản có tỷ lệ sai số thấp hơn trung bình chỉ 16%.

Thời gian xử lý của mô hình FPT.AI Reader cũng tương đối nhanh, theo quan sát thực tế, mỗi văn bản 3 trang tốn khoảng trên dưới 5 giây để hoàn thành. Trong thực tế, số trang và dung lượng của văn bản có thể đa dạng và lớn hơn, nhưng để đáp ứng nhu cầu số hóa cơ bản, tức là bóc tách được các trường thông tin quan trọng (thường nằm ở trang đầu văn bản) thì có thể có biện pháp tiền xử lý trước khi đưa vào mô hình.

##  Kết luận và hướng phát triển

### Kết luận

Trong bài báo này, tác giả đã nêu tầm quan trọng của việc số hóa dữ liệu, khảo sát sơ bộ thực trạng số hóa tài liệu văn bản tại Học viện Ngân hàng. Qua đó tác giả đặt ra 4 mục tiêu nghiên cứu và đã giải quyết lần lượt từng mục tiêu. Có thể tóm tắt một số đóng góp chính của bài báo như sau:

Giới thiệu các công nghệ cốt lõi như nhận dạng ký tự quang học (OCR), nhận dạng dấu quang học (OMR), xử lý văn bản thông minh (IDP) và những ứng dụng trên nhiều lĩnh vực của các công nghệ này.

Tìm hiểu và khảo sát một số giải pháp thương mại cho số hóa tài liệu phổ biến ở Việt Nam như FPT.AI Reader, ViettelOCR, Google Vision AI. Trên cơ sở đó tác giả so sánh đánh giá và lựa chọn FPT.AI Reader để cài đặt ứng dụng thử nghiệm tại Học viện Ngân hàng.

Thu thập dữ liệu văn bản từ 150 email nội bộ của Học viện, chọn lọc 20 file pdf đính kèm trong các email đó sao cho đảm bảo có các loại văn bản khác nhau, các định dạng khác nhau và các phòng ban phụ trách khác nhau.

Cài đặt thử nghiệm hệ thống OCR trên nền tảng FPT.AI Reader để áp dụng với bộ dữ liệu văn bản vừa thu thập. Kết quả thử nghiệm cho thấy mô hình nhận dạng ký tự của FPT.AI hoạt động khá tốt với 27% sai số ở mức từ và thời gian xử lý chỉ khoảng 5 giây cho mỗi văn bản 3 trang, chỉ tồn tại một vài sai số ở những ký tự viết tay hoặc bị mờ do chất lượng scan tài liệu.

### Hướng phát triển

Với kết quả thử nghiệm trình bày như trên, tác giả đề xuất Học viện Ngân hàng đẩy mạnh áp dụng các công nghệ mới cho quá trình số hóa dữ liệu, đặc biệt là dữ liệu văn bản. Giải pháp của FPT.AI tuy còn một số tồn tại, sai số, nhưng có thể được cải thiện bằng cách huấn luyện hoặc tinh chỉnh mô hình OCR với bộ dữ liệu đầy đủ và đa dạng hơn của Học viện. Điều này sẽ cần các nghiên cứu chuyên sâu về công nghệ OCR trong tương lai. ■

# TÀI LIỆU THAM KHẢO

Akabot (2022), Sự khác biệt giữa OCR và IDP, Truy cập ngày 20 tháng 4 năm 2023, từ https://akabot.com/vi/tai-nguyen/ blog/su-khac-biet-giua-ocr-va-idp/

ALS (2021), Quy trình các bước số hóa tài liệu lưu trữ doanh nghiệp, Truy cập ngày 20 tháng 4 năm 2023, từ https://als. com.vn/quy-trinh-cac-buoc-so-hoa-tai-lieu-luu-tru-doanh-nghiep

Duc Phan Van Hoai, Huu-Thanh Duong, Vinh Truong Hoang (2021), “Text recognition for Vietnamese identity card based on deep features network”, International Journal on Document Analysis and Recognition (IJDAR), số 24, trang 123–131.

FPT.AI (2022), FPT.AI Reader - Vietnamese Passport Recognition, Truy cập ngày 20 tháng 4 năm 2023, từ https://docs. fpt.ai/docs/en/vision/documentation/license-recognition

FPT.AI (2022), “FPT AI Read - Trích xuất dữ liệu vượt mọi giới hạn”, Truy cập ngày 20 tháng 4 năm 2023, từ https:// fpt.ai/vi/reader

FPT.AI (2022), Hướng dẫn sử dụng FPT.AI Reader - phần mềm ocr trích xuất thông tin từ ảnh chụp, Truy cập ngày 20 tháng 4 năm 2023, từ https://fpt.ai/vi/huong-dan-su-dung-fptai-reader-phan-mem-ocr-trich-xuat-thong-tin-tu-anh-chup

Geewook Kim, Teakgyu Hong, Moonbin Yim, JeongYeon Nam, Jinyoung Park, Jinyeong Yim, Wonseok Hwang, Sangdoo Yun, Dongyoon Han, Seunghyun Park (2022), “OCR-Free Document Understanding Transformer”, Computer Vision – ECCV, số 13688, trang 498–517.

Học viện Ngân hàng (2023), Tờ trình số 694/TTr-HVNH ngày 28/3/2023 Kế hoạch Chuyển đổi số tại Học viện Ngân hàng. Krisana Chinnasarn, Yuttapong Rangsanseri (1999), “Image-processing-oriented optical mark reader”. Applications of Digital Image Processing XXII, số 3808.

Noman Islam, Zeeshan Islam,Nazia Noor (2016), “A Survey on Optical Character Recognition System”, Journal of Information & Communication Technology-JICT, số 10, trang 1-4

Phạm Huy Giao (2020), “Chuyển đổi số: Bản chất, thực tiễn và ứng dụng”, Tạp chí Dầu khí, số 12, trang 12-16. Phan Thi Thanh Nga, Nguyễn Thị Huyền Trang, Nguyễn Văn Phúc, Thái Duy Quý, Võ Phương Bình (2017), “Vietnamese

text extraction from book covers”. Tạp chí Khoa học Đại học Đà Lạt”, số 7, trang 142–152.

Ravina Mithe, Supriya Indalkar, Nilam Divekar (2013), “Optical Character Recognition”, International Journal of Recent Technology and Engineering (IJRTE), số 2, trang 72-75.

Raymond Ptucha, Felipe Petroski Such, Suhas Pillai, Frank Brockler, Vatsala Singh, Paul Hutkowski (2019), “Intelligent character recognition using fully convolutional neural networks”, Pattern Recognition, số 88, trang 604-613.

Thủ tướng Chính phủ (2022), Quyết định số 131/QĐ-TTg ngày 25/01/2022 của Thủ tướng Chính phủ: Phê duyệt Đề án “Tăng cường ứng dụng công nghệ thông tin và chuyển đổi số trong giáo dục và đào tạo giai đoạn 2022-2025, định hướng đến năm 2030”

Trần Thị Hương, Ngô Thị Kiều Hằng (2021), “Kỹ thuật nhận dạng biển số xe và ứng dụng vào bài toán quản lý bãi giữ xe tại trường đại học Hà Tĩnh”. Tạp chí Khoa học Đại học Đồng Tháp, số 3, trang 115-120.

Viettel AI (2021), “Nhận dạng ký tự quang học”, Truy cập ngày 20 tháng 4 năm 2023, từ https://viettelgroup.ai/service/ocr

Vu Xuan-Son, Bui Quang-Anh, Nguyen Nhu-Van, Hai Nguyen Thi Tuyet, Vu Thanh (2021), “MC-OCR Challenge:

Mobile-Captured Image Document Recognition for Vietnamese Receipts”, RIVF International Conference on Computing and Communication Technologies, IEEE, trang 1-6.

# Public_006

# Nội dung chính

## Giới thiệu

“Trong bối cảnh cách mạng công nghệp 4.0, các trường đại học trên thế giới đã nắm bắt và chuyển đổi số” [1] các hoạt động của mình. Điều đó “đặt ra yêu cầu… phải thay đổi theo mô hình quản trị đại học tiên tiến” [2]. “Mô hình này phù hợp với xu hướng tự chủ cao trong tổ chức bộ máy và điều hành”. Theo đó, các trường đại học Việt Nam “cần phát huy tinh thần chủ động, đổi mới, sáng tạo” [3]. Đổi mới cấu trúc, bộ máy quản trị [4], ứng dụng công nghệ trong quản trị để tối đa hoá hiệu quả hoạt động nhà trường [5]. Tăng cường ứng dụng công nghệ thông tin nâng cao chất lượng dạy, học, chuyển giao khoa học - công nghệ [6]; chuyển đổi số trong quản lý, điều hành, hỗ trợ ra quyết định nhanh, chính xác [7]. Nhờ đó, các trường đại học Việt Nam đã chuyển từ thế bị động sang thế chủ động ứng dụng công nghệ trong nhà trường và đạt nhiều thành tựu trong các mặt công tác [8]-[11]. Như vậy, hiện có nhiều công trình đề cập đến một khía cạnh nào đó của vấn đề nghiên cứu. Bài báo này tập trung làm rõ nội dung, thực trạng, giải pháp ứng dụng công nghệ số trong quản trị đại học nhằm tận dụng tối đa cơ hội thời đại số, nâng cao vị thế, vai trò đại học Việt Nam hiện nay.

## Phương pháp nghiên cứu

Để hoàn thành mục tiêu nghiên cứu, tác giả sử dụng các phương pháp nghiên cứu chủ yếu như: phương pháp tổng hợp, phân tích và xử lý số liệu thông qua các tư liệu, số liệu thứ cấp để hệ thống hoá những nội dung lý luận liên quan, phân tích thực trạng và đề xuất các giải pháp ứng dụng công nghệ số trong công tác quản trị đại học nhằm thúc đẩy quá trình xây dựng đại học số ở Việt Nam hiện nay.

## Kết quả và bàn luận

### Một số vấn đề về ứng dụng công nghệ số trong quản trị đại học ở Việt Nam

#### Quan niệm về quản trị đại học và công nghệ số

Công tác quản trị có vai trò quan trọng, quyết định sự thành công của cơ quan, tổ chức. Quản trị tốt sẽ tạo ra hệ thống các thiết chế, nguyên tắc quản lý, điều hành tốt bộ máy, sự phối hợp hiệu quả các nguồn lực tổ chức để đạt mục tiêu phát triển. Ở trường đại học, nơi nguồn vốn đặc trưng là con người, với sản phẩm quan trọng là nhân lực, tri thức khoa học, công nghệ... thì công tác quản trị càng trở nên quan trọng. Quản trị khoa học, hiệu quả sẽ khơi dậy tiềm năng, khuyến khích các chủ thể phát triển, tạo ra và phát huy hiệu quả các nguồn lực của nhà trường. Đó là bí quyết, là lợi thế cạnh tranh của các trường đại học trong bối cảnh hiện nay. Quản trị yếu kém sẽ hủy hoại giá trị, môi trường làm việc, kìm hãm sự phát triển của nhà trường.

Trên cơ sở kế thừa các quan niệm về quản trị đại học, có thể khái quát: Công tác quản trị đại học là một hệ thống được thiết lập và thực hiện trong các nhà trường phù hợp với sự phát triển kinh tế - xã hội. Đó là quá trình “hoạch định, tổ chức, điều khiển và kiểm soát cũng như những nỗ lực khai thác mọi tài nguyên để hoàn thành các mục tiêu đã định của nhà trường một cách có hiệu quả” [2, tr.68]. Nó dựa trên nguyên lý đảm bảo các trường đại học thực hiện thành công sứ mệnh đã cam kết, đảm bảo hiệu quả các hoạt động, đáp ứng tốt nhất yêu cầu của các chủ thể liên quan. Trong đó, các nguyên lý quản trị thực hiện theo quy trình hoặc dựa vào kết quả đầu ra với tiêu chí cụ thể để các bên liên quan giám sát hoạt động của nhà trường. Bên cạnh đó, công tác này cũng phải tuân theo các nguyên tắc mang tính bắt buộc do cơ quan quản lý nhà nước, cơ quan chủ sở hữu ban hành, đảm bảo sự minh bạch, công bằng trong công tác lãnh đạo, quản lý, điều hành hoạt động của trường đại học.

Tại Việt Nam, Luật số 34/2018 - Luật Giáo dục đại học sửa đổi và bổ sung; Nghị định số 99/2019 đã quy định rõ nhiệm vụ, quyền hạn của các thiết chế quản trị, quản lý cơ sở giáo dục đại học. Theo đó, Hội đồng trường là cơ quan có thẩm quyền cao nhất, có quyền quyết định các vấn đề lớn, các quy định nội bộ chủ yếu, các vị trí quan trọng của cơ sở giáo dục đại học. Chủ tịch Hội đồng trường là người đứng đầu cơ quan có thẩm quyền cao nhất. Hiệu trưởng là người đứng đầu bộ máy hành chính, có trọng trách rất lớn của nhà trường, đại diện lãnh đạo, quản lý, điều hành cấp trường, cùng Ban Giám hiệu với các đơn vị chức năng tham mưu giúp việc thực hiện chức trách, nhiệm vụ dưới sự lãnh đạo của Đảng ủy, Hội đồng trường. Đây là lĩnh vực hành chính chủ yếu và chiếm tỉ trọng khối lượng công việc nhiều nhất trong nhà trường.

Trong bối cảnh cách mạng công nghiệp 4.0, để công tác quản trị tại các trường đại học hiệu quả cao thì một trong những vấn đề quan trọng là tìm ra phương thức quản trị phù hợp. Chuyển đổi số, ứng dụng công nghệ số trong quản trị đại học được coi là phương thức hữu hiệu. Công nghệ số là quá trình thay đổi tổng thể và toàn diện trong cách thức vận hành, tổ chức của một cơ quan, đơn vị dựa trên những thành tựu công nghệ mới như Internet vạn vật, trí tuệ nhân tạo, thực tế ảo, tương tác thực tại ảo, điện toán đám mây, phân tích dữ liệu lớn… Đó là quá trình chuyển đổi toàn diện các hoạt động của con người từ không gian thực lên không gian số để tạo ra phương thức hoạt động mới, cơ hội mới và giá trị mới, tối ưu hóa quy trình, hoạt động của tổ chức cơ quan, đơn vị. Ứng dụng công nghệ số trong công tác quản trị đại học hiệu quả sẽ góp phần nâng cao chất lượng, hiệu quả công tác quản lý, điều hành, nâng cao vị thế, vai trò của trường đại học trong bối cảnh mới.

#### Ứng dụng công nghệ số trong quản trị đại học ở Việt Nam hiện nay

Trong lĩnh vực giáo dục - đào tạo, công nghệ số được ứng dụng mạnh mẽ và có nhiều tác động tích cực. Tận dụng cơ hội chuyển đổi số mang lại, các đại học Việt Nam phải thực hiện rất khẩn trương việc ứng dụng công nghệ số, nhất là trong công tác quản trị. Đó là việc sử dụng thành tựu công nghệ số vào quá trình hoạch định, tổ chức, điều khiển và kiểm soát cũng như những nỗ lực khai thác mọi tài nguyên, nâng cao chất lượng và hiệu quả việc tổ chức phối hợp giữa các đơn vị, các hoạt động của nhà trường để hoàn thành các mục tiêu đã định.

Ứng dụng công nghệ số vào hoạt động quản trị đại học cho phép các nhà quản trị bao quát toàn bộ hoạt động của nhà trường kịp thời, nắm bắt đầy đủ, chính xác, chi tiết thông tin đối tượng quản lý ở mọi thời điểm; tiết kiệm thời gian, nhân lực, vật lực, giảm thiểu phiền hà, hỗ trợ tối đa hoạt động quản trị nhà trường; giúp quản lý, khai thác, phân tích dữ liệu thuận tiện, chính xác. Từ đó, giúp lãnh đạo, quản lý ra quyết sách lãnh đạo, điều hành phù hợp, hiệu quả.

Xuất phát từ yêu cầu hiện đại hóa, tối ưu hoá tổ chức và hoạt động, các trường đại học chú trọng việc ứng dụng công nghệ số vào quản lý, điều hành. Việc ứng dụng này tập trung vào những nội dung cơ bản sau:

  * Ứng dụng công nghệ số trong quản lý, điều hành công tác hành chính như: Số hóa văn bản, hồ sơ, điểm học tập, rèn luyện của sinh viên; chương trình đào tạo; học liệu;...

  * Ứng dụng công nghệ số trong quản lý, khai thác và sử dụng hiệu quả các nguồn lực: Cơ sở vật chất, con người (cán bộ, giảng viên, học viên, sinh viên) và các nguồn lực khác.

  * Ứng dụng công nghệ số trong quản lý đánh giá chất lượng công việc của cán bộ, giảng viên, người lao động trong nhà trường.

  * Ứng dụng công nghệ số trong công tác tuyển sinh, xây dựng hệ thống tuyển sinh số.

  * Ứng dụng công nghệ số trong quản lý, điều hành hoạt động giảng dạy; quản lý, khai thác các thông tin phục vụ hoạt động giảng dạy; đánh giá chất lượng giảng dạy của giảng viên.

  * Ứng dụng công nghệ số trong quản lý, điều hành hoạt động học tập của học viên, sinh viên.

  * Ứng dụng công nghệ số trong quản lý, điều hành nghiên cứu, chuyển giao khoa học - công nghệ; đăng ký, cấp mã số các đề tài nghiên cứu; quản lý đầu ra sản phẩm nghiên cứu khoa học và bảo vệ quyền sở hữu trí tuệ...

  * Ứng dụng công nghệ số trong quản lý, hỗ trợ sinh viên tìm kiếm việc làm; quản lý, đánh giá chất lượng sản phẩm đầu ra của quá trình đào tạo, giúp nhà quản lý điều chỉnh hoạt động, tạo sự liên kết giữa nhà trường - doanh nghiệp - sinh viên; đổi mới chương trình đào tạo, cập nhật công nghệ hiện đại, đào tạo, cung ứng nguồn nhân lực chất lượng theo thị trường.


Như vậy, ứng dụng công nghệ số trong công tác quản trị đại học là xu thế tất yếu và có nội dung bao trùm các hoạt động của nhà trường. Thực hiện tốt giải pháp này giúp các trường đại học

Việt Nam tổ chức, phối hợp giữa các đơn vị thuộc nhà trường hiệu quả hơn, triển khai các hoạt động trên nền tảng số hướng tới xây dựng đại học số, phù hợp với xu thế phát triển đại học.

### Thực trạng ứng dụng công nghệ số trong công tác quản trị tại các trường đại học ở Việt Nam hiện nay

#### Những kết quả đạt được

Thực hiện sự lãnh đạo của Đảng, Nhà nước, việc ứng dụng công nghệ số trong ngành giáo dục đào tạo đã có những thành tựu bước đầu. Đến nay, “toàn ngành đã triển khai số hóa, xây dựng cơ sở dữ liệu dùng chung từ Trung ương đến 63 sở Giáo dục và Đào tạo, 710 phòng và khoảng 53.000 cơ sở giáo dục. Hiện nay đã số hóa và định danh dữ liệu của khoảng 53.000 trường học, 1,4 triệu giáo viên, 23 triệu học sinh. Cơ sở dữ liệu này đã hỗ trợ đắc lực công tác tuyển sinh, thống kê, báo cáo trong toàn ngành; giúp các cấp quản lý ban hành chính sách quản lý hiệu quả, vừa qua đã góp phần giải quyết vấn đề thừa thiếu giáo viên ở các nhà trường theo từng địa phương, môn học… Hệ thống quản lý hành chính điện tử kết nối 63 sở Giáo dục và Đào tạo và hơn 300 trường đại học, cao đẳng trên cả nước với Bộ Giáo dục và Đào tạo hoạt động thông suốt, ổn định, phát huy hiệu quả tích cực” [7].

Trong công tác quản trị đại học, ứng dụng công nghệ số thể hiện ngày càng rõ với việc thực hiện các giải pháp tổ chức, quản lý, điều hành giáo dục trực tuyến; đầu tư phát triển chương trình ứng dụng công nghệ số trong quản lý, giảng dạy, thực hành cho sinh viên, nghiên cứu chuyển giao công nghệ phần mềm… Nhiều trường đã chủ động ứng dụng công nghệ số hiệu quả như: Tại các trường Đại học thành viên của Đại học Thái Nguyên hiện nay đã số hóa khoảng 90% giáo trình giảng dạy, 100% các luận văn, luận án, 40% tài liệu tham khảo; toàn đại học cũng đã xây dựng được hơn 110 bài giảng điện tử. Nhiều hình thức học tập hiện đại như học trực tuyến, từ xa... được thực hiện [8]; Đại học Bách khoa Hà Nội chính thức ra mắt và đưa vào sử dụng Hệ thống quản trị đại học trực tuyến https://e.hust.edu.vn (1 cổng) và app eHUST từ ngày 22/9/2021. Sinh viên và giảng viên có thể truy cập, thực hiện các tác vụ giúp cho công việc, nghiệp vụ giảng dạy; hoạt động học tập, các thủ tục hành chính thuận tiện và hiệu quả hơn [9]. Học viện Công nghệ Bưu chính Viễn thông, 1 trong 5 trường được lựa chọn thực hiện Đề án thí điểm triển khai mô hình đại học số đã đề xuất và vận hành Dịch vụ số, Quản trị số và Xã hội số “make in Việt Nam” [10]... Như vậy, ứng dụng công nghệ số là giải pháp hiệu quả tăng cường nội lực, tính chủ động và góp phần hiện đại hóa giáo dục đại học.

Về hạ tầng công nghệ, phần lớn các trường đại học ở Việt Nam được đầu tư trang bị, nhất là khi phải chuyển sang ứng phó với đại dịch Covid-19 bùng phát. “Đến nay, khoảng 110/240 cơ sở giáo dục đại học đã triển khai đào tạo trực tuyến, với các cấp độ khác nhau. Do đặc thù, nhiều trường thuộc khối văn hóa nghệ thuật chưa tổ chức đào tạo trực tuyến và 33 trường thuộc nhóm quốc phòng - an ninh đang đào tạo tập trung” [11]. Như vậy, các trường đại học đã chủ động về hạ tầng công nghệ, đồng thời còn có sự đồng hành của 11 tập đoàn ICT tham gia hỗ trợ về hạ tầng, giải pháp phần mềm và cước truy cập Internet…

Về mức độ ứng dụng công nghệ số trong quản trị tại các trường đại học ở Việt Nam hiện nay chủ yếu ở các phương diện sau:

Một là, các trường đại học đã triển khai hệ thống thông tin quản lý giáo dục - đào tạo đáp ứng yêu cầu kết nối, liên thông tích hợp, chia sẻ thông tin đối với các đơn vị trực thuộc. Việc này thực hiện chủ yếu trên trang thông tin điện tử, Website của nhà trường. Các văn bản “không mật” được điện tử hóa, công khai trên không gian mạng, giúp các đơn vị trong nhà trường cập nhật thường xuyên, kịp thời, có hệ thống, rút ngắn thời gian xử lý, nâng cao chất lượng chuyên môn, đảm bảo công việc thông suốt, hiệu quả, cung cấp dịch vụ hành chính văn phòng không giấy mọi lúc, mọi nơi tạo sự thuận tiện và hướng tới minh bạch trong công tác quản lý, điều hành.

Hai là, triển khai hệ thống quản lý hành chính điện tử. Trong công tác quản trị văn phòng, từ việc đăng ký văn phòng phẩm, lịch công tác, lên lịch các cuộc họp... đến các tiện ích văn phòng khác được ứng dụng công nghệ thông tin để quản lý. Nhờ đó, công tác hành chính thực hiện kịp thời, hiệu quả. Trong công tác tài chính, các nhà trường đã phối hợp với các đối tác xây dựng hệ thống thanh toán điện tử đã giúp cán bộ, học viên, sinh viên tiết kiệm thời gian, công sức, đảm bảo độ chính xác; trong công tác hội, họp, hội thảo, tập huấn chuyên môn được tổ chức qua mạng, sử dụng ứng dụng trực tuyến, kết nối đa điểm với các giải pháp đảm bảo an toàn thông tin, mã hoá bảo mật. Đây là những giải pháp quan trọng giúp cấp quản lý, điều hành, xử lý công việc mọi lúc, mọi nơi; thông tin nhanh chóng, kịp thời, ra quyết định chính xác. Cán bộ, giảng viên, người học dễ tiếp cận văn bản, tài liệu số hóa phục vụ công việc đảm bảo chất lượng, tiến độ.

Ba là, ứng dụng công nghệ số trong công tác quản lý, điều hành công tác tuyển sinh - tuyển sinh số là phương thức chủ đạo của các trường đại học hiện nay. Nhiều trường đại học hiện có cổng thông tin tuyển sinh, trang thông tin tuyển sinh, hệ thống tuyển sinh tự động… cung cấp đầy đủ thông tin về công tác tuyển sinh, chế độ chính sách, giới thiệu về môi trường, điều kiện học tập và rèn luyện, cơ hội việc làm, cơ hội phát triển năng lực bản thân, liên kết doanh nghiệp, phương thức nộp hồ sơ… giúp học sinh, phụ huynh dễ dàng tra cứu, tìm hiểu, lựa chọn, đăng ký ngành nghề phù hợp năng lực, sở trường, điều kiện kinh tế. Công tác kế hoạch, tuyển sinh, mở lớp, thi cử, hồ sơ tuyển sinh… được giải quyết trực tuyến nhanh, tiện lợi, chính xác.

Bốn là, thực hiện quản lý giảng viên, người học; quản lý thi, thời khóa biểu, sổ quản lý điện tử; tích hợp với trang tin điện tử của nhà trường trên môi trường mạng. Chương trình phục vụ hoạt động quản lý đào tạo đã được xây dựng thành những sản phẩm phần mềm đóng gói, cài trên từng máy tính riêng lẻ hoặc được thiết kế, xây dựng theo mô hình quản lý dữ liệu phân tán có sự phân cấp. Với mô hình này, dữ liệu quản lý được xử lý trên máy chủ nên thông tin về công tác quản lý sinh viên công khai, minh bạch, cụ thể, được chia sẻ trên mạng nội bộ của trường.

Như vậy, nhiều trường đại học đã bước đầu hiện thực hóa mục tiêu đề ra trong Đề án “Tăng cường ứng dụng công nghệ thông tin trong quản lý và hỗ trợ các hoạt động dạy - học, nghiên cứu khoa học góp phần nâng cao chất lượng giáo dục và đào tạo giai đoạn 2016-2020, định hướng đến năm 2025” là: 100% các cơ quan quản lý nhà nước về giáo dục và đào tạo, các cơ sở giáo dục và đào tạo thực hiện quản lý hành chính xử lý hồ sơ công việc trên môi trường mạng; 70% cuộc họp giữa các cơ quan quản lý nhà nước và cơ sở giáo dục và đào tạo được áp dụng hình thức trực tuyến; 70% lớp bồi dưỡng chuyên môn cho giáo viên và cán bộ quản lý giáo dục được thực hiện qua mạng theo phương thức học tập kết hợp; 50% hồ sơ thủ tục hành chính được xử lý trực tuyến tối thiểu mức độ 3, trong đó 30% được xử lý trực tuyến ở mức độ 4.

#### Một số hạn chế

Bên cạnh những kết quả đạt được, việc ứng dụng công nghệ số trong công tác quản trị tại các trường đại học còn nhiều hạn chế. Nghiên cứu thực trạng ứng dụng công nghệ số trong công tác quản trị các trường đại học ở Việt Nam hiện nay, có thể nhận thấy những hạn chế cơ bản như sau:

Một là, về thủ tục hành chính, một số khâu vẫn còn thực hiện bằng phương pháp thủ công, việc số hóa chưa đồng bộ. Việc quản lý văn bản, tiếp nhận, chuyển phát thông tin, báo cáo; quản lý cán bộ giảng viên, cập nhật cơ sở dữ liệu; kiểm soát, theo dõi việc thực hiện các quyết định quản lý, điều hành của cấp trên thực hiện chủ yếu bằng tập hợp và lưu trữ bằng văn bản giấy. Điều này làm mất nhiều thời gian, công sức của lực lượng làm công tác hành chính.

Hai là, vấn đề an toàn thông tin đảm bảo thông tin nhân thân và bản quyền thông tin chưa được coi trọng đúng mức. Thu thập, chia sẻ, khai thác dữ liệu quản lý giáo dục và học liệu số cần hành lang pháp lý chung phù hợp với các quy định về bản quyền tác giả, sở hữu trí tuệ, an ninh thông tin, giao dịch điện tử và luật chia sẻ cung cấp thông tin.

Ba là, chất lượng công tác dự báo còn hạn chế bởi ứng dụng công nghệ như: Big data, AI, Blockchain trong các trường đại học chưa thực sự hiệu quả.

Bốn là, kỹ năng ứng dụng công nghệ số của đội ngũ cán bộ quản lý, hành chính chưa cao và không đồng đều. Mặc dù, trong những năm qua, đội ngũ cán bộ quản lý, hành chính, giảng viên đã tích cực triển khai, ứng dụng công nghệ số trong các hoạt động.

### Một số giải pháp ứng dụng công nghệ số trong công tác quản trị tại các trường đại học ở Việt Nam hiện nay

Đẩy mạnh ứng dụng công nghệ số trong công tác quản trị, hỗ trợ công tác quản trị trở nên toàn diện hơn, khoa học hơn, minh bạch trong bối cảnh cuộc cách mạng công nghiệp 4.0 là tất yếu. Trong đó, tăng cường ứng dụng công nghệ số trong công tác quản trị đại học sẽ góp phần nâng cao năng lực cạnh tranh, uy tín của các trường trên thị trường giáo dục, giúp sinh viên có tăng cơ hội tìm kiếm việc làm, doanh nghiệp có thêm nguồn nhân lực chất lượng cao. Để thực hiện tốt nhiệm vụ này, các trường đại học cần làm tốt các giải pháp sau:

Một là, nâng cao nhận thức của các chủ thể quản trị, nhất là lãnh đạo các trường đại học về tầm quan trọng và quyết tâm ứng dụng công nghệ số trong công tác quản trị đại học. Đó là nhân tố quyết định việc ứng dụng công nghệ số, thúc đẩy chuyển đổi số trong công tác quản trị tại các trường đại học hướng tới xây dựng đại học số đáp ứng yêu cầu phát triển của xã hội. Từ nhận thức đúng đắn, các chủ thể lãnh đạo, quản lý đại học sẽ đề ra các chủ trương và giải pháp tận dụng tối đa hiệu quả thành tựu công nghệ số, tận dụng cơ hội, đồng thời vượt qua các thách thức của thời đại số trong việc thực hiện sứ mệnh của trường đại học.

Hai là, các trường đại học cần chủ động huy động và sử dụng hiệu quả nguồn ngân sách trong và ngoài nhà trường, tập trung xây dựng hệ thống thông tin kết nối liên thông giữa trường đại học với các tổ chức chính trị - xã hội trong, ngoài nước và với doanh nghiệp. Bởi, triển khai ứng dụng công nghệ số trong quản trị tại các trường đại học đòi hỏi nguồn lực đầu tư lớn nên ngoài việc chủ động, các trường cần phải phát huy năng lực hợp tác với các tổ chức, doanh nghiệp để huy động tối đa nguồn lực nhất là nguồn lực tài chính và hạ tầng công nghệ. Triển khai các hoạt động trong môi trường số thành công, các trường đại học phải dựa trên nền tảng cơ sở hạ tầng hiện đại, có khả năng mở rộng và cập nhật công nghệ mới, công nghệ thông minh cần được tích hợp… Các nền tảng này được kết nối, liên thông với nhau dựa trên công nghệ truyền thông điện toán đám mây hiện đại với những giao thức như: Wifi, viễn thông (5G/4G), mạng Internet nội bộ để hướng tới xây dựng môi trường IoT và tính toán đám mây hiện đại. Khi đó, nó sẽ tạo điều kiện cho việc chia sẻ, thống nhất các cơ sở dữ liệu phục vụ công tác quản trị trong nhà trường, tạo điều kiện cho việc phân tích dữ liệu lớn hỗ trợ Ban Lãnh đạo nhà trường có cái nhìn tổng quát. Thực hiện tốt giải pháp này cần phải có cơ chế, chính sách cho sự hợp tác giữa các trường đại học và các tổ chức, doanh nghiệp.

Ba là, xây dựng chế độ, chính sách đối với nhân lực công nghệ số để thu hút được nhân lực có chất lượng làm việc cho các trường đại học, khuyến khích họ gắn bó, làm việc lâu dài. Nhà nước và các trường đại học cần có chính sách, chế độ ưu đãi về thu nhập, các ưu đãi khác như: học tập, hội nghị, hội thảo trong và ngoài nước, tham gia các đề tài, dự án…

Bốn là, tăng cường hợp tác quốc tế, tranh thủ sự giúp đỡ của các nước trong việc củng cố hạ tầng công nghệ số, nguồn lực công nghệ số cũng như công tác đào tạo, bồi dưỡng nhân lực công nghệ số chất lượng cao.

Năm là, xây dựng, triển khai hiệu quả các dịch vụ số trong công tác quản lý, điều hành nhà trường. Trên nền tảng liên thông toàn bộ dữ liệu, các dịch vụ lõi hỗ trợ hiệu quả công tác quản lý, điều hành cơ bản trong nhà trường phải được xây dựng, triển khai như: Hệ thống quản lý nhân sự: quản lý thông tin hồ sơ nhân lực hỗ trợ Lãnh đạo các cấp ra quyết định, bố trí, sắp xếp công tác nhân sự; hệ thống quản lý tài chính: quản lý công tác tài chính kế toán, hỗ trợ Ban lãnh đạo các cấp ra quyết định, phê duyệt kinh phí hoạt động; hệ thống quản lý cơ sở vật chất: quản lý cơ sở vật chất góp phần xác định hiện trạng sử dụng và nhu cầu trang cấp cho các nhu cầu sử dụng cơ sở vật chất trong nhà trường; hệ thống quản lý nghiên cứu khoa học: quản lý công tác đăng ký, thực hiện các nhiệm vụ nghiên cứu khoa học; Các hệ thống quản lý đào tạo và đào tạo trực tuyến: quản lý thời khóa biểu, văn bằng, chứng chỉ, công tác giáo vụ, khảo thí và đảm bảo chất lượng đào tạo, giờ giảng, LMS/CMS,…; hệ thống tuyển sinh số: hỗ trợ công tác tuyển sinh, thống kê, đưa ra khuyến nghị phù hợp để lãnh đạo ra quyết định, phê duyệt chỉ tiêu, ngành nghề theo xu hướng xã hội; hệ thống quản lý công việc: quản lý thông tin giao việc, tiến độ, kết quả công việc, nhiệm vụ được giao cho cán bộ, giảng viên; hệ thống quản lý công tác đối ngoại: quản lý thông tin các đối tác của nhà trường, hỗ trợ đưa ra quyết sách đối ngoại cho sự phát triển mở rộng của nhà trường; hệ thống tổng hợp/hỗ trợ ra quyết định cho lãnh đạo: Kết hợp khả năng liên thông dữ liệu toàn trường và công nghệ phân tích dữ liệu lớn sẽ hỗ trợ cho các cấp lãnh đạo nhà trường ra quyết định dựa trên chức năng khuyến nghị, gợi ý của trợ lý ảo. Ngoài ra còn có các phần mềm hỗ trợ đắc lực cho các chức năng như nhắc việc, tính KPI, thi đua khen thưởng,…

Như vậy, ứng dụng công nghệ số sẽ giúp tối ưu hóa các hoạt động của nhà trường trên môi trường số khi công nghệ hóa toàn bộ tiến trình dạy và học, tự động hóa quy trình nghiệp vụ, quản lý, mở rộng đối tượng, năng lực, phạm vi giảng dạy, nâng cao chất lượng, hiệu quả đào tạo… Đây là cách thức hiệu quả để đại học phát huy vai trò phát triển kinh tế số bền vững ở Việt Nam. Tuy nhiên, ứng dụng công nghệ số trong công tác quản trị đại học đòi hỏi nguồn lực rất lớn khi tiến hành triển khai và phải thực hiện đồng bộ các giải pháp nêu trên.

## Kết luận

Trong kỷ nguyên số, ứng dụng công nghệ số trong công tác quản trị đại học là yêu cầu cấp thiết nhằm nâng cao hơn nữa chất lượng và hiệu quả công tác quản trị trong bối cảnh mới và phù hợp với quá trình chuyển đổi số hiện nay. Ứng dụng công nghệ số hiệu quả là một trong những giải pháp tăng cường nội lực, tính chủ động, góp phần hiện đại hóa giáo dục đại học, xây dựng thành công đại học số - mô hình Đại học mà toàn bộ nội dung và hoạt động của nhà trường được đưa lên môi trường số thông qua các nền tảng số và các phương tiện kỹ thuật số. Để đạt được mục tiêu này, cần sự quan tâm, chỉ đạo sát sao từ lãnh đạo cấp chiến lược và sự vào cuộc mạnh mẽ của Ban Lãnh đạo các trường đại học, của đội ngũ giảng viên, cán bộ quản lý và đội ngũ sinh viên, chủ thể của quá trình xây dựng và phát triển của các trường đại học.

# TÀI LIỆU THAM KHẢO/ REFERENCES

V. T. Phung, “Digital transformation in university governance: International and Vietnamese

experience,” In Smart Governance in a Global Complex Environment: Theory and Practice: Publishing company Ha Noi national university, 2021, pp. 451-474.

T. V. Dinh, “The change in governance approach of universities in the context of innovation start-up,”

Industry and Trade Magazine, no. 1, pp. 207-212, January 2020.

T. V. Dinh, “Research on the Model of Entrepreneurial University and Advanced University

Governance: Policy Recommendations for Public Universities in Vietnam,” VNU Journal of Science: Policy and Management Studies, vol. 37, no. 1, pp. 62-73, 2021.

H. T. T. Pham, G. H. T. Nguyen, A. M. T. Vu, and Q. N. Hoang, "Higher Education Governance - International Experience and Lessons for Vietnam," VNU Journal of Science: Education Research, vol. 35, no. 3, pp. 32-45, 2019.

S. M. Hoang, H. T. T. Bui, and G. H. T. Nguyen, “University model in the context of the industrial revolution 4.0,” Proceedings of International conference New issues in educational sciences: Inter-disciplinary and cross-disciplinary approaches, Hanoi, June 2019, pp. 37-46.

T. D. Do, “Implementing information technology in university management and scientific research to meet new requirements of the market economy,” 2020. [Online]. Available: http://hvcsnd.edu.vn/nghien-cuu-trao-doi/dai-hoc-40/ung-dung-cong-nghe-thong-tin-trong-quan-tri-dai-hoc-nham-dap-ung-yeu-cau-doi-moi-cua-nen-kinh-te-thi-truong-6231. [Accessed Dec. 28, 2022].

H. N. To, “Digital transformation in education and training: Current situation and solutions | People's Police

Academy,” 2020. [Online]. Available: http://hvcsnd.edu.vn/nghien-cuu-trao-doi/dai-hoc-40/chuyen-doi-so-trong-linh-vuc-giao-duc-va-dao-tao-thuc-trang-va-giai-phap-6886. [Accessed Dec. 29, 2022].

P. Hung and D. Son, “Digital Transformation in Universities in Thai Nguyen,” 2020. [Online]. Available: https://thainguyentv.vn/chuyen-doi-so-trong-cac-truong-dai-hoc-o-thai-nguyen-82638.html. [Accessed Feb. 17, 2023].

Hanoi university of science and Technology, “Hanoi Polytechnic promotes digital transformation,”

2022\. [Online]. Available: https://www.hust.edu.vn/tin-tuc/-/asset_publisher/AKFI5qRls1e8/content/ bach-khoa-ha-noi-day-manh-chuyen-soi-so-coi-sinh-vien-la-trung-tam. [Accessed Feb. 17, 2023].

Posts and telecommunicasions institule of Technology, “The first digital university in Vietnam: A miniature digital country,” 2020. [Online]. Available: https://portal.ptit.edu.vn/dai-hoc-so-dau-tien-tai-viet-nam-quoc- gia-so-thu-nho/. [Accessed Feb. 16, 2023].

Ministry of Education and Training, “Pioneer university to promote digital transformation of education,” 2020. [Online]. Available: https://moet.gov.vn/tintuc/Pages/phong-chong-nCoV.aspx?ItemID=6615. [Accessed Dec. 29, 2022].

# Public_007

# Nội dung tiêu chuẩn

## Phạm vi

Tài liệu này quy định các yêu cầu về chất lượng và năng lực của các phòng xét nghiệm y tế.
Tài liệu này được áp dụng cho các phòng xét nghiệm y tế trong việc phát triển hệ thống quản lý và đánh giá năng lực của họ. Tài liệu này cũng được áp dụng để xác nhận hoặc công nhận năng lực của các phòng xét nghiệm y tế bởi người sử dụng phòng xét nghiệm, cơ quan quản lý và cơ quan công nhận.
Tài liệu này cũng có thể áp dụng cho xét nghiệm tại chỗ (POCT).
CHÚ THÍCH: Các quy định hoặc yêu cầu quốc tế, quốc gia hoặc khu vực cũng có thể áp dụng cho các chủ đề cụ thể được đề cập trong tài liệu này.

## Tài liệu tham khảo

Các tài liệu sau đây được đề cập trong văn bản theo cách mà một số hoặc tất cả nội dung của chúng cấu thành các yêu cầu của tài liệu này. Đối với tài liệu ghi năm công bố thì áp dụng bản được nêu. Đối với các tài liệu tham khảo không ghi năm công bố, ấn bản mới nhất (bao gồm mọi sửa đổi) sẽ được áp dụng.
ISO / IEC Guide 99: 2007, _Từ vựng quốc tế về đo lường - Các khái niệm cơ bản và chung và các thuật ngữ liên quan (VIM)_
CHÚ THÍCH: ISO/IEC Guide 99 còn được gọi là Ủy ban hỗn hợp về hướng dẫn đo lường (JCGM) 200.
ISO/IEC 17000:2020, _Đánh giá sự phù hợp — Từ vựng và nguyên tắc chung_
ISO / IEC 17025: 2017, _Yêu cầu chung về năng lực của các phòng thử nghiệm và hiệu chuẩn_

## Thuật ngữ và định nghĩa

Đối với mục đích của tài liệu này, các thuật ngữ và định nghĩa được đưa ra trong ISO/IEC Guide 99 và ISO/IEC 17000 và những điều sau đây sẽ được áp dụng.
ISO và IEC duy trì cơ sở dữ liệu thuật ngữ để sử dụng trong tiêu chuẩn hóa tại các địa chỉ sau:

  * Nền tảng ISO trực tuyến: có sẵn tại [_https://www.iso.org/obp_](https://www.iso.org/obp)

  * IEC Electropedia: có sẵn tại [_https://wwwelectropedia.org/_](https://wwwelectropedia.org/)


### Độ chệch (bias) - ước lượng độ chệch

ước lượng sai số của hệ thống đo lường

### Khoảng tham chiếu sinh học - khoảng tham chiếu

phân bố các giá trị được lấy từ quần thể tham chiếu sinh học

CHÚ THÍCH 1: Khoảng tham chiếu thường được định nghĩa là khoảng tập trung 95%. Độ rộng hoặc giá trị trung bình của khoảng tham chiếu có thể có thể khác nhau trong các trường hợp cụ thể.

CHÚ THÍCH 2: Khoảng tham chiếu có thể phụ thuộc vào loại mẫu ban đầu (3.25) và quy trình xét nghiệm (3.9) được sử dụng.

CHÚ THÍCH 3: Trong một số trường hợp, chỉ một giới hạn quy tham sinh học là quan trọng, thường là giới hạn trên, “x”, sao cho khoảng tham chiếu sinh học tương ứng sẽ nhỏ hơn hoặc bằng “x”.

CHÚ THÍCH 4: Các thuật ngữ như: “phạm vi bình thường”, “giá trị bình thường” và “phạm vi lâm sàng” là không rõ ràng và do đó không được khuyến khích.

[NGUỒN: ISO 18113-1: 2022, 3.1.9, sửa đổi - VÍ DỤ đã bị xóa.]

### Giới hạn quyết định lâm sàng

_Kết quả xét nghiệm_ cho thấy rủi ro cao hơn về kết quả lâm sàng bất lợi hoặc được chẩn đoán cho sự hiện diện của một bệnh cụ thể.

CHÚ THÍCH 1: Giới hạn quyết định lâm sàng đối với thuốc điều trị được gọi là "phạm vi điều trị".

CHÚ THÍCH 2: Nó được sử dụng để xác định nguy cơ mắc bệnh, để chẩn đoán hoặc điều trị.

### Tính chất có thế thay đổi của vật liệu tham chiếu - Tính chất có thể thay đổi

Vật liệu tham chiếu có thể được thể hiện bằng mức độ gần giống nhau giữa các kết quả đo đối v ới một đại lượng đã nêu trong vật liệu này, thu được theo hai quy trình đo đã cho và thu được giữa các kết quả đo đối với các vật liệu được chỉ định khác

CHÚ THÍCH 1: Vật liệu chuẩn được đề cập thường là chất hiệu chuẩn và các vật liệu quy định khác thường là các mẫu thông thường.

CHÚ THÍCH 2: Thông thường có nhiều hơn hai thủ tục đo sẵn có và việc so sánh giữa tất cả các thủ tục đo có thể áp dụng là điều nên làm.

CHÚ THÍCH 3: Độ gần giống nhau của các kết quả đo được xác định theo tính phù hợp với mục đích phù hợp với mục đích sử dụng dự kiến của mẫu chuẩn.

CHÚ THÍCH 4: Tuyên bố về tính có thể hoán đổi được giới hạn trong các quy trình đo như được quy định trong một so sánh cụ thể.

[NGUỒN: ISO 17511: 2020 3.10, được sửa đổi - Chú thích 2 cho mục nhập đã được thay thế bằng Chú thích 2 mới cho mục nhập.]

### Năng lực

thể hiện khả năng áp dụng kiến thức và kỹ năng để đạt được kết quả như mong muốn

[NGUỒN: ISO / IEC 17021-1: 2015, 3.7, được sửa đổi - "đã được chứng minh" được thêm vào đầu định nghĩa.]

###  Khiếu nại

thể hiện hiện sự không hài lòng của bất kỳ cá nhân hoặc tổ chức nào đối với phòng xét nghiệm (3.20), liên quan đến các hoạt động hoặc kết quả của phòng xét nghiệm đó, nơi dự kiến sẽ có phản hồi

[NGUỒN: ISO/IEC 17000:2020, 8.7, được sửa đổi — Cụm từ “khác với khiếu nại” đã bị xóa và cụm từ “tổ chức đánh giá sự phù hợp hoặc tổ chức công nhận, liên quan đến các hoạt động của tổ chức đó” đã được thay thế bằng “ một phòng xét nghiệm, liên quan đến các hoạt động hoặc kết quả của phòng xét nghiệm đó”.

### Tư vấn viên

người cung cấp lời khuyên chuyên môn một cách chuyên nghiệp

### Xét nghiệm

Tập hợp các thao tác để xác định giá trị, hoặc đặc trưng của một thuộc tính

CHÚ THÍCH 1: Việc kiểm tra có thể là tổng số các hoạt động, quan sát hoặc phép đo được yêu cầu để xác định một giá trị hoặc đặc tính.

CHÚ THÍCH 2: Các xét nghiệm trong phòng xét nghiệm để xác định giá trị bằng số được gọi là "xét nghiệm định lượng"; những xét nghiệm để xác định đặc tính được gọi là "xét nghiệm định tính".

CHÚ THÍCH 3: Xét nghiệm trong phòng xét nghiệm còn được gọi là "phân tích" hoặc "kiểm tra".

### Quy trình xét nghiệm

CHÚ THÍCH 1: Trong ngành thiết bị y tế IVD và trong nhiều phòng xét nghiệm sử dụng thiết bị y tế IVD, quy trình xét nghiệm chất phân tích trong mẫu sinh học thường được gọi là phương pháp phân tích, quy trình phân tích hoặc quy trình xét nghiệm.

[NGUỒN: ISO 15198:2004, 3.7, được sửa đổi - “tập hợp các thao tác được mô tả cụ thể” được thay đổi thành “tập hợp các thao tác được mô tả cụ thể”.]

### Đánh giá chất lượng bên ngoài - EQA

CHÚ THÍCH 1: Còn được gọi là thử nghiệm thành thạo (PT)

[NGUỒN: ISO/IEC 17043:2010, 3.7 được sửa đổi - Thuật ngữ “đánh giá chất lượng bên ngoài”, được đưa ra trong Chú thích 2 của mục, được sử dụng làm thuật ngữ chính. Chú thích cho mục 1 và 2 đã được bỏ qua và chú thích 1 mới cho mục được thêm vào.]

### Tính khách quan

Tính khách quan đối với các kết quả xét nghiệm do phòng xét nghiệm y tế thực hiện

CHÚ THÍCH 1: Tính khách quan có thể được hiểu là không thiên vị hoặc không xung đột lợi ích.

CHÚ THÍCH 2: Các thuật ngữ khác hữu ích trong việc truyền tải yếu tố không thiên vị bao gồm “độc lập”, “không thành kiến”, “trung lập”, “công bằng”, “cởi mở”, “công bằng”, “không phụ thuộc” , "cân bằng".

[NGUỒN: ISO/IEC 17000:2020 5.3 được sửa đổi - “kết quả của hoạt động đánh giá sự phù hợp” đã được thay đổi thành “các nhiệm vụ được thực hiện bởi phòng xét nghiệm y tế”. Lưu ý 2 vào mục đã được thêm vào.]

### So sánh liên phòng

thực hiện và đánh giá các phép đo hoặc xét nghiệm (3.8) trên cùng một vật liệu hoặc vật liệu tương tự do hai hoặc nhiều phòng xét nghiệm độc lập thực hiện theo các điều kiện xác định trước

[NGUỒN: ISO/IEC 17043:2010 3.4, được sửa đổi — "kiểm tra" đã được thay thế bằng "xét nghiệm". "vật phẩm" đã được thay thế bằng "vật liệu". "các phòng xét nghiệm" đã được thay thế bằng "các phòng xét nghiệm độc lập".]

### Kiểm soát chất lượng nội bộ (IQC) - kiểm soát chất lượng (QC)

Quy trình nội bộ giám sát quá trình xét nghiệm để xác minh hệ thống đang hoạt động chính xác và đảm bảo rằng kết quả đủ tin cậy để công bố

[NGUỒN: ISO/TS 22583:2019 3.9, được sửa đổi — “quyết định” đã được thay thế bằng “xác minh”. Lưu ý 1 cho mục nhập đã bị xóa.]

### Thiết bị y tế chẩn đoán in vitro - Thiết bị y tế IVD

Thiết bị, dù được sử dụng riêng lẻ hay kết hợp, được nhà sản xuất dự kiến dùng để kiểm tra trong ống nghiệm các mẫu lấy từ cơ thể người chỉ hoặc chủ yếu để cung cấp thông tin cho mục đích chẩn đoán, theo dõi hoặc tương thích và bao gồm cả thuốc thử , bộ hiệu chuẩn, vật liệu kiểm soát, hộp đựng mẫu, phần mềm và các dụng cụ hoặc thiết bị liên quan hoặc các vật phẩm khác

[NGUỒN: ISO 18113-1:2022, 3.1.33, được sửa đổi — "y tế" đã bị xóa khỏi phần đầu của định nghĩa. "và bao gồm thuốc thử, chất hiệu chuẩn, vật liệu kiểm soát, hộp đựng mẫu, phần mềm và các dụng cụ hoặc thiết bị liên quan hoặc các sản phẩm khác" đã được thêm vào phần cuối của định nghĩa. Ghi chú 1 và 2 cho mục nhập đã bị xóa.]

### Quản lý phòng xét nghiệm

(Những) người có trách nhiệm và quyền hạn đối với phòng xét nghiệm (3.20)

CHÚ THÍCH 1: Lãnh đạo phòng xét nghiệm có quyền ủy quyền và cung cấp các nguồn lực trong phòng xét nghiệm.

CHÚ THÍCH 2: Lãnh đạo phòng xét nghiệm bao gồm (các) giám đốc phòng xét nghiệm và những người được ủy quyền cùng với các cá nhân được phân công cụ thể để đảm bảo chất lượng các hoạt động của phòng xét nghiệm.

### Người sử dụng phòng xét nghiệm

Cá nhân hoặc tổ chức người sử dụng dịch vụ của phòng xét nghiệm y tế (3.20)

CHÚ THÍCH 1: Người sử dụng có thể bao gồm bệnh nhân, bác sĩ lâm sàng và các phòng xét nghiệm hoặc tổ chức khác gửi mẫu để kiểm tra.

### Hệ thống quản lý

tập hợp các yếu tố liên quan hoặc tương tác với nhau của một tổ chức để thiết lập các chính sách và mục tiêu cũng như các quá trình để đạt được các mục tiêu đó

CHÚ THÍCH 1: Điều này trước đây được đề cập và đồng nghĩa với “hệ thống quản lý chất lượng”.

CHÚ THÍCH 2: Các yếu tố của hệ thống quản lý thiết lập cơ cấu, vai trò và trách nhiệm, hoạch định, vận hành, chính sách, thực hành, quy tắc, niềm tin, mục tiêu và quá trình của tổ chức để đạt được các mục tiêu đó.

[NGUỒN: ISO 9000:2015, 3.5.3 được sửa đổi - Chú thích cho mục 1, 3 và 4 đã được loại bỏ và Chú thích 1 mới cho mục đã được thêm vào.]

### Độ chính xác phép đo - độ chính xác của phép đo - độ chính xác độ gần nhau giữa giá trị đo được và giá trị thực của đại lượng đo

CHÚ THÍCH 1: Khái niệm 'độ chính xác của phép đo' không phải là một đại lượng và không được đưa ra một giá trị đại lượng bằng số. Một phép đo được cho là chính xác hơn khi nó có sai số đo nhỏ hơn.

CHÚ THÍCH 2: Không nên sử dụng thuật ngữ “độ chính xác của phép đo” cho độ đúng của phép đo và thuật ngữ độ chụm của phép đo không được sử dụng cho 'độ chính xác của phép đo', tuy nhiên, thuật ngữ này có liên quan đến cả hai khái niệm này.

CHÚ THÍCH 3: 'Độ chính xác của phép đo' đôi khi được hiểu là mức độ gần giống nhau giữa các giá trị đại lượng đo được quy cho đại lượng đo.

[NGUỒN: ISO / IEC Guide 99:2007, 2.13]

### Độ không đảm bảo đo MU

tham số không âm đặc trưng cho sự phân tán của các giá trị đại lượng được quy cho một phép đo, dựa trên thông tin được sử dụng

CHÚ THÍCH 1: MU bao gồm các thành phần phát sinh từ các hiệu ứng hệ thống, như trong trường hợp hiệu chỉnh các giá trị đại lượng ấn định của chuẩn đo lường. Đôi khi các hiệu ứng hệ thống ước tính không được hiệu chỉnh mà thay vào đó, các thành phần MU liên quan được kết hợp.

CHÚ THÍCH 2: Tham số có thể là, ví dụ, độ lệch chuẩn (SD) được gọi là MU chuẩn (hoặc bội số xác định của nó), hoặc nửa độ rộng của một khoảng, có xác suất bao phủ đã nêu.

CHÚ THÍCH 3: MU nói chung bao gồm nhiều thành phần. Một số trong số này có thể được đánh giá bằng cách đánh giá. Loại A của MU từ phân bố thống kê của các giá trị đại lượng từ các chuỗi phép đo và có thể được đặc trưng bởi SD. Các thành phần khác, có thể được đánh giá bằng đánh giá Loại B của MU, cũng có thể được đặc trưng bởi SD hoặc được đánh giá từ các hàm mật độ xác suất dựa trên kinh nghiệm hoặc thông tin khác.

CHÚ THÍCH 4: Nói chung, đối với một tập hợp thông tin nhất định, người ta hiểu rằng MU được liên kết với một giá trị đại lượng đã nêu được gán cho đại lượng đo. Việc sửa đổi giá trị này có thể dẫn đến việc sửa đổi độ không đảm bảo liên quan.

CHÚ THÍCH 5: Tất cả các phép đo đều có độ chệch (3.1) và độ không chính xác. Ví dụ, các phép đo lặp lại của một mẫu được thực hiện trong các điều kiện lặp lại thường tạo ra các giá trị khác nhau cho cùng một đại lượng đo.

Bởi vì tất cả các giá trị khác nhau đều có thể được quy một cách hợp lý cho cùng một lượng đại lượng đo, nên có sự không chắc chắn về việc giá trị nào sẽ được báo cáo là giá trị của đại lượng đo”.

CHÚ THÍCH 6: Dựa trên dữ liệu sẵn có về hiệu suất phân tích của một quy trình đo nhất định, ước tính MU cung cấp một khoảng các giá trị được cho là bao gồm giá trị thực của đại lượng đo, với mức độ tin cậy đã nêu.

CHÚ THÍCH 7: Dữ liệu sẵn có về hiệu suất phân tích của một quy trình đo nhất định thường bao gồm độ không đảm bảo của các giá trị ấn định cho bộ hiệu chuẩn và độ không chính xác lâu dài của vật liệu IQC.

CHÚ THÍCH 8: Trong các phòng xét nghiệm y tế, hầu hết các phép đo được thực hiện đơn lẻ và được coi là ước lượng có thể chấp nhận được về giá trị của đại lượng đo, trong khi khoảng MU biểu thị các kết quả khác cũng có thể thực hiện được.

[NGUỒN: ISO/IEC Guide 99:2007 2.26, được sửa đổi - Chú thích cho mục 5 đến 8 đã được thêm vào từ ISO/TS 20914:2019 3.26.]

### Phòng xét nghiệm Y tế \- Phòng xét nghiệm

để kiểm tra (3.8) các vật liệu có nguồn gốc từ cơ thể người nhằm mục đích cung cấp thông tin cho việc chẩn đoán, theo dõi, quản lý, phòng ngừa và điều trị bệnh hoặc đánh giá sức khỏe

CHÚ THÍCH 1: Phòng xét nghiệm cũng có thể đưa ra lời khuyên về tất cả các khía cạnh của xét nghiệm bao gồm lựa chọn thích hợp, giải thích kết quả và tư vấn về các xét nghiệm tiếp theo.

CHÚ THÍCH 2: Các hoạt động của phòng xét nghiệm bao gồm các quá trình trước xét nghiệm (3.24), xét nghiệm (3.8) và sau xét nghiệm (3.23).

CHÚ THÍCH 3: Vật liệu để kiểm tra (3.8) bao gồm nhưng không giới hạn ở vi sinh vật, miễn dịch học, sinh hóa, miễn dịch huyết học, huyết học, lý sinh, tế bào học, mô và tế bào, và vật liệu di truyền..

### Quá trình sau xét nghiệm

Các quy trình sau xét nghiệm (3.8) bao gồm xem xét kết quả, định dạng, phát hành, báo cáo và lưu giữ kết quả xét nghiệm, lưu giữ và bảo quản vật liệu lâm sàng, mẫu (3.28) và xử lý chất thải

### Quá trình trước xét nghiệm

Các quá trình bắt đầu, theo trình tự thời gian, từ yêu cầu của người sử dụng và bao gồm yêu cầu xét nghiệm (3.8), chuẩn bị và nhận dạng bệnh nhân (3.21), thu thập (các) mẫu ban đầu (3.25), vận chuyển đến và trong phòng xét nghiệm (3.20), kết thúc khi bắt đầu kiểm tra (3.8)

### Mẫu ban đầu - Mẫu xét nghiệm

phần riêng biệt của dịch cơ thể hoặc mô hoặc mẫu khác liên quan đến cơ thể người được dùng để kiểm tra (3.8), nghiên cứu hoặc phân tích một hoặc nhiều đại lượng hoặc đặc điểm để xác định đặc tính của toàn bộ mẫu.

CHÚ THÍCH 1: Diễn đàn các cơ quan quản lý thiết bị y tế quốc tế (IMDRF) sử dụng thuật ngữ mẫu vật trong các tài liệu hướng dẫn hài hòa của mình để chỉ mẫu có nguồn gốc sinh học dành cho xét nghiệm bởi phòng xét nghiệm y tế (3.20).

[NGUỒN: ISO 18113-1:2022, 3.1.65, được sửa đổi - Chú thích 1 cho mục nhập đã được sửa đổi. Lưu ý 2 cho mục nhập đã bị xóa.]

### Chỉ số chất lượng

Thước đo mức độ mà một số lượng lớn các đặc tính của một đối tượng đáp ứng các yêu cầu

CHÚ THÍCH 1: Phép đo có thể được biểu thị, ví dụ, như % năng suất (% trong các yêu cầu quy định), % lỗi (% ngoài các yêu cầu quy định), lỗi trên một triệu lần (DPMO) hoặc trên thang đo Six Sigma.

CHÚ THÍCH 2: Các chỉ số chất lượng có thể đo lường mức độ tổ chức đáp ứng các nhu cầu và yêu cầu của người sử dụng cũng như chất lượng của tất cả các quá trình hoạt động.

### phòng xét nghiệm bên ngoài

Phòng xét nghiệm bên ngoài (3.20) nơi gửi mẫu hoặc dữ liệu để kiểm tra (3.8)

CHÚ THÍCH 1: Phòng xét nghiệm giới thiệu là phòng mà ban giám đốc phòng xét nghiệm chọn để gửi mẫu hoặc mẫu phụ để kiểm tra, dữ liệu để phân tích hoặc giải thích hoặc khi không thể thực hiện kiểm tra thường xuyên.

CHÚ THÍCH 2: Điều này khác với phòng xét nghiệm yêu cầu gửi mẫu theo quy định hoặc phòng xét nghiệm được gọi là phòng xét nghiệm tham chiếu, ví dụ như dịch vụ y tế công cộng, pháp y, sàng lọc ung thư hoặc cơ sở trung ương (đầu não) mà việc gửi mẫu là theo yêu cầu về cơ cấu hoặc theo quy định.

### Độ đúng - Đo lường độ đúng

Mức độ gần nhau giữa giá trị trung bình của vô số giá trị đại lượng đo lặp lại và giá trị đại lượng tham chiếu

CHÚ THÍCH 1: Độ đúng của phép đo không phải là đại lượng và do đó không thể biểu thị bằng số, nhưng các thước đo về mức độ gần giống nhau được nêu trong ISO 5725-1.

CHÚ THÍCH 2: Độ đúng của phép đo tỷ lệ nghịch với sai số hệ thống, nhưng không liên quan đến sai số ngẫu nhiên.

CHÚ THÍCH 3: 'Độ chính xác của phép đo' không được sử dụng cho 'độ đúng của phép đo'.

CHÚ THÍCH 4: Đối với các xét nghiệm định tính, độ đúng của phép đo (độ gần phù hợp) có thể được thể hiện dưới dạng độ phù hợp (nghĩa là tỷ lệ phần trăm phù hợp với xét nghiệm quy chiếu).

CHÚ THÍCH 5: Độ đúng là thuộc tính của quy trình kiểm tra (3.9) phản ánh độ chệch (3.1) của phép đo so với giá trị mong đợi hoặc giá trị mục tiêu. Nó được mô tả một cách định tính là tốt hay xấu. Quy trình kiểm tra (3.9) có độ đúng tốt nếu độ chệch (3.1) của phép đo được chấp nhận.

[NGUỒN: ISO/IEC Guide 99:2007, 2.14, được sửa đổi - Chú thích cho mục 4 và 5 đã được thêm vào.]

### Thời gian trả kết quả

thời gian đã trôi qua giữa hai điểm xác định thông qua các quy trình trước xét nghiệm (3.24), xét nghiệm (3.8) và sau xét nghiệm (3.23).

### Xác nhận giá trị sử dụng

xác nhận tính hợp lý cho mục đích sử dụng hoặc ứng dụng cụ thể thông qua việc cung cấp bằng chứng khách quan rằng các yêu cầu quy định đã được đáp ứng

CHÚ THÍCH 1: Bằng chứng khách quan có thể thu được thông qua quan sát, đo lường, kiểm tra hoặc bằng cách khác có nghĩa.

CHÚ THÍCH 2: Từ “đã xác nhận giá trị sử dụng” được sử dụng để chỉ trạng thái tương ứng.

CHÚ THÍCH 3: Các yêu cầu cụ thể của một phương pháp kiểm tra có thể bao gồm các thông số kỹ thuật thực hiện sau: độ đúng của phép đo, độ chính xác của phép đo bao gồm độ lặp lại của phép đo và độ chính xác trung gian của phép đo, tính đặc hiệu của phân tích, bao gồm các chất gây nhiễu, giới hạn phát hiện và giới hạn định lượng, khoảng thời gian đo, mức độ phù hợp về mặt lâm sàng , độ đặc hiệu chẩn đoán và độ nhạy chẩn đoán.

[NGUỒN: ISO/IEC 17000:2020, 6.5, được sửa đổi - Chú thích 1 đến 3 cho mục nhập đã được thêm vào.]

### Kiểm tra xác nhận

xác nhận tính trung thực, thông qua việc cung cấp bằng chứng khách quan rằng các yêu cầu cụ thể đã được đáp ứng

VÍ DỤ 1 Xác nhận rằng các đặc tính kỹ thuật hiệu suất của một hệ thống đo lường đã đạt được.

VÍ DỤ 2 Xác nhận rằng có thể đáp ứng độ không đảm bảo đo mục tiêu.

CHÚ THÍCH 1: Kiểm tra xác nhận là quá trình mà phòng xét nghiệm xác nhận rằng các tuyên bố về hiệu suất đã thiết lập của một hệ thống đo lường, ví dụ như độ đúng, độ chụm, phạm vi có thể báo cáo, có thể được lặp lại trong phòng xét nghiệm trước khi thực hiện xét nghiệm trên mẫu bệnh nhân.

CHÚ THÍCH 2: Bằng chứng khách quan cần thiết cho việc kiểm tra xác nhận có thể là kết quả kiểm tra hoặc các hình thức xác định khác, chẳng hạn như thực hiện các phép tính thay thế hoặc xem xét tài liệu.

CHÚ THÍCH 3: Việc kiểm tra xác nhận có thể đủ để triển khai thiết bị IVD mới trong các trường hợp khi việc xét nghiệm (3.8) được thực hiện và sử dụng theo cách như được chỉ dẫn trong tờ hướng dẫn sử dụng.

CHÚ THÍCH 4: Từ "đã xác nhận" được sử dụng để chỉ trạng thái tương ứng

[NGUỒN: ISO/IEC 17000:2020, 6.6 được sửa đổi - VÍ DỤ 1 và 2 đã được thêm vào. Ghi chú cho mục 1 đến 4 đã được thêm vào.]

## Những yêu cầu chung

### Tính khách quan

  * Các hoạt động của phòng xét nghiệm phải được thực hiện một cách khách quan. Phòng xét nghiệm phải được cấu trúc và quản lý để bảo vệ sự khách quan.

  * Ban lãnh đạo phòng xét nghiệm phải cam kết duy trì sự khách quan.

  * Phòng xét nghiệm phải chịu trách nhiệm về tính khách quan trong các hoạt động xét nghiệm của mình và không được cho phép các áp lực thương mại, tài chính hoặc các áp lực khác ảnh hưởng đến tính khách quan.

  * Phòng xét nghiệm phải giám sát các hoạt động và các mối quan hệ của mình để xác định các mối đe dọa đối với tính khách quan của phòng xét nghiệm. Giám sát này sẽ bao gồm các mối quan hệ của nhân viên phòng xét nghiệm.


CHÚ THÍCH: Mối quan hệ đe dọa đến tính khách quan của phòng xét nghiệm có thể dựa trên quyền sở hữu, quản trị, quản lý, nhân sự, nguồn lực được chia sẻ, tài chính, hợp đồng, tiếp thị (bao gồm cả việc xây dựng thương hiệu) và thanh toán hoa hồng bán hàng hoặc sự xúi giục khác để giới thiệu phòng xét nghiệm mới, v.v. Những mối quan hệ như vậy không nhất thiết khiến phòng xét nghiệm bị đe dọa đến tính khách quan.

  * Nếu xác định được mối đe dọa đối với tính khách quan, ảnh hưởng đó phải được loại bỏ hoặc giảm thiểu để tính khách quan không bị tổn hại. Phòng xét nghiệm phải có khả năng chứng minh cách mà phòng xét nghiệm giảm thiểu mối đe dọa đó.

# Public_008

# Tiêu chuẩn quản trị

## Yêu cầu về cơ cấu và quản trị

### Pháp nhân

Phòng xét nghiệm hoặc tổ chức mà phòng xét nghiệm là một phần của nó phải là một pháp nhân có thể chịu trách nhiệm pháp lý về các hoạt động của mình.

CHÚ THÍCH: Với mục đích của tài liệu này, phòng xét nghiệm của chính phủ được coi là một pháp nhân trên cơ sở tư cách chính phủ của nó.

## Giám đốc phòng xét nghiệm

###  Năng lực của giám đốc phòng xét nghiệm

Phòng xét nghiệm phải được chỉ đạo bởi một người, hoặc những người được nêu tên, với trình độ, năng lực, quyền hạn được ủy quyền, trách nhiệm và nguồn lực cụ thể để đáp ứng các yêu cầu của tài liệu này.

### Trách nhiệm của Giám đốc phòng xét nghiệm

Giám đốc phòng xét nghiệm chịu trách nhiệm triển khai hệ thống quản lý, bao gồm cả việc áp dụng quản lý rủi ro cho tất cả các khía cạnh của hoạt động phòng xét nghiệm để các rủi ro đối với việc chăm sóc bệnh nhân và các cơ hội cải tiến được xác định và giải quyết một cách có hệ thống.

Nhiệm vụ và trách nhiệm của giám đốc phòng xét nghiệm phải được lập thành văn bản.

### Phân công nhiệm vụ

Giám đốc phòng xét nghiệm có thể ủy quyền các nhiệm vụ hoặc trách nhiệm, hoặc cả hai, cho nhân viên có trình độ và năng lực và việc ủy quyền đó phải được lập thành văn bản. Tuy nhiên, giám đốc phòng xét nghiệm phải duy trì trách nhiệm cuối cùng đối với hoạt động chung của phòng xét nghiệm.

## Hoạt động của phòng xét nghiệm

### Tổng quát

Phòng xét nghiệm phải chỉ định và lập thành văn bản phạm vi hoạt động của phòng xét nghiệm, bao gồm các hoạt động của phòng xét nghiệm được thực hiện tại các địa điểm khác với địa điểm chính (ví dụ: POCT, thu thập mẫu) mà nó tuân thủ với tài liệu này. Phòng xét nghiệm chỉ được công bố sự phù hợp với tài liệu này đối với phạm vi hoạt động của phòng xét nghiệm, loại trừ các hoạt động của phòng xét nghiệm do bên ngoài cung cấp.

### Tuân thủ các yêu cầu

Các hoạt động của phòng xét nghiệm phải được thực hiện đáp ứng các yêu cầu của tài liệu này, của người dùng, của cơ quan quản lý và tổ chức đánh giá công nhận. Điều này áp dụng cho toàn bộ các hoạt động phòng xét nghiệm được chỉ định và lập thành văn bản, bất kể dịch vụ được cung cấp ở đâu.

### Hoạt động tư vấn

Khoa xét nghiệm đảm bảo các tư vấn và giải thích phù hợp về dịch vụ xét nghiệm luôn sẵn có và đáp ứng nhu cầu của bệnh nhân và người sử dụng.

Phòng xét nghiệm thiết lập các thỏa thuận để liên lạc với người sử dụng phòng xét nghiệm về những điều sau đây khi áp dụng:

  * Tư vấn về lựa chọn và sử dụng các dịch vụ, bao gồm loại mẫu được yêu cầu, chỉ định lâm sàng, giới hạn của phương pháp xét nghiệm và tần suất yêu cầu xét nghiệm;

  * Đưa ra những đánh giá chuyên môn nhằm giải thích kết quả xét nghiệm;

  * Thúc đẩy việc sử dụng hiệu quả các dịch vụ của phòng xét nghiệm;

  * Tư vấn về các vấn đề khoa học và hậu cần, chẳng hạn như trường hợp (các) mẫu không đáp ứng tiêu chí chấp nhận.


Các vấn đề liên quan đến hoạt động tư vấn thực hiện theo quy trình tư vấn dịch vụ

##  Cơ cấu và quyền hạn

### Tổng quát

Phòng xét nghiệm có trách nhiệm:

  * xác định cơ cấu tổ chức và quản lý, vị trí của nó trong tổ chức mẹ và mối quan hệ giữa quản lý, hoạt động kỹ thuật và dịch vụ hỗ trợ;

  * xác định trách nhiệm, quyền hạn, thông tin liên lạc và mối quan hệ qua lại của tất cả những nhân viên, thực hiện hoặc kiểm tra xác nhận công việc ảnh hưởng đến kết quả các hoạt động của phòng xét nghiệm;

  * quy định các thủ tục trong phạm vi cần thiết để đảm bảo áp dụng nhất quán cho phòng xét nghiệm.


### Quản lý chất lượng

Phòng xét nghiệm phải có nhân viên quản lý chất lượng, ngoài các trách nhiệm khác, phải có thẩm quyền và nguồn lực cần thiết để thực hiện nhiệm vụ của họ, bao gồm:

  * việc áp dụng, duy trì và cải tiến hệ thống quản lý;

  * xác định các sự không phù hợp của hệ thống quản lý hoặc các thủ tục trong hoạt động của phòng xét nghiệm;

  * Tổ chức các hành động để phòng ngừa hoặc khắc phục những sự không phù hợp đó;

  * báo cáo cho ban lãnh đạo phòng xét nghiệm về kết quả hoạt động của hệ thống quản lý và mọi nhu cầu để cải tiến;

  * đảm bảo hiệu quả của các hoạt động trong phòng xét nghiệm.


CHÚ THÍCH: Những trách nhiệm này có thể được giao cho một hoặc nhiều người.

## Mục tiêu và chính sách

  * Lãnh đạo phòng xét nghiệm phải thiết lập và duy trì các mục tiêu và chính sách để:

* đáp ứng nhu cầu và yêu cầu của bệnh nhân và người sử dụng;

* cam kết thực hành tốt chuyên môn;

* cung cấp các dịch vụ xét nghiệm đáp ứng mục đích sử dụng;

* phù hợp với tài liệu này.

  * Các mục tiêu chất lượng phải đo lường được và nhất quán với các chính sách chất lượng. Phòng xét nghiệm phải đảm bảo rằng các mục tiêu và chính sách được thực hiện ở tất cả các cấp trong tổ chức phòng xét nghiệm.

  * Lãnh đạo phòng xét nghiệm phải đảm bảo rằng tính toàn vẹn của hệ thống quản lý được duy trì khi các thay đổi đối với hệ thống quản lý được hoạch định và thực hiện.

  * Phòng xét nghiệm phải thiết lập và theo dõi các chỉ số chất lượng để đánh giá hiệu suất các khía cạnh của quá trình trước xét nghiệm, xét nghiệm và sau xét nghiệm


CHÚ THÍCH: Các chỉ số chất lượng bao gồm số lượng mẫu bị từ chối, số lượng lỗi khi chỉ định hoặc nhận mẫu hoặc cả hai, số lượng báo cáo kết quả đã sửa, tỷ lệ thời gian trả kết quả đúng hạn.

## Quản lý rủi ro

  * Lãnh đạo phòng xét nghiệm phải thiết lập, thực hiện và duy trì các quy trình để xác định các rủi ro gây hại cho bệnh nhân và các cơ hội để cải tiến việc chăm sóc bệnh nhân liên quan đến các hoạt động và xét nghiệm của mình, đồng thời phát triển các hành động để giải quyết cả rủi ro và cơ hội cải tiến

  * Giám đốc phòng xét nghiệm phải đảm bảo rằng các quy trình này được đánh giá về tính hiệu quả và được sửa đổi, khi được xác định là không hiệu quả.


CHÚ THÍCH 1: ISO 22367 cung cấp chi tiết để quản lý rủi ro trong các phòng xét nghiệm y tế.
CHÚ THÍCH 2: ISO 35001 cung cấp thông tin chi tiết về quản lý rủi ro sinh học trong phòng thí nghiệm.

## Yêu cầu về nguồn lực

###  Tổng quát

Phòng xét nghiệm phải có sẵn nhân sự, cơ sở vật chất, thiết bị, thuốc thử, vật tư tiêu hao và các dịch vụ hỗ trợ cần thiết để quản lý và thực hiện các hoạt động của phòng xét nghiệm.

###  Nhân sự

#### Tổng quát

  * Phòng xét nghiệm phải có đủ số lượng nhân viên có năng lực để thực hiện các hoạt động của mình.

  * Tất cả nhân viên của phòng xét nghiệm, nội bộ hoặc bên ngoài, có thể ảnh hưởng đến các hoạt động của phòng xét nghiệm phải hành động một cách vô tư, có đạo đức, có năng lực và làm việc phù hợp với hệ thống quản lý của phòng xét nghiệm.


CHÚ THÍCH: ISO/TS 22583 cung cấp hướng dẫn cho người giám sát và vận hành thiết bị POCT.

  * Phòng xét nghiệm phải truyền đạt cho nhân viên phòng xét nghiệm về tầm quan trọng của việc đáp ứng nhu cầu và yêu cầu của người sử dụng cũng như các yêu cầu của tài liệu này.

  * Phòng xét nghiệm phải có chương trình giới thiệu cho nhân sự mới về tổ chức, bộ phận hoặc khu vực mà người đó sẽ làm việc, các điều khoản và điều kiện tuyển dụng, cơ sở vật chất của nhân viên, các yêu cầu về sức khỏe và an toàn cũng như các dịch vụ sức khỏe nghề nghiệp.


#### Yêu cầu về năng lực

  * Phòng xét nghiệm phải quy định cụ thể các yêu cầu về năng lực đối với từng chức năng ảnh hưởng đến kết quả hoạt động của phòng xét nghiệm, bao gồm các yêu cầu về trình độ học vấn, trình độ chuyên môn, đào tạo, đào tạo lại, kiến thức kỹ thuật, kỹ năng và kinh nghiệm.

  * Phòng xét nghiệm phải đảm bảo tất cả nhân viên có đủ năng lực thực hiện các hoạt động trong phòng xét nghiệm mà họ chịu trách nhiệm.

  * Phòng xét nghiệm phải có quy trình quản lý năng lực của nhân viên, bao gồm yêu cầu về tần suất đánh giá năng lực.

  * Phòng xét nghiệm phải có thông tin dạng văn bản chứng minh năng lực của nhân viên.


CHÚ THÍCH: Ví dụ về các phương pháp đánh giá năng lực có thể được sử dụng bất kỳ sự kết hợp nào dưới đây bao gồm:

  * quan sát trực tiếp một hoạt động,

  * giám sát việc ghi chép và báo cáo kết quả xét nghiệm,

  * xem xét hồ sơ công việc,

  * đánh giá kỹ năng giải quyết vấn đề,

  * kiểm tra bằng các mẫu được cung cấp đặc biệt, ví dụ: các mẫu đã được kiểm tra trước đó, vật liệu so sánh liên phòng hoặc các mẫu tách.


### Ủy quyền

Phòng xét nghiệm phải ủy quyền cho nhân viên thực hiện các hoạt động cụ thể của phòng xét nghiệm, bao gồm nhưng không giới hạn ở các hoạt động sau:

  * lựa chọn, phát triển, sửa đổi, xác nhận giá trị sử dụng và kiểm tra xác nhận các phương pháp;

  * xem xét, công bố và báo cáo kết quả;

  * sử dụng các hệ thống thông tin của phòng xét nghiệm, cụ thể: truy cập dữ liệu và thông tin bệnh nhân, nhập dữ liệu bệnh nhân và kết quả xét nghiệm, thay đổi dữ liệu bệnh nhân hoặc kết quả xét nghiệm.


### Đào tạo liên tục và phát triển chuyên môn

Một chương trình đào tạo liên tục sẽ có sẵn cho nhân viên tham gia vào các quá trình quản lý và kỹ thuật. Tất cả nhân viên phải tham gia vào chương trình đào tạo liên tục và phát triển chuyên môn thường xuyên, hoặc các hoạt động liên kết chuyên môn khác.
Sự phù hợp của các chương trình và hoạt động sẽ được xem xét định kỳ.

### Hồ sơ nhân sự

Phòng xét nghiệm phải có các thủ tục và lưu giữ hồ sơ về:

  * xác định các yêu cầu về năng lực quy định

  * mô tả vị trí việc làm;

  * đào tạo và đào tạo lại;

  * ủy quyền cho nhân sự;

  * giám sát năng lực của nhân viên.


### Cơ sở vật chất và điều kiện môi trường

#### Tổng quát

Cơ sở vật chất và điều kiện môi trường phải phù hợp với hoạt động của phòng xét nghiệm và không ảnh hưởng xấu đến hiệu lực của kết quả, hoặc sự an toàn của bệnh nhân, khách thăm, người sử dụng phòng xét nghiệm và nhân viên. Điều này sẽ bao gồm các cơ sở và địa điểm liên quan đến trước xét nghiệm và khi xét nghiệm mà khác với cơ sở chính của phòng xét nghiệm, cũng như POCT.
Các yêu cầu về cơ sở vật chất và điều kiện môi trường cần thiết cho việc thực hiện các hoạt động của phòng xét nghiệm phải được quy định , theo dõi và ghi lại.
CHÚ THÍCH 1: ISO 15190 cung cấp thông tin chi tiết về cơ sở vật chất và điều kiện môi trường.
CHÚ THÍCH 2: Các điều kiện môi trường có thể ảnh hưởng bất lợi đến tính hợp lệ của kết quả bao gồm, nhưng không
giới hạn ở: axit nucleic được khuếch đại ngẫu nhiên, nhiễm vi sinh vật, bụi, nhiễu điện từ, bức xạ, điều kiện ánh sáng (chiếu sáng), độ ẩm, nguồn điện, nhiệt độ, âm thanh và rung động.

#### Kiểm soát cơ sở

Các biện pháp kiểm soát cơ sở phải được thực hiện, ghi lại, giám sát, xem xét định kỳ và phải bao gồm:

  * kiểm soát truy cập, có tính đến sự an toàn, bảo mật, chất lượng và bảo vệ thông tin y tế và mẫu bệnh phẩm;

  * ngăn ngừa nhiễm bẩn, nhiễu hoặc ảnh hưởng xấu đến các hoạt động của phòng xét nghiệm có thể phát sinh từ các nguồn năng lượng, chiếu sáng, thông gió, tiếng ồn, nước và xử lý chất thải;

  * ngăn ngừa nhiễm chéo, khi quy trình xét nghiệm có rủi ro, hoặc khi công việc có thể bị ảnh hưởng hoặc ảnh hưởng do thiếu sự tách biệt;

  * cung cấp các phương tiện và thiết bị an toàn, nếu có thể áp dụng và kiểm tra xác nhận thường xuyên chức năng của chúng;

* VÍ DỤ: Hoạt động của hệ thống thoát khẩn cấp, liên lạc nội bộ và hệ thống báo động cho phòng lạnh và tủ đông không cửa ngăn, khả năng tiếp cận vòi tắm khẩn cấp, thiết bị rửa mắt và hồi sức.

  * duy trì các trang thiết bị của phòng xét nghiệm trong điều kiện hoạt động tốt và đáng tin cậy.


#### Tiện nghi lưu trữ

  * Phòng xét nghiệm phải cung cung cấp không gian lưu trữ, với các điều kiện đảm bảo tính toàn vẹn liên tục của mẫu, thiết bị, thuốc thử, vật tư tiêu hao, tài liệu và hồ sơ.

  * Các mẫu bệnh nhân và vật liệu được sử dụng trong quy trình xét nghiệm phải được bảo quản theo cách ngăn ngừa nhiễm chéo và hư hỏng.

  * Cơ sở lưu trữ, xử lý vật liệu nguy hiểm và chất thải sinh học phải phù hợp với việc phân loại vật liệu theo các yêu cầu luật định hoặc quy định.


#### Tiện nghi cho nhân viên

Phải cung cấp điều kiện về thiết bị vệ sinh và nguồn cung cấp nước uống, cũng như các phương tiện cất giữ thiết bị và quần áo bảo hộ cá nhân.
Phải cung cấp không gian cho các hoạt động của nhân viên, như các cuộc họp, khu vực yên tĩnh để học tập và khu vực nghỉ ngơi.

#### Tiện nghi lấy mẫu bệnh phẩm

Cơ sở thu thập mẫu có trách nhiệm:

  * cho phép thực hiện việc thu thập theo cách thức không làm mất hiệu lực của kết quả hoặc ảnh hưởng xấu đến chất lượng xét nghiệm;

  * xem xét sự riêng tư, thoải mái và các nhu cầu (ví dụ: lối đi dành cho người khuyết tật, nhà vệ sinh) của bệnh nhân và chỗ ở của những người đi cùng (ví dụ: người giám hộ hoặc thông dịch viên) trong quá trình thu thập;

  * cung cấp các khu vực tiếp nhận và thu thập mẫu bệnh phẩm riêng biệt;

  * duy trì vật liệu sơ cứu cho cả bệnh nhân và nhân viên.


CHÚ THÍCH: ISO 20658 cung cấp thông tin chi tiết về phương tiện lấy mẫu.

###  Trang thiết bị

####  Tổng quát

Phòng xét nghiệm phải có quy trình lựa chọn, mua sắm, lắp đặt,nghiệm thu (bao gồm các tiêu chí về khả năng chấp nhận), xử lý, vận chuyển, bảo quản, sử dụng, bảo trì và ngừng hoạt động của thiết bị, để đảm bảo thiết bị hoạt động bình thường và ngăn ngừa nhiễm bẩn hoặc hư hỏng.
CHÚ THÍCH: Thiết bị phòng xét nghiệm bao gồm phần cứng và phần mềm của thiết bị, hệ thống đo lường và hệ thống thông tin phòng xét nghiệm hoặc bất kỳ thiết bị nào có ảnh hưởng đến kết quả của các hoạt động trong phòng xét nghiệm, bao gồm cả hệ thống vận chuyển mẫu.

####  Yêu cầu về thiết bị

  * Phòng xét nghiệm phải có quyền truy cập vào các thiết bị cần thiết để thực hiện chính xác các hoạt động của phòng xét nghiệm.

  * Trong trường hợp thiết bị được sử dụng nằm ngoài tầm kiểm soát thường xuyên của phòng xét nghiệm hoặc thông số chức năng kỹ thuật của nhà sản xuất, ban lãnh đạo phòng xét nghiệm phải đảm bảo rằng các yêu cầu của tài liệu này được đáp ứng.

  * Mỗi hạng mục của thiết bị có thể ảnh hưởng đến hoạt động của phòng xét nghiệm phải được dán nhãn riêng, đánh dấu hoặc xác định duy nhất và duy trì sổ theo dõi.

  * Phòng xét nghiệm phải bảo dưỡng và thay thế thiết bị khi cần thiết để đảm bảo chất lượng kết quả xét nghiệm.


#### Thủ tục nghiệm thu thiết bị

Phòng xét nghiệm phải xác minh rằng thiết bị phù hợp với các tiêu chí chấp nhận được xác định trước khi đưa vào sử dụng hoặc khi đưa trở lại sử dụng.

Thiết bị được sử dụng để đo phải có khả năng đạt được độ chính xác của phép đo hoặc độ không đảm bảo đo, hoặc cả hai, được yêu cầu để cung cấp kết quả hợp lệ.

CHÚ THÍCH 1 Điều này bao gồm thiết bị được sử dụng trong phòng xét nghiệm, thiết bị cho mượn hoặc thiết bị được sử dụng trong các cơ sở chăm sóc tại chỗ hoặc trong các cơ sở liên quan hoặc di động, được phòng xét nghiệm uỷ quyền.

CHÚ THÍCH 2 Việc xác minh thử nghiệm chấp nhận thiết bị, nếu phù hợp, có thể dựa trên chứng nhận hiệu chuẩn của thiết bị được trả lại.

####  Hướng dẫn sử dụng thiết bị

  * Phòng xét nghiệm phải có các biện pháp bảo vệ thích hợp để ngăn chặn các điều chỉnh ngoài ý muốn của thiết bị có thể làm mất hiệu lực của kết quả xét nghiệm.

  * Thiết bị phải được vận hành bởi nhân viên được đào tạo, được ủy quyền và có năng lực.

  * Hướng dẫn sử dụng thiết bị, bao gồm cả hướng dẫn thiết bị do nhà sản xuất cung cấp, phải có sẵn.

  * Thiết bị phải được sử dụng theo quy định của nhà sản xuất, trừ khi được xác nhận bởi phòng xét nghiệm


####  Bảo dưỡng và sửa chữa thiết bị

  * Phòng xét nghiệm phải có các chương trình bảo trì phòng ngừa, dựa trên hướng dẫn của nhà sản xuất. Những sai lệch so với lịch trình hoặc hướng dẫn của nhà sản xuất phải được ghi lại.

  * Thiết bị phải được duy trì trong điều kiện làm việc an toàn và hoạt động bình thường. Điều này phải bao gồm an toàn điện, bất kỳ thiết bị dừng khẩn cấp nào và việc xử lý và tiêu hủy an toàn các vật liệu nguy hiểm bởi nhân viên được uỷ quyền.

  * Thiết bị bị lỗi hoặc không đạt yêu cầu quy định sẽ bị ngừng sử dụng. Nó phải được dán nhãn rõ ràng hoặc đánh dấu là không hoạt động, cho đến khi nó được xác minh là hoạt động chính xác. Phòng xét nghiệm phải xem xét ảnh hưởng của lỗi hoặc sai lệch so với các yêu cầu quy định và phải bắt đầu các hành động khi xảy ra sự không phù hợp

  * Khi có thể, phòng xét nghiệm phải khử nhiễm thiết bị trước khi bảo dưỡng, sửa chữa hoặc ngừng hoạt động, cung cấp không gian thích hợp để sửa chữa và cung cấp thiết bị bảo hộ cá nhân thích hợp


####  Báo cáo sự cố bất lợi của thiết bị

Các sự cố và tai nạn bất lợi có thể được quy trực tiếp cho thiết bị cụ thể sẽ được điều tra và báo cáo cho nhà sản xuất hoặc nhà cung cấp, hoặc cả hai, và các cơ quan có thẩm quyền thích hợp, theo yêu cầu.

Phòng xét nghiệm phải có các thủ tục để ứng phó với bất kỳ thông báo thu hồi hoặc thông báo nào khác của nhà sản xuất và thực hiện các hành động do nhà sản xuất khuyến nghị.

####  Hồ sơ thiết bị

Hồ sơ phải được duy trì cho từng hạng mục thiết bị ảnh hưởng đến kết quả hoạt động của phòng xét nghiệm.

Các hồ sơ này phải bao gồm những điều sau đây, nếu có liên quan:

  * chi tiết về nhà sản xuất và nhà cung cấp, và thông tin đầy đủ để xác định duy nhất từng hạng mục của thiết bị, bao gồm phần mềm và chương trình cơ sở;

  * ngày tiếp nhận, nghiệm thu và đưa vào sử dụng;

  * bằng chứng cho thấy thiết bị phù hợp với các tiêu chí chấp nhận được quy định;

  * vị trí hiện tại;

  * tình trạng khi nhận (ví dụ: mới, đã qua sử dụng hoặc đã tân trang lại);

  * hướng dẫn của nhà sản xuất;

  * chương trình bảo dưỡng phòng ngừa;

  * bất kỳ hoạt động bảo trì nào được thực hiện bởi phòng xét nghiệm hoặc nhà cung cấp dịch vụ bên ngoài đã được phê duyệt;

  * hư hỏng, trục trặc, sửa đổi hoặc sửa chữa thiết bị;

  * hồ sơ hiệu suất của thiết bị như báo cáo hoặc giấy chứng nhận hiệu chuẩn hoặc kiểm tra xác nhận, hoặc cả hai, kể cả ngày tháng, thời gian và kết quả;

  * tình trạng của thiết bị như đang hoạt động hay đang sử dụng, không hoạt động, cách ly, ngừng hoạt động hoặc lỗi thời.


Các hồ sơ này phải được lưu giữ và phải có sẵn trong suốt vòng đời của thiết bị hoặc lâu hơn, như được quy định

### Hiệu chuẩn thiết bị và liên kết chuẩn đo lường

####  Tổng quát

Phòng xét nghiệm phải quy định các yêu cầu hiệu chuẩn và liên kết chuẩn đủ để duy trì báo cáo nhất quán về kết quả kiểm tra. Đối với các phương pháp định lượng chất phân tích đo được, các thông số kỹ thuật phải bao gồm các yêu cầu về hiệu chuẩn và truy xuất nguồn gốc đo lường. Các phương pháp định tính và phương pháp định lượng đo các đặc tính chứ không phải các chất phân tích rời rạc phải quy định đặc tính được đánh giá và các yêu cầu cần thiết cho khả năng tái lập theo thời gian.

CHÚ THÍCH: Ví dụ về phương pháp định tính và phương pháp định lượng có thể không cho phép truy xuất nguồn gốc bằng đo lường bao gồm phát hiện kháng thể hồng cầu, đánh giá độ nhạy cảm với kháng sinh, xét nghiệm di truyền, tốc độ máu lắng, nhuộm chất đánh dấu tế bào học dòng chảy và nhuộm hóa mô miễn dịch HER2 của khối u.

####  Hiệu chuẩn thiết bị

Phòng xét nghiệm phải có thủ tục hiệu chuẩn thiết bị có ảnh hưởng trực tiếp hoặc gián tiếp đến kết quả xét nghiệm. Các thủ tục phải quy định:

  * điều kiện sử dụng và hướng dẫn hiệu chuẩn của nhà sản xuất;

  * ghi lại truy xuất nguồn gốc đo lường;

  * kiểm tra độ chính xác của phép đo cần thiết và hoạt động của hệ thống đo trong các khoảng thời gian quy định;

  * ghi lại tình trạng hiệu chuẩn và ngày hiệu chuẩn lại;

  * đảm bảo rằng, khi các yếu tố hiệu chỉnh được sử dụng, chúng được cập nhật và ghi lại khi hiệu chuẩn lại;

  * xử lý các tình huống khi hiệu chuẩn nằm ngoài tầm kiểm soát, để giảm thiểu rủi ro cho hoạt động dịch vụ và cho bệnh nhân.


####  Liên kết chuẩn đo lường

  * Phòng xét nghiệm phải thiết lập và duy trì liên kết chuẩn đo lường cho các kết quả đo của mình bằng một chuỗi không đứt đoạn các phép hiệu chuẩn được lập thành văn bản. Mỗi phép hiệu chuẩn đóng góp vào độ không đảm bảo đo. Liên kết các kết quả đo tới mốc quy chiếu thích hợp.


CHÚ THÍCH: Thông tin liên kết chuẩn tới vật liệu chuẩn bậc cao hoặc quy trình tham chiếu có thể được cung cấp bởi hệ thống kiểm tra của nhà sản xuất. Tài liệu như vậy chỉ được chấp nhận khi hệ thống kiểm tra và quy trình hiệu chuẩn của nhà sản xuất được sử dụng mà không sửa đổi.

  * Phòng xét nghiệm phải đảm bảo rằng kết quả đo lường có thể liên kết đến hệ đơn vị quốc tế thông qua:


Việc hiệu chuẩn được cung cấp bởi phòng thí nghiệm có năng lực; hoặc
CHÚ THÍCH 1: Các phòng thí nghiệm hiệu chuẩn đáp ứng các yêu cầu của ISO / IEC 17025 được coi là có năng lực để thực hiện hiệu chuẩn.

  * Các giá trị được chứng nhận của mẫu chuẩn được chứng nhận do nhà sản xuất có năng lực cung cấp có liên kết chuẩn đo lường tới SI được công bố: hoặc;


CHÚ THÍCH 2: Các nhà sản xuất mẫu chuẩn đáp ứng các yêu cầu của ISO 17034 được coi là có năng lực.
CHÚ THÍCH 3: Mẫu chuẩn được chứng nhận đáp ứng yêu cầu của ISO 15194 được coi là phù hợp.

  * Trường hợp không thể cung cấp liên kết chuẩn phải áp dụng các biện pháp khác để cung cấp sự tin cậy cho các kết quả sẽ được áp dụng, bao gồm nhưng không giới hạn ở các biện pháp sau đây:


kết quả của các quy trình đo quy chiếu, các phương pháp quy định hoặc các chuẩn chuẩn đồng thuận được mô tả rõ ràng và được chấp nhận là cho ra kết quả đo phù hợp với việc sử dụng đã định và được đảm bảo bằng phép so sánh thích hợp.

CHÚ THÍCH: ISO 17511 cung cấp thêm thông tin về cách quản lý đồng thuận trong liên kết chuẩn đo lường của đại lượng đo.

  * Đối với giám định di truyền, phải thiết lập liên kết chuẩn đến các trình tự tham chiếu di truyền.

  * Đối với các phương pháp định tính, liên kết chuẩn có thể được chứng minh bằng cách thử nghiệm vật liệu đã biết hoặc các mẫu trước đó đủ để cho thấy nhận biết nhất quán và, nếu có, mức độ phản ứng.


### Thuốc thử và vật tư tiêu hao

####  Tổng quát

Phòng xét nghiệm phải có các quy trình lựa chọn, mua sắm, tiếp nhận, lưu trữ, nghiệm thu và quản lý tồn kho các thuốc thử, vật tư tiêu hao.

CHÚ THÍCH: Thuốc thử bao gồm các chất được cung cấp thương mại hoặc tự chuẩn bị, vật liệu chuẩn (chất hiệu chuẩn và vật liệu QC), môi trường nuôi cấy; vật tư tiêu hao bao gồm đầu tip pipet, phiến kính, vật tư POCT, v.v.

#### Thuốc thử và vật tư tiêu hao — Tiếp nhận và bảo quản

Phòng xét nghiệm phải lưu trữ thuốc thử và vật tư tiêu hao theo thông số kỹ thuật của nhà sản xuất và theo dõi các điều kiện môi trường nếu có liên quan.

Khi phòng xét nghiệm không phải là cơ sở tiếp nhận, nó phải xác minh rằng cơ sở tiếp nhận có đủ khả năng lưu trữ và xử lý để duy trì nguồn cung cấp theo cách ngăn ngừa hư hỏng và xuống cấp.

#### Thuốc thử và vật tư tiêu hao — Kiểm tra nghiệm thu

Mỗi thuốc thử hoặc công thức mới của bộ kít xét nghiệm có thay đổi về thuốc thử hoặc quy trình, hoặc lô hoặc lô hàng mới, phải được xác minh về hiệu suất trước khi đưa vào sử dụng hoặc trước khi công bố kết quả, nếu thích hợp.

Vật tư tiêu hao có thể ảnh hưởng đến chất lượng xét nghiệm phải được kiểm tra hiệu suất trước khi đưa vào sử dụng.

CHÚ THÍCH 1: Hiệu suất IQC so sánh của lô thuốc thử mới và của lô trước đó có thể được sử dụng làm bằng chứng để chấp nhận. Các mẫu bệnh nhân được ưu tiên sử dụng khi so sánh các lô thuốc thử khác nhau để tránh các vấn đề tính dễ thay đổi của vật liệu IQC.

CHÚ THÍCH 2: Việc kiểm tra xác nhận đôi khi có thể dựa trên giấy chứng nhận phân tích thuốc thử.

####  Thuốc thử và vật tư tiêu hao — Quản lý hàng tồn kho

Phòng xét nghiệm phải thiết lập một hệ thống quản lý hàng tồn kho cho thuốc thử và vật tư tiêu hao.

Hệ thống quản lý hàng tồn kho phải tách biệt thuốc thử và vật tư tiêu hao đã được chấp nhận sử dụng với những thuốc thử chưa được kiểm tra cũng như không được chấp nhận sử dụng.

#### Thuốc thử và vật tư tiêu hao — Hướng dẫn sử dụng

Hướng dẫn sử dụng thuốc thử và vật tư tiêu hao, bao gồm cả hướng dẫn do nhà sản xuất cung cấp, phải có sẵn. Thuốc thử và vật tư tiêu hao phải được sử dụng theo thông số kỹ thuật của nhà sản xuất.

#### Thuốc thử và vật tư tiêu hao — Báo cáo sự cố bất lợi

Các sự cố và tai nạn bất lợi có thể do các thuốc thử hoặc vật tư tiêu hao cụ thể phải được điều tra và báo cáo cho nhà sản xuất hoặc nhà cung cấp, hoặc cả hai, và các cơ quan có thẩm quyền thích hợp, theo yêu cầu.

Phòng xét nghiệm phải có các quy trình để ứng phó với bất kỳ thông báo thu hồi hoặc thông báo nào khác của nhà sản xuất và thực hiện các hành động do nhà sản xuất khuyến nghị.

#### Thuốc thử và vật tư tiêu hao — Hồ sơ

Phải lưu giữ các hồ sơ cho mỗi thuốc thử và vật tư tiêu hao góp phần vào việc thực hiện các xét nghiệm. Những hồ sơ này phải bao gồm, nhưng không giới hạn, những mục sau:

  * nhận dạng thuốc thử hoặc vật tư tiêu hao;

  * thông tin của nhà sản xuất, bao gồm hướng dẫn, tên và mã lô hoặc số lô;

  * ngày nhận và tình trạng khi nhận, ngày hết hạn, ngày sử dụng đầu tiên và, nếu có, ngày thuốc thử hoặc vật tư tiêu hao ngừng sử dụng;

  * hồ sơ xác nhận việc thuốc thử hoặc vật tư tiêu hao được chấp nhận sử dụng ban đầu và liên tục.


Trong trường hợp phòng xét nghiệm sử dụng thuốc thử tự chuẩn bị, pha chế hoặc sản xuất trong phòng xét nghiệm, ngoài các thông tin liên quan ở trên, chỉ dẫn đến người hoặc những người thực hiện việc chuẩn bị, cũng như ngày chuẩn bị và ngày hết hạn.

### Thỏa thuận dịch vụ

####  Thỏa thuận với người dùng phòng xét nghiệm

Phòng xét nghiệm phải có quy trình để thiết lập và xem xét định kỳ các thỏa thuận cung cấp các hoạt động của phòng xét nghiệm. Thủ tục phải bảo đảm:

  * các yêu cầu được quy định đầy đủ;

  * phòng xét nghiệm phải có khả năng và nguồn lực để đáp ứng các yêu cầu này;

  * Khi thích hợp, phòng xét nghiệm tư vấn cho người sử dụng các hoạt động cụ thể sẽ được thực hiện bởi các phòng xét nghiệm bên ngoài và chuyên gia tư vấn.


Người sử dụng phòng xét nghiệm phải được thông báo về mọi thay đổi đối với thỏa thuận có thể ảnh hưởng đến kết quả xét nghiệm.

Hồ sơ xem xét, bao gồm bất kỳ thay đổi quan trọng nào, phải được lưu giữ.

#### Thỏa thuận với bộ phận thực hiện POCT

Các thỏa thuận dịch vụ giữa phòng xét nghiệm và các bộ phận khác của tổ chức sử dụng POCT được phòng xét nghiệm hỗ trợ phải đảm bảo rằng các trách nhiệm và quyền hạn tương ứng được chỉ định và truyền đạt.

###  Các sản phẩm và dịch vụ do bên ngoài cung cấp

####  Tổng quát

Phòng xét nghiệm phải đảm bảo rằng các sản phẩm và dịch vụ do bên ngoài cung cấp có ảnh hưởng đến các hoạt động của phòng xét nghiệm là phù hợp khi các sản phẩm và dịch vụ đó:

  * dự định kết hợp vào các hoạt động riêng của phòng xét nghiệm;

  * được cung cấp, một phần hoặc toàn bộ, trực tiếp cho người sử dụng bởi phòng xét nghiệm, khi nhận được từ nhà cung cấp bên ngoài;

  * được sử dụng để hỗ trợ hoạt động của phòng xét nghiệm.


Có thể cần phải cộng tác với các bộ phận hoặc chức năng khác của tổ chức để đáp ứng yêu cầu này.

CHÚ THÍCH: Các dịch vụ bao gồm, ví dụ: dịch vụ lấy mẫu, pipet và các dịch vụ hiệu chuẩn khác, dịch vụ bảo trì cơ sở và thiết bị, chương trình EQA, phòng xét nghiệm bên ngoài và chuyên gia tư vấn.

#### Các phòng xét nghiệm và chuyên gia tư vấn bên ngoài

Phòng xét nghiệm phải truyền đạt các yêu cầu của mình cho các phòng xét nghiệm và các chuyên gia tư vấn bên ngoài cung cấp các giải thích và tư vấn, cho:

  * các thủ tục, kiểm tra, báo cáo và hoạt động tư vấn sẽ được cung cấp;

  * quản lý các kết quả quan trọng;

  * bất kỳ trình độ nhân sự cần thiết và chứng minh năng lực.


Trừ trường hợp được quy định trong thỏa thuận, chính phòng xét nghiệm (chứ không phải là phòng xét nghiệm bên ngoài) phải có trách nhiệm đảm bảo rằng các kết quả xét nghiệm của phòng xét nghiệm bên ngoài được cung cấp cho người yêu cầu.

Một danh sách tất cả các phòng xét nghiệm và chuyên gia tư vấn bên ngoài phải được duy trì.

#### Xem xét và phê duyệt các sản phẩm và dịch vụ do bên ngoài cung cấp

Phòng xét nghiệm phải có các thủ tục và lưu giữ hồ sơ về:

  * xác định, xem xét và phê duyệt các yêu cầu của phòng xét nghiệm đối với tất cả các sản phẩm và dịch vụ do bên ngoài cung cấp;

  * xác định tiêu chí đánh giá năng lực, lựa chọn, đánh giá kết quả thực hiện và đánh giá lại nhà cung cấp bên ngoài;

  * các mẫu tham chiếu; đảm bảo rằng các sản phẩm và dịch vụ do bên ngoài cung cấp phù hợp với các yêu cầu đã được thiết lập của phòng xét nghiệm, hoặc nếu có thể áp dụng cho các yêu cầu


| e) | thực hiện bất kỳ hành động nào phát sinh từ việc đánh giá kết quả
thực hiện của các nhà cung cấp bên ngoài. |  |
| --- | --- | --- |

 

## Yêu cầu về quá trình

### Tổng quát

Phòng xét nghiệm phải xác định các rủi ro tiềm ẩn đối với việc chăm sóc người bệnh trong các quy trình trước xét nghiệm, xét nghiệm và sau xét nghiệm. Những rủi ro này sẽ được đánh giá và giảm thiểu trong phạm vi có thể. Rủi ro còn lại sẽ được thông báo cho người dùng khi có thể.

Các rủi ro đã xác định và hiệu quả của các quy trình giảm thiểu rủi ro phải được theo dõi và đánh giá theo khả năng gây hại tiềm ẩn cho bệnh nhân.

Phòng xét nghiệm cũng phải xác định các cơ hội để cải thiện việc chăm sóc bệnh nhân và phát triển một khuôn khổ để quản lý những cơ hội này.

###  Quá trình trước xét nghiệm

#### Tổng quát

Phòng xét nghiệm phải có các thủ tục cho tất cả các hoạt động trước xét nghiệm và cung cấp sẵn có để tiếp cận được với các nhân viên có liên quan.

CHÚ THÍCH 1: Các quá trình trước xét ghiệm có thể ảnh hưởng đến kết quả của xét nghiệm dự kiến.

CHÚ THÍCH 2: ISO 20658 cung cấp thông tin chi tiết cho việc thu thập và vận chuyển mẫu.

CHÚ THÍCH 3: ISO 20186-1, ISO 20186-2, ISO 20186-3, ISO 20166 (tất cả các phần), ISO 20184 (tất cả các phần), ISO 23118 và ISO 4307 cung cấp thông tin chi tiết cho các mẫu từ các nguồn cụ thể và cho các xét nghiệm cụ thể.

#### Thông tin cho bệnh nhân và người dùng

Phòng xét nghiệm phải có sẵn thông tin thích hợp cho người dùng và bệnh nhân. Thông tin phải đủ chi tiết để cung cấp cho người sử dụng phòng xét nghiệm sự hiểu biết toàn diện về phạm vi hoạt động và yêu cầu của phòng xét nghiệm.

Thông tin phải bao gồm khi thích hợp:

  * (Các) địa điểm của phòng xét nghiệm, giờ hoạt động và thông tin liên lạc;

  * thủ tục yêu cầu và lấy mẫu;

  * phạm vi hoạt động của phòng xét nghiệm và thời gian dự kiến có kết quả;

  * sự sẵn có của các dịch vụ tư vấn;

# Public_009

# Học phần

## A – Phần bắt buộc:

### Những nguyên lý cơ bản của Chủ nghĩa Mác – Lênin

_Cấu trúc học phần:5_ (5:0:10)
_Mô tả học phần:_
Môn học Những nguyên lý cơ bản của Chủ nghĩa Mác – Lênin là môn học thuộc chương trình lý luận chính trị nhằm giới thiệu cho người học các kiến thức cơ bản về hệ thống lý luận của chủ nghĩa Mác – Lênin, bao gồm:

  * Thế giới quan và phương pháp luận triết học của Chủ nghĩa Mác – Lênin.

  * Học thuyết kinh tế của Chủ nghĩa Mác – Lênin về phương thức sản xuất tư bản chủ nghĩa.

  * Lý luận của Chủ nghĩa Mác – Lênin về chủ nghĩa xã hội.


### Tư tưởng Hồ Chí Minh

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Môn học tư tưởng Hồ Chí Minh là môn học thuộc chương trình Lý luận chính trị nhằm cung cấp cho người học những hiểu biết có tính hệ thống về:

  * Cơ sở hình thành tư tưởng Hồ Chí Minh

  * Những nội dung về tư tưởng, đạo đức, giá trị văn hoá Hồ Chí Minh.


### Đường lối cách mạng của Đảng cộng sản Việt Nam

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Nội dung chủ yếu của học phần là cung cấp, trang bị cho sinh viên những hiểu biết cơ bản có hệ thống về đường lối của Đảng, đặc biệt là đường lối trong thời kỳ đổi mới, trên một số lĩnh vực cơ bản của đời sống xã hội.

### Pháp luật đại cương

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần trang bị cho sinh viên tất cả các ngành những kiến thức cơ bản về những kiến thức lý luận cơ bản nhất về Nhà nước và pháp luật nói chung, nhà nước và pháp luật xã hội chủ nghĩa nói riêng. Từ đó giúp cho sinh viên có nhận thức, quan điểm đúng đắn về đường lối, chính sách của Đảng và pháp luật của Nhà nước ta. Đồng thời trang bị cho sinh viên những kiến thức cơ bản về hệ thống pháp luật Việt Nam và một số ngành luật cụ thể, giúp cho sinh viên hiểu biết hơn về pháp luật để vận dụng vào thực tiễn cuộc sống.

### Nhập môn ngành CNTT

_Cấu trúc học phần:_ 3(2:1:6)
_Mô tả học phần:_
Học phần Nhập Môn Ngành Công Nghệ Thông Tin được thiết kế để giúp sinh viên năm thứ nhất làm quen với môi trường học đại học, các kiến thức cơ bản của ngành, đồng thời hình thành các kỹ năng mềm và các chuẩn mực đạo đức, ứng xử cần có để sinh viên tiến bước thành công trên con trường trở thành kỹ sư công nghệ thông tin. Cụ thể, học phần này trang bị cho người học các kiến thức cơ bản của ngành về phần cứng, phần mềm, lập trình, mạng máy tính, cũng như các hiểu biết về lịch sử máy tính, các lĩnh vực nghiên cứu, xu hướng phát triển của ngành. Học phần cũng giúp người học phát triển các kỹ năng mềm hữu ích, như phương pháp học đại học, phương pháp hiểu bản thân, kỹ năng tìm kiếm thông tin, kỹ năng làm việc nhóm, kỹ năng thuyết trình; và hiểu biết về các chuẩn mực đạo đức, phẩm chất cần có, như trung thực, bền chí, kỷ luật, vị tha, khiêm tốn.

### Toán 1

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần Toán 1 cung cấp các kiến thức cơ bản về giới hạn, tính liên tục và phép tính vi tích phân của hàm một biến.

### Toán 2

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần Toán 2 cung cấp các kiến thức cơ bản về phép tính tích phân của hàm một biến, chuỗi số, chuỗi lũy thừa, véc-tơ trong mặt phẳng và trong không gian.

### Đại số và cấu trúc đại số

_Cấu trúc học phần:_ 4(4:0:8)
_Mô tả học phần:_
Môn học này bao gồm các kiến thức: Tập hợp, ánh xạ, quan hệ tương đương, quy nạp toán học; ma trận, định thức, hệ phương trình tuyến tính; không gian vectơ, không gian Euclide, ánh xạ tuyến tính, chéo hóa ma trận, dạng toàn phương; lý thuyết về một số cấu trúc đại số như nhóm, vành, trường; và một số ứng dụng như các mô hình tuyến tính, đồ họa máy tính, mã hóa, mật mã,….

### Xác suất thống kê và ứng dụng

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Môn học này bao gồm thống kê mô tả, xác suất sơ cấp, biến ngẫu nhiên và luật phân phối xác suất, các số đặc trưng của biến ngẫu nhiên, ước lượng tham số, kiểm định giả thuyết, tương quan và hồi quy tuyến tính.

### Vật lý 1

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần này cung cấp cho sinh viên những nội dung cơ bản của vật lý bao gồm các phần cơ học và nhiệt học làm cơ sở cho việc tiếp cận các môn học chuyên ngành trình độ đại học các ngành khoa học, kỹ thuật và công nghệ. Sinh viên sẽ được trang bị các kiến thức về vật lý để khảo sát sự chuyển động, năng lượng và các hiện tượng vật lý liên quan đến các đối tượng trong tự nhiên có kích thước từ phân tử đến cỡ hành tinh. Sau khi học xong học phần sinh viên sẽ có khả năng ứng dụng những kiến thức đã học trong nghiên cứu khoa học cũng như trong phát triển kỹ thuật và công nghệ hiện đại.
Nội dung của học phần gồm các chương từ 1 đến 22 trong sách _Physics for Scientists and Engineers with Modern Physics_ , 9th Edition của các tác giả R.A. Serway và J.W. Jewett. Các nội dung của học phần này nhằm giúp sinh viên làm quen với phương pháp khoa học, các định luật cơ bản của vật lý, phát triển hiểu biết về khoa học vật lý nói chung và kỹ năng lập luận cũng như các chiến lược để chuẩn bị cho việc học tập các lớp khoa học chuyên ngành trong chương trình dành cho kỹ sư. Để đạt mục tiêu này, học phần sẽ chú trọng vào việc kết hợp cung cấp những hiểu biết về các khái niệm với các kỹ năng giải các bài tập dạng chuẩn (làm ở nhà) ở cuối mỗi chương.
Bên cạnh đó, học phần sẽ giúp sinh viên hiểu cách xây dựng các mô hình toán học dựa trên các kết quả thực nghiệm, biết cách ghi nhận, trình bày, phân tích số liệu và phát triển một mô hình dựa trên các dữ liệu và có thể sử dụng mô hình này để phán đoán kết quả của các thí nghiệm khác. Đồng thời, sinh viên sẽ biết được giới hạn của mô hình và có thể sử dụng chúng trong việc phán đoán.

### Thí nghiệm vật lý 1

_Cấu trúc học phần:_ 1(0:1:2)
_Mô tả học phần:_
Thí nghiệm Vật lý 1 gồm một đơn vị học phần có 9 bài thí nghiệm về động học, động lực học chất điểm và động lực học vật rắn. Đây là môn học bổ sung cho sinh viên thuộc khối ngành công nghệ hệ cao đẳng và đại học những kiến thức về bản chất các hiện tượng vật lý xảy ra trong tự nhiên, kiểm tra lại các lý thuyết vật lý đã được học trong chương trình nhằm rèn luyện cho các kỹ sư tương lai kỹ năng quan sát, tiến hành thí nghiệm, đo đạc và tính toán, phân tích, xử lý số liệu.

### Điện tử căn bản

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Cung cấp cho sinh viên ngành công nghệ thông tin các kiến thức chung cơ bản và phương pháp phân tích, tính toán các mạch điện và mạch điện tử căn bản thường sử dụng trong thực tế như: mạch điện một chiều, mạch điện xoay chiều, mạch chỉnh lưu, mạch ổn áp, mạch ngắt dẫn dùng BJT, mạch khuếch đại tín hiệu, mạch dao động ...

### Thực tập điện tử căn bản

Môn học này hướng dẫn sinh viên thực hành các mạch kỹ thuật điện tử như mạch chỉnh lưu, mạch xén, mạch nguồn DC, mạch khuếch đại tín hiệu nhỏ, mạch transistor ngắt dẫn, mạch dao động, các mạch điều khiển dùng SCR, TRAC, DIAC, quang trở, op-to, các mạch đếm và thanh ghi và các mạch điện tử ứng dụng trong thực tế.

### Kinh tế học đại cương

_Cấu trúc học phần: 5_ (5:0:10)
_Mô tả học phần:_
Môn Kinh tế học đại cương cung cấp cho sinh viên không chuyên ngành kinh tế những kiến thức cơ bản về kinh tế, những hiện tượng thực tế đang diễn ra trong nền kinh tế dưới góc độ vi mô cũng như vĩ mô.

### Nhập môn quản trị chất lượng

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học những kiến thức cơ bản về chất lượng và quản trị chất lượng. Học phần giới thiệu một số chỉ tiêu và phương pháp đánh giá chất lượng trong tổ chức, đồng thời hướng dẫn sinh viên sử dụng các phương pháp, kỹ thuật và công cụ để quản lý chất lượng. Học phần cung cấp những kiến thức về cách xây dựng và áp dụng hệ thống quản lý chất lượng theo tiêu chuẩn trong các doanh nghiệp.

### Nhập môn quản trị học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học những kiến thức cơ bản về quản trị, bao gồm những yếu tố môi trường tổng quát nhất tác động đến doanh nghiệp và những chức năng cơ bản của quản trị trong tổ chức kinh doanh, bao gồm: hoạch định, tổ chức, lãnh đạo, và kiểm tra.
Bên cạnh đó, các hoạt động trên lớp được thiết kế để nâng cao kỹ năng tìm kiếm thông tin, nói chuyện trước đám đông, tư duy phản biện của sinh viên.

### Kỹ năng học tập đại học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Môn học “Kỹ năng học tập đại học” trang bị cho người học những kiến thức về phương pháp học tập để sinh viên vận dụng hình thành các kỹ năng học tập ở bậc đại học, nhằm nâng cao hiệu quả học tập và nghiên cứu của bản thân. Qua môn học này hình thành ở người học khả năng tổ chức và thực hiện học tập một cách hệ thống, logic và khoa học.

### Kỹ năng làm việc trong môi trường kỹ thuật

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_

Môn học Kỹ năng làm việc trong môi trường kỹ thuật thuộc nhóm môn học tự chọn của khối ngành kỹ thuật công nghệ. Môn học này nhằm hình thành cho sinh viên một số kỹ năng làm việc cơ bản trong môi trường kỹ thuật, đặc biệt là các kỹ năng làm việc trong môi trường đa văn hóa, hiện đại, có sự thay đổi nhanh chóng về công nghệ, như: Kỹ năng (KN) giao tiếp kỹ thuật; KN tư duy sáng 5

tạo; KN giải quyết vấn đề và ra quyết định; KN lập kế hoạch thực hiện dự án; KN làm việc nhóm; KN trình bày ý tưởng/vấn đề kỹ thuật; KN viết tài liệu/báo cáo kỹ thuật; KN sử dụng công nghệ thông tin trong công việc; KN quản lý bản thân.

### Kỹ năng xây dựng kế hoạch

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học những kiến thức cơ bản về phương pháp xây dựng kế hoạch. Hướng dẫn cho người học các kỹ năng tư duy và tìm kiếm giải pháp phù hợp với điều kiện và hoàn cảnh bản thân để từ đó người học hình thành cho mình kỹ năng xây dựng kế hoạch học tập, kế hoạch cá nhân ngắn hạn và dài hạn, kế hoạch cho công việc phù hợp và hiệu quả. Ngoài ra còn hướng dẫn người học cách thức và kỹ năng quản lí thời gian và sắp xếp công việc hiệu quả.

### Phương pháp nghiên cứu khoa học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Trong quá trình đào tạo ở trường Đại học, sinh viên không chỉ lĩnh hội tri thức từ phía giáo viên, mà học còn phải tự học và tự nghiên cứu. Từ tự giác, tích cực và sáng tạo, sinh viên sẽ tìm ra cái mới nhằm giải thích sâu sắc hay có lời giải phù hợp đó chính là sinh viên đã nghiên cứu khoa học. Học phần Phương pháp nghiên cứu khoa học bao gồm những nội dung về các khái niệm, qui trình và cấu trúc... Để từ đó sinh viên định hướng được việc lựa chọn đề tài nghiên cứu, soạn được đề cương và áp dụng được các phương pháp nghiên cứu trong khi thu thập và xử lý thông tin hợp lý trong khi tiến hành công trình nghiên cứu khoa học. Sinh viên sẽ chủ động trong việc đang ký thực hiện đề tài nghiên cứu cấp trường cũng như tiến hành luận văn tốt nghiệp hay đồ án tốt nghiệp một cách khoa học và thành công.

### Tâm lý học kỹ sư

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Để tạo nên sự tương tác giữa công nghệ và con người, sinh viên các ngành kỹ thuật công nghệ cần hiểu được đặc điểm tâm lý cơ bản của con người. Học phần Tâm lý học kỹ sư sẽ cung cấp cho sinh viên các ngành kỹ thuật công nghệ các kiến thức về tâm lý con người và ứng dụng các kiến thức này vào thiết kế hệ thống kỹ thuật phù hợp với con người.

### Tư duy hệ thống

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_ Học phần Tư duy hệ thống trang bị cho sinh viên những kiến thức cơ bản về hệ thống, phương pháp luận tư duy hệ thống, các phương pháp tư duy sáng tạo; hình thành ở sinh viên khả năng lập luận và giải quyết vấn đề một cách hệ thống, logic và sáng tạo.

### Nhập môn logic học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học kiến thức về quá trình nhận thức của con người nhận thức và bản chất của hoạt động tư duy. Người học được cung cấp kiến thức về các quy luật cơ bản của tư duy và các hình thức của tư duy qua đó rèn luyện tư duy logic, có thể sử dụng chính xác từ, câu trong diễn đạt tư tưởng, có kỹ năng lập luận, diễn giải cũng như chứng minh, bác bỏ vấn đề có sức thuyết phục, suy nghĩ chín chắn, nhất quán, khắc phục những sai phạm trong tư duy, trong giao tiếp.

### Nhập môn xã hội học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần trang bị cho sinh viên không chuyên ngành xã hội học, trường Đại học Sư phạm Kỹ thuật TP.HCM những kiến thức cơ bản về hệ thống lý luận Xã hội học, lịch sử hình thành và phát triển của ngành khoa học xã hội trong tiến trình phát triển của nhận thức, tiến bộ xã hội và khoa học kỹ thuật; các khái niệm, phạm trù và các lĩnh vực nghiên cứu chính của khoa học xã hội học trong đời sống con người thông qua các phương pháp và kỹ thuật nghiên cứu, học tập môn học xã hội học.

### Cơ sở văn hoá Việt Nam

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này được thiết kế cho sinh viên năm thứ hai ở bậc đại học nhằm cung cấp cho sinh viên những kiến thức cơ bản về văn hoá nói chung, văn hoá Việt Nam nói riêng; giúp sinh viên nắm bắt những đặc trưng cơ bản của văn hoá Việt Nam từ truyền thống đến hiện đại; biết tự định hướng trong thế giới thông tin đa dạng, đa chiều hiện nay, tiếp thu có chọn lọc những tinh hoa văn hoá của nhân loại trên nền tảng bảo tồn và phát triển những giá trị truyền thống tốt đẹp của dân tộc và con người Việt Nam một cách chủ động, tích cực. Bên cạnh đó, học phần này còn giúp hỗ trợ cho sinh viên hình thành và rèn luyện một số kỹ năng học tập tích cực như: kỹ năng tìm kiếm tài liệu tham khảo, kỹ năng thuyết trình trước đám đông, kỹ năng làm việc nhóm.

# Public_010

# Tiêu chuẩn phòng xét nghiệm

## Lập kế hoạch liên tục và chuẩn bị cho tình huống khẩn cấp

Phòng xét nghiệm phải đảm bảo rằng các rủi ro liên quan đến các tình huống khẩn cấp hoặc các điều kiện khác khi các hoạt động của phòng xét nghiệm bị hạn chế hoặc không khả dụng, đã được xác định và tồn tại một chiến lược phối hợp bao gồm các kế hoạch, các quy trình, và biện pháp kỹ thuật để cho phép tiếp tục hoạt động sau khi bị gián đoạn.
Các kế hoạch phải được kiểm tra định kỳ và khả năng ứng phó theo kế hoạch được thực hiện, nếu có thể.
Phòng xét nghiệm có trách nhiệm:

  * thiết lập một kế hoạch ứng phó với các tình huống khẩn cấp, có tính đến nhu cầu và khả năng của tất cả các nhân viên phòng xét nghiệm có liên quan;

  * cung cấp thông tin và đào tạo thích hợp cho nhân viên phòng xét nghiệm có liên quan;

  * ứng phó với các tình huống khẩn cấp trong thực tế;

  * hành động để ngăn chặn hoặc giảm thiểu hậu quả của các tình huống khẩn cấp, phù hợp với mức độ khẩn cấp và tác động tiềm tàng.


CHÚ THÍCH: CLSI GP36-A [35] cung cấp thêm chi tiết.

## Yêu cầu hệ thống quản lý

### Yêu cầu chung

#### Tổng quát

Phòng xét nghiệm phải thiết lập, lập thành văn bản, thực hiện và duy trì một hệ thống quản lý để hỗ trợ và chứng minh việc đáp ứng nhất quán các yêu cầu của tiêu chuẩn này.
Tối thiểu, hệ thống quản lý của phòng xét nghiệm phải bao gồm những nội dung sau đây:

  * Trách nhiệm

  * Mục tiêu và chính sách

  * Thông tin tài liệu

  * Hành động để giải quyết rủi ro và cơ hội cải tiến

  * Cải tiến liên tục

  * Hành động khắc phục

  * Đánh giá và đánh giá nội bộ

  * Xem xét của lãnh đạo


#### Đáp ứng các yêu cầu của hệ thống quản lý

Phòng xét nghiệm có thể đáp ứng 8.1.1 bằng cách thiết lập, thực hiện và duy trì hệ thống quản lý chất lượng (ví dụ: phù hợp với các yêu cầu của ISO 9001) (xem Bảng B.1). Hệ thống quản lý chất lượng này phải hỗ trợ và chứng minh sự đáp ứng nhất quán các yêu cầu từ điều 4 đến điều 7 và các yêu cầu được quy định trong 8.2 đến 8.9.

#### Nhận thức về hệ thống quản lý

Phòng xét nghiệm phải bảo đảm rằng những người làm công việc dưới sự kiểm soát của phòng xét nghiệm nhận thức được:

  * các mục tiêu và chính sách có liên quan;

  * đóng góp của họ vào hiệu quả của hệ thống quản lý, bao gồm cả lợi ích của việc cải thiện hiệu suất;

  * hậu quả của việc không phù hợp với các yêu cầu của hệ thống quản lý.


### Tài liệu hệ thống quản lý

####  Tổng quát

Ban lãnh đạo phòng xét nghiệm phải thiết lập, lập thành văn bản và duy trì các mục tiêu và chính sách để thực hiện các mục đích của tài liệu này và phải đảm bảo rằng các mục tiêu và chính sách được thừa nhận và thực hiện ở tất cả các cấp của tổ chức phòng xét nghiệm.
CHÚ THÍCH: Các tài liệu của hệ thống quản lý có thể, nhưng không bắt buộc, được đưa vào sổ tay chất lượng.

#### Năng lực và chất lượng

Các mục tiêu và chính sách phải đề cập đến năng lực, chất lượng và hoạt động nhất quán của phòng xét nghiệm.

#### Bằng chứng cam kết

Lãnh đạo phòng xét nghiệm phải cung cấp bằng chứng về cam kết xây dựng, thực hiện và cải tiến liên tục hiệu lực của hệ thống quản lý.

####  Tài liệu

Tất cả tài liệu, quy trình, hệ thống và hồ sơ liên quan đến việc đáp ứng các yêu cầu của tiêu chuẩn này phải được đưa vào, tham chiếu từ hoặc liên kết với hệ thống quản lý.

####  Tiếp cận của nhân viên

Tất cả nhân viên tham gia vào các hoạt động của phòng xét nghiệm phải có quyền truy cập vào các phần của tài liệu hệ thống quản lý và thông tin liên quan áp dụng cho trách nhiệm của họ.

### Kiểm soát tài liệu hệ thống quản lý

#### Tổng quát

Phòng xét nghiệm phải kiểm soát các tài liệu (nội bộ và bên ngoài) liên quan đến việc thực hiện tiêu chuẩn này.
CHÚ THÍCH: Trong ngữ cảnh này, "tài liệu" có thể là tuyên bố chính sách, quy trình và hướng dẫn công việc liên quan,
lưu đồ, hướng dẫn sử dụng, thông số kỹ thuật, hướng dẫn của nhà sản xuất, bảng hiệu chuẩn, khoảng tham chiếu sinh
học và nguồn gốc của chúng, biểu đồ, áp phích, thông báo, bản ghi nhớ, tài liệu phần mềm, bản vẽ, kế hoạch, thỏa thuận
và các tài liệu có nguồn gốc bên ngoài như luật, quy định, tiêu chuẩn và sách giáo khoa để lấy phương pháp xét nghiệm,
tài liệu mô tả trình độ nhân sự (như mô tả công việc), v.v. Những tài liệu này có thể ở bất kỳ dạng hoặc loại nào của phương tiện, chẳng hạn như bản cứng hoặc kỹ thuật số.

####  Kiểm soát tài liệu

Phòng xét nghiệm phải đảm bảo rằng:

  * các tài liệu được xác định là duy nhất;

  * các tài liệu được phê duyệt về tính phù hợp trước khi ban hành bởi nhân viên có chuyên môn, và năng lực, đủ thẩm quyền để xác định tính phù hợp của tài liệu;

  * tài liệu được xem xét định kỳ và cập nhật khi cần thiết;

  * các phiên bản liên quan của các tài liệu áp dụng có sẵn tại nơi sử dụng và, khi cần thiết, việc phân phối chúng được kiểm soát;

  * những thay đổi và trạng thái sửa đổi hiện tại của các tài liệu được nhận biết;

  * các tài liệu được bảo vệ khỏi những thay đổi trái phép và bất kỳ việc việc xóa hoặc loại bỏ nào;

  * các tài liệu được bảo vệ khỏi truy cập trái phép;

  * ngăn ngừa việc sử dụng ngoài ý muốn các tài liệu lỗi thời và áp dụng cách nhận dạng phù hợp cho chúng nếu chúng được giữ lại cho bất kỳ mục đích nào;

  * Ít nhất một bản sao giấy hoặc điện tử của tài liệu lỗi thời được kiểm soát phải được giữ lại trong một khoảng thời gian quy định hoặc theo yêu cầu quy định thích hợp.


### Kiểm soát hồ sơ

#### Tạo hồ sơ

Phòng xét nghiệm phải thiết lập và lưu giữ các hồ sơ rõ ràng để chứng minh việc đáp ứng các yêu cầu của tài liệu này.
Hồ sơ phải được lập vào thời điểm mỗi hoạt động có ảnh hưởng đến chất lượng của xét nghiệm được thực hiện.
CHÚ THÍCH: Hồ sơ có thể ở bất kỳ hình thức hoặc loại phương tiện nào.

#### Sửa đổi hồ sơ

Phòng xét nghiệm phải đảm bảo rằng các sửa đổi đối với hồ sơ có thể được truy nguyên tới các phiên bản trước đó hoặc các quan sát ban đầu. Cả các tệp và dữ liệu gốc và dữ liệu sửa đổi đều phải được lưu giữ, bao gồm ngày và nếu có liên quan, thời gian, thay đổi, chỉ dẫn về các khía cạnh đã thay đổi và nhân viên thực hiện các thay đổi.

#### Lưu giữ hồ sơ

  * Phòng xét nghiệm phải thực hiện các thủ tục cần thiết để xác định, lưu trữ, bảo vệ khỏi truy cập và thay đổi trái phép, sao lưu, lưu trữ, truy xuất, thời gian lưu giữ và hủy bỏ hồ sơ của mình.

  * Thời gian lưu giữ hồ sơ phải được xác định cụ thể.


CHÚ THÍCH 1: Ngoài các yêu cầu, thời gian lưu giữ có thể được chọn dựa trên các rủi ro đã xác định.

  * Các kết quả xét nghiệm đã báo cáo phải truy xuất được trong khoảng thời gian cần thiết hoặc theo quy định.

  * Tất cả các hồ sơ phải truy cập được trong toàn bộ thời gian lưu giữ, có thể đọc được trong bất kỳ phương tiện nào mà phòng xét nghiệm lưu giữ hồ sơ và sẵn có để lãnh đạo phòng xét nghiệm xem xét


CHÚ THÍCH 2: Vấn đề trách nhiệm pháp lý liên quan đến một số loại thủ tục nhất định (ví dụ như các xét nghiệm mô học, các xét nghiệm di truyền, các xét nghiệm nhi khoa) có thể yêu cầu việc lưu giữ một số hồ sơ trong khoảng thời gian dài hơn rất nhiều so với các hồ sơ khác.

### Các hành động để giải quyết rủi ro và cơ hội cải tiến

####  Xác định rủi ro và cơ hội cải tiến

Phòng xét nghiệm phải xác định các rủi ro và cơ hội cải tiến liên quan đến các hoạt động của phòng xét nghiệm để:

  * ngăn ngừa hoặc giảm thiểu các tác động không mong muốn và các sai sót tiềm ẩn trong các hoạt động của phòng xét nghiệm;

  * đạt được sự cải tiến, bằng cách hành động dựa trên các cơ hội;

  * đảm bảo rằng hệ thống quản lý đạt được các kết quả dự kiến;

  * giảm thiểu rủi ro đối với việc chăm sóc bệnh nhân;

  * giúp đạt được mục đích và mục tiêu của phòng xét nghiệm.


####  Hành động dựa trên rủi ro và cơ hội cải tiến

Phòng xét nghiệm phải ưu tiên và hành động đối với các rủi ro đã xác định. Các hành động được thực hiện để giải quyết rủi ro phải tỷ lệ thuận với tác động tiềm ẩn đối với các kết quả xét nghiệm trong phòng xét nghiệm, cũng như sự an toàn của bệnh nhân và nhân viên.
Phòng xét nghiệm phải ghi lại các quyết định đã đưa ra và các hành động được thực hiện đối với các rủi ro và cơ hội.
Phòng xét nghiệm phải tích hợp và thực hiện các hành động đối với các rủi ro đã xác định và các cơ hội cải tiến vào hệ thống quản lý của mình và đánh giá hiệu quả của chúng.
CHÚ THÍCH 1: Các lựa chọn để giải quyết rủi ro có thể bao gồm xác định và tránh các mối đe dọa, loại bỏ nguồn rủi ro, giảm khả năng xảy ra hoặc hậu quả của rủi ro, chuyển giao rủi ro, chấp nhận rủi ro để theo đuổi cơ hội cải tiến hoặc chấp nhận rủi ro bằng quyết định sáng suốt.
CHÚ THÍCH 2: Mặc dù tài liệu này yêu cầu phòng xét nghiệm xác định và giải quyết các rủi ro nhưng không có yêu cầu đối với bất kỳ phương pháp quản lý rủi ro cụ thể nào. Các phòng xét nghiệm có thể sử dụng ISO 22367 và ISO 35001 để được hướng dẫn.
CHÚ THÍCH 3: Cơ hội cải tiến có thể dẫn đến việc mở rộng phạm vi hoạt động của phòng xét nghiệm, áp dụng công nghệ mới hoặc tạo ra các khả năng khác để đáp ứng nhu cầu của bệnh nhân và người dùng.

### Cải tiến

####  Cải tiến liên tục

  * Phòng xét nghiệm phải cải tiến liên tục hiệu quả của hệ thống quản lý, bao gồm các quy trình trước xét nghiệm, xét nghiệm và sau xét nghiệm như đã nêu trong các mục tiêu và chính sách.

  * Phòng xét nghiệm phải xác định và lựa chọn các cơ hội để cải tiến và phát triển, lập thành văn bản và thực hiện mọi hành động cần thiết. Các hoạt động cải tiến phải được hướng vào các lĩnh vực có mức độ ưu tiên cao nhất dựa trên đánh giá rủi ro và các cơ hội đã được xác định


CHÚ THÍCH: Các cơ hội để cải tiến có thể được xác định thông qua đánh giá rủi ro, sử dụng các chính sách, xem xét các quy trình vận hành, mục tiêu tổng thể, báo cáo đánh giá bên ngoài, kết quả đánh giá nội bộ, khiếu nại, hành động khắc phục, xem xét của lãnh đạo, đề xuất từ nhân viên, đề xuất hoặc phản hồi từ bệnh nhân và người dùng, phân tích dữ liệu và kết quả EQA.

  * Phòng xét nghiệm phải đánh giá hiệu quả của các hành động được thực hiện.

  * Lãnh đạo phòng xét nghiệm phải đảm bảo rằng phòng xét nghiệm tham gia vào các hoạt động cải tiến liên tục bao gồm các lĩnh vực và kết quả chăm sóc bệnh nhân có liên quan.


  * Lãnh đạo phòng xét nghiệm phải trao đổi với nhân viên về kế hoạch cải tiến của mình và các mục tiêu liên quan.


####  Phản hồi của bệnh nhân, người dùng và nhân viên phòng xét nghiệm

Phòng xét nghiệm phải tìm kiếm phản hồi từ bệnh nhân, người dùng và nhân viên của mình. Phản hồi phải được phân tích và sử dụng để cải thiện hệ thống quản lý, các hoạt động của phòng xét nghiệm và dịch vụ cho người dùng. Hồ sơ phản hồi phải được duy trì bao gồm cả các hành động được thực hiện. Phải thông báo cho nhân viên về các hành động được thực hiện phát sinh từ phản hồi của họ.

### Sự không phù hợp và hành động khắc phục

#### Các hành động khi xảy ra sự không phù hợp

Khi xảy ra sự không phù hợp, phòng xét nghiệm phải:

  * Phản hồi về sự không phù hợp và, khi thích hợp:

* có hành động ngay lập tức để kiểm soát và khắc phục sự không phù hợp;

* giải quyết các hậu quả, đặc biệt tập trung vào sự an toàn của bệnh nhân bao gồm cả việc cáo cáo cho người thích hợp.

  * Xác định (các) nguyên nhân của sự không phù hợp.

  * Đánh giá sự cần thiết của hành động khắc phục để loại bỏ (các) nguyên nhân của sự không phù hợp, nhằm giảm khả năng tái diễn hoặc xảy ra ở nơi khác, bằng cách:

* xem xét và phân tích sự không phù hợp;

* xác định xem có tồn tại hoặc có khả năng xảy ra sự không phù hợp tương tự hay không;

* đánh giá (các) rủi ro tiềm ẩn và (các) ảnh hưởng nếu sự không phù hợp tái diễn.

  * Thực hiện mọi hành động cần thiết.

  * Xem xét và đánh giá hiệu quả của mọi hành động khắc phục đã được thực hiện.

  * Cập nhật rủi ro và cơ hội để cải tiến, khi cần.

  * Thực hiện các thay đổi đối với hệ thống quản lý, nếu cần thiết.


####  Hiệu quả của hành động khắc phục

Các hành động khắc phục phải phù hợp với tác động của sự không phù hợp gặp phải và phải giảm thiểu (các) nguyên nhân đã xác định.

#### Hồ sơ về sự không phù hợp và hành động khắc phục

Phòng xét nghiệm phải lưu giữ hồ sơ làm bằng chứng về

  * bản chất của sự không phù hợp, (các) nguyên nhân và mọi hành động tiếp theo được thực hiện, và

  * đánh giá hiệu quả của mọi hành động khắc phục.


###  Đánh giá

#### Tổng quát

Phòng xét nghiệm phải tiến hành đánh giá theo các khoảng thời gian theo kế hoạch để chứng minh rằng việc quản lý, hỗ trợ và các quy trình trước xét nghiệm, xét nghiệm và sau xét nghiệm đáp ứng nhu cầu và yêu cầu của bệnh nhân và người sử dụng phòng xét nghiệm, đồng thời đảm bảo tuân thủ với các yêu cầu của tài liệu này.

#### Chỉ tiêu chất lượng

Quá trình giám sát các chỉ số chất lượng [xem 5.5 d)] phải được lập kế hoạch, bao gồm thiết lập các mục tiêu, phương pháp luận, diễn giải, giới hạn, kế hoạch hành động và thời gian giám sát. Các chỉ số phải được xem xét định kỳ, để đảm bảo tính phù hợp liên tục.

####  Đánh giá nội bộ

##### Phòng xét nghiệm phải tiến hành đánh giá nội bộ theo các khoảng thời gian dự kiến để cung cấp thông tin về việc hệ thống quản lý có

  * phù hợp với các yêu cầu riêng của phòng xét nghiệm đối với hệ thống quản lý, bao gồm tất cả các hoạt động của phòng xét nghiệm,

  * phù hợp với các yêu cầu của tài liệu này, và

  * được thực hiện và duy trì hiệu quả.


Phòng xét nghiệm phải lập kế hoạch, thiết lập, thực hiện và duy trì một chương trình đánh giá nội bộ bao gồm:

  * ưu tiên đối với rủi ro cho bệnh nhân từ các hoạt động của phòng xét nghiệm;

  * lịch trình có tính đến các rủi ro đã xác định; kết quả của cả đánh giá bên ngoài và đánh giá nội bộ trước đó; sự xuất hiện của những sự không phù hợp, sự cố và khiếu nại; và những thay đổi ảnh hưởng đến hoạt động của phòng xét nghiệm;

  * quy định cụ thể mục tiêu, chuẩn mực và phạm vi đánh giá cho từng cuộc đánh giá;

  * lựa chọn các chuyên gia đánh giá được đào tạo, có năng lực và được ủy quyền để đánh giá kết quả hoạt động của hệ thống quản lý của phòng xét nghiệm, và khi các nguồn lực cho phép, độc lập với hoạt động được đánh giá;

  * bảo đảm tính khách quan và công bằng của quá trình đánh giá;

  * đảm bảo rằng các kết quả đánh giá được báo cáo cho những người có liên quan;

  * thực hiện ngay các hành động thích hợp khi xác định được sự không phù hợp;

  * lưu giữ hồ sơ làm bằng chứng về việc thực hiện chương trình đánh giá và kết quả đánh giá.


CHÚ THÍCH: ISO 19011 cung cấp hướng dẫn cho đánh giá hệ thống quản lý.

### Xem xét của lãnh đạo

#### Tổng quát

Lãnh đạo phòng xét nghiệm phải xem xét hệ thống quản lý của mình theo các khoảng thời gian đã hoạch định để đảm bảo tính phù hợp, đầy đủ và hiệu quả liên tục của hệ thống, bao gồm các chính sách và mục tiêu đã nêu liên quan đến việc thực hiện tài liệu này.

#### Đầu vào của xem xét

Đầu vào của việc xem xét của lãnh đạo phải được ghi lại và phải bao gồm các xem xét về ít nhất những nội dung sau:

  * tình trạng của các hành động từ các cuộc xem xét của lãnh đạo trước đó, những thay đổi bên trong và bên ngoài đối với hệ thống quản lý, những thay đổi về khối lượng và loại hình hoạt

  * động của phòng xét nghiệm và sự đầy đủ của các nguồn lực;

  * hoàn thành các mục tiêu và sự phù hợp của các chính sách và thủ tục;

  * kết quả của các đánh giá gần đây, giám sát quá trình sử dụng các chỉ số chất lượng, đánh giá nội bộ, phân tích sự không phù hợp, hành động khắc phục, đánh giá của các cơ quan bên ngoài;

  * phản hồi và khiếu nại của bệnh nhân, người sử dụng và nhân viên;

  * đảm bảo chất lượng về hiệu lực của kết quả;

  * hiệu quả của mọi cải tiến và các hành động được thực hiện để giải quyết các rủi ro và cơ hội cải tiến;

  * hiệu quả của các nhà cung cấp bên ngoài;

  * kết quả tham gia các chương trình so sánh liên phòng;

  * đánh giá các hoạt động POCT;

  * các yếu tố liên quan khác, chẳng hạn như các hoạt động giám sát và đào tạo.


####  Đầu ra của xem xét

Đầu ra của hoạt động xem xét của lãnh đạo phải là hồ sơ về các quyết định và hành động liên quan đến ít nhất:

  * hiệu lực của hệ thống quản lý và các quá trình của nó;

  * cải tiến các hoạt động của phòng xét nghiệm liên quan đến việc đáp ứng các yêu cầu của tài liệu này;

  * cung cấp các nguồn lực cần thiết;

  * cải thiện dịch vụ cho bệnh nhân và người dùng;

  * mọi nhu cầu thay đổi.


Lãnh đạo phòng xét nghiệm phải đảm bảo rằng các hành động phát sinh từ việc xem xét của lãnh đạo phải được hoàn thành trong một khung thời gian xác định.
Các kết luận và hành động phát sinh từ cuộc họp xem xét của lãnh đạo phải được thông báo cho nhân viên phòng xét nghiệm.

# Public_011

# Lịch sử phát triển của mạng máy tính

_Khái niệm mạng máy tính:_

_**Mạng máy tính**_ hay _**mạng**_ ( _computer network, network_ ) là một tập hợp gồm nhiều máy tính hoặc thiết bị xử lý thông tin được kết nối với nhau qua các đường truyền và có sự trao đổi dữ liệu với nhau.

Nhờ có mạng máy tính, thông tin từ một máy tính có thể được truyền sang máy tính khác. Có thể ví mạng máy tính như một hệ thống giao thông vận tải mà hàng hoá trên mạng là dữ liệu, máy tính là nhà máy lưu trữ xử lý dữ liệu, hệ thống đường truyền như là hệ thống đường sá giao thông.

_Ví dụ về mạng_ :

  * Mạng tại Trung tâm Máy tính, Khoa CNTT, Trường ĐHBK Hà Nội

  * Mạng của Tổng cục thuế

  * Mạng Internet


_Lịch sử phát triển của mạng:_

  * Máy tính ra đời từ những năm 1950. Đến đầu những năm 1960 mạng máy tính bắt đầu xuất hiện. Lúc đầu mạng có dạng là một máy tính lớn nối với nhiều trạm cuối ( _terminal_ ). Đến đầu những năm 1970 mạng máy tính là các máy tính độc lập được nối với nhau. Qui mô và mức độ phức tạp của mạng ngày càng tăng.

  * Hiện nay mạng máy tính phát triển rất mạnh ở mọi lĩnh vực mọi nơi. Ngày càng hiếm các máy tính đơn lẻ, không nối mạng. Ngay các máy tính cá nhân ở gia đình cũng được kết nối Internet qua đường điện thoại. Mạng trở thành một yếu tố không thể thiếu của công nghệ thông tin nói riêng, cũng như đời sống nói chung.


# Phân loại mạng máy tính

Có nhiều cách phân loại mạng máy tính. Sau đây là một số cách phân loại thông dụng.

_Cách 1._ Theo mối quan hệ giữa các máy trong mạng

  * _Mạng bình đẳng (peer-to-peer)_ các máy có quan hệ ngang hàng, một máy có thể yêu cầu một máy khác phục vụ.

  * _Mạng khách/chủ_ ( _client/server_ ). Một số máy là server (máy chủ) chuyên phục vụ các máy khác gọi là máy khách (client) hay máy trạm (workstation) khi có yêu cầu. Các dịch vụ có thể là cung cấp thông tin, tính toán hay các dịch vụ Internet.


_Cách 2._ Theo qui mô địa lý. Tuỳ theo qui mô địa lý, có thể phân ra ba loại chính là:

  * _LAN_ ( _Local Area Network)_ mạng cục bộ ở trong phạm vi nhỏ, ví dụ bán kính 500m, số lượng máy tính không quá nhiều, mạng không quá phức tạp.

  * _WAN (Wide Area Network)_ mạng diện rộng, các máy tính có thể ở các thành phố khác nhau. Bán kính có thể 100-200 km. Ví dụ mạng của Tổng cục thuế.

  * _GAN (Global Area Network)_ mạng toàn cầu, máy tính ở nhiều nước khác nhau. Thường mạng toàn cầu là kết hợp của nhiều mạng con. Ví dụ mạng Internet.


# Các thành phần cơ bản của một mạng máy tính

Một mạng máy tính có thể có các thành phần sau:

  * _Các máy tính_

* Để xử lý, lưu trữ và trao đổi thông tin. Ta cũng thường gọi mỗi máy tính trong mạng máy tính là một _nút_ của mạng.

  * _Vỉ mạng_

* Vỉ mạng (Network Interface Card, NIC) cho mỗi máy tính có chức năng giao tiếp giữa máy tính và đường truyền.

  * _Đường truyền_

* Đường truyền, chính xác hơn còn gọi là đường truyền vật lý, là phương tiện (media) truyền tải thông tin dữ liệu, là nơi trên đó thông tin dữ liệu được truyền đi. Ta có thể chia đường truyền thành hai loại là _hữu tuyến_ và _vô tuyến_.

  * _Các thiết bị kết nối mạng_

* Để liên kết các máy tính và các mạng với nhau như HUB, SWITCH, ROUTER, …

  * _Các thiết bị đầu cuối (terminal). Ví dụ:…?_

  * _Các phụ kiện mạng_

* Các phụ kiện mạng khác gồm giắc cắm, ổ cắm, ….

  * _Hệ điều hành mạng_

* Hệ điều hành mạng là một phần mềm điều khiển sự hoạt động của mạng.


  * C _ác phần mềm mạng cho máy tính_

* Hiện nay nói chung các hệ điều hành đều sẵn có khả năng kết nối mạng. Trong trường hợp hệ điều hành của máy tính không có sẵn khả năng kết nối mạng thì các phần mềm này là cần thiết.


  * _Các ứng dụng trên mạng._

* Ví dụ như Email, hệ quản trị cơ sở dữ liệu.


  * _Kiến trúc mạng máy tính_

* _Kiến trúc mạng máy tính_ (network architecture) thể hiện cách kết nối máy tính với nhau và qui ước truyền dữ liệu giữa các máy tính như thế nào. Cách nối các máy tính với nhau gọi là _hình_ _trạng_ ( _topology_ ) của mạng. Tập các qui ước truyền thông gọi là _giao thức_ ( _protocol)._


  * Có hai kiểu nối mạng chủ yếu là _điểm-điểm_ (point to point) và _quảng bá_ (broadcast).

  * Trong kiểu điểm-điểm các đường truyền nối các nút thành từng cặp. Như vậy một nút sẽ gửi dữ liệu đến nút lân cận nó (nút được nối trực tiếp với nó). Nút lân cận sẽ chuyển tiếp dữ liệu như vậy cho đến khi dữ liệu đến đích.


Kiểu nối mạng điểm- điểm có ba dạng chính là : hình sao ( _star_ ), chu trình ( _loop_ ), cây ( _tree_ ) và đầy đủ ( _complete_ ).

![](images/image1.png)

Star Loop Tree complete

Trong kiểu quảng bá các nút nối vào đường truyền chung. Như vậy khi một nút gửi dữ liệu các nút còn lại đều nhận được. Do đó dữ liệu gửi đi cần có địa chỉ đích. Khi một nút nhận được dữ liệu nó sẽ kiểm tra địa chỉ đích xem có phải gửi cho mình không.

![](images/image2.png)

Ring Bus

![](images/image3.png)

# Mạng Internet

_Khái niệm về Internet_

_Internet_ là một mạng máy tính có qui mô toàn cầu (GAN), gồm rất nhiều mạng con và máy tính nối với nhau bằng nhiều loại phương tiện truyền. Internet không thuộc sở hữu của ai cả. Chỉ có các uỷ ban điều phối và kỹ thuật giúp điều hành Internet.

Ban đầu là mạng của Bộ Quốc phòng Mỹ (DoD) dùng để đảm bảo liên lạc giữa các đơn vị quân đội. Sau đó phát triển thành mạng cho các trường đại học và viện nghiên cứu. Cuối cùng mạng có qui mô toàn cầu và trở thành mạng Internet.

_Các dịch vụ chính của Internet_

Ta có thể dùng Internet để thực hiện nhiều dịch vụ mạng. Các dịch vụ thông dụng nhất trên

Internet hiện nay là:

  * Truyền thông tin (FTP, File Transfer Protocol)

  * Truy nhập máy tính từ xa (telnet)

  * Web (WWW) để tìm kiếm và khai thác thông tin trên mạng

  * Thư điện tử (E-mail)

  * Tán gẫu (Chat) trên mạng…


_Lợi ích của Internet_

Trong thời đại của công nghệ thông tin hiện nay Internet có nhiều lợi ích như truyền tin, phổ biến tin, thu thập tin, trao đổi tin một cách nhanh chóng thuận tiện rẻ tiền hơn so với các phương tiện khác như điện thoại, fax. Internet ảnh hưởng đến toàn bộ thế giới đến mọi ngành, mọi lĩnh vực xã hội. Hiện nay Internet thành một yếu tố quan trọng không thiếu được trong thời đại hiện nay, có mặt ở mọi nơi, mọi lĩnh vực, mọi ngành.

_Làm sao để có được các dịch vụ Internet_

Để kết nối được Internet ta cần :

  * Máy tính có Modem (Dial-up, ADSL) hoặc card mạng.

  * Có thuê bao kết nối với Internet: qua mạng, qua đường điện thoại, đường thuê riêng của bưu điện. Thông thường hiện nay kết nối qua điện thoại hoặc qua ADSL

  * Có tài khoản Internet ở trên mạng hay ở một nhà cung cấp dịch vụ Internet (Internet Service Provider, ISP), ví dụ như VNN, FPT.

  * Có phần mềm Internet thông dụng như Web browser để xem trang web, ví dụ IE, FireFox , phần mềm để xem thư hay chat như Outlook, Messenger.

# Public_012

# Các khái niệm cơ bản

## Khái niệm hệ điều hành

Hệ điều hành là một trong các phần mềm hệ thống có tính phổ dụng. Có nhiều cách diễn đạt khác nhau về hệ điều hành xuất phát từ góc độ của người sử dụng khác nhau. Tuy vậy có thể diễn đạt như sau:

_**Hệ điều hành là hệ thống chương trình đảm bảo quản lý tài nguyên của hệ thống tính toán và cung cấp các dịch vụ cho người sử dụng.**_

Thông thường trong các hệ máy tính hiện nay, hệ điều hành được cài đặt trên đĩa.

Nhiệm vụ cụ thể hơn của hệ điều hành là:

  * Khởi động máy tính, tạo môi trường giao tiếp cho người sử dụng.

  * Tự động điều khiển và kiểm soát hoạt động của các thiết bị (ổ đĩa, bàn phím, màn hình, máy in,…).

  * Quản lý việc cấp phát tài nguyên của máy tính như bộ xử lý trung ương, bộ nhớ, các thiết bị vào ra…

  * Quản lý các chương trình đang thực hiện trên máy tính.

  * Thực hiện giao tiếp với người sử dụng để nhận lệnh và thực hiện lệnh.


Hệ điều hành là phần mềm hệ thống, nên phụ thuộc vào cấu trúc của máy tính. Mỗi loại máy tính có hệ điều hành khác nhau. Ví dụ:

  * Máy tính lớn IBM360 có hệ điều hành là DOS, TOS.

  * Máy tính lớn EC-1022 có hệ điều hành là OC-EC.

  * Máy tính cá nhân PC-IBM có hệ điều hành MS-DOS.

  * Mạng máy tính có các hệ điều hành mạng NETWARE, UNIX, WINDOWS-NT…


## Tệp (File)

Tệp là tập hợp các dữ liệu có liên quan với nhau và được tổ chức theo 1 cấu trúc nào đó, thường được lưu trữ bên ngoài máy tính.

Nội dung của tệp có thể là chương trình, dữ liệu, văn bản,... Mỗi tập tin được lưu lên đĩa với một tên riêng phân biệt. Mỗi hệ điều hành có qui ước đặt tên khác nhau, tên tập tin thường có 2 phần: phần tên (name) và phần mở rộng (extension). Phần tên là phần bắt buộc phải có của một tập tin, còn phần mở rộng thì có thể có hoặc không.

  * Phần tên: Bao gồm các ký tự chữ từ A đến Z, các chữ số từ 0 đến 9, các ký tự khác như #, $, %, ~, ^, @, (, ), !, _, khoảng trắng. Phần tên do người tạo ra tập tin đặt. Với MS-DOS phần tên có tối đa là 8 ký tự, với Windows phần tên có thể đặt tối đa 128 ký tự.

  * Phần mở rộng: thường dùng 3 ký tự trong các ký tự nêu trên. Thông thường phần mở rộng do chương trình ứng dụng tạo ra tập tin tự đặt.

  * Giữa phần tên và phần mở rộng có một dấu chấm (.) ngăn cách.


Ta có thể căn cứ vào phần mở rộng để xác định kiểu của file:

  * COM, EXE : Các file khả thi chạy trực tiếp được trên hệ điều hành.

  * TXT, DOC, ... : Các file văn bản.

  * PAS, BAS, ... : Các file chương trình PASCAL, DELPHI, BASIC, ...

  * WK1, XLS, ... : Các file chương trình bảng tính LOTUS, EXCEL ...

  * BMP, GIF, JPG, ... : Các file hình ảnh.

  * MP3, DAT, WMA, … : Các file âm thanh, video.


_Ký hiệu đại diện (Wildcard)_

Để chỉ một nhóm các tập tin, ta có thể sử dụng hai ký hiệu đại diện:

  * Dấu ? dùng để đại diện cho một ký tự bất kỳ trong tên tập tin tại vị trí nó xuất hiện.

  * Dấu * dùng để đại diện cho một chuỗi ký tự bất kỳ trong tên tập tin từ vị trí nó xuất hiện.


Ví dụ:

Bai?.doc

Bai1.doc, Bai6.doc, Baiq.doc, …

Bai*.doc

Bai.doc, Bai6.doc, Bai12.doc, Bai Tap.doc, …

BaiTap.*

BaiTap.doc, BaiTap.xls, BaiTap.ppt, BaiTap.dbf, …

_Lưu ý_ : _Nên đặt tên mang tính gợi nhớ._

## Quản lý tệp của hệ điều hành

_Cấu trúc đĩa từ_

Hệ thống đĩa từ gồm nhiều mặt (side) gắn số hiệu là 0, 1,… Về mặt logic mỗi mặt đãi có một đầu ghi/ đọc (header), đôi khi người ta còn đồng nhất 2 khái niệm này. Mỗi mặt chia thành các rãnh (track - các đường tròn đồng tâm). Các rãnh được đánh số từ ngoài vào trong bắt đầu từ 0. Mỗi rãnh chia thành các cung (Sector), mỗi sector thông thường có dung lượng 512 byte. Một từ trụ (cylinder) gồm các rãnh có cùng bán kính nằm trên các mặt đĩa khác nhau.

_Tổ chức ghi thông tin trên đĩa_

Thông tin lưu trữ trên đĩa dưới dạng các tệp. Mỗi tệp chiếm 1 hoặc nhiều sectors tuỳ dung lượng tệp.

Để thuận lợi cho việc quản lý tệp, hệ điều hành cho phép chia đĩa thành các vùng, mỗi vùng chia thành các vùng con,.... Mỗi vùng có 1 vùng con riêng để lưu trữ thông tin về vùng đó, vùng con này được gọi là thư mục (Directory). Tệp được lưu trữ ở các vùng, vì vậy ta có thể thấy tổ chức lưu trữ này có dạng cây (Tree).

Thư mục là nơi lưu giữ các tập tin theo một chủ đề nào đó theo ý người sử dụng. Đây là biện pháp giúp ta quản lý được tập tin, dễ dàng tìm kiếm chúng khi cần truy xuất. Các tập tin có liên quan với nhau có thể được xếp trong cùng một thư mục. Sau đây là biểu tượng của thư mục hay còn gọi là Folder trong Windows

![](images/image2.jpeg)

Trên mỗi đĩa có một thư mục chung gọi là thư mục gốc. Thư mục gốc không có tên riêng và được ký hiệu là \ (dấu xổ phải: backslash). Dưới mỗi thư mục gốc có các tập tin trực thuộc và các thư mục con. Trong các thư mục con cũng có các tập tin trực thuộc và thư mục con của nó. Thư mục chứa thư mục con gọi là thư mục cha.

Thư mục đang làm việc gọi là thư mục hiện hành.
Tên của thư mục tuân thủ theo cách đặt tên của tập tin.

_Cách xác định tên đầy đủ của tệp_

Tên tệp đầy đủ gồm nơi lưu trữ tệp - đường dẫn từ gốc đến tệp (Path) và tên tệp. Đường dẫn được chỉ ra nhánh cây thư mục chứa tệp, trong đó sử dụng ký hiệu “\” ngăn cách tên các thư mục .

Ví dụ :

C:\TC\BIN\B1.C
…

Hệ điều hành được phân chia thành các phần, phù hợp với các chức năng riêng của công việc.

Những phần này được lưu trên đĩa dưới dạng các tệp (File). Ví dụ:

Hệ điều hành MS-DOS gồm tập các tệp, trong đó có 3 tệp cơ bản:

  * MSDOS.SYS - tệp.

  * IO.SYS - tệp điều khiển vào ra.

  * COMMAND.COM - tệp lệnh.


# Hệ lệnh của hệ điều hành

  * Thao tác với tệp: Sao chép, di chuyển, xoá, đổi tên , xem nội dung tệp

  * Thao tác với thư mục: tạo, xoá, sao chép

  * Thao tác với đĩa: tạo khuôn ( Format), sao chép đĩa


# Hệ điều hành Windows

## Sự ra đời và phát triển

Windows là một bộ chương trình do hãng Microsoft sản xuất. Từ version 3.0 ra đời vào tháng 5 năm 1990 đến nay, Microsoft đã không ngừng cải tiến làm cho môi trường này ngày càng được hoàn thiện.

**Windows 95** : vào cuối năm 1995, ở Việt nam đã xuất hiện một phiên bản mới của Windows mà chúng ta quen gọi là Windows 95. Những cải tiến mới của Windows 95 được liệt kê tóm tắt như sau:

  * Giao diện với người sử dụng được thiết kế lại hoàn toàn nên việc khởi động các chương trình ứng dụng cùng các công việc như mở và lưu cất các tư liệu, tổ chức các tài nguyên trên đĩa và nối kết với các hệ phục vụ trên mạng - tất cả đều trở nên đơn giản và dễ dàng hơn.

  * Cho phép đặt tên cho các tập tin dài đến 255 ký tự. Điều này rất quan trọng vì những tên dài sẽ giúp ta gợi nhớ đến nội dung của tập tin.

  * Hỗ trợ Plug and Play, cho phép tự động nhận diện các thiết bị ngoại vi nên việc cài đặt và quản lý chúng trở nên đơn giản hơn.

  * Hỗ trợ tốt hơn cho các ứng dụng Multimedia. Với sự tích hợp Audio và Video của Windows 95, máy tính cá nhân trở thành phương tiện giải trí không thể thiếu được.

  * Windows 95 là hệ điều hành 32 bit, vì vậy nó tăng cường sức mạnh và khả năng vận hành lên rất nhiều.

  * Trong Windows 95 có các công cụ đã được cải tiến nhằm chuẩn hoá, tối ưu hoá và điều chỉnh các sự cố. Điều này giúp bạn yên tâm hơn khi làm việc với máy vi tính trong môi trường của Windows 95.


Tóm lại, với những tính năng mới ưu việt và tích hợp cao, Windows 95 đã trở thành môi trường làm việc được người sử dụng ưa chuộng và tin dùng.

**Windows 98, Windows Me:** là những phiên bản tiếp theo của Windows 95, những phiên bản này tiếp tục phát huy và hoàn thiện những tính năng ưu việt của Windows 95 và tích hợp thêm những tính năng mới về Internet và Multimedia.

**Windows NT 4.0, Windows 2000, Windows XP, Windows 2003:** là những hệ điều hành được phát triển cao hơn, được dùng cho các cơ quan và doanh nghiệp. Giao diện của những hệ điều hành này tương tự như Windows 98/ Windows Me. Điểm khác biệt là những hệ điều hành này có tính năng bảo mật cao, vì vậy nó được sử dụng cho môi trường có nhiều người dùng.

**Windows VISTA,** đây là sản phẩm mới của MicroSoft hỗ trợ tốt cho các dịch vụ mạng, trò chơi, văn phòng,..

Giáo trình này sẽ trình bày dựa vào hệ điều hành Windows XP.

## Khởi động và thoát khỏi Windows XP

_Khởi động Windows XP_

Windows XP được tự động khởi động sau khi bật máy. Sẽ có thông báo yêu cầu nhập vào tài khoản (User name) và mật khẩu (Password) của người dùng. Thao tác này gọi là đăng nhập (logging on).

Mỗi người sử dụng sẽ có một tập hợp thông tin về các lựa chọn tự thiết lập cho mình (như bố trí màn hình, các chương trình tự động chạy khi khởi động máy, tài nguyên/ chương trình được phép sử dụng, v.v...) gọi là user profile và được Windows XP lưu giữ lại để sử dụng cho những lần khởi động sau.

_Thoát khỏi Windows XP:_

Khi muốn thoát khỏi Windows XP, bạn phải đóng tất cả các cửa sổ đang mở. Tiếp theo bạn nhấn tổ hợp phím Alt + F4 hoặc chọn menu Start (nếu không nhìn thấy nút Start ở phía dưới bên góc trái màn hình thì bạn nhấn tổ hợp phím Ctrl + Esc) và chọn Turn Off Computer. Sau thao tác này một hộp thoại sẽ xuất hiện như bên dưới.

Nếu bạn chọn Turn Off, ứng dụng đang làm việc sẽ được đóng lại và máy sẽ tự động tắt. Nếu vì một lý do nào đó mà máy tính không sẵn sàng để đóng (chưa lưu dữ liệu cho một ứng dụng hoặc sự trao đổi thông tin giữa hai máy nối mạng đang tiếp diễn v.v..) thì sẽ có thông báo để xử lý.

**Chú ý:** nếu không làm những thao tác đóng Windows như vừa nói ở trên mà tắt máy ngay thì có thể sẽ xảy ra việc thất lạc một phần của nội dung các tập tin dẫn đến trục trặc khi khởi động lại ở lần sử dụng tiếp theo.

## Một số thuật ngữ và thao tác thường sử dụng

_Biểu tượng_ ( _icon_ )

Biểu tượng là các hình vẽ nhỏ đặc trưng cho một đối tượng nào đó của Windows hoặc của các ứng dụng chạy trong môi trường Windows. Phía dưới biểu tượng là tên biểu tượng. Tên này mang một ý nghĩa nhất định, thông thường nó diễn giải cho chức năng được gán cho biểu tượng (ví dụ nó mang tên của 1 trình ứng dụng).

_Cửa sổ (Windows ):_

Cửa sổ là khung giao tiếp đồ họa của 1 ứng dụng hoặc 1 lệnh.

  * Bố cục của 1 cửa sổ : gồm thanh tiêu đề, thanh thực đơn, 1 số thành phần khác phụ thuộc vào loại cửa sổ,…

  * Các hộp giao tiếp

  * Các thao tác trên một cửa sổ

* Di chuyển cửa sổ: Drag thanh tiêu đề cửa sổ (Title bar) đến vị trí mới.

* Thay đổi kích thước của cửa sổ: Di chuyển con trỏ chuột đến cạnh hoặc góc cửa sổ, khi con trỏ chuột biến thành hình mũi tên hai chiều thì Drag cho đến khi đạt được kích thước mong muốn.

* Phóng to cửa sổ ra toàn màn hình: Click lên nút Maximize ![](images/image3.jpeg) .

* Phục hồi kích thước trước đó của cửa sổ: Click lên nút Restore ![](images/image4.jpeg) .

* Thu nhỏ cửa sổ thành biểu tượng trên Taskbar: Click lên nút Minimize ![](images/image5.jpeg) .

* Chuyển đổi giữa các cửa sổ của các ứng dụng đang mở: Để chuyển đổi giữa các ứng dụng nhấn tổ hợp phím Alt + Tab hoặc chọn ứng dụng tương ứng trên thanh

  * Taskbar.

* Đóng cửa sổ: Click lên nút Close ![](images/image6.jpeg) của cửa sổ hoặc nhấn tổ hợp phím Alt + F4.


_Hộp hội thoại (Dialogue box)_

Trong khi làm việc với Windows và các chương tình ứng dụng chạy dưới môi trường Windows bạn thường gặp những hộp hội thoại. Các hộp thoại này xuất hiện khi nó cần thêm những thông số để thực hiện lệnh theo yêu cầu của bạn. Hình dưới đây giới thiệu các thành phần của hộp hội thoại

Thông thường, trên một hộp hội thoại sẽ có các thành phần sau:

  * Hộp văn bản (Text box): dùng để nhập thông tin.

  * Hộp liệt kê (List box): liệt kê sẵn một danh sách có các mục có thể chọn lựa, nếu số mục trong danh sách nhiều không thể liệt kê hết thì sẽ xuất hiện thanh trượt để cuộn danh sách.

  * Hộp liệt kê thả (Drop down list box/ Combo box): khi nhắp chuột vào nút thả thì sẽ buông xuống một danh sách.

  * Hộp kiểm tra (Check box): có 2 dạng , dạng hình vuông thể hiện việc cho phép không

* chọn, chọn 1 hoặc nhiều mục không loại trừ lẫn nhau. Dạng ô tròn (Option button): bắt buộc phải chọn một trong số các mục. Đây là những lựa chọn loại trừ lẫn nhau.

  * Nút lệnh (Command Button): lệnh cần thực thi.Các loại nút lệnh thường gặp có:

* **OK( hoặc bấm phím Enter)** : thực hiện lệnh ( chấp nhận)

* **Close** : giữ lại các thông số đã chọn và đóng cửa sổ

* **Cancel** ( **hay nhấn phím Esc** ): không thực hiện lệnh ( từ chối thực hiện)

* **Apply** : áp dụng các thông số đã chọn.

* **Default** : đặt mặc định theo các thông số

# Public_013

# Thông tin- Information

Khái niệm thông tin (information) được sử dụng thường ngày.Thông tin mang lại cho con người sự hiểu biết, nhận thức tốt hơn về những đối tượng trong đời sống xã hội, trong thiên nhiên,... giúp cho họ thực hiện hợp lý công việc cần làm để đạt tới mục đích một cách tốt nhất.

Người ta quan niệm rằng, thông tin là kết quả xử lý, điều khiển và tổ chức dữ liệu theo cách mà nó sẽ bổ sung thêm tri thức cho người nhận. Nói một cách khác, thông tin là ngữ cảnh trong đó dữ liệu được xem xét

Dữ liệu - Data

Dữ liệu (data) là biểu diễn của thông tin được thể hiện bằng các tín hiệu vật lý. Thông tin chứa đựng ý nghĩa còn dữ liệu là các sự kiện không có cấu trúc và không có ý nghĩa nếu chúng không được tổ chức và xử lý.

Dữ liệu trong thực tế có thể là:

  * Các số liệu thường được mô tả bằng số như trong các bảng biểu

  * Các ký hiệu qui ước, ví dụ chữ viết

  * Các tín hiệu vật lý ví dụ như ánh sáng, âm thanh, nhiệt độ, áp suất,…


Theo quan niệm chung của những người làm công nghệ thông tin thì thông tin là những hiểu biết của chúng ta về một lĩnh vực nào đấy, còn dữ liệu là thông tin được biểu diễn và xử lý trong máy tính.

## Tri thức – Knowledge

Tri thức theo nghĩa thường là thông tin ở mức trừu tượng hơn. Tri thức khá đa dạng, nó có thể là sự kiện, là thông tin và cách mà một người thu thập được qua kinh nghiệm hoặc qua đào tạo. Nó có thể là sự hiểu biết chung hay về một lĩnh vực cụ thể nào đó. Thuật ngữ tri thức được sử dụng theo nghĩa “hiểu” về một chủ thể với một tiềm năng cho một mục đích chuyên dụng.

Hệ thống thông tin ( _information system_ ) là một hệ thống ghi nhận dữ liệu, xử lý chúng để tạo nên thông tin có ý nghĩa hoặc dữ liệu mới.

# Qui trình xử lý thông tin

Mọi quá trình xử lý thông tin bằng máy tính hay bởi con người đều được thực hiện theo một qui trình sau:

Dữ liệu (Data) được nhập ở đầu vào (Input), qua quá trình xử lý để nhận được thông tin ở đầu ra (Output). Dữ liệu trong quá trình nhập, xử lý và xuất đều có thể được lưu trữ.

_Xử lý thông tin bằng máy tính điện tử_

Thông tin được thu thập và lưu trữ, qua quá trình xử lý có thể trở thành dữ liệu mới để theo một quá trình xử lý dữ liệu khác tạo ra thông tin mới hơn theo ý đồ của con người.

Con người có nhiều cách để có dữ liệu và thông tin. Người ta có thể lưu trữ thông tin qua tranh vẽ, giấy, sách báo, hình ảnh trong phim, băng từ. Trong thời đại hiện nay, khi lượng thông tin đến với chúng ta càng lúc càng nhiều thì con người có thể dùng một công cụ hỗ trợ cho việc lưu trữ, chọn lọc và xử lý thông tin gọi là máy tính điện tử (Computer). Máy tính điện tử giúp con người tiết kiệm rất nhiều thời gian, công sức và tăng độ chính xác cao trong việc tự động hoá một phần hay toàn phần của quá trình xử lý thông tin.

# Máy tính điện tử và phân loại

## Lịch sử phát triển của máy tính điện tử

Do nhu cầu cần tăng độ chính xác tính toán và giảm thời gian tính toán, con người đã quan tâm chế tạo các công cụ tính toán từ xưa: bàn tính tay của người Trung Quốc, máy cộng cơ học của nhà toán học Pháp Blaise Pascal (1623 - 1662), máy tính cơ học có thể cộng, trừ, nhân, chia của nhà toán học Đức Gottfried Wilhelmvon Leibniz (1646 - 1716), máy sai phân để tính các đa thức toán học ...

Tuy nhiên, máy tính điện tử thực sự bắt đầu hình thành vào thập niên 1950 và đến nay đã trải qua 5 thế hệ và dựa vào sự tiến bộ về công nghệ điện tử và vi điện tử cũng như các cải tiến về nguyên lý, tính năng và loại hình của nó.

  * Thế hệ 1 (1950 - 1958): máy tính sử dụng các bóng đèn điện tử chân không, mạch riêng rẽ, vào số liệu bằng phiếu đục lỗ, điều khiển bằng tay. Máy có kích thước rất lớn, tiêu thụ năng lượng nhiều, tốc độ tính chậm khoảng 300 - 3.000 phép tính/s. Loại máy tính điển hình thế hệ 1 như EDVAC (Mỹ) hay BESEM (Liên Xô cũ),...

  * Thế hệ 2 (1958 - 1964): máy tính dùng bộ xử lý bằng đèn bán dẫn, mạch in. Máy tính đã có chương trình dịch như Cobol, Fortran và hệ điều hành đơn giản. Kích thước máy còn lớn, tốc độ tính khoảng 10.000 -100.000 phép tính/s. Điển hình như loại IBM-1070 (Mỹ) hay MINSK (Liên Xô cũ),...

  * Thế hệ 3 (1965 - 1974): máy tính được gắn các bộ vi xử lý bằng vi mạch điện tử cỡ nhỏ có thể có được tốc độ tính khoảng 100.000 - 1 triệu phép tính/s. Máy đã có các hệ điều hành đa chương trình, nhiều người đồng thời hoặc theo kiểu phân chia thời gian. Kết quả từ máy tính có thể in ra trực tiếp ở máy in. Điển hình như loại IBM-360 (Mỹ) hay EC (Liên Xô cũ),...

  * Thế hệ 4 (1974 - nay): máy tính bắt đầu có các vi mạch đa xử lý có tốc độ tính hàng chục


triệu đến hàng tỷ phép tính/s. Giai đoạn này hình thành 2 loại máy tính chính: máy tính cá nhân để bàn (Personal Computer - PC) hoặc xách tay (Laptop hoặc Notebook computer) và các loại máy tính chuyên nghiệp thực hiện đa chương trình, đa xử lý,...
hình thành các hệ thống mạng máy tính (Computer Networks), và các ứng dụng phong phú đa phương tiện.

  * Thế hệ 5 (1990 - nay): bắt đầu các nghiên cứu tạo ra các máy tính mô phỏng các hoạt động của não bộ và hành vi con người, có trí khôn nhân tạo với khả năng tự suy diễn phát triển các tình huống nhận được và hệ quản lý kiến thức cơ bản để giải quyết các bài toán đa dạng.

  * Máy tính lượng tử


## Phân loại máy tính điện tử

Trên thực tế tồn tại nhiều cách phân loại máy tính khác nhau và chúng ta có thể phân loại máy tính theo hiệu năng tính toán như sau:

  * **Máy Vi tính (Microcomputer or PC)** : Loại này thường được thiết kế cho một người dùng, do đó giá thành rẻ. Hiện nay, máy vi tính khá phổ dụng và xuất hiện dưới khá nhiều dạng: máy để bàn (Destop), máy trạm (Workstation), máy xách tay (Notebook) và máy tính bỏ túi.

  * **Máy tính tầm trung (Mini Computer)** : Là loại máy tính có tốc độ và hiệu năng tính toán mạnh hơn các máy vi tính. Chúng thường được thiết kế để sử dụng cho các ứng dụng phức tạp. Giá của các máy này cũng cỡ hàng vài chục nghìn USD.

  * **Máy tính lớn (Mainframe Computer)** và **Siêu máy tính** (SuperComputer) là những máy tính có tổ chức bên trong rất phức tạp, có tốc độ siêu nhanh và hiệu năng tính toán cao, cỡ hàng tỷ phép tính/giây. Các máy tính này cho phép nhiều người dùng đồng thời và được sử dụng tại các Trung tâm tính toán/ Viện nghiên cứu để giải quyết các bài toán cực kỳ phức tạp, yêu cầu cao về tốc độ. Chúng có giá thành rất đắt, cỡ hàng trăm ngàn, thậm chí hàng triệu USD.


# Tin học và các ngành công nghệ liên quan

##  Tin học

Thuật ngữ Tin học có nguồn gốc từ tiếng Đức vào năm 1957 **do** [_Karl Steinbuch_](http://en.wikipedia.org/wiki/Karl_Steinbuch) đề xướng trong 1 bài báo _Informatik: Automatische Informationsverarbeitung_ (i.e. "Informatics: automatic information processing"). Sau đó vào năm 1962, [_Philippe Dreyfus_](http://en.wikipedia.org/wiki/Philippe_Dreyfus) người Pháp gọi là “informatique”, tiếp theo là [_Walter F.Bauer_](http://www.softwarehistory.org/history/Bauer1.html) cũng sử dụng tên này. Phần lớn các nước Tây Âu, trừ Anh đều chấp nhận. Ở Anh người ta sử dụng thuật ngữ „computer science‟, hay „computing science‟ là thuật ngữ dịch, Nga cũng chấp nhận tên _informatika_ (1966).

Tin học được xem là ngành khoa học nghiên cứu các phương pháp, công nghệ và kỹ thuật xử lý thông tin một cách tự động. Công cụ chủ yếu sử dụng trong tin học là máy tính điện tử và các thiết bị truyền tin khác. Nội dung nghiên cứu của tin học chủ yếu gồm 2 phần:

  * **Kỹ thuật phần cứng** (Hardware engineering): nghiên cứu chế tạo các thiết bị, linh kiện điện tử, công nghệ vật liệu mới... hỗ trợ cho việc thiết kế chế tạo máy tính và mạng máy tính, đẩy mạnh khả năng xử lý và truyền thông.

  * **Kỹ thuật phần mềm** (Software engineering): nghiên cứu phát triển các hệ điều hành, các tiện ích chung cho máy tính và mạng máy tính, các phần mềm ứng dụng phục vụ các mục đích xử lý và khai thác thông tin khác nhau của con người.


## Công nghệ thông tin (Information Technology - IT)

Thuật ngữ Công nghệ thông tin xuất hiện ở Việt nam vào những năm 90 của thế kỷ 20. Theo [_Information Technology Association of America_](http://en.wikipedia.org/wiki/Information_Technology_Association_of_America) (ITAA): “ _Công nghệ thông tin là ngành nghiên cứu các hệ thống thông tin dựa vào máy tính, đặc biệt là các phần mềm ứng dụng và phần cứng máy tính. Nói một cách ngắn gọn, IT xử lý với các máy tính điện tử và các phần mềm máy tính nhằm chuyển đổi, lưu trữ, bảo vệ, truyền tin và trích rút thông tin một cách an toàn_ ”.

Theo NQ49 CP thì “Công nghệ thông tin là…”

Các ứng dụng ngày nay của IT:

  * Quản trị dữ liệu

  * Thiết kế hệ thống cơ sở dữ liệu

  * Quản lý hệ thống thông tin

  * Quản lý hệ thống

  * ….


## Công nghệ thông tin và truyền thông

Ngày nay, khuynh hướng sử dụng "[ _information_](http://en.wikipedia.org/wiki/Information)" thay thế cho "[ _data_](httpkhuynh://en.wikipedia.org/wiki/Data)" và có xu thế mở rộng cho lĩnh vực truyền thông và trở thành **ICT** ( _Information and Communication Technology_ ). Thuần tuý theo cách nói thì hai thuật ngữ này là như nhau.

Truyền thông máy tính, nói đơn giản là sự kết nối một số lượng máy tính với nhau trong một phạm vi địa lý nhỏ. Tuy nhiên, nhiều máy tính có thể kết nối với nhau theo một phạm vi rộng hơn và việc trao đổi thực hiện qua một mạng viễn thông nào đó. **Internet** _\- Mạng máy tính toàn cầu_ là một phát minh vĩ đại của nhân loại trong thế kỷ 20, đó cũng chính là sản phẩm của ngành Công nghệ thông tin và Truyền thông.

# Public_014

# Biểu diễn dữ liệu trong máy tính 

## Biểu diễn số trong các hệ đếm

Hệ đếm là tập hợp các ký hiệu và qui tắc sử dụng tập ký hiệu đó để biểu diễn và xác định các giá trị các số. Mỗi hệ đếm có một số ký số (digits) hữu hạn. Tổng số ký số của mỗi hệ đếm được gọi là **cơ số** (base hay radix), ký hiệu là b.

### Hệ đếm cơ số b

Hệ đếm cơ số b (b ≥ 2 và nguyên dương) mang tính chất sau :

  * Có b ký số để thể hiện giá trị số. Ký số nhỏ nhất là **0** và lớn nhất là **b-1**.

  * Giá trị vị trí thứ n trong một số của hệ đếm bằng cơ số b lũy thừa n

  * Số N(b) trong hệ đếm cơ số (b) được biểu diễn bởi:


![](images/image1.jpeg)

trong đó, số N(b) có **n+1** ký số biểu diễn cho phần nguyên và **m** ký số lẻ biểu diễn cho phần b_phân, và có giá trị là:

![](images/image2.jpeg)

Trong ngành toán - tin học hiện nay phổ biến 4 hệ đếm là hệ thập phân, hệ nhị phân, hệ bát phân và hệ thập lục phân.

### Hệ đếm thập phân (Decimal system, b=10)

Hệ đếm thập phân hay hệ đếm cơ số 10 là một trong các phát minh của người Ả rập cổ, bao gồm 10 ký số theo ký hiệu sau:

**0,1,2,3,4,5,6,7,8,9**

Qui tắc tính giá trị của hệ đếm này là mỗi đơn vị ở một hàng bất kỳ có giá trị bằng 10 đơn vị của hàng kế cận bên phải. Ở đây b=10. Bất kỳ số nguyên dương trong hệ thập phân có thể biểu diễn như là một tổng các số hạng, mỗi số hạng là tích của một số với 10 lũy thừa, trong đó số mũ lũy thừa được tăng thêm 1 đơn vị kể từ số mũ lũy thừa phía bên phải nó. Số mũ lũy thừa của hàng đơn vị trong hệ thập phân là 0.

Ví dụ: Số 5246 có thể được biểu diễn như sau:

3 2 1 0
5246 = 5 x 10 + 2 x 10 + 4 x 10 + 6 x 10
= 5 x 1000 + 2 x 100 + 4 x 10 + 6 x 1

Thể hiện như trên gọi là ký hiệu mở rộng của số nguyên vì

5246 = 5000 + 200 + 40 + 6

Như vậy, trong số 5246 : ký số 6 trong số nguyên đại diện cho giá trị 6 đơn vị (1s), ký số 4 đại diện cho giá trị 4 chục (10s), ký số 2 đại diện cho giá trị 2 trăm (100s) và ký số 5 đại diện cho giá trị 5 ngàn (1000s). Nghĩa là, số lũy thừa của 10 tăng dần 1 đơn vị từ trái sang phải tương ứng với vị trí ký hiệu số,

0 1 2 3 4
10 = 1 10 = 10 10 = 100 10 = 1000 10 = 10000 ...

Mỗi ký số ở thứ tự khác nhau trong số sẽ có giá trị khác nhau, ta gọi là giá trị vị trí (place value).

Phần thập phân trong hệ thập phân sau dấu chấm phân cách thập phân (theo qui ước của Mỹ) thể hiện trong ký hiệu mở rộng bởi 10 lũy thừa âm tính từ phải sang trái kể từ dấu chấm phân cách:

101101−= 1011002−= 10110003−= ...


| 2 | 1 | 0 | -1 | -2 |
| --- | --- | --- | --- | --- |

 

### Hệ đếm nhị phân (Binary system, b=2)

Với cơ số b=2, chúng ta có hệ đếm nhị phân. Đây là hệ đếm đơn giản nhất với 2 chữ số là 0 và 1, mỗi chữ số nhị phân gọi là BIT (viết tắt từ chữ BInary digiT). Vì hệ nhị phân chỉ có 2 trị số là 0 và 1, nên khi muốn diễn tả một số lớn hơn, hoặc các ký tự phức tạp hơn thì cần kết hợp nhiều bit với nhau. Ta có thể chuyển đổi số trong hệ nhị phân sang số trong hệ thập phân quen thuộc.

Ví dụ: Số 11101.11(2) sẽ tương đương với giá trị thập phân là :

![](images/image3.jpeg)

### Hệ đếm bát phân (Octal system, b=8)

Nếu dùng 1 tập hợp 3 bit thì có thể biểu diễn 8 trị khác nhau : 000, 001, 010, 011, 100, 101, 110, 111. Các trị này tương đương với 8 trị trong hệ thập phân là 0, 1, 2, 3, 4, 5, 7. Tập hợp các chữ

3

số này gọi là hệ bát phân, là hệ đếm với b = 8 = 2 . Trong hệ bát phân, trị vị trí là lũy thừa của 8.

Ví dụ:


| 2 | 1 | 0 | -1 | -2 |
| --- | --- | --- | --- | --- |

 

### Hệ đếm thập lục phân (Hexa-decimal system, b=16)

4

Hệ đếm thập lục phân là hệ cơ số b=16 = 2 , tương đương với tập hợp 4 chữ số nhị phân (4 bit). Khi thể hiện ở dạng hexa-decimal, ta có 16 ký tự gồm 10 chữ số từ 0 đến 9, và 6 chữ in A, B, C, D, E, F để biểu diễn các giá trị số tương ứng là 10, 11, 12, 13, 14, 15. Với hệ thập lục phân, trị vị trí là lũy thừa của 16.

Ví dụ:

4 3 2 1 0
34F5C(16) = 3x16 + 4x16 + 15x16 + 5x16 + 12x16 = 216294(10)
_Ghi chú_ : Một số ngôn ngữ lập trình qui định viết số hexa phải có chữ H ở cuối chữ số. Ví dụ: Số 15 viết là FH.

### Chuyển đổi một số từ hệ thập phân sang hệ đếm cơ số b

#### Đổi phần nguyên từ hệ thập phân sang hệ b

Tổng quát: Lấy số nguyên thập phân N(10) lần lượt chia cho b cho đến khi thương số bằng 0. Kết

quả số chuyển đổi N(b) là các dư số trong phép chia viết ra theo thứ tự ngược lại.. Ví dụ: Số 12(10)

  * ?(2). Dùng phép chia cho 2 liên tiếp, ta có một loạt các số dư như sau:


![](images/image4.jpeg)

#### Đổi phần thập phân từ hệ thập phân sang hệ cơ số b

![](images/image5.jpeg)Tổng quát: Lấy phần thập phân N(10) lần lượt nhân với b cho đến khi phần thập phân của tích số bằng 0. Kết quả số chuyển đổi N(b) là các số phần nguyên trong phép nhân viết ra theo thứ tự

tính toán.

## Biểu diễn dữ liệu trong máy tính và đơn vị thông tin

###  Nguyên tắc chung

Thông tin và dữ liệu mà con người hiểu được tồn tại dưới nhiều dạng khác nhau, ví dụ như các số liệu, các ký tự văn bản, âm thanh, hình ảnh,… nhưng trong máy tính mọi thông tin và dữ liệu đều được biểu diễn bằng số nhị phân (chuỗi bit).

Để đưa dữ liệu vào cho máy tính, cần phải mã hoá nó về dạng nhị phân. Với các kiểu dữ liệu khác nhau cần có cách mã hoá khác nhau. Cụ thể:

  * Các dữ liệu dạng số (số nguyên hay số thực) sẽ được chuyển đổi trực tiếp thành các chuỗi số nhị phân theo các chuẩn xác định.

  * Các ký tự được mã hoá theo một bộ mã cụ thể, có nghĩa là mỗi ký tự sẽ tương ứng với một chuỗi số nhị phân.

  * Các dữ liệu phi số khác như âm thanh, hình ảnh và nhiều đại lượng vật lý khác muốn đưa vào máy phải **số hoá** ( _digitalizing_ ). Có thể hiểu một cách đơn giản khái niệm số hoá như sau: các dữ liệu tự nhiên thường là quá trình biến đổi liên tục, vì vậy để đưa vào máy tính, nó cần được biến đổi sang một dãy hữu hạn các giá trị số (nguyên hay thực) và được biểu diễn dưới dạng nhị phân.


Tuy rằng mọi dữ liệu trong máy tính đều ở dạng nhị phân, song do bản chất của dữ liệu, người ta thường phân dữ liệu thành 2 dạng:

  * **Dạng cơ bản** : gồm dạng số (nguyên hay thực) và dạng ký tự. Số nguyên không dấu được biểu diễn theo dạng nhị phân thông thường, số nguyên có dấu theo mã bù hai, còn số thực theo dạng dấu phảy động. Để biểu diễn một dữ liệu cơ bản, người ta sử dụng 1 số bit. Các bit này ghép lại với nhau để tạo thành từ: từ 8 bít, từ 16 bít,…

  * **Dạng có cấu trúc** : Trên cơ sở dữ liệu cơ bản, trong máy tính, người ta xây dựng nên các dữ liệu có cấu trúc phục vụ cho các mục đích sử dụng khác nhau. Tuỳ theo cách “ghép” chúng ta có mảng, tập hợp,xâu, bản ghi,…


### Đơn vị thông tin

Đơn vị nhỏ nhất để biểu diễn thông tin gọi là **bit**. Một bit tương ứng với một sự kiện có 1 trong 2 trạng thái.

Ví dụ: Một mạch đèn có 2 trạng thái là:

  * Tắt (Off) khi mạch điện qua công tắc là hở

  * Mở (On) khi mạch điện qua công tắc là đóng


Số học nhị phân sử dụng hai ký số 0 và 1 để biểu diễn các số. Vì khả năng sử dụng hai số 0 và 1 là như nhau nên một chỉ thị chỉ gồm một chữ số nhị phân có thể xem như là đơn vị chứa thông tin nhỏ nhất.

Bit là chữ viết tắt của **BI** nary digi **T**. Trong tin học, người ta thường sử dụng các đơn vị đo thông tin lớn hơn như sau:

## Biểu diễn số nguyên

Số nguyên gồm số nguyên không dấu và số nguyên có dấu. Về nguyên tắc đều dùng 1 chuỗi bit để biểu diễn. Đối với số nguyên có dấu, người ta sử dụng bit đầu tiên để biểu diễn dấu „-„ và bit này gọi là bit dấu.

### Số nguyên không dấu

Trong biểu diễn số nguyên không dấu, mọi bit đều được sử dụng để biểu diễn giá trị số. Ví dụ 1 dãy 8 bit biểu diễn số nguyên không dấu có giá trị:

8

  2. = 256 số nguyên dương, cho giá trị từ 0 (0000 0000) đến 255 (1111 1111).


Với n bits ta có thể biểu diễn 1 số nguyên có giá trị lớn nhất là 2n-1 và dải giá trị biểu diễn được từ 0 đến 2n-1.


| Thí dụ: 00000000 | = | 0 |
| --- | --- | --- |
| 00000010 | = | 2 |
| 00000100 | = | 4 |
| …………. |  |  |
| 11111111 | = | 255 |

 

### Số nguyên có dấu

Trong biểu diễn số nguyên có dấu, bit đầu làm bít dấu: 0 là số dương và 1 cho số âm. Số nguyên có dấu thể hiện trong máy tính ở dạng nhị phân là số dùng 1 bit làm bít dấu, người ta qui ước dùng bit ở hàng đầu tiên bên trái làm bit dấu (S): 0 là số dương và 1 cho số âm. Cách phổ biến biểu diễn số âm có dấu là dùng mã bù hai:

Số bù hai được tính như sau:

  * Biểu diễn số nguyên không dấu

  * Nghịch đảo tất cả các bit (số bù một)

  * Cộng thêm một. (số bù hai)


_Chú ý: Thử biểu diễn mã bù hai của -37 để thu được số +35_

### Tính toán số học với số nguyên

#### Cộng/ trừ số nguyên

_Cộng/ trừ số nguyên không dấu_

Khi cộng hai số nguyên không dấu n bits ta thu được một số nguyên không dấu cũng n bits. Vì vậy,

  * Nếu tổng của hai số đó nhỏ hơn hoặc bằng 2n-1 thì kết quả nhận được là đúng.

  * Nếu tổng của hai số đó lớn hơn 2n-1 thì khi đó sẽ tràn số và kết quả sẽ là sai. Thí dụ với trường hợp 8 bits, tổng nhỏ hơn 255 thì ta sẽ có kết quả đúng:

* 57 = 00111001


34 = 00100010
91 = 01011011
209 = 11010001

  * 73 = 01001001


282 = **1** 00011010

![](images/image6.png)

Bit tràn ra ngoài => kết quả = 26 là sai.

  * Để tránh hiện tượng tràn số này ta phải sử dụng nhiều bit hơn để biểu diễn.


_Cộng/trừ số nguyên có dấu_

Số nguyên có dấu được biểu diễn theo mã bù hai, vậy qui tắc chung như sau:

  * Cộng hai số nguyên có dấu n-bit sẽ bỏ qua giá trị nhớ ra khỏi bit có ý nghĩa cao nhất, tổng nhận được sẽ có giá trị đúng và cũng được biểu diễn theo mã bù hai, nếu kết quả nhận được nằm trong dải -2n-1 đến + 2n-1 -1.

  * Để trừ hai số nguyên có dấu X và Y (X – Y) , cần lấy bù hai của Y tức –Y, sau đó cộng X với –Y theo nguyên tắc trên.


Như vậy, khi thực hiện phép tính trên sẽ thừa ra 1 bit bên trái cùng, bit này sẽ không được lưu trong kết quả và sẽ được bỏ qua.

#### Nhân/ chia số nguyên

So với phép cộng và phép trừ, phép nhân và phép chia phức tạp hơn nhiều. Dưới đây, chỉ giới thiệu phép nhân/phép chia với số nhị phân. Ví dụ sau mô tả phép nhân hai số nhị phân:

1011 (11 cơ số 10)
x
1101 (13 cơ số 10)

![](images/image7.png)

1011
0000
1011
1011
**10001111** **kết quả 143 trong cơ số 10**

Chúng ta có một số nhận xét sau:

  * Phép nhân tạo ra các tích riêng, mỗi tích thu được là kết quả của việc nhân từng bit.

  * Các tích riêng dễ dàng xác định theo qui tắc:

* Bit tương ứng số nhân là 1 thì tích riêng bằng số bị nhân

* Bit tương ứng số nhân bằng 0 thì tích riêng bằng 0

  * Tích được tính bằng tổng các tích riêng.


Phép chia phức tạp hơn phép nhân nhưng dựa trên cùng 1 nguyên tắc.

# Public_015

# Bộ xử lý trung tâm – CPU

Bộ xử lý trung tâm (Central Proccesor Unit- CPU) điều khiển các thành phần của máy tính, xử lý dữ liệu. CPU hoạt động theo chương trình nằm trong bộ nhớ chính, nhận các lệnh từ bộ nhớ chính, giải mã lệnh để phát ra các tín hiệu điều khiển thực thi lệnh. Trong quá trình thực hiện lệnh, CPU có trao đổi với bộ nhớ chính và hệ thống vào ra. CPU có 3 bộ phận chính: khối điều khiển, khối tính toán số học và logic, và tập các thanh ghi (hình 3.2).

  * **Khối điều khiển** ( _Control Unit_ – CU):

* Nhận lệnh của chương trình từ bộ nhớ trong đưa vào CPU. Nó có nhiệm vụ giải mã các lệnh, tạo ra các tín hiệu điều khiển công việc của các bộ phận khác của máy tính theo yêu cầu của người sử dụng hoặc theo chương trình đã cài đặt..

  * **Khối tính toán số học và logic** ( _Arithmetic_ – _Logic Unit_ \- ALU)

* Bao gồm các thiết bị thực hiện các phép tính số học (cộng, trừ, nhân, chia, ...), các phép tính logic (AND, OR, NOT, XOR) và các phép tính quan hệ (so sánh lớn hơn, nhỏ hơn, bằng nhau, ...)

* Dữ liệu từ bộ nhớ hay các thiết bị vào-ra sẽ được chuyển vào các thanh ghi của CPU, rồi chuyển đến ALU. Tại đây, dữ liệu được tính toán rồi trả lại các thanh ghi và chuyển về bộ nhớ hay các thiết bị vào-ra.

* Độ dài từ của các toán hạng được đưa vào tính toán trực tiếp ở khối ALU. Độ dài phổ biến với các máy tính hiện nay là 32 hay 64 bit.

* Ban đầu ALU chỉ gồm khối tính toán số nguyên IU (Integer Unit). Để tăng khả năng tính toán nhất là trong dấu phẩy động. Khối tính toán hiện nay được bổ sung thêm khối tính toán dấu phẩy động FPU (Floating Point Unit)- hay còn gọi là bộ đồng xử lý (Co-proccesor Unit) .

  * **Tập các thanh ghi** ( _Registers_ )

* Được gắn chặt vào CPU bằng các mạch điện tử làm nhiệm vụ bộ nhớ trung gian cho CPU. Các thanh ghi mang các chức năng chuyên dụng giúp tăng tốc độ trao đổi thông tin

* trong máy tính. Trên các CPU hiện nay có từ vài chục đến vài trăm thanh ghi. Độ dài của các thanh ghi cũng khác nhau từ 8 đến 64 bit.

* Ngoài ra, CPU còn được gắn với một đồng hồ (clock) hay còn gọi là bộ tạo xung nhịp. Tần số đồng hồ càng cao thì tốc độ xử lý thông tin càng nhanh. Thường thì đồng hồ được gắn tương xứng với cấu hình máy và có các tần số dao động (cho các máy Pentium 4 trở lên) là 2.0 GHz, 2.2 GHz, ... hoặc cao hơn.


# Bộ vi xử lý (Microprocessor)

CPU được chế tạo trên một vi mạch và được gọi là bộ vi xử lý. Vì vậy, chúng ta có thể gọi CPU là bộ vi xử lý. Tuy nhiên, các bộ vi xử lý hiện nay có cấu trúc phức tạp hơn nhiều so với một CPU cơ bản.

# Bộ nhớ

Bộ nhớ là thiết bị lưu trữ thông tin trong quá trình máy tính xử lý. Bộ nhớ bao gồm bộ nhớ trong và bộ nhớ ngoài.

_Bộ nhớ trong_

Bộ nhớ trong ( _Internal Memory_ ) là những thành phần nhớ mà CPU có thể trao đổi trực tiếp: các lệnh mà CPU thực thi, các dữ liệu mà CPU sử dụng đều phải nằm trong bộ nhớ trong. Bộ nhớ trong có dung lượng không thật lớn song có tốc độ trao đổi thông tin cao.

_Bộ nhớ chính_

Là thành phần quan trọng nhất của bộ nhớ trong, vì vậy nhiều khi người ta đồng nhất bộ nhớ chính với bộ nhớ trong. Bộ nhớ chính tổ chức thành các ngăn theo byte và các ngăn nhớ này được đánh địa chỉ trực tiếp bởi CPU, có nghĩa là mỗi ngăn nhớ của bộ nhớ chính được gán một địa chỉ xác định. CPU muốn đọc/ghi vào ngăn nhớ nào, nó phải biết được địa chỉ của ngăn nhớ đó.

Nội dung của ngăn nhớ là giá trị được ghi trong đó. Số bit được dùng để đánh địa chỉ của ngăn nhớ sẽ quyết định dung lượng tối đa của bộ nhớ chính. Thí dụ:

  * Dùng 16 bit địa chỉ thì dung lượng tối đa của bộ nhớ là 216 = 26 x 210 = 64KB

  * Bộ xử lý Pentium III có 36 bit địa chỉ, do đó có khả năng quản lý tối đa 26 x 230=64GB . _Chú ý:_ Nội dung của ngăn nhớ có thể thay đổi còn địa chỉ ngăn nhớ thì cố định.


Bộ nhớ chính của máy tính được thiết kế bằng bộ nhớ bán dẫn với 2 loại ROM và RAM, trong đó:

  * **ROM** ( **Read Only Memory** ) là Bộ nhớ chỉ đọc thông tin, dùng để lưu trữ các chương trình hệ thống, chương trình điều khiển việc nhập xuất cơ sở (ROM-BIOS : ROM-Basic Input/Output System). Thông tin trên ROM không thể thay đổi và không bị mất ngay cả khi không có điện.

  * **RAM** ( **Random Access Memory** ) là Bộ nhớ truy xuất ngẫu nhiên, được dùng để lưu trữ dữ liệu và chương trình trong quá trình thao tác và tính toán. RAM có đặc điểm là nội dung thông tin chứa trong nó sẽ mất đi khi mất điện hoặc tắt máy. Dung lượng bộ nhớ RAM cho các máy tính hiện nay thông thường vào khoảng 128 MB, 256 MB, 512 MB và có thể hơn nữa.


Ngoài ra, trong máy tính cũng còn phần bộ nhớ khác: _**Cache Memory**_ cũng thuộc bộ nhớ trong.

Bộ nhớ cache được đặt đệm giữa CPU và bộ nhớ trong nhằm làm tăng tốc độ trao đổi thông tin. Bộ nhớ cache thuộc bộ nhớ RAM, có dung lượng nhỏ. Nó chứa một phần chương trình và dữ liệu mà CPU đang xử lý, do vậy thay vì lấy lệnh và dữ liệu từ bộ nhớ chính, CPU sẽ lấy trên cache. Hầu hết các máy tính hiện nay đều có cache tích hợp trên chip vi xử lý.

_Bộ nhớ ngoài_

Bộ nhớ ngoài ( _External Memory_ ) Là thiết bị lưu trữ thông tin với dung lượng lớn, thông tin không bị mất khi không có điện. Các thông tin này có thể là phần mềm máy tính hay dữ liệu. Bộ nhớ ngoài được kết nối với hệ thống thông qua mô-đun nối ghép vào-ra. Như vậy, _bộ nhớ ngoài về chức năng thuộc bộ nhớ, song về cấu trúc nó lại thuộc hệ thống vào ra_. Có thể cất giữ và di chuyển bộ nhớ ngoài độc lập với máy tính. Hiện nay có các loại bộ nhớ ngoài phổ biến như:

  * Đĩa mềm (Floppy disk) : là loại đĩa đường kính 3.5 inch dung lượng 1.44 MB.

  * Đĩa cứng (Hard disk) : phổ biến là đĩa cứng có dung lượng 20 GB, 30 GB, 40 GB, 60 GB, và lớn hơn nữa.

  * Đĩa quang (Compact disk): loại 4.72 inch, là thiết bị phổ biến dùng để lưu trữ các phần mềm mang nhiều thông tin, hình ảnh, âm thanh và thường được sử dụng trong các phương tiện đa truyền thông (multimedia). Có hai loại phổ biến là: đĩa CD (dung lượng khoảng 700 MB) và DVD (dung lượng khoảng 4.7 GB).

  * Các loại bộ nhớ ngoài khác như thẻ nhớ (Memory Stick, Compact Flash Card), USB Flash Drive có dung lượng phổ biến là 32 MB, 64 MB, 128 MB, ...


![](images/image1.png)

**Hình I.2.1.1.c.** **Một số loại bộ** **nhớ**

# Hệ thống vào-ra

Chức năng của hệ thống vào-ra là trao đổi thông tin giữa máy tính với thế giới bên ngoài. Hệ thống vào-ra được xây dựng dựa trên hai thành phần: các _**thiết bị vào-ra**_ (IO devices) hay còn gọi là thiết bị ngoại vi (Peripheral devices) và các _**mô-đun ghép nối vào-ra**_ (IO Interface modules)

_Mô đun ghép nối vào ra_

Các thiết bị vào ra không kết nối trực tiếp với CPU mà được kết nối thông qua các mô-đun ghép nối vào-ra. Trong các mô đun ghép nối vào-ra có các cổng vào-ra IO Port), các cổng này cũng được đánh địa chỉ bởi CPU, có nghĩa là mỗi cổng cũng có một địa chỉ xác định. Mỗi thiết bị vào-ra kết nối với CPU thông qua cổng tương ứng với địa chỉ xác định.

Mỗi thiết bị vào-ra làm nhiệm vụ chuyển đổi thông tin từ một dạng vật lý nào đó về dạng dữ liệu phù hợp với máy tính hoặc ngược lại. các thiết bị ngoại vi thông dụng như bàn phím, màn hình, máy in hay một máy tính khác. Người ta có thể phân các thiết bị ngoại vi ra nhiều loại:

  * _Thiết bị thu nhận dữ liệu_ : Bàn phím, chuột, máy quét ảnh,…

  * _Thiết bị hiển thị dữ liệu_ : màn hình, máy in,…

  * _Thiết bị nhớ_ : các loại ổ đĩa

  * _Thiết bị truyền thông_ : modem

  * _Thiết bị hỗ trợ đa phương tiện_ : hệ thống âm thanh, hình ảnh,… Các thiết bị vào:

  * **Bàn phím** (Keyboard, thiết bị nhập chuẩn): là thiết bị nhập dữ liệu và câu lệnh, bàn phím máy vi tính phổ biến hiện nay là một bảng chứa 104 phím có các tác dụng khác nhau.

  * Có thể chia làm 3 nhóm phím chính:

  * Nhóm phím đánh máy: gồm các phím chữ, phím số và phím các ký tự đặc biệt (~,

  * !, @, #, $, %, ^,&, ?, ...).

  * Nhóm phím chức năng (function keypad): gồm các phím từ F1 đến F12 và các phím như ← ↑ → ↓ (phím di chuyển từng điểm), phím PgUp (lên trang màn hình), PgDn (xuống trang màn hình), Insert (chèn), Delete (xoá), Home (về đầu), End (về cuối)

  * Nhóm phím số (numeric keypad) như NumLock (cho các ký tự số), CapsLock (tạo các chữ in), ScrollLock (chế độ cuộn màn hình) thể hiện ở các đèn chỉ thị.


  * **Chuột** (Mouse): là thiết bị cần thiết phổ biến hiện nay, nhất là các máy tính chạy trong môi trường Windows. Con chuột có kích thước vừa nắm tay di chuyển trên một tấm phẳng (mouse pad) theo hướng nào thì dấu nháy hoặc mũi tên trên màn hình sẽ di chuyển theo hướng đó tương ứng với vị trí của của viên bi hoặc tia sáng (optical mouse) nằm dưới bụng của nó. Một số máy tính có con chuột được gắn trên bàn phím.

  * **Máy quét** (Scanner): là thiết bị dùng để nhập văn bản hay hình vẽ, hình chụp vào máy tính. Thông tin nguyên thuỷ trên giấy sẽ được quét thành các tín hiệu số tạo thành các tập tin ảnh (image file).


Các thiết bị ra:

  * **Màn hình** (Screen hay Monitor, thiết bị ra chuẩn): dùng để hiển thị thông tin cho người sử dụng xem. Thông tin được thể hiện ra màn hình bằng phương pháp ánh xạ bộ nhớ (memory mapping), với cách này màn hình chỉ việc đọc liên tục bộ nhớ và hiển thị (display) bất kỳ thông tin nào hiện có trong vùng nhớ ra màn hình.

  * Màn hình phổ biến hiện nay trên thị trường là màn hình màu SVGA 15”,17”, 19” với độ phân giải có thể đạt 1280 X 1024 pixel.

  * **Máy in** (Printer): là thiết bị ra để đưa thông tin ra giấy. Máy in phổ biến hiện nay là loại máy in ma trận điểm (dot matrix) loại 24 kim, máy in phun mực, máy in laser trắng đen hoặc màu.

  * **Máy chiếu** (Projector): chức năng tương tự màn hình, thường được sử dụng thay cho màn hình trong các buổi Seminar, báo cáo, thuyết trình, …


# Liên kết hệ thống (buses)

Giữa các thành phần của một hệ thống máy tính hay ngay trong một thành phần phức tạp như CPU cũng cần trao đổi với nhau. Nhiệm vụ này được thực thi bởi hệ thống kết nối mà chúng ta quen gọi là bus. Tuỳ theo nhiệm vụ của chúng mà chúng ta phân làm 3 loại chính:

  * **Bus điều khiển** (Control bus): chuyển các thông tin/tín hiệu điều khiển từ thành phần này đến thành phần khác: CPU phát tín hiệu để điều khiển bộ nhớ hay hệ thống vào-ra hoặc từ hệ thống vào-ra gửi tín hiệu yêu cầu đến CPU.

  * **Bus dữ liệu** (Data bus): làm nhiệm vụ chuyển tải dữ liệu (nội dung ngăn nhớ, kết quả xử lý) từ CPU đến bộ nhớ hay ngược lại hoặc từ bộ nhớ/CPU ra các thiết bị ngoại vi. Đây là loại bus 2 chiều. Các máy tính hiện nay thường có đường bit dữ liệu 32 hay 64 bit.

  * **Bus địa chỉ** (Address bus): chuyển tải địa chỉ của các ngăn nhớ khi muốn truy nhập (đọc/ghi) nội dung của ngăn nhớ đó hoặc là địa chỉ cổng của các thiết bị mà CPU cần trao đổi. Độ rộng (số bit) của bus địa chỉ cho biết dung lượng cực đại của bộ nhớ mà CPU có thể quản lý được. Với độ rộng là n thì dung lượng bộ nhớ tối đa sẽ là 2n.

# Public_016

# Lời nói đầu

TCVN 9395:2012 được chuyển đổi từ TCXDVN 326:2004 theo quy định tại khoản 1 Điều 69 của Luật Tiêu chuẩn và Quy chuẩn kỹ thuật và điểm a khoản 1 Điều 7 Nghị định số 127/2007/NĐ-CP ngày 01/8/2007 của Chính phủ quy định chi tiết thi hành một số điều của Luật Tiêu chuẩn và Quy chuẩn kỹ thuật.
TCVN 9395:2012 do Viện Khoa học Công nghệ Xây dựng - Bộ Xây dựng biên soạn, Bộ Xây dựng đề nghị, Tổng cục Tiêu chuẩn Đo lường Chất lượng thẩm định, Bộ Khoa học và Công nghệ công bố.

# Phạm vi áp dụng

Tiêu chuẩn này áp dụng cho thi công và nghiệm thu cọc khoan nhồi bê tông cốt thép đường kính lớn hơn hoặc bằng 60 cm trừ những công trình có điều kiện địa chất đặc biệt như vùng có hang các-tơ, mái đá nghiêng.

## Tài liệu viện dẫn

Các tài liệu viện dẫn sau cần thiết cho việc áp dụng tiêu chuẩn này. Đối với các tài liệu viện dẫn ghi năm công bố thì áp dụng phiên bản được nêu. Đối với các tài liệu viện dẫn không ghi năm công bố thì áp dụng phiên bản mới nhất, bao gồm cả các sửa đổi, bổ sung (nếu có).
TCVN 5308:1991, Quy phạm kỹ thuật an toàn trong xây dựng.
TCVN 9393:2012, Cọc-Phương pháp thí nghiệm bằng tải trọng tĩnh ép dọc trục.
TCVN 9396:2012, Cọc khoan nhồi - Phương pháp xung siêu âm xác định tính đồng nhất của bê tông.
TCVN 9397:2012, Cọc - Thí nghiệm kiểm tra khuyết tật bằng phương pháp động biến dạng nhỏ.

# Thuật ngữ và định nghĩa

## Cọc khoan nhồi (Bored pile)

Loại cọc tiết diện tròn được thi công bằng cách khoan tạo lỗ trong đất sau đó lấp đầy bằng bê tông cốt thép.

## Dung dịch khoan (Stabilizing fluids)

Dung dịch gồm nước sạch và các hoá chất khác như bentonite, polime ... có khả năng tạo màng cách nước giữa thành hố khoan và đất xung quanh đồng thời giữ ổn định thành hố khoan.

## Thép gia cường (Stiffening rings)

Vòng thép tròn đặt phía trong cốt thép chủ của lồng thép để tăng độ cứng của lồng khi vận chuyển và lắp dựng.

## Con kê (Spacers)

Phụ kiện bằng thép bản hoặc xi măng-cát (hình tròn) dùng định vị lồng thép trong lỗ khoan.

# Quy định chung

  * Khi thi công gần các công trình hiện có phải có biện pháp quan trắc các công trình này và lựa chọn giải pháp thi công thích hợp để đảm bảo an toàn ổn định cho chúng. Nhà thầu được đưa các giải pháp đảm bảo an toàn công trình lân cận vào giá chào thầu.

  * Người chịu trách nhiệm thiết kế tổ chức thi công, chọn biện pháp, thiết bị phải có trình độ và kinh nghiệm thi công cọc nhồi qua ít nhất 1 công trình tương tự, cán bộ và công nhân tham gia thi công phải được huấn luyện và đào tạo tay nghề.

  * Nhà thầu cần lập biện pháp thi công đầy đủ bản vẽ và thuyết minh chi tiết trình chủ đầu tư phê duyệt trước khi tiến hành thi công. Trong khi thi công phải tiến hành kiểm tra từng công đoạn, khi đạt yêu cầu mới được thi công công đoạn tiếp theo.

  * Nghiệm thu móng cọc khoan nhồi dựa theo các quy định hiện hành.


# Công tác chuẩn bị

  * Để có đầy đủ số liệu cho thi công cọc đại trà, nhất là trong điều kiện địa chất phức tạp, các công trình quan trọng, cọc chịu tải trọng lớn, thời gian lắp dựng cốt thép, ống siêu âm và đổ bê tông một cọc kéo dài, Nhà thầu phải tiến hành thí nghiệm việc giữ thành hố khoan, thi công các cọc thử và tiến hành thí nghiệm cọc bằng tải trọng tĩnh, kiểm tra độ toàn khối của bê tông cọc theo quy định của Thiết kế.

  * Trước khi thi công cọc cần tiến hành kiểm tra các công tác chuẩn bị để thi công cọc theo biện pháp thi công được duyệt, có thể gồm:

  * Hiểu biết rõ điều kiện địa chất công trình và địa chất thuỷ văn, chiều dày, thế nằm và đặc trưng cơ lý của các lớp đất, kết quả quan trắc mực nước ngầm; áp lực nước lỗ rỗng, tốc độ dòng chảy của nước trong đất, khí độc hoặc khí dễ gây cháy nổ ...;

  * Tìm hiểu khả năng có các chướng ngại dưới đất để có biện pháp loại bỏ chúng, đề xuất biện pháp phòng ngừa ảnh hưởng xấu đến công trình lân cận và công trình ngầm; nếu chưa có hồ sơ hiện trạng các công trình lân cận và công trình ngầm, Nhà thầu phải yêu cầu Chủ đầu tư tiến hành công tác khảo sát, đo vẽ lập hồ sơ; biên bản lập với các chủ sở hữu các công trình liền kề phải được cơ quan có thẩm quyền bảo lãnh;

  * Nhà thầu tham khảo hồ sơ do Chủ đầu tư cấp là chính, nếu còn thiếu thì bổ sung trong hồ sơ dự thầu.

  * Kiểm tra vật liệu chính (thép, xi măng, dung dịch khoan, phụ gia, cát, đá, nước sạch...), chứng chỉ chất lượng của nhà sản xuất, và kết quả thí nghiệm kiểm định chất lượng;

  * Thi công lưới trắc đạc định vị các trục móng và toạ độ các cọc cần thi công;

  * Thi công các công trình phụ trợ, đường cấp điện, cấp thoát nước, hố rửa xe; hệ thống tuần hoàn vữa sét (kho chứa, trạm trộn, bể lắng, đường ống, máy bơm, máy tách cát..);

  * San ủi mặt bằng và làm đường phục vụ thi công, đủ để chịu tải trọng của thiết bị thi công lớn nhất, lập phương án vận chuyển đất thải, tránh gây ô nhiễm môi trường;

  * Tập kết vật tư kỹ thuật và thiết bị, kiểm tra máy móc, thiết bị trong tình trạng sẵn sàng hoạt động tốt; dụng cụ và thiết bị kiểm tra chất lượng phải có kiểm chuẩn của cơ quan đủ thẩm quyền;

  * Chuẩn bị dung dịch khoan, cốt thép cọc, ống siêu âm, ống đặt sẵn để khoan lấy lõi bê tông (nếu cần), thùng chứa đất khoan, máy khoan và các thiết bị phụ trợ (cần cẩu, máy bơm, máy trộn dung dịch, máy lọc cát, máy nén khí, máy hàn, tổ hợp ống đổ, sàn công tác phục vụ đổ bê tông, xe chở đất khoan) cùng các thiết bị để kiểm tra dung dịch khoan, lỗ khoan, dụng cụ kiểm tra độ sụt bê tông, hộp lấy mẫu bê tông, dưỡng định vị lỗ cọc...;

  * Lập biểu kiểm tra và nghiệm thu các công đoạn thi công theo mẫu in sẵn (xem Phụ lục C).


Hệ thống mốc chuẩn và mốc định vị trục móng phải đáp ứng điều kiện độ chính xác về tọa độ và cao độ theo yêu cầu kỹ thuật của công trình. Nhà thầu có trách nhiệm nhận và bảo quản hệ thống mốc chuẩn trong suốt quá trình thi công cọc.
Lập biên bản nghiệm thu công tác chẩn bị trước khi thi công.

# Dung dịch khoan

  * Tuỳ theo điều kiện địa chất, thuỷ văn, nước ngầm, thiết bị khoan để chọn phương pháp giữ thành hố khoan và dung dịch khoan thích hợp. Cao độ dung dịch khoan được chọn dựa trên tính toán theo nguyên lý cân bằng áp lực ngang giữa cột dung dịch trong hố khoan và áp lực của đất nền và nước quanh vách lỗ. Khi khoan trong địa tầng dễ sụt lở, áp lực cột dung dịch phải luôn lớn hơn áp lực ngang của đất và nước bên ngoài.

  * Khi áp lực ngang của đất và nước bên ngoài lỗ khoan lớn (do tải trọng của thiết bị thi công hay của các công trình lân cận sẵn có...) thì phải dùng ống vách để chống sụt lở, chiều sâu ống vách tính theo nguyên lý cân bằng áp nêu trên. Khi khoan gần công trình hiện hữu nếu có nguy cơ sập thành lỗ khoan thì phải dùng ống chống suốt chiều sâu lỗ cọc.

  * Dung dịch bentonite dùng giữ thành hố khoan nơi địa tầng dễ sụt lở cho mọi loại thiết bị khoan, giữ cho mùn khoan không lắng đọng dưới đáy hố khoan và đưa mùn khoan ra ngoài phải đảm bảo được yêu cầu giữ ổn định vách hố khoan trong suốt quá trình thi công cọc. Khi mực nước ngầm cao (lên đến mặt đất) cho phép tăng tỷ trọng dung dịch bằng các chất có tỷ trọng cao như barit, cát magnetic ...

  * Kiểm tra dung dịch bentonite từ khi chế bị cho tới khi kết thúc đổ bê tông từng cọc, kể cả việc điều chỉnh để đảm bảo độ nhớt và tỷ trọng thích hợp nhằm tránh lắng đáy cọc quá giới hạn cho phép cần tuân theo các quy định nêu trong Điều 12 và các yêu cầu đặc biệt (nếu có) của Thiết kế. Dung dịch có thể tái sử dụng trong thời gian thi công công trình nếu đảm bảo được các chỉ tiêu thích hợp, nhưng không quá 6 tháng.

  * Khi dùng dung dịch polime hoặc các hoá phẩm khác ngoài các chức năng giữ ổn định thành hố khoan phải kiểm tra ảnh hưởng của nó đến môi trường đất-nước (tại khu vực công trình và nơi chôn lấp đất khoan).


# Công tác tạo lỗ khoan

  * Khoan gần cọc mới đổ xong bê tông

  * Khoan trong đất no nước khi khoảng cách mép các lỗ khoan nhỏ hơn 1,5 m nên tiến hành cách quãng 1 lỗ, khoan các lỗ nằm giữa hai cọc đã đổ bê tông nên tiến hành sau ít nhất 24 h từ khi kết thúc đổ bê tông.

  * Thiết bị khoan tạo lỗ

  * Có nhiều thiết bị khoan tương ứng với các kiểu lấy đất đá trong lòng lỗ khoan như sau: choòng đập đá; gàu ngoạm; gàu xoay, thổi rửa để hút bùn theo chu trình thuận, nghịch ...Tuỳ theo đặc điểm địa chất công trình, vị trí công trình với các công trình lân cận, khả năng của Nhà thầu, yêu cầu của thiết kế mà chọn lựa thiết bị khoan thích hợp.

  * Ống chống tạm

  * Ống chống tạm (casing) dùng bảo vệ thành lỗ khoan ở phần đầu cọc, tránh lở đất bề mặt đồng thời là ống dẫn hướng cho suốt quá trình khoan tạo lỗ. Khi hạ ống nên có dưỡng định vị để đảm bảo sai số cho phép.

  * Ống chống tạm được chế tạo thường từ 6 m đến 10 m trong các xưởng cơ khí chuyên dụng, chiều dày ống thường từ 6 mm đến 16 mm.

  * Cao độ đỉnh ống cao hơn mặt đất hoặc nước cao nhất tối thiểu 0,3 m. Cao độ chân ống đảm bảo sao cho áp lực cột dung dịch lớn hơn áp lực chủ động của đất nền và hoạt tải thi công phía bên ngoài.

  * Ống chống tạm được hạ và rút chủ yếu bằng thiết bị thuỷ lực hoặc thiết bị rung kèm theo máy khoan, khi không có thiết bị này có thể dùng búa rung đóng kết hợp lấy đất bằng gầu hoặc hạ bằng kích ép thuỷ lực.

  * Cao độ dung dịch khoan

  * Cao độ dung dịch khoan trong lỗ phải luôn giữ sao cho áp lực của dung dịch khoan luôn lớn hơn áp lực của đất và nước ngầm phía ngoài lỗ khoan để tránh hiện tượng sập thành trước khi đổ bê tông. Cao độ dung dịch khoan nên cao hơn mực nước ngầm ít nhất là 1,5 m. Khi có hiện tượng thất thoát dung dịch trong hố khoan nhanh thì phải có biện pháp xử lý kịp thời.

  * Đo đạc trong khi khoan

  * Đo đạc trong khi khoan gồm kiểm tra tim cọc bằng máy kinh vĩ và đo đạc độ sâu các lớp đất qua mùn khoan lấy ra và độ sâu hố khoan theo thiết kế. Các lớp đất theo chiều sâu khoan phải được ghi chép trong nhật ký khoan và hồ sơ nghiệm thu cọc (xem Phụ lục C). Khoảng 2,0 m lấy mẫu một lần. Khi phát hiện địa tầng khác với hồ sơ khảo sát địa chất công trình cần báo ngay cho Chủ đầu tư để có biện pháp xử lý kịp thời. Khi khoan đến cao độ thiết kế, tiến hành đo độ lắng. Độ lắng được xác định bằng chênh lệch chiều sâu giữa hai lần đo lúc khoan xong và sau 30 min. Nếu độ lắng vượt quá quy định cần xử lý kịp thời.


  * 


# Công tác gia công và hạ cốt thép

  * Cốt thép được gia công theo bản vẽ thiết kế thi công. Nhà thầu phải bố trí mặt bằng gia công, nắn cốt thép, đánh gỉ, uốn đai, cắt và buộc lồng thép theo đúng quy định.

  * Cốt thép được chế tạo sẵn trong xưởng hoặc tại công trường, chế tạo thành từng lồng, chiều dài lớn nhất của mỗi lồng phụ thuộc khả năng cẩu lắp và chiều dài xuất xưởng của cốt chủ. Lồng thép phải có thép gia cường ngoài cốt chủ và cốt đai theo tính toán để đảm bảo lồng thép không bị xoắn, méo. Lồng thép phải có móc treo bằng cốt thép chuyên dùng làm móc cẩu, số lượng móc treo phải tính toán đủ để treo cả lồng vào thành ống chống tạm mà không bị tuột xuống đáy hố khoan, hoặc cấu tạo guốc cho đoạn lồng dưới cùng tránh lồng thép bị lún nghiêng cũng như để đảm bảo chiều dày lớp bê tông bảo hộ dưới đáy cọc.

  * Cốt gia cường thường dùng cùng đường kính với cốt chủ, uốn thành vòng đặt phía trong cốt chủ khoảng cách từ 2,5 m đến 3,0 m, liên kết với cốt chủ bằng hàn đính và dây buộc theo yêu cầu của thiết kế. Khi chuyên chở, cẩu lắp có thể dùng cách chống tạm bên trong lồng thép để tránh hiện tượng biến hình.

  * Định tâm lồng thép bằng các con kê chế tạo từ thép trơn hàn vào cốt chủ đối xứng qua tâm cọc, hoặc bằng các viên tròn xi măng - cát, theo nguyên lý bánh xe trượt, cố định vào giữa 2 thanh cốt chủ bằng thanh thép trục. Chiều rộng hoặc bán kính con kê phụ thuộc vào chiều dày lớp bảo hộ, thông thường là 5 cm. Số lượng con kê phải đủ để hạ lồng thép chính tâm.

  * Nối các đoạn lồng thép chủ yếu bằng dây buộc, chiều dài mối nối theo quy định của thiết kế. Khi cọc có chiều dài lớn, Nhà thầu phải có thêm biện pháp gia cường mối nối để tránh tụt lồng thép khi lắp hạ.

  * Ống siêu âm (thường là ống thép đường kính 60 mm) cần được buộc chặt vào cốt thép chủ, đáy ống được bịt kín và hạ sát xuống đáy cọc, nối ống bằng hàn, có măng xông, đảm bảo kín, tránh rò rỉ nước xi măng làm tắc ống, khi lắp đặt cần đảm bảo đồng tâm. Chiều dài ống siêu âm theo chỉ định của thiết kế, thông thường được đặt cao hơn mặt đất san lấp xung quanh cọc từ 10 cm đến 20 cm. Sau khi đổ bê tông các ống được đổ đầy nước sạch và bịt kín, tránh vật lạ rơi vào làm tắc ống.

  * CHÚ THÍCH: Số lượng ống siêu âm cho 1 cọc thường quy định như sau:


  2. ống cho cọc có đường kính 60 cm;


3 ống cho cọc có đường kính từ 60 cm đến 100 cm
4 ống cho cọc có đường kính lớn hơn 100 cm.

# Xử lý cặn lắng đáy lỗ khoan trước khi đổ bê tông

  * Sau khi hạ cốt thép mà cặn lắng vẫn quá quy định phải dùng biện pháp khí nâng (air lift) hoặc bơm hút bằng máy bơm. Liên tục bổ sung dung dịch khoan để đảm bảo cao độ dung dịch theo quy định, tránh gây sập thành lỗ khoan.

  * Công nghệ khí nâng được dùng để làm sạch hố khoan. Khí nén được đưa xuống gần đáy hố khoan qua ống thép đường kính khoảng 60 mm, dày từ 3 mm đến 4 mm, cách đáy khoảng từ 50 cm đến 60 cm. Khí nén trộn với bùn nặng tạo thành loại bùn nhẹ dâng lên theo ống đổ bê tông (ống tremi) ra ngoài; bùn nặng dưới đáy ống tremi lại được trộn với khí nén thành bùn nhẹ; dung dịch khoan tươi được bổ sung liên tục bù cho bùn nặng đã trào ra; quá trình thổi rửa tiến hành cho tới khi các chỉ tiêu của dung dịch khoan và độ lắng đạt yêu cầu quy định.


# Đổ bê tông

  * Bê tông dùng thi công cọc khoan nhồi phải được thiết kế thành phần hỗn hợp và điều chỉnh bằng thí nghiệm, các loại vật liệu cấu thành hỗn hợp bê tông phải được kiểm định chất lượng theo các tiêu chuẩn Việt Nam hiện hành. Có thể dùng phụ gia bê tông để tăng độ sụt của bê tông và kéo dài thời gian ninh kết của bê tông. Ngoài việc đảm bảo yêu cầu của thiết kế về cường độ, hỗn hợp bê tông có độ sụt từ 18 cm đến 20 cm.

  * Ống đổ bê tông được chế bị trong nhà máy thường có đường kính từ 219 mm đến 273 mm theo tổ hợp 0,5; 1,0; 2,0; 3,0 và 6,0 m, ống dưới cùng được tạo vát hai bên để làm cửa xả, nối ống bằng ren hình thang hoặc khớp nối dây rút đặc biệt, đảm bảo kín khít, không lọt dung dịch khoan vào trong. Đáy ống đổ bê tông phải luôn ngập trong bê tông không ít hơn 1,5 m.

  * Dùng nút dịch chuyển tạm thời (dùng phao bằng bọt biển hoặc nút cao su, nút nhựa có vát côn), đảm bảo cho mẻ vữa bê tông đầu tiên không tiếp xúc trực tiếp với dung dịch khoan trong ống đổ bê tông và loại trừ khoảng chân không khi đổ bê tông.

  * Bê tông được đổ không gián đoạn trong thời gian dung dịch khoan có thể giữ thành hố khoan (thông thường là 4 h). Các xe bê tông đều được kiểm tra độ sụt đúng quy định để tránh tắc ống đổ do vữa bê tông quá khô. Dừng đổ bê tông khi cao độ bê tông cọc cao hơn cao độ cắt cọc khoảng 1 m (để loại trừ phần bê tông lẫn dung dịch khoan khi thi công đài cọc).

  * Sau khi đổ xong mỗi xe, tiến hành đo độ dâng của bê tông trong lỗ cọc, ghi vào hồ sơ để vẽ đường đổ bê tông. Khối lượng bê tông thực tế so với kích thước lỗ cọc theo lý thuyết không được vượt quá 20 %. Khi tổn thất bê tông lớn phải kiểm tra lại biện pháp giữ thành lỗ khoan.


# Rút ống vách và vệ sinh đầu cọc

  * Sau khi kết thúc đổ bê tông từ 15 min đến 20 min cần tiến hành rút ống chống tạm (casing) bằng hệ thống day (rút + xoay) của máy khoan hoặc đầu rung theo phương thẳng đứng, đảm bảo ổn định đầu cọc và độ chính xác tâm cọc.

  * Sau khi rút ống vách từ 1 h đến 2 h cần tiến hành hoàn trả hố khoan bằng cách lấp đất hoặc cát, cắm biển báo cọc đã thi công cấm mọi phương tiện qua lại tránh hỏng đầu cọc và ống siêu âm.


# Kiểm tra và nghiệm thu

  * Chất lượng cọc được kiểm tra trong tất cả các công đoạn thi công, ghi vào mẫu biên bản được thống nhất giữa các bên tham gia nghiệm thu, tham khảo Phụ lục C.

  * Kiểm tra dung dịch khoan

  * Dung dịch khoan phải được chuẩn bị trong các bồn chứa có dung tích đủ lớn, pha với nước sạch, cấp phối tuỳ theo chủng loại bentonite, điều kiện địa chất công trình và địa chất thuỷ văn của địa điểm xây dựng, đảm bảo giữ thành hố khoan trong suốt quá trình thi công khoan lỗ, lắp dựng cốt thép, ống kiểm tra siêu âm, ống đặt sẵn để khoan lấy lõi đáy cọc (nếu có), cẩu lắp ống đổ bê tông và sàn công tác... Bề dày lớp cặn lắng đáy cọc không quá trị số sau:


  * Cọc chống: không quá 5 cm;

  * Cọc ma sát + chống: không quá 10 cm.


  * Kiểm tra dung dịch khoan bằng các thiết bị thích hợp. Dung trọng của dung dịch trộn mới được kiểm tra hàng ngày để biết chất lượng, việc đo lường dung trọng nên đạt tới độ chính xác 0,005 g/cm³. Các thí nghiệm kiểm tra dung dịch bentonite tiến hành theo quy định tại Bảng 1 cho mỗi lô bentonite trộn mới. Việc kiểm tra, nghiệm thu dung trọng, độ nhớt, hàm lượng cát và độ pH phải được kiểm tra cho từng cọc. Trước khi đổ bê tông nếu kiểm tra mẫu dung dịch tại độ sâu khoảng 0,5 m từ đáy lên có khối lượng riêng vượt quá 1,25 g/cm³, hàm lượng cát lớn hơn 8 %, độ nhớt quá 28 s thì phải có biện pháp thổi rửa đáy lỗ khoan để đảm bảo chất lượng cọc.

  * Kiểm tra lỗ khoan


CHÚ THÍCH: Kích thước lỗ khoan khuyến khích Nhà thầu tự kiểm tra để hoàn thiện công nghệ, hiện tại trong thực tế chưa bắt buộc phải đo đường kính lỗ (chỉ khống chế chiều sâu, độ lắng đáy và khối lượng bê tông).
CHÚ THÍCH 1: Giá trị âm ở sai số cho phép về đường kính cọc chỉ ở tiết diện cọc cá biệt.
CHÚ THÍCH 2: Sai số về độ nghiêng của cọc xiên không lớn hơn 15 % góc nghiêng của cọc.
CHÚ THÍCH 3: Sai số cho phép về độ sâu hố khoan ± 10 cm.
CHÚ THÍCH 4: D là đường kính thiết kế cọc, H là khoảng cách giữa cao độ mặt đất thực tế và cao độ căt cọc trong thiết kế.
Kiểm tra cốt thép
Sai số cho phép về lồng cốt thép do thiết kế quy định và tham khảo Bảng 4.
Bảng 4- Sai số cho phép chế tạo lồng thép.


|  | Hạng mục | Sai số cho phép, mm |
| --- | --- | --- |
| 1. | Khoảng cách giữa các cốt chủ | ± 10 |
| 2. | Khoảng cách cốt đai hoặc cốt lò so | ±20 |
| 3. | Đường kính lồng thép | ± 10 |
| 4. | Độ dài lồng thép | ±50 |

 

## Kiểm tra chất lượng bê tông thân cọc

### Bê tông trước khi đổ phải lấy mẫu, mỗi cọc 3 tổ mẫu lấy cho ba phần, đầu, giữa và mũi cọc, mỗi tổ 3 mẫu.

Cốt liệu, nước và xi măng được thử mẫu, kiểm tra theo quy định cho công tác bê tông. Kết quả ép mẫu kèm theo lý lịch cọc.

### Phương pháp siêu âm, tán xạ Gamma, phương pháp động biến dạng nhỏ...và các phương pháp thử không phá hoại khác được dùng để đánh giá chất lượng bê tông cọc đã thi công, tuỳ theo mức độ quan trọng của công trình, thiết kế chỉ định số lượng cọc cần kiểm tra.

Đối với các công trình dân dụng và công nghiệp thông thường, khối lượng kiểm tra chất lượng bê tông cọc tối thiểu theo Bảng 5. Cần kết hợp từ 2 phương pháp khác nhau trở lên để kiểm tra. Khi cọc có chiều sâu lớn hơn 30 lần đường kính (L/D > 30) thì phương pháp kiểm tra qua ống đặt sẵn là chủ yếu. Nếu còn nghi ngờ khuyết tật cần kiểm tra bằng khoan lấy mẫu để khẳng định khả năng chịu tải lâu dài của cọc trước khi có quyết định sửa chữa hoặc thay thế. Quyết định cuối cùng do Thiết kế kiến nghị, Chủ đầu tư chấp thuận. Thí nghiệm siêu âm tiến hành theo TCVN 9396:2012. Thí nghiệm động biến dạng nhỏ tiến hành theo TCVN 9397:2012.

### Phương pháp khoan kiểm tra tiếp xúc đáy cọc với đất tiến hành trong ống đặt sẵn, đường kính từ 102 mm đến 114 mm cao hơn mũi cọc từ 1 m đến 2 m, số lượng ống đặt sẵn để khoan lõi đáy cọc theo quy định của Thiết kế, tham khảo Bảng 5. Khi mũi cọc tựa vào cuội hòn lớn, có thể bị mất nước xi măng ở phần tiếp xúc đáy cọc - cuội sỏi, cần thận trọng khi đánh giá chất lượng bê tông cọc.

Bảng - Khối lượng kiểm tra chất lượng bê tông cọc


| Phương pháp kiểm tra | Tỷ lệ kiểm tra tối thiểu, % số cọc |
| --- | --- |

 

## Kiểm tra sức chịu tải của cọc đơn

### Sức chịu tải của cọc đơn do thiết kế xác định. 

Tuỳ theo mức độ quan trọng của công trình và tính phức tạp của điều kiện địa chất công trình mà thiết kế quy định số lượng cọc cần kiểm tra sức chịu tải.
CHÚ THÍCH 1: Thang điểm để chọn số lượng cọc cần kiểm tra tính toàn khối tham khảo Phụ lục A
CHÚ THÍCH 2: Đánh giá và xử lý cọc khoan nhồi có thể tham khảo Phụ lục B.
1 Số lượng cọc cần kiểm tra sức chịu tải được quy định dựa trên mức độ hoàn thiện công nghệ của Nhà thầu, mức độ rủi ro khi thi công, tầm quan trọng của công trình, nhưng tối thiểu là mỗi loại đường kính 1 cọc, tối đa là 2 % tổng số cọc. Kết quả thí nghiệm là căn cứ pháp lý để nghiệm thu móng cọc.

### Phương pháp kiểm tra sức chịu tải của cọc đơn chủ yếu là thử tĩnh (nén tĩnh, nhổ tĩnh, nén ngang) theo tiêu chuẩn hiện hành. 

Đối với các cọc không thể thử tĩnh được (cọc trên sông, biển...) thì dùng phương pháp thí nghiệm động biến dạng lớn (PDA), Osterberg, Statnamic ...

### Tiến hành thử tĩnh cọc có thể trước hoặc sau khi thi công cọc đại trà. Để xác định phương án thiết kế có thể tiến hành thử tĩnh cọc ngoài móng công trình đến phá hoại trước khi thi công đại trà; để chấp nhận chất lượng thi công có thể tiến hành thí nghiệm khi thi công xong. Đầu cọc thí nghiệm phải cao hơn mặt đất xung quanh từ 20 cm đến 30 cm và có ống thép dày từ 5 mm đến 6 mm, dài khoảng 1 m bao để đảm bảo không bị nứt khi thí nghiệm và phản ánh đúng chất lượng thi công. Thí nghiệm nén tĩnh tiến hành theo TCVN 9393:2012.

## Nghiệm thu cọc khoan nhồi

Nghiệm thu công tác thi công cọc tiến hành dựa trên cơ sơ các hồ sơ sau:

  * Hồ sơ thiết kế dược duyệt;

  * Biên bản nghiệm thu trắc đạc định vị trục móng cọc;

  * Kết quả kiểm định chất lượng vật liệu, chứng chỉ xuất xưởng của cốt thép và các loại vật liệu chế tạo trong nhà máy;

  * Kết quả thí nghiệm mẫu bê tông;

  * Hồ sơ nghiệm thu từng cọc, tham khảo Phụ lục C; thành phần nghiệm thu theo quy định hiện hành;

  * Hồ sơ hoàn công cọc có thuyết minh sai lệch theo mặt bằng và chiều sâu cùng các cọc bổ sung và các thay đổi thiết kế đã được chấp thuận;

  * Các kết quả thí nghiệm kiểm tra độ toàn khối của cọc (siêu âm, thí nghiệm biến dạng nhỏ (PIT)...) theo quy định của Thiết kế;

  * Các kết quả thí nghiệm kiểm tra sức chịu tải của cọc.


# Các biện pháp an toàn lao động

  * Công tác an toàn lao động cần tuân theo TCVN 5308:1991 và các quy định an toàn hiện hành liên quan.

  * Tất cả các loại máy móc, thiết bị vân hành phải tuyệt đối tuân theo quy trình thao tác và quy trình an toàn, đặc biệt là quy trình an toàn cho xe cẩu và máy khoan.

  * Lắp dựng hệ thống biển báo khu vực nguy hiểm, khu vực cọc vừa mới đổ xong bê tông, cấm di chuyển qua các khu vực này.

  * Khi bị tắc ống đổ bê tông, Nhà thầu phải có phương án xử lý được thiết kế chấp thuận và chỉ được xử lý theo lệnh của người chỉ huy chung.

# Public_017

# Yêu cầu đối với tính toán kết cấu bê tông và bê tông cốt thép

## Yêu cầu chung

### Tính toán kết cấu bê tông và bê tông cốt thép cần được tiến hành phù hợp với các yêu cầu của

TCVN 9379:2012 theo các trạng thái giới hạn, bao gồm:

  * Các trạng thái giới hạn thứ nhất, dẫn tới mất hoàn toàn khả năng sử dụng kết cấu;

  * Các trạng thái giới hạn thứ hai, làm khó khăn cho sử dụng bình thường hoặc giảm độ bền lâu của nhà và công trình so với thời hạn sử dụng đã dự định.


Các tính toán cần phải đảm bảo được độ tin cậy của nhà và công trình trong suốt thời hạn sử dụng của chúng, cũng như trong quá trình thi công phù hợp với các yêu cầu đề ra đối với chúng.

Các tính toán theo các trạng thái giới hạn thứ nhất bao gồm:

  * Tính toán độ bền;

  * Tính toán ổn định hình dạng (đối với kết cấu thành mỏng); Tính toán ổn định ví trí (lật, trượt, đẩy nổi).

  * Tính toán độ bền kết cấu bê tông và bê tông cốt thép cần được tiến hành theo điều kiện mà trong đó nội lực, ứng suất và biến dạng trong kết cấu do các tác động khác nhau có kể đến trạng thái ứng suất ban đầu (ứng suất trước, tác động nhiệt độ và tác động khác) không được vượt quá các giá trị mà kết cấu có thể chịu được.

  * Tính toán ổn định hình dạng kết cấu, cũng như ổn định vị trí (có kể đến sự làm việc đồng thời của kết cấu và nền, các tính chất biến dạng của chúng, khả năng chống trượt tại bề mặt tiếp xúc với nền và các đặc điểm riêng khác) cần được tiến hành theo các chỉ dẫn của các tiêu chuẩn áp dụng cho các loại kết cấu riêng.


Trong các trường hợp cần thiết, tùy thuộc vào loại, công năng kết cấu cần tiến hành các tính toán theo các trạng thái giới hạn liên quan đến các hiện tượng dẫn đến phải dừng sử dụng nhà và công trình (biến dạng quá mức, trượt trong các liên kết và các hiện tượng khác).

Tính toán theo các trạng thái giới hạn thứ hai bao gồm:

  * Tính toán hình thành vết nứt; Tính toán mở rộng vết nứt;


## Tính toán biến dạng.

  * Tính toán kết cấu bê tông và bê tông cốt thép theo sự hình thành vết nứt cần được tiến hành theo điều kiện mà trong đó ứng suất hoặc biến dạng trong kết cấu do các tác động khác nhau không được vượt quá các giá trị giới hạn tương ứng của chúng do kết cấu phải chịu khi hình thành vết nứt.

  * Tính toán kết cấu bê tông và bê tông cốt thép theo sự mở rộng vết nứt cần được tiến hành theo điều kiện mà trong đó chiều rộng vết nứt trong kết cấu do các tác động khác nhau không được vượt quá các giá trị giới hạn cho phép được quy định phụ thuộc vào các yêu cầu đối với kết cấu, các điều kiện sử dụng chúng, tác động của môi trường xung quanh và các đặc trưng vật liệu có kể đến các đặc điểm riêng về ứng xử ăn mòn của cốt thép.

  * Tính toán kết cấu bê tông và bê tông cốt thép theo biến dạng cần được tiến hành theo điều kiện mà trong đó độ võng, góc xoay, chuyển vị và biên độ dao động của kết cấu do các tác động khác nhau không được vượt quá các giá trị giới hạn cho phép tương ứng.


Đối với kết cấu mà trong đó không cho phép hình thành vết nứt thì cần phải đảm bảo các yêu cầu không xuất hiện vết nứt. Trong trường hợp này, không cần tính toán mở rộng vết nứt.
Đối với các kết cấu khác mà trong đó cho phép hình thành vết nứt thì tính toán theo sự hình thành vết nứt được tiến hành để xác định sự cần thiết phải tính toán theo sự mở rộng vết nứt và kể đến vết nứt trong tính toán biến dạng.

### Tính toán kết cấu bê tông và bê tông cốt thép (dạng thanh, phẳng, không gian, khối) theo các trạng thái giới hạn thứ nhất và thứ hai được tiến hành theo ứng suất, nội lực, biến dạng và chuyển vị đã tính được do các tác động ngoài trong các kết cấu và được hình thành trong các hệ được tạo ra từ các kết cấu của nhà và công trình có kể đến tính phi tuyến vật lý (biến dạng không đàn hồi của bê tông và cốt thép), khả năng hình thành vết nứt và trong các trường hợp cần thiết – tính không đẳng hướng, sự tích tụ hư hỏng và tính phi tuyến hình học (ảnh hưởng của biến dạng đến sự thay đổi nội lực trong kết cấu).

  * Tính phi tuyến vật lý và tính không đẳng hướng cần được kể đến trong các quan hệ giữa ứng suất và biến dạng (hoặc nội lực và chuyển vị), cũng như trong các điều kiện độ bền và độ chống nứt của vật liệu.

  * Trong các kết cấu siêu tĩnh cần kể đến sự phân bố lại nội lực trong các cấu kiện của hệ kết cấu do hình thành vết nứt và phát triển các biến dạng không đàn hồi trong bê tông và cốt thép đến tận khi xuất hiện trạng thái giới hạn trong cấu kiện. Khi không có các phương pháp tính toán mà có thể kể đến được các tính chất không đàn hồi của bê tông cốt thép, cũng như đối với các tính toán sơ bộ có kể đến các tính chất không đàn hồi của bê tông cốt thép thì cho phép xác định nội lực và ứng suất trong các kết cấu và các hệ siêu tĩnh với giả thiết sự làm việc đàn hồi của các cấu kiện bê tông cốt thép. Khi đó, ảnh hưởng của tính phi tuyến vật lý nên được kể đến bằng cách hiệu chỉnh các kết quả tính toán đàn hồi trên cơ sở các số liệu nghiên cứu thực nghiệm, mô hình phi tuyến, kết quả tính toán các công trình tương tự và các đánh giá chuyên gia.

  * Khi tính toán kết cấu theo độ bền, biến dạng, hình thành và mở rộng vết nứt trên cơ sở phương pháp phần tử hữu hạn thì cần phải kiểm tra các điều kiện độ bền và độ chống nứt đối với tất cả các phần tử hữu hạn tạo nên kết cấu, cũng như các điều kiện xuất hiện các chuyển vị quá mức của kết cấu. Khi đánh giá trạng thái giới hạn về độ bền thì cho phép giả thiết rằng các phần tử hữu hạn riêng lẻ bị phá hoại, nếu như điều này không dẫn đến phá hủy dây chuyền (lũy tiến) nhà hoặc công trình, và khi tác động đang xét thôi tác dụng thì khả năng sử dụng bình thường của nhà hoặc công trình được bảo toàn hoặc có thể khôi phục được.

  * Xác định các nội lực và biến dạng giới hạn trong các kết cấu bê tông và bê tông cốt thép cần được tiến hành dựa trên các sơ đồ (mô hình) tính toán phản ánh được thực chất đặc điểm vật lý về sự làm việc của các kết cấu và vật liệu ở trạng thái giới hạn đang xét.

  * Cho phép xác định khả năng chịu lực của các kết cấu bê tông cốt thép mà có thể chịu được các biến dạng dẻo (ví dụ: khi sử dụng cốt thép có giới hạn chảy thực tế) bằng phương pháp cân bằng giới hạn.


###  Khi tính toán các kết cấu bê tông và bê tông cốt thép theo các trạng thái giới hạn thì cần xét các trường hợp tính toán khác nhau phù hợp với TCVN 9379:2012, trong đó có giai đoạn chế tạo, vận chuyển, sử dụng, các trường hợp sự cố, cũng như trường hợp có cháy.

### Tính toán kết cấu bê tông và bê tông cốt thép cần được tiến hành với tất cả các loại tải trọng theo chức năng của nhà và công trình, có kể đến ảnh hưởng của môi trường xung quanh (các tác động khí hậu và nước – đối với các kết cấu nằm trong nước), còn trong các trường hợp cần thiết – có kể đến tác động của lửa, các tác động công nghệ, các tác động nhiệt độ và ẩm và các tác động của môi trường hóa học xâm thực.

### Tính toán kết cấu bê tông và bê tông cốt thép được tiến hành dưới tác dụng của mô men uốn, lực dọc, lực cắt và mô men xoắn, cũng như dưới tác dụng cục bộ của tải trọng.

### Khi tính toán các cấu kiện của các kết cấu lắp ghép chịu tác dụng của nội lực sinh ra khi nâng, vận chuyển và lắp dựng, thì tải trọng do trọng lượng các cấu kiện cần được nhân với hệ số động lực bằng 1,60 khi vận chuyển và bằng 1,40 khi nâng và lắp dựng.

Khi có cơ sở thì cho phép lấy giá trị hệ số động lực thấp hơn, nhưng không thấp hơn 1,25.

### Khi tính toán các kết cấu bê tông và bê tông cốt thép cần kể đến các đặc điểm riêng của các tính chất của các loại bê tông và cốt thép, ảnh hưởng của đặc điểm tải trọng và môi trường xung quanh đến chúng, biện pháp đặt cốt thép, sự làm việc đồng thời của cốt thép và bê tông (khi có hoặc không có bám dính giữa cốt thép và bê tông), công nghệ chế tạo các loại cấu kiện bê tông cốt thép của nhà và công trình.

### Tính toán các kết cấu ứng suất trước cần được tiến hành có kể đến ứng suất ban đầu (ứng suất trước) và biến dạng trong cốt thép và bê tông, hao tổn ứng suất trước và các đặc điểm truyền lực nén trước lên bê tông.

### Trong các kết cấu liền khối cần phải đảm bảo được độ bền của các kết cấu có kể đến các mạch ngừng thi công.

### Khi tính toán kết cấu lắp ghép cần phải đảm bảo độ bền của các liên kết nút và liên kết đối đầu của các cấu kiện lắp ghép đã được thực hiện bằng cách nối các chi tiết thép đặt sẵn, các đầu thép chờ và đổ bù bằng bê tông.

### Khi tính toán các kết cấu phẳng và kết cấu không gian chịu tác động của lực theo hai phương vuông góc nhau thì cần xét các phần tử phẳng nhỏ hoặc không gian điển hình tách từ kết cấu với các nội lực tác dụng theo các cạnh bên của phần tử. Khi có các vết nứt thì các nội lực này cần được xác định có kể đến vị trí các vết nứt, độ cứng của cốt thép (độ cứng dọc trục và tiếp tuyến), độ cứng của bê tông (nằm giữa các vết nứt và ở tại các vết nứt) và các đặc điểm riêng khác. Khi không có vết nứt thì nội lực được xác định như đối với vật thể đặc. Khi có các vết nứt thì cho phép xác định nội lực với giả thiết cấu kiện bê tông làm việc đàn hồi. Tính toán các cấu kiện cần được tiến hành theo các tiết diện nguy hiểm nhất nằm dưới một góc so với phương nội lực tác dụng lên cấu kiện, trên cơ sở các mô hình tính toán có kể đến sự làm việc của cốt thép chịu kéo ở vị trí có vết nứt và sự làm việc của bê tông giữa các vết nứt trong các điều kiện trạng thái ứng suất phẳng.

### Tính toán các kết cấu phẳng và không gian cho phép được tiến hành đối với kết cấu về tổng thể dựa trên phương pháp cân bằng giới hạn, kể cả có kể đến trạng thái biến dạng tại thời điểm gần phá hoại.

### Khi tính toán các kết cấu khối chịu tác động của lực theo ba phương trực giao thì cần xét các phần tử khối nhỏ điển hình tách từ kết cấu với các nội lực tác dụng theo các mặt của phẩn tử. Khi đó, các nội lực cần được xác định dựa trên giả thiết tương tự đã được chấp nhận đối với các phần tử phẳng 

Tính toán các cấu kiện cần được tiến hành theo các tiết diện nguy hiểm nhất nằm dưới một góc so với phương nội lực tác dụng lên cấu kiện, trên cơ sở các mô hình tính toán có kể đến sự làm việc của bê tông và cốt thép trong các điều kiện trạng thái ứng suất khối.

### Đối với các kết cấu có cấu hình phức tạp (ví dụ, kết cấu không gian) thì ngoài các phương pháp tính toán để đánh giá khả năng chịu lực, khả năng chống nứt và biến dạng, cũng có thể sử dụng các kết quả thử nghiệm mô hình kết cấu.

## Yêu cầu đối với tính toán cấu kiện bê tông và bê tông cốt thép theo độ bền

Tính toán kết cấu bê tông và bê tông cốt thép theo độ bền được tiến hành:
Theo các tiết diện thẳng góc (khi có tác dụng của mô men uốn và lực dọc) – theo mô hình biến dạng phi tuyến. Đối với các loại kết cấu bê tông cốt thép đơn giản (tiết diện chữ nhật, chữ T và chữ I với cốt thép nằm ở biên trên và biên dưới của tiết diện) thì cho phép tiến hành tính toán theo nội lực giới hạn;
Theo tiết diện nghiêng (khi có tác dụng của lực cắt), theo tiết diện không gian (khi có tác dụng của mô men xoắn), chịu tác dụng cục bộ của tải trọng (nén cục bộ, chọc thủng)
Tính toán độ bền các cấu kiện bê tông cốt thép ngắn (công xôn ngắn và các cấu kiện khác tương tự) được tiến hành theo mô hình thanh – giàn (giàn ảo).

### Tính toán độ bền cấu kiện bê tông và bê tông cốt thép theo nội lực giới hạn được tiến hành theo điều kiện mà nội lực do tải trọng và tác động ngoài _F_ trong tiết diện đang xét không vượt quá nội

lực giới hạn _Fu_ mà cấu kiện có thể chịu được trong tiết diện này:

### Các cấu kiện bê tông, tùy thuộc vào điều kiện làm việc và yêu cầu đối với chúng, cần được tính toán theo các tiết diện thẳng góc theo nội lực giới hạn không kể đến hoặc có kể đến cường độ chịu kéo của bê tông vùng chịu kéo.

### Tiến hành tính toán không kể đến cường độ chịu kéo của bê tông đối với các cấu kiện bê tông chịu nén lệch tâm với độ lệch tâm của lực dọc không vượt quá 0,9 khoảng cách từ trọng tâm tiết diện đến thớ chịu nén nhiều nhất. Khi đó, nội lực giới hạn, mà cấu kiện có thể chịu được, được xác định theo cường độ chịu nén tính toán của bê tông _Rb_ , phân bố đều trên vùng chịu nén quy ước của tiết diện có trọng tâm trùng với điểm đặt lực dọc.

Đối với kết cấu bê tông dạng khối thì sử dụng biểu đồ ứng suất trong vùng chịu nén dạng tam giác với ứng suất không vượt quá giá trị tính toán của cường độ chịu nén tính toán của bê tông _Rb_. Khi đó, độ lệch tâm của lực dọc đối với trọng tâm tiết diện không được vượt quá 0,65 khoảng cách từ trọng tâm tiết diện đến thớ bê tông chịu nén nhiều nhất.

### Tiến hành tính toán có kể đến cường độ chịu kéo của bê tông đối với các cấu kiện bê tông chịu nén lệch tâm với độ lệch tâm của lực dọc lớn hơn giá trị nêu đối với cấu kiện bê tông chịu uốn (mà được phép sử dụng), cũng như đối với cấu kiện chịu nén lệch tâm với độ lệch tâm của lực dọc bằng giá trị, nhưng trong đó không cho phép hình thành vết nứt theo các điều kiện sử dụng. Khi đó, nội lực giới hạn, mà tiết diện cấu kiện có thể chịu được, được xác định như đối với vật thể đàn hồi với ứng suất kéo lớn nhất bằng giá trị tính toán của cường độ chịu kéo dọc trục của bê tông _Rbt_.

### Khi tính toán cấu kiện bê tông chịu nén lệch tâm cần kể đến ảnh hưởng của uốn dọc và độ lệch tâm ngẫu nhiên.

## Tính toán cấu kiện bê tông cốt thép theo độ bền tiết diện thẳng góc

### Tính toán cấu kiện bê tông cốt thép theo nội lực giới hạn cần được tiến hành với các nội lực giới hạn mà bê tông và cốt thép có thể chịu được, dựa trên các giả thiết sau:

  * Cường độ chịu kéo của bê tông lấy bằng không;

  * Cường độ chịu nén của bê tông lấy bằng ứng suất có giá trị bằng cường độ chịu nén tính toán của bê tông và được phân bố đều trên vùng chịu nén quy ước của bê tông;

  * Ứng suất kéo và nén trong cốt thép lấy không lớn hơn cường độ chịu kéo tính toán và chịu nén tính toán tương ứng.


### Tính toán cấu kiện bê tông cốt thép theo mô hình biến dạng phi tuyến được tiến hành trên cơ sở các biểu đồ biến dạng của bê tông và cốt thép, xuất phát từ giả thiết tiết diện phẳng. Tiêu chí độ bền của tiết diện thẳng góc là biến dạng tương đối trong bê tông hoặc cốt thép đạt tới giá trị giới hạn.

### Khi tính toán cấu kiện bê tông cốt thép chịu nén lệch tâm cần kể đến ảnh hưởng của uốn dọc và độ lệch tâm ngẫu nhiên.

## Tính toán cấu kiện bê tông cốt thép theo độ bền tiết diện nghiêng

### Tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện nghiêng được tiến hành: theo tiết diện nghiêng chịu tác dụng của lực cắt, theo tiết diện nghiêng chịu tác dụng của mô men uốn và theo dải bê tông giữa các tiết diện nghiêng chịu tác dụng của lực cắt.

### Khi tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện nghiêng chịu tác dụng của lực cắt thì lực cắt giới hạn mà cấu kiện có thể chịu được trên tiết diện nghiêng cần được xác định bằng tổng các lực cắt giới hạn chịu bởi bê tông trong tiết diện nghiêng và bởi cốt thép ngang cắt qua tiết diện nghiêng.

### Khi tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện nghiêng chịu tác dụng của mô men uốn thì mô men uốn giới hạn mà cấu kiện có thể chịu được trên tiết diện nghiêng cần được xác định bằng tổng các mô men uốn giới hạn chịu bởi cốt thép dọc và cốt thép ngang cắt qua tiết diện nghiêng, đối với trục đi qua điểm đặt hợp lực của các nội lực trong vùng chịu nén.

### Khi tính toán cấu kiện bê tông cốt thép theo độ bền dải bê tông giữa các tiết diện nghiêng chịu tác dụng của lực cắt thì lực cắt giới hạn mà cấu kiện có thể chịu được cần được xác định theo độ bền của dải bê tông nghiêng nằm dưới tác dụng của nội lực nén dọc theo dải bê tông này và nội lực kéo do cốt thép ngang cắt qua dải bê tông nghiêng.

## Tính toán cấu kiện bê tông cốt thép theo độ bền tiết diện không gian

Khi tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện không gian thì mô men xoắn giới hạn mà cấu kiện có thể chịu được cần được xác định bằng tổng mô men xoắn giới hạn chịu bởi cốt thép dọc và cốt thép ngang nằm ở mỗi cạnh cấu kiện. Ngoài ra, cần tiến hành tính toán độ bền cấu kiện bê tông cốt thép theo dải bê tông giữa các tiết diện không gian và chịu tác dụng của lực nén dọc theo dải bê tông và lực kéo do cốt thép ngang cắt qua dải bê tông.

## Tính toán cấu kiện bê tông cốt thép chịu tác dụng cục bộ của tải trọng

### Khi tính toán cấu kiện bê tông cốt thép chịu tác dụng cục bộ thì lực nén giới hạn mà cấu kiện có thể chịu được cần được xác định xuất phát từ cường độ của bê tông ở trạng thái ứng suất khối được tạo bởi bê tông bao quanh và cốt thép hạn chế biến dạng ngang, nếu có.

### Tính toán chọc thủng được tiến hành đối với các cấu kiện bê tông cốt thép phẳng (bản sàn) khi có tác dụng của lực tập trung và mô men tập trung trong vùng chọc thủng. Nội lực giới hạn mà cấu kiện bê tông cốt thép có thể chịu được khi chọc thủng được xác định bằng tổng nội lực giới hạn chịu bởi bê tông và cốt thép ngang nằm trong vùng chọc thủng.

## Yêu cầu đối với tính toán cấu kiện bê tông cốt thép theo sự hình thành vết nứt

### Tính toán cấu kiện bê tông cốt thép theo sự hình thành vết nứt thẳng góc được tiến hành theo nội lực giới hạn hoặc theo mô hình biến dạng phi tuyến. Tính toán theo sự hình thành vết nứt xiên được tiến hành theo nội lực giới hạn.

### Tính toán theo sự hình thành các vết nứt của các cấu kiện bê tông cốt được tiến hành theo điều kiện mà nội lực do tải trọng và tác động ngoài.

### Nội lực chịu bởi cấu kiện bê tông cốt thép khi hình thành các vết nứt thẳng góc cần được xác định từ tính toán cấu kiện bê tông cốt thép như đối với vật thể đặc có kể đến các biến dạng đàn hồi trong cốt thép và biến dạng không đàn hồi trong bê tông chịu kéo và chịu nén với ứng suất pháp lớn nhất khi kéo trong bê tông bằng giá trị tính toán của cường độ chịu kéo dọc trục của bê tông _Rbt,ser._

### Tính toán theo sự hình thành các vết nứt thẳng góc của các cấu kiện bê tông cốt thép theo mô hình biến dạng phi tuyến được tiến hành dựa trên các biểu đồ biến dạng của cốt thép, của bê tông chịu kéo và bê tông chịu nén, và dựa trên giả thiết tiết diện phẳng. Tiêu chí hình thành các vết nứt là biến dạng tương đối trong bê tông chịu kéo đạt tới giá trị giới hạn.

### Nội lực mà cấu kiện bê tông cốt thép có thể chịu được khi hình thành vết nứt xiên cần được xác định từ tính toán cấu kiện bê tông cốt thép như đối với vật thể đàn hồi và theo tiêu chí độ bền của bê tông ở trạng thái ứng suất phẳng “kéo-nén”.

##  Yêu cầu đối với tính toán cấu kiện bê tông cốt thép theo sự mở rộng vết nứt

### Tính toán cấu kiện bê tông cốt thép được tiến hành theo sự mở rộng các loại vết nứt khác nhau trong các trường hợp khi mà việc kiểm tra bằng tính toán theo sự hình thành vết nứt chỉ ra rằng các vết nứt sẽ hình thành.

### Tính toán theo sự mở rộng vết nứt được tiến hành theo điều kiện mà chiều rộng vết nứt _a crc_ do ngoại lực không được vượt quá giá trị chiều rộng vết nứt giới hạn cho phép

### Chiều rộng vết nứt thẳng góc được xác định bằng tích của biến dạng tương đối trung bình của cốt thép trên đoạn giữa các vết nứt và chiều dài đoạn này. Biến dạng tương đối trung bình giữa các vết nứt được xác định có kể đến sự làm việc của bê tông chịu kéo giữa các vết nứt. Biến dạng tương đối của cốt thép tại vết nứt được xác định từ tính toán đàn hồi quy ước cấu kiện bê tông cốt thép có vết nứt với việc sử dụng mô đun biến dạng quy đổi của bê tông chịu nén được xác định có kể đến ảnh hưởng của biến dạng không đàn hồi của bê tông vùng chịu nén, hoặc theo mô hình biến dạng phi tuyến. Khoảng cách giữa các vết nứt được xác định theo các điều kiện mà hiệu số nội lực trong cốt thép dọc tại tiết diện có vết nứt và giữa các vết nứt cần phải được chịu bởi lực bám dính của cốt thép với bê tông trên chiều dài đoạn này

## Vật liệu cho kết cấu bê tông và bê tông cốt thép

### Bê tông

#### Các chỉ tiêu chất lượng của bê tông được sử dụng khi thiết kế

Đối với các kết cấu bê tông và bê tông cốt thép được thiết kế phù hợp với các yêu cầu của tiêu chuẩn này thì cần sử dụng các loại bê tông kết cấu sau:
Bê tông nặng có khối lượng thể tích trung bình từ 2 200 kg/m3 đến 2 500 kg/m3;
Bê tông hạt nhỏ có khối lượng thể tích trung bình từ 1 800 kg/m3 đến 2 200 kg/m3; Bê tông nhẹ;

  * Bê tông tổ ong;

  * Bê tông tự ứng suất.


Khi thiết kế các công trình bê tông và bê tông cốt thép phù hợp với các yêu cầu đối với các kết cấu cụ thể thì cần phải quy định loại bê tông và các chỉ tiêu chất lượng quy định của nó được kiểm soát trong thi công.
Các chỉ tiêu chất lượng quy định và cần được kiểm soát của bê tông bao gồm:
Cấp độ bền chịu nén B;

  * Cấp độ bền chịu kéo dọc trục Bt; Mác chống thấm nước W;

  * Mác khối lượng thể tích trung bình D; Mác tự ứng suất Sp.


Cấp độ bền chịu nén của bê tông B được định nghĩa trong 3.1.5 và được gọi là cường độ lập phương tiêu chuẩn.
Cấp độ bền chịu kéo dọc trục của bê tông Bt được định nghĩa trong 3.1.3 và được gọi là cường độ chịu kéo tiêu chuẩn.
Cho phép lấy giá trị xác suất đảm bảo khác của cường độ chịu nén và chịu kéo dọc trục của bê tông theo yêu cầu của các tiêu chuẩn đối với các loại công trình đặc biệt cụ thể.

# Public_018

# Phạm vi áp dụng

Tiêu chuẩn này quy định các yêu cầu thiết kế kết cấu bê tông và bê tông cốt thép của nhà và công trình với các chức năng khác nhau, chịu tác động có hệ thống của nhiệt độ không cao hơn dương 50 °С và không thấp hơn âm 70 °С, làm việc trong môi trường không xâm thực.
Tiêu chuẩn này quy định các yêu cầu về thiết kế kết cấu bê tông và bê tông cốt thép được chế tạo từ bê tông nặng, bê tông hạt nhỏ, bê tông nhẹ, bê tông tổ ong và bê tông tự ứng suất.
Tiêu chuẩn này không quy định các yêu cầu để thiết kế kết cấu liên hợp thép – bê tông, kết cấu bê tông cốt sợi, kết cấu bán lắp ghép, kết cấu bê tông và bê tông cốt thép của các công trình thủy công, cầu, lớp phủ mặt đường ô tô và đường băng sân bay và của các công trình đặc biệt khác, cũng như không quy định các yêu cầu để thiết kế kết cấu được chế tạo từ bê tông có khối lượng thể tích trung bình nhỏ hơn 500 kg/m3 và lớn hơn 2500 kg/m3, bê tông polyme và polyme bê tông, bê tông trên nền chất kết dính là vôi, xỉ và chất kết dính hỗn hợp (trừ khi sử dụng chúng trong bê tông tổ ong), trên nền thạch cao và chất kết dính đặc biệt, bê tông dùng cốt liệu đặc biệt và cốt liệu hữu cơ, bê tông có cấu trúc rỗng lớn.
Tiêu chuẩn này không quy định các yêu cầu về thiết kế các kết cấu đặc thù (bản sàn rỗng, kết cấu được giảm tiết diện ở phần đầu, mũ cột và các kết cấu tương tự).

# Tài liệu viện dẫn

Các tài liệu viện dẫn sau cần thiết cho việc áp dụng tiêu chuẩn này. Đối với các tài liệu viện dẫn ghi năm công bố thì áp dụng phiên bản được nêu. Đối với các tài liệu viện dẫn không ghi năm công bố thì áp dụng phiên bản mới nhất, bao gồm cả các sửa đổi, bổ sung (nếu có).
TCVN 1651-1:2008, _Thép cốt cho bê tông – Phần 1: Thép thanh tròn trơn_
TCVN 1651-2:2008, _Thép cốt cho bê tông – Phần 2: Thép thanh vằn_
TCVN 2737:1995, _Tải trọng và tác động – Tiêu chuẩn thiết kế_
TCVN 3108:1993, _Hỗn hợp bê tông nặng – Phương pháp xác định khối lượng thể tích_
TCVN 3116:1993, _Bê tông nặng – Phương pháp xác định độ chống thấm nước_
TCVN 5575:2012, _Kết cấu thép – Tiêu chuẩn thiết kế_
TCVN 6284-2:1997 (ISO 6394-2:1991) _, Thép cốt bê tông dự ứng lực – Phần 2: Dây kéo nguội_
TCVN 6284-4:1997 (ISO 6934-4:1991), _Thép cốt bê tông dự ứng lực – Phần 4: Dảnh_
TCVN 6284-5:1997 (ISO 6934-5:1991), _Thép cốt bê tông dự ứng lực – Phần 5: Thép thanh cán nóng có hoặc không xử lý tiếp_
TCVN 6288:1997 (ISO 10544:1992), _Dây thép vuốt nguội để làm cốt bê tông và sản xuất lưới thép hàn làm cốt_
TCVN 8163:2009, _Thép cốt bê tông – Mối nối bằng ống ren_
TCVN 8590-1:2010 (ISO 4301-1:1986), _Cần trục – Phân loại theo chế độ làm việc – Phần 1: Yêu cầu chung_
TCVN 9362:2012, _Tiêu chuẩn thiết kế nền nhà và công trình_
TCVN 9379:2012, _Kết cấu_ xây _dựng và nền – Nguyên tắc cơ bản về tính toán_
TCVN 9386:2012, _Thiết kế công trình chịu động đất_
TCVN 9390:2012, _Thép cốt bê tông – Mối nối bằng dập ép ống – Yêu cầu thiết kế, thi công và nghiệm thu_
TCVN 12251:2018, _Bảo vệ chống ăn mòn cho kết cấu xây dựng_
GOST 13015-2012 _, Concrete and reinforced concrete products for construction. General technical requirements. Rules for acceptance, marking, transportation and storage (Các sản phẩm bê tông và bê tông cốt thép cho xây dựng – Yêu cầu kỹ thuật chung – Nguyên tắc nghiệm thu, ghi nhãn, vận chuyển và bảo quản)_

# Thuật ngữ, định nghĩa và ký hiệu

## Thuật ngữ và định nghĩa

Tiêu chuẩn này sử dụng các thuật ngữ và định nghĩa sau:

### Các đặc trưng tiêu chuẩn của các tính chất vật lý của vật liệu (normative characteristics of physical properties of materials)

Các giá trị của các đặc trưng vật lý của vật liệu được quy định trong các tiêu chuẩn hoặc yêu cầu kỹ thuật và được kiểm soát trong quá trình chế tạo, thi công và khai thác sử dụng công trình xây dựng.

### Các hệ số độ tin cậy (partial factors)

Các hệ số kể đến các sai lệch bất lợi có thể có của các giá trị tải trọng, các đặc trưng vật liệu và sơ đồ tính toán công trình xây dựng do điều kiện sử dụng thực tế của nó, cũng như kể đến mức độ tầm quan trọng của các công trình xây dựng. Có 4 loại hệ số độ tin cậy: hệ số độ tin cậy về tải trọng; hệ số độ tin cậy về vật liệu, hệ số điều kiện làm việc, hệ số độ tin cậy về tầm quan trọng của công trình.

### Cấp độ bền (cấp cường độ) chịu kéo của bê tông, Bt (grade of tensile strength of concrete)

Giá trị được kiểm soát nhỏ nhất của cường độ chịu kéo tức thời, tính bằng megapascan (MPa), với xác suất đảm bảo không dưới 95 %, được xác định trên các mẫu thử kéo chuẩn đã được chế tạo, dưỡng hộ trong điều kiện tiêu chuẩn và thử kéo ở tuổi 28 ngày.

CHÚ THÍCH: Mẫu thử chuẩn để xác định cường độ chịu kéo dọc trục có kích thước tiết diện ngang (150 × 150) mm (tham khảo tiêu chuẩn liên quan).

### Cấp cường độ chịu kéo của cốt thép (grade of tensile strength of steel)

Giá trị được kiểm soát nhỏ nhất của giới hạn chảy thực tế hoặc quy ước (bằng giá trị của ứng suất ứng với độ giãn dài dư tương đối 0,1 % hoặc 0,2 %) với xác suất đảm bảo không nhỏ hơn 0,95, tính bằng megapascan (MPa).

### Cấp độ bền (cấp cường độ) chịu nén của bê tông, B (grade of compressive strength of concrete)

Giá trị được kiểm soát nhỏ nhất của cường độ chịu nén tức thời, tính bằng megapascan (MPa), với xác suất đảm bảo không dưới 95 %, được xác định trên các mẫu lập phương chuẩn đã được chế tạo, dưỡng hộ trong điều kiện tiêu chuẩn và thử nén ở tuổi 28 ngày.

CHÚ THÍCH: Mẫu lập phương chuẩn để xác định cường độ chịu nén có kích thước (150×150×150) mm.

### Chiều cao làm việc của tiết diện (effective depth of cross section)

Khoảng cách từ biên chịu nén của cấu kiện đến trọng tâm của cốt thép dọc chịu kéo.

### Cốt thép chịu lực (load-bearing reinforcement)

Cốt thép được bố trí theo tính toán.

### Cốt thép cấu tạo (constructive reinforcement)

Cốt thép được bố trí theo các yêu cầu về cấu tạo mà không cần tính toán.

### Cốt thép hạn chế biến dạng ngang (confinement reinforcement)

Cốt thép ngang dùng để gia cường các vị trí cần tăng độ bền, tăng khả năng chống nứt.

### Cốt thép ứng suất trước (prestressing steel)

Cốt thép được ứng suất trước trong quá trình chế tạo kết cấu trước khi ngoại lực tác dụng trong gian đoạn khai thác sử dụng.

### Cường độ (strength)

Tính chất cơ học của vật liệu, chỉ khả năng chịu được các tác động, thường được tính bằng đơn vị của ứng suất.

### Điểu kiện sử dụng bình thường (serviceability)

Điều kiện sử dụng các công trình xây dựng phù hợp với các điều kiện đã quy định trong các tiêu chuẩn hoặc nhiệm vụ thiết kế, bao gồm cả bảo dưỡng (bảo trì), sửa chữa lớn và sửa chữa nhỏ.

### Độ bền (resistance)

Khả năng của một cấu kiện hoặc của tiết diện ngang cấu kiện, chịu được các tác động mà không bị phá hoại về cơ học, ví dụ khả năng chịu uốn, khả năng chịu kéo, khả năng chống mất ổn định.

### Độ bền lâu (durability)

Khả năng của công trình xây dựng bảo toàn được các tính chất độ bền, vật lý và các tính chất khác đã được quy định trong thiết kế và đảm bảo cho công trình xây dựng sử dụng bình thường trong suốt thời hạn sử dụng theo thiết kế.

### Độ thấm của bê tông (penetrability of concrete)

Tính chất của bê tông cho phép khí hoặc chất lỏng thấm qua khi có gradient áp lực (được biểu thị bằng mác chống thấm nước W) hoặc đảm bảo độ thấm khuyếch tán các chất hòa tan trong nước khi không có gradient áp lực (được biểu thị bằng các đại lượng quy định về mật độ dòng điện và hiệu điện thế).

### Hàm lượng cốt thép, _μ_ (reinforcement percentage)

Tỉ số giữa diện tích tiết diện cốt thép và diện tích làm việc của tiết diện bê tông, tính bằng phần trăm.

### Kết cấu bê tông (concrete structure)

Kết cấu được làm từ bê tông không cốt thép hoặc có cốt thép đặt theo cấu tạo và không được kể đến trong tính toán; nội lực gây bởi tất cả các tác động trong kết cấu bê tông đều do bê tông chịu.

### Kết cấu bê tông cốt thép (reinforced concrete structure)

Kết cấu được làm từ bê tông với cốt thép chịu lực và cốt thép cấu tạo; nội lực gây bởi tất cả các tác động trong kết cấu bê tông cốt thép do bê tông và cốt thép chịu lực cùng chịu.

### Kết cấu dạng khối (massive structure)

Kết cấu mà có tỉ số diện tích bề mặt hở để khô, tính bằng mét vuông (m2), và thể tích của nó, tính bằng mét khối (m3), không lớn hơn 2.

### Khả năng chịu lực (load bearing capacity)

Hệ quả tác động lớn nhất xuất hiện trong công trình xây dựng mà không vượt quá các trạng thái giới

hạn.

### Khối lượng thể tích của bê tông (density of concrete)

Đặc trưng của bê tông, tính bằng tỉ số giữa khối lượng và thể tích của nó, được biểu thị bằng mác khối lượng thể tích trung bình D.

### Lớp bê tông bảo vệ (concrete cover)

Chiều dày lớp bê tông tính từ biên (mép) cấu kiện đến bề mặt gần nhất của thanh cốt thép.

### Mác chống thấm nước của bê tông, W (watertightness mark of concrete)

Chỉ tiêu thấm nước của bê tông, được xác định bằng áp lực nước lớn nhất, mà khi đó trong các điều kiện thử nghiệm tiêu chuẩn, nước không thấm qua mẫu thử bê tông, đơn vị tính bằng một trên megapascan (MPa-1).

CHÚ THÍCH: Mẫu trụ tròn để thử độ chống thấm nước nêu trong TCVN 3116:1993 có đường kính 150 mm và chiều cao 150 mm.

### Mác khối lượng thể tích trung bình, D (mark of density)

Giá trị khối lượng thể tích trung bình, tính bằng kilôgam trên mét khối (kg/m3).

### Mác tự ứng suất của bê tông Sp (self-stressing mark of concrete)

Giá trị ứng suất trước trong bê tông, tính bằng megapascan (MPa), do bê tông tự trương nở với hàm lượng cốt thép dọc _μ_ = 0,01.

CHÚ THÍCH: Mẫu thử chuẩn để xác định tự ứng suất của bê tông là mẫu lăng trụ có kích thước (100 × 100 × 400) mm hoặc (50 × 50 × 200) mm.

### Mô hình biến dạng phi tuyến (nonlinear deformation model)

Mô hình biến dạng phi tuyến của vật liệu bê tông và cốt thép.

### Mối nối chồng cốt thép (overlap connection of reinforcement)

Liên kết không hàn các thanh cốt thép theo chiều dài của chúng bằng cách kéo dài một đầu của một thanh cốt thép so với đầu kia.

### Mối nối cơ khí cốt thép (mechanical connection of reinforcement)

Mối nối các thanh thép bằng các ống nối chuyên dụng để đảm bảo truyền lực từ thanh này sang thanh kia.

### Neo cốt thép (reinforcement anchorage)

Sự đảm bảo cho cốt thép chịu được nội lực tác dụng lên nó bằng cách kéo dài nó thêm một đoạn tính từ tiết diện tính toán hoặc bằng cách bố trí chi tiết neo đặc biệt ở các đầu của nó.

### Nội lực giới hạn (ultimate internal force)

Nội lực lớn nhất mà cấu kiện, tiết diện của nó, với các đặc trưng đã chọn của vật liệu, có thể chịu được.

### Sơ đồ tính toán, mô hình tính toán (structural model)

Mô hình hệ kết cấu được sử dụng khi tính toán.

### Tiết diện nghiêng (inclined cross section)

Tiết diện của cấu kiện mà mặt phẳng của tiết diện nằm nghiêng với trục dọc cấu kiện và vuông góc với mặt phẳng thẳng đứng chứa trục dọc cấu kiện.

### Tiết diện thẳng góc (normal cross section)

Tiết diện của cấu kiện mà mặt phẳng tiết diện vuông góc với trục dọc cấu kiện.

### Trạng thái giới hạn (limit state)

Trạng thái mà khi vượt quá các thông số đặc trưng của nó thì việc sử dụng kết cấu hoặc là không được phép, hoặc bị gây khó khăn hoặc không còn phù hợp.

### Tự ứng suất của bê tông (self-stress of concrete)

Ứng suất nén xuất hiện trong bê tông của kết cấu khi đóng rắn do đá xi măng trương nở trong điều kiện bị cản trở sự trương nở này, được biểu thị bằng mác tự ứng suất Sp.

### Xác suất đảm bảo (probability)

Xác suất có lợi của một giá trị đại lượng ngẫu nhiên. Ví dụ, đối với tải trọng thì “xác suất đảm bảo” là xác suất không bị vượt của một giá trị cho trước; đối với các đặc trưng vật liệu thì “xác suất đảm bảo” là xác suất của các giá trị lớn hơn hoặc bằng giá trị cho trước.

## Ký hiệu

### Nội lực trong tiết diện ngang của cấu kiện do tải trọng và tác động ngoài _M_

M: Mô men uốn (Nm);

p: Mô men uốn có kể đến mô men của lực nén trước đối với trọng tâm tiết diện quy đổi (Nm);

R: Lực dọc (N);

Q: Lực cắt (N);

T: Mô men xoắn (Nm).

### Các đặc trưng vị trí cốt thép dọc trong tiết diện ngang của cấu kiện

Ký hiệu cốt thép dọc:

  * Nằm trong vùng chịu kéo khi trong tiết diện có vùng chịu nén và chịu kéo do ngoại lực; Nằm ở biên chịu nén ít hơn của tiết diện khi toàn bộ tiết diện chịu nén do ngoại lực;

  * Nằm ở biên chịu kéo nhiều hơn của tiết diện khi toàn bộ tiết diện chịu kéo do ngoại lực đối với cấu kiện chịu kéo lệch tâm;

  * Nằm trong tiết diện ngang của cấu kiện khi toàn bộ tiết diện chịu kéo do ngoại lực đối với cấu kiện chịu kéo đúng tâm;


Ký hiệu cốt thép dọc:

  * Nằm trong vùng chịu nén khi trong tiết diện có vùng chịu nén và chịu kéo do ngoại lực; Nằm ở biên chịu nén nhiều hơn của tiết diện khi toàn bộ tiết diện chịu nén do ngoại lực;

  * Nằm ở biên chịu kéo ít hơn của tiết diện khi toàn bộ tiết diện chịu kéo của cấu kiện chịu kéo lệch tâm do ngoại lực.


_Lan_ Chiều dài vùng neo của cốt thép (mm);
_L p_ Chiều dài vùng truyền ứng suất trước trong cốt thép ứng suất trước vào bê tông (mm);
_L_ 0 Chiều dài tính toán của cấu kiện chịu lực nén dọc trục (mm);
_sw_ Khoảng cách cốt thép đai, đo theo chiều dài cấu kiện (mm);

  24. Chiều cao vùng chịu nén của bê tông (mm);

  25. khoảng cách từ trục trung hòa đến điểm đặt lực nén trước có kể đến mô men uốn do ngoại lực (mm);


  23. Mô men kháng uốn của tiết diện cấu kiện đối với thớ chịu kéo ngoài cùng (mm3);


|  | s |  |
| --- | --- | --- |

 

_h_ 0 ;Hàm lượng cốt thép thanh, được xác định bằng tỉ số giữa diện tích tiết diện của cốt thép _S_ và diện tích tiết diện ngang của cấu kiện ( _b h_ 0 ), không kể đến phần cánh chịu nén và chịu kéo nhô ra.

# Yêu cầu chung đối với kết cấu bê tông và bê tông cốt thép

## Tất cả các loại kết cấu bê tông và bê tông cốt thép cần phải thỏa mãn:

  * Các yêu cầu về an toàn;

  * Các yêu cầu về điều kiện sử dụng bình thường; Các yêu cầu về độ bền lâu;

  * Các yêu cầu bổ sung nêu trong nhiệm vụ thiết kế.


## Để thỏa mãn các yêu cầu về an toàn thì kết cấu cần phải có các đặc trưng ban đầu sao cho dưới các tác động tính toán khác nhau trong quá trình xây dựng và sử dụng nhà và công trình loại trừ được sự phá hoại bất kỳ đặc điểm nào hoặc sự vi phạm điều kiện sử dụng bình thường làm hại cho cuộc sống hoặc sức khỏe của người, tài sản, môi trường xung quanh, cuộc sống và sức khỏe của động vật và thực vật.

## Để thỏa mãn các yêu cầu về điều kiện sử dụng bình thường thì kết cấu cần phải có các đặc trưng ban đầu sao cho dưới các tác động tính toán khác nhau không xảy ra sự hình thành hoặc mở rộng vết nứt quá mức, cũng như không xảy ra chuyển vị quá mức, dao động và các hư hỏng khác làm khó khăn cho việc sử dụng bình thường (vi phạm các yêu cầu về hình dạng bên ngoài của kết cấu, các yêu cầu công nghệ về sự làm việc bình thường của các thiết bị, cơ cấu, các yêu cầu cấu tạo về sự làm việc đồng thời của các cấu kiện và các yêu cầu khác đặt ra khi thiết kế).

Trong các trường hợp cần thiết thì kết cấu cần phải có các đặc trưng đảm bảo được các yêu cầu về cách nhiệt, cách âm, bảo vệ sinh học và các yêu cầu khác.

Các yêu cầu không được có vết nứt được đề ra đối với:

  * Các kết cấu bê tông cốt thép, mà trong đó khi toàn bộ tiết diện của chúng là chịu kéo thì độ không thấm vẫn cần được đảm bảo (các kết cấu chịu áp lực chất lỏng hoặc khí, các kết cấu chịu tác động phóng xạ và các kết cấu tương tự);

  * Các kết cấu đặc thù mà có yêu cầu nâng cao về độ bền lâu;

  * Các kết cấu làm việc trong môi trường xâm thực trong các trường hợp nêu trong [SP 28.13330.2012.](normacs://normacs.ru/10573?dob=41365.000012&dol=41410.711586)


Trong các kết cấu bê tông còn lại thì cho phép hình thành các vết nứt và đối với chúng phải có các yêu cầu hạn chế chiều rộng vết nứt.

## Để thỏa mãn các yêu cầu về độ bền lâu thì kết cấu cần phải có các đặc trưng ban đầu sao cho trong suốt khoảng thời gian dài đã được thiết lập, nó sẽ vẫn thỏa mãn các yêu cầu về an toàn và điều kiện sử dụng có kể đến ảnh hưởng của các tác động tính toán khác nhau (tác dụng dài hạn của tải trọng, các tác động bất lợi của khí hậu, công nghệ, nhiệt độ và độ ẩm, tác động xâm thực, v.v…) đến các đặc trưng hình học của kết cấu và các đặc trưng cơ học của vật liệu.

## Sự an toàn, điều kiện sử dụng, độ bền lâu của kết cấu bê tông và bê tông cốt thép và các yêu cầu khác đặt ra trong nhiệm vụ thiết kế cần được đảm bảo bởi việc thực hiện:

Các yêu cầu đối với bê tông và các thành phần của nó;

  * Các yêu cầu đối với cốt thép;

  * Các yêu cầu đối với tính toán kết cấu;

  * Các yêu cầu cấu tạo;

  * Các yêu cầu công nghệ;

  * Các yêu cầu sử dụng.

  * Các yêu cầu về tải trọng và tác động, giới hạn chịu lửa, độ không thấm nước, các giá trị giới hạn của biến dạng (độ võng, chuyển vị, biên độ dao động), về các giá trị tính toán của nhiệt độ không khí bên ngoài và độ ẩm tương đối của môi trường xung quanh, về bảo vệ kết cấu chịu tác động của môi trường xâm thực và các yêu cầu khác được quy định trong các tiêu chuẩn tương ứng (TCVN 2737:1995, Phụ lục M của tiêu chuẩn này, TCVN 9386:2012, TCVN 12251:2018, TCVN 9362:2012 và các tiêu chuẩn liên quan khác).


## Khi thiết kế kết cấu bê tông và bê tông cốt thép, độ tin cậy của các kết cấu được quy định trong TCVN 9379:2012 theo phương pháp tính toán bán xác suất bằng cách sử dụng các giá trị tính toán của tải trọng và tác động, các đặc trưng tính toán của bê tông và cốt thép (hoặc thép kết cấu), được xác định với các hệ số độ tin cậy (an toàn) riêng tương ứng của các giá trị tiêu chuẩn của các đặc trưng này, có kể đến mức độ tầm quan trọng của nhà và công trình.

Giá trị tiêu chuẩn của tải trọng và tác động, giá trị của hệ số độ tin cậy (an toàn) riêng về tải trọng, hệ số độ tin cậy về chức năng của kết cấu, cũng như sự phân loại tải trọng thành thường xuyên và tạm thời (dài hạn và ngắn hạn) được quy định trong các tiêu chuẩn tương ứng đối với kết cấu xây dựng (TCVN 2737:1995 và các tiêu chuẩn khác).

Giá trị tính toán của tải trọng và tác động lấy phụ thuộc vào trạng thái giới hạn tính toán và trường hợp tính toán.

Mức độ tin cậy của các giá trị tính toán của các đặc trưng vật liệu được quy định phụ thuộc vào trường hợp tính toán và vào nguy cơ đạt tới trạng thái giới hạn tương ứng và được điều chỉnh bằng giá trị của hệ số độ tin cậy (an toàn) về bê tông và cốt thép (hoặc thép kết cấu).

Tính toán kết cấu bê tông và bê tông cốt thép có thể được tiến hành theo giá trị độ tin cậy tiền định trên cơ sở tính toán xác suất toàn phần khi có đủ số liệu về sự biến động của các yếu tố chính trong các công thức tính toán.

# Yêu cầu đối với tính toán kết cấu bê tông và bê tông cốt thép

## Yêu cầu chung

### Tính toán kết cấu bê tông và bê tông cốt thép cần được tiến hành phù hợp với các yêu cầu của

TCVN 9379:2012 theo các trạng thái giới hạn, bao gồm:

  * Các trạng thái giới hạn thứ nhất, dẫn tới mất hoàn toàn khả năng sử dụng kết cấu;

  * Các trạng thái giới hạn thứ hai, làm khó khăn cho sử dụng bình thường hoặc giảm độ bền lâu của nhà và công trình so với thời hạn sử dụng đã dự định.


Các tính toán cần phải đảm bảo được độ tin cậy của nhà và công trình trong suốt thời hạn sử dụng của chúng, cũng như trong quá trình thi công phù hợp với các yêu cầu đề ra đối với chúng.

  * Các tính toán theo các trạng thái giới hạn thứ nhất bao gồm:

  * Tính toán độ bền;

  * Tính toán ổn định hình dạng (đối với kết cấu thành mỏng); Tính toán ổn định ví trí (lật, trượt, đẩy nổi).

  * Tính toán độ bền kết cấu bê tông và bê tông cốt thép cần được tiến hành theo điều kiện mà trong đó nội lực, ứng suất và biến dạng trong kết cấu do các tác động khác nhau có kể đến trạng thái ứng suất ban đầu (ứng suất trước, tác động nhiệt độ và tác động khác) không được vượt quá các giá trị mà kết cấu có thể chịu được.

  * Tính toán ổn định hình dạng kết cấu, cũng như ổn định vị trí (có kể đến sự làm việc đồng thời của kết cấu và nền, các tính chất biến dạng của chúng, khả năng chống trượt tại bề mặt tiếp xúc với nền và các đặc điểm riêng khác) cần được tiến hành theo các chỉ dẫn của các tiêu chuẩn áp dụng cho các loại kết cấu riêng.


Trong các trường hợp cần thiết, tùy thuộc vào loại, công năng kết cấu cần tiến hành các tính toán theo các trạng thái giới hạn liên quan đến các hiện tượng dẫn đến phải dừng sử dụng nhà và công trình (biến dạng quá mức, trượt trong các liên kết và các hiện tượng khác).

# Public_019

# Về một chiến lược Trí tuệ nhân tạo quốc gia của Viêt Nam

  * nước ta hiện nay, các thuật ngữ như “Cách mạng công nghiệp 4.0”, “Thời đại số”, “Cuộc sống số” và “Trí tuệ nhân tạo” xuất hiện khá thường xuyên trong nhiều phát biểu, bài viết trên các phương tiện thông tin đại chúng. Hầu hết hướng tới công nghiệp TTNT, tập trung vào chủ đề người máy và một số chủ đề công nghiệp TTNT khác.


TTNT được xác định là một công nghệ cho mục đích tổng thể ( _general purpose technologies_ ) vì vậy TTNT được coi là công nghệ “người cầm lái” dẫn dắt năng suất quốc gia [8]. Thủ tướng Chính phủ đã khẳng định Việt Nam cần “sớm lên đoàn tàu 4.0”13 và điều đó có nghĩa là cần thiết xây dựng một chiến lược TTNT quốc gia _**“Trí tuệ nhân tạo cùng con người vì nhân loại”**_ phù hợp nhất cho Việt Nam. Dưới đây là một khảo sát sơ bộ về chiến lược TTNT quốc gia của một số nước trên thế giới.

## Sơ lược về chiến lược Trí tuệ nhân tạo quốc gia trên thế giới

Như đã được đề cập, Hình 7 cung cấp một ước tính về lợi ích thu được từ TTNT vào năm 2030 của các quốc gia và khu vực, trong đó, Trung Quốc (7000 tỷ đô la Mỹ) và Bắc Mỹ (3700 tỷ đô la Mỹ), chiếm tới 70% lợi ích thu được từ TTNT trên thế giới [34]. Ước tính này là một trong nhiều thông số để các nước xây dựng chiến lược TTNT quốc gia. Bài viết này tập trung khảo sát chiến lược TTNT quốc gia của Mỹ, Trung Quốc, Pháp (đại diện cho Châu Âu) và một số nước có vị trí địa lý gần gũi với Việt Nam.

### Chiến lược TTNT quốc gia của Mỹ

Với lợi thế về sự phổ biến rộng rãi các công nghệ _Phân tích dữ liệu lớn_ và _Internet vạn vật_ ( _Internet of Things_ ), về độ sẵn sàng công nghệ và tiêu dùng tiên tiến, về sự sẵn có tài sản (hạ tầng tiên tiến, đầu tư mạnh, lượng lớn kỹ năng, dòng chảy nhanh dữ liệu và thông tin), nước Mỹ sớm khởi đầu mạnh mẽ và là quốc gia đầu tiên (tháng 5/2016) xây dựng Kế hoạch chiến lược TTNT quốc gia (ban hành tháng 10/2016) với mục tiêu làm cho nước Mỹ là cường quốc TTNT thế giới, và từ đó thúc đầy nền kinh tế và an ninh quốc gia của họ [29, 32]. Do khu vực tư nhân đầu tư mạnh vào TTNT với tốc độ ngày càng tăng, kế hoạch chiến lược này chọn phương thức đầu tư của Chính phủ Mỹ tập trung vào các khu vực y tế công cộng, hệ thống đô thị, phúc lợi xã hội, tư pháp hình sự, bền vững môi trường, an ninh quốc gia và khoa học cơ bản. Bảy chiến lược được xác định và hai khuyến nghị được đưa ra trong kế hoạch. Bảy chiến lược phát triển TTNT của Mỹ như sau:

  * __Chiến lược 1__. Đầu tư dài hạn cho nghiên cứu TTNT. Ưu tiên đầu tư vào thế hệ TTNT tiếp theo nhằm thúc đẩy việc khám phá và thấu hiểu TTNT làm cho Mỹ duy trì vị trí dẫn đầu thế giới về TTNT.

  * __Chiến lược 2__. Phát triển các phương pháp hiệu quả cho cộng tác con người – TTNT. Thay vì thay thế con người, hầu hết các hệ thống TTNT cộng tác với con người để đạt được hiệu năng tối ưu. Cần tiến hành nghiên cứu tạo ra sự tương tác hiệu quả giữa con người và hệ thống TTNT.

  * __Chiến lược 3__. Hiểu và giải quyết được các hệ lụy đạo đức, pháp lý và xã hội của TTNT. Công nghệ TTNT được kỳ vọng hoạt động theo các tiêu chuẩn chính thức và phi chính thức nhằm gìn giữ đồng loại của chúng ta. Cần tiến hành nghiên cứu để hiểu được ảnh hưởng đạo đức, pháp lý và xã hội của TTNT, và phát triển các phương pháp thiết kế hệ thống TTNT phù hợp với các mục đích đạo đức, pháp lý và xã hội.

  * __Chiến lược 4__. Đảm bảo an toàn và bảo mật hệ thống TTNT. Trước khi hệ thống TTNT được sử dụng rộng rãi, cần đảm bảo rằng hệ thống sẽ hoạt động an toàn và bảo mật, theo phương thức kiểm soát được, xác định tốt và hiểu rõ. Cần tiến hành các nghiên cứu tiên phong giải quyết các thách thức trong việc tạo ra hệ thống TTNT đúng đắn, có căn cứ và đáng tin cậy.

  * __Chiến lược 5__. Phát triển các tập dữ liệu và môi trường đào tạo và đánh giá về TTNT dùng chung. Độ sâu, chất lượng và độ chính xác của tập dữ liệu và nguồn lực đào tạo ảnh hưởng đáng kể đến hiệu năng TTNT. Cần nghiên cứu phát triển các tập dữ liệu và môi trường chất lượng cao cho phép truy cập có thẩm quyền vào các tập dữ liệu chất lượng cao tốt như tài nguyên đánh giá và đào tạo.

  * __Chiến lược 6__. Đo lường và đánh giá công nghệ TTNT thông qua các tiêu chuẩn và quy chuẩn. Cần cải tiến các tiêu chuẩn, quy chuẩn, bộ kiểm thử và sự tham gia của cộng đồng TTNT đối với hướng dẫn và đánh giá tiến bộ trong TTNT. Cần tiến hành các nghiên cứu bổ sung nhằm phát triển một phổ rộng rãi kỹ thuật đánh giá.

  * __Chiến lược 7__. Thấu hiểu nhu cầu về đội ngũ nghiên cứu – phát triển (NC-PT) TTNT quốc gia. Tiến bộ trong TTNT đòi hỏi một cộng đồng nhân lực nghiên cứu TTNT mạnh mẽ. Nâng cao hiểu biết về nhu cầu nhân lực NC-PT TTNT hiện tại và trong tương lai là rất cần thiết để đảm bảo sự sẵn có các chuyên gia TTNT giải quyết các khu vực NC-PT chiến lược được nêu trong bản kế hoạch.


Hai khuyến nghị về phương châm hành động để thực thi bảy chiến lược trên:

  * __Khuyến nghị 1__. Xây dựng khung triển khai NC-PT TTNT nhằm xác định được các cơ hội khoa học – công nghệ và hỗ trợ điều phối hiệu quả đầu tư ( _công và tư_ ) NC-PT TTNT, phù hợp với sáu chiến lược 1-6 trên đây,

  * __Khuyến nghị 2__. Nghiên cứu phối cảnh quốc gia để tạo dựng và duy trì một đội ngũ NC-PT TTNT lành mạnh, phù hợp với chiến lược 7 trên đây.


Hai điểm nổi bật trong bảy chiến lược và hai khuyến nghị là các khu vực tập trung đầu tư của Chính phủ Mỹ và nguồn nhân lực NC-PT TTNT cho nước Mỹ.

17

Một số dự án NC-PT TTNT do Chính phủ Mỹ tài trợ đã được khởi động, chẳng hạn Chương trình học máy suốt đời của Cơ quan dự án nghiên cứu tiên tiến quốc phòng Mỹ14. Tuy nhiên, chính quyền mới của Tổng thống Donald Trump dường như từ bỏ kế hoạch trên đây bằng cách thi hành một chính sách đầu tư TTNTkhác. Đồng thời với việc giảm đầu tư công trực tiếp cho phát triển một số khu vực TTNT, Chính phủ Mỹ sử dụng chính sách cải cách thuế để thu hồi tiền đầu tư ra nước ngoài của các công ty và cho phép các công ty dùng toàn bộ số tiền đó vào đầu tư phát triển TTNT và các công nghệ tiên tiến khác trên đất Mỹ. Chính sách này giúp một số khu vực TTNT của nước Mỹ có bước phát triển nhanh, chằng hạn như máy bay không người lái và xe tự lái [32]. Tuy nhiên, sự thay đổi chính sách như vậy cũng vấp phải sự phản đổi của một số chuyên gia hàng đầu về TTNT của Mỹ, chẳng hạn như Cựu giám đốc điều hành Google Eric Schmidt15.

### Chiến lược TTNT quốc gia của Trung Quốc

Nền công nghiệp TTNT Trung Quốc được dự báo là lớn nhất thế giới vào năm 2030 nhưng hiện vẫn ở vị trí “đuổi theo” so với Mỹ (tổng vốn đầu tư TTNT dành cho các công ty Trung Quốc giai đoạn 2012-2016 là 2,6 tỷ đô la Mỹ so với 17,2 tỷ đô la Mỹ của các công ty Mỹ; nhân lực tài năng TTNT của Trung Quốc so với Mỹ thua cả về số lượng (39 nghìn người so với 78 nghìn người), lẫn kinh nghiệm, v.v.). Với lợi thế về tài nguyên dữ liệu của quốc gia đông dân nhất thế giới (dự kiến, Trung Quốc chiếm 20% lượng 44 Zetabytes dữ liệu toàn cầu năm 2020), Chính phủ và cộng động hàn lâm – công nghiệpTrung Quốc đã chứng tỏ một quyết tâm cao trong xây dựng và thực thi chiến lược TTNT quốc gia. Một số nội dung cơ bản trong chiến lược TTNT quốc gia của Trung Quốc [5, 14, 42]:

  * Phát huy lợi thế về khối lượng dữ liệu nội tại và sự phối hợp chặt chẽ của Chính phủ và cộng động hàn lâm – công nghiệp về một lộ trình phát triển công nghiệp TTNT với tốc độ: (i) năm 2020: bắt kịp các cường quốc TTNT tiên tiến nhất thế giới (công nghiệp TTNT lõi: 22,5 tỷ đô la Mỹ, công nghiệp liên quan TTNT: 150,8 tỷ đô la Mỹ); (ii) năm 2025: trở thành một nhà lãnh đạo thế giới về TTNT (công nghiệp TTNT lõi: 60,3 tỷ đô la Mỹ, công nghiệp liên quan TTNT: 754 tỷ đô la Mỹ); (iii) năm 2030: đạt mức tiêu chuẩn quốc tế đổi mới TTNT ưu việt (công nghiệp TTNT lõi: 150,8 tỷ đô la Mỹ và công nghiệp liên quan TTNT: 1500 tỷ đô la Mỹ).

  * Sáu nhiệm vụ chính được xác định là: (i) Xây dựng một hệ thống đổi mới công nghệ

  * TTNT hợp tác mở: thiết lập một hệ thống lý thuyết cơ bản mới về TTNT, thiết lập một thế hệ mới của hệ thống công nghệ TTNT quan trọng, bố cục phối hợp nền tảng đổi mới TTNT, đẩy nhanh thu hút và ươm trồng tài năng TTNTcao cấp (đào tạo Tiến sỹ và Thạc sỹ ngành TTNT); (ii) Chăm nuôi nền kinh tế TTNT tiên tiến và hiệu quả: phát triển mạnh mẽ ngành công nghiệp TTNT mới nổi, đẩy nhanh việc thúc đẩy nâng cấp công nghiệp TTNT, phát triển mạnh mẽ các doanh nghiệp TTNT, tạo hệ sinh thái đổi mới TTNT; (ii) Xây dựng một xã hội TTNT an toàn và thuận tiện: phát triển các dịch vụ TTNT tiện lợi và hiệu quả, thúc đẩy quản trị xã hội thông minh, sử dụng TTNT cải thiện năng lực bảo mật công cộng, thúc đẩy tương tác xã hội và chia sẻ niềm tin lẫn nhau; (iv) Tăng cường sự tích hợp quân sự và dân sự trong lĩnh vực TTNT; (v) Xây dựng một hệ thống hạ tầng TTNT thông minh hiệu quả và phổ biến; (vi) Bố trí một thế hệ mới các dự án khoa học và công nghệ TTNT lớn tương lai.


  * Xác định chín lĩnh vực công nghệ TTNT gồm lĩnh vực công nghệ TTNT lõi và tám lĩnh vực công nghệ liên quan TTNT. Lĩnh vực công nghệ lõi bao gồm: (i) các nghiên cứu cơ bản như học sâu, tính toán thần kinh, hệ thống thần kinh xử lý thông tin; (ii) phát triển các phần mềm và phần cứng cơ bản như chíp, cảm biến, hệ điều hành;

3. nghiên cứu ứng dụng trong các lĩnh vực thị giác máy tính, sinh trắc học, nhận diện môi trường phức tạp, tương tác người - máy, xử lý ngôn ngữ tự nhiên, dịch máy, điều khiển thông minh và an ninh mạng. Tám lĩnh vực công nghệ liên quan TTNT gồm: (i) nền tảng dịch vụ công cộng cho tính toán; (ii) nhà thông minh; (iii) xe thông minh; (iv) các ứng dụng giao thông không người điều khiển thông minh;

5. An ninh thông minh; (vi) Ứng dụng người dùng cuối được TTNT hỗ trợ; (vii) Thiết bị neo thông minh cho con người; (viii) Người máy thông minh. Đồng thời, nhận diện bốn động cơ phát triển TTNT Trung Quốc gồm phần cứng, dữ liệu, nghiên cứu và thuật toán, hệ sinh thái TTNT thương mại.

  * Về phần cứng, Trung Quốc chủ trương bắt kịp các nước tiên tiến thế giới về sản xuất chíp và siêu máy tính. Tiếp cận của Trung Quốc là kết hợp thúc đẩy các cuộc đua tranh nội địa, khuyến khích giao dịch với các công ty nước ngoài, xây dựng siêu máy tính với việc tạo động lực cho các tập đoàn công nghệ khổng lồ và các công ty khởi nghiệp huyền thoại đầu tư vào sản xuất chíp TTNT: chip chung CPU và chip GPU ( _graphics processing unit_ ) gián tiếp cho TTNT, chíp riêng cho thuật toán học và học sâu như TPU ( _tensor processing unit_ ) của Google và FPGA ( _field-programmable gate array_ ) của Microsoft đồng thời với thiết lập các siêu máy tính.

  * Về dữ liệu, Trung Quốc chủ trương phát huy lợi thế nguồn dữ liệu kết hợp hoạt động chia sẽ dữ liệu giữa Chính phủ và các công ty, bảo hộ dòng dữ liệu xuyên biên giới với việc nâng cao sự quan tâm về quyền riêng tư trong các ứng dụng TTNT dựa trên tiêu chuẩn hóa các ngành công nghệ liên quan TTNT và tăng cường thảo luận quốc gia cho quan điểm bảo vệ quyền riêng tư dữ liệu mạnh mẽ hơn chống lại việc lợi dụng thái quá tự do hóa dữ liệu vào kinh doanh TTNT.

  * Về nghiên cứu và phát triển thuật toán, Trung Quốc tăng tốc hoạt động đào tạo và thu hút tài năng TTNT, kết hợp các biện pháp hỗ trợ nghiên cứu cơ bản thu hút và đào tạo tài năng (đặc biệt các tài năng TTNT hàng đầu thế giới) với khuyến khích các công ty công nghệ khổng lồ (Baidu, Huawei , Alibaba, Tencent, iFlyTek, v.v.) thành lập các viện nghiên cứu TTNT ở nước ngoài để tuyển dụng tài năng TTNT, khắc phục hạn chế công bố khoa học về TTNT (tuy nhiều về số lượng, nhưng yếu về tác động ảnh hưởng).


  * Về xây dựng hệ sinh thái TTNT thương mại, Chính phủ Trung Quốc đầu tư hơn một tỷ đô la Mỹ cho các công ty khởi nghiệp trong nước, đồng thời hướng dẫn các chính quyền địa phương và các tập đoàn nhà nước thu hút đầu tư tư nhân để thành lập các quỹ ( _government guidance funds:_ GGF) tài trợ các dự án TTNT khai thác khối lượng dữ liệu khổng lồ từ một quy mô dân số, tích hợp mục tiêu TTNT của công ty vào mục tiêu chiến lược TTNT của đất nước.


### Chiến lược TTNT của nước Pháp

Châu Âu đi sau Bắc Mỹ và Trung Quốc trong xây dựng chiến lược TTNT [16, 31, 41]. Do Đức tập trung vào Công nghiệp 4.0 và Anh tập trung cho việc rời khởi Liên minh châu Âu, cho nên sự kiện Tổng thống Pháp Emmanuel Macron công bố chiến lược “ _lãnh đạo TTNT_ ” quốc gia của nước Pháp với vốn đầu tư 1,5 tỷ Euro của Chính phủ Pháp trong năm năm 2018-2022 được nhìn nhận như đại diện cho chiến lược TTNT quốc gia của châu Âu. Tuyên bố của Tổng thống Pháp về chiến lược TTNT là tóm tắt các điểm chính của Báo cáo chiến lược TTNT của Pháp và Châu Âu dài 154 trang do Cédric Villani (nhà toán học Pháp được giải thưởng Fields năm 2010 và là một nghị sỹ Pháp) và cộng sự xây dựng. Bảy nội dung chính trong báo cáo nói trên là:

  * Xây dựng một chính sách dữ liệu tích cực: khuyến khích các công ty cùng tạo lập và chia sẻ dữ liệu, tạo lập dữ liệu được xã hội quan tâm, hỗ trợ quyền sao lưu dữ liệu.

  * Bốn khu vực TTNT chiến lược trọng tâm là y tế, giao thông, môi trường, quốc phòng và an ninh: tiến hành các chính sách riêng theo từng khu vực chiến lược hướng vào các vấn đề chính, tạo nền tảng đặc thù khu vực, kiểm tra vùng đổi mới cho mỗi khu vực.

  * Thúc đẩy lợi thế tiềm năng nghiên cứu TTNT của Pháp: thành lập các tổ chức TTNT liên ngành tại các trường đại học và viện nghiên cứu được chọn lựa, phân bổ nguồn lực phù hợp dành cho nghiên cứu (bao gồm một siêu máy tính được thiết kế riêng cho ứng dụng TTNT với sự hợp tác của nhà sản xuất), tăng độ hấp dẫn với nghề nghiệp nghiên cứu công nhờ thúc đẩy sự hấp dẫn của Pháp đối với tài năng xuất ngoại hoặc nước ngoài: tăng số lượng thạc sĩ và sinh viên tiến sĩ nghiên cứu TTNT, tăng lương cho nhà nghiên cứu và tăng cường trao đổi hàn lâm–công nghiệp.

  * Lập kế hoạch ứng phó tác động của công nghệ TTNT tới người lao động: thiết lập phòng thí nghiệm công về chuyển đổi công việc, phát triển nghiên cứu về sự bổ trợ của máy móc tới con người, đánh giá phương pháp tài trợ mới cho đào tạo nghề,

  * Nâng cao tính thân thiện môi trường của công nghệ TTNT: xây dựng trung tâm nghiên cứu về TTNT với hệ sinh thái (bao gồm đo lường tác động của các công cụ TTNT tới môi trường), giảm thiểu năng lượng cho sử dụng TTNT (bao gồm hỗ trợ chuyển đổi hệ sinh thái từ công nghiệp tính toán đám mây châu Âu), chuyển đổi hệ sinh thái song hành với độ tự do dữ liệu hệ sinh thái.


  * Đảm bảo tính minh bạch của công nghệ TTNT: Phát triển tính minh bạch và kiểm toán thuật toán, lưu ý trách nhiệm của các tác nhân TTNT liên quan tới đe dọa đạo đức, thành lập ủy ban đạo đức tư vấn cho các công nghệ số và TTNT với trách nhiệm tổ chức các tranh luận công khai về đạo đức TTNT, đảm bảo nguyên tắc trách nhiệm là của con người (đặc biệt khi công cụ TTNT dùng trong dịch vụ công).

  * Đảm bảo TTNT hỗ trợ tính đa dạng và không bị loại trừ xã hội: đảm bảo phụ nữ chiếm 40% số người tham dự các khóa học kỹ thuật số vào năm 2020, sửa đổi thủ tục hành chính và nâng cao kỹ năng hòa giải, hỗ trợ cải tiến xã hội dựa trên TTNT.


Sự phát triển thị trường dữ liệu với tốc độ cao (vào khoảng 739 tỷ Euro năm 2020) và tiềm năng nhân lực phân tích dữ liệu (trên 10 triệu người năm 2020) của châu Âu16 là một lợi thế cho sự phát triển TTNT tại châu lục này.

### Chiến lược TTNT quốc gia của các nước Đông Á

#### Nhật Bản

Từ nay tới năm 2030, Nhật Bản luôn là nền kinh tế lớn thứ tư thế giới tính theo GDP ngang giá sức mua17. Thị trường TTNT Nhật Bản tăng trưởng nhanh từ khoảng 3.700 tỷ Yên (năm 2015) lên khoảng 87.000 tỷ Yên (năm 2030)18. Chiến lược công nghệ TTNT Nhật Bản hướng mục tiêu dẫn đầu thế giới [39] với một số nội dung đáng chú ý sau đây:

  * Hội đồng chiến lược công nghệ TTNT Nhật Bản được Chính phủ thành lập với vai trò quản lý ngành dọc năm cơ quan NC-PT quốc gia (Ba trung tâm phát triển nòng cốt là Viện CNTT-TT quốc gia ( _National Institute of Information and Communications Technology_ : NICT), Viện nghiên cứu vật lý và hóa học ( _Institute of Physical and Chemical Research_ : RIKEN), Viện Khoa học và Công nghệ Công nghiệp quốc gia ( _National Institute of Advanced Industrial Science and Technology_ : AIST)).

  * Lộ trình công nghiệp hóa TTNT tập trung ưu tiên vào ba khu vực là năng suất, chăm sóc sức khỏe – y tế, và di động theo ba giai đoạn (i) Giai đoạn 1 (tới khoảng 2020): Phát triển việc sử dụng và ứng dụng TTNT hướng dữ liệu vào các miền ứng dụng hạt giống, (ii) Giai đoạn 2 (khoảng 2020-2025): Phát triển việc sử dụng công cộng TTNT và dữ liệu vào nhiều miền mở rộng, (ii) Giai đoạn 3 (khoảng 2025-2030):


Hệ sinh thái TTNT được thiết lập dựa trên sự kết nối và trộn nhiều miền. “TTNT như một dịch vụ” (AI as a Service: AIaaS) được thực thi dọc theo nhiều miền.

  * Ba trung tâm NC-PT nòng cốt tập trung nghiên cứu ưu tiên các công nghệ TTNT tiếp xúc xã hội (nhận dạng hình ảnh, xử lý ngôn ngữ tự nhiên, nhận dạng/tổng hợp tiếng nói, dự báo) dựa trên dữ liệu đa dạng (cá nhân, thoại – hội thoại, nội khoa, lịch sử hành động và tìm kiếm, không gian sống - làm việc, bán hàng - sản xuất, giao thông, thiên nhiên, thời tiết, bản đồ - vùng đất -không gian đô thị). Chính phủ tăng đầu tư NC-PT TTNT gấp ba lần cho các công ty thuộc các trường đại học và các cơ quan NC-PT trong vòng mười năm, đồng thời, thúc đẩy tăng cường đầu tư tư nhân cho NC-PT TTNT.

  * Phát triển môi trường đảm bảo cơ hội phát triển và thu hút nguồn nhân lực TTNT (quan tâm các nhà nghiên cứu trẻ), đặc biệt thu hút nhân lực TTNT cao cấp trong và ngoài nước ở giai đoạn 1. Khuyến khích các nhà nghiên cứu TTNT tham gia tích cực tiêu chuẩn toàn cầu về TTNT. Khuyến khích sự hiểu biết về phát triển công nghệ TTNT.


####  Hàn Quốc

Tháng 5/2018, Ủy ban Công nghiệp 4.0 Hàn Quốc công bố chiến lược TTNT quốc gia với vốn đầu tư 2.200 tỷ Won nhằm mục tiêu trở thành một trong bốn cường quốc TTNT trên thế giới, thu hút được 5.000 nhân sự TTNT cao cấp, xây dựng được 160 triệu đơn vị dữ liệu TTNT [43]. Bốn giai đoạn NC-PT TTNT của Hàn Quốc tới năm 2030 như sau:

  * **Giai đoạn 1 (tới năm 2020)**. __Công nghệ lõi__ : Phát triển công nghệ hiểu âm thanh - thị


giác ngôn ngữ. __Công nghệ mở rộng__ : Hệ thống hỏi-đáp TTNT trong các lĩnh vực chuyên môn. Rút ngắn thời gian tìm kiếm thuốc mới trong ngành y tế từ năm năm xuống một năm. __Công nghệ nền__ : Phân tích thông tin phức tạp cần vận dụng hoạt động diễn giải công suất lớn. Thu hút và đào tạo 590 nhân sự TTNT cao cấp và 2.250 nhân sự TTNT phổ thông. Xây dựng được 66,7 triệu đơn vị dữ liệu thông dụng, 4,3 triệu đơn vị dữ liệu công nghiệp và 9,2 tỷ đơn vị hiểu tiếng Hàn. Mỗi năm cung cấp hỗ trợ siêu máy tính cho 300 tổ chức.

  * **Giai đoạn 2 (tới năm 2022)**. __Công nghệ lõi__ : Làm chủ lý thuyết học không giám sát, kỹ thuật tóm tắt ảnh, công nghệ theo dõi-phát hiện và dự đoán, học suy luận chức năng diễn giải (kéo dài tới 2025). __Công nghệ mở rộng__ : Hệ thống phát hiện rủi ro thời gian thực. Rút ngắn hơn một nửa chu kỳ phát triển thuốc mới trong ngành y tế (từ 15 năm xuống 7 năm). __Công nghệ nền__ : Trao đổi thông tin nhận thức giữa mạng thần kinh não bộ và mạng thần kinh TTNT và Giao diện tích hợp an toàn não bộ và máy móc (kéo dài tới 2025). Thu hút và đào tạo 1370 nhân sự TTNT cao cấp và 3600 nhân sự TTNT phổ thông. Xây dựng được 111 triệu đơn vị dữ liệu thông dụng, 48,5 triệu đơn vị dữ liệu công nghiệp và 15,3 tỷ đơn vị hiểu tiếng Hàn. Mỗi năm cung cấp hỗ trợ siêu máy tính cho 400 tổ chức

  * **Giai đoạn 3 (tới năm 2025)**. __Công nghệ lõi__ : Tiếp tục học suy luận chức năng diễn giải. Thương mại hóa chíp mạng nơ-ron nhân tạo. __Công nghệ mở rộng__ : Hệ thống hỏi – đáp bằng hình ảnh. Phát triển thuốc mới tương tích mới với từng cá thể. __Công nghệ nền__ : Trao đổi thông tin nhận thức giữa mạng thần kinh não bộ và mạng thần kinh TTNT và Giao diện tích hợp an toàn não bộ và máy móc (tiếp tục). Phát triển nhân tài có năng lực lãnh đạo TTNT tầm thế giới (kéo dài tới 2030). Tăng cường củng cố cơ sở hạ tầng nghiên cứu với hình thức hợp tác mở rộng (kéo dài tới 2030).

  * **Giai đoạn 4 (tới năm 2030)**. __Công nghệ lõi__ : Hợp tác tự chủ giữa TTNT với con người thông qua công nghệ học không giám sát. __Công nghệ mở rộng__ : Cung cấp chế phẩm thực phẩm – y tế phù hợp với từng đối tượng cụ thể. __Công nghệ nền__ : Củng cố, cải thiện khả năng nhận thức của con người thông qua ứng dụng TTNT. Phát triển nhân tài có năng lực lãnh đạo TTNT tầm thế giới (tiếp tục). Tăng cường củng cố cơ sở hạ tầng nghiên cứu với hình thức hợp tác mở rộng (tiếp tục).


Phương án đầu tư là tập trung vào các công nghệ mới, khu vực công khó thu hút đầu tư tư nhân và hỗ trợ tạo thị trường sơ khai về các lĩnh vực có sức cạnh tranh tư nhân. Phương châm thực hiện là đảm bảo năng lực kỹ thuật TTNT theo tiêu chuẩn quốc tế trong khoa học cơ bản (TTNT thế hệ mới dựa trên nền tảng khoa học nhận thức, tính toán mạng nơ-ron), về công nghệ hạ tầng chíp TTNT, tính toán hiệu năng cao TTNT, về các lĩnh vực ứng dụng theo công thức TTNT+ X (thuốc mới, nguyên liệu tương lai, ứng dụng vào công nghiệp); Thành lập Viện đào tạo sau và trên đại học về TTNT, tăng cường hỗ trợ đào tạo, NC-PT TTNT tại các trường đại học – viện nghiên cứu; xây dựng Phòng Thí nghiệm não bộ TTNT, Hub TTNT và các nền tảng hạ tầng TTNT công và tư. Công ty dẫn đầu về TTNT của Hàn Quốc là Saltlux đã nhận được vốn đầu tư 32 tỷ Won cho sản phẩm TTNT19.

#### . Đài Loan, Singapore và Malaysia

  * Chiến lược TTNT của Đài Loan (Trung Quốc)20 gồm có: (i) TTNT cho đổi mới công nghiệp: trau dồi và phù hợp tài năng theo nhu cầu đối vói năm ngành công nghiệp (máy móc thông minh, ngành y sinh, năng lượng tái tạo, công nghiệp quốc phòng, nông nghiệp mới) cho “Thung lũng Silicon châu Á” và một nền kinh tế tuần hoàn (circular economy); (ii) Trở thành một trung tâm đổi mới quốc tế về TTNT: nuôi dưỡng 100 công ty khởi nhiệp về TTNT, phát triển các cụm đổi mới TTNT quốc tế; (iii) Áp dụng các mô hình tương tự như DARPA ở Mỹ và SIP (Strategic Innovation Promotion) ở Nhật Bản đối với các dự án hoa tiêu về TTNT; (iv) Tới năm 2021, trau dồi được 1000 tài năng ưu tú về TTNT (800 người từ các trường đại học, 200 người từ các tổ chức nghiên cứu), khuyến khích các doanh nghiệp quốc tế thành lập trung tâm NC-PT về TTNT; đào tạo 10.000 người tiên phong trong ứng dụng TTNT (5.000 người qua công nghệ TTNT thực tiễn, 2.000 người qua đào tạo đa miền từ trường đại học, 2.000 nhân viên công ty, 1.000 người từ ngành khác); thu hút tài năng TTNT toàn cầu; (v) Chứng thực lĩnh vực và đồng sáng tạo theo quy định: chứng thực các lĩnh vực và dữ liệu, nghiên cứu và phân tích về các luật và quy định có liên quan.


  * Chương trình quốc gia về TTNT của Singapore21 được đầu tư 150 triệu đô la Singapore trong năm năm nhằm kết hợp năng lực TTNT mức quốc gia để thúc đẩy nền kinh tế số Singapore trong tương lai. Chương trình nhắm tới ba mục tiêu: (i) Sử dụng TTNT để giải quyết những thách thức chính tác động lớn đến xã hội và công nghiệp trong giao thông, chăm sóc sức khỏe, v.v.; (ii) Đầu tư tăng cường năng lực TTNT (hệ thống TTNT giải thích được thế hệ TTNT tiếp theo, khoa học nhận thức, đào tạo tài năng TTNT, v.v.); (iii) Cung cấp 100 dự án để thúc đẩy việc tiếp nhận và sử dụng TTNT và học máy vào các ngành công nghiệp.

  * Chính phủ Malaysia dự kiến xây dựng một Kế hoạch TTNT quốc gia là phiên bản mở rộng Kế hoạch phân tích dữ liệu lớn (Big Data Analytics: BDA) quốc gia22. Nội dung cơ bản của Kế hoạch phân tích dữ liệu lớn (PTDLL) của Malaysia là: (i) Malaysia là một trong số ít quốc gia có lộ trình có cấu trúc cho phép giải phóng đầy đủ giá trị của dữ liệu lớn; (ii) Chủ doanh nghiệp, chính quyền và công dân sẵn sàng cho tầm nhìn “Malaysia là trung tâm giải pháp PTDLL hàng đầu Đông Nam Á”; (iii) Ba sáng kiến chiến lược: Mở rộng việc sử dụng PTDLL trong khu vực tư nhân, xúc tiến việc tiếp nhận và sử dụng PTDLL trong khu vực công, xây dựng ngành công nghiệp PTDLL của Malaysia; (iv) Ba mệnh lệnh chiến lược là: phát triển đội ngũ nhà khoa học dữ liệu, giải phóng giá trị của dữ liệu mở của chính quyền, thúc đẩy đổi mới dựa trên công nghiệp đối với các trường hợp có ảnh hưởng lớn.


## Một số trao đổi về một chiến lược Trí tuệ nhân tạo quốc gia của Việt Nam

Trong bối cảnh của Việt Nam, cần thiết phải xác định rõ ràng bối cảnh, mục tiêu và các biện pháp hướng mục tiêu trong một chiến lược TTNT quốc gia như vậy. Dưới đây là một số trao đổi liên quan.

Thứ nhất, cần xác định đúng quy mô thị trường TTNT Việt Nam hiện thời và theo kỳ vọng chiến lược của một quốc gia xếp hạng 29 vào năm 2030, xếp hạng 20 vào năm 2050 tính theo GDP ngang giá sức mua trên thế giới. Tránh kỳ vọng chiến lược bị phóng đại hoặc bị hạ thấp quá mức. Hiện chưa xuất hiện một báo cáo khảo sát chính thức về quy mô thị trường TTNT Việt Nam; các báo cáo về thị trường TTNT thế giới và khu vực của các công ty khảo sát có uy tín trên thế giới chưa cho thông tin về Việt Nam. Điều đó có nghĩa là thị trường TTNT Việt Nam vẫn còn nhỏ bé. Ngoài ra, qua trao đổi với đại diện một số doanh nghiệp tại Hội nghị AI4Life-2018, chúng tôi tiếp thu được một điều là TTNT chưa thành hạng mục đầu tư của nhiều doanh nghiệp Việt Nam và nếu có chỉ chiếm một phần không đáng kể. Đó là các chỉ dấu cho thấy thị trường TTNT Việt Nam hiện còn rất nhỏ và độ cam kết của các doanh nghiệp Việt Nam đóng góp vào thị trường TTNT chưa rõ ràng. Như vậy, một mặt, Việt Nam có lợi thế về vị trí địa lý kề cận với một trung tâm TTNT là Đông Bắc Á (chiếm tới 50,32% lợi ích toàn cầu từ TTNT năm 2030 theo dự báo), mặt khác, Việt Nam có hạn chế là thị trường TTNT hiện thời quá nhỏ bé. Tìm ra các biện pháp để khắc phục được hạn chế và khai thác tốt lợi thế để làm tăng trưởng nhanh thị trường TTNT nội địa và xuất khẩu, gia công sản phẩm TTNT Việt Nam có ý nghĩa đặc biệt quan trọng (ví dụ, Việt Nam là đối tác NC-PT phần mềm bên ngoài (offshore) lớn thứ hai của Nhật Bản vào năm 2016 [40]). Đối với thị trường TTNT nội địa, với vai trò vừa là người tiêu dùng lớn nhất vừa là tác nhân có trách nhiệm dẫn dắt phát triển nền kinh tế đất nước, Nhà nước ta cần là nhà đầu tư chiến lược vào những thành phần TTNT cốt lõi quốc gia, trước mắt là đầu tư xây dựng công phu một chiến lược TTNT quốc gia phù hợp nhất với Việt Nam; chiến lược đó cần bao gồm việc xác định đúng quy mô thị trường TTNT Việt Nam theo kỳ vọng và xây dựng các chính sách tạo động lực tăng cường quy mô thị trường TTNT Việt Nam tới quy mô theo kỳ vọng.

Thứ hai, cần xác định được chính xác các cơ hội và thách thức đối với sự phát triển TTNT Việt Nam. Như đã được đề cập, TTNT là một lĩnh vực hội tụ nhiều ngành thuộc nhiều lĩnh vực cho nên nhận thức về TTNT cũng như về công nghệ TTNT là rất đa dạng. Nghiên cứu của E. Brynjolfsson và cộng sự [8] về “nghịch lý năng suất hiện đại” của công nghệ (nói riêng công nghệ TTNT) cho thấy xu hướng khác biệt giữa đánh giá lạc quan của giới công nghệ và đầu tư mạo hiểm với đánh giá bi quan của giới kinh tế, xã hội học, thống kê và quan chức chính quyền. Nếu không dựa trên một khung nhìn khoa học trung thực, việc đánh giá cơ hội và thách thức đối với sự phát triển TTNT Việt Nam dễ rơi vào một trạng thái cực đoan theo một phía lạc quan hoặc bi quan trên đây.

Thứ ba, cần khảo sát, phân tích khoa học nội dung chiến lược TTNT quốc gia của các nước trên thế giới. Chiến lược phát triển TTNT quốc gia của Việt Nam cần đặt NC-PT theo mục tiêu kinh doanh của doanh nghiệp có mục tiêu ngắn hạn vào tổng thể nghiên cứu cơ bản theo mục tiêu chiến lược phát triển đất nước dài hạn của Nhà nước23. Nền tảng khoa học cơ bản là rất quan trọng trong xây dựng chiến lược TTNT quốc gia. Chiến lược TTNT quốc gia cũng cần xây dựng được các chính sách thúc đẩy sự chung tay đầu tư của doanh nghiệp Việt Nam cho một thị trường kinh tế số (nói chung) và thị trường TTNT (nói riêng) bền vững, đồng thời, cần giảm thiểu tác động từ cách tiếp cận theo mục tiêu kinh doanh ngắn hạn của doanh nghiệp tới chiến lược quốc gia và chính sách Nhà nước. Phát huy lợi thế ổn định chính trị vào việc giảm thiểu nhanh chóng tiến tới triệt tiêu bốn nguyên nhân dẫn đến sự trì trệ của đất nước đã được Thủ tướng Chính phủ nhận diện (chưa tuân thủ đúng tinh thần kinh tế thị trường định hướng xã hội chủ nghĩa; kỷ cương phép nước chưa nghiêm; tham nhũng, tiêu cực, lợi ích nhóm còn xảy ra trầm trọng, kéo dài; bệnh quan liêu, xa dân)24 và ngăn ngừa hiện tượng lạm dụng tiếp cận cơ hội kinh doanh của doanh nghiệp vào hoạt động quản lý Nhà nước. Trong mọi trường hợp, một nhận thức đúng đắn về TTNT, về công nghiệp TTNT, về điều kiện cụ thể của đất nước và bối cảnh quốc tế để hiểu biết đúng và phát huy thế mạnh, để giảm thiểu và khắc phục hạn chế là những yếu tố cốt lõi tiên quyết cho xây dựng và thực hiện thành công chiến lược phát triển TTNT quốc gia và nền kinh tế số Việt Nam.

Thứ tư, cần quan tâm tới năng lực hội nhập toàn cầu của các doanh nghiệp Việt Nam, đặc biệt là các doanh nghiệp vừa và nhỏ. Một tỷ lệ lớn các doanh nghiệp Việt Nam chuyên cung cấp nguyên, vật liệu gốc trong các chuỗi cung ứng toàn cầu. Một chiến lược TTNT doanh nghiệp về phân tích dữ liệu hiệu quả nhằm làm giảm thiểu hoặc triệt tiêu tác động của hiệu ứng Bullwill (lỗi dự báo nhu cầu và yêu cầu người dùng bị khuyếch đại) và thực sự đưa doanh nghiệp Việt Nam trở thành một đối tác trong chuỗi (mạng) cung ứng toàn cầu sẽ giúp doanh nghiệp Việt Nam kinh doanh bền vững trong thời đại số ngày nay. Về mặt quản lý, doanh nghiệp cần quan tâm tới ba thách thức (i) Phát triển một hiểu biết trực tiếp về TTNT; (ii) Cấu trúc tổ chức phù hợp với TTNT; (iii) Đổi mới tư duy về bối cảnh cạnh tranh. Mỗi doanh nghiệp cần tìm được một chiến lược TTNT riêng phù hợp nhất với mình. Đối với Việt Nam, các nhà quản lý trong các khu vực khác nhau trong doanh nghiệp cần phải hiểu được các nguyên tắc cơ bản của công nghệ TTNT để có năng lực tiếp nhận và sử dụng được hiệu quả từ các đòn bẩy từ công nghệ TTNT tới việc ra quyết định tốt hơn trong mọi khu vực của doanh nghiệp là một điều kiện có tầm quan trọng đặc biệt. Andrew Ng, nhà khoa học trưởng của Baidu Trung Quốc giai đoạn 2014-2017, nhận định rằng học sâu là nhiệm vụ của con người, không chỉ là của máy móc25. Như thế có nghĩa là, các nhà quản lý ở mọi khu vực kinh doanh của doanh nghiệp là chủ thể chính tiếp nhận và sử dụng hiệu quả đòn bẩy từ khoa học dữ liệu (và TTNT) để ra quyết định tốt hơn trong mọi khu vực của doanh nghiệp26. Điều này có nghĩa là chiến lược TTNT quốc gia của Việt Nam cần bao gồm hoạt động đào tạo và tự đào tạo nâng cao trình độ hiểu biết và ứng dụng TTNT của các nhà quản lý trong doanh nghiệp là một điều kiện có tầm quan trọng đặc biệt trong việc hình thành hệ sinh thái công nghiệp TTNT Việt Nam.

Thứ năm, nhân lực TTNT Việt Nam tài năng là một nhân tố cốt lõi đảm bảo sự thành công của phát triển TTNT và nền kinh tế số Việt Nam. Mặc dù vị thế quốc tế của toán học Việt Nam không còn cao như thời kỳ chống Mỹ cứu nước27, song tiềm năng NC-PT TTNT của lớp trẻ Việt Nam là khá khả quan. Dù còn có nghi ngại về phương thức lấy mẫu, song kết quả đánh giá PISA hai đợt của Việt Nam (năm 2012 và năm 2015) được Tổ chức Hợp tác và Phát triển kinh tế thế giới (The Organisation for Economic Co-operation and Development: OECD) ghi nhận tích cực28. Về kỹ năng lập trình, từ 2007 tới nay, thường xuyên có các đội tuyển sinh viên Việt Nam vượt qua các vòng đấu loại quốc tế (có sự tham gia của hàng nghìn trường đại học trên thế giới) để được tham dự vòng chung kết toàn cầu cuộc thi lập trình sinh viên ACM/ICPC; ở khu vực Đông Nam

  * chỉ có Singapore có được kết quả như vậy. Trường Đại học Công nghệ (ĐHQGHN), Trường Đại học Khoa học Tự nhiên (ĐHQG Thành phố Hồ Chí Minh), Trường Đại học Bách khoa (ĐHQG Thành phố Hồ Chí Minh), Trường Đại học PFT là các trường đại học có các đội tuyển như vậy, trong đó dẫn đầu là Trường Đại học Công nghệ (ĐHQGHN) với bảy lần (2007-2009, 2015-2018) tham dự vòng thi chung kết toàn cầu ACM/ICPC và ở khu vực Đông Nam Á thì chỉ có Đại học Quốc gia Singapore và Đại học Công nghệ Nanyang (Singapore) có được thành công như vậy. Hơn nữa, đội tuyển sinh viên của Trường Đại học Công nghệ (ĐHQGHN) nhiều năm đạt thứ hạng cao, sánh ngang với các trường đại học công nghệ hàng đầu thế giới, chẳng hạn, đội tuyển sinh viên của Trường Đại học Công nghệ (ĐHQGHN) đạt hạng 14 vào năm 201829. Trên cơ sở khai thác các tiềm năng về khoa học và lập trình của lớp trẻ Việt Nam, đầu tư phát triển tài năng TTNT Việt Nam có chuyên môn và đạo đức tốt _không chỉ biết tạo sản phẩm TTNT mà còn đảm bảo sử dụng nó có lợi cho loài người 30_, thấm nhuần triết lý “ _TTNT cùng con người, TTNT vì nhân loại_ ”cần là một nội dung quan trọng trong chiến lược phát triển TTNT quốc gia của Việt Nam. Đầu tư ưu tiên cho phát triển tài năng TTNT cần được coi là thành phần quan trọng nhất trong đầu tư chiến lược tăng cường quy mô thị trường TTNT của Nhà nước. Cần tiến hành một nghiên cứu công phu về các khía cạnh con người, văn hóa, lịch sử, xã hội, đặc biệt là các khía cạnh chính sách và quản lý để tìm ra nguyên nhân làm cho hệ thống giáo dục đại học Việt Nam không đạt mức đặc biệt hiệu quả hơn hẳn hệ thống Bắc Mỹ ở một số phương diện của các hệ thống giáo dục đại học Hàn Quốc, Trung Quốc, Đài Loan, Hồng Kông, Singapore dù có cùng một gốc rễ giáo dục dân tộc “nho giáo”[26]. Xây dựng chương trình đào tạo chuyên TTNT và các chương trình đào tạo liên ngành có liên quan tới TTNT. Chương trình đào tạo cần quan tâm tới các khối kiến thức toán học, khoa học máy tính, điều khiển học cùng một số kiến thức khoa học cơ bản khác (bao gồm kiến thức khoa học xã hội và nhân văn) để cung cấp một nền tảng khoa học cốt lõi phát triển các mô hình và thuật toán TTNT độc đáo. Phân tích toán học để hiểu sâu hơn cơ chế nền tảng của mạng nơ-ron học sâu là rất quan trọng không chỉ để cải thiện hiệu năng của mạng mà quan trọng hơn là để đảm bảo triển khai một cách có trách nhiệm các ứng dụng có ảnh hưởng xã hội [10, 17]; điều đó cho thấy tầm quan trọng đặc biệt của kiến thức khoa học cơ bản trong việc phát triển nhân lực TTNT tài năng.


# Kết luận

Trong thời đại số ngày nay, dù tiềm ẩn một số thách thức như làm gia tăng tình trạng bất bình đẳng xã hội và đe dọa đời sống con người nhưng TTNT được coi là một công nghệ “người cầm lái” dẫn dắt năng suất quốc gia và mang tới các cơ hội lớn cho mọi người, mọi tổ chức và mọi quốc gia. Theo một dự báo được thừa nhận rộng rãi, lợi ích từ TTNT sẽ đóng góp tới 15.700 tỷ đô la Mỹ và chiếm 14% GDP danh nghĩa toàn cầu vào năm 2030.

Nhận thức đúng đắn và đầy đủ về NC-PT TTNT theo triết lý “ _TTNT cùng con người, TTNT vì nhân loại_ ”, tập trung phát triển các khu vực TTNT có lợi thế là những đặc trưng cốt lõi của chiến lược TTNT quốc gia của nhiều nước trên thế giới. Chú trọng phát triển đội ngũ nhân lực TTNT tài năng, tăng cường phát triển các công nghệ TTNT lõi (đặc biệt là các thuật toán học máy và công nghệ dữ liệu lớn), triển khai công nghệ TTNT phục vụ cộng đồng, mở rộng hệ sinh thái TTNT thương mại và nâng cao đạo đức TTNT là những nội dung nổi bật trong chiến lược TTNT quốc gia của không chỉ các nước siêu cường kinh tế mà còn các nước khác.

Phát huy lợi thế về ổn định chính trị, ưu tiên đầu tư phát triển tiềm năng nhân lực về khoa học và lập trình, khai thác lợi thế có vị trí địa lý kề cận một khu vực tiềm năng có lợi ích từ TTNT lớn nhất thế giới, khắc phục hạn chế về thị trường TTNT nội địa còn nhỏ bé cần là một số giải pháp trong một chiến lược TTNT quốc gia của Việt Nam.

Chúng ta tin tưởng vào tương lai công nghiệp TTNT Việt Nam sẽ phát triển với tốc độ cao, góp phần xứng đáng vào sự nghiệp phát triển kinh tế - xã hội của đất nước trong thời đại số ngày nay.

# Tài liệu tham khảo

  1. Ngân hàng Thế giới (Khối Thương mại và Cạnh tranh Toàn cầu). _Việt Nam: Tăng cường_


_năng lực cạnh tranh và liên kết của doanh nghiệp vừa và nhỏ: Bài học kinh nghiệm trong nước và quốc tế_. Tài liệu 119861, Ngân hàng Thế giới, 2017.

  2. Wil M. P. van der Aalst. _Process Mining - Data Science in Action (2nd edition)_. Springer, 2016.

  3. Ajay Agrawal, Joshua Gans, Avi Goldfarb. _Prediction Machines The Simple Economics of Artificial Intelligence_. Harvard Business Review, 2018.

  4. James Barrat. _Our Final Invention Artificial Intelligence and the End of the Human Era_. Thomas Dunne Books, 2013.

  5. Dominic Barton, Jonathan Woetzel, Jeongmin Seong, Qinzheng Tian. _Artificial intelligence: Implications for China._ Report, McKinsey Global Institute, April 2017.

  6. Gaurav Batra, Andrea Queirolo, and Nick Santhanam. _Artificial intelligence: The time to_


_act is now_. Article January 2018, McKinsey.& Company. _https://www.mckinsey.com/industries/advanced-electronics/our-insights/artificial-intelligence-the-time-to-act-is-now_

  7. Bhabani Shankar Prasad Mishra, Satchidananda Dehuri, Euiwhan Kim, Gi-Name Wang. _Techniques and Environments for Big Data Analysis: Parallel, Cloud, and Grid Computing_. Springer, 2016.

  8. Erik Brynjolfsson, Daniel Rock, Chad Syverson. _Artificial Intelligence and the Modern Productivity Paradox: A Clash of Expectations and Statistics_. Working Paper 24001, 2017.

  9. Andrew Burgess. _The Executive Guide to Artificial Intelligence: How to identify and implement applications for AI in your organization_. Palgrave Macmillan, 2018.

  10. Anthony L. Caterini, Dong Eui Chang. _Deep Neural Networks in a Mathematical Framework_. Springer, 2018.

  11. Calum Chace. _Artificial Intelligence and the Two Singularities_. CRC, 2018.

  12. Clarivate Analytics. _Artificial Intelligence in Southeast Asia_. Industry Bytes, Clarivate Analytics, 2018.

  13. Francesco Corea. _Artificial Intelligence and Exponential Technologies: Business Models Evolution and New Investment Opportunities_. Springer International, 2017.

  14. Jeffrey Ding. _Deciphering China’s AI Dream: The context, components, capabilities, and consequences of China’s strategy to lead the world in AI_. Research Report, Future of Humanity Institute, University of Oxford, March 2018. _https://www.fhi.ox.ac.uk/wp-content/uploads/Deciphering_Chinas_AI-Dream.pdf_.

  15. Wolfgang Ertel, Nathanael T. Black. _Introduction to Artificial Intelligence_. Springer, 2018.

  16. European Political Strategy Center. _The Age of Artificial Intelligence: Towards a European Strategy for Human-Centric Machines_. EPSC Strategic Notes, Issue 29, 27 March 2018.

  17. Ian Goodfellow, Yoshua Bengio, Aaron Courville. _Deep Learning_. The MIT Press, 2016.

  18. M. Hilbert and P. Lopez. _The World’s Technological Capacity to Store, Communicate, and Compute Information_. Science, 332(6025): 60–65, 2011.

  19. Kai Hwang, Min Chen. _Big-Data Analytics for Cloud, IoT and Cognitive Computing_. Wiley, 2017.


  20. Fernando Iafrate. _Artificial intelligence and big data: the birth of a new intelligence._ Wiley-ISTE, 2018.

  21. IEEE Global Initiative. _Ethically Aligned Design: A Vision for Prioritizing Human Well-being with Autonomous and Intelligent Systems (Version 2 - For Public Discussion)_. IEEE's document, December 2017.

  22. Ray Kurzweil. _The Singularity Is Near: When Humans Transcend Biology_. Viking Adult, 2005.

  23. Ray Kurzweil. _How to Create a Mind - The Secret of Human Thought Revealed_. Viking Books, 2012.

  24. Tsugio Makimoto. _Implications of Makimoto's Wave_. IEEE Computer 46(12): 32-37, 2013.

  25. Tsugio Makimoto. _Chip Technologies as the Engine for IT Revolution_. COMPSAC 2015: 3.

  26. Simon Marginson. _The Confucian Model of Higher Education in East Asiaand Singapore_. In _Simon Marginson, Sarjit Kaur, Erlenawati Sawir. Higher Education in the Asia-Pacific_ , pp. 53-75, Springer, 2011.

  27. John McCarthy, M.L. Minsky, N. Rochester, C.E.Shannon. _A Proposal for the Dartmouth summer conference on artificial intelligence_. AI Magazine, 31 Aug. 1955.

  28. Bob Merritt. _The Digital Revolution_. Morgan & Claypool, 2016.

  29. National Science and Technology Council. _National Artificial Intelligence Research and Development Strategic Plan_. National Science and Technology Council of USA, October 2016.

  30. David L Poole, Alan K Mackworth. _Artificial intelligence foundations of computational agents (2nd edition)_. Cambridge University Press, 2017.

  31. Laurent Probst, Bertrand Pedersen, Virginie Lefebvre, Lauriane Dakkak. _USA-China-EU plans for AI: where do we stand?_ A report of Digital Transformation Monitor, January 2018.

  32. PwC. _2018 AI predictions 8 insights to shape business strategy_. PwC report, January 2018. _https://www.pwc.com/us/en/advisory-services/assets/ai-predictions-2018-report.pdf_

  33. S. Ransbotham, D. Kiron, P. Gerbert, và M. Reeves. _Reshaping Business With Artificial Intelligence._ MIT Sloan Management Review and The Boston Consulting Group, September 2017. Bài đi kèm “Philipp Gerbert, Martin Reeves, Sebastian Steinhäuser, and Patrick Ruwolt. _Is Your Business Ready for Artificial Intelligence?_ ” _https://www.bcg.com/publications/2017/strategy-technology-digital-is-your-business-ready-artificial-intelligence.aspx._

  34. Anand S. Rao, Gerard Verweij. _Sizing the prize: What’s the real value of AI for your business and how can you capitalise_. PwC report, 2017.

  35. Stuart Russell, Peter Norvig. _Artificial Intelligence. A Modern Approach (3rd Global Edition)_. Pearson, 2016.

  36. Ralph M. Stair, George Reynolds. _Principles of Information Systems (13thedition)_. Course Tachnology, 2018

  37. Jim Sterne. _Artificial Intelligence for Marketing: Practical Applications_. Wiley, 2017.

  38. Ion Stoica, Dawn Song, Raluca Ada Popa, David A. Patterson, Michael W. Mahoney, Randy H. Katz, Anthony D. Joseph, Michael Jordan, Joseph M. Hellerstein, Joseph Gonzalez, Ken Goldberg, Ali Ghodsi, David E. Culler, Pieter Abbeel. _A Berkeley View of_


_Systems Challenges for AI_. Technical Report No. UCB/EECS-2017-159, University of California at Berkeley, October 16, 2017.

  39. Strategic Council for AI Technology. _Artificial Intelligence Technology Strategy_. Report, Japan Strategic Council for AI Technology, 31/3/2017.

  40. Dinh Thi Quynh Van. _Vietnam has potential to become the next BPO giant_. PwC Vietnam, 22 January 2018.

  41. Cédric Villani et al. _For a Meaningful Artificial Intelligence: Towards a French and European strategy_. Mission Report, March 2018.

  42. 国务院关于印发. 新一代人工智能发展规划的通知. 国发〔2017〕35号 . 2017年7月8日（此件公开发布）. _http://www.gov.cn/zhengce/content/2017-07/20/content_5211996.htm_

  43. 4차산업혁명위원회 심의안건. 인공지능(AI) R&D 전략. 5/2018.

# Public_020

# Giới thiệu

Việc xác định độ dày của vật liệu bảo vệ chịu lửa và các vật liệu khác được sử dụng trong thử nghiệm khả năng chịu lửa là rất quan trọng để dự đoán chính xác chiều dày lớp chống cháy yêu cầu từ kết quả thử nghiệm.
Do đó, các phương pháp được sử dụng để thiết lập các đặc tính này phải nhất quán và Phụ lục này đưa ra hướng dẫn về các quy trình thích hợp được sử dụng.
Mọi mẫu thử được sử dụng để xác định độ dày phải phù hợp với mẫu thử cháy thực tế trong các điều kiện được mô tả trong Điều 8.
Các quy trình nêu trong EN 1363-1 phải được tuân thủ cùng với các yêu cầu sau.

## Chiều dày của vật liệu bảo vệ

### Chiều dày màng khô

Độ dày màng khô phải được xác định trực tiếp trên các mẫu thử nghiệm, sau khi lớp phủ được để khô hoàn toàn theo quy định của khách hàng.
Phòng thử nghiệm phải đo chiều dày bằng dụng cụ sử dụng nguyên tắc cảm ứng điện từ hoặc nguyên tắc dòng điện xoáy với đường kính tiếp xúc đầu dò ít nhất là 2,5 mm.

### Vị trí đo

Số lượng và vị trí điểm đo chiều dày (được coi là yêu cầu tối thiểu) phải như sau:

#### Dầm chịu tải

Cần thực hiện số lượng tối thiểu 88 phép đo trên các mặt cắt đo được chỉ ra trong Hình 6 và Hình 13.

  * Các mặt cắt đo nhiệt tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của dầm thử nghiệm.

  * Vị trí thực hiện phép đo nhiệt độ ở mặt trên của bản cánh dưới dầm hoặc mặt dưới của dầm rỗng, giữa mỗi mặt cắt đo nhiệt.

  * Vị trí nằm giữa các mặt cắt đo nhiệt độ ngoài cùng và giữa các điểm ngoài cùng trên mặt trên của bản cánh dưới dầm hoặc mặt dưới của dầm rỗng.


#### Dầm không chịu tải

Số lượng tối thiểu là 24 phép đo tại các vị trí trên bề mặt tiếp xúc với lửa của dầm (bản bụng và bản cánh hoặc mặt của dầm rỗng; xem Hình 12) tại các vị trí gần với.

  * Các mặt cắt đo nhiệt (cách từ 50 mm đến 100 mm) tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của dầm thử nghiệm.


#### Cột cao chịu tải

Cần thực hiện số lượng tối thiểu 50 phép đo trên các mặt cắt đo nhiệt được chỉ ra trong Hình 13 đối với cấu kiện tiết diện chữ I hoặc H và Hình 14 đối với cấu kiện có tiết diện rỗng.

  * Các mặt cắt đo nhiệt (cách từ 50 mm đến 100 mm) tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của cột thử nghiệm.

  * Các vị trí nằm giữa mỗi mặt cắt đo nhiệt.


#### Cột ngắn không chịu tải

Cần thực hiện số lượng tối thiểu 24 phép đo trên các mặt cắt đo nhiệt được chỉ ra trong Hình 13 đối với cấu kiện tiết diện chữ I hoặc H và Hình 14 đối với cấu kiện tiết diện rỗng.

  * Các mặt cắt đo nhiệt (cách từ 50 mm đến 100 mm) tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của cột thử nghiệm.


## Nhận dạng

Việc xác định lớp phủ phải phù hợp với ETAG 018-Phần 2.

Các thuộc tính của vật liệu phải được đặc trưng / nhận dạng rõ ràng (công thức).

# Lắp đặt đầu đo nhiệt vào cấu kiện thép và đi dây

## Nguyên tắc chung

Việc đo chính xác nhiệt độ thép là cơ sở cho phương pháp đánh giá. Loại đầu đo nhiệt và phương pháp gắn và lắp đặt dây dẫn, bảo vệ và kết nối với cáp nối dài hoặc phần mở rộng thích hợp phải được xem xét cẩn thận. Phụ lục này đưa ra hướng dẫn về các quy định phù hợp.

## Kiểu đầu đo nhiệt

Một vài loại khác nhau của đầu đo nhiệt được cho là phù hợp, bao gồm loại “T”, “N”, “K” và “J” như quy định trong IEC 60584-1.

Ưu tiên sử dụng đầu đo nhiệt nằm trong lớp vỏ bọc bằng thép không gỉ được cách nhiệt bằng sợi khoáng với đầu nóng được cách nhiệt. Đường kính tổng thể của lớp vỏ bọc ít nhất là 1,5 mm.

Các đầu đo nhiệt khác có thể được sử dụng với sự tham vấn giữa phòng thí nghiệm và khách hàng thử nghiệm về tính phù hợp của chúng. Các đầu đo nhiệt thích hợp phải là dạng dây đơn có đường kính tối thiểu 0,5 mm và có lớp cách nhiệt giữa 2 sợi dây và giữa mỗi sợi dây với bất kỳ vật liệu dẫn nhiệt bên ngoài sao cho không bị hỏng trong quá trình thử nghiệm.

## Lắp đặt đầu đo nhiệt

Đầu nóng của đầu đo nhiệt cần được gắn trên cấu kiện thép bằng búa hoặc phương pháp khác mà không gây ảnh hưởng đến độ nhậy và độ chính xác của đầu đo nhiệt. Không được gắn bằng vít hoặc bu lông.

Với bất kỳ phương pháp cố định nào điều cơ bản là các đầu đo nhiệt không được tiếp xúc ngoài phạm

  6. mối nối nóng được đặt ở trong hoặc tại bề mặt thép; mối nối nóng của đầu đo nhiệt phải được lắp đặt tại vị trí gần nhất với điểm nối lạnh. Đầu đo nhiệt phải được cố định để đảm bảo rằng nó vẫn phải ở đúng vị trí.


## Lắp đặt dây dẫn cho sợi dây đo nhiệt

Cần thực hiện mọi nỗ lực bất cứ khi nào có thể để đảm bảo rằng dây dẫn từ đầu nóng đi theo một đường để đến đầu lạnh mà không để nó tiếp xúc với nhiệt độ vượt quá nhiệt độ ở đầu nóng. Các dây dẫn phải được luồn ra sau vật liệu chống cháy và ra khỏi lò mà không đi qua môi trường lò.

Có thể cần thiết phải bảo vệ các sợi dây đo nhiệt bằng cách sử dụng các thanh thép C hoặc ống dẫn trước khi phủ lớp vật liệu bảo vệ. Nó được lắp đặt từ thanh thép nhẹ và được hàn điểm vào góc của bản bụng và bản cánh.

Nên xác định rằng đặc tính nhiệt độ công bố của vật liệu cách nhiệt của đầu đo nhiệt có liên quan đến đầu đo nhiệt ở trong môi trường mà các dây dẫn không được dịch chuyển hoặc có các biến dạng khác

Có thể các dây đo nhiệt sẽ cần được đỡ để đảm bảo rằng phá hoại của vật liệu cách nhiệt không xảy ra.

## Kết nối đầu đo nhiệt

Không được có mối nối giữa các dây đo nhiệt và bất kỳ phần mở rộng hoặc cáp nối dài trong bất kỳ khu vực có nhiệt độ cao.
Dây dẫn bù phải là loại phù hợp với dây dẫn nhiệt.

## Hỏng đầu đo nhiệt

Các hư hỏng của đầu đo nhiệt không dễ dàng xác định được. Hỏng do đứt dây hoặc do hỏng lớp cách nhiệt giữa các dây, do đó làm chập mối nối nóng.
Tuy nhiên các dấu hiệu hỏng rõ ràng là:

  * Sự giảm đột ngột của nhiệt độ được chỉ định so với nhiệt độ đã ghi trước đó.

  * Sự gia tăng đột ngột nhiệt độ được chỉ định đến một giá trị đại diện cho phạm vi tối đa của thiết bị đo được

  * Nhiệt độ hiển thị “thay đổi và biến động” không phù hợp với các giá trị dự báo.


Một dấu hiệu phổ biến của hỏng lớp cách nhiệt mà có thể quan sát được là giá trị nhiệt độ hiển thị không phù hợp với nhiệt độ lò thử nghiệm.

# Phương pháp thử nghiệm đối với lửa âm ỉ (đường cong nhiệt chậm)

## Giới thiệu

Các sản phẩm bảo vệ chịu lửa được hoạt động bởi thông lượng nhiệt của đám cháy có thể được yêu cầu thử nghiệm đối với đường cong âm ỉ (đường cong nhiệt chậm được định nghĩa trong ISO 834-2), với tốc độ tăng nhiệt độ nhỏ hơn tốc độ của đường cong nhiệt độ / thời gian tiêu chuẩn.

Sự tiếp xúc với lửa này, áp dụng cho các vật liệu chống cháy phản ứng, chỉ được sử dụng trong những trường hợp đặc biệt, khi có thể dự kiến rằng công năng của sản phẩm khi tiếp xúc với lửa âm ỉ kém hơn đáng kể so với khi nó được tiếp xúc với đường cong nhiệt độ / thời gian tiêu chuẩn và khi thí nghiệm này được quy định trong các quy chuẩn xây dựng quốc gia.

Quy định này không phải là bắt buộc đối với tất cả các vật liệu chống cháy áp dụng cho các cấu kiện thép kết cấu.

## Trang thiết bị thử nghiệm

Lò đốt và các thiết bị thử nghiệm nên được lựa chọn để các mẫu thử nghiệm tiếp xúc với sự gia nhiệt theo quy định trong F.5

Đường cong âm ỉ (đường cong nhiệt chậm) phải như quy định trong ISO 834-2, được cung cấp một chế độ gia nhiệt trong đó trong khoảng thời gian t = 0 phút đến 20 phút, nhiệt độ lò (T) tuân theo mối quan hệ:


| T 1544 | t | 20 | (F.1) |
| --- | --- | --- | --- |

 

![](images/image1.png)

Sau t = 20 phút và trong khoảng thời gian còn lại của thử nghiệm, nhiệt độ lò thử nghiệm (T) tuân theo mối quan hệ nhiệt độ - thời gian

# Public_021

# Mở đầu

Gần đây khi có dịp nói chuyện về xử lý ngôn ngữ (XLNN) và xử lý tiếng Việt (XLTV) trong công nghệ thông tin (CNTT) với một số nhà quản lý khoa học và công nghệ hoặc một số đồng nghiệp, chúng tôi thấy có sự khác nhau giữa nhiều người về cách hiểu một số khái niệm cũng như giữa những nhìn nhận về tình hình nghiên cứu-phát triển trong lĩnh vực này. Điều này cũng tự nhiên, tự nhiên như hầu hết chúng ta không thật rõ về bệnh tim, hay không rõ protein được tổng hợp ra như thế nào. Khi chuẩn bị dự án về xử lý tiếng Việt, chúng tôi bỗng thấy cần giải thích cho nhiều người không làm chuyên môn về xử lý ngôn ngữ rõ hơn về các câu chuyện của lĩnh vực này. Và thay vì viết ngay đề cương, chúng tôi bắt đầu các việc của dự án bằng bài viết này.

# Những khái niệm cơ bản

Tiếng nói và chữ viết là hai yếu tố cơ bản nhất của bất kỳ ngôn ngữ nào. Trong sự phát triển của công nghệ thông tin (CNTT) ở Việt Nam, một số việc liên quan đến “tiếng Việt” đã được làm và ít nhiều có kết quả ban đầu:

  * Trước hết là các _bộ gõ chữ Việt_ và thành công của việc đưa được _bộ mã chữ Việt_ vào bảng mã Unicode, cũng như việc chọn Unicode cho bộ mã chuẩn tiếng Việt (nhân đây cũng xin nói thêm, do chưa ý thức về chuẩn, rất nhiều cán bộ CNTT, nhiều cơ quan nhà nước vẫn chưa chịu đổi thói quen cũ để dùng bộ mã chuẩn Unicode, một việc rất quan trọng của xử lý tiếng Việt). Bảo tồn chữ Nôm trên máy tính cũng là một việc đầy nỗ lực và nhiều ý nghĩa được nhiều người theo đuổi lâu nay, cần được nhà nước tiếp tục ủng hộ lâu dài ( _http://nomfoundation.org_ ).

  * Tiếp theo có thể kể đến các chương trình _nhận dạng chữ Việt in_ (OCR: optical character recognition), như hệ VnDOCR của Viện Công nghệ Thông tin, Viện Khoa học và Công nghệ Việt Nam. Các chương trình nhận dạng chữ in nhằm _chuyển_ các tài liệu in trên giấy thành các tài liệu điện tử (dưới dạng các tệp văn bản trên máy tính).

  * Các _phần mềm hỗ trợ việc sử dụng_ tiếng nước ngoài, tiêu biểu là các từ điển song ngữ trên máy tính, thí dụ như các từ điển điện tử của Lạc Việt đã được dùng rộng rãi trên máy tính để tra cứu từ Anh-Việt, Việt-Anh. Điều ta cần phân biệt là các từ điển điện tử này dành cho con người sử dụng, khác với từ điển điện tử dành cho máy tính sử dụng trong xử lý ngôn ngữ tự nhiên (sẽ được đề cập ở phần sau).

  * Các nỗ lực trong việc làm các _phần mềm dịch Anh-Việt,Việt-Anh_ , chẳng hạn như các hệ dịch EVTRAN và VETRAN.

  * Một loại việc nữa là _Việt hóa các phần mềm_ mà gần đây tiêu biểu là kết quả Việt hóa Windows và Microsoft Office của Microsoft. Việc này có thể xem như việc “dịch” các thông báo tiếng Anh _cố định_ trong các phần mềm thành các thông báo tiếng Việt.

  * Tuy liên quan đến tiếng Việt, không phải tất cả các việc kể trên đều thuộc về lĩnh vực xử lý ngôn ngữ tự nhiên nói chung và xử lý tiếng Việt nói riêng theo nghĩa thông thường trong CNTT, vốn chủ yếu nhằm vào những vấn đề liên quan đến xử lý văn bản (text) và tiếng nói (speech) [Jurafsky and Martin, 2000].


Để làm sáng tỏ điều này ta thử xem xét lại khái niệm “xử lý thông tin”, một khái niệm cốt lõi của công nghệ thông tin và là khái niệm rộng hơn “xử lý ngôn ngữ”. Về bản chất, _xử lý thông tin là quá trình biến đổi dữ liệu từ dạng này thành dạng khác để có thể thu được thông tin và tri thức_. Trong giai đoạn đầu, CNTT tập trung vào các dữ liệu dạng số, biểu diễn bởi các dạng được cấu trúc (structured) như các vectơ (vector) hay bảng biểu (tables). Trong hơn nửa thế kỷ phát triển, CNTT dần dần “xử lý” nhiều kiểu dữ liệu khác, như hình ảnh (image), âm thanh (voice, speech), văn bản (text), kí hiệu hình thức (symbols), đồ thị (graph),… và gần đây là nhiều kiểu dữ liệu phức tạp như dữ liệu sinh học (genomic data). Phương pháp xử lý cũng ngày càng phong phú, từ tính toán (computing) đến suy luận (reasoning), và nhiều kiểu khác nữa. _Xử lý ngôn ngữ_ chính là xử lý thông tin khi đầu vào là “dữ liệu ngôn ngữ” (dữ liệu cần biến đổi), tức dữ liệu “văn bản” hay “tiếng nói”.

Các dữ liệu liên quan đến ngôn ngữ viết (văn bản) và nói (tiếng nói) đang dần trở nên kiểu dữ liệu chính con người có và lưu trữ dưới dạng điện tử. Đặc điểm chính của các kiểu dữ liệu này là không có cấu trúc hoặc nửa cấu trúc (non-structured hoặc semi-structured) và chúng không thể lưu trữ trong các khuôn dạng cố định như các bảng biểu. Theo đánh giá của công ty Oracle, hiện có đến 80% dữ liệu không cấu trúc trong lượng dữ liệu của loài người đang có [Oracle Text]. Với sự ra đời và phổ biến của Internet, của sách báo điện tử, của máy tính cá nhân, của viễn thông, của thiết bị âm thanh, … người người ai cũng có thể tạo ra dữ liệu văn bản hay tiếng nói. Vấn đề là làm sao ta có thể xử lý chúng, tức chuyển chúng từ các dạng ta chưa hiểu được thành

các dạng ta có thể hiểu và giải thích được, tức là ta có thể tìm ra thông tin, tri thức hữu ích cho mình.

Giả sử chúng ta có các câu sau trong các tiếng nước ngoài:

  * “We meet here today to talk about Vietnamese language and speech processing.”

  * “Aujourd'hui nous nous réunissons ici pour discuter le traitement de langue et de parole vietnamienne.”

  * “Mы встрачаемся здесь сегодня, чтобы говорить о вьетнамском языке и обработке речи.”

  * “今日我々はここに集まりベトナム語処理について議論します.”

  * “오늘 우리는 여기에 모여서 베트남어와 발언처리에 대하여 의론하겠습니다.”


Và giả sử chúng ta không ai biết cả năm thứ tiếng trên, nhưng tò mò muốn biết các câu đó nói gì. Nếu có ai đó dịch, hoặc có một chương trình máy tính dịch (biến đổi) chúng ra tiếng Việt, ta sẽ hiểu nghĩa các câu trên đều là:

  * “Hôm nay chúng ta gặp nhau ở đây để bàn về xử lý ngôn ngữ và tiếng nói tiếng Việt.”


Nếu các câu này được lưu trữ như các tệp tiếng Anh, Pháp, Nga, Nhật, Hàn và Việt như ta nhìn thấy ở trên, ta có các dữ liệu “văn bản”. Nếu ai đó đọc các câu này, ghi âm lại, ta có thể chuyển chúng vào máy tính dưới dạng các tệp các tín hiệu (signal) “tiếng nói”. Tín hiệu sóng âm của hai âm tiết tiếng Việt có thể nhìn thấy như sau

![](images/image1.jpeg)

Tuy nhiên, một văn bản thật sự (một bài báo khoa học chẳng hạn) có thể có đến hàng nghìn câu, và ta không phải có một mà hàng triệu văn bản. Web là một nguồn dữ liệu văn bản khổng lồ, và cùng với các thư viện điện tử − khi trong một tương gần các sách báo xưa nay và các nguồn âm thanh được chuyển hết vào máy tính (chẳng hạn bằng các chương trình nhận dạng chữ, thu nhập âm thanh, hoặc gõ thẳng vào máy) − sẽ sớm chứa hầu như toàn bộ kiến thức của nhân loại. Vấn đề là làm sao “xử lý” (chuyển đổi) được khối dữ liệu văn bản và tiếng nói khổng lồ này qua dạng khác để mỗi người có được thông tin và tri thức cần thiết từ chúng? Điều này càng quan trọng khi đa số nguồn tri thức quý giá này lại bằng tiếng nước ngoài và đa số người Việt chúng ta còn ít nghe hay đọc được chúng.

Có thể hình dung phần mềm gõ chữ Việt cho phép ta trực tiếp tạo ra một tệp văn bản trên máy tính (như chúng tôi đang gõ máy tính để viết bài này), còn chương trình nhận dạng chữ VnDOCR cho phép ta biến đổi một văn bản in trên giấy thành một tệp văn bản trên máy tính. Tuy nhiên, các sản phẩm trên vẫn chưa động chạm đến cốt lõi của xử lý ngôn ngữ. Theo nghĩa “xử lý ngôn ngữ” nêu ở trên − tức biến đổi dữ liệu ngôn ngữ − có thể nêu ra một số bài toán tiêu biểu của xử lý ngôn ngữ với các mức độ khác nhau về xử lý và sử dụng ngôn ngữ tự nhiên của con người:

  * _Nhận dạng tiếng nói (speech recognition)_ : từ sóng tiếng nói, nhận biết và chuyển chúng thành dữ liệu văn bản tương ứng [Jelinek, 1998], [Jurafsky and Martin, 2000].

  * _Tổng hợp tiếng nói (speech synthesis):_ từ dữ liệu văn bản, phân tích và chuyển thành tiếng người nói [Jelinek, 1998], [Jurafsky and Martin, 2000].

  * _Nhận dạng chữ viết (optical character recognition, OCR):_ từ một văn bản in trên giấy, nhận biết từng chữ cái và chuyển chúng thành một tệp văn bản trên máy tính.

  * _Dịch tự động (machine translation)_ : từ một tệp dữ liệu văn bản trong một ngôn ngữ (tiếng Anh chẳng hạn), máy tính dịch và chuyển thành một tệp văn bản trong một ngôn ngữ khác (tiếng Việt chẳng hạn) [Dorr et al., 2000], [Nagao, 1989].

  * _Tóm tắt văn bản (text summarization):_ từ một văn bản dài (mười trang chẳng hạn) máy tóm tắt thành một văn bản ngắn hơn (một trang) với những nội dung cơ bản [Mani and Maybury, 1999]

  * _Tìm kiếm thông tin (information retrieval)_ : từ một nguồn rất nhiều tệp văn bản hay tiếng nói, tìm ra những tệp có nội dung liên quan đến một vấn đề (câu hỏi) ta cần biết (hay trả lời) [Baeza-Yates and Ribeiro-Neto, 1999].. Điển hình của công nghệ này là _Google_ , một hệ tìm kiếm thông tin trên Web, mà hầu như chúng ta đều dùng thường xuyên. Cần nói thêm rằng mặc dù hữu hiệu hàng đầu như vậy, Google mới có khả năng cho chúng ta tìm kiếm câu hỏi dưới dạng các từ khóa (keywords) và luôn “tìm” cho chúng ta rất nhiều tài liệu không liên quan, cũng như rất nhiều tài liệu liên quan đã tồn tại thì Google lại tìm không ra. Hình bên chỉ ra một màn

  * hình của Google đưa ra các trang Web liên quan đến câu hỏi “protein-protein interaction”


  * _Trích chọn thông tin (information extraction)_ : từ một nguồn rất nhiều tệp văn bản hay tiếng nói, tìm ra những _đoạn bên trong_ một số tệp liên quan đến một vấn đề (câu hỏi) ta cần biết hay trả lời. Hình bên phải minh họa một kết quả trích chọn thông tin với

  * cùng câu hỏi “protein-protein interaction”. Một hệ trích chọn thông tin có thể “lần” vào từng trang Web liên quan, phân tích bên trong và trích ra các thông tin cần thiết, nói gọn trong tiếng Anh để phân biệt với tìm kiếm thông tin là “find things but not pages” [Cohen and McCallum, 2003].

  * _Phát hiện tri thức và khai phá dữ liệu văn bảm (knowledge discovery and text data mining)_ : Từ những nguồn rất nhiều văn bản thậm chí hầu như không có quan hệ với nhau, tìm ra được những tri thức trước đấy chưa ai biết. Đây là một vấn đề rất phức tạp và đang ở giai đoạn đầu của các nghiên cứu trên thế giới [Berry, 2004], [Sirmakessis, 2004].


Còn nhiều bài toán và công nghệ xử lý ngôn ngữ khác, như giao diện người máy bằng ngôn ngữ tự nhiên, các hệ hỏi đáp, các hệ sinh ra ngôn ngữ, …

Ứng dụng của công nghệ xử lý ngôn ngữ hết sức phong phú. Có thể lấy vài thí dụ gần đây. Tin trên Internet ngày 21/4/2005, hãng Samsung đưa ra thị trường điện thoại di động P207 có thể nhận biết được các câu nói đơn giản của người sử dụng điện thoại di động như “Hãy gọi cho tôi” hay “Tôi sẽ gọi lại”, rồi chuyển chúng thành dạng văn bản (tin nhắn) cho người dùng điện thoại di động gửi nhắn tin. Đây là một ứng dụng của QuickPhrase trong VoiceSignal Technologies, tất nhiên là cho tiếng Hàn. Ta có thể hình dung đây là việc ghi lại tín hiệu một câu nói đơn giản, so sánh tín hiệu này với tín hiệu của một rất nhiều câu nói đã được ghi trước rồi chọn câu gần nhất ( _http://www.vnexpress.net/Vietnam/Vi-tinh/San-pham-moi/2005/04/ 3B9D D713/_ ). Tin ngày 22/4/2005 ( _http://www2.tuoitre.com.vn/Tianyon/Index.aspx?ArticleID=75496 &ChannelID=17_) cho biết công ty CombiWith (Nhật) công bố sắp tung ra các bức ảnh biết nói để cho những người cô đơn ở Nhật có thể có ảnh của người thân biết nói với chính giọng của họ. Có thể hình dung đây chính là việc tổng hợp tiếng nói của người trong ảnh dựa trên việc học giọng nói từ rất nhiều mẫu câu nói của người đó. Tất nhiên, đây lại là tiếng Nhật vì công nghệ cho tiếng Việt sẽ rất khác. Cũng vậy, có rất nhiều phần mềm dịch tự động trên Web, như Babel Fish Translation của AltaVista ( _http://babelfish.altavista.com/_ ), dịch Anh-Nhật, Nhật-Anh bởi Excite bản tiếng Nhật

( _http://www.excite.co.jp/world/english/_ ), hay Language Tools dịch nhiều thứ tiếng của Google ( _http://www.google.com/language_tools?hl=en_ ).

Có thể phân loại các bài toán:

  * 1-3 thuộc lĩnh vực _xử lý tiếng nói và xử lý ảnh_ (speech and image processing),

  * 4-5 thuộc lĩnh vực _xử lý văn bản_ (text processing),

  * 6-8 thuộc lĩnh vực _khai phá văn bản và Web_ (text and Web mining).


Phân loại này là tương đối, vì các lĩnh vực trên có rất nhiều phần chung nhau. Về bản chất, xử lý tiếng nói dựa hay ảnh trên các kỹ thuật _phân tích và nhận dạng tín hiệu_ (signal processing and recognition). Xử lý văn bản cũng như khai phá văn bản và Web lại dựa trên các kỹ thuật của _xử lý ngôn ngữ tự nhiên_ (natural language processing hay computational linguistics) mà quan trọng là việc _hiểu_ (understanding) và _dùng tri thức về ngôn ngữ_ ở các mức độ khác nhau [Jurafsky and Martin, 2000]. Nếu các bài toán 1-5 có đối tượng xử lý là _một tệp_ văn bản hay tiếng nói, thì các bài toán 6-8 có đối tượng xử lý là một tập hợp _rất nhiều tệp_ văn bản hay tiếng nói. Cần nhấn mạnh thêm là do sự phát triển của Internet, việc tìm kiếm và trích chọn thông tin, phát hiện tri thức từ các cơ sở dữ liệu lớn là các nội dung thời sự và xu thế của phát triển CNTT trên thế giới [Berry, 2004], [Chakrabarti, 2003], [Cole et al., 1997], [Sirmakessis, 2004].

Các bài toán 1-3, 5-8 liên quan việc “xử lý” _một ngôn ngữ_ , trong khi (g) “xử lý” _hai ngôn ngữ khác nhau_. Khi đầu vào hay đầu ra của các bài toán 1-8 là tiếng Việt, ta có các vấn đề của __xử lý tiếng Việt__.

# Về sự phát triển của xử lý ngôn ngữ và tiếng nói trong CNTT

Có thể nói xử lý ngôn ngữ tự động trên máy tính là một trong những vấn đề khó nhất của CNTT. Cái khó nằm ở chỗ làm sao cho máy được hiểu ngôn ngữ con người, từ việc hiểu nghĩa từng từ trong mỗi hoàn cảnh cụ thể, đến việc hiểu nghĩa một câu, rồi hiểu cả văn bản. Ta lấy lại thí dụ của Marvin Minsky (1992), một cây đa cây đề của ngành trí tuệ nhân tạo (artificial intelligence): “Xét từ “sợi dây” chẳng hạn. Ngày nay không một máy tính nào có thể hiểu nghĩa từ này như con người. Còn chúng ta ai cũng biết có thể dùng sợi dây để kéo một vật, nhưng không thể đẩy một vật bằng sợi dây này. Ta có thể gói một gói hàng hoặc thả diều bằng một sợi dây, nhưng không thể ăn sợi dây. Trong vài phút, một đứa trẻ nhỏ có thể chỉ ra hàng trăm cách dùng hoặc không dùng một sợi dây, nhưng không máy tính nào có thể làm việc này.”

Mấu chốt ở đây là bản chất phức tạp của ngôn ngữ của con người, đặc biệt là sự đa nghĩa và nhập nhằng nghĩa của ngôn ngữ. Thêm nữa, có một khác biệt sâu sắc nữa là con người ngầm hiểu và dùng quá nhiều _lẽ thường_ (common sense) trong ngôn ngữ, như biết “lửa” thì nóng còn “chim” thì biết bay, hay sợi dây thì không dùng để đẩy hay khều các vật, trong khi rất khó làm cho máy hiểu các lẽ thường này.

_Công nghệ ngôn ngữ_ , nhất là xử lý văn bản, về đại thể bao gồm các bước (tầng, layer) cơ bản sau đây [Allen, 1994], [Jurafsky and Martin, 2000]:

  * _Tầng ngữ âm (phonetic and phonological layer)_ : Nghiên cứu về ngữ âm (linguistic sounds), như mô hình hóa việc các từ trong cách nói thông thường được phát âm thế nào, về bản chất thanh điệu, ngôn điệu, ngữ điệu (prosody, intonation), trường độ âm tiết, độ nhấn, biến thanh, …

  * _Tầng hình thái (morphological layer):_ Nghiên cứu về các thành phần có nghĩa của từ (word), như từ được tạo ra bởi các hình vị (morphemes) và từ được tách ra trong một câu thế nào. Thí dụ, từ “tiếng Việt” tạo thành từ “t-iế-ng V-iệ-t”, còn ngữ (phrase) “xử lý tiếng Việt” tạo thành gồm hai từ “xử lý” và “tiếng Việt”. Trong tiếng Việt, một bài toán quan trọng là phân tách từ (word segmentation). Một thí dụ quen thuộc là câu “Ông già đi nhanh quá” có thể phân tách thành (Ông già) (đi) (nhanh quá) hoặc (Ông) (già đi) (nhanh quá) hoặc những cách khác nữa.

  * _Tầng ngữ pháp (morphological layer **)** :_ Nghiên cứu các quan hệ cấu trúc giữa các từ, xem các từ đi với nhau thế nào để tạo ra câu đúng. Quá trình này thường được cụ thể trong các bước cơ bản sau:

* _Xác định từ loại_ (POS tagging): Xem mỗi từ trong câu là loại gì (danh từ, động từ, giới từ, …). Trong thí dụ trên, có thể “Ông già” là danh từ, “đi” là động từ, “nhanh” là trạng từ, và “quá” là thán từ.

* _Xác định cụm từ_ (chunking): Thí dụ “Ông già” là cụm danh từ, “đi” là cụm động từ, “nhanh quá” là cụm trạng từ. Như vậy câu trên có hai phân tích (Ông già) (đi) (nhanh quá) hoặc (Ông) (già đi) (nhanh quá).

* _Xác định quan hệ ngữ pháp_ (parsing): (Ông già) (đi) (nhanh quá) là quan hệ chủ ngữ-vị ngữ-trạng ngữ.

  * _Tầng ngữ nghĩa (semantic layer_ ): Nghiên cứu xác định nghĩa của từng từ và tổ hợp của chúng để tạo nghĩa của câu. Thí dụ trong phân tích (Ông già) (đi) (nhanh quá), động từ “đi” có thể có nghĩa “bước đi”, hay “chết” hay “điều khiển” (khi đánh cờ), … và tương ứng ta có các nghĩa khác nhau của câu.

  * _Tầng ngữ dụng (pragmatic layer):_ Nghiên cứu mối quan hệ giữa ngôn ngữ và ngữ cảnh xử dụng ngôn ngữ (context-of-use). Ngữ dụng như vậy nghiên cứu việc ngôn ngữ được dùng để nói về người và vật như thế nào.


Việc phân tích một câu nói hay một câu trong văn bản ở các tầng từ ngữ âm (1) đến tầng ngữ pháp (3) gọi là _phân tích sơ bộ_ (shallow parsing). Nếu phân tích thêm cả tầng ngữ nghĩa (từ (1) đến (4)) ta sẽ có _phân tích đầy đủ_ (fully parsing). Trong các vấn đề của xử lí ngôn ngữ, có vấn đề cần đến phân tích đầy đủ (như dịch tự động), nhưng cũng có những vấn đề chỉ với phân tích sơ bộ cũng có thể đã xử lí được (như tìm kiếm thông tin, phân tích văn bản cho tổng hợp tiếng nói, mô hình ngôn ngữ trong nhận dạng tiếng nói…).

_Nhận dạng tiếng nói_ là một quá trình nhận dạng mẫu, với các mẫu là các đơn vị nhận dạng, có thể là các từ hoặc các âm vị. Khó khăn cơ bản của bài toán này là tiếng nói luôn biến thiên theo thời gian và có sự khác biệt lớn giữa tiếng nói của những người nói khác nhau, tốc độ nói, ngữ cảnh và môi trường âm học khác nhau. Các nghiên cứu về nhận dạng tiếng nói dựa trên _ba nguyên tắc cơ bản_ :

  * Tín hiệu tiếng nói được biểu diễn chính xác bởi các giá trị phổ trong một khung thời gian ngắn (short-term amplitude spectrum). Nhờ vậy ta có thể trích ra các đặc điểm tiếng nói từ những khoảng thời gian ngắn và dùng các đặc điểm này làm dữ liệu để nhận dạng tiếng nói.

  * Nội dung của tiếng nói được biểu diễn dưới dạng chữ viết, là một dãy các ký hiệu ngữ âm. Do đó ý nghĩa của một phát âm được bảo toàn khi chúng ta phiên âm phát âm thành dãy các ký hiệu ngữ âm.

  * Nhận dạng tiếng nói là một quá trình nhận thức. Ngôn ngữ nói có nghĩa, do đó thông tin về ngữ nghĩa (semantics) và ngữ dụng (pragmatics) có giá trị trong quá trình nhận dạng tiếng nói, đặc biệt khi thông tin về âm học là không rõ ràng.


Lĩnh vực nghiên cứu của nhận dạng tiếng nói là khá rộng liên quan đến nhiều ngành khác nhau, như xử lý tín hiệu số (digital signal proccessing), vật lý hay âm học (acoustic), nhận dạng mẫu, lý thuyết thông tin và khoa học máy tính (information and computer science theory), ngôn ngữ học (linguistics), sinh lý học (physiology), tâm lý học ứng dụng (applied psychology). Các hệ thống nhận dạng tiếng nói có thể được phân chia thành hai loại khác nhau: hệ thống _nhận dạng từ rời rạc_ và hệ thống _nhận dạng từ liên tục_. Trong hệ thống nhận dạng tiếng nói liên tục, người ta lại phân biệt hệ thống nhận dạng có kích thước từ điển nhỏ và hệ thống nhận dạng với kích thước từ điển trung bình hoặc lớn.

_Tổng hợp tiếng nói_ (text-to-speech, TTS) có mục tiêu ngược với mục tiêu của nhận dạng tiếng nói. Kiến trúc của một hệ thống TTS giống như kiến trúc đọc chữ của con người, bao gồm một _môđun xử lý ngôn ngữ tự nhiên_ (bộ tiền xử lý nhằm tổ chức các câu thành danh sách, bộ phân tích hình thái, bộ phân tích ngữ cảnh, bộ phân tích câu cú pháp, ngôn điệu, …), có khả năng sinh ra phiên âm phù hợp với cách phát âm của quá trình đọc văn bản cùng với ngữ điệu, ngôn điệu; và một _môđun xử lý tín hiệu số_ , môđun này chuyển thông tin tượng trưng nhận được thành tiếng nói (môđun letter-to-sound và môđun sinh ra ngôn điệu). Khi hai khối xử lý ngôn ngữ tự nhiên và xử lý tín hiệu số được định nghĩa rõ ràng, việc nghiên cứu về hai quá trình có thể được thực hiện riêng rẽ, độc lập với nhau. Khối xử lý tín hiệu số phải xét đến các hạn chế phát âm, vì sự biến đổi ngữ âm (phần động, chuyển tiếp giữa các âm) là quan trọng đối với việc hiểu lời nói hơn là các phần tĩnh của lời nói. Tổng hợp tiếng nói có thể đạt được cơ bản theo hai phương pháp thuộc về hai trường phái tổng hợp tiếng nói có nội dung và mục tiêu khác nhau:

  * Phương pháp thứ nhất được thực hiện dưới dạng các quy tắc mô tả âm vị, ảnh hưởng lẫn nhau giữa các âm vị khi phát ra một âm (tổng hợp bằng qui luật).

  * Phương pháp thứ hai lưu giữ những đơn vị âm cơ bản, biến đổi đơn vị âm cơ bản và đồng thời tạo ra cơ sở dữ liệu tiếng nói, sử dụng chúng như là các đơn vị âm học cơ bản để tạo thành lời nói (phương pháp tổng hợp theo xích chuỗi).


Trong khi xử lý tiếng Việt còn đang chập chững những bước đi đầu, các nghiên cứu và ứng dụng về xử lý ngôn ngữ nói chung trên thế giới và nhiều nước khác đã có một lịch sử hơn nửa thế kỷ, đã trải qua nhiều giai đoạn, và điều quan trọng hơn cả là nhiều con đường và cách thức xử lí ngôn ngữ đã được trải nghiệm và thừa nhận. Lịch sử xử lý ngôn ngữ có thể được chia ra các giai đoạn như sau [Jurafsky and Martin, 2000]:

**Các lý thuyết nền tảng được xây dựng trong các năm 1940 và 1950** : Hai kiểu mô hình nền tảng của giai đoạn này có ảnh hưởng sâu sắc đến xử lý ngôn ngữ là mô hình các máy tự động (automaton) và các mô hình của lý thuyết thông tin hay xác suất: Máy tính điện tử bắt nguồn từ các mô hình máy Turing (1936), lý thuyết ngôn ngữ hình thức, mã hóa, entropy, …

**Hai nhánh tách rời nhau từ cuối các năm 1950 đến đầu năm 1970** : Hai kiểu xử lý khác biệt nhau rõ rệt: (a) kiểu hình thức (symbolic paradigm) cho văn bản như lý thuyết ngôn ngữ hình thức của Chomsky và trí tuệ nhân tạo, và (b) kiểu ngẫu nhiên (stochastic paradigm) cho tiếng nói như các phương pháp Bayes.

**Bốn kiểu xử lý ngôn ngữ phổ biến trong thập kỷ 70 đến giữa thập kỷ 80** :

  * các _mô hình ngẫu nhiên_ đóng một vai trò lớn, tiêu biểu là các mô hình Markov ẩn (HMM, Hidden Markov Model) trong xử lý tiếng nói;

  * _kiểu dựa trên logic_ (logic-based paradigm);

  * _hiểu ngôn ngữ tự nhiên_ (natural language understanding);

  * _mô hình hóa các cuộc đối thoại liên tục_ (discourse modeling).


Cũng trong thời gian này xuất hiện các bài toán và tài nguyên chuẩn (Penn Treebank, WordNet, MUC, etc.).

**Chủ nghĩa kinh nghiệm và các mô hình hữu hạn trạng thái từ giữa thập kỷ 80 đến giữa thập kỷ 90:** Ở giai đoạn này đã có thể huấn luyện các mô hình hữu hạn trạng thái ra đời trong thập kỷ 60. Các mô hình xác suất và tiếp cận dựa vào dữ liệu (data-driven approach) xuất hiện trong hầu hết các nhiệm vụ của xử lý ngôn ngữ [Manning and Schutze, 1999], [Jelinek, 1998].

**Xử lý văn bản và tiếng nói gặp nhau trong mười năm qua** : Đây là giai đoạn tiến bộ vượt bậc với mô hình thống kê và tiếp cận dựa vào dữ liệu, với việc tăng trưởng nhanh chóng của tốc độ và bộ nhớ máy tính, của các ứng dụng dựa trên Web [Jurafsky and Martin, 2000]. Công nghệ xử lý tiếng nói không thể chỉ dựa trên các kỹ thuật xử lý tín hiệu, mà còn phải dựa cả trên việc hiểu ngôn ngữ. Do tham số của các mô hình thống kê hoặc các mô hình hữu hạn trạng thái đã có thể huấn luyện được từ các kho ngữ liệu lớn, nhiều mô hình kiểu này tiếp tục ra đời và được ứng dụng rộng rãi như Maximum Entropy (MaxEnt), Maximum Entropy Markov Model (MEMM), Conditional Random Fields (CRF), … [Cohen and McCallum, 2003]

Như đã trình bày sơ bộ ở trên, xử lí ngôn ngữ là một việc khó, phức tạp, chỉ có thể làm lâu dài theo nhiều bước tuần tự, chỉ có thể đạt được kết quả bước sau khi bước trước đã có kết quả. Chẳng hạn như các chương trình dịch tự động trên thế giới đã được theo đuổi hàng chục năm và chặng đường đến đích cuối vẫn còn rất xa. Nếu chúng ta muốn làm dịch tự động Anh-Việt, bắt buộc chúng ta đi qua các tầng của xử lý ngôn ngữ kể trên, và nói chung không thể hy vọng thời gian sẽ ngắn hơn nhiều so với người đi trước [Dorr et al., 2000].

Trên thế giới, nhiều tổ chức quốc tế, nhiều hiệp hội xử lí ngôn ngữ tự nhiên đã được thành lập với các hoạt động phong phú hàng năm, với lực lượng nghiên cứu đông đảo: ACL (Association Computational Linguistics), NAACL (North American Association on Computational Linguistics), EACL (Euro Association on Computational Linguistics), PACLIC (Pacific Association on Computational Linguistics), ICCL (International committee Computational Linguistics). Rất đáng chú ý là nhiều nguồn tài nguyên, ngữ liệu phong phú được tạo ra, được chia sẻ dù đôi khi dưới dạng thương mại nhưng với giá cả hợp lí, tiêu biểu là LDC (Linguistic Data Consortium, _http://ww.ldc.upenn.edu_ ).

Nhiều chính phủ đã đầu tư lớn cho xử lý ngôn ngữ trong CNTT (Mỹ, Nhật bản, Trung quốc, Singapore, etc.). Hãy thử nhìn đến các nước quanh Việt Nam. Ở Trung quốc, nghiên cứu về xử lý ngôn ngữ có từ lâu và hiện đang rất phát triển với sự đầu tư mạnh mẽ từ chính phủ. Họ đã làm ra nhiều công cụ, tài nguyên phong phú, như Wordnet cho tiếng Trung quốc, các hệ dịch giữa tiếng Trung quốc và qua tiếng một số nước, các ngân hàng ngữ liệu cho phân tích cú pháp như Chinese Bank. Ngay với nước láng giềng Thailand, xử lý ngôn ngữ Thái đã là phần được đầu tư lớn của chính phủ tại National Electronics and Computer Technology Center (NECTEC), National research council of Thailand (NRCT), Thai Research Foundation (TRF) với những kết quả ban đầu về dịch máy, về POS tagging. Thailand đã có các phòng thí nghiệm lớn nghiên cứu về NLP, Thai Computational Linguistics Laboratories ( _http://www.tcllab.org_ ).

Là người đi sau trong lĩnh vực xử lí ngôn ngữ, việc hiểu các công nghệ ngôn ngữ, các xu thế công nghệ, các nguồn ngữ liệu, kinh nghiệm và bài học từ các nước khác trong lĩnh vực này là hết sức quan trọng. _Biết, học và khai thác được chúng sẽ giúp ta cân nhắc chọn được đường đi hợp lí trong xử lý tiếng Việt_.

# Tình hình và những vấn đề chính trong xử lý tiếng Việt

Hãy thử nhìn lại tình hình của chúng ta. Ngoài những việc đã làm và bước đầu làm được kể ở phần đầu, đã có những cố gắng trong nhiều nội dung khác nhau về xử lý ngôn ngữ và tiếng Việt. Trong các bài giảng về Trí tuệ Nhân tạo, về Lý thuyết Nhận dạng, về Xử lý Tín hiệu, về Khai phá Dữ liệu ở nhiều đại học, các nội dung và kỹ thuật xử lý ngôn ngữ đã ít nhiều được đề cập. Về xử lý tiếng nói và tiếng Việt, theo chúng tôi biết, hai tập thể làm nghiên cứu đã có những kết quả gần đây là Viện Công nghệ Thông tin và Trung tâm nghiên cứu quốc tế Thông tin đa phương tiện, truyền thông và ứng dụng (MICA) – Đại học Bách khoa Hà nội; một số kết quả ở một số trường Đại học là những đề tài tiến sĩ, thạc sĩ, mang tính chất tìm hiểu, chưa hệ thống và định hướng rõ ràng. Nghiên cứu về xử lý ngôn ngữ (văn bản) đã được theo đuổi bởi một số tập thể từ khá lâu (Đại học Bách khoa và Đại học Khoa học Tự nhiên thành phố Hồ Chí Minh, Đại học Bách Khoa Đà Nẵng, Đại học Bách khoa và Đại học Khoa học Tự nhiên Hà Nội, Trường Đại học Công nghệ, Viện Ứng dụng Công nghệ, Viện Công nghệ Thông tin, công ty Lạc Việt,…) về các vấn đề dịch máy, các bài toán cơ bản của xử lý tiếng Việt [Dien et al., 2001; Dien, 2003], [Huyen et al., 2003], và gần đây là tóm tắt văn bản [Minh, 2004; Minh et al., 2004], [Huong, 2004], tìm kiếm và trích chọn thông tin [Bao and Funakoshi, 1998], phân loại và chia nhóm văn bản [Bao and Binh, 2001], khai phá Web [Hieu, 2005], gióng hàng văn bản [Huyen et al., 2003], mô hình từ điển điện tử [Bao et al., 2003], xây dựng kho ngữ liệu [Dien, 2002], … và gần đây nhất là đề tài nhà nước “Nghiên cứu phát triển công nghệ nhận dạng, tổng hợp và xử lý ngôn ngữ tiếng Việt” giai đoạn 2001-2004 trong chương trình quốc gia KC-01 [Khang, 2004].
Bên ngoài Việt Nam, cũng có những nỗ lực về xử lý tiếng Việt, như nhóm dịch Anh-Việt của tiến sỹ Phạm Hải và bè bạn (Mỹ) khởi đầu từ đầu các năm 1990, của tiến sỹ Lê Tăng Hồ và phần mềm tổng hợp tiếng Việt VVV (Canada), … đặc biệt là của các cán bộ và nghiên cứu sinh Việt Nam tại Viện Khoa học và Công nghệ Tiên tiến Nhật bản (JAIST) với 6 nghiên cứu sinh về xử lý ngôn ngữ, hợp tác theo một kế hoạch thống nhất. Số nghiên cứu sinh về xử lý ngôn ngữ mới tốt nghiệp như Lê Thanh Hương (Anh) [Huong, 2004], Nguyễn Thị Minh Huyền (Pháp), Hồ Bảo Quốc (Pháp), Nguyễn Lê Minh (Nhật) [Minh, 2004], và số sắp tốt nghiệp trong 1-2 năm tới đây ước tính khoảng 10 người.
Ngoài những kết quả ban đầu, sau đây có thể là một vài đặc điểm chính về hoạt động xử lý ngôn ngữ của chúng ta:

  * Thường _tập trung vào làm các sản phẩm cho người dùng cuối_ với nhiều kỳ vọng vào các sản phẩm dịch máy, một loại sản phẩm khó làm và cần làm dài hạn với những phương pháp hợp lý.

  * _Ít các nghiên cứu nền tảng, thiếu phát triển “hạ tầng cơ sở”_ cho xử lý ngôn ngữ như công cụ và tài nguyên: từ điển (dùng cho máy), kho ngữ liệu, …, những thứ đã được cả cộng đồng quốc tế xác định là không thể thiếu trong xử lý ngôn ngữ.

  * Phần đông là các _nghiên cứu ngắn hạn và đơn lẻ ở mức đề tài thạc sỹ, tiến sỹ_ với nhiều hạn chế về thời hạn và điều kiện. Đa số mới xây dựng được mô hình, thử và kiểm tra trên những tập ngữ liệu nhỏ. Những kết quả đạt được ở đây còn xa với mức sử dụng được trong thực tế.

  * Rất có thể nhiều nhóm đã bắt đầu với _sự khảo sát chưa đầy đủ_ , hoặc tiến hành công việc khi _có thể còn thiếu kiến thức_. Do vấn đề mới và phức tạp, các hội đồng đánh gía thẩm định các đề tài về xử lý ngôn ngữ còn _chưa có chuyên gia_ , chưa thật rõ hết cái có thể và cái chưa thể làm được, người làm đi đường ngắn hay đường vòng, …

  * Đáng băn khoăn hơn cả là các nỗ lực của chúng ta _chưa được liên kết, thiếu chia sẻ, phân công, hợp tác theo một lộ trình có kế hoạch, thiếu “kim chỉ nam”_ về xử lý tiếng Việt, và _không có tính kế thừa_ về kết quả giữa các tầng của xử lý ngôn ngữ tự nhiên. Nếu hình dung công việc trong các tầng của xử lý ngôn ngữ được đánh số từ A đến Z, thì hầu hết các việc làm ra cho người dùng cuối đều ở quãng từ R, S, … trở đi, mà muốn làm mấy việc này thì đều cần kết quả của tất cả các bước từ A đến tận P, Q. Hiềm nỗi mỗi việc từ A, B, … đến P, Q muốn làm tốt đều đòi hỏi một nhóm người làm trong một vài năm. Vì vậy, nếu ai cũng phải làm từ A đến gì đấy tận P, Q, có lẽ sẽ không ai có thể làm ra các sản phẩm R, S, …, Z đủ tốt. Dù bây giờ hay năm, mười, hai mươi năm sau cũng vậy.


# Kết luận

Chúng ta ai cũng biết xử lý tiếng Việt chỉ có thể do người Việt làm, không thể mua được từ bên ngoài. Ngoài ra, xử lý tiếng Việt là công việc phải làm _trên đường dài gồm nhiều chặng ngắn với các đích chọn lựa kỹ lưỡng_ , và _cần được nhà nước hỗ trợ_. Trước mắt, trong kế hoạch 2006-2010, hai mục tiêu của dự án đầu là:

  * _Xây dựng và phát triển một số sản phẩm tiêu biểu_ về xử lý tiếng Việt và tìm kiếm thông tin trên Internet bằng tiếng Việt cho đông đảo người sử dụng máy tính và Internet.

  * _Xây dựng các công cụ và nguồn tài nguyên thiết yếu,_ với vai trò hạ tầng cơ sở, để thực hiện mục tiêu 1 của dự án này và các phát triển lâu dài của công nghệ thông tin của nước nhà.


Mặc dù việc phải tạo các sản phẩm cho người dùng cuối là cấp bách và đích cuối cùng ta cần đến, chúng ta vẫn luôn phải chú ý đầu tư cho việc tạo ra các công cụ và tài nguyên cho xử lý tiếng Việt, vì chỉ có như vậy ta mới có thể làm được các sản phẩm có thể dùng được trong những năm về sau.

# Public_022

# Phạm vi áp dụng

Tiêu chuẩn này quy định phương pháp thử nghiệm các hệ bọc bảo vệ chịu lửa cho cấu kiện kết cấu thép được sử dụng trong công trình như dầm, cột, hoặc cấu kiện chịu kéo. Tiêu chuẩn này được biên soạn để sử dụng kết hợp với quy trình đánh giá được trình bày trong ISO 834-11. Tiêu chuẩn áp dụng cho các loại tiết diện thép (bao gồm các tiết diện rỗng) và chỉ xét đến các tiết diện không có các lỗ hở trên bản bụng. Các kết quả từ phân tích tiết diện chữ I hoặc tiết diện chữ H được áp dụng trực tiếp cho tiết diện thép góc, tiết diện chữ C và tiết diện chữ T có cùng hệ số tiết diện được sử dụng như các cấu kiện riêng lẻ, ví dụ như giằng, hoặc một phần của hệ kết cấu chế tạo sẵn như hệ giàn thép. Tiêu chuẩn này không áp dụng đối với các thanh/que đặc, hoặc tiết diện rỗng được nhồi bê tông.
Tiêu chuẩn này mô tả các quy trình thử nghiệm chịu lửa cần được thực hiện để đánh giá khả năng của hệ bọc bảo vệ để duy trì đủ sự kết dính và giữ đúng vị trí đối với một phạm vi biến dạng, nhiệt độ lò và nhiệt độ thép được xác định rõ từ trước, sao cho hiệu quả của hệ bọc bảo vệ không bị suy giảm đáng kể, và để cung cấp dữ liệu về các đặc tính nhiệt của hệ bọc bảo vệ khi chịu tác động của đường cong nhiệt độ/thời gian tiêu chuẩn được quy định trong tiêu chuẩn TCVN 9311-1.
Trong các trường hợp đặc biệt được quy định trong các quy chuẩn xây dựng quốc gia, các vật liệu chống cháy dạng phản ứng có thể được yêu cầu phải chịu đường cong nhiệt chậm. Thử nghiệm và các yêu cầu cho việc sử dụng đường cong này được mô tả trong phụ lục F.
Tiêu chuẩn này có thể áp dụng cho cả hệ bọc bảo vệ chịu lửa dạng thụ động và dạng phản ứng như được định nghĩa trong phần thuật ngữ và định nghĩa, được lắp đặt hoặc bọc phủ sao cho chúng giữ nguyên vị trí trong khoảng thời gian dự kiến chịu lửa.
Phương pháp thử nghiệm chịu lửa cung cấp các quy định cho việc thu thập và diễn giải số liệu được sử dụng làm đầu vào trực tiếp của tiêu chuẩn ISO 834-11 để xác định các giới hạn áp dụng trực tiếp cho các tiết diện thép với hình dạng, kích thước và khoảng thời gian chịu lửa bất kì.

# Tài liệu viện dẫn

Một phần hoặc toàn bộ các tài liệu viện dẫn sau là cần thiết cho việc sử dụng tiêu chuẩn này. Đối với các tài liệu viện dẫn ghi năm công bố thì áp dụng phiên bản được nêu. Đối với các tài liệu viện dẫn không ghi năm công bố thì áp dụng phiên bản mới nhất, bao gồm cả các sửa đổi, bổ sung (nếu có).TCVN xxxx:202x

TCVN 9311-1 (ISO 834-1), Thử nghiệm chịu lửa - Các bộ phận công trình xây dựng - Phần 1: Yêu cầu chung

TCVN 9311-6:2012 (ISO 834-6), Thử nghiệm chịu lửa - Các bộ phận công trình xây dựng - Phần 6:

Các yêu cầu riêng đối với dầm

TCVN 9311-7:2012 (ISO 834-7), Thử nghiệm chịu lửa - Các bộ phận công trình xây dựng - Phần 7:

Các yêu cầu riêng đối với cột

ISO 1182:2010, Thử nghiệm sản phẩm phản ứng với lửa – Phương pháp thử tính không cháy

ISO 1716, Thử nghiệm sản phẩm phản ứng với lửa – Xác định nhiệt lượng của quá trình đốt (giá trị nhiệt lượng).

ISO 8421-2, Bảo vệ chịu lửa – Từ vựng – Phần 2: Bảo vệ chịu lửa kết cấu.

ISO 834-11, Thử nghiệm chịu lửa – Các bộ phận công trình xây dựng – Phần 11: các yêu cầu riêng cho việc đánh giá lớp bọc bảo vệ với cấu kiện của kết cấu thép.

EN 13501-1, Phân loại chịu lửa cho sản phẩm xây dựng và bộ phận công trình – Phần 1: Phân loại dữ liệu từ các thử nghiệm phản ứng với lửa.

EN 1363-1, Thử nghiệm chịu lửa – Phần 1: Các quy định chung.

ISO 13943, An toàn cháy – Từ vựng.

IEC 584-1, Đầu đo nhiệt – Phần 1: Bảng tham khảo.

ETAG 018, Các sản phẩm bọc bảo vệ chịu lửa.

# Thuật ngữ và định nghĩa

Các thuật ngữ và định nghĩa được nêu trong TCVN 9311-1, ISO 13943, TCVN 9310-4 và những thuật ngữ, định nghĩa sau được áp dụng khi sử dụng tiêu chuẩn này.

## Nhiệt độ đặc trưng của thép (characteristic steel temperature)

Nhiệt độ của cấu kiện thép kết cấu được sử dụng để xác định hệ số hiệu chỉnh cho khả năng bám dính được tính toán bằng (nhiệt độ trung bình + nhiệt độ lớn nhất)/2

## Nhiệt độ thiết kế (design temperature)

Nhiệt độ của cấu kiện thép được sử dụng cho mục đích thiết kế kết cấu

## Bảo vệ chịu lửa

Biện pháp bảo vệ các cấu kiện thép bằng hệ bảo vệ chịu lửa sao cho nhiệt độ của cấu kiện thép được giới hạn trong suốt thời gian tiếp xúc với lửa

## Hệ bảo vệ chịu lửa (fire protection system)

Vật liệu chống cháy cùng với hệ đỡ bao gồm lưới thép như được thử nghiệm.
CHÚ THÍCH 1: Hệ vật liệu chống cháy dạng phản ứng bao gồm sơn lót và lớp sơn phủ nếu có.

## Chiều dày lớp bảo vệ chịu lửa (fire protection thickness)

Chiều dày khô của 1 lớp trong hệ bảo vệ chịu lửa hoặc chiều dày tổng cộng của tất cả các lớp trong hệ bảo vệ chịu lửa
CHÚ THÍCH 1: Chiều dày các bộ phận của hệ đỡ hoặc dải che mối nối không được tính vào chiều dày lớp bảo vệ chịu lửa
CHÚ THÍCH 2: với hệ bảo vệ dạng phản ứng, chiều dày là chiều dày trung bình của lớp màng phủ khô không bao gồm sơn lót và sơn phủ nếu có

## Cấu kiện chữ H (H section)

Cấu kiện thép có chiều rộng bản cánh lớn so với chiều cao tiết diện có chức năng chính là chịu tải dọc trục, có thể kết hợp chịu uốn và chịu cắt

## Cấu kiện chữ I (I section)

Dầm phụ hoặc dầm chính bằng thép với phần bản cánh ngắn như chữ “I” có chức năng chính là chịu tải vuông góc với trục dọc của cấu kiện
CHÚ THÍCH 1: các tải trọng trên thường gây ra uốn cho cấu kiện dầm. Các bản cánh dầm có thể song song với nhau hoặc dạng dốc

## Vật liệu bảo vệ dạng thụ động (passive fire protection material)

Các vật liệu, không thay đổi tính chất vật lý khi chịu nhiệt, cung cấp hiệu quả bảo vệ bằng các tính chất vật lý hoặc cách nhiệt của chúng.

## Vật liệu bảo vệ dạng phản ứng (reactive fire protection material)

Các vật liệu mà thành phần của nó xảy ra phản ứng hóa học khi chịu nhiệt để làm thay đổi tính chất vật lý và do đó cung cấp hiệu quả bảo vệ chịu lửa thông qua các hiệu ứng cách nhiệt và làm mát.

## Cấu kiện tham chiếu (reference section)

Cấu kiện thép được lấy cùng chiều dài với cấu kiện tương đương mang tải

## Hệ số tiết diện (với cấu kiện không được bọc bảo vệ) (section factor- unprotected steel)

Tỷ lệ của diện tích phần chu vi tiếp xúc với lửa của cấu kiện thép, trên một đơn vị chiều dài, Am, với thể tích mặt cắt ngang trên mỗi đơn vị chiều dài, V

## **Hệ số tiết diện (với hệ bảo vệ dạng định hình) (section factor-profiled fire protection** system)

Tỉ số giữa diện tích của chu vi bên ngoài phần tiếp xúc với lửa của bộ phận kết cấu thép không bao gồm vật liệu bảo vệ, trên một đơn vị chiều dài, Am, với thể tích của tiết diện trên một đơn vị chiều dài,

## Hệ số tiết diện (với hệ bảo vệ dạng hộp) (section factor - boxed fire protection system)

Tỉ số giữa diện tích bề mặt bên trong của vỏ bọc hình chữ nhật hoặc hình vuông nhỏ nhất được đo xung quanh cấu kiện kết cấu, Am, với thể tích trên một đơn vị chiều dài, V

## Cấu kiện thép (steel member)

Cấu kiện của công trình xây dựng, chịu tải trọng và được chế tạo từ thép

CHÚ THÍCH 1: đối với mục đích của tiêu chuẩn ISO 834, thép được sử dụng trong thử nghiệm phải cùng loại.

## Nhiệt độ thép (steel temperature)

Sử dụng nhiệt độ trung bình tổng thể làm dữ liệu đầu vào cho phân tích, tính toán như sau:

  * Với dầm tiết diện chữ I và tiết diện chữ H, bằng nhiệt độ trung bình của bản cánh trên cộng với nhiệt độ trung bình của bản bụng cộng với nhiệt độ trung bình của bản cánh dưới , chia cho 3.

  * Với cột có tiết diện chữ I, chữ H và tiết diện rỗng, bằng tổng của nhiệt độ trung bình trên mỗi mặt cắt đo chia cho số mặt cắt đo

  * Với dầm tiết diện rỗng, bằng nhiệt độ trung bình của các mặt bên cộng với nhiệt độ trung bình của mặt dưới, chia cho 2.


## Khả năng bám dính (stickability)

Khả năng của hệ bảo vệ chịu lửa duy trì đủ sự kết dính và giữ đúng vị trí đối với một phạm vi biến dạng, nhiệt độ lò và nhiệt độ thép được xác định rõ từ trước, sao cho hiệu quả của hệ bọc bảo vệ không bị suy giảm đáng kể

## Gói thử nghiệm (test package)

Tập hợp các tiết diện thép bao gồm cả mẫu ngắn và mẫu dài được thử nghiệm để xác định đầy đủ khả năng bám dính thích hợp của hệ bảo vệ chịu lửa và cung cấp dữ liệu nhiệt trong một phạm vi chiều dày bảo vệ, hệ số tiết diện, nhiệt độ thép.

## Mẫu thử nghiệm (test specimen)

Cấu kiện thép cùng với hệ bảo vệ chịu lửa được thử nghiệm
CHÚ THÍCH 1: cấu kiện thép được thử nghiệm, đại diện cho một cấu kiện thép được xác định cho mục đích thử nghiệm, bao gồm cột hoặc dầm thép dài và ngắn.

# Ký hiệu và từ viết tắt

  * Diện tích (m2);


Am
Ap

Diện tích phần chu vi tiếp xúc với lửa của cấu kiện kết cấu thép, trên một đơn vị chiều

dài (m2);

Với hệ bảo vệ dạng định hình: là diện tích phần chu vi ngoài của cấu kiện thép kết cấu

không bao gồm vật liệu bảo vệ, trên một đơn vị chiều dài (m2);

Với hệ bảo vệ dạng hộp: diện tích bề mặt phía trong của lớp bảo vệ hình chữ nhật hoặc

hình vuông mà có thể đo được xung quanh cấu kiện thép (m2);

  * Bề rộng của tiết diện thép (m);


  * Chiều dày (mm);


daver
dp
dp(max)
dp(min)

Chiều dày trung bình (mm);

Chiều dày của vật liệu bảo vệ chịu lửa (mm);

Chiều dày lớn nhất của vật liệu bảo vệ chịu lửa (mm);

Chiều dày nhỏ nhất của vật liệu bảo vệ chịu lửa (mm);

  * Chiều cao tiết diện thép (mm);


Kp
Ks
Lexp
Lspec
Lsup

Hệ số ảnh hưởng của chiều dày;

Hệ số ảnh hưởng của tiết diện;

Chiều dài của đoạn dầm tiếp xúc với lửa (mm);

Tổng chiều dài của mẫu thử (mm);

Chiều dài của dầm giữa hai gối tựa (mm);

  * Chu vi của phần tiết diện tiếp xúc với lửa (m);


sp
smax

Hệ số tiết diện của hệ số Ks (m-1);

Hệ số tiết diện lớn nhất tương ứng với hệ số Ks bằng 1 (m-1);


| smin | Hệ số tiết diện nhỏ nhất tương ứng với hệ số Ks bằng 0
(m-1); |
| --- | --- |
| tf | Chiều dày bản cánh của tiết diện (m-1); |
| tw | Chiều dày thành của tiết diện rỗng hoặc chiều dày bản bụng của cột
tiết diện chữ I và |
|  | chữ H (mm); |

 

  * Thể tích của tiết diện thép trên một đơn vị chiều dài (m3/m);


Vp

Thể tích của phần bảo vệ chịu lửa trên một đơn vị chiều dài (m3/m);

LB

Dầm chịu tải

LC

Cột chịu tải dài 3 m

TC

Cột cao không chịu tải (2 m)

LHB

Dầm rỗng chịu tải

LHC

Cột rỗng chịu tải

SIB

Dầm ngắn tiết diện chữ I

SIC

Cột ngắn tiết diện chữ I

TCHS

Dầm cao hình tròn rỗng

TRHS

Dầm cao hình chữ nhật rỗng

SHB

Dầm ngắn tiết diện rỗng

SHC

Cột ngắn tiết diện rỗng

RB

Dầm tham chiếu

# Thiết bị thử nghiệm

## Yêu cầu chung

Lò thử nghiệm và các thiết bị thử nghiệm phải phù hợp với những yêu cầu được quy định trong TCVN 9311-1

## Lò thử nghiệm

Lò thử nghiệm phải được thiết kế phù hợp với kích thước của mẫu thử chịu nhiệt được quy định trong 7.2 và phải phù hợp với việc lắp đặt ở trên hoặc trong lò thử nghiệm được quy định trong mục 8.

## Thiết bị gia tải

Tải trọng phải được tác dụng theo TCVN 9311-1 (ISO 834-1). Hệ gia tải có khả năng chất tải lên dầm theo quy định tại 6.2.2 và lên cột theo quy định tại 6.2.4

# Các điều kiện thử nghiệm

## Yêu cầu chung

Các quy trình được đưa ra trong TCVN 9311-1 phải được tuân thủ trong quá trình thực hiện thử nghiệm trừ khi có hướng dẫn cụ thể khác được đưa ra.
Một số lượng các cấu kiện thép có tiết diện chữ “I”, tiết diện chữ “H”, và tiết diện rỗng, được bảo vệ bằng hệ bọc bảo vệ, được gia nhiệt trong lò thử nghiệm theo cách thức được đưa ra trong tiêu chuẩn TCVN 9311-1
Dầm chịu tải và cột chịu tải được gia nhiệt để cung cấp các thông tin về khả năng của hệ bọc bảo vệ chịu lửa đối với việc duy trì tính nguyên vẹn và bám dính với cấu kiện của kết cấu thép. Dầm không chịu tải và cột không chịu tải được gia nhiệt để cung cấp thông tin về các đặc tính nhiệt học của hệ bọc bảo vệ.
Kiến nghị các thử nghiệm được tiếp tục tiến hành cho đến khi nhiệt độ của thép đạt mức giá trị tối đa tương ứng với ứng dụng của dữ liệu.
Phương pháp thử nghiệm dầm chịu tải trong phần này của phương pháp thử nghiệm được xây dựng để cung cấp giá trị chuyển vị lớn nhất (nhịp/30) dưới tác dụng của tải trọng và nhiệt độ được quy định trong tiêu chuẩn TCVN 9311-1 (ISO 834-1). Nếu không thực hiện được việc xác định này, thì tốc độ võng không được vượt quá giá trị quy định trong tiêu chuẩn TCVN 9311-1 (ISO 834-1).
Trong trường hợp nhiều mẫu thử được thử nghiệm đồng thời, cần lưu ý rằng mỗi mẫu thử cần phải đảm bảo được tiếp xúc với lửa đúng với các điều kiện thử nghiệm đã quy định.

## Gối đỡ và điều kiện tải trọng

### Yêu cầu chung

Chi tiết về các tính toán được thực hiện để xác định tải trọng thử nghiệm cần được đưa vào báo cáo thử nghiệm.

### Dầm chịu tải

Đối với mỗi mẫu thử nghiệm dầm chịu tải, cần có các quy định đối với hệ gối đỡ thích hợp, vị trí và sự căn chỉnh trong lò theo yêu cầu của tiêu chuẩn TCVN 9311-6 (ISO 834-6), tùy thuộc vào bất kỳ yêu cầu sửa đổi nào của tiêu chuẩn này.
Cấu kiện dầm không nên được bổ sung thêm liên kết chống xoắn trừ trường hợp cần thiết nêu trong 7.2.1. Nhịp của gối đỡ đơn giản (Lsup) không nên lớn hơn chiều dài phần tiếp xúc với lửa cộng thêm 400 mm ở mỗi đầu. Chiều dài của mẫu thử nghiệm (Lspec) nên bằng chiều dài tiếp xúc với lửa cộng thêm tối đa 500 mm ở mỗi đầu.
Mẫu thử nghiệm là dầm chịu tải cần phải chịu tổng tải trọng đại diện cho 60 % sức kháng mô men thiết kế, được tính toán sử dụng giới hạn chảy thực tế lấy từ chứng chỉ thử nghiệm lô hoặc giá trị đo thực tế.
Tải trọng thực tế tác dụng lên mẫu thử là tổng tải trọng tính toán trừ đi trọng lượng bản thân của dầm, lớp bê tông đổ bù, và hệ bảo vệ chịu lửa.

# Public_023

# Các hệ bảo vệ chịu lửa

## Nguyên tắc chung

Thành phần của hệ bảo vệ chịu lửa cần được quy định bởi khách hàng và cần bao gồm ít nhất khối lượng riêng danh nghĩa và độ ẩm dự kiến của vật liệu đó. Thông tin bổ sung có thể được yêu cầu liên quan đến khả năng chịu nhiệt cho mục đích đánh giá.

Vì lý do bảo mật, khách hàng có thể không muốn thông báo chi tiết về công thức hoặc thành phần trong báo cáo thử nghiệm.

Đối với các lớp phủ dạng phản ứng, độ dày màng khô của lớp phủ phải được đo tại thời điểm thử nghiệm. Các bước thực hiện và quy trình kiểm tra thích hợp được nêu trong Phụ lục B.

Đối với các vật liệu chống cháy thụ động như dạng tấm, dạng bản và dạng phun, độ dày thực tế, khối lượng riêng và độ ẩm thực tế của vật liệu phải được đo tại thời điểm thử nghiệm đối với từng mẫu thử. Các quy trình thích hợp với các loại vật liệu bảo vệ khác nhau được nêu trong Phụ lục A.

Kích thước và độ dày của tấm và bản sàn phải được xác định theo các tiêu chuẩn quốc gia và nằm trong dung sai được xác định trong các tiêu chuẩn này.

## Chiều dày của vật liệu bảo vệ

### Bản và tấm

Chiều dày vật liệu bọc bảo vệ dạng bản hoặc tấm không sai lệch quá 15% giá trị trung bình trên toàn bộ bề mặt của nó. Giá trị trung bình phải được sử dụng trong đánh giá kết quả và trong giới hạn khả năng áp dụng của đánh giá. Nếu độ dày của tấm thay đổi lớn hơn 15% thì chiều dày lớn nhất sẽ được ghi nhận để sử dụng trong đánh giá.

Giá trị trung bình là giá trị trung bình của tất cả các phép đo theo Phụ lục A.

### Vữa phun và vật liệu phủ dạng bị động

Chiều dày vật liệu bảo vệ dạng vữa phun và lớp phủ dạng bị động cần được đo tại các vị trí quy định trong Phụ lục A. Các điểm đo chiều dày không gần hơn 150 mm tới sườn cứng bản bụng của dầm chịu tải.

Phép đo phải được thực hiện cách xa các vị trí đặt đầu đo nhiệt từ 50 mm đến 100 mm.

Chiều dày của lớp phủ dạng phun không được sai lệch quá 20% giá trị trung bình. Giá trị trung bình được sử dụng trong đánh giá kế quả trong trong giới hạn khả năng áp dụng đánh giá. Nếu độ lệch của chiều dày lớn hơn 20 %, chiều dày lớn nhất cần được sử dụng trong đánh giá.

Chiều dày trung bình (hoặc chiều dày tối đa theo các yêu cầu nêu trên về độ lệch chiều dày cho phép) của vật liệu bảo vệ chịu lửa được áp dụng cho từng cấu kiện dầm chịu tải và cột chịu tải, nếu được sử dụng, phải giống như đối với cấu kiện dầm hoặc cột ngắn tham chiếu. Trong mỗi trường hợp, chênh lệch không được lớn hơn 10% giá trị lớn nhất hoặc ± 5mm, tùy theo giá trị nào nhỏ hơn.TCVN xxxx:202x

### Lớp phủ dạng phản ứng

Đối với vật liệu bọc phủ dạng phản ứng, độ dày trung bình của lớp sơn lót phải được đo trước và trừ đi từ tổng chiều dày trung bình của lớp sơn lót và lớp sơn dạng phản ứng. Dung sai độ dày cho phép không bao gồm sơn lót và sơn phủ (giả sử phân bố chuẩn của độ dày đo được) phải như sau:

  * Tại các mặt cắt đo nhiệt độ

  * Tối thiểu 68% số đọc phải nằm trong khoảng ± 20% giá trị trung bình.

  * Tối thiểu 95% số đọc phải nằm trong khoảng ± 30% giá trị trung bình.

  * Tất cả các số đọc phải nằm trong khoảng ± 45% giá trị trung bình.

  * Về tổng thể

  * Tối thiểu 68% số đọc phải nằm trong khoảng ± 20% giá trị trung bình tại các mặt cắt đo nhiệt độ.

  * Tối thiểu 95% số đọc phải nằm trong khoảng ± 30% giá trị trung bình tại các mặt cắt đo nhiệt độ.

  * Tất cả các số đọc phải nằm trong khoảng ± 45% giá trị trung bình tại các mặt cắt đo nhiệt độ.


Nếu chiều dày vượt quá những giá trị giới hạn trên, mẫu thử nghiệm cần phải được điều chỉnh để phù hợp với những yêu cầu trên.

### Khối lượng riêng của vật liệu bảo vệ dạng thụ động

Khối lượng riêng của vật liệu bảo vệ (nếu phù hợp) được áp dụng cho từng cấu kiện phải được xác định theo Phụ lục A và được ghi nhận.
Với mỗi chiều dày của vật liệu bảo vệ, trọng lượng riêng của vật liệu không được sai lệch quá 15 % giá trị trung bình. Giá trị trung bình phải được sử dụng trong việc đánh giá kết quả và trong phạm vi áp dụng của đánh giá. Nếu có sai lệch lớn hơn 15% thì phải sử dụng giá trị lớn nhất để đánh giá.
Khối lượng riêng trung bình của vật liệu bảo vệ (hoặc khối lượng riêng lớn nhất theo độ lệch cho phép) được áp dụng cho cấu kiện dầm thép mang tải và cột thép mang tải phải giống như áp dụng cho cấu kiện dầm thép hoặc cột thép ngắn tương đương không chịu tải . Chênh lệch giữa các giá trị khối lượng riêng trong mỗi trường hợp không được lớn hơn 10 % giá trị trung bình lớn nhất tại chiều dày sử dụng. Phòng thí nghiệm phải xác nhận các giá trị cân bằng đối với cấu kiện chịu tải và cấu kiện tham chiếu phải nằm trong phạm vi 10 % của nhau.

### Kiểm tra mẫu thử

Việc kiểm tra và xác nhận mẫu thử để đảm bảo sự phù hợp với đặc điểm kỹ thuật phải được thực hiện như trong mô tả của tiêu chuẩn TCVN 9311-1.
Đặc tính của vật liệu bảo vệ được sử dụng trong việc chuẩn bị các mẫu thử nghiệm phải được xác định bằng cách sử dụng các mẫu đặc biệt khi cần thiết theo các phương pháp được nêu trong Phụ lục A hoặc Phụ lục B.
Khách hàng phải có trách nhiệm kiểm tra rằng vật liệu bảo vệ được áp dụng đúng cách, và trong trường hợp vật liệu dạng phun hoặc phủ, phải đảm bảo bằng chúng được sử dụng đúng thành phần và đặc điểm kỹ thuật.TCVN xxxx:202x

Phải ghi chép đầy đủ khoảng hở giữa mặt trong của hệ tấm hoặc bản và tiết diện thép. Đối với dầm, các phép đo phải được thực hiện ở khoảng giữa nhịp và ở cả hai đầu của dầm. Đối với cột, các phép đo phải được thực hiện ở khoảng giữa chiều cao và ở trên cùng của cột.

## Lựa chọn mẫu thử nghiệm

### Nguyên tắc lựa chọn

Phạm vi đánh giá sẽ quyết định việc lựa chọn mẫu thử

Đối với vật liệu bảo vệ dạng thụ động, hướng dẫn lựa chọn mẫu thử được nêu trong Phụ lục C. Đối với vật liệu bảo vệ dạng phản ứng, hướng dẫn lựa chọn mẫu thử được nêu trong Phụ lục D.

Phụ lục C và Phụ lục D cho phép thực hiện nhiều đánh giá khác nhau, tùy thuộc vào việc nhà sản xuất muốn thực hiện thử nghiệm hạn chế hay mở rộng. Mỗi gói thử nghiệm chỉ ra số lượng mẫu thử tối thiểu cần thiết cho phạm vi đã cho.

### Cấu kiện thử nghiệm để đánh giá khả năng bám dính

Phương pháp để xác định việc hiệu chỉnh khả năng bám dính phụ thuộc vào phạm vi của gói thử nghiệm và hệ bọc bảo vệ.

Hướng dẫn lựa chọn cho vật liệu bảo vệ dạng thụ động được nêu trong Phụ lục C. Hướng dẫn cho vật liệu bảo vệ dạng phản ứng được nêu trong Phụ lục D.

### Yêu cầu cho phân tích nhiệt

Ngoài các yêu cầu, sẽ cần có một phạm vi các cấu kiện tiết diện chữ I không chịu tải mà không phụ thuộc vào phương pháp phân tích được sử dụng. Các cấu kiện này sẽ được chọn để bao được phạm vi chiều dày bảo vệ, hệ số tiết diện và khoảng thời gian chịu lửa và cũng bao gồm cấu kiện ngắn tham chiếu tương đương với cấu kiện chịu tải hoặc cấu kiện cao.

Các cấu kiện ngắn và cao sẽ được yêu cầu bổ sung để phân tích với cấu kiện tiết diện rỗng được lựa chọn tương tự để kể đến các yếu tố về chiều dày bảo vệ, hệ số tiết diện và khoảng thời gian chịu lửa

Lựa chọn mẫu thử nghiệm được xác định bởi phạm vi đánh giá cần thiết đối với sản phẩm bảo vệ. Điều này sẽ dựa trên phạm vi hệ số tiết diện (lớn nhất và nhỏ nhất) và phạm vi chiều dày (lớn nhất và nhỏ nhất) cho từng khoảng thời gian chịu lửa. Các hệ số phạm vi sẽ có giá trị lớn nhất là 1,0 và giá trị nhỏ nhất 0,0 và sẽ được xác định bởi nhà sản xuất.

Lựa chọn mẫu cho vật liệu bảo vệ dạng thụ động được nêu trong Phụ lục D. Đối với vật liệu bảo vệ phản ứng, Lựa chọn mẫu trong Phụ lục E.

# Lắp đặt mẫu thử nghiệm 

## Dầm chịu tải

Các tấm sàn bê tông nhẹ hoặc bê tông khí phải được dùng làm lớp bê tông trên cùng, được bắt vít vào dầm bằng bu lông có đường kính 12 mm. Chỉ có hai mặt bên và mặt dưới của dầm được tiếp xúc với nhiệt, như thể hiện trong Hình 1. Các tấm sàn phải có các đặc tính sau:

  * Chiều rộng dọc theo dầm là 600 mm ± 100 mm.

  * Chiều dày tấm sàn trong khoảng 150 mm đến 200 mm.

  * Chiều dài tối đa là 625 mm.

  * Khối lượng riêng danh nghĩa của các tấm sàn dạng bê tông khí là 500 kg/m3.

  * Khối lượng riêng danh nghĩa của các tấm sàn bê tông nhẹ là 1 500 kg/m3.

  * Tấm sàn bê tông phải có khoảng cách giữa chúng đủ lớn cho phép dầm chịu uốn.

  * Phải có một lớp vật liệu cách nhiệt chịu nén bằng sợi gốm giữa lớp bê tông nhẹ và bản cánh trên của dầm. Lớp vật liệu cách nhiệt có cấp A1 được xác định theo tiêu chuẩn EN 13501-1 và chịu được nhiệt độ thấp nhất là 1 0000C. Độ dày khi không nén là 30 mm ± 5 mm và có khối lượng riêng danh nghĩa là 125 ± 25 kg/m3 . Lớp cách nhiệt có chiều rộng bằng chiều rộng mặt trên của dầm thép (xem Hình 1).


Vật liệu cách nhiệt thay thế cấp A1 được xác định theo tiêu chuẩn ISO 1182:2010, (1) và tiêu chuẩn ISO 1716 có thể được sử dụng với điều kiện có đặc tính tương tự về nhiệt và chiều dày so với tấm cách nhiệt bằng sợi bông gốm.
Các bộ phận của lớp bê tông nhẹ phía trên phải được liên kết bu lông vào dầm thông qua đinh chống cắt có đường kính thích hợp được hàn vào dầm. Phải có một tấm thép đệm thích hợp bên dưới đai ốc khóa. Các đinh chống cắt này có thể được đặt trong phần tiếp giáp giữa mỗi cấu kiện của lớp mặt bê tông phía trên hoặc trong nằm chiều dài của lớp tấm bê tông (xem Hình 1; cố định trong chiều dài của lớp tấm).
Mỗi cấu kiện của lớp bê tông phải được cố định ít nhất tại 2 vị trí. Khoảng hở giữa các cấu kiện của lớp bê tông phải được lấp đầy bằng vật liệu chống cháy.
Tại thời điểm bắt đầu thử nghiệm, mặt dưới của lớp bê tông phủ trên mặt dầm chịu tải về danh nghĩa phải bằng với mặt dưới của các tấm nắp lò liền kề.
Việc bố trí mẫu thử, phù hợp với điều kiện phòng thí nghiệm, cần đảm bảo rằng khe hở giữa lớp bê tông phủ trên mặt dầm chịu tải và các tấm nắp lò liền kề được bịt kín để tránh thoát khí lò ra ngoài, đặc biệt khi dầm bị biến dạng trong quá trình thử nghiệm. Dầm chịu tải phải được lắp đặt với yêu cầu các gối đỡ của dầm phải được cách nhiệt.
Ngoài ra, các đầu dầm chịu tải bên ngoài lò phải được cách nhiệt và có đủ khe hở giữa mặt dưới của lớp bảo vệ và thành lò để ngăn cản ảnh hưởng.

## Dầm không chịu tải

Mỗi mẫu thử nghiệm dầm không chịu tải phải được bắt bu lông vào mặt dưới của các tấm nắp lò làm từ cùng một loại bê tông được sử dụng làm lớp phủ lên dầm có tải. Phải có một tấm thép thích hợp bên dưới đai ốc khóa của bu lông.
Mỗi mẫu thử phải được cung cấp một lớp cách nhiệt bằng sợi gốm được đặt giữa mặt dưới nắp lò và bản cánh trên của dầm như quy định trong 8.1 đối với dầm chịu tải và Hình 2.
Các vật liệu cách nhiệt thay thế (Loại A1) có thể được sử dụng với điều kiện chúng có các thông số về nhiệt và độ dày tương tự như lớp cách nhiệt bằng sợi gốm đã chỉ định.

Các dầu dầm phải được cách nhiệt bằng các vật liệu cách nhiệt cứng hoặc vật liệu cách nhiệt đàn hồi.

Xem cấu tạo chi tiết tại hình 2.

## Cột chịu tải

Mẫu thử nghiệm cột chịu tải được bố trí lắp đặt như Hình 3 và được mô tả trong tiêu chuẩn TCVN 9311-7.

## Cột không chịu tải

Mẫu thử nghiệm cột cao và cột ngắn phải được liên kết bu lông vào mặt dưới của tấm nắp lò bê tông nhẹ [mô tả trong 6.2.5, sử dụng đinh chống cắt đường kính 10 mm hàn vào cấu kiện cột và có các tấm (100 × 100 × 6) mm nằm dưới có đai ốc khóa] hoặc đặt trên sàn lò nung (trực tiếp hoặc trên bệ).

Cách nhiệt dạng sợi phù hợp như mô tả trong 8.1 được sử dụng giữa các bề mặt tiếp xúc của cột và tấm nắp lò, hoặc sàn lò, hoặc bệ đỡ để tránh truyền nhiệt qua các đầu của cấu kiện.

Kích thước của vật liệu cách nhiệt không nhỏ hơn kích thước tổng thể của cấu kiện thép được bảo vệ chống cháy.

## Bố trí lắp đặt mẫu thử nghiệm

Đối với mỗi thử nghiệm cho một dầm hoặc một cột chịu tải, một dầm hoặc cột tương đương không chịu tải phải được đưa vào và thử nghiệm trong lò cùng một lúc.

Đối với mỗi dầm chịu tải, dầm tham chiếu tương đương phải được bố trí song song và ở giữa nhịp của dầm chịu tải.

Mỗi cột cao và cấu kiện cột tham chiếu tương đương không chịu tải của nó phải được lắp đặt trong lò cùng một lúc và được thử nghiệm cùng nhau nếu có thể.

Các cấu kiện phải được định vị trong lò để đảm bảo chúng không bị che chắn hoặc bị ảnh hưởng bởi thành lò, các mẫu thử khác và các chướng ngại vật. Khoảng cách tối thiểu đến mẫu thử là 300 m hoặc bằng chiều cao của bản bụng dầm nếu chiều cao của dầm lớn hơn 300 mm. Lắp đặt mẫu thử điển hình có thể sử dụng được trong lò nung 4 m x 3 m

# Public_024

# THỰC PHẨM LÀ GÌ?

Khái niệm thực phẩm (food) liên quan đến các loại thức ăn và thức uống của con người. Nhìn từ góc độ hóa học, thực phẩm là một hỗn hợp các chất hóa học có nguồn gốc từ thực vật và động vật, được con người sử dụng qua đường tiêu hóa nhằm mục đích chủ yếu là dinh dưỡng.  
Trong thực phẩm, các hợp chất hữu cơ là những thành phần chủ yếu.

Thực phẩm rất đa dạng về chủng loại. Một số loại thực phẩm rất phổ biến và được sử dụng khắp nơi trên thế giới, ví dụ như sữa, đường saccharose... Tuy nhiên, mỗi địa phương, khu vực, tùy theo điều kiện địa lý và thói quen ẩm thực, sẽ có những sản phẩm thực phẩm truyền thống và đặc trưng riêng, ví dụ như natto của Nhật Bản, kim chi của Hàn Quốc, chả giò của Việt Nam...  
Hiện nay, cùng với vấn đề toàn cầu hóa, sự phát triển du lịch, giao lưu văn hóa và khoa học công nghệ giữa các nước, người dân trên thế giới có điều kiện tìm hiểu về các loại thực phẩm đặc trưng của nhiều quốc gia khác nhau.  
Ngoài ra, cần lưu ý rằng theo thời gian, con người sáng tạo và chế biến thêm nhiều sản phẩm thực phẩm mới từ các nguyên liệu sẵn có. Do đó, chúng ta không thể thống kê đầy đủ tên các sản phẩm thực phẩm hiện có của một vùng miền hay một quốc gia.

# PHÂN LOẠI THỰC PHẨM

Có nhiều phương pháp để phân loại thực phẩm, dựa trên những nguyên lý khác nhau. Dưới đây là ba phương pháp phổ biến:

## Phân loại thực phẩm theo thành phần hóa học

Thực phẩm có thể được chia thành bốn nhóm chính: thực phẩm giàu glucid, thực phẩm giàu protein, thực phẩm giàu lipid và thực phẩm dạng hỗn hợp.

Một sản phẩm thực phẩm bất kỳ thường chứa nhiều hợp chất hóa học khác nhau. Trong phương pháp phân loại thực phẩm theo thành phần hóa học, người ta dựa vào hợp chất có hàm lượng cao nhất trong thực phẩm (trừ nước) để phân loại sản phẩm.

### Thực phẩm giàu glucid

Glucid được chia thành hai nhóm cơ bản: nhóm có phân tử lượng thấp và nhóm có phân tử lượng cao.

  * **Nhóm glucid có phân tử lượng thấp** bao gồm các loại đường như glucose, fructose, saccharose, lactose, maltose và các loại oligosaccharide khác. Ví dụ thực phẩm giàu glucid phân tử lượng thấp: mật ong, đường mía, kẹo caramel...

  * **Nhóm glucid có phân tử lượng cao** gồm tinh bột, cellulose, hemicellulose, pectin, agar và một số loại polysaccharide khác. Tinh bột là polysaccharide quan trọng trong dinh dưỡng người. Tinh bột có nhiều trong các loại ngũ cốc (lúa mì, lúa mạch, gạo, bắp, đại mạch...) và các loại củ (khoai tây, khoai mì, khoai lang...). Cellulose là một chất xơ quan trọng, có nhiều trong rau.  
Ví dụ thực phẩm giàu glucid phân tử lượng cao phổ biến ở Việt Nam: bánh mì, bánh biscuit, mì sợi, các loại bún từ gạo, rau câu...


### Thực phẩm giàu protein

Protein có nhiều trong nguyên liệu động vật (thịt, thủy sản) và một số nhóm nguyên liệu thực vật (các loại đậu, nấm mũ...). Ví dụ: thịt, cá đóng hộp; khô thịt, cá; nấm rơm đóng hộp...

### Thực phẩm giàu lipid

Cùng với glucid và protein, lipid là một trong ba thành phần bắt buộc trong khẩu phần ăn hàng ngày. Ví dụ: dầu thực vật, bơ, margarine...

### Thực phẩm dạng hỗn hợp

Một số thực phẩm mà tỷ lệ khối lượng của các thành phần hóa học chính (trừ nước) gần như tương đương nhau được xếp vào nhóm thực phẩm dạng hỗn hợp. Ví dụ: sữa bò tươi, trong đó glucid, protein và lipid có tỷ lệ gần như tương đương.

Cần lưu ý ngoài glucid, protein và lipid, khẩu phần ăn hàng ngày của con người cần cung cấp thêm vitamin, khoáng, nước và một số hợp chất khác.

## Phân loại thực phẩm theo mục đích sử dụng

### Mục đích dinh dưỡng

Hầu hết các loại thực phẩm được sử dụng nhằm mục đích chủ yếu là dinh dưỡng. Thành phần trong thực phẩm khi đưa vào cơ thể sẽ được chuyển hóa thành năng lượng sinh học (ATP) và vật chất tế bào, giúp cơ thể tồn tại và phát triển.  
Ngày nay, một số thực phẩm được chế biến để ngoài mục đích dinh dưỡng còn có các mục đích khác. Ví dụ tại Việt Nam, các nhà sản xuất dùng khái niệm “thực phẩm dinh dưỡng” cho nhóm giàu năng lượng hoặc bổ sung vitamin, khoáng chất.

### Mục đích phòng và trị bệnh

Một số thực phẩm có chứa các thành phần hóa học đặc biệt, giúp phòng ngừa hoặc điều trị một số bệnh, được gọi là **thực phẩm chức năng (functional food)**. Theo Gibson Œ.R. et al. (2000), thực phẩm chức năng vừa cung cấp giá trị dinh dưỡng thông thường, vừa tác động có lợi đến một hay nhiều chức năng cơ thể nhằm tăng cường sức khỏe hoặc giảm nguy cơ bệnh tật.

Ví dụ: nhóm thực phẩm phòng bệnh như sữa bột giàu canxi để ngừa loãng xương, gia vị - nước mắm bổ sung iod để ngừa bướu cổ. Nhóm thực phẩm trị bệnh như nhân sâm (Panax ginseng C.A. Meyer) có các saponin kháng khuẩn, kháng viêm, chống khối u; hoặc phô mai chứa peptide sinh học và probiotic có tác dụng điều trị một số bệnh.

Lưu ý: thực phẩm chức năng khác thuốc, liều dùng phải cân đối trong khẩu phần, tác dụng thường chậm hơn thuốc.

##  Các mục đích sử dụng khác

Một số người coi ăn uống là thú vui, thư giãn, không quan tâm đến dinh dưỡng hay phòng bệnh. Ví dụ: uống trà vào buổi sáng tại Việt Nam là thói quen lâu đời, không chỉ để giải khát hay dinh dưỡng.

### Thực phẩm tươi

Thực phẩm tươi là thực phẩm không qua chế biến hoặc chế biến tối thiểu, không làm thay đổi đáng kể thành phần hóa học và giá trị cảm quan so với nguyên liệu ban đầu. Ví dụ: trái cây tươi, rau tươi, sữa tươi.  
**Chế biến tối thiểu (minimal processing)** nhằm bảo đảm chất lượng và tiện dụng, ví dụ: trái cây bóc vỏ, cắt miếng, bảo quản lạnh.

### Thực phẩm chế biến ở quy mô gia đình

Được chế biến trong bếp gia đình hoặc nhà hàng, khách sạn (tôm rim, thịt kho, cá chiên, canh chua, rau xào...). Quy trình phụ thuộc kinh nghiệm người chế biến, chất lượng có thể không đồng đều.

### Thực phẩm chế biến ở quy mô công nghiệp

Chế biến trong nhà máy quy mô lớn, áp dụng khoa học công nghệ, kiểm soát nghiêm ngặt chất lượng nguyên liệu, bán thành phẩm và thành phẩm. Ví dụ: mì ăn liền, bánh biscuit, đường saccharose, cà phê hòa tan, paté đóng hộp, xúc xích tiệt trùng.

# CÁC CHỈ TIÊU CHẤT LƯỢNG CỦA THỰC PHẨM

Chất lượng thực phẩm được đánh giá dựa trên nhiều chỉ tiêu. Có thể phân loại theo hai cách:

## Theo lĩnh vực khoa học tự nhiên

Chia thành vật lý, hóa học, hóa lý, sinh học và hóa sinh.

### Chỉ tiêu vật lý

  * Thực phẩm rắn: hình dạng, kích thước, khối lượng, độ giòn, dẻo, dai...

  * Thực phẩm lỏng: thể tích, tỷ trọng...


### Chỉ tiêu hóa học

#### Chất dinh dưỡng

Bao gồm nước, glucid, protein, lipid, vitamin, khoáng, acid trong thực phẩm. Ví dụ: nước cam đóng hộp - hàm lượng chất khô, độ chua, đường, vitamin C; mì sợi - độ ẩm, tinh bột, protein, độ chua.

#### Phụ gia và chất hỗ trợ kỹ thuật

  * **Phụ gia:** chất màu, mùi, ức chế vi sinh vật, chống oxy hóa, nhũ hóa, tạo cấu trúc, tạo vị...

  * **Chất hỗ trợ kỹ thuật:** phá bọt, trợ lọc, trợ lắng, hiệu chỉnh pH, xúc tác...


#### Các chất khác

  * **Tác dụng tốt:** hợp chất sinh học như alkaloid, flavonoid, glycoside.

  * **Tác dụng xấu:** độc tố sinh ra từ nguyên liệu hoặc trong chế biến.  
Ví dụ: khoai mì chứa HCN, nước tương nếu xúc tác bằng HCl có thể tạo 3-MCPD.


### Chỉ tiêu hóa lý

Liên quan hệ phân tán: nhũ tương, huyền phù, bọt, độ hòa tan, khả năng hấp phụ hơi nước.

### Chỉ tiêu sinh học

  * **Liên quan dinh dưỡng:** giá trị năng lượng, hệ số hấp thu protein NN.

  * **Vi sinh vật:** tổng số vi sinh vật hiếu khí, nấm men, nấm sợi, vi sinh vật gây bệnh.


### Chỉ tiêu hóa sinh

Hoạt tính enzyme ảnh hưởng thành phần hóa học. Ví dụ: phosphatase và lactoperoxidase trong sữa thanh trùng.

### Chỉ tiêu bao bì

Hình dạng, kích thước, khối lượng, vật liệu, độ kín, thông tin in trên bao bì, giá trị thẩm mỹ.

## Theo cơ sở khoa học của phương pháp phân tích

Chia thành hóa lý, sinh học, cảm quan.

### Chỉ tiêu hóa lý

Định lượng bằng thiết bị phân tích. Ví dụ: độ giòn bằng lực, hàm lượng hương bằng sắc ký khí, mức độ phân bố pha phân tán bằng nhiễu xạ laser, hoạt tính enzyme bằng quang phổ.

### Chỉ tiêu sinh học

Định lượng bằng phương pháp sinh học (nuôi cấy vi sinh, thực nghiệm in vivo).

### Chỉ tiêu cảm quan

Đánh giá bằng giác quan: màu sắc, độ trong, mùi, vị.

# NHỮNG VẤN ĐỀ QUAN TÂM CỦA NGƯỜI TIÊU DÙNG VỀ CHẤT LƯỢNG THỰC PHẨM

## An toàn thực phẩm

Thực phẩm phải đảm bảo an toàn tuyệt đối. Ngưỡng hàm lượng độc tố được quy định và có thể khác nhau giữa các quốc gia. Ở các nước phát triển, ngưỡng này thường thấp hơn ở các nước đang phát triển.

# Public_025

# Cơ sở khoa học

Chiếu xạ là một quá trình vật lý. Người ta sử dụng tia bức xạ điện từ hoặc dòng electron để tác động lên các mẫu thực phẩm. Khi thực phẩm hấp thụ năng lượng từ tia bức xạ điện từ hoặc dòng electron, sẽ xảy ra một số biến đổi có lợi cho chất lượng của sản phẩm.

Tia bức xạ điện từ gồm nhiều loại như tia X, tia gamma, tia beta... Hiện nay, tia gamma được sử dụng phổ biến trong sản xuất công nghiệp.

Ứng dụng của phương pháp chiếu xạ đã được phát hiện từ đầu thế kỷ XX. Năm 1930, nhà khoa học người Đức Wurt O. đã đăng ký bằng sáng chế tại Pháp về việc sử dụng phương pháp chiếu xạ để tiệt trùng thực phẩm. Tuy nhiên, lúc bấy giờ chiếu xạ được xem là một “phương pháp nhạy cảm”. Người ta lo lắng không biết thực phẩm đã qua chiếu xạ có chứa các chất phóng xạ gây nguy hiểm cho sức khỏe hay không. Sau một thời gian dài nghiên cứu, các nhà khoa học nhiều nước trên thế giới kết luận: chiếu xạ là một phương pháp an toàn trong công nghiệp thực phẩm nếu sử dụng liều thích hợp tương ứng với từng loại thực phẩm. Ngày nay, nhiều quốc gia trên thế giới cho phép sử dụng chiếu xạ trong công nghiệp thực phẩm, trong đó có nhiều nước công nghiệp phát triển như Mỹ, Canada, Anh, Pháp, Đức, Hà Lan, Bỉ, Đan Mạch, Nga, Nhật, Australia... Việt Nam cũng nằm trong danh mục các nước cho phép sử dụng chiếu xạ trong công nghiệp thực phẩm.

Giá trị năng lượng mà tia bức xạ điện từ hoặc dòng electron truyền cho thực phẩm được gọi là **liều xạ** (irradiation dose). Trong hệ SI, liều xạ có đơn vị đo là **Gy (Gray)** , với:

1 Gy=10−2 kGy=10−5 MGy1 \text{ Gy} = 10^{-2} \text{ kGy} = 10^{-5} \text{ MGy}

Các tổ chức thế giới đã quy định liều xạ tối đa được phép sử dụng cho từng loại thực phẩm.

# Mục đích công nghệ và phạm vi thực hiện

## Bảo quản

Quá trình chiếu xạ có thể kéo dài thời gian bảo quản một số loại thực phẩm do nhiều nguyên nhân khác nhau:

  * Chiếu xạ sẽ ức chế hoặc tiêu diệt một số loại côn trùng, sâu bọ và vi sinh vật. Sự hư hỏng của thực phẩm bởi các tác nhân này, đặc biệt là vi sinh vật, có thể xảy ra rất nhanh. Do đó, việc làm giảm mật độ vi sinh vật sẽ gia tăng thời hạn sử dụng sản phẩm. Quá trình chiếu xạ được sử dụng phổ biến trong công nghệ sau thu hoạch trái cây và rau tươi, ngũ cốc, thịt và thủy sản tươi. Ngoài ra, chiếu xạ còn được sử dụng trong sản xuất một số loại bột gia vị (tiêu bột, ớt bột...) và các loại bột trái cây, bột rau (ví dụ: bột măng tây khô).

  * Khi chiếu xạ với liều lượng thích hợp, quá trình chín sau thu hoạch và quá trình lão hóa ở một số loại trái cây sẽ bị chậm lại, ví dụ: chuối, xoài, đu đủ. Quá trình chiếu xạ làm chậm quá trình trao đổi chất trong các loại trái cây này, kéo dài thời gian bảo quản mà không phụ thuộc hoàn toàn vào việc ức chế vi sinh vật.

  * Chiếu xạ có thể gây ức chế sự nảy mầm ở một số loại thực vật như khoai tây, củ hành, tỏi, gừng. Nhờ đó, thời gian bảo quản những nguyên liệu này được kéo dài, giảm tỷ lệ tổn thất do nảy mầm.


## Chuẩn bị

Chiếu xạ có thể được xem là một quá trình chuẩn bị nguyên liệu cho các giai đoạn khai thác và chế biến:

  * Khi chiếu xạ đại mạch với liều thấp (10–100 Gy), sự nảy mầm của hạt được kích thích, giúp quá trình ươm mầm diễn ra thuận lợi và nhanh hơn. Chiếu xạ được xem là bước chuẩn bị cho quá trình ươm mầm trong sản xuất malt.

  * Khi chiếu xạ nho với liều 2–7 kGy, quá trình ép thu nhận dịch nho diễn ra dễ dàng hơn, hiệu suất thu hồi chất chiết trong nước nho tăng cao so với mẫu đối chứng không qua chiếu xạ. Quá trình chiếu xạ nho được xem là bước chuẩn bị cho sản xuất nước ép trái cây hoặc rượu vang.


## Hoàn thiện

Chiếu xạ có thể cải thiện một số chỉ tiêu chất lượng sản phẩm. Ví dụ, trong công nghệ sản xuất súp ăn liền, chiếu xạ sẽ làm gãy mạch một số phân tử carbohydrate dài, nhờ đó chúng dễ hydrat hóa hơn khi pha với nước, cải thiện chất lượng súp.

Hiện nay, mục đích chính của chiếu xạ thực phẩm vẫn là **kéo dài thời gian bảo quản sản phẩm**.

# Các biến đổi của nguyên liệu

## Vật lý

Khi chiếu tia gamma hoặc dòng electron lên mẫu thực phẩm, các photon hoặc electron trong chùm chiếu sẽ tác động lên các hạt vật chất của nguyên tử. Nguyên tử gồm proton, neutron và electron. Proton và neutron nằm trong nhân, electron chuyển động quanh hạt nhân theo quỹ đạo xác định. Với liều xạ sử dụng trong công nghiệp thực phẩm, photon và electron của chùm chiếu không tác động đến proton và neutron; chúng chỉ tác động lên electron của nguyên tử.

**Sử dụng tia gamma:**  
Khi photon gamma chiếu vào thực phẩm, có thể xảy ra hai trường hợp:

  1. Photon xuyên qua mẫu, truyền một phần năng lượng.

  2. Photon bị hấp thu toàn bộ năng lượng.


Hai kiểu tương tác giữa photon và electron:

  * **Hiệu ứng quang điện (Photoelectric effect):**  
Photon tác động lên electron, tách electron ra khỏi nguyên tử, photon biến mất. Nguyên tử mất electron bị ion hóa và electron thứ cấp được sinh ra. Electron thứ cấp tiếp tục gây ion hóa các electron khác.


  * **Hiệu ứng Compton:**  
Photon tác động tách electron, nhưng photon vẫn tồn tại với năng lượng giảm và quỹ đạo thay đổi. Photon và electron thứ cấp đều có thể tiếp tục tương tác với các electron khác.


**Sử dụng dòng electron:**  
Electron từ nguồn chiếu tác động lên electron của nguyên tử trong mẫu (tương tác Coulomb), dẫn đến:

  1. Tách electron ra khỏi nguyên tử → tạo electron thứ cấp, ion hóa nguyên tử.

  2. Thay đổi quỹ đạo electron → nguyên tử bị kích thích.


**Lưu ý:** Khả năng xuyên qua của tia gamma cao hơn dòng electron, là lý do phổ biến trong chiếu xạ thực phẩm.

## Hóa học

### Nước

Phân tử nước có thể biến đổi qua:

  * **Ion hóa:**


  * **Kích thích:**


Các gốc tự do (H·, OH·) có thể phản ứng tạo ra hợp chất mới:

### Polysaccharide

Các polysaccharide như tinh bột, pectin, cellulose, hemicellulose... có thể bị gãy mạch, tạo sản phẩm phân tử thấp.

  * Lợi: trong súp ăn liền, polysaccharide gãy → dễ hydrat hóa, cải thiện chất lượng.

  * Hại: chiếu xạ trái cây tươi liều cao → làm mềm trái cây, giảm giá trị cảm quan.


### Protein

Với liều xạ cho phép, protein hầu như không thay đổi về cấu trúc và tính chất hóa học. Liều thấp cũng không ảnh hưởng hàm lượng acid amin tự do.

### Lipid

Trong điều kiện có oxy, acid béo, đặc biệt là không no, dễ oxy hóa. Gốc tự do sinh ra từ phân tử nước và các hợp chất khác phản ứng với acid béo không no, tạo aldehyde, ketone, hydrogen peroxide… ảnh hưởng xấu đến giá trị dinh dưỡng và cảm quan.

### Khoáng

Các hợp chất khoáng không biến đổi đáng kể.

### Vitamin

Mức độ tổn thất phụ thuộc liều xạ:

  * Liều 1 kGy: nhóm trái cây có múi không mất vitamin C.

  * Liều 2–4 kGy: lượng vitamin C giảm mạnh.


### Acid nucleic

Biến đổi DNA/RNA:

  * Gãy mạch phân tử, tạo nhánh hoặc cả hai nhánh.

  * Hydroxyl hóa các base (A, T, G, C, U).

  * Phân hủy đường ribose/desoxyribose.

  * Tạo cầu nối ngẫu nhiên giữa các mạch DNA.


### Các hợp chất khác

Các hợp chất sinh học, màu, mùi… thay đổi tùy liều xạ. Ví dụ, carotenoids trong đu đủ 1,5 kGy không biến đổi đáng kể.

## Hóa lý

Chiếu xạ không ảnh hưởng trạng thái pha của thực phẩm.

## Sinh học

Chiếu xạ làm biến đổi acid nucleic → ảnh hưởng cấu trúc nhân tế bào vi sinh vật.

  * Tế bào vi sinh vật có hệ enzyme (ligase, exonuclease, polymerase…) sửa chữa DNA, duy trì trao đổi chất.

  * Nếu tổn thương quá lớn → tế bào chết hoặc không sinh sản được.

  * Có thể gây đột biến ở một số vi sinh vật.

  * Chiếu xạ còn tổn thương phospholipid màng tế bào, làm giảm vận chuyển chất, giảm hoạt tính trao đổi chất hoặc gây chết vi sinh vật.


Khả năng tiêu diệt vi sinh vật của tia gamma phụ thuộc loài. **Liều xạ phá hủy thập phân** : liều cần thiết để giảm số vi sinh vật xuống 10 lần.

# Public_026

# KHÁI NIỆM CHUNG

Vật liệu dệt là một ngành chuyên môn nghiên cứu **về cấu tạo, tính chất của các loại xơ, sợi và chế phẩm dệt** , cùng những phương pháp xác định cấu tạo và các tính chất đó.

Đối tượng nghiên cứu của vật liệu dệt bao gồm tất cả các loại xơ và sản phẩm làm ra từ xơ, như: sợi đơn (sợi con), sợi xe, chỉ khâu, hàng dệt kim, các loại dây lưới… Ngoài những sản phẩm kể trên có thể sử dụng trực tiếp, vật liệu dệt còn bao gồm các loại bán thành phẩm chưa dùng trực tiếp được như quả hông, cứu, sợi thô.

Hiểu biết về đặc trưng cấu tạo và tính chất của vật liệu dệt có liên quan trực tiếp đến việc sản xuất các loại hàng dệt **có phẩm chất đáp ứng yêu cầu sử dụng** , cũng như thực hiện các biện pháp tiết kiệm, hợp lý trong sản xuất (ví dụ: đay có tính hút ẩm tốt và xơ bền nên dùng để sản xuất các loại bao bì đựng đường, muối rất thích hợp).

Nghiên cứu cấu tạo và tính chất của vật liệu dệt còn có ý nghĩa trong việc **thiết lập tiêu chuẩn thử nghiệm ngành dệt** , quy định phương pháp chọn mẫu thí nghiệm, kiểm tra chất lượng sản phẩm, quy định về hình thức, kích thước của chế phẩm và bán chế phẩm.

Các loại xơ, sợi và chế phẩm dệt được sử dụng rộng rãi trong thực tế sản xuất và đời sống hàng ngày. Ngoài việc may mặc, vải còn được dùng trong công nghiệp, y tế và các lĩnh vực sinh hoạt văn hóa, xã hội. Ví dụ: vải may quần áo chống nóng dùng trong luyện kim, trang phục bảo hộ cứu hỏa, lưới đánh cá, các loại dây, chỉ khâu trong y tế, vải dù, dây dù, vải bạt trong quân đội, vải che phủ thiết bị máy móc và làm lán trại.

Theo số liệu thống kê ở nhiều nước, chế phẩm dệt bằng vật liệu dệt được sử dụng như sau:


| Mục đích sử dụng | Tỷ lệ (%) |
| --- | --- |
| May mặc | 35–40 |
| Nội trợ, sinh hoạt | 20–25 |
| Mục đích kỹ thuật | 30–35 |
| Các công việc khác (bao gói, văn hóa phẩm, y tế…) | ~10 |

 

Sản lượng các loại xơ, sợi dệt trên thế giới tăng nhanh trong những thập kỷ gần đây, đặc biệt là sản xuất các loại xơ tổng hợp.

# PHÂN LOẠI VẬT LIỆU DỆT

Các loại xơ, sợi được liệt kê trên có thể thay đổi tùy theo từng nước, phụ thuộc vào điều kiện công nghiệp phát triển, khí hậu và chế độ xã hội. Vật liệu dệt được phân biệt dựa theo **hình dạng, đặc trưng cấu tạo và tính chất** , vì vậy chế phẩm dệt sản xuất ra cũng được phân loại theo nguyên liệu.

Để nghiên cứu tính chất vật liệu dệt thuận tiện, cần tiến hành phân loại. **Nguyên tắc phân loại vật liệu dệt** dựa vào: kết cấu đặc biệt, phương pháp sản xuất, thành phần hóa học của các loại xơ.

Trong phân loại vật liệu dệt, bao gồm: **xơ, sợi và chế phẩm dệt**.

## XƠ DỆT

### Khái niệm

Xơ là những vật thể mềm dẻo, giãn nở (bông, len), nhỏ bé, dùng để làm sợi, vải. Chiều dài đo bằng milimet (mm), kích thước ngang đo bằng micromet (µm).

### Phân loại

Phần lớn xơ dệt có cấu tạo thuộc dạng liên kết cao phân tử. Tuy nhiên, do nguồn gốc, thành phần cấu tạo và phương pháp tạo xơ khác nhau, mỗi loại xơ được chia thành các nhóm riêng biệt theo nguồn gốc.

**Các loại xơ:**

  1. **Xơ thiên nhiên:** Hình thành trong điều kiện tự nhiên từ các chất hữu cơ. Gồm:


  * **Xơ cơ bản:** Không phá vỡ theo chiều dọc xơ thì không thể chia nhỏ.

  * **Xơ kỹ thuật:** Ghép nhiều xơ cơ bản lại với nhau (xơ lay).


**Xơ thiên nhiên chia thành:**

  * **Xơ thực vật:** Thành phần chủ yếu là xenlulozơ, ví dụ: xơ hồng (từ quả hồng), xơ tẩy, gel, lanh (từ thân cây).

  * **Xơ động vật:** Thành phần chủ yếu là protein, ví dụ:

* Xơ len: keratin chiếm 50%

* Xơ tơ tằm: fibroin chiếm 75%, sericin 25%

  * **Xơ khoáng vật:** Tạo từ chất vô cơ thiên nhiên, ví dụ xơ trăng.


  2. **Xơ hóa học:** Hình thành trong điều kiện nhân tạo.


  * **Xơ nhân tạo:** Tạo từ chất hữu cơ thiên nhiên, ví dụ:

* Nhóm xơ từ hydrat xenlulozơ: viscose, cuprammonium…

* Nhóm xơ từ axetyl xenlulozơ: cellulose acetate, triacetate

* Nhóm xơ từ mô tơ tự nhiên: capron, đen

  * **Xơ tổng hợp:** Tạo từ chất tổng hợp, phổ biến nhất hiện nay, ví dụ: polyester, polyamide, polyacrylonitrile.


Xơ hóa học được sản xuất dưới nhiều dạng: xơ staple, sợi cơ bản, sợi phức. Quá trình sản xuất: nguyên liệu (từ thiên nhiên hoặc tổng hợp) chế biến thành dung dịch hoặc trạng thái nóng chảy, ép qua ống định hình sợi (lỗ nhỏ tùy yêu cầu sản xuất), tạo sợi cơ bản. Sợi cắt đoạn gọi là xơ staple (thường 40–15 mm). Có thể tạo sợi đơn dùng trực tiếp cho chế phẩm như lưới đánh cá, bít tất mỏng.

## SỢI DỆT

Sợi là sự liên kết của các xơ có kích thước nhỏ, mềm, uốn dẻo và bền. Chiều dài sợi được xác định trong quá trình gia công.

### Phân loại theo cấu trúc

#### **Loại sợi thứ nhất:** Dạng sợi nhận trực tiếp sau quá trình kéo sợi:

  * **Sợi con (sợi đơn):** Nhiều xơ cơ bản ghép và xoắn lại (ví dụ: sợi bông, sợi len). Chiếm ~85% sản lượng thế giới.

* **Sợi trơn:** Kết cấu và màu sắc đồng đều.

* **Sợi hoa:** Kết cấu không đồng đều, chỗ dày mỏng khác nhau, nhiều màu sắc do quá trình sản xuất.

  * **Sợi phức:** Nhiều sợi cơ bản liên kết bằng xoắn hoặc dính, thường là sợi hóa học (trừ sợi tơ tằm).

  * **Sợi cử:** Tạo bằng cách xe xoắn các dải băng (giấy, nhựa, kim loại).


#### **Loại sợi thứ hai:** Ghép và xoắn các loại sợi thứ nhất thành sợi xe.

### Phân loại theo nguyên liệu và thiết bị kéo sợi

  1. **Sợi chỉ thường (chải thô):** Nguyên liệu xơ trung bình, kéo trên dây chuyền máy chải thô, cho sợi chất lượng trung bình (sợi bông, sợi đay).

  2. **Sợi chỉ kỹ:** Nguyên liệu xơ dài, tốt, kéo trên dây chuyền máy chủ thôn và chủ kỹ, sản xuất sợi chất lượng cao (sản xuất chỉ khâu, hàng dệt kim, vải cao cấp).

  3. **Sợi chi liên hợp:** Nguyên liệu xơ ngắn, chất lượng thấp, xơ phế liệu trộn, kéo trên dây chuyền nhiều máy, tạo sợi xốp dùng dệt chăn, mền, đồ nội thất.


### Phân loại theo quá trình sản xuất và sử dụng

  * **Sản phẩm mộc:** Xơ, sợi hay vải còn ở dạng nguyên liệu chưa xử lý hóa lý, dùng làm phụ liệu hoặc nguyên liệu cho ngành sản xuất khác. Ví dụ: sợi đưa vào sản xuất chỉ khâu là sợi mộc từ máy xe và máy quấn ống.

  * **Sản phẩm hoàn tất:** Xơ, sợi hay vải đã qua xử lý hóa lý (nấu, tẩy, nhuộm, in, định hình nhiệt, tẩm hóa chất chống nhăn, chống thấm). Sản phẩm hoàn tất được bày bán rộng rãi. Ngành may sử dụng chủ yếu **vải hoàn tất** và **chỉ khâu**.

# Public_027

# 1\. TÍNH CHẤT LÝ HÓA CỦA SỢI DỆT

## Xơ xenlulô (Cotton)

**Xenlulô** là polyme chính của các loại xơ gốc thực vật (bông, lanh, gai…).
**Công thức hóa học:** (C6H10O5)n(C_6H_{10}O_5)_n
**Khối lượng riêng:** 1,52 – 1,56 g/cm³
**Các tính chất chủ yếu của xơ xenlulô (xơ bông)**

### Ảnh hưởng của nước

  * Xenlulô không tan trong nước, cồn, benzen, axit loãng… Để hòa tan xenlulô thường dùng dung dịch amôniac đồng [Cu(NH3)4](OH)2[Cu(NH_3)_4](OH)_2.

  * Trong nước, xơ bông bị trương nở, diện tích mặt cắt ngang tăng 22–34%, chiều dài chỉ tăng ~1%.


### Ảnh hưởng của ánh sáng mặt trời

  * Dưới tác dụng ánh sáng mặt trời và khí quyển, đặc biệt tia tử ngoại, các phần tử xenlulô bị oxy hóa, làm giảm độ bền. Chiếu trực tiếp trong 900–1000 giờ có thể làm giảm độ bền một nửa.

  * Khí quyển cũng gây lão hóa, giảm độ bền cơ học, giảm độ dãn nở, tăng độ cứng. Quá trình mạnh hơn khi nhiệt độ và độ ẩm cao.


### Ảnh hưởng của nhiệt độ

  * Đốt nóng xơ xenlulô ở 120–130°C vài giờ không gây thay đổi đáng kể.

  * Trên 160°C, quá trình phá hủy bắt đầu nhanh hơn; 180°C phá hủy mạnh các phần tử xenlulô.

  * Nếu đốt trong trạng thái khô, xenlulô tạo than (~40% khối lượng), nước, CO₂ và các chất khác.

  * Với quần áo bằng cotton, không nên sử dụng nhiệt độ quá 100°C.


### Ảnh hưởng của axit

  * Axit vô cơ phá hủy đại phân tử xenlulô, cắt liên kết glucôzit → thủy phân thành glucose:

  * Axit hữu cơ tác dụng yếu hơn.

  * Xenlulô tác dụng với HNO₃ tạo nitrat xenlulô (10,5–12% N), dùng làm nguyên liệu xơ nhân tạo đầu tiên.

  * Axetyl xenlulô (este của axit axetic) dùng sản xuất xơ axetat và triacetat.


### Ảnh hưởng của chất oxy hóa

  * Với Na₂S₂O₃, tính chất xơ không thay đổi → dùng tẩy trắng an toàn.

  * Bột tẩy trắng, muối Na, K… có thể làm giảm độ bền hoặc phá hủy xơ.


### Ảnh hưởng của kiềm

  * Xenlulô bền với kiềm, NaOH không phá vỡ liên kết glucôzit nhưng có thể oxy hóa khi có O₂ → xenlulô kiềm:

  * Ứng dụng: làm tăng độ bền khi kéo sợi, bề mặt sợi tròn hơn, nhẵn hơn, phản chiếu ánh sáng tốt.

  * Quá trình NaOH quá mạnh hoặc kéo căng → phá hủy hoàn toàn xơ.


### Ảnh hưởng của vi sinh vật

  * Xơ ẩm lâu trong không khí ẩm → vi khuẩn, nấm mốc phát triển → thủy phân xenlulô, phá hủy cấu trúc phân tử.


### Ứng dụng

  * Dùng may quần áo mùa hè, trang phục trẻ em, người già, người bệnh, lao động, quân đội.

  * Vải cotton thích hợp cho đồ dùng sinh hoạt hút ẩm tốt: áo gối, chăn mền, khăn tay, khăn tắm, khăn bàn, giày vải…

  * Giặt bằng xà phòng kiềm, phơi nơi khô ráo, tránh nắng trực tiếp.

  * **Ưu điểm:** hút ẩm cao, ít tĩnh điện, thích hợp may mặc.

  * **Nhược điểm:** dễ hỏng do vi sinh vật, không chịu được axit mạnh.


## Xơ protein (Len, Tơ tằm)

### Tơ tằm

  * Tơ tằm là sợi tự nhiên, chiếm >90% sản lượng tơ. Tằm ăn lá dâu → chất lỏng tiết ra → đông cứng thành sợi tơ.

  * Việt Nam: nuôi tằm ở Hà Tây, Hòa Bình, Nam Hà, Thái Bình, Nghệ Tĩnh, Phú Thọ, Lâm Đồng.

  * Chu kỳ sinh trưởng: trứng → tằm → kéo kén → nhộng → ngài (bướm).


**Cấu tạo kén tằm:**

  * Lớp ngoài: sợi cứng, nhiều keo, dùng dệt lụa gốc hoặc đan lưới.

  * Lớp giữa: sợi mềm mịn, dùng dệt lụa.

  * Lớp trong: không ươm tơ, dùng kéo sợi đũi.


**Tính chất cơ lý:**

  * Fibroin: 75% thành phần tơ.

  * Khối lượng riêng: 1,37 g/cm³.

  * Độ dài: 300–1500 m/kén.

  * Độ mảnh, độ bền: cao hơn xơ bông.


**Ảnh hưởng của nước, nhiệt độ, ánh sáng, axit, kiềm và chất oxy hóa:**

  * Nước: trương nở 16–20% chiều ngang, chiều dài tăng 1–2%.

  * Nhiệt độ: 130–140°C không thay đổi tính chất; trên 170°C phá hủy tơ.

  * Ánh sáng: tia tử ngoại làm oxy hóa → giảm độ bền 50% sau 200 giờ.

  * Axit: axit mạnh và nhiệt độ cao phá hủy nhanh.

  * Kiềm: phá hủy tùy nhiệt độ và nồng độ dung dịch.

  * Chất oxy hóa: H₂O₂, Na₂O₂ phá hủy màu, làm trắng.


**Ứng dụng:**

  * Dệt vải mỏng, may quần áo, sản xuất phế phẩm sợi, chỉ khâu, chỉ thêu.

  * Giặt bằng xà phòng trung tính, tránh ánh sáng trực tiếp, là ở 140–150°C.


### Len

  * Len lấy từ lông phủ của cừu, thỏ, dê, lạc đà. Lông cừu chiếm 96–97%, dê 2%, lạc đà 1%.

  * Thành phần cơ bản: keratin 50–90%.


**Phân loại:**

  * Len mịn: đồng nhất, lông cừu mịn (Merino) hoặc cừu lai.

  * Len nửa mịn: lông tơ kích thước 25–31 µm.

  * Len nửa thô: hỗn hợp lông tơ, lông thô, 31–40 µm.

  * Len thô: hỗn hợp lông tơ, lông thô, lông chết, >34 µm.


**Tính chất cơ lý:**

  * Khối lượng riêng: 1,3 g/cm³.

  * Độ bền: kém hơn tơ tằm.


**Ảnh hưởng của hơi nước, nhiệt độ, ánh sáng, axit, kiềm và chất oxy hóa:**

  * Hơi nước 25°C: diện tích mặt cắt tăng 26%, chiều dài tăng 1,2%.

  * Hơi nước 100°C: giảm độ bền đáng kể (3h giảm 18%, 6h giảm 23%, 60h giảm 74%).

  * Nhiệt độ 130–140°C ngắn: không thay đổi. 80–100°C lâu: cứng, giòn, giảm độ bền và màu. 170–200°C: phá hủy.

  * Ánh sáng: chiếu trực tiếp 1120h giảm độ bền 50%.

  * Axit: axit trung bình ít ảnh hưởng, axit mạnh + nhiệt độ cao → phá hủy.

  * Kiềm: phá hủy nhanh, phụ thuộc nhiệt độ và nồng độ.

  * Oxy hóa: H₂O₂, Na₂O₂ phá hủy màu, làm trắng.


**Ứng dụng:**

  * Sử dụng nguyên chất hoặc pha với xơ hóa học, kéo sợi, dệt kim, may khăn, bít tất, giày, lót, đệm…

  * Quần áo mùa đông: manteau, áo khoác…

  * Giặt: xà phòng trung tính, giặt khô cho hàng cao cấp.

  * Bảo quản: nơi khô ráo, tránh côn trùng.

# Public_028

Sự phát triển của ngành công nghiệp điện tử như chúng ta thấy ngày nay bắt đầu với sự phát minh ra **Transistor**. Cách thức hoạt động của transistor có thể được hiểu dễ dàng nếu bạn đã có kiến thức về **Diode bán dẫn**. Việc thêm một lớp khác vào một diode mối nối P-N tạo thành một thiết bị **3 đầu cuối** được gọi là **Transistor**. Thuật ngữ transistor thường đề cập đến **Transistor Bipolar Junction (BJT)**.

Transistor đã được kiểm chứng thành công vào ngày **23/12/1947** tại Phòng thí nghiệm Bell, New Jersey. Ba cá nhân được ghi nhận phát minh ra transistor là **John Bardeen, William Shockley và Walter Brattain** , trong đó William Shockley đóng vai trò quan trọng trong việc phát minh.

**Các ứng dụng của Transistor lưỡng cực (BJT) bao gồm:**

  * Ti vi

  * Điện thoại di động

  * Máy tính

  * Thiết bị phát sóng vô tuyến

  * Bộ khuếch đại âm thanh …


# Cấu tạo – Ký hiệu

## Cấu tạo

Giống như diode mối nối P-N, một BJT cũng được tạo thành từ sự kết hợp của các lớp bán dẫn loại P và loại N. Tuy nhiên, transistor có thể chứa:

  * Một lớp P giữa hai lớp N → **Transistor NPN**

  * Một lớp N giữa hai lớp P → **Transistor PNP**


Transistor có ba thiết bị đầu cuối ( **3 chân ra** ):

  * **Emitter (Bộ phát)**

  * **Base (Cơ sở / Đế / Lớp nền)**

  * **Collector (Bộ thu)**


**Cấu tạo cụ thể:**

**Transistor NPN:**

  * Emitter kết nối với lớp N bên trái

  * Collector kết nối với lớp N bên phải

  * Base kết nối với lớp P ở giữa


**Transistor PNP:**

  * Emitter kết nối với lớp P bên trái

  * Collector kết nối với lớp P bên phải

  * Base kết nối với lớp N ở giữa


Transistor có **hai mối nối P-N** :

  1. **Emitter-Base (E-B)**

  2. **Base-Collector (B-C)**


## Thiết bị đầu cuối của BJT

  * **Emitter:**  
Cung cấp các điện tích. Emitter được pha tạp nặng để bơm nhiều hạt mang điện vào Base. Kích thước E > Base.

  * **Base:**  
Lớp giữa, rất mỏng, pha tạp nhẹ, nồng độ tạp chất thấp nhất.

  * **Collector:**  
Thu thập các hạt mang điện, pha tạp vừa phải. Kích thước lớn hơn Emitter và Base, để xử lý năng lượng và tản nhiệt tốt.


## Ký hiệu

Transistor được xem như **hai diode mắc chung Anode hoặc Cathode** :

  * **NPN:** chung Anode

  * **PNP:** chung Cathode


# Nguyên lý hoạt động

## Nguyên lý làm việc của Transistor NPN

Khi không có điện áp cấp cho transistor NPN → **không phân cực**.

  * **Lớp N (Emitter & Collector):** điện tử tự do là hạt dẫn đa số, lỗ trống là hạt mang điện thiểu số.

  * **Lớp P (Base):** điện tử tự do là hạt mang điện thiểu số, lỗ trống là hạt dẫn đa số.


Các hạt mang điện luôn di chuyển từ vùng nồng độ cao → nồng độ thấp:

  * Điện tử: từ N (n-region) → P (p-region)

  * Lỗ trống: từ P (p-region) → N (n-region)


Quá trình này tạo ra **vùng nghèo kiệt (depletion region)** tại mối nối **B-E** và **B-C**.

### Tại sao vùng nghèo kiệt thâm nhập nhiều hơn về phía pha tạp nhẹ?

  * Doping là quá trình thêm tạp chất vào chất bán dẫn để tăng dẫn điện.

  * **Pha tạp nặng:** nhiều hạt mang điện, dẫn điện cao

  * **Pha tạp nhẹ:** ít hạt mang điện, dẫn điện thấp


Trong **Transistor NPN** :

  * **Emitter (N):** pha tạp nặng → nhiều điện tử tự do

  * **Base (P):** pha tạp nhẹ → ít lỗ trống

  * **Collector (N):** pha tạp vừa phải → nồng độ giữa Emitter và Base


### Nguyên tử và ion trong bán dẫn

  * Nguyên tử nhường electron → **ion dương**

  * Nguyên tử nhận electron → **ion âm**

  * Nguyên tử cho electron → **nhà tài trợ (donor)**

  * Nguyên tử nhận electron → **người nhận (acceptor)**


## Mối nối B- E(Emitter-base junction)

### n lỗ trống từ Base sang Emitter:

  * Đồng thời, các **lỗ trống** trong vùng p (Base) di chuyển sang vùng n (Emitter).

  * Tuy nhiên, vì Emitter được pha tạp nặng, số lỗ trống đi vào Emitter chỉ là một phần rất nhỏ so với số electron đi sang Base.


### Tương tác nguyên tử tại mối nối

Tại **mối nối B-E** , khi các electron từ Emitter di chuyển vào Base:

  * Mỗi nguyên tử trong **n-region (Emitter)** nhường electron cho các nguyên tử lỗ trống trong **p-region (Base)**.

  * Ví dụ: nếu mỗi nguyên tử Emitter nhường **3 electron tự do** , thì **3 nguyên tử trong Base** sẽ nhận các electron này.

  * Khi nguyên tử Emitter nhường electron → trở thành **ion dương** , do mất electron.

  * Khi nguyên tử Base nhận electron → trở thành **ion âm** , do thêm electron vào lỗ trống.


Kết quả của quá trình này là:

  1. Hình thành **vùng nghèo kiệt (depletion region)** tại mối nối B-E:

* Vùng này chứa các **ion dương cố định** ở phía Emitter và **ion âm cố định** ở phía Base.

* Vùng nghèo kiệt này tạo ra một **điện trường nội** ngăn cản dòng electron và lỗ trống tự do tiếp tục khuếch tán một cách quá mức.

  2. Dòng điện chủ yếu là **electron từ Emitter sang Base** :

* Chỉ một phần nhỏ electron kết hợp với lỗ trống trong Base, số còn lại đi vào **Collector** nhờ hiệu ứng điện trường tại mối nối Base-Collector.


### Tóm tắt cơ chế hoạt động B-E

  * **Emitter:** cung cấp electron tự do với nồng độ cao.

  * **Base:** mỏng, pha tạp nhẹ, chứa lỗ trống nhưng ít electron.

  * **Khuếch tán:** electron từ Emitter sang Base, lỗ trống từ Base sang Emitter.

  * **Vùng nghèo kiệt:** ion dương Emitter và ion âm Base hình thành điện trường nội.

  * **Dòng điện chủ yếu:** từ Emitter sang Collector qua Base, cơ chế này giúp transistor hoạt động như **bộ khuếch đại dòng điện**.

# Public_029

# Chất bán dẫn (Semiconductor)

Chất bán dẫn là những vật liệu có khả năng dẫn điện trung gian giữa chất dẫn điện tốt (kim loại) và chất cách điện. Các vật liệu bán dẫn phổ biến gồm **silic (Si)** , **germanium (Ge)** và **gallium arsenide (GaAs)**. Chúng không phải là chất dẫn điện tốt nhưng cũng không phải là chất cách điện hoàn hảo, do đó chúng được gọi là **"bán dẫn"**.

Chất bán dẫn tinh khiết có rất ít **electron tự do** vì các nguyên tử của chúng được sắp xếp trong một **mạng tinh thể**. Tuy nhiên, dưới một số điều kiện nhất định hoặc khi được thêm các tạp chất thích hợp, các electron có thể di chuyển và dẫn điện.

Khả năng dẫn điện của chất bán dẫn có thể được **cải thiện đáng kể** bằng cách **thêm các nguyên tử tạp chất** vào mạng tinh thể. Các nguyên tử này có thể cung cấp thêm electron hoặc tạo ra nhiều lỗ trống (hole), từ đó thay đổi tính chất dẫn điện của vật liệu. Quá trình này được gọi là **doping**.

## Bán dẫn thuần khiết (Pure Semiconducting)

Chất bán dẫn thuần khiết như **Silicon (Si)** và **Germanium (Ge)** về mặt hóa học không chứa tạp chất.

  * Mỗi nguyên tử **silicon** có **4 electron hóa trị** trong lớp vỏ ngoài cùng.

  * Các nguyên tử silicon chia sẻ electron với các nguyên tử lân cận để tạo ra **liên kết cộng hóa trị bền vững** , giúp mỗi nguyên tử silicon đạt được **8 electron ở lớp vỏ ngoài**.


Trong silicon tinh khiết, có rất ít electron tự do để di chuyển quanh mạng tinh thể. Vì vậy, **silicon tinh khiết hoặc germanium tinh khiết** hoạt động giống như chất cách điện, có điện trở cao.

Để silicon có thể dẫn điện, cần tạo ra **cực dương (+) và cực âm (-)** thông qua việc **doping silicon với một số tạp chất nhất định**.

## Bán dẫn loại N (N-type Semiconductor)

Để tạo **bán dẫn loại N** , các nguyên tử tạp chất có **5 electron hóa trị** (pentavalent) như **Phốt pho (P)** , **Arsenic (As)** hoặc **Antimon (Sb)** được thêm vào tinh thể silicon.

  * 4 trong 5 electron hóa trị của nguyên tử tạp chất sẽ tạo liên kết cộng hóa trị với các nguyên tử silicon lân cận.

  * Electron thứ 5 còn dư trở thành **electron tự do** , có thể di chuyển trong mạng tinh thể khi có điện áp, trở thành **hạt mang điện**.


Các nguyên tử pentavalent được gọi là **chất cho (donor)** vì chúng cung cấp electron tự do.

  * **Vật liệu loại N** có **điện tích âm dư thừa** do electron tự do chiếm ưu thế so với các lỗ trống.

  * **Hạt dẫn đa số** là electron, **hạt dẫn thiểu số** là lỗ trống.


Khi bị kích thích bởi nguồn điện hoặc nhiệt, electron tự do từ các nguyên tử tạp chất này dễ dàng di chuyển, tạo ra dòng điện trong silicon loại N.

## Bán dẫn loại P (P-type Semiconductor)

Ngược lại, để tạo **bán dẫn loại P** , các nguyên tử tạp chất **3 electron hóa trị** (trivalents) như **Nhôm (Al)** hoặc **Bo (B)** được thêm vào silicon.

  * Mỗi nguyên tử tạp chất loại P tạo ra một **lỗ trống** trong mạng tinh thể, nơi electron có thể di chuyển để lấp vào.

  * **Hạt dẫn đa số** là **lỗ trống** , **hạt dẫn thiểu số** là electron.


### Dòng điện trong chất bán dẫn loại P

  * Khi có điện áp, các **electron tự do** di chuyển đến cực dương (+) để lấp vào các lỗ trống.

  * Khi electron lấp vào lỗ trống, lỗ mới lại xuất hiện ở vị trí khác.

  * Quá trình này lặp lại, tạo ra **dòng chuyển động của lỗ trống về phía cực âm (-)** , đồng thời electron di chuyển về phía cực dương (+).


Như vậy, trong chất bán dẫn loại P, **electron thực sự di chuyển về cực dương** , còn **lỗ trống** di chuyển theo hướng ngược lại, tạo ra dòng điện.

## Chuyển động của electron và lỗ trống trong chất bán dẫn

  * **Electron** là hạt mang điện thực sự đang di chuyển trong mạng tinh thể.

  * **Lỗ trống** xuất hiện như một hạt tích điện dương, di chuyển ngược chiều electron.


Nhờ cơ chế này, cả chất bán dẫn loại P và loại N đều dẫn điện, nhưng không tốt bằng kim loại. **Điểm đặc biệt của chất bán dẫn** là khả năng **kiểm soát dòng điện** bằng cách thay đổi điều kiện điện áp, nhiệt độ, hoặc ánh sáng, thông qua việc sử dụng **mối nối P-N**.

## Mối nối P-N (P-N Junction)

Mối nối P-N được tạo ra khi **bán dẫn loại P** được ghép với **bán dẫn loại N** :

  * **Diode P-N** là thiết bị cơ bản xuất phát từ mối nối P-N, cho phép dòng điện đi theo một hướng nhất định.

  * Khi **P nối cực dương (+)** và **N nối cực âm (-)** :

* Các **electron** từ N di chuyển vào P.

* Các **lỗ trống** từ P di chuyển vào N.


Quá trình tái hợp tại mối nối

  * Khi electron gặp lỗ trống, chúng **tái hợp** và bị loại bỏ.

  * Các electron mới từ lớp N tiếp tục di chuyển vào lớp P, và các lỗ trống mới xuất hiện ở lớp P, duy trì dòng điện liên tục.


Mối nối P-N cho phép **dòng điện đi theo một hướng** , tạo cơ sở cho các thiết bị điện tử như **diode, transistor, LED, và IC**.

### Cấu trúc mối nối P-N

Mối nối P-N hình thành khi **bán dẫn loại P** (có lỗ trống là hạt dẫn đa số) được ghép với **bán dẫn loại N** (có electron tự do là hạt dẫn đa số). Khi hai loại bán dẫn này tiếp xúc:

  * **Electron** từ vùng N di chuyển sang vùng P để lấp vào các lỗ trống.

  * **Lỗ trống** từ vùng P di chuyển sang vùng N, nhưng thực tế các lỗ này không phải là vật chất, mà là sự “khuyết thiếu” electron, giúp dòng điện được hình dung.


Khi quá trình này diễn ra, tại **giao diện P-N** , một **vùng nghèo (depletion region)** hình thành.

### Vùng nghèo (Depletion Region)

  * Vùng nghèo là **khu vực gần mối nối** nơi các electron và lỗ trống đã tái hợp và bị loại bỏ, do đó **không còn hạt dẫn tự do**.

  * Trong vùng này tồn tại **các ion dương cố định** ở lớp N và **các ion âm cố định** ở lớp P.

  * Các ion này tạo ra một **điện trường nội** (internal electric field) hướng từ N → P, cản trở sự di chuyển của electron từ N sang P và lỗ từ P sang N.


Vùng nghèo là yếu tố quan trọng, vì nó xác định **điện áp chặn** và **điện áp phân cực thuận** của diode.

### Phân cực thuận (Forward Bias)

  * Khi **cực dương (+)** của nguồn nối vào **vùng P** và **cực âm (-)** nối vào **vùng N** :

* Điện áp ngoài **giảm bớt rào cản của vùng nghèo** , làm electron và lỗ dễ dàng vượt qua mối nối.

* Kết quả là **dòng điện lớn** chạy qua diode theo hướng thuận.

  * Trong phân cực thuận:

* Electron từ N đi vào P, lấp vào các lỗ trống.

* Lỗ từ P đi vào N, tạo dòng chuyển động ngược hướng electron.

* Quá trình tái hợp liên tục, cho phép dòng điện duy trì ổn định.


Điện áp cần thiết để diode bắt đầu dẫn điện thuận thường gọi là **điện áp ngưỡng** (~0,7 V đối với silicon và ~0,3 V đối với germanium).

### Phân cực ngược (Reverse Bias)

  * Khi **cực dương (+)** của nguồn nối vào **vùng N** và **cực âm (-)** nối vào **vùng P** :

* Điện áp ngoài **tăng rào cản vùng nghèo** , làm electron và lỗ khó di chuyển qua mối nối.

* Kết quả là **dòng điện rất nhỏ** , gần như bằng 0, gọi là **dòng rò ngược** (leakage current).

  * Điện trường nội cùng với điện áp ngược ngăn cản dòng electron từ N sang P, và lỗ từ P sang N.

  * Khi điện áp ngược đủ lớn, vùng nghèo có thể bị phá vỡ (breakdown), tạo ra **dòng điện lớn đột ngột** , cơ sở cho các thiết bị như **zener diode**.


### Tóm tắt hoạt động


| Điều kiện phân cực | Vùng nghèo | Dòng điện | Điện áp điển hình |
| --- | --- | --- | --- |
| Thuận (Forward) | Thu hẹp | Dẫn điện lớn | ~0,7 V (Si), 0,3 V (Ge) |
| Ngược (Reverse) | Mở rộng | Dòng rò nhỏ | Tùy vật liệu |
| Phá vỡ (Breakdown) | Bị phá hủy | Dòng lớn đột ngột | Zener: ~tùy chọn |

# Public_030

# Tụ điện (Capacitor)

## Giới thiệu về tụ điện (Introduction to Capacitors)

### Tụ điện là gì?

Tụ điện là linh kiện thụ động có khả năng tích trữ năng lượng điện trường dưới dạng điện tích khi áp một điện áp tĩnh (Static Voltage) trên các bản cực (plates) của nó. Tụ điện tích trữ năng lượng điện tương tự như một pin sạc nhỏ.

Có rất nhiều loại tụ điện khác nhau, từ các tụ điện rất nhỏ được sử dụng trong các mạch cộng hưởng, lọc nguồn, lọc tín hiệu, cho đến các tụ điện lớn dùng để bù công suất. Tuy khác nhau về kích thước và ứng dụng, tất cả đều có chức năng tương tự là lưu trữ điện tích.

### Cấu tạo tụ điện cơ bản

Trong dạng cơ bản, một tụ điện bao gồm hai hoặc nhiều tấm dẫn điện (kim loại) đặt song song, không nối hoặc chạm vào nhau. Để cách ly về điện, người ta sử dụng không khí hoặc các vật liệu cách điện tốt như giấy, sáp, mica, gốm, nhựa hoặc một số dạng gel lỏng dùng trong tụ điện phân cực. Lớp cách điện giữa các tấm thường được gọi là điện môi (Dielectric).

Do lớp cách điện này, dòng điện một chiều (DC) không thể chảy qua tụ điện; nó chỉ cho phép tạo ra điện áp trên các tấm dưới dạng điện tích (electrical charge). Các tấm kim loại dẫn điện của tụ điện có thể có hình vuông, hình tròn, hình chữ nhật, hoặc hình trụ, hình cầu. Hình dạng, kích thước và cấu trúc tấm song song phụ thuộc vào ứng dụng và mức điện áp của tụ điện.

### Nguyên lý hoạt động

Khi được sử dụng trong mạch điện một chiều (DC), tụ điện sẽ sạc lên đến điện áp cung cấp nhưng chặn dòng điện chạy qua nó do điện môi không dẫn điện.

Có hai loại điện tích: điện tích dương (+) dưới dạng proton và điện tích âm (−) dưới dạng electron. Khi một điện áp DC được đặt trên tụ điện, điện tích dương tích lũy trên một tấm, trong khi điện tích âm tích lũy trên tấm còn lại. Các tấm giữ điện tích cân bằng, tạo ra sự khác biệt điện áp giữa hai tấm. Khi đạt trạng thái ổn định, dòng điện không thể chảy qua tụ điện.

Khi kết nối với dòng điện xoay chiều (AC), dòng điện có thể đi qua tụ điện nhờ sự thay đổi liên tục điện áp. Dòng electron vào các tấm tụ điện được gọi là dòng điện sạc, chảy cho đến khi điện áp trên cả hai tấm bằng với điện áp cung cấp VcV_c. Khi đó tụ điện được gọi là “fully charged”.

## Các tham số chính của tụ điện (Main Parameters of the Capacitor)

### Điện dung của tụ điện

Điện dung là thước đo khả năng tụ điện lưu trữ điện tích giữa hai tấm của nó. Đơn vị điện dung là Farad (F), đặt theo tên nhà vật lý người Anh Michael Faraday.

Điện dung CC được tính bằng:

C=QVC = Q/V

Trong đó:

  * CC: điện dung, đơn vị Farad (F)

  * QQ: điện lượng (coulomb), là điện tích tích trên tụ

  * VV: điện áp (volt), là điện áp cấp cho tụ


### Đơn vị tiêu chuẩn của điện dung

Do Farad là đơn vị lớn, các bội số thường dùng là:

  * Microfarad (μF\mu F) : 1μF=10−6F1 \mu F = 10^{-6} F

  * Nanofarad (nF) : 1nF=10−9F1 nF = 10^{-9} F

  * Picofarad (pF) : 1pF=10−12F1 pF = 10^{-12} F


### Điện dung của tụ điện phẳng (Parallel Plate Capacitor)

Điện dung của tụ điện phẳng tỷ lệ thuận với diện tích AA (m²) của hai tấm và tỷ lệ nghịch với khoảng cách dd (m) giữa hai tấm:

C=εAd=εrε0AdC = eA/d = e_r e_0 A/d

Trong đó:

  * CC: điện dung (F)

  * εre_r: hằng số điện môi tương đối của vật liệu

  * ε0e_0: hằng số điện môi chân không, ε0=8.854×10−12 F/m, e_0 = 8.854 e-12, F/m

  * AA: diện tích bản cực (m²)

  * dd: khoảng cách giữa hai tấm (m)


## Các loại tụ điện (Types of Capacitors)

Tùy theo vật liệu điện môi và cấu tạo, tụ điện được phân loại như sau:

### Tụ gốm (Ceramic Capacitor)

  * Điện môi: gốm.

  * Điện dung: thường nhỏ, từ vài pF đến vài μF.

  * Ứng dụng: lọc tín hiệu, mạch cộng hưởng, mạch cao tần.

  * Ưu điểm: nhỏ gọn, chịu nhiệt tốt, giá rẻ.

  * Nhược điểm: điện dung thay đổi theo nhiệt độ và điện áp.


### Tụ phim (Film Capacitor)

  * Điện môi: nhựa polyester, polypropylene, polystyrene.

  * Điện dung: từ vài nF đến vài μF.

  * Ứng dụng: lọc nguồn, mạch bảo vệ, mạch công suất.

  * Ưu điểm: điện dung ổn định, chịu được điện áp cao.

  * Nhược điểm: kích thước lớn hơn tụ gốm cùng điện dung.


### Tụ hóa (Electrolytic Capacitor)

  * Điện môi: chất điện phân.

  * Điện dung: lớn, từ vài μF đến vài mF.

  * Ứng dụng: lọc nguồn, bù công suất, lưu trữ năng lượng tạm thời.

  * Ưu điểm: dung lượng cao, giá rẻ.

  * Nhược điểm: điện áp làm việc thấp hơn, tuổi thọ ngắn, phân cực (+, −) rõ ràng.


### Tụ tantalum (Tantalum Capacitor)

  * Điện môi: tantalum oxide.

  * Điện dung: từ vài μF đến vài trăm μF.

  * Ứng dụng: mạch điện tử nhạy, nguồn xung.

  * Ưu điểm: dung lượng ổn định, kích thước nhỏ.

  * Nhược điểm: nhạy cảm với quá áp, giá cao hơn tụ nhôm.


### **Tụ** siêu điện (Supercapacitor / Ultracapacitor)

  * Điện dung: rất lớn, từ vài F đến vài nghìn F.

  * Ứng dụng: lưu trữ năng lượng tạm thời, backup nguồn, hệ thống hybrid/EV.

  * Ưu điểm: lưu trữ năng lượng lớn, tuổi thọ dài.

  * Nhược điểm: điện áp thấp, giá cao, kích thước lớn.


## Ứng dụng của tụ điện (Applications of Capacitors)

  * **Lọc nguồn (Power Supply Filtering)**  
Tụ điện dùng để lọc nhiễu và ổn định điện áp DC. Chúng loại bỏ các xung AC còn sót lại sau khi chỉnh lưu từ AC sang DC.

  * **Lưu trữ năng lượng tạm thời**  
Trong mạch xung hoặc hệ thống hybrid, tụ điện có thể cung cấp dòng điện lớn trong thời gian ngắn.

  * **Mạch cộng hưởng và lọc tín hiệu**  
Kết hợp với cuộn cảm (inductor), tụ điện tạo mạch LC dùng để chọn tần số hoặc loại bỏ tần số không mong muốn.

  * **Bù công suất (Power Factor Correction)**  
Trong các mạch điện công nghiệp, tụ điện được dùng để cải thiện hệ số công suất, giảm tổn thất điện năng.

  * **Khởi động động cơ (Motor Start)**  
Tụ điện khởi động giúp động cơ chạy êm và đạt mô-men xoắn ban đầu cao.


## Lưu ý khi sử dụng và bảo quản tụ điện (Precautions and Storage)

  * **Điện áp**  
Không vượt quá điện áp làm việc, đặc biệt với tụ phân cực. Quá áp có thể gây đánh thủng điện môi.

  * **Nhiệt độ**  
Bảo quản và vận hành trong phạm vi nhiệt độ cho phép để tránh giảm tuổi thọ hoặc hỏng tụ.

  * **Phân cực**  
Với tụ điện phân cực (electrolytic, tantalum), chú ý cực (+/−) khi lắp mạch, lắp sai có thể gây nổ.

  * **Lão hóa**  
Một số tụ điện (như tụ hóa) mất điện dung theo thời gian; cần kiểm tra định kỳ nếu dùng lâu năm.

  * **Bảo quản**

1. Tránh ẩm ướt, bụi bẩn.

2. Không để gần nguồn nhiệt cao.

3. Tụ siêu điện và tụ hóa nên xả điện trước khi bảo quản lâu dài.


# Bài tập mẫu (Sample Problem)

Một tụ điện có A=10 m2A = 10\, \text{m}^2, d=5 md = 5\,\text{m}, điện môi là không khí. Tính điện dung CC.

# Hướng dẫn giải (Tutorial)

Điện dung được tính bởi công thức:

C=εAd=εrε0AdC = eA/d = e_r e_0 A/d

Điện dung của tụ điện thay đổi theo vật liệu điện môi. Các vật liệu điện môi thường là cách điện, tấm kim loại dẫn điện có thể làm bằng đồng, nhôm; điện môi có thể là giấy, sáp, mica, gốm, polyme, gel. Theo thời gian, vật liệu lão hóa dẫn đến giảm điện dung. Sai số tụ điện có thể dao động từ −20% đến +80% so với giá trị danh định.

## Điện áp làm việc (Working Voltage)

Điện áp làm việc là mức điện áp tối đa DC hoặc AC mà tụ điện chịu được mà không bị hỏng. Giá trị này thường được in trên thân tụ.

Điện áp AC và DC khác nhau do AC đề cập đến giá trị hiệu dụng; điện áp cực đại AC = 1.414 × điện áp hiệu dụng. Khi chọn tụ điện, điện áp làm việc nên cao hơn điện áp mạch ~30%.  
Ví dụ: mạch 12V → chọn tụ 16V.

## Nhiệt độ làm việc (Working Temperature)

Nhiệt độ ảnh hưởng điện dung do thay đổi tính chất điện môi. Phạm vi làm việc bình thường: −30°C đến +125°C, điện áp danh định. Nhiệt độ làm việc không quá +70°C đối với tụ nhựa.

**Lưu ý:**

  * Tụ phân nhôm: trên 85°C chất lỏng điện phân có thể bay hơi; thân tụ có thể biến dạng hoặc rò rỉ.

  * Tụ phân không dùng ở dưới −10°C do chất điện phân đóng băng.

# Public_031

# Điện trở (Resistor)

## Điện trở là gì? (What is a Resistor)

Điện trở (Resistor) là linh kiện điện tử thụ động tạo ra trở kháng (resistance), làm cản trở dòng chảy của các electron trong mạch điện.

Chúng được gọi là phần tử thụ động (passive) vì chỉ tiêu thụ năng lượng (consume power) mà không tạo ra năng lượng.

Điện trở thường được sử dụng trong các mạch như OP-AMP, vi điều khiển (microcontrollers) và các mạch tích hợp khác (IC – integrated circuits). Chúng dùng để hạn dòng (limit current), chia điện áp (divide voltages) và điều khiển các đường I/O (pull-up/pull-down lines).

## Đơn vị điện trở (Resistor Units)

Đơn vị đo điện trở là **Ohm (Ω)** , ký hiệu bằng chữ Hy Lạp Omega (Ω). Ohm đặt theo tên nhà vật lý Georg Simon Ohm (1784–1854), người đã nghiên cứu và phát hiện mối quan hệ giữa điện áp, dòng điện và điện trở (Luật Ohm).

Trong hệ SI, các tiền tố được dùng để biểu thị điện trở lớn hoặc nhỏ: kilo (kΩ), mega (MΩ), giga (GΩ) hoặc mili (mΩ).

**Ví dụ:**

  * 4.700 Ω = 4.7 kΩ

  * 5.600.000 Ω = 5.6 MΩ hoặc 5,600 kΩ


Tên các điện trở trong mạch thường bắt đầu bằng chữ **R** , mỗi điện trở có một số duy nhất.

## Ký hiệu điện trở trong sơ đồ mạch (Resistor Schematic Symbol)

Tất cả các điện trở có hai đầu nối. Trên sơ đồ mạch, điện trở được biểu thị theo hai tiêu chuẩn:

  * **Hình chữ nhật** : theo tiêu chuẩn IEC (International Electrotechnical Commission)

  * **Đường ngoằn ngoèo (zigzag)** : theo tiêu chuẩn IEEE (Institute of Electrical and Electronics Engineers)


Cả hai ký hiệu đều chấp nhận được. Hình chữ nhật thường được ưu tiên; dạng zigzag phổ biến ở Mỹ và châu Á. Số đỉnh zigzag tiêu chuẩn là 7, với 4 đỉnh trên và 3 đỉnh dưới.

## Thành phần điện trở (Resistor Composition)

Điện trở được chế tạo từ nhiều loại vật liệu, phổ biến là **màng carbon, kim loại hoặc oxit kim loại**. Một lớp vật liệu dẫn điện mỏng được quấn quanh và bao phủ bởi lớp cách điện.

  * **Màng dày** : rẻ nhưng ít chính xác

  * **Màng mỏng** : đắt hơn nhưng chính xác cao


**Ví dụ giá trị điện trở:**

  * 27 Ω, 330 Ω, 3.3 MΩ


Bên trong, màng carbon quấn quanh lõi cách điện. Nhiều lớp bọc → điện trở cao hơn.

## Ý nghĩa điện trở trong mạch điện (Resistor in Circuit)

Điện trở có thể thay thế nhiều thiết bị điện như bóng đèn hoặc động cơ. Trong mạch điện đốt nóng (electric heater circuit), sợi dây đốt nóng được xem như điện trở.

**Định luật Ohm:**

R=VIR = V/I

**Ví dụ:**

  * Tổng điện trở bình thường: RT=60 ΩR_T = 60\,\Omega (240 ÷ 4 = 60 Ω)

  * Khi dòng điện giảm còn 3 A, điện trở tăng: RT=240÷3=80 ΩR_T = 240 ÷ 3 = 80\,\Omega → báo hiệu mạch có vấn đề.


## Giá trị điện trở của dây dẫn (Resistance of Conductor)

Bốn yếu tố ảnh hưởng điện trở dây dẫn:

### Vật liệu (Material)

  * Dây dẫn tốt: đồng, bạc, nhôm

  * Cách điện: cao su, thủy tinh, sứ


### Chiều dài (L)

  * Dây càng dài, điện trở càng cao.

  * Ví dụ: dây 2 m → điện trở gấp đôi dây 1 m


### Diện tích mặt cắt ngang (A)

  * Mặt cắt lớn → điện trở giảm.

  * Ví dụ: diện tích tăng gấp đôi → điện trở giảm phân nửa


### Nhiệt độ (T)

  * Nhiệt độ tăng → điện trở tăng.

  * Khó dự đoán so với các yếu tố khác.


**Công thức tính điện trở dây dẫn:**

R=ρLAR

Trong đó:

  * RR: điện trở (Ω)

  * ρ\rho: điện trở suất của vật liệu (Ω·m)

  * LL: chiều dài dây (m)

  * AA: diện tích mặt cắt ngang (m²)


## Mạch điện trở mắc nối tiếp (Resistor Series Circuits)

Trong **mạch nối tiếp** , các điện trở được kết nối từ đầu đến cuối, tạo thành một **đường dẫn duy nhất** cho dòng điện.

**Tổng điện trở mạch nối tiếp:**

RT=R1+R2+R3+…R_T = R_1 + R_2 + R_3 + \dots

**Ví dụ 1:** 3 điện trở nối tiếp

  * R1=2 Ω,R2=4 Ω,R3=6 ΩR_1 = 2\,\Omega, R_2 = 4\,\Omega, R_3 = 6\,\Omega

  * Dòng điện I=4 AI = 4\,A

  * Tổng điện trở: RT=2+4+6=12 ΩR_T = 2 + 4 + 6 = 12\,\Omega

  * Điện áp nguồn: E=I⋅RT=4×12=48 VE = I \cdot R_T = 4 \times 12 = 48\,V


**Ví dụ 2:** 3 điện trở nối tiếp với điện áp nguồn E=9 VE = 9\,V

  * R1=3 kΩ,R2=10 kΩ,R3=5 kΩR_1 = 3\,k\Omega, R_2 = 10\,k\Omega, R_3 = 5\,k\Omega

  * Dòng điện trong mạch:


Sau đó, điện áp rơi trên mỗi điện trở:

VR1=I⋅R1=0.5×3=1.5 VV_{R1} = I R_1 = 0.5 x3 = 1.5\,V VR2=I⋅R2=0.5×10=5 VV_{R2} = I R_2 = 0.5 x 10 = 5\,V VR3=I⋅R3=0.5×5=2.5 VV_{R3} = I R_3 = 0.5 x 5 = 2.5\,V

Tôi sẽ viết thêm một đoạn mở rộng về **mạch điện trở song song (parallel resistor circuits)** để nối tiếp tài liệu hiện tại:

## Mạch điện trở mắc song song (Resistor Parallel Circuits)

Trong **mạch điện song song** , các điện trở được kết nối sao cho cả hai đầu của chúng được nối trực tiếp vào cùng hai điểm, tạo ra **nhiều đường dẫn** cho dòng điện chảy. Điện áp trên mỗi điện trở trong mạch song song luôn bằng nhau, nhưng dòng điện phân chia theo giá trị điện trở của từng nhánh.

**Ví dụ:**  
Ba điện trở mắc song song: R1=6 ΩR_1 = 6 , R2=3 ΩR_2 = 3, R3=2 ΩR_3 = 2.  
Tổng điện trở: 1

Dòng điện tổng từ nguồn được chia theo tỉ lệ nghịch với điện trở từng nhánh:

Điều này giúp mạch **giảm tổng điện trở** so với bất kỳ điện trở riêng lẻ nào và **tăng khả năng phân phối dòng điện** cho các thiết bị nối vào nhánh khác nhau. Mạch song song phổ biến trong **hệ thống chiếu sáng, mạch nguồn và điện gia dụng** , nơi các tải cần hoạt động độc lập nhưng cùng điện áp.

**Ưu điểm của mạch song song:**

  * Nếu một nhánh hỏng, các nhánh khác vẫn hoạt động.

  * Dễ dàng điều chỉnh dòng điện cho từng nhánh bằng cách chọn điện trở phù hợp.


**Nhược điểm:**

  * Cần tính toán tổng điện trở cẩn thận, đặc biệt khi nhiều nhánh nối song song, để tránh dòng quá tải.

# Public_032

# Dòng điện một chiều (Direct Current – DC)

## Định nghĩa (Definition)

Dòng điện một chiều (DC) là dòng điện mà các electron chảy liên tục theo **một hướng** trong mạch kín. Loại điện áp tạo ra dòng điện này gọi là **điện áp một chiều (DC voltage)** , và dòng điện gọi là **dòng điện một chiều (DC current)**.

**Các nguồn DC điển hình:** Pin, ắc quy, máy phát DC.

## Định luật Ohm (Ohm’s Law)

Có một mối quan hệ xác định giữa ba đặc tính điện cơ bản: **dòng điện (I), điện áp (V), điện trở (R)**.

Định luật Ohm do nhà vật lý người Đức **Georg Simon Ohm** phát hiện vào thế kỷ 19:

I=VRI = V/R

Trong đó:

  * II: dòng điện (amps – A)

  * VV: điện áp (volts – V)

  * RR: điện trở (ohms – Ω)


**Giải thích:**

  * Điện áp 1 V đặt vào điện trở 1 Ω → dòng điện 1 A chảy qua.

  * Điện trở tăng → dòng điện giảm (với cùng điện áp).


**Thiết bị Ohmic và Non-Ohmic:**

  * **Ohmic:** Tuân theo luật Ohm (điện trở tuyến tính, ví dụ dây dẫn, điện trở thông thường).

  * **Non-Ohmic:** Không tuân theo (ví dụ transistor, diode).


## Ví dụ minh họa

**Ví dụ 1:** Biết V=12 VV = 12V , R=6 ΩR = 6Ω. Tìm dòng điện II:

I=VR= 2A

**Ví dụ thực tế:** Pin 4.2 V cấp cho tải 0.5 Ω:

I= 8.4A

Nếu pin còn 3.7 V, dòng điện giảm:

I= 7.4A

**Ví dụ 2:** Biết V=24 VV = 24\,V, I=6 AI = 6\,A. Tìm điện trở RR:

$$
R=VI=246=4ΩR=V/I=24/6=4ΩR = VI = 246 = 4,Omega R  =  V/I  =  24/6  =  4Omega
$$

**Ví dụ 3:** Biết I=5 AI = 5\,A, R=8 ΩR = 8\,Ω. Tìm điện áp VV:

## Công suất điện (Power Calculation)

Công suất (P) do dòng điện tạo ra trong điện trở tính theo:

$$
P=V⋅I=V2R=I2⋅RP=V⋅I=V2R=I2⋅RP = V cdot I = V2R = I2 cdot RP  =  V  cdot I  = frac{V^{2}}{R} =  I^{2} cdot R
$$

**Ví dụ:** Pin 4.2 V, điện trở 0.5 Ω, dòng điện 8.4 A:

P=4.2×8.4=35.3 WP = 4.2 \times 8.4 = 35.3\,W

Như vậy, cuộn dây 0.5 Ω với pin sạc đầy 4.2 V sẽ kéo 8.4 A và cung cấp 35.3 W. Khi điện trở tăng → dòng điện giảm → công suất giảm.

# Dòng điện xoay chiều (Alternating Current – AC)

## Định nghĩa (Definition)

Dòng điện xoay chiều (AC) là dòng điện mà các electron **thay đổi hướng liên tục** theo thời gian. Điện áp AC buộc electron chảy theo một hướng, sau đó theo hướng ngược lại, tuần hoàn liên tục.

**Nguồn AC:** Máy phát điện.  
**Ứng dụng:** Cung cấp điện cho hộ gia đình, nhà máy, văn phòng.

## Dạng sóng (Waveform)

AC có nhiều dạng sóng khác nhau. Khi kết nối nguồn AC với dao động kế và vẽ điện áp theo thời gian, các dạng sóng phổ biến:

  * **Sóng sin:** Dạng sóng chính dùng trong dân dụng và công nghiệp.

  * **Sóng vuông và sóng tam giác:** Thường dùng trong mạch điện tử và điều khiển.


## Mô tả toán học của sóng sin AC

Sóng sin AC có thể mô tả bằng hàm toán học:

$$
V(t)=Vpsin(2πft+ϕ)V(t)=Vp∖sin(2πft+ϕ)V(t) = Vpsin(2pi ft + phi)V(t) =  V_{p}backslash sin(2pi f t  +  phi)
$$

Trong đó:

  * V(t)V(t): điện áp theo thời gian (V)

  * VpV_p: biên độ (amplitude), điện áp cực đại ±Vp

  * sin(): dao động hình sin tuần hoàn

  * 2π2\pi: hằng số chuyển đổi từ chu kỳ (Hz) sang tần số góc (rad/s)

  * ff: tần số (Hz), số dao động trong 1 giây

  * tt: thời gian (s)

  * ϕ\phi: pha (phase), dịch chuyển sóng theo thời gian, đơn vị độ (°)


**Ví dụ:** Ở Mỹ, điện áp AC cho hộ gia đình: biên độ 170 V, tần số 60 Hz, pha 0°:

$$
V(t)=170sin(2π⋅60⋅t)V(t)=170∖sin(2π⋅60⋅t)V(t) = 170sin(2pi cdot 60 cdot t)V(t) =  170 backslash sin(2 pi cdot 60  cdot t)
$$

## Ứng dụng (Applications)

Nguồn AC phổ biến trong **nhà dân, cửa hàng, văn phòng** , vì:

  1. **Truyền tải dễ dàng trên khoảng cách dài:**

* Điện áp cao (>110 kV) → dòng điện thấp → giảm tổn hao năng lượng (I²R) trên đường dây.

* AC có thể biến đổi điện áp bằng **máy biến áp** , tiện lợi cho truyền tải.

  2. **Cung cấp năng lượng cho động cơ điện:**

* Động cơ AC chuyển năng lượng điện thành cơ học.

* Máy phát điện cũng là động cơ hoạt động ngược lại (quay trục sinh điện áp).

* Thiết bị sử dụng AC: máy rửa chén, tủ lạnh, máy lạnh, máy giặt, máy bơm,…


## Điện áp hiệu dụng (RMS Voltage)

Để tính công suất thực tế của AC, sử dụng **điện áp RMS (Root Mean Square)** :

VRMS=Vp2V_\text{RMS} = \frac{V_p}{\sqrt{2}}

Trong đó VpV_p là biên độ cực đại.

Ví dụ: Nguồn AC 170 V (biên độ) → điện áp RMS:

VRMS=1702≈120 VV_\text{RMS} = \frac{170}{\sqrt{2}} \approx 120\,V

Điện áp RMS cho biết mức điện áp tương đương DC tạo ra cùng công suất trên tải điện trở.

## Công suất AC (AC Power)

**Công suất tức thời:**

P(t)=V(t)⋅I(t)P(t) = V(t) \cdot I(t)

**Lưu ý:** Đối với tải thuần trở, ϕ=0\phi = 0, công suất trung bình:

Pavg=VRMS⋅IRMSP_\text{avg} = V_\text{RMS} \cdot I_\text{RMS}

## So sánh DC và AC


| Tiêu chí | DC | AC |
| --- | --- | --- |
| Dòng chảy điện | Một hướng | Thay đổi luân phiên |
| Nguồn | Pin, ắc quy, máy phát DC | Máy phát AC, lưới điện |
| Truyền tải | Khó trên khoảng cách dài | Dễ dàng qua máy biến áp |
| Ứng dụng chính | Điện tử, thiết bị nhỏ | Nhà dân, công nghiệp, động cơ |

# Public_033

# Nguồn gốc của dòng điện (The Origin of the Current)

## Sơ lược về lịch sử phát triển (A Brief History of Development)

Lịch sử phát triển điện học có thể nói bắt đầu từ khoảng **600 năm trước Công nguyên**. Thời bấy giờ, những người Hi Lạp cổ đại lần đầu tiên đề cập đến những tính chất bí ẩn. Nhà triết học **Thales xứ Miletus** đã phát hiện rằng mảnh hổ phách cọ xát (rubbed piece of amber) có thể hút được lông chim và nâng các chất liệu nhẹ khác như vỏ gỗ bào (lift small chips of wood). Phát hiện này nhắc nhở Thales về truyền thuyết về **Magnus** (từ “magnetism”) – đá từ còn gọi là nam châm có khả năng hút sắt.

Sau nhiều thế kỷ, các hiệu ứng tĩnh điện và từ tính (the electrostatic and magnetic effects) đã được nghiên cứu và xác minh bằng thực nghiệm, đặt nền móng cho mạch điện (electrical circuits).

Mãi đến thế kỉ 13, **Pierre de Maricourt (Petrus Peregrinus)** thực hiện các thí nghiệm với đá nam châm hình cầu và các vật liệu khác, rồi công bố kết quả trong cuốn _“Epistola de Magnete”_. Ông là một trong những người đầu tiên đề xuất khai thác tính chất từ tính để chế tạo các cỗ máy.

Một công cụ từ tính quan trọng được sử dụng từ lâu là **la bàn**. La bàn do người Trung Hoa phát minh từ thời Chiến Quốc sau khi tìm ra đá nam châm (từ thạch). Người ta mài gọt đá thành hình chiếc thìa, đặt trên đế đồng nhẵn và quay. Khi chiếc thìa dừng lại, cán thìa hướng về Nam, gọi là "kim chỉ Nam". La bàn được sử dụng trong hàng hải sớm hơn phương Tây gần 100 năm, giúp các nhà thám hiểm châu Âu khám phá các vùng địa lý mới, như Cristoforo Colombo tìm ra châu Mỹ.

Năm 1752, **Benjamin Franklin** thực hiện thí nghiệm thả diều trong cơn bão, chứng minh rằng sét là một dạng điện (electricity).  
Năm 1800, **Alessandro Volta** phát minh ra pin đầu tiên, đơn vị lực điện hay điện áp là **volt** được đặt theo tên ông.  
Năm 1831, **Michael Faraday** phát hiện ra rằng khi nam châm di chuyển bên trong cuộn dây đồng, một dòng điện nhỏ chạy qua, tạo ra máy biến áp và máy phát điện đầu tiên.  
Năm 1879, **Thomas Edison** phát minh ra bóng đèn điện đầu tiên.

## Giới thiệu về điện (Introduction to Electricity)

Mọi vật, từ nước và không khí đến đá, thực vật và động vật, đều được tạo thành từ các hạt nhỏ gọi là **nguyên tử**. Nguyên tử gồm **proton, neutron và electron**. Hạt nhân chứa proton (dương) và neutron (trung hòa), các electron (âm) quay quanh hạt nhân. Nguyên tử có thể được so sánh với hệ mặt trời, hạt nhân là Mặt Trời, electron là các hành tinh quay quanh.

Các electron có thể bị giải phóng bởi lực từ bên ngoài: từ trường, nhiệt độ, ma sát hoặc phản ứng hóa học. Khi electron tự do chuyển từ nguyên tử này sang nguyên tử khác, **dòng điện tử** được tạo ra – cơ sở của **dòng điện**.

# Đặc tính (Characteristics)

Có ba đặc tính chính của điện:

  * **Dòng điện (Current)** – ký hiệu **I**

  * **Điện áp (Voltage)** – ký hiệu **E** hoặc **V** (đôi khi U)

  * **Trở kháng (Resistance)** – ký hiệu **R**

  * **Dòng điện (Current)**


Dòng electron tự do di chuyển cùng hướng từ nguyên tử này sang nguyên tử kia được gọi là **dòng điện** , đo bằng **ampe (A)**. Số lượng electron chảy qua mặt cắt dây trong 1 giây được đo bằng **amps**.


| Quantity | Symbol | Decimal |
| --- | --- | --- |
| 1 milliampere | 1 mA | 1/1000 A |
| 1 ampere | 1 A | 1 ampere |
| 1 kiloampere | 1 kA | 1000 amperes |

 

**Chiều của dòng điện:**

  * **Dòng quy ước (Conventional Flow):** dòng điện đi từ cực dương sang cực âm. Benjamin Franklin là người phát triển lý thuyết này.

  * **Dòng điện tử (Electron Flow):** electron đi từ cực âm sang cực dương. Dù đây là lý thuyết chính xác, dòng quy ước vẫn được sử dụng phổ biến trong giáo khoa và thiết bị điện.


## Điện áp (Voltage)

Điện áp là lực điện áp lên dây dẫn để electron chuyển động, đo bằng **volt (V)**. Dòng điện tiếp tục chạy miễn có điện áp đặt lên dây dẫn.


| Quantity | Symbol | Decimal |
| --- | --- | --- |
| 1 millivolt | 1 mV | 1/1000 volt |
| 1 volt | 1 V | 1 volt |
| 1 kilovolt | 1 kV | 1000 volts |

 

Điện áp tạo dòng điện theo hai cách:

  * **Dòng điện một chiều (Direct Current – DC)**

  * **Dòng điện xoay chiều (Alternating Current – AC)**


## Trở kháng (Resistance)

Trở kháng là khả năng hạn chế dòng electron chảy qua dây dẫn, đo bằng **ohm (Ω)**.


| Quantity | Symbol | Decimal |
| --- | --- | --- |
| 1 ohm | 1 Ω | 1 ohm |
| 1 kilohm | 1 kΩ | 1000 ohms |
| 1 megohm | 1 MΩ | 1,000,000 ohms |

 

Trở kháng là khả năng **cản trở dòng điện** chạy qua một vật dẫn. Khi dòng điện chạy qua dây dẫn, electron va chạm với các nguyên tử của vật liệu, làm giảm tốc độ di chuyển của chúng. Khả năng cản trở này được gọi là **trở kháng** , ký hiệu **R** và đo bằng **ohm (Ω)** , biểu tượng là chữ **Ω** trong bảng chữ cái Hy Lạp.

### Công thức cơ bản

Điện trở của dây dẫn được xác định bởi các yếu tố:

$R=ρ⋅LAR=ρ⋅L/AR = rho cdot LAR  =  rho cdot L/A$

Trong đó:

  * R là điện trở (Ω)

  * ρ là **điện trở suất của vật liệu** (ohm·m)

  * L là chiều dài dây dẫn (m)

  * A là diện tích mặt cắt ngang của dây dẫn (m²)


**Giải thích:**

  * **Vật liệu (ρ\rho)** : Các vật liệu khác nhau có khả năng dẫn điện khác nhau. Đồng, bạc, nhôm là những vật dẫn tốt (ρ\rho thấp), còn cao su, thủy tinh là cách điện (ρ\rho rất cao).

  * **Chiều dài dây dẫn (L)** : Dây càng dài, điện trở càng lớn. Ví dụ, dây 2 m có điện trở gấp đôi dây 1 m cùng loại và cùng tiết diện.

  * **Diện tích mặt cắt ngang (A)** : Dây càng dày, điện trở càng nhỏ. Nếu tiết diện dây tăng gấp đôi, điện trở giảm còn một nửa.


### Ảnh hưởng của nhiệt độ

Điện trở của hầu hết vật liệu dẫn điện thay đổi theo **nhiệt độ**. Thông thường, khi nhiệt độ tăng, điện trở tăng theo:

$$
RT=R0(1+αΔT)RT=R0(1+αΔT)RT = R0(1 + alphaDelta T)R_{T} =  R_{0}(1  +  alphaDelta T)
$$

Trong đó:

  * RTR_T là điện trở ở nhiệt độ T

  * R0R_0 là điện trở ở nhiệt độ chuẩn (thường 20°C)

  * α\alpha là hệ số nhiệt điện trở của vật liệu (1/°C)

  * ΔT=T−20°C\Delta T = T - 20°C


Ví dụ: hệ số α\alpha của đồng khoảng 0.00393/°C. Nếu điện trở 10 Ω ở 20°C, ở 50°C:

$$
R50=10(1+0.00393⋅30)≈11.18ΩR{50}=10(1+0.00393⋅30)≈11.18ΩR50 = 10(1 + 0.00393 cdot 30) approx 11.18Omega R_{left{ 50 right}} =  10 (1  +  0.00393  cdot 30) approx 11.18 Omega
$$

Điều này giải thích tại sao dây điện nóng lên sẽ làm giảm hiệu suất truyền tải.

### Loại điện trở

  * **Điện trở dây quấn (Wire-wound resistor):** điện trở được tạo từ dây hợp kim quấn quanh lõi cách điện. Dùng cho công suất lớn, chịu nhiệt tốt.

  * **Điện trở màng carbon hoặc màng kim loại (Carbon/Metal film resistor):** phổ biến trong mạch điện tử. Giá trị chính xác và ổn định, công suất nhỏ hơn dây quấn.

  * **Điện trở biến thiên (Variable resistor, potentiometer):** có thể thay đổi điện trở theo nhu cầu.


### Trở kháng trong mạch

  * **Điện trở nối tiếp:** các điện trở cộng lại tổng cộng:


$$
RT=R1+R2+R3+…RT=R1+R2+R3+…RT = R1 + R2 + R3 + ldots R_{T} =  R_{1} +  R_{2} +  R_{3} +  ldots
$$

  * **Điện trở song song**


  * **Ứng dụng:**

* Hạn chế dòng điện vào các thiết bị điện tử.

* Chia điện áp cho các mạch điều khiển.

* Làm mạch tải (load) cho nguồn hoặc máy đo.


### Điện trở và công suất

Công suất tiêu tán trên điện trở được tính bằng:

$$
P=I2R=V2R=V⋅IP=I2R=V2/R=V⋅IP = I2R = V2R = V cdot IP  =  I^{2}R  =  V^{2}/R =  V  cdot I
$$

Trong đó:

  * P là công suất (Watt)

  * I là dòng điện (A)

  * V là điện áp (V)

  * R là điện trở (Ω)


Điều này rất quan trọng khi thiết kế mạch điện, tránh tình trạng **cháy điện trở** do công suất vượt mức.

# Public_034

# Giới thiệu

Một **photodiode** là một tiếp giáp **P–N** hoặc thiết bị bán dẫn tiêu thụ năng lượng ánh sáng để tạo ra dòng điện. Nó đôi khi còn được gọi là **bộ dò ánh sáng** , **bộ cảm biến ảnh** hoặc **bộ dò tìm ảnh**.

Photodiodes được thiết kế đặc biệt để hoạt động trong **điều kiện phân cực nghịch**. Phân cực nghịch có nghĩa là mặt **P** của photodiode được kết nối với cực âm của nguồn và mặt **N** được kết nối với cực dương của nguồn.

Photodiode rất nhạy với ánh sáng; khi photon rơi vào photodiode, nó chuyển đổi năng lượng ánh sáng thành dòng điện. **Tế bào năng lượng mặt trời** còn được gọi là photodiode diện tích lớn vì chúng chuyển đổi năng lượng ánh sáng mặt trời thành năng lượng điện. Tuy nhiên, pin mặt trời chỉ hoạt động với ánh sáng khả kiến.

Cấu tạo và hoạt động của photodiode gần như **tương tự diode nối tiếp P–N thông thường** , nhưng photodiode chủ yếu được sử dụng trong các ứng dụng **tốc độ cao**.

Trong diode P–N thông thường, **điện áp** là nguồn năng lượng tạo dòng điện; trong diode quang, **cả điện áp và ánh sáng** đều được sử dụng để sinh dòng điện.

## Ký hiệu Photodiode

Ký hiệu của photodiode tương tự như diode P–N thông thường, ngoại trừ có thêm **mũi tên đại diện cho ánh sáng hoặc photon**. Một photodiode có **hai đầu cuối (terminals)** : một cực âm và một cực dương.

## Mục tiêu và hạn chế của Photodiode

  * Luôn hoạt động khi phân cực nghịch.

  * Điện áp phân cực nghịch nên thấp.

  * Tạo ra tiếng ồn thấp.

  * Tốc độ phản ứng cao.

  * Độ nhạy cao với ánh sáng.

  * Độ nhạy thấp với nhiệt độ.

  * Giá thấp.

  * Kích thước nhỏ.

  * Tuổi thọ lâu dài.


## Các loại Photodiode

Hoạt động của tất cả các loại photodiode là **tương tự nhau** , nhưng các loại khác nhau được phát triển dựa trên ứng dụng cụ thể. Ví dụ, **PIN photodiode** được phát triển để tăng tốc độ đáp ứng.

Các loại photodiode phổ biến:

  * PN photodiode

  * PIN photodiode

  * Avalanche photodiode


Trong số đó, **PN junction** và **PIN photodiode** được sử dụng rộng rãi nhất.

## Ứng dụng của Photodiode

  * Máy chơi đĩa compact (CD/DVD)

  * Thiết bị báo khói

  * Ứng dụng không gian

  * Ứng dụng y tế: chụp cắt lớp vi tính, dụng cụ phân tích mẫu, đo oxy xung

  * Truyền thông quang học

  * Đo cường độ ánh sáng cực thấp


## Phototransistor

Phototransistor là thiết bị có thể cảm nhận mức ánh sáng và thay đổi dòng chảy giữa **emitter** và **collector** theo mức ánh sáng.

  * Phototransistor nhạy hơn photodiode về **độ lợi (gain)** do transistor cung cấp.

  * Ý tưởng về phototransistor được William Shockley đề xuất năm 1951, hai năm sau khi transistor thông thường được phát hiện. Phototransistor đã được sử dụng rộng rãi trong nhiều ứng dụng kể từ đó.


## Hoạt động của Phototransistor

Phototransistor dựa trên **khái niệm transistor cơ bản**. Nó được tạo ra bằng cách **phơi bày chất bán dẫn của transistor thông thường với ánh sáng**.

  * Ánh sáng chiếu vào vùng cơ sở, tạo ra các cặp **electron–lỗ**.

  * Các electron bị bơm vào bộ phát, tạo ra dòng phototransistor, được khuếch đại bởi transistor.


**So sánh:**

  * Một photodiode có thể cho dòng điện khoảng **1 µA** trong điều kiện phòng.

  * Một phototransistor có thể cho dòng điện khoảng **100 µA** , cho thấy hiệu suất lớn hơn.


**Nhược điểm:**

  * Phototransistor không đáp ứng tần số cao tốt do **điện dung lớn** kết hợp với tiếp điểm cơ sở–thu.

  * Băng thông điển hình bị giới hạn ~250 kHz, trong khi photodiode có thể hoạt động tới 1 GHz.


## Ứng dụng Phototransistor

Phototransistor hoạt động ở hai chế độ cơ bản:

  * **Chế độ tuyến tính:** phản ứng tỷ lệ với kích thích ánh sáng, sử dụng trong đo lường.

  * **Chế độ chuyển mạch:** phản ứng phi tuyến, với hai trạng thái: **bật** và **tắt**.

* Khi không có ánh sáng, dòng điện gần như bằng 0 ("tắt").

* Khi ánh sáng đủ lớn, dòng điện đạt bão hòa ("bật").


Ứng dụng: phát hiện đối tượng, gửi dữ liệu, đọc bộ mã hóa, v.v.

## Các bộ ghép quang (Opto–Couplers)

**Optocoupler (Optoisolator)** là thành phần **cách ly tín hiệu điện giữa hai mạch** bằng ánh sáng.

  * Thường gồm **LED** và **phototransistor** trong cùng một gói.

  * Chủ yếu sử dụng giữa **cảm biến và PLC** để ngăn dòng điện trực tiếp có thể gây hỏng thiết bị.


**Chức năng:**

  * Duy trì kết nối giữa hai thiết bị mà không có **dẫn điện trực tiếp**.

  * Đảm bảo an toàn cho PLC hoặc thiết bị điều khiển khi xảy ra lỗi mạch.


# Nguyên lý vật lý của Photodiode và Phototransistor

## Hiệu ứng quang điện

Photodiode hoạt động dựa trên **hiệu ứng quang điện** , nghĩa là khi photon ánh sáng tác động vào vùng **P–N** , năng lượng của photon đủ lớn sẽ **giải phóng các electron** khỏi liên kết hóa học, tạo ra cặp electron–lỗ. Quá trình này tạo ra **dòng điện quang** trong mạch, tỷ lệ với cường độ ánh sáng chiếu vào diode.

  * **Photon năng lượng cao** : tạo ra nhiều cặp electron–lỗ, tăng dòng quang.

  * **Photon năng lượng thấp** : có thể không đủ năng lượng để giải phóng electron, dòng quang rất nhỏ hoặc bằng 0.


Hiệu suất quang điện của photodiode được đo bằng **hiệu suất lượng tử (Quantum Efficiency)** , là tỷ lệ giữa số electron tạo ra và số photon chiếu vào.

## Các tham số quan trọng của Photodiode

  * **Dark Current (Dòng tối)** : dòng nhỏ chạy qua photodiode ngay cả khi không có ánh sáng.

  * **Responsivity (Độ nhạy quang)** : tỷ lệ giữa dòng điện quang tạo ra và công suất ánh sáng chiếu vào diode.

* $$
R=IphPopt[AW]RR = IphPoptleftlbrack frac{A}{W} rightrbrack R
$$

* Trong đó IphI_{ph} là dòng quang, PoptP_{opt} là công suất ánh sáng.

  * **Công suất tối đa cho phép** : photodiode chỉ chịu được một mức công suất ánh sáng nhất định. Quá mức có thể làm hỏng diode.

  * **Tốc độ phản ứng (Response Time)** : thời gian để dòng điện quang đạt 63% giá trị cuối cùng khi ánh sáng thay đổi đột ngột.


## Phân cực Photodiode

  * **Phân cực thuận** : diode dẫn điện, nhưng hiệu suất quang thấp, dòng tối cao.

  * **Phân cực nghịch** : diode hầu như không dẫn, nhưng **tăng tốc độ phản ứng** và giảm dòng tối. Đây là chế độ hoạt động chuẩn của photodiode.


$I=Iph−IDI=Iph−IDI = Iph - IDI  =  I_{ph} -  I_{D}$

Trong đó:

  * II là dòng tổng.

  * $IphI_{ph}$ là dòng quang.

  * $IDI_{D}$ là dòng dò điện (Dark Current).


## Nguyên lý hoạt động của Phototransistor

Phototransistor là **sự kết hợp giữa transistor và photodiode** :

  * Ánh sáng chiếu vào vùng cơ sở, tạo ra dòng quang nhỏ.

  * Dòng quang này được transistor **khuếch đại** ở bộ phát, tạo ra dòng lớn hơn nhiều.

  * Do transistor khuếch đại dòng, phototransistor có **độ lợi dòng cao** , nhưng **điện dung lớn** nên tốc độ phản ứng thấp hơn diode.


## Nguyên lý cách ly quang của Optocoupler

Optocoupler truyền tín hiệu bằng ánh sáng để **cách ly điện hai mạch** :

  * LED bên trong phát sáng khi có dòng vào.

  * Phototransistor bên trong nhận ánh sáng, tạo ra dòng điện trong mạch nhận.

  * Không có **kết nối điện trực tiếp** , nhờ đó mạch nhận được bảo vệ khỏi điện áp cao hoặc nhiễu điện.


  * Optocoupler thường dùng để:

* Ngăn nhiễu trong truyền tín hiệu.

* Bảo vệ vi điều khiển, PLC hoặc mạch điều khiển khỏi dòng cao bất ngờ.


## Các thông số quan trọng của Optocoupler

  * **CTR (Current Transfer Ratio)** : tỷ lệ giữa dòng ra của phototransistor và dòng vào LED.


$$
CTR=IoutIin×100%CTR={I{out}}{I{in}}×100∖%CTR = IoutIin times 100% CTR  = frac{left{ I_{left{ out right}} right}}{left{ I_{left{ in right}} right}} times 100backslash%
$$

  * **Isolation Voltage** : điện áp tối đa mà hai mạch cách ly có thể chịu trước khi bị dò điện.

  * **Tốc độ phản hồi (Response Time)** : thời gian từ LED bật/tắt đến phototransistor phản hồi.

# Public_035

Thuật toán linear regression giải quyết các bài toán có đầu ra là giá trị thực, ví dụ: dự đoán giá nhà, dự đoán giá cổ phiếu, dự đoán tuổi,...

# Bài toán

Bạn làm ở công ty bất động sản, bạn có dữ liệu về diện tích và giá nhà, giờ có một ngôi nhà mới bạn muốn ước tính xem giá ngôi nhà đó khoảng bao nhiêu. Trên thực tế thì giá nhà phụ thuộc rất nhiều yếu tố: diện tích, số phòng, gần trung tâm thương mại,.. nhưng để cho bài toán đơn giản giả sử giá nhà chỉ phụ thuộc vào diện tích căn nhà. Bạn có dữ liệu về diện tích và giá bán của 30 căn nhà như sau:


| Diện tích(m2) | Giá bán (triệu VNĐ) |
| --- | --- |
| 30 | 448.524 |
| 32.4138 | 509.248 |
| 34.8276 | 535.104 |
| 37.2414 | 551.432 |
| 39.6552 | 623.418 |
| ... | ... |

 

Khi có dữ liệu mình sẽ visualize dữ liệu lên hình 3.1
Nếu giờ yêu cầu bạn ước lượng nhà 50 mét vuông khoảng bao nhiêu tiền thì bạn sẽ làm thế nào? Vẽ một đường thẳng gần với các điểm trên nhất và tính giá nhà ở điểm 50 như ở hình 3.2
Về mặt lập trình cũng cần làm 2 việc như vậy:

  1. Training: Tìm đường thẳng (model) gần các điểm trên nhất. Mọi người có thể vẽ ngay được đường thẳng mô tả dữ liệu từ hình 1, nhưng máy tính thì không, nó phải đi tìm bằng thuật toán Gradient descent ở phía dưới. (Từ model và đường thẳng được dùng thay thế lẫn nhau trong phần còn lại của bài này).


  1. Prediction: Dự đoán xem giá của ngôi nhà 50 _m_ 2 có giá bao nhiêu dựa trên đường tìm được ở phần trên.


![](images/image1.png)
Hình 3.1: Đồ thị quan hệ giữa diện tích và giá nhà.

# Thiết lập công thức

## Model

Phương trình đường thẳng có dạng _y_ = _ax_ + _b_ ví dụ hình 3.3. Thay vì dùng kí hiệu a, b cho phương trình đường thẳng; để tiện cho biểu diễn ma trận phần sau ta sẽ thay _w_ 1 = _a,w_ 0 = _b_
Nên phương trình được viết lại thành: _y_ = _w_ 1∗ _x_ + _w_ 0 => Việc tìm đường thẳng giờ thành việc tìm _w_ 0 _,w_ 1.
Để tiện cho việc thiết lập công thức, ta sẽ đặt ký hiệu cho dữ liệu ở bảng dữ liệu: ( _x_ 1 _,y_ 1) = (30, 448.524), ( _x_ 2 _,y_ 2) = (32.4138, 509.248),..
Tức là nhà diện tích _x i _thực sự có giá _y i _. Còn giá trị mà model hiện tại đang dự đoán kí hiệu là _y_ ˆ _i_ = _w_ 1∗ _x i _+ _w_ 0

## Loss function

Việc tìm _w_ 0 _,w_ 1 có thể đơn giản nếu làm bằng mắt nhưng máy tính không biết điều đấy, nên ban đầu giá trị được chọn ngẫu nhiên ví dụ _w_ 0 = 0 _,w_ 1 = 1 sau đấy được chỉnh dần.
Rõ ràng có thể thấy đường y = x như ở hình 3.4 không hề gần các điểm hay không phải là đường mà ta cần tìm. Ví dụ tại điểm x = 42 (nhà 42 _m_ 2 ) giá thật là 625 triệu nhưng giá mà model dự đoán chỉ là 42 triệu.
![](images/image2.png)
Hình 3.2: Ước tính giá căn nhà 50 _m_ 2
![](images/image3.png)
Hình 3.4: Sự khác nhau tại điểm x = 42 của model đường thẳng y = x và giá trị thực tế ở bảng 1
![](images/image4.png)
Hình 3.3: Ví dụ đường thẳng y = x + 1 (a = 1 và b = 1)
Nên giờ cần 1 hàm để đánh giá là đường thẳng với bộ tham số ( _w_ 0 _,w_ 1) = (0 _,_ 1) có tốt hay không. Với mỗi điểm dữ liệu ( _x i,yi_) độ chênh lệch giữa giá thật và giá dự đoán được tính bằng: $$
12(ŷi−yi)2frac{1}{2}left( {widehat{y}}_{i} - y_{i} right)^{2}
$$.
Và độ chênh lệch trên toàn bộ dữ liệu tính bằng tổng chênh lệch của từng điểm:
$$
J=12⋅1N⋅∑i=1N(ŷi−yi)2J = frac{1}{2} cdot frac{1}{N} cdot sum_{i = 1}^{N}{}left( {widehat{y}}_{i} - y_{i} right)^{2}
$$ (N là số điểm dữ liệu). Nhận xét:

  * J không âm

  * J càng nhỏ thì đường thẳng càng gần điểm dữ liệu. Nếu J = 0 thì đường thẳng đi qua tất các điểm dữ liệu.


J được gọi là loss function, hàm để đánh giá xem bộ tham số hiện tại có tốt với dữ liệu không.
=> Bài toán tìm đường thẳng gần các điểm dữ liệu nhất trở thành tìm _w_ 0 _,w_ 1 sao cho hàm J đạt giá trị nhỏ nhất.
Tóm tắt: Cần tìm đường thẳng (model) fit nhất với dữ liệu, tương ứng với việc tìm tham số _w_ 0 _,w_ 1 để cực tiểu hóa hàm J.
Giờ cần một thuật toán để tìm giá trị nhỏ nhất của hàm J( _w_ 0, _w_ 1). Đó chính là thuật toán gradient descent.

# Thuật toán gradient descent

## Đạo hàm là gì?

Có nhiều người có thể tính được đạo hàm của hàm _f_ ( _x_ ) = _x_ 2 hay _f_ ( _x_ ) = _sin_ ( _cos_ ( _x_ )) nhưng vẫn không biết thực sự đạo hàm là gì. Theo tiếng hán đạo là con đường, hàm là hàm số nên đạo hàm chỉ sự biến đổi của hàm số hay có tên thân thương hơn là độ dốc của đồ thị.
![](images/image5.png)
Hình 3.5: Đồ thị _y_ = _x_ 2
Như mọi người đã học đạo hàm _f_ ( _x_ ) = _x_ 2 là _f’_ ( _x_ ) = 2∗ _x_ (hoàn toàn có thể chứng minh từ định nghĩa nhưng cấp 3 mọi người đã học quá nhiều về công thức nên tôi không đề cập lại). Nhận xét:

  * f’(1) = 2 * 1 < f’(2) = 2 * 2 nên mọi người có thể thấy trên hình là đồ thị tại điểm x = 2 dốc hơn đồ thị tại điểm x = 1, tuy nhiên f’(-2) = -4 < f’(-1) = -2 nhưng đồ thị tại x = -2 dốc hơn đồ thị tại x = -1 => trị tuyệt đối của đạo hàm tại một điểm càng lớn thì đồ thị tại điểm đấy càng dốc.

  * f’(-1) = 2 * (-1) = -2 < 0 => đồ thị đang giảm hay khi tăng x thì y sẽ giảm; ngược lại đạo hàm tại điểm nào đó mà dương thì đồ thị tại điểm đấy đang tăng.


## Gradient descent

Gradient descent là thuật toán tìm giá trị nhỏ nhất của hàm số f(x) dựa trên đạo hàm. Thuật toán:

  1. Khởi tạo giá trị _x_ = _x_ 0 tùy ý

  2. Gán x = x - learning_rate * f’(x) ( learning_rate là hằng số dương ví dụ learning_rate = 0.001) 3. Tính lại f(x): Nếu f(x) đủ nhỏ thì dừng lại, ngược lại tiếp tục bước 2


Thuật toán sẽ lặp lại bước 2 một số lần đủ lớn (100 hoặc 1000 lần tùy vào bài toán và hệ số learning_rate) cho đến khi f(x) đạt giá trị đủ nhỏ. Ví dụ cần tìm giá trị nhỏ nhất hàm _y_ = _x_ 2, hàm này ai cũng biết là giá giá trị nhỏ nhất là 0 tại x = 0 nhưng để cho mọi người dễ hình dung hơn về thuật toán Gradient descent nên tôi lấy ví dụ đơn giản.
![](images/image6.png)
Hình 3.6: Ví dụ về thuật toán gradient descent

  1. Bước 1: Khởi tạo giá trị ngẫu nhiên x = -2 (điểm A).

  2. Bước 2: Do ở A đồ thị giảm nên f’(x=-2) = 2*(-2) = -4 < 0 => Khi gán x = x - learning_rate * f’(x) nên x tăng nên đồ thị bước tiếp theo ở điểm C. Tiếp tục thực hiện bước 2, gán x = x learning_rate * f’(x) thì đồ thị ở điểm D,... => hàm số giảm dần dần tiến tới giá trị nhỏ nhất.


Mọi người có để ý là trị tuyệt đối của đạo hàm tại A lớn hơn tại C và tại C lớn hơn tại D không? Đến khi đến gần điểm đạt giá trị nhỏ nhất x = 0, thì đạo hàm xấp xỉ 0 đến khi hàm đạt giá trị nhỏ nhất tại x = 0, thì đạo hàm bằng 0, nên tại điểm gần giá trị nhỏ nhất thì bước 2 gán x = x - learning_rate * f’(x) là không đáng kể và gần như là giữ nguyên giá trị của x.
Tương tự nếu giá trị khởi tạo tại x = 2 (tại B) thì đạo hàm tại B dương nên do x = x - learning_rate * f’(x) giảm -> đồ thị ở điểm E -> rồi tiếp tục gán x=x -learning_rate * f’(x) thì hàm f(x) cũng sẽ giảm dần dần đến giá trị nhỏ nhất.
Ví dụ: chọn x = 10, learning_rate = 0.1, bước 2 sẽ cập nhất x = x - learning_rate*f’(x) = x learning_rate *2*x, giá trị f(x) = _x_ 2 sẽ thay đổi qua các lần thực hiện bước 2 như sau:


| Lần | x | f(x) |
| --- | --- | --- |
| 1 | 8.00 | 64.00 |
| 2 | 6.40 | 40.96 |
| 3 | 5.12 | 26.21 |
| 4 | 4.10 | 16.78 |
| 5 | 3.28 | 10.74 |
| 6 | 2.62 | 6.87 |
| 7 | 2.10 | 4.40 |
| 8 | 1.68 | 2.81 |
| 9 | 1.34 | 1.80 |
| 10 | 1.07 | 1.15 |

 

![](images/image7.png)
Hình 3.7: Ví dụ về thuật toán gradient descent
Nhận xét:

  * Thuật toán hoạt động rất tốt trong trường hợp không thể tìm giá trị nhỏ nhất bằng đại số tuyến tính.

  * Việc quan trọng nhất của thuật toán là tính đạo hàm của hàm số theo từng biến sau đó lặp lại bước 2.


Việc chọn hệ số learning_rate cực kì quan trọng, có 3 trường hợp:

  * Nếu learning_rate nhỏ: mỗi lần hàm số giảm rất ít nên cần rất nhiều lần thực hiện bước 2 để hàm số đạt giá trị nhỏ nhất.

  * Nếu learning_rate hợp lý: sau một số lần lặp bước 2 vừa phải thì hàm sẽ đạt giá trị đủ nhỏ.

  * Nếu learning_rate quá lớn: sẽ gây hiện tượng overshoot (như trong hình 3.8) và không bao giờ đạt được giá trị nhỏ nhất của hàm.


![](images/image8.png)
Hình 3.8: Các giá trị learning_rate khác nhau [13]
Cách tốt nhất để kiểm tra learning_rate hợp lý hay không là kiểm tra giá trị hàm f(x) sau mỗi lần thực hiện bước 2 bằng cách vẽ đồ thị với trục x là số lần thực hiện bước 2, trục y là giá trị loss function tương ứng ở bước đấy.
![](images/image9.png)
Hình 3.9: Loss là giá trị của hàm cần tìm giá trị nhỏ nhất, Epoch ở đây là số cần thực hiện bước 2 [13]

# So sánh các loss function

## Mean Absolute Error, L1 Loss

Mean Absolute Error (MAE) hay còn được gọi là L1 Loss là một loss function được sử dụng cho các mô hình hồi quy, đặc biệt cho các mô hình hồi quy tuyến tính. MAE được tính bằng tổng các trị tuyệt đối của hiệu giữa giá trị thực ( _y i_: target) và giá trị mà mô hình của chúng ra dự đoán ($ŷi{widehat{y}}_{i}$: predicted).
$$
MAE=1N∑i=1N|ŷi−yi|MAE = frac{1}{N}sum_{i = 1}^{N}{}left| {widehat{y}}_{i} - y_{i} right|
$$

## Mean Square Error, L2 Loss

Mean Square Error (MSE) hay còn được gọi là L2 Loss là một loss function cũng được sử dụng cho các mô hình hồi quy, đặc biệt là các mô hình hồi quy tuyến tính. MSE được tính bằng tổng các bình phương của hiệu giữa giá trị thực ( _y i_: target) và giá trị mà mô hình của chúng ra dự đoán ($ŷi{widehat{y}}_{i}$: predicted).
$$
MSE=1N∑i=1N(ŷi−yi)2MSE = frac{1}{N}sum_{i = 1}^{N}{}left( {widehat{y}}_{i} - y_{i} right)^{2}
$$

# Public_036

# Bài toán Image segmentation

Bài trước bạn đã được giới thiệu về object detection, đi tìm các bounding box quanh các đối tượng trong ảnh và sau đó phân loại các bounding box. Tuy nhiên là các bounding box thì không biểu thị được đúng hình dạng của đối tượng và có nhiều nhiễu ở trong bounding box đấy ví dụ như trong bounding box màu đỏ có cả một phần của cây thông cũng như cái gối => Image segmentation ra đời để chia ảnh thành nhiều vùng khác nhau hay tìm được đúng hình dạng của các đối tượng.
![](images/image1.png)
Hình 15.1: So sánh object detection và segmentation [4]
Cùng thử lấy ví dụ tại sao cần image segmentation nhé. Ung thư là một căn bệnh hiểm nghèo và cần được phát hiện sớm để điều trị. Vì hình dạng của các tế bào ung thư là một trong những yếu tố quyết định độ ác tính của bệnh, nên ta cần image segmentation để biết được chính xác hình dạng của các tế bào ung thư để có các chẩn đoán xác định. Rõ ràng object detection ở đây không giải quyết được vấn đề.
![](images/image2.png)
Hình 15.2: Ví dụ về segmentation [15]

## Phân loại bài toán image segmentation

Bài toán image segmentation được chia ra làm 2 loại:

  * **Semantic segmentation** : Thực hiện segment với từng lớp khác nhau, ví dụ: tất cả người là 1 lớp, tất cả ô tô là 1 lớp.

  * **Instance segmentation** : Thực hiện segment với từng đối tượng trong một lớp. Ví dụ có 3 người trong ảnh thì sẽ có 3 vùng segment khác nhau cho mỗi người.


![](images/image3.png)
Hình 15.3: Phân loại semantic segmentation và instance segmentation [27]
Cần áp dụng kiểu segmentation nào thì phụ thuộc vào bài toán. Ví dụ: cần segment người trên đường cho ô tô tự lái, thì có thể dùng semantic segmentation vì không cần thiết phải phân biệt ai với ai, nhưng nếu cần theo dõi mọi hành vi của mọi người trên đường thì cần instance segmentation thì cần phân biệt mọi người với nhau.

## Ứng dụng bài toán segmentation

### Ô tô tự lái

Segmentation dùng để xác định đường, các xe ô tô, người đi bộ,... để hỗ trợ cho ô tô tự lái
![](images/image4.png)

### Chẩn đoán trong y học

Segmentation được ứng dụng rất nhiều trong y học để hỗ trợ việc chẩn đoán bệnh. Ví dụ phân tích ảnh X-quang.
![](images/image5.png)
Hình 15.4: Ứng dụng segmentation [16]

# Mạng U-Net với bài toán semantic segmentation

Như trong bài xử lý ảnh ta đã biết thì ảnh bản chất là một ma trận của các pixel. Trong bài toán image segmentation, ta cần phân loại mỗi pixel trong ảnh. Ví dụ như trong hình trên với semantic segmentation, với mỗi pixel trong ảnh ta cần xác định xem nó là background hay là người. Thêm nữa là ảnh input và output có cùng kích thước.
U-Net được phát triển bởi Olaf Ronneberger et al. để dùng cho image segmentation trong y học. Kiến trúc có 2 phần đối xứng nhau được gọi là encoder (phần bên trái) và decoder (phần bên phải).

## Kiến trúc mạng U-Net

![](images/image6.png)
Hình 15.5: Mạng U-Net [20]
Nhận xét:

  * Thực ra phần encoder chỉ là ConvNet bình thường (conv, max pool) với quy tắc quen thuộc từ bài VGG, các layer sau thì width, height giảm nhưng depth tăng.

  * Phần decoder có mục đích là khôi phục lại kích thước của ảnh gốc, ta thấy có up-conv lạ. Conv với stride > 1 thì để giảm kích thước của ảnh giống như max pool, thì up-conv dùng để tăng kích thước của ảnh.

  * Bạn thấy các đường màu xám, nó nối layer trước với layer hiện tại được dùng rất phổ biến trong các CNN ngày nay như DenseNet để tránh vanishing gradient cũng như mang được các thông tin cần thiết từ layer trước tới layer sau.


## Loss function

Vì bài toán là phân loại cho mỗi pixel nên loss function sẽ là tổng cross-entropy loss cho mỗi pixel trong toàn bộ bức ảnh.

## Transposed convolution

Hình ở trên có kích thước là 6*6, hình ở dưới có kích thước là 4*4, kernel có kích thước 3*3.
Nếu ta thực hiện phép tính convolution với input là hình ở trên, padding = 0, stride = 1 và kernel 3*3 thì output sẽ là hình ở dưới.
![](images/image7.png)
Phép tính transposed convolution thì sẽ ngược lại, input là hình ở dưới, padding = 0, stride = 1 và kernel 3*3 thì output sẽ là hình ở trên. Các ô vuông ở hình trên bị đè lên nhau thì sẽ được cộng dồn. Các quy tắc về stride và padding thì tương tự với convolution.

# Public_037

Ở những bài trước tôi đã giới thiệu về mô hình Recurrent Neural Network (RNN) cho bài toán dữ liệu dạng chuỗi. Tuy nhiên RNN chỉ có short term memory và bị vanishing gradient. Tiếp đó tôi đã giới thiệu về Long short term memory (LSTM) có cả short term memory và long term memory, hơn thế nữa tránh được vanishing gradient. Bài này tôi sẽ viết về ứng dụng của LSTM cho ứng dụng image captioning.

# Ứng dụng

![](images/image1.png)
Hình 18.1: Ví dụ image captioning [10]
Ta có thể thấy ngay 2 ứng dụng của image captioning:

  * Để giúp những người già mắt kém hoặc người mù có thể biết được cảnh vật xung quanh hay hỗ trợ việc di chuyển. Quy trình sẽ là: Image -> text -> voice.

  * Giúp google search có thể tìm kiếm được hình ảnh dựa vào caption.


# Dataset

Dữ liệu dùng trong bài này là Flickr8k Dataset. Mọi người tải ở [đây.](http://academictorrents.com/details/9dea07ba660a722ae1008c4c8afdd303b6f6e53b) Dữ liệu gồm 8000 ảnh, 6000 ảnh cho training set, 1000 cho dev set (validation set) và 1000 ảnh cho test set.
Bạn tải về có 2 folder: Flicker8k_Dataset và Flicker8k_Text. Flicker8k_Dataset chứa các ảnh với tên là các id khác nhau. Flicker8k_Text chứa:

  * Flickr_8k.testImages, Flickr_8k.devImages, Flickr_8k.trainImages, Flickr_8k.devImages chứa id các ảnh dùng cho việc test, train, validation.

  * Flickr8k.token chứa các caption của ảnh, mỗi ảnh chứa 5 captions.


Ví dụ ảnh ở hình 18.2 có 5 captions:

  * A child in a pink dress is climbing up a set of stairs in an entry way.

  * A girl going into a wooden building.

  * A little girl climbing into a wooden playhouse.

  * A little girl climbing the stairs to her playhouse.

  * A little girl in a pink dress going into a wooden cabin.


Thực ra 1 ảnh nhiều caption cũng hợp lý vì bức ảnh có thể được mô tả theo nhiều cách khác nhau. Một ảnh 5 caption sẽ cho ra 5 training set khác nhau: (ảnh, caption 1), (ảnh, caption 2), (ảnh, caption 3), (ảnh, caption 4), (ảnh, caption 5). Như vậy training set sẽ có 6000 * 5 = 40000 dataset.

# Phân tích bài toán

Input là ảnh và output là text, ví dụ "man in black shirt is playing guitar".
Nhìn chung các mô hình machine learning hay deep learning đều không xử lý trực tiếp với text như ’man’, ’in’, ’black’,... mà thường phải quy đổi (encode) về dạng số. Từng từ sẽ được encode sang dạng vector với độ dài số định, phương pháp đấy gọi là word embedding.
Nhìn thấy output là text nghĩ ngay đến RNN và sử dụng mô hình LSTM.
Input là ảnh thường được extract feature qua pre-trained model với dataset lớn như ImageNet và model phổ biến như VGG16, ResNet, quá trình được gọi là embedding và output là 1 vector.
**Ý tưởng sẽ là dùng embedding của ảnh và dùng các từ phía trước để dự đoán từ tiếp theo trong caption.**
Ví dụ:

  * Embedding vector + A -> girl

  * Embedding vector + A girl -> going

  * Embedding vector + A girl going -> into

  * Embedding vector + A girl going into -> a.

  * Embedding vector + A girl going into a -> wooden building .

  * Embedding vector + A girl going into a wooden -> building .


![](images/image2.png)
Hình 18.3: Mô hình của bài toán
Để dự đoán từ tiếp theo ta sẽ xây dựng từ điển các từ xuất hiện trong training set (ví dụ 2000 từ) và bài toán trở thành bài toán phân loại từ, xem từ tiếp theo là từ nào, khá giống như bài phân loại ảnh.

# Các bước chi tiết

## Image embedding với Inception

Có lẽ cái tên GoogLeNet sẽ quen thuộc hơn và gặp nhiều hơn so với Inception, GoogLeNet là version 1 của Inception, hiện giờ mô hình phổ biến là Inception v3.
![](images/image3.png)
Hình 18.4: Mô hình Googlenet, Going Deeper with Convolutions, Szegedy et al
Thay vì trong mỗi Conv layer chỉ dùng 1 kernel size nhất định như 3*3, 5*5, thì giờ ở một layer có nhiều kernel size khác nhau, do đó mô hình có thể học được nhiều thuộc tính khác nhau của ảnh trong mỗi layer.
Ta sẽ sử dụng pre-trained model Inception v3 với dataset Imagenet. Do là pre-trained model yêu cầu ảnh đầu vào là 229*229 nên ra sẽ resize ảnh về kích thước này. Sau khi qua pre-trained model ta sẽ lấy được embedding vector của ảnh, kích thước 256*1.

## Text preprocessing

Ta xử lý text qua một số bước cơ bản.

  * Chuyển chữ hoa thành chữ thường, "Hello" -> "hello"

  * Bỏ các kí tự đặc biệt như "

  * Loại bỏ các chữ có số như hey199


Sau đó ta sẽ thêm 2 từ "startseq" và "endseq" để biểu thị sự bắt đầu và kết thúc của caption. Ví dụ: "startseq a girl going into a wooden building endseq". "endseq" dùng khi test ảnh thì biết kết thúc của caption.
Ta thấy có 8763 chữ khác nhau trong số 40000 caption. Tuy nhiên ta không quan tâm lắm những từ mà chỉ xuất hiện 1 vài lần, vì nó giống như là nhiễu vậy và không tốt cho việc học và dự đoán từ của model, nên ta chỉ giữ lại những từ mà xuất hiện trên 10 lần trong số tất cả các caption. Sau khi bỏ những từ xuất hiện ít hơn 10 lần ta còn 1651 từ.
Tuy nhiên do độ dài các sequence khác nhau, ví dụ: "A", " A girl going", " A girl going into a wooden", nên ta cần padding thêm để các chuỗi có cùng độ dài bằng với độ dài của chuỗi dài nhất là 34. Do đó số tổng số từ (từ điển) ta có là 1651 + 1 (từ dùng để padding).

## Word embedding

Để có thể đưa text vào mô hình deep learning, việc đầu tiên chúng ta cần làm là số hóa các từ đầu vào (embedding). Ở phần này chúng ta sẽ thảo luận về các mô hình nhúng từ (word embedding) và sự ra đời của mô hình word2vec rất nổi tiếng được google giới thiệu vào năm 2013. Trước đó ta thảo luận một số phương pháp cổ điển

### One hot encoding

Phương pháp này là phương pháp đơn giản nhất để đưa từ về dạng số hóa vector với chiều bằng với kích thước bộ từ điển. Mỗi từ sẽ được biểu diễn bởi 1 vector mà giá trị tại vị trí của từ đó trong từ điển bằng 1 và giá trị tại các vị trí còn lại đều bằng 0.
Ví dụ: Ta có 3 câu đầu vào: "Tôi đang đi học", "Mình đang bận nhé", "Tôi sẽ gọi lại sau". Xây dựng bộ từ điển: "Tôi, đang , đi, học, Mình, bận, nhé, sẽ , gọi, lại, sau". Ta có các biểu diễn one hot encoding của từng từ như sau:
Tôi:[1 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0] _,_
đang: [0 _,_ 1 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0] _,_
_..._
Mình: [0 _,_ 0 _,_ 0 _,_ 0 _,_ 1 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0] _,_
_...  
_sau: [0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 1] _._
Cách biểu diễn này rất đơn giản, tuy nhiên ta có thể nhận thấy ngay các hạn chế của phương pháp này. Trước hết, one hot encoding không thể hiện được thông tin về ngữ nghĩa của từ, ví dụ như khoảng cách(vector(Tôi) - vector(Mình)) = khoảng cách(vector(Tôi) - vector(đang)), trong khi rõ ràng từ "Tôi" và từ "Mình" trong ngữ cảnh như trên có ý nghĩa rất giống nhau còn từ "Tôi" và từ "đang" lại khác nhau hoàn toàn. Tiếp nữa, mỗi từ đều được biểu diễn bằng một vector có độ dài bằng kích thước bộ từ điển, như bộ từ điển của google gồm 13 triệu từ, thì mỗi one hot vector sẽ dài 13 triệu chiều. Cách biểu diễn này tốn rất nhiều tài nguyên nhưng thông tin biểu diễn được lại rất hạn hẹp.
=> Cần một cách biểu diễn từ ít chiều hơn và mang nhiều thông tin hơn.

### Co-occurrence Matrix

Năm 1957, nhà ngôn ngữ học J.R. Firth phát biểu rằng: "Bạn sẽ biết nghĩa của một từ nhờ những từ đi kèm với nó.". Điều này cũng khá dễ hiểu. Ví dụ nhắc đến Việt Nam, người ta thường có các cụm từ quen thuộc như "Chiến tranh Việt Nam", "Cafe Việt Nam", "Việt Nam rừng vàng biển bạc", dựa vào những từ xung quanh ta có thể hiểu hoặc mường tượng ra được "Việt Nam" là gì, như thế nào. Co-occurrence Matrix được xây dựng dựa trên nhận xét trên, co-occurrence đảm bảo quan hệ ngữ nghĩa giữa các từ, dựa trên số lần xuất hiện của các cặp từ trong "context window". Một context window được xác dựa trên kích thước và hướng của nó, ví dụ của context window:
![](images/image4.png)
Hình 18.5: Ví dụ về context window
Co-occurrence matrix là một ma trận vuông đối xứng, mỗi hàng, mỗi cột sẽ làm vector đại diện cho từ tương ứng. Từ ví dụ trên ta tiếp tục xây dựng co-occurrence matrix:
![](images/image5.png)
Hình 18.6: Ví dụ về co-occurrence matrix
Trong đó, giá trị tại ô [i, j] là số lần xuất hiện của từ i nằm trong context window của từ j. Cách biểu diễn trên mặc dù đã giữ được thông tin về ngữ nghĩa của một từ, tuy vẫn còn các hạn chế như sau:

  * Khi kích thước bộ từ điển tăng, chiều vector cũng tăng theo.

  * Lưu trữ co-occurrence matrix cần rất nhiều tài nguyên về bộ nhớ.

  * Các mô hình phân lớp bị gặp vấn đề với biểu diễn thưa (có rất nhiều giá trị 0 trong ma trận).


Để làm giảm kích thước của co-occurrence matrix người ta thường sử dụng phép SVD (Singular Value Decomposition) để giảm chiều ma trận. Ma trận thu được sau SVD có chiều nhỏ hơn, dễ lưu trữ hơn và ý nghĩa của từ cũng cô đọng hơn. Tuy nhiên, SVD có độ phức tạp tính toán cao, tăng nhanh cùng với chiều của ma trận ( _O_ ( _mn_ 2) với m là chiều của ma trận trước SVD, n là chiều của ma trận sau SVD và _n < m_ ) , ngoài ra phương pháp này cũng gặp khó khăn khi thêm các từ vựng mới vào bộ từ điển.
=> Cần phương pháp khác lưu trữ được nhiều thông tin và vector biểu diễn nhỏ.

### Word to vec (Word2vec)

Với tư tưởng rằng ngữ cảnh và ý nghĩa của một từ có sự tương quan mật thiết đến nhau, năm 2013 nhóm của Mikolov đề xuất một phương pháp mang tên Word2vec.
Ý tưởng chính của Word2vec:

  * Thay thế việc lưu thông tin số lần xuất hiện của các từ trong context window như co-occurrence matrix, word2vec học cách dự đoán các từ lận cận.

  * Tính toán nhanh hơn và có thể transfer learning khi thêm các từ mới vào bộ từ điển.

  * Phương pháp:


Với mỗi từ t trong bộ từ điển ta dự đoán các từ lân cận trong bán kính _m_ của nó.
Hàm mục tiêu nhằm tối ưu xác suất xuất hiện của các từ ngữ cảnh (context word) đối với từ đang xét hiện tại: 
Có 2 kiến trúc khác nhau của word2vec, là CBoW và Skip-Gram:

  * Cbow: Cho trước ngữ cảnh ta dự đoán xác suất từ đích. Ví dụ: "I ... you", với đầu vào là 2 từ "I" và "you" ta cố gắng dự đoán từ còn thiếu, chẳng hạn "love".

  * Skip-Gram: Cho từ đích ta dự đoán xác suất các từ ngữ cảnh (nằm trong context window) của nó. Ví dụ: "... love ...", cho từ "love" ta dự đoán các từ là ngữ cảnh của nó, chẳng hạn "I", "you".


Trong bài báo giới thiệu word2vec, Mikolov và cộng sự có so sánh và cho thấy 2 mô hình này cho kết quả tương đối giống nhau.
Chi tiết mô hình:
![](images/image6.png)
Hình 18.7: Mô hình Cbow
![](images/image7.png)
Hình 18.8: Mô hình Skip-Gram
Do 2 kiến trúc khá giống nhau nên ta chỉ thảo luận về Skip-Gram.
Mô hình Skip-Gram sẽ input từ đích và dự đoán ra các từ ngữ cảnh. Thay vì input từ đích và output ra nhiều từ ngữ cảnh trong 1 mô hình, họ xây dựng model để input từ đích và output ra 1 từ ngữ cảnh.
Mô hình là một mạng neural network 2 lớp, với chỉ 1 hidden layer. Input là một từ trong từ điển đã được mã hóa thành dạng one hot vector chiều _V_ ∗1 với V là kích thước từ điển. Hidden layer không sử dụng activation function có N node, trong đó N chính là độ dài vector embedding của mỗi từ. Output layer có V node, sau đó softmax activation được sử dụng để chuyển về dạng xác suất. Categorical cross entropy loss function được học để dự đoán được từ ngữ cảnh với input là từ đích. Ví dụ của xây dựng training data:
![](images/image8.png)
Hình 18.9: Ví dụ của xây dựng training data, window size = 2, tức là lấy 2 từ bên trái và 2 từ bên phải mỗi từ trung tâm làm từ ngữ cảnh (context word)
Một số kết quả của Word2vec:
![](images/image9.png)
Hình 18.11: Vị trí các word vector trong không gian
Ví dụ trên là ví dụ kinh điển của Word2vec cho thấy các vector biểu diễn tốt quan hệ về mặt ngữ nghĩa của từ vựng như thế nào.

## Output

Bài toán là dự đoán từ tiếp theo trong chuỗi ở input với ảnh hiện tại, nên output là từ nào trong số 1652 từ trong từ điển mà ta có. Với bài toán phân loại thì softmax activation và categorical_crossentropy loss function được sử dụng.

# Public_038

# Giới thiệu

Mô hình RNN ra đời để xử lý các dữ liệu dạng chuỗi (sequence) như text, video.

![](images/image1.png)

Hình 19.1: Các dạng bài toán RNN

Bài toán RNN được phân làm một số dạng:

  * **One to one** : mẫu bài toán cho Neural Network (NN) và Convolutional Neural Network (CNN), 1 input và 1 output, ví dụ với bài toán phân loại ảnh MNIST input là ảnh và output ảnh đấy là số nào.

  * **One to many** : bài toán có 1 input nhưng nhiều output, ví dụ với bài toán caption cho ảnh, input là 1 ảnh nhưng output là nhiều chữ mô tả cho ảnh đấy, dưới dạng một câu.

  * **Many to one** : bài toán có nhiều input nhưng chỉ có 1 output, ví dụ bài toán phân loại hành động trong video, input là nhiều ảnh (frame) tách ra từ video, output là hành động trong video.

  * **Many to many** : bài toán có nhiều input và nhiều output, ví dụ bài toán dịch từ tiếng anh sang tiếng việt, input là 1 câu gồm nhiều chữ: "I love Vietnam" và output cũng là 1 câu gồm nhiều chữ "Tôi yêu Việt Nam". Để ý là độ dài sequence của input và output có thể khác nhau.


Mô hình sequence to sequence (seq2seq) sinh ra để giải quyết bài toán many to many và rất thành công trong các bài toán: dịch, tóm tắt đoạn văn. Bài này mình sẽ cùng tìm hiểu về mô hình seq2seq với bài toán dịch từ tiếng anh sang tiếng việt.

# Mô hình seq2seq

Input của mô hình seq2seq là một câu tiếng anh và output là câu dịch tiếng việt tương ứng, độ dài hai câu này có thể khác nhau. Ví dụ: input: I love teaching -> output: Tôi thích dạy học, input 1 câu 3 từ, output 1 câu 4 từ.

![](images/image2.png)

Hình 19.2: Seq2seq model

Mô hình seq2seq gồm 2 thành phần là encoder và decoder.

![](images/image3.png)

Hình 19.3: Seq2seq model

Encoder nhận input là câu tiếng anh và output ra context vector, còn decoder nhận input là context vector và output ra câu tiếng việt tương ứng. Phần encoder sử dụng mô hình RNN (nói là mô hình RNN nhưng có thể là các mô hình cải tiến như GRU, LSTM) và context vector được dùng là hidden states ở node cuối cùng. Phần decoder cũng là một mô hình RNN với _s_ 0 chính là context vector rồi dần dần sinh ra các từ ở câu dịch.

Phần decoder này giống với bài toán image captioning. Ở bài image captioning mình cũng cho ảnh qua pre-trained model để lấy được embedding vector, sau đó cho embedding vector làm _s_ 0 của mô hình RNN rồi sinh ta caption tương ứng với ảnh.

Bài trước mình đã biết model RNN chỉ nhận input dạng vector nên dữ liệu ảnh (từ) sẽ được encode về dạng vector trước khi cho vào model.

![](images/image4.png)

Hình 19.4: Mô hình encoder

Các từ trong câu tiếng anh sẽ được embedding thành vector và cho vào mô hình RNN, hidden state ở node cuối cùng sẽ được dùng làm context vector. Về mặt lý thuyết thì context vector sẽ mang đủ thông tin của câu tiếng anh cần dịch và sẽ được làm input cho decoder.

![](images/image5.png)

Hình 19.5: Mô hình decoder

2 tag <START> và <END> được thêm vào câu output để chỉ từ bắt đầu và kết thúc của câu dịch. Mô hình decoder nhận input là context vector. Ở node đầu tiên context vector và tag <START> sẽ output ra chữ đầu tiên trong câu dịch, rồi tiếp tục mô hình sinh chữ tiếp theo cho đến khi gặp tag <END> hoặc đến max_length của câu output thì dừng lại.

**Vấn đề** : Mô hình seq2seq encode cả câu tiếng anh thành 1 context vector, rồi dùng context vector để sinh ra các từ trong câu dịch tương ứng tiếng Việt. Như vậy khi câu dài thì rất khó cho decoder chỉ dùng 1 context vector có thể sinh ra được câu output chuẩn. Thêm vào đó các mô hình RNN đều bị mất ít nhiều thông tin ở các node ở xa nên bản thân context vector cũng khó để học được thông tin ở các từ ở phần đầu của encoder.

=> Cần có cơ chế để lấy được thông tin các từ ở input cho mỗi từ cần dự đoán ở output thay vì chỉ dựa vào context vector => **Attention** ra đời.

# Cơ chế attention

## Motivation

Attention tiếng anh nghĩa là chú ý, hay tập trung. Khi dịch ở mỗi từ tiếng việt ta cần chú ý đến 1 vài từ tiếng anh ở input, hay nói cách khác là có 1 vài từ ở input có ảnh hưởng lớn hơn để dịch từ đấy.

![](images/image6.png)

Hình 19.6: Dịch tiếng anh sang tiếng việt, độ quan trọng các từ khi dịch

Ta thấy từ I có trọng số ảnh hưởng lớn tới việc dịch từ tôi, hay từ teaching có ảnh hưởng nhiều tới việc dịch từ dạy và từ học.

=> Do đó khi dịch mỗi từ ta cần chú ý đến các từ ở câu input tiếng anh và đánh trọng số khác nhau cho các từ để dịch chuẩn hơn.

## Cách hoạt động

Attention sẽ định nghĩa ra 3 thành phần query, key, value.

![](images/image7.png)

Hình 19.7: Các thành phần attention

Query (q) lấy thông tin từ từ tiếp theo cần dịch (ví dụ từ dạy). Mỗi từ trong câu input tiếng anh sẽ cho ra 2 thành phần tương ứng là key và value, từ thứ i kí hiệu là _k i_, _v i_.

Mỗi bộ q, _k i _qua hàm _α_ sẽ cho ra _a i _tương ứng, _a i _chính là độ ảnh hưởng của từ thứ i trong input lên từ cần dự đoán. Sau đó các giá trị _a i _được normalize theo hàm softmax được _b i_.

![](images/image8.png)

Hình 19.8: Các thành phần attention

Cuối cùng các giá trị _v i _được tính tổng lại theo hệ số _b i_, output = ∑ _b i _∗ _v i_, trong đó N là số từ trong câu input. Việc normalize các giá trị _a i _giúp output cùng scale với các giá trị value.

![](images/image9.png)

Hình 19.9: Các bước trong attention

Ở phần encoder, thông thường mỗi từ ở input thì hidden state ở mỗi node được lấy làm cả giá trị key và value của từ đấy. Ở phần decoder, ở node 1 gọi input là _x_ 1, output _y_ 1 và hidden state _s_ 1; ở node 2 gọi input là _x_ 2, output _y_ 2. Query là hidden state của node trước của node cần dự đoán từ tiếp theo ( _s_ 1). Các bước thực hiện:

  * Tính score: _a i _= _α_ ( _q,k i_)

  * Normalize score: _b i_

  * Tính output: output_attention = ∑ _b i _∗ _v i_

  * Sau đó kết hợp hidden state ở node trước _s_ 1, input node hiện tại _x_ 2 và giá trị output_attention để dự đoán từ tiếp theo _y_ 2.


![](images/image10.png)

Hình 19.10: Một số hàm _α_ hay được sử dụng

Nhận xét: Cơ chế attention không chỉ dùng context vector mà còn sử dụng hidden state ở từng từ trong input với trọng số ảnh hưởng tương ứng, nên việc dự đoán từ tiếp theo sẽ tốt hơn cũng như không sợ tình trạng từ ở xa bị mất thông tin ở context vector.

Ngoài ra các mô hình deep learning hay bị nói là hộp đen (black box) vì mô hình không giải thích được, attention phần nào giúp visualize được kết quả dự đoán, ví dụ từ nào ở output ảnh hưởng nhiều bởi từ nào trong input. Do đó model học được quan hệ giữa các từ trong input và output để đưa ra kết quả dự đoán.

Lúc đầu cơ chế attention được dùng trong bài toán seq2seq, về sau do ý tưởng attention quá hay nên được dùng trong rất nhiều bài toán khác, ví dụ như trong CNN người ta dùng cơ chế attention để xem pixel nào quan trọng đến việc dự đoán, feature map nào quan trọng hơn trong CNN layer,.. Giống như resnet, attention cũng là 1 đột phá trong deep learning. Mọi người để ý thì các mô hình mới hiện tại đều sử dụng cơ chế attention.

# Public_039

Mô hình GAN được giới thiệu bởi Ian J. Goodfellow vào năm 2014 và đã đạt được rất nhiều thành công lớn trong Deep Learning nói riêng và AI nói chung. Yann LeCun, VP and Chief AI Scientist, Facebook, từng mô tả về GAN: "The most interesting idea in the last 10 years in Machine Learning". Để mọi người thấy được các ứng dụng của GAN, phần dưới tôi sẽ trình bày một vài ứng dụng điển hình của GAN.

# Ứng dụng của GAN

## Generate Photographs of Human Faces

Ví dụ về ảnh mặt người do GAN sinh ra từ 2014 đến 2017. Mọi người có thể thấy chất lượng ảnh sinh ra tốt lên đáng kể theo thời gian.

![](images/image1.png)

Hình 20.1: Ảnh mặt GAN sinh ra qua các năm, Malicious Use of Artificial Intelligence: Forecasting, Prevention, and Mitigation, 2018.

Hình dưới là ảnh sinh ra bởi GAN năm 2018, phải để ý rất chi tiết thì mới có thể phân biệt được ảnh mặt đấy là sinh ra hay ảnh thật.

![](images/image2.png)

Hình 20.2: [StyleGAN](https://github.com/NVlabs/stylegan)

## Image editing

Chắc mọi người vẫn nhớ tới FaceApp làm mưa làm gió trong thời gian vừa qua. Nó là một ứng dụng của GAN để sửa các thuộc tính của khuôn mặt như màu tóc, da, giới tính, cảm xúc hay độ tuổi.

![](images/image3.png)

Hình 20.3: [StarGAN](https://github.com/yunjey/stargan)

![](images/image4.png)

Hình 20.4: [Age-cGAN](https://arxiv.org/pdf/1702.01983.pdf)

## Generate Realistic Photographs

Năm 2018, Andrew Brock cho ra paper [bigGAN](https://arxiv.org/abs/1809.11096) với có khả năng sinh ra các ảnh tự nhiên rất khó phân biệt với ảnh chụp thường.

![](images/image5.png)

Hình 20.5: Example of Realistic Synthetic Photographs Generated with BigGAN Taken from Large Scale GAN Training for High Fidelity Natural Image Synthesis, 2018.

## Image-to-Image Translation

Ví dụ điển hình của mô hình image to image translation là Pix2pix. Input là 1 ảnh và output là 1 ảnh tương ứng, ví dụ input là ảnh không màu, output là ảnh màu. Mọi người có thể vào [đây](https://affinelayer.com/pixsrv/) thử, input là bản phác (draft) con mèo, output là ảnh con mèo hay input là các khối block, output là ảnh ngôi nhà.

![](images/image6.png)

Hình 20.6: Ví dụ ảnh draft sang ảnh màu, taken from Image-to-Image Translation with Conditional Adversarial Networks, 2016.

# GAN là gì?

GAN thuộc nhóm generative model. Generative là tính từ nghĩa là khả năng sinh ra, model nghĩa là mô hình. Vậy hiểu đơn giản generative model nghĩa là mô hình có khả năng sinh ra dữ liệu. Hay nói cách khác, GAN là mô hình có khả năng sinh ra dữ liệu mới. Ví dụ như những ảnh mặt người ở trên bạn thấy là do GAN sinh ra, không phải mặt người thật. Dữ liệu sinh ra nhìn như thật nhưng không phải thật.

GAN viết tắt cho Generative Adversarial Networks. Generative giống như ở trên, Network có nghĩa là mạng (mô hình), còn Adversarial là đối nghịch. Tên gọi như vậy là do GAN được cấu thành từ 2 mạng gọi là Generator và Discriminator, luôn đối nghịch đầu với nhau trong quá trình train mạng GAN. Chi tiết sẽ được trình bày ở phần dưới.

Tóm lại GAN là mạng để sinh dữ liệu mới giống với dữ liệu trong dataset có sẵn và có 2 mạng trong GAN là Generator và Discriminator.

# Cấu trúc mạng GAN

GAN cấu tạo gồm 2 mạng là Generator và Discriminator. Trong khi Generator sinh ra các dữ liệu giống như thật thì Discriminator cố gắng phân biệt đâu là dữ liệu được sinh ra từ Generator và đâu là dữ liệu thật có.

Ví dụ bài toán giờ là dùng GAN để generate ra tiền giả mà có thể dùng để chi tiêu được. Dữ liệu có là tiền thật.

Generator giống như người làm tiền giả còn Discriminator giống như cảnh sát. Người làm tiền giả sẽ cố gắng làm ra tiền giả mà cảnh sát cũng không phân biệt được. Còn cảnh sát sẽ phân biệt đâu là tiền thật và đâu là tiền giả. Mục tiêu cuối cùng là người làm tiền giả sẽ làm ra tiền mà cảnh sát cũng không phân biệt được đâu là thật và đâu là giả và thế là mang tiền đi tiêu được.

Trong quá trình train GAN thì cảnh sát có 2 việc: 1 là học cách phân biệt tiền nào là thật, tiền nào là giả, 2 là nói cho thằng làm tiền giả biết là tiền nó làm ra vẫn chưa qua mắt được và cần cải thiện hơn. Dần dần thì thằng làm tiền giả sẽ làm tiền giống tiền thật hơn và cảnh sát cũng thành thạo việc phân biệt tiền giả và tiền thật. Và mong đợi là tiền giả từ GAN sẽ đánh lừa được cảnh sát.

Ý tưởng của GAN bắt nguồn từ [zero-sum non-cooperative game,](https://cs.stanford.edu/people/eroberts/courses/soco/projects/1998-99/game-theory/nonzero.html) hiểu đơn giản như trò chơi đối kháng 2 người (cờ vua, cờ tướng), nếu một người thắng thì người còn lại sẽ thua. Ở mỗi lượt thì cả 2 đều muốn maximize cơ hội thắng của tôi và minimize cơ hội thắng của đối phương. Discriminator và Generator trong mạng GAN giống như 2 đối thủ trong trò chơi. Trong lý thuyết trò chơi thì GAN model converge khi cả Generator và Discriminator đạt tới trạng thái Nash equilibrium, tức là 2 người chơi đạt trạng thái cân bằng và đi tiếp các bước không làm tăng cơ hội thắng. "A strategy profile is a Nash equilibrium if no player can do better by unilaterally changing his or her strategy", [nguồn.](https://medium.com/cantors-paradise/the-nash-equilibrium-explained-c9ad7e97633a)

**Bài toán** : Dùng mạng GAN sinh ra các chữ số viết tay giống với dữ liệu trong [MNIST dataset.](http://yann.lecun.com/exdb/mnist/)

## Generator

Generator là mạng sinh ra dữ liệu, tức là sinh ra các chữ số giống với dữ liệu trong MNIST dataset. Generator có input là noise (random vector) là output là chữ số.

Tại sao input là noise? Vì các chữ số khi viết ra không hoàn toàn giống nhau. Ví dụ số 0 ở hàng đầu tiên có rất nhiều biến dạng nhưng vẫn là số 0. Thế nên input của Generator là noise để khi ta thay đổi noise ngẫu nhiên thì Generator có thể sinh ra một biến dạng khác của chữ viết tay. Noise cho Generator thường được sinh ra từ normal distribution hoặc uniform distribution.

![](images/image7.png)

Hình 20.14: MNIST dataset, [nguồn](https://syncedreview.com/2019/06/19/mnist-reborn-restored-and-expanded-additional-50k-training-samples/)

Input của Generator là noise vector 100 chiều. Sau đấy mô hình neural network được áp dụng với số node trong hidden layer lần lượt là 256, 512, 1024.

![](images/image8.png)

Hình 20.15: Mô hình generator

Output layer có số chiều là 784, vì output đầu ra là ảnh giống với dữ liệu MNIST, ảnh xám kích thước 28*28 (784 pixel).

Output là vector kích thước 784*1 sẽ được reshape về 28*28 đúng định dạng của dữ liệu MNIST.

![](images/image9.png)

Hình 20.16: Ví dụ về reshape, [nguồn](http://jalammar.github.io/visual-numpy/)

## Discriminator

Discriminator là mạng để phân biệt xem dữ liệu là thật (dữ liệu từ dataset) hay giả (dữ liệu sinh ra từ Generator). Trong bài toán này thì discriminator dùng để phân biệt chữ số từ bộ MNIST và dữ liệu sinh ra từ Generator. Discriminator có input là ảnh biểu diễn bằng 784 chiều, output là ảnh thật hay ảnh giả.

Đây là bài toán binary classification, giống với [logistic regression.](https://nttuan8.com/bai-2-logistic-regression/)

![](images/image10.png)

Hình 20.17: Ví dụ về reshape, [nguồn](http://jalammar.github.io/visual-numpy/)

Input của Discriminator là ảnh kích thước 784 chiều.

Sau đấy mô hình neural network được áp dụng với số node trong hidden layer lần lượt là 1024, 512, 256. Mô hình đối xứng lại với Generator.

Output là 1 node thể hiện xác suất ảnh input là ảnh thật, hàm sigmoid được sử dụng.

# Public_040

# Deep Convolutional GAN

Bài trước tôi đã giới thiệu về GAN, cấu trúc mạng GAN và hướng dẫn dùng GAN để sinh các số trong bộ dữ liệu MNIST. Tuy nhiên mô hình của Generator và Discriminator đều dùng Neural Network. Trong khi ở bài CNN tôi đã biết CNN xử lý dữ liệu ảnh tốt hơn và hiệu quả hơn rất nhiều so với Neural Network truyền thống. Vậy nên bài này tôi sẽ hướng dẫn áp dụng CNN vào mô hình GAN bài trước, mô hình đấy gọi là Deep Convolutional GAN (DCGAN).

Bài toán: Dùng mạng GAN sinh ra các ảnh giống với dữ liệu trong CIFAR-10 dataset.

CIFAR-10 dataset bao gồm 60000 ảnh màu kích thước 32x32 thuộc 10 thể loại khác nhau. Mỗi thể loại có 6000 ảnh.

## Cấu trúc mạng

Nhắc lại bài trước 1 chút thì GAN gồm 2 mạng là generator và discriminator. Trong khi discriminator được train để phân biệt ảnh thật (trong dataset) và ảnh fake (do generator sinh ra), thì generator được train để đánh lừa discriminator. Ở bài trước thì cả generator và discriminator đều được xây bằng mạng neural network thông thường với các fully connected layer, bài này thì generator và discriminator được xây dựng bằng mô hình CNN với 2 layers chính là convolutional layer và transposed convolutional layer.

### Generator

Mạng Generator nhằm mục đích sinh ảnh fake, input là noise vector kích thước 128 và output và ảnh fake cùng kích thước ảnh thật (32 * 32 *3)

![](images/image1.png)

Hình 21.1: Mô hình generator của DCGAN

Các layer trong mạng

  * Dense (fully-connected) layer: 128*1 -> 2048*1

  * Flatten chuyển từ vector về dạng tensor 3d, 2048*1 -> 2*2*512

  * Transposed convolution stride=2, kernel=256, 2*2*512 -> 4*4*256 • Transposed convolution stride=2, kernel=128, 4*4*256 -> 8*8*128

  * Transposed convolution stride=2, kernel=64, 8*8*128 -> 16*16*64

  * Transposed convolution stride=2, kernel=3, 16*16*64 -> 32*32*3


Đầu tiên thì input noise (128) được dùng full-connected layer chuyển thành 2048 ( = 2*2*512). Số 2048 được chọn để reshape về dạng tensor 3d (2*2*512). Sau đó transposed convolution với stride = 2 được dùng để tăng kích thước tensor lên dần 4*4 -> 8*8 -> 16*16 -> 32*32. Cho tới khi kích thước tensor 32*32 (bằng đúng width, height của ảnh trong CIFAR-10 dataset) thì ta dùng 3 kernel để ra đúng shape của ảnh.

Mọi người để ý thấy là khi width, height tăng thì depth sẽ giảm, cũng giống như trong mạng CNN bình thường width, height giảm thì depth sẽ tăng.

Transposed convolution hay deconvolution có thể coi là phép toán ngược của convolution. Nếu như convolution với stride > 1 giúp làm giảm kích thước của ảnh thì transposed convolution với stride > 1 sẽ làm tăng kích thước ảnh. Ví dụ stride = 2 và padding = ’SAME’ sẽ giúp gấp đôi width, height kích thước của ảnh.

Transposed convolution có 2 kiểu định nghĩa:

  * **Kiểu 1** Kiểu 1 được định nghĩa đơn giản hơn lấy từ sách Dive into deep learning. Ý tưởng đơn giản là transposed convolution là phép tính ngược của convolution.


![](images/image2.png)

Hình 21.3: Convolution s=1, p=0

Nếu như ở phép tính convolution thì 1 vùng kích thước 2*2 được nhân element-wise với kernel và tính tổng viết ra ở output thì ở phép tính transposed convolution mỗi phần tử ở input sẽ được nhân với kernel và ma trận kết quả cùng kích thước với kernel được viết vào output. Nếu các phần tử ở output viết đè lên nhau thì ta sẽ cộng dồn vào.

![](images/image3.png)

Hình 21.4: Transposed convolution với s=1, p=0

Stride trong transposed convolution được định nghĩa là số bước nhảy khi viết kết quả ra ma trận output. Với padding thì ta tính toán bình thường như với p=0 sau đó kết quả ta sẽ bỏ p hàng và cột ở 4 cạnh (trên, dưới, trái, phải)

![](images/image4.png)

Hình 21.6: Transposed convolution s=2, p=1

  * **Kiểu 2** Kiểu định nghĩa thứ 2 thì phức tạp hơn nhưng lại có vẻ chuẩn và hay gặp hơn. Ý nghĩa của stride và padding ở đây là khi ta thực hiện phép tính convolution trên output sẽ được kích thước giống input.


![](images/image5.png)

Hình 21.7: Các bước thực hiện transposed convolution

### Discriminator

Mạng Discriminator nhằm mục đích phân biệt ảnh thật từ dataset và ảnh fake do Generator sinh ra, input là ảnh kích thước (32 * 32 *3), output là ảnh thật hay fake (binary classification)

![](images/image6.png)

Hình 21.8: Mô hình discriminator của DCGAN

Mô hình discriminator đối xứng lại với mô hình generator. Ảnh input được đi qua convolution với stride = 2 để giảm kích thước ảnh từ 32*32 -> 16*16 -> 8*8 -> 4*4 -> 2*2. Khi giảm kích thước thì depth tăng dần. Cuối cùng thì tensor shape 2*2*512 được reshape về vector 2048 và dùng 1 lớp fully connected chuyển từ 2048d về 1d.

Loss function được sử dụng giống như bài trước về GAN.

## Tips

Đây là một số tips để build model và train DCGAN

  * Dùng ReLU trong generator trừ output layer

  * Output layer trong generator dùng tanh (-1, 1) và scale ảnh input về (-1,1) sẽ cho kết quả tốt hơn dùng sigmoid và scale ảnh về (0, 1) hoặc để nguyên ảnh.

  * Sử dụng Leaky ReLU trong discriminator

  * Thay thế max pooling bằng convolution với stride = 2

  * Sử dụng transposed convolution để upsampling

  * Sử dụng batch norm từ output layer trong generator và input layer trong discriminator


## Thực nghiệm

Ảnh CIFAR-10 được scale về (-1, 1) để cùng scale với ảnh sinh ra bởi generator khi dùng tanh activation.

Ở những epoch đầu tiên thì generator chỉ sinh ra noise.

![](images/image7.png)

Hình 21.9: Ảnh sinh ra bởi generator sau 10 epochs

Tuy nhiên sau 150 epoch thì mạng đã học được thuộc tính của ảnh trong dữ liệu CIFAR-10 và có thể sinh ra được hình con chim, ô tô.

![](images/image8.png)

Hình 21.10: Ảnh sinh ra bởi generator sau 150 epochs **  
**

# Conditional GAN

Phần trước tôi giới thiệu về DCGAN, dùng deep convolutional network trong mô hình GAN. Tuy nhiên khi ta train GAN xong rồi dùng generator để sinh ảnh mới giống trong dataset tôi không kiểm soát được là ảnh sinh ra giống category nào trong dataset. Ví dụ như dùng GAN để sinh các chữ số trong bộ MNIST, thì khi train xong và dùng generator sinh ảnh thì tôi không biết được ảnh sinh ra sẽ là số mấy (0 -> 9). Bài toán hôm nay muốn kiểm soát được generator sinh ra ảnh theo 1 category nhất định. Ví dụ có thể chỉ định generator sinh ra số 1 chẳng hạn. Mô hình đấy gọi là Conditional GAN (cGAN).

## Fashion-MNIST

Dữ liệu Fashion-MNIST về quần áo, giày dép gồm 60000 ảnh training và 10000 ảnh test. Ảnh xám kích thước 28*28 thuộc 10 lớp khác nhau.


| 0 | T-shirt/top |
| --- | --- |
| 1 | Trouser |
| 2 | Pullover |
| 3 | Dress |
| 4 | Coat |
| 5 | Sandal |
| 6 | Shirt |
| 7 | Sneaker |
| 8 | Bag |
| 9 | Ankle boot |

 

Bài toán hôm nay sẽ dùng cGAN để sinh ra dữ liệu trong từng thể loại ở dữ liệu Fashion-MNIST như sinh ra các ảnh áo Shirt. Ví dụ dữ liệu Fashion-MNIST ở hình 22.1

![](images/image9.png)

Hình 22.1: Ảnh dữ liệu Fashion-MNIST

## Cấu trúc mạng

### Generator

Ở bài trước thì Generator sinh ảnh fake từ noise vector. Cái hay của random vector là có thể sample được nhiều giá trị khác nhau, thành ra khi train xong mạng GAN thì có thể sinh được nhiều ảnh fake khác nhau. Tuy nhiên lại không thể kiểm soát xem ảnh sinh ra thuộc thể loại nào (áo, giày, dép,...).

Bên cạnh noise vector z, tôi sẽ thêm vào y, 1 số từ (0 - 9), mỗi thể loại trong dữ liệu Fashion-MNIST sẽ được encode về 1 số. tôi mong muốn là z với số y nào thì sẽ cho ra dữ liệu tương ứng thể loại đấy.

![](images/image10.png)

Hình 22.2: Mô hình Generator cGAN

Input z là noise vector như bài trước, sau đấy được qua dense layer về kích thước 7*7*128 rồi reshape về dạng 3D tensor kích thước 7x7x128 (y1)

Input y là 1 số được đi qua embedding layer của keras, layer này giống như 1 dictionary map mỗi số thành một vector 50*1, sau đó được qua dense với output 49 node cuối cùng được reshape về 3D tensor kích thước 7x7x1 (y2)

Sau đó y1 và y2 được xếp chồng lên nhau thành tensor 3d kích thước 7*7*129, tiếp đi qua transposed convolution để tăng kích thước lên 14*14 và 28*28, cuối cùng cho ra output 28*28*1.

### Discriminator

Discriminator mục đích phân biệt ảnh thật trong dataset và ảnh fake sinh ra bởi generator.

Tương tự như ở trong generator bên cạnh ảnh, tôi sẽ thêm vào y, 1 số từ (0 - 9) tương ứng với thể loại trong dữ liệu Fashion-MNIST.

![](images/image11.png)

Hình 22.3: Mô hình Discriminator cGAN

Input y là 1 số được đi qua embedding layer của keras, layer này giống như 1 dictionary map mỗi số thành một vector 50*1, sau đó được qua dense với output 28*28 node cuối cùng được reshape về 3D tensor kích thước 28x28x1 (y1)

Sau đó y1 và ảnh input được xếp chồng lên nhau thành tensor 3d kích thước 28*28*2, sau đó tensor đi qua convolution với stride = 2 để giảm kích thước ảnh từ 28*28 -> 14*14 -> 7*7. Khi giảm kích thước thì depth tăng dần. Cuối cùng thì tensor shape 2*2*512 được reshape về vector 2048 và dùng 1 lớp fully connected chuyển từ 2048d về 1d.

### Loss function

![](images/image12.png)

Hình 22.4: Loss function cGAN

# Public_041

# Bài toán

Ngân hàng bạn đang làm có chương trình cho vay ưu đãi cho các đối tượng mua chung cư. Tuy nhiên gần đây có một vài chung cư rất hấp dẫn (giá tốt, vị trí đẹp,...) nên lượng hồ sơ người nộp cho chương trình ưu đãi tăng đáng kể. Bình thường bạn có thể duyệt 10-20 hồ sơ một ngày để quyết định hồ sơ có được cho vay hay không, tuy nhiên gần đây bạn nhận được 1000-2000 hồ sơ mỗi ngày. Bạn không thể xử lý hết hồ sơ và bạn cần có một giải pháp để có thể dự đoán hồ sơ mới là có nên cho vay hay không.
Sau khi phân tích thì bạn nhận thấy là hai yếu tố chính quyết định đến việc được vay tiền đó là mức lương và thời gian công tác. Đây là dữ liệu bạn có từ trước đến nay:


| Lương | Thời gian làm việc | Cho vay |
| --- | --- | --- |
| 10 | 1 | 1 |
| 9 | 0.5 | 1 |
| 5 | 2 | 1 |
| ... | ... | ... |
| 8 | 0.1 | 0 |
| 6 | 0.3 | 0 |
| 7 | 0.15 | 0 |
| ... | ... | ... |

 

Khi có dữ liệu bạn visualize dữ liệu lên như hình 4.1
Về mặt logic, giờ ta cần tìm đường thẳng phân chia giữa các điểm cho vay và từ chối. Rồi quyết định hồ sơ mới có nên có vay hay không từ đường đấy như hình 4.2
![](images/image1.png)
Hình 4.1: Đồ thị giữa mức lương, số năm kinh nghiệm và kết quả cho vay
![](images/image7.png)
Hình 4.2: Đường phân chia và dự đoán điểm dữ liệu mới
Ví dụ đường xanh là đường phân chia. Dự đoán cho hồ sơ của người có mức lương 6 triệu và 1 năm kinh nghiệm là không cho vay.
Tuy nhiên, do ngân hàng đang trong thời kỳ khó khăn nên việc cho vay bị thắt lại, chỉ những hồ sơ nào chắc chắn trên 80% mới được vay.
Vậy nên bây giờ bạn không những tìm là hồ sơ ấy cho vay hay không cho vay mà cần tìm xác suất nên cho hồ sơ ấy vay là bao nhiêu.
Hay trong nhiều trường hợp khác trong bài toán phân loại người ta quan tâm hơn đến xác suất hay vì chỉ 1 hay 0. Ví dụ: bác sĩ sẽ thông báo ca mổ này 80% thành công cho người nhà bệnh nhân.

# Xác suất

Bạn được học xác suất từ cấp hai, cấp ba rồi đến toán cao cấp, nhưng có bao giờ bạn hỏi tại sao lại có xác suất không? Vì trong cuộc sống này có những sự việc không chắc chắn, ví dụ ngày mai trời có mưa không. Vậy nên xác suất ra đời để đo lường sự không chắc chắn ấy.
Vậy xác suất là gì? "Các nhà toán học coi xác suất là các số trong khoảng [0,1], được gán tương ứng với một biến cố mà khả năng xảy ra hoặc không xảy ra là ngẫu nhiên" [28]. Ví dụ bạn tung đồng xu có 2 mặt, thì xác suất bạn tung được mặt ngửa là 50% ( = 50/100 = 0.5).
Nhận xét:

  * Xác suất của 1 sự kiện trong khoảng [0,1]

  * Sự kiện bạn càng chắc chắn xảy ra thì xác suất càng cao. Ví dụ bạn lương cao và còn đi làm lâu lăm thì xác suất bạn được vay mua chung cư là cao.

  * Tổng xác suất của sự kiện A và sự kiện phủ định của A là 100% (hay 1). Ví dụ sự kiện A: tung đồng xu mặt ngửa, xác suất 50%; phủ định của sự kiện A: tung đồng xu mặt sấp, xác suất 50% => tổng 100%.


Bạn sẽ thấy xác suất quan trọng hơn là chỉ 0 hay 1, ví dụ trước mỗi ca mổ khó, bác sĩ không thể chắc chắn là sẽ thất bại hay thành công mà chỉ có thể nói xác suất thành công là bao nhiêu (ví dụ 80%).

# Hàm sigmoid

Giờ ta cần tìm xác suất của hồ sơ mới nên cho vay. Hay giá trị của hàm cần trong khoảng [0,1]. Rõ ràng là giá trị của phương trình đường thẳng như bài trước có thể ra ngoài khoảng [0,1] nên cần một hàm mới luôn có giá trị trong khoảng [0,1]. Đó là hàm sigmoid.
![](images/image4.png)
Hình 4.3: Đồ thị hàm sigmoid
Nhận xét:

  * Hàm số liên tục, nhận giá trị thực trong khoảng (0,1).

  * Hàm có đạo hàm tại mọi điểm (để áp dụng gradient descent).


# Thiết lập bài toán

Mọi người có để ý các bước trong bài linear regression không nhỉ, các bước bao gồm:

  1. Visualize dữ liệu

  2. Thiết lập model

  3. Thiết lập loss function

  4. Tìm tham số bằng việc tối ưu loss function

  5. Dự đoán dữ liệu mới bằng model vừa tìm được 


Đây là mô hình chung cho bài toán trong Deep Learning.

## Model

Với dòng thứ i trong bảng dữ liệu, gọi _x_ 1 là lương và _x_ 2 là thời gian làm việc của hồ sơ thứ i .
$$
p(x(i)=1)=ŷipleft( x^{(i)} = 1 right) = {widehat{y}}_{i}
$$ là xác suất mà model dự đoán hồ sơ thứ i được cho vay.
$$
p(x(i)=0)=1−ŷipleft( x^{(i)} = 0 right) = 1 - {widehat{y}}_{i}
$$là xác suất mà model dự đoán hồ sơ thứ i không được cho vay.
Như bài trước công thức của linear regression là: $$
ŷi=w0+w1x1+w2x2{widehat{y}}_{i} = w_{0} + w_{1}x_{1} + w_{2}x_{2}
$$ thì giờ công thức của logistic regression là:

$$
ŷi=σ(w0+w1x1(i)+w2x2(i))=11+e−(w0+w1x1(i)+w2x2(i)){widehat{y}}_{i} = sigmaleft( w_{0} + w_{1}x_{1}^{(i)} + w_{2}x_{2}^{(i)} right) = frac{1}{1 + e^{- left( w_{0} + w_{1}x_{1}^{(i)} + w_{2}x_{2}^{(i)} right)}}
$$

Ở phần cuối mọi người sẽ thấy được quan hệ giữa xác suất và đường thẳng.

## Loss function

Giờ cũng cần một hàm để đánh giá độ tốt của model. Như bài trước là _y_ ˆ càng gần y càng tốt, giờ cũng vậy:

  * Nếu hồ sơ thứ i là cho vay, tức _y i _= 1 thì ta cũng mong muốn _y_ ˆ _i_ càng gần 1 càng tốt hay model dự đoán xác suất người thứ i được vay vốn càng cao càng tốt.

  * Nếu hồ sơ thứ i không được vay, tức _y i _= 0 thì ta cũng mong muốn _y_ ˆ _i_ càng gần 0 càng tốt hay model dự đoán xác suất người thứ i được vay vốn càng thấp càng tốt.


Với mỗi điểm ![](images/image3.png), gọi hàm loss function $$
L=−(yiloglogŷi+(1−yi)loglog(1−ŷi))L = - left( y_{i}loglog {widehat{y}}_{i}  + left( 1 - y_{i} right)loglog left( 1 - {widehat{y}}_{i} right)  right)
$$, loss function này có tên gọi là binary_crossentropy
**Mặc định trong machine learning nói chung hay deep learning thì viết log hiểu là ln**
Thử đánh giá hàm L nhé. Nếu _y i _= 1 => L = − _log_ ( _y_ ˆ _i_ )
![](images/image2.png)
Hình 4.4: Đồ thị hàm loss function trong trường hợp _y i _= 1
Nhận xét:

  * Hàm L giảm dần từ 0 đến 1.

  * Khi model dự đoán _y_ ˆ _i_ gần 1, tức giá trị dự đoán gần với giá trị thật _y i _thì L nhỏ, xấp xỉ 0

  * Khi model dự đoán _y_ ˆ _i_ gần 0, tức giá trị dự đoán ngược lại giá trị thật _y i _thì L rất lớn


Ngược lại, nếu _y i _= 0 => L = − _log_ (1− _y_ ˆ _i_ )
![](images/image5.png)
Hình 4.5: Đồ thị hàm loss function trong trường hợp _y i _= 0
Nhận xét:

  * Hàm L tăng dần từ 0 đến 1

  * Khi model dự đoán _y_ ˆ _i_ gần 0, tức giá trị dự đoán gần với giá trị thật _y i _thì L nhỏ, xấp xỉ 0

  * Khi model dự đoán _y_ ˆ _i_ gần 1, tức giá trị dự đoán ngược lại giá trị thật _y i _thì L rất lớn => Hàm L nhỏ khi giá trị model dự đoán gần với giá trị thật và rất lớn khi model dự đoán sai, hay nói cách khác L càng nhỏ thì model dự đoán càng gần với giá trị thật. => Bài toán tìm model trở thành tìm giá trị nhỏ nhất của L


Hàm loss function trên toàn bộ dữ liệu $$
J=−1N∑i=1N(yiloglogŷi+(1−yi)loglog(1−ŷi))J = - frac{1}{N}sum_{i = 1}^{N}left( y_{i}loglog {widehat{y}}_{i}  + left( 1 - y_{i} right)loglog left( 1 - {widehat{y}}_{i} right)  right)
$$

# Public_042

# Neural network là gì

Con chó có thể phân biệt được người thân trong gia đình và người lạ hay đứa trẻ có thể phân biệt được các con vật. Những việc tưởng chừng như rất đơn giản nhưng lại cực kì khó để thực hiện bằng máy tính. Vậy sự khác biệt nằm ở đâu? Câu trả lời nằm ở cấu trúc bộ não với lượng lớn các nơ-ron thần kinh liên kết với nhau. Liệu máy tính có thể mô phỏng lại cấu trúc bộ não để giải các bài toán trên ???
Neural là tính từ của neuron (nơ-ron), network chỉ cấu trúc, cách các nơ-ron đó liên kết với nhau, nên neural network (NN) là một hệ thống tính toán lấy cảm hứng từ sự hoạt động của các nơ-ron trong hệ thần kinh.

## Hoạt động của các nơ-ron

Nơ-ron là đơn vị cơ bản cấu tạo hệ thống thần kinh và là thành phần quan trọng nhất của não. Đầu chúng ta gồm khoảng 10 triệu nơ-ron và mỗi nơ-ron lại liên kết với tầm 10.000 nơ-ron khác.
Ở mỗi nơ-ron có phần thân (soma) chứa nhân, các tín hiệu đầu vào qua sợi nhánh (dendrites) và các tín hiệu đầu ra qua sợi trục (axon) kết nối với các nơ-ron khác. Hiểu đơn giản mỗi nơ-ron nhận dữ liệu đầu vào qua sợi nhánh và truyền dữ liệu đầu ra qua sợi trục, đến các sợi nhánh của các nơ-ron khác.
Mỗi nơ-ron nhận xung điện từ các nơ-ron khác qua sợi nhánh. Nếu các xung điện này đủ lớn để kích hoạt nơ-ron, thì tín hiệu này đi qua sợi trục đến các sợi nhánh của các nơ-ron khác.
![](images/image1.png)
Hình 5.1: Tế bào thần kinh [14]
=> Ở mỗi nơ-ron cần quyết định có kích hoạt nơ-ron đấy hay không. Tương tự các hoạt động của hàm sigmoid bài trước.
Tuy nhiên NN chỉ là lấy cảm hứng từ não bộ và cách nó hoạt động, chứ không phải bắt chước toàn bộ các chức năng của nó. Việc chính của chúng ta là dùng mô hình đấy đi giải quyết các bài toán chúng ta cần.

# Mô hình neural network

## Logistic regression

Logistic regression là mô hình neural network đơn giản nhất chỉ với input layer và output layer.
Mô hình của logistic regression từ bài trước là: _y_ ˆ= _σ_ ( _w_ 0+ _w_ 1∗ _x_ 1+ _w_ 2∗ _x_ 2). Có 2 bước:
Tính tổng linear: _z_ =1∗ _w_ 0+ _x_ 1∗ _w_ 1+ _x_ 2∗ _w_ 2
Áp dụng sigmoid function: _y_ ˆ= _σ_ ( _z_ )
Để biểu diễn gọn lại ta sẽ gộp hai bước trên thành một trên biểu đồ như hình 5.2.
![](images/image2.png)
Hình 5.2: Mô hình logistic regression
Hệ số _w_ 0 được gọi là bias. Để ý từ những bài trước đến giờ dữ liệu khi tính toán luôn được thêm 1 để tính hệ số bias _w_ 0 . Tại sao lại cần hệ số bias? Quay lại với bài 1, phương trình đường thẳng sẽ thế nào nếu bỏ _w_ 0, phương trình giờ có dạng: _y_ = _w_ 1∗ _x_ , sẽ luôn đi qua gốc tọa độ và nó không tổng quát hóa phương trình đường thẳng nên có thể không tìm được phương trình mong muốn. => Việc thêm bias (hệ số tự do) là rất quan trọng.
Hàm sigmoid ở đây được gọi là activation function.

## Mô hình tổng quát

Layer đầu tiên là input layer, các layer ở giữa được gọi là hidden layer, layer cuối cùng được gọi là output layer. Các hình tròn được gọi là node.
Mỗi mô hình luôn có 1 input layer, 1 output layer, có thể có hoặc không các hidden layer. Tổng số layer trong mô hình được quy ước là số layer - 1 (không tính input layer).
Ví dụ như ở hình trên có 1 input layer, 2 hidden layer và 1 output layer. Số lượng layer của mô hình là 3 layer.
Mỗi node trong hidden layer và output layer :
Liên kết với tất cả các node ở layer trước đó với các hệ số w riêng.
Mỗi node có 1 hệ số bias b riêng.
Diễn ra 2 bước: tính tổng linear và áp dụng activation function.

## Kí hiệu

Số node trong hidden layer thứ i là _l_ ( _i_ ).
Ma trận _W_ ( _k_ ) kích thước _l_ ( _k_ −1) ∗ _l_ ( _k_ ) là ma trận hệ số giữa layer (k-1) và layer k, trong đó _w_ ( _ij k_) là hệ số kết nối từ node thứ i của layer k-1 đến node thứ j của layer k.
![](images/image3.png)
Hình 5.3: Mô hình neural network
Vector $b(k)b^{(k)}$ kích thước $lkl^{k}$∗1 là hệ số bias của các node trong layer k, trong đó _b_ ( _i k_) là bias của node thứ i trong layer k.
( _l_ )
Với node thứ i trong layer l có bias _b i(l)_ thực hiện 2 bước:

  * Tính tổng tất cả các node trong layer trước nhân với hệ số w tương ứng, rồi cộng với bias b.


Áp dụng activation function: _a i(l)_ = _σ_ ( _z i (l)_)
Vector _z_ ( _k_ ) kích thước _l_ ( _k_ ) ∗1 là giá trị các node trong layer k sau bước tính tổng linear.
Vector _a_ ( _k_ ) kích thước _l_ ( _k_ ) ∗1 là giá trị của các node trong layer k sau khi áp dụng hàm activation function.
![](images/image4.png)
Mô hình neural network trên gồm 3 layer. Input layer có 2 node ( _l_ (0) =2), hidden layer 1 có 3 node, hidden layer 2 có 3 node và output layer có 1 node.
Do mỗi node trong hidden layer và output layer đều có bias nên trong input layer và hidden layer cần thêm node 1 để tính bias (nhưng không tính vào tổng số node layer có).

# Feedforward

Để nhất quán về mặt ký hiệu, gọi input layer là _a_ (0)(= _x_ ) kích thước 2*1.
![](images/image5.png)
Tương tự ta có:
_z_ (2) =( _W_ (2)) _T_ ∗ _a_ (1) + _b_ (2)
_a_ (2) = _σ_ ( _z_ (2)) 
_z_ (3) =( _W_ (3)) _T_ ∗ _a_ (2) + _b_ (3)
_y_ ˆ= _a_ (3) = _σ_ ( _z_ (3))
![](images/image6.png)
Hình 5.4: Feedforward

# Logistic regression với toán tử XOR

Phần này không bắt buộc, nó giúp giải thích việc có nhiều layer hơn thì mô hình sẽ giải quyết được các bài toán phức tạp hơn. Cụ thể là mô hình logistic regression bài trước không biểu diễn được toán tử XOR nhưng nếu thêm 1 hidden layer với 2 node ở giữa input layer và output layer thì có thể biểu diễn được toán tử XOR.
AND, OR, XOR là các phép toán thực hiện phép tính trên bit. Thế bit là gì? bạn không cần quan tâm, chỉ cần biết mỗi bit nhận 1 trong 2 giá trị là 0 hoặc 1.

## NOT

Phép tính NOT của 1 bit cho ra giá trị ngược lại.


| A | NOT(A) |
| --- | --- |
| 0 | 1 |
| 1 | 0 |

 

## AND

Phép tính AND của 2 bit cho giá trị 1 nếu cả 2 bit bằng 1 và cho giá trị bằng 0 trong các trường hợp còn lại. Bảng chân lý


| A | B | A AND B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

 

## OR

Phép tính OR của 2 bit cho giá trị 1 nếu 1 trong 2 bit bằng 1 và cho giá trị bằng 0 trong các trường hợp còn lại. Bảng chân lý


| A | B | A OR B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

 

## XOR

Phép tính XOR của 2 bit cho giá trị 1 nếu đúng 1 trong 2 bit bằng 1 và cho giá trị bằng 0 trong các trường hợp còn lại. Bảng chân lý


| A | B | A XOR B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

 

Khi thiết lập bài toán logistic regression, ta có đồ thị
![](images/image7.png)
Rõ ràng là không thể dùng một đường thẳng để phân chia dữ liệu thành 2 miền. Nên khi bạn dùng gradient descent vào bài toán XOR thì bất kể bạn chạy bước 2 bao nhiêu lần hay chỉnh learning_rate thế nào thì vẫn không ra được kết quả như mong muốn. Logistic regression như bài trước không thể giải quyết được vấn đề này, giờ cần một giải pháp mới !!!
Áp dụng các kiến thức về bit ở trên lại, ta có:


| A | B | A XOR B | A AND B | NOT(A AND B) | A OR B | (NOT(A AND B)AND (A OR B)) |
| --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 1 | 0 | 1 | 0 |

 

Do đó: A XOR B = (NOT(A AND B) AND (A OR B)), vậy để tính được XOR ta kết hợp NOT(AND) và OR sau đó tính phép tính AND.
![](images/image8.png)
Hình 5.12: Mô hình XOR
Nhìn có vẻ rối nhỉ, cùng phân tích nhé:
node NOT( _x_ 1 AND _x_ 2) chính là từ hình 5.10, với 3 mũi tên chỉ đến từ 1 _,x_ 1 _,x_ 2 với hệ số _w_ 0 _,w_ 1 _,w_ 2 tương ứng là 1.5, -1, -1.
node tính _x_ 1 OR _x_ 2 là từ hình 5.11
node trong output layer là phép tính AND từ 2 node của layer trước, giá trị hệ số từ hình 1 mang xuống.
Nhận xét: mô hình logistic regression không giải quyết được bài toán XOR nhưng mô hình mới thì giải quyết được bài toán XOR. Đâu là sự khác nhau:
Logistic regression chỉ có input layer và output layer
Mô hình mới có 1 hidden layer có 2 node ở giữa input layer và output layer.
Càng nhiều layer và node thì càng giải quyết được các bài toán phức tạp hơn.

# Public_043

# Ảnh trong máy tính

## Hệ màu RGB

RGB viết tắt của Red (đỏ), Green (xanh lục), Blue (xanh lam), là ba màu chính của ánh sáng khi tách ra từ lăng kính. Khi trộn ba màu trên theo tỉ lệ nhất định có thể tạo thành các màu khác nhau.
![](images/image1.png)
Hình 7.1: Thêm đỏ vào xanh lá cây tạo ra vàng; thêm vàng vào xanh lam tạo ra trắng [19]
Ví dụ khi bạn chọn màu ở [_đây._](https://www.w3schools.com/colors/colors_picker.asp) Khi bạn chọn một màu thì sẽ ra một bộ ba số tương ứng (r,g,b) Với mỗi bộ 3 số r, g, b nguyên trong khoảng [0, 255] sẽ cho ra một màu khác nhau. Do có 256 cách chọn r, 256 cách chọn màu g, 256 cách chọn b => tổng số màu có thể tạo ra bằng hệ màu RGB là: 256 * 256 * 256 = 16777216 màu !!!
![](images/image2.png)
Hình 7.2: màu được chọn là rgb(102, 255, 153), nghĩa là r=102, g=255, b=153.

## Ảnh màu

Ví dụ về ảnh màu trong hình 7.3
Khi bạn kích chuột phải vào ảnh trong máy tính, bạn chọn properties (mục cuối cùng), rồi chọn tab details
![](images/image3.png)
Bạn sẽ thấy chiều dài ảnh là 800 pixels (viết tắt px), chiều rộng 600 pixels, kích thước là 800 * 600. Trước giờ chỉ học đơn vị đo là mét hay centimet, pixel là gì nhỉ ?
Theo wiki, pixel (hay điểm ảnh) là một khối màu rất nhỏ và là đơn vị cơ bản nhất để tạo nên một bức ảnh kỹ thuật số.
Vậy bức ảnh trên kích thước 800 pixel * 600 pixel, có thể biểu diễn dưới dạng một ma trận kích thước 600 * 800 (vì định nghĩa ma trận là số hàng nhân số cột).
![](images/image4.png)
Hình 7.3: Mathematical bridge, Cambridge
Trong đó mỗi phần tử _w ij _là một pixel.
Như vậy có thể hiểu là mỗi pixel thì biểu diễn một màu và bức ảnh trên là sự kết hợp rất nhiều pixel. Hiểu đơn giản thì in bức ảnh ra, kẻ ô vuông như chơi cờ ca rô với 800 đường thẳng ở chiều dài, 600 đường ở chiều rộng, thì mỗi ô vuông là một pixel, biểu diễn một chấm màu.
Tuy nhiên để biểu diễn 1 màu ta cần 3 thông số (r,g,b) nên gọi _w ij _=( _r ij,gij,bij_) để biểu diễn dưới dạng ma trận thì sẽ như sau:
![](images/image5.png)
Hình 7.4: Ảnh màu kích thước 3*3 biểu diễn dạng ma trận, mỗi pixel biểu diễn giá trị (r,g,b)
Để tiện lưu trữ và xử lý không thể lưu trong 1 ma trận như thế kia mà sẽ tách mỗi giá trị màu trong mỗi pixel ra một ma trận riêng.
![](images/image6.png)
Hình 7.5: Tách ma trận trên thành 3 ma trận cùng kích thước: mỗi ma trận lưu giá trị từng màu khác nhau red, green, blue
Mỗi ma trận được tách ra được gọi là 1 channel nên ảnh màu được gọi là 3 channel: channel red, channel green, channel blue.
Tóm tắt: Ảnh màu là một ma trận các pixel mà mỗi pixel biểu diễn một điểm màu. Mỗi điểm màu được biểu diễn bằng bộ 3 số (r,g,b). Để tiện cho việc xử lý ảnh thì sẽ tách ma trận pixel ra 3 channel red, green, blue.

## Tensor là gì

Khi dữ liệu biểu diễn dạng 1 chiều, người ta gọi là vector, mặc định khi viết vector sẽ viết dưới dạng cột.
Khi dữ liệu dạng 2 chiều, người ta gọi là ma trận, kích thước là số hàng * số cột.
![](images/image7.png)
Hình 7.7: Vector v kích thước n, ma trận W kích thước m*n
Khi dữ liệu nhiều hơn 2 nhiều thì sẽ được gọi là tensor, ví dụ như dữ liệu có 3 chiều.
Để ý thì thấy là ma trận là sự kết hợp của các vector cùng kích thước. Xếp n vector kích thước m cạnh nhau thì sẽ được ma trận m*n. Thì tensor 3 chiều cũng là sự kết hợp của các ma trận cùng kích thước, xếp k ma trận kích thước m*n lên nhau sẽ được tensor kích thước m*n*k.
![](images/image8.png)
Hình 7.8: Hình hộp chữ nhật kích thước a*b*h
Tưởng tượng mặt đáy là một ma trận kích thước a * b, được tạo bởi b vector kích thước a. Cả hình hộp là tensor 3 chiều kích thước a*b*h, được tạo bởi xếp h ma trận kích thước a*b lên nhau.
Do đó biểu diễn ảnh màu trên máy tính ở phần trên sẽ được biểu diễn dưới dạng tensor 3 chiều kích thước 600*800*3 do có 3 ma trận (channel) màu red, green, blue kích thước 600*800 chồng lên nhau.
Ví dụ biểu diễn ảnh màu kích thước 28*28, biểu diễn dưới dạng tensor 28*28*3
![](images/image9.png)
Hình 7.9: Ảnh màu biểu diễn dưới dạng tensor [1]

## Ảnh xám

![](images/image10.png)

Hình 7.10: Ảnh xám của mathematical bridge
Tương tự ảnh màu, ảnh xám cũng có kích thước 800 pixel * 600 pixel, có thể biểu diễn dưới dạng một ma trận kích thước 600 * 800 (vì định nghĩa ma trận là số hàng nhân số cột).
Tuy nhiên mỗi pixel trong ảnh xám chỉ cần biểu diễn bằng một giá trị nguyên trong khoảng từ [0,255] thay vì (r,g,b) như trong ảnh màu. Do đó khi biểu diễn ảnh xám trong máy tính chỉ cần một ma trận là đủ.
![](images/image11.png)
Hình 7.11: Biểu diễn ảnh xám
Giá trị 0 là màu đen, 255 là màu trắng và giá trị pixel càng gần 0 thì càng tối và càng gần 255 thì càng sáng.

## Chuyển hệ màu của ảnh

Mỗi pixel trong ảnh màu được biểu diễn bằng 3 giá trị (r,g,b) còn trong ảnh xám chỉ cần 1 giá trị x để biểu diễn.
Khi chuyển từ ảnh màu sang ảnh xám ta có thể dùng công thức: x = r * 0.299 + g * 0.587 + b * 0.114.
Tuy nhiên khi chuyển ngược lại, bạn chỉ biết giá trị x và cần đi tìm r,g,b nên sẽ không chính xác.

# Phép tính convolution

## Convolution

Để cho dễ hình dung tôi sẽ lấy ví dụ trên ảnh xám, tức là ảnh được biểu diễn dưới dạng ma trận A kích thước m*n.
Ta định nghĩa kernel là một ma trận vuông kích thước k*k trong đó k là số lẻ. k có thể bằng 1, 3, 5, 7, 9,... Ví dụ kernel kích thước 3*3
![](images/image12.png)
Kí hiệu phép tính convolution (⊗), kí hiệu _Y_ = _X_ ⊗ _W_
Với mỗi phần tử _x ij _trong ma trận X lấy ra một ma trận có kích thước bằng kích thước của kernel W có phần tử _x ij _làm trung tâm (đây là vì sao kích thước của kernel thường lẻ) gọi là ma trận A. Sau đó tính tổng các phần tử của phép tính element-wise của ma trận A và ma trận W, rồi viết vào ma trận kết quả Y.
![](images/image13.png)
Ví dụ khi tính tại _x_ 22 (ô khoanh đỏ trong hình), ma trận A cùng kích thước với W, có _x_ 22 làm trung tâm có màu nền da cam như trong hình. Sau đó tính _y_ 11 = _sum_ ( _A_ ⊗ _W_ )= _x_ 11∗ _w_ 11+ _x_ 12∗ _w_ 12+ _x_ 13∗ _w_ 13+ _x_ 21∗ _w_ 21+ _x_ 22∗ _w_ 22+ _x_ 23∗ _w_ 23+ _x_ 31∗ _w_ 31+ _x_ 32∗ _w_ 32+ _x_ 33∗ _w_ 33 =4. Và làm tương tự với các phần tử còn lại trong ma trận.
Thế thì sẽ xử lý thế nào với phần tử ở viền ngoài như _x_ 11? Bình thường khi tính thì sẽ bỏ qua các phần tử ở viền ngoài, vì không tìm được ma trận A ở trong X.
Nên bạn để ý thấy ma trận Y có kích thước nhỏ hơn ma trận X. Kích thước của ma trận Y là (m-k+1) * (n-k+1).
![](images/image14.png)
Hình 7.12: Các bước thực hiện phép tính convolution cho ma trận X với kernel K ở trên

## Padding

Như ở trên thì mỗi lần thực hiện phép tính convolution xong thì kích thước ma trận Y đều nhỏ hơn X. Tuy nhiên giờ ta muốn ma trận Y thu được có kích thước bằng ma trận X => Tìm cách giải quyết cho các phần tử ở viền => Thêm giá trị 0 ở viền ngoài ma trận X.
![](images/image15.png)
Hình 7.13: Ma trận X khi thêm viền 0 bên ngoài
Rõ ràng là giờ đã giải quyết được vấn đề tìm A cho phần tử _x_ 11 , và ma trận Y thu được sẽ bằng
kích thước ma trận X ban đầu.
Phép tính này gọi là convolution với padding=1. Padding=k nghĩa là thêm k vector 0 vào mỗi phía (trên, dưới, trái, phải) của ma trận.

## Stride

Như ở trên ta thực hiện tuần tự các phần tử trong ma trận X, thu được ma trận Y cùng kích thước ma trận X, ta gọi là stride=1.
![](images/image16.png)
Hình 7.14: stride=1, padding=1
Tuy nhiên nếu stride=k (k > 1) thì ta chỉ thực hiện phép tính convolution trên các phần tử _x_ 1+ _i_ ∗ _k,_ 1+ _j_ ∗ _k_. Ví dụ k = 2.
![](images/image17.png)
Hình 7.15: padding=1, stride=2
Hiểu đơn giản là bắt đầu từ vị trí _x_ 11 sau đó nhảy k bước theo chiều dọc và ngang cho đến hết ma trận X.
Kích thước của ma trận Y là 3*3 đã giảm đi đáng kể so với ma trận X.
Công thức tổng quát cho phép tính convolution của ma trận X kích thước m*n với kernel kích thước k*k, stride = s, padding = p ra ma trận Y kích thước là
$$
(m−2k+ps+1)×(n−2k+ps+1)left( frac{m - 2k + p}{s} + 1 right) times left( frac{n - 2k + p}{s} + 1 right)
$$
Stride thường dùng để giảm kích thước của ma trận sau phép tính convolution.

# Public_044

# Thiết lập bài toán

Gần đây việc kiểm tra mã captcha để xác minh không phải robot của google bị chính robot vượt qua
![](images/image1.png)
Hình 8.1: Robot vượt qua kiểm tra captcha
Thế nên google quyết định cho ra thuật toán mới, dùng camera chụp ảnh người dùng và dùng deep learning để xác minh xem ảnh có chứa mặt người không thay cho hệ thống captcha cũ.
Bài toán: Input một ảnh màu kích thước 64*64, output ảnh có chứa mặt người hay không.

# Convolutional neural network

## Convolutional layer

Mô hình neural network từ những bài trước
![](images/image2.png)
Hình 8.2: Mô hình neural network.
Mỗi hidden layer được gọi là fully connected layer, tên gọi theo đúng ý nghĩa, mỗi node trong hidden layer được kết nối với tất cả các node trong layer trước. Cả mô hình được gọi là fully connected neural network (FCN).
Như bài trước về xử lý ảnh, thì ảnh màu 64*64 được biểu diễn dưới dạng 1 tensor 64*64*3. Nên để biểu thị hết nội dung của bức ảnh thì cần truyền vào input layer tất cả các pixel (64*64*3 = 12288). Nghĩa là input layer giờ có 12288 nodes.
![](images/image3.png)
Hình 8.3: Input layer và hidden layer 1
Giả sử số lượng node trong hidden layer 1 là 1000. Số lượng weight W giữa input layer và hidden layer 1 là 12288*1000 = 12288000, số lượng bias là 1000 => tổng số parameter là: 12289000. Đấy mới chỉ là số parameter giữa input layer và hidden layer 1, trong model còn nhiều layer nữa, và nếu kích thước ảnh tăng, ví dụ 512*512 thì số lượng parameter tăng cực kì nhanh => Cần giải pháp tốt hơn !!!
Nhận xét:

  * Trong ảnh các pixel ở cạnh nhau thường có liên kết với nhau hơn là những pixel ở xa. Ví dụ như phép tính convolution trên ảnh ở bài trước. Để tìm các đường trong ảnh, ta áp dụng sobel kernel trên mỗi vùng kích thước 3*3. Hay làm nét ảnh ta áp dụng sharpen kernel cũng trên vùng có kích thước 3*3.

  * Với phép tính convolution trong ảnh, chỉ 1 kernel được dùng trên toàn bộ bức ảnh. Hay nói cách khác là các pixel ảnh chia sẻ hệ số với nhau.


=> Áp dụng phép tính convolution vào layer trong neural network ta có thể giải quyết được vấn đề lượng lớn parameter mà vẫn lấy ra được các đặc trưng của ảnh.

### Convolutional layer đầu tiên

Bài trước phép tính convolution thực hiện trên ảnh xám với biểu diễn ảnh dạng ma trận
![](images/image4.png)
Tuy nhiên ảnh màu có tới 3 channels red, green, blue nên khi biểu diễn ảnh dưới dạng tensor 3 chiều. Nên ta cũng sẽ định nghĩa kernel là 1 tensor 3 chiều kích thước k*k*3.
![](images/image5.png)
Hình 8.4: Phép tính convolution trên ảnh màu với k=3.
Ta định nghĩa kernel có cùng độ sâu (depth) với biểu diễn ảnh, rồi sau đó thực hiện di chuyển khối kernel tương tự như khi thực hiện trên ảnh xám.
![](images/image6.png)
Hình 8.5: Tensor X, W 3 chiều được viết dưới dạng 3 matrix.
Khi biểu diễn ma trận ta cần 2 chỉ số hàng và cột: i và j, thì khi biểu diễn ở dạng tensor 3 chiều cần thêm chỉ số độ sâu k. Nên chỉ số mỗi phần tử trong tensor là _x ijk_.
Nhận xét:

  * Output Y của phép tính convolution trên ảnh màu là 1 matrix.

  * Có 1 hệ số bias được cộng vào sau bước tính tổng các phần tử của phép tính element-wise


**Các quy tắc đối với padding và stride toàn hoàn tương tự như ở bài trước.**
Với mỗi kernel khác nhau ta sẽ học được những đặc trưng khác nhau của ảnh, nên trong mỗi convolutional layer ta sẽ dùng nhiều kernel để học được nhiều thuộc tính của ảnh. Vì mỗi kernel cho ra output là 1 matrix nên k kernel sẽ cho ra k output matrix. Ta kết hợp k output matrix này lại thành 1 tensor 3 chiều có chiều sâu k.
![](images/image7.png)
Hình 8.6: Thực hiện phép tính convolution trên ảnh màu.
![](images/image8.png)
Hình 8.7: Convolutional layer đầu tiên
Output của convolutional layer đầu tiên sẽ thành input của convolutional layer tiếp theo.

### Convolutional layer tổng quát

Giả sử input của 1 convolutional layer tổng quát là tensor kích thước H * W * D.
Kernel có kích thước F * F * D (kernel luôn có depth bằng depth của input và F là số lẻ), stride: S, padding: P.
Convolutional layer áp dụng K kernel.
=> Output của layer là tensor 3 chiều có kích thước: $$
(H−F+2PS+1)*(W−F+2PS+1)left( frac{H - F + 2P}{S} + 1 right)*left( frac{W - F + 2P}{S} + 1 right)
$$∗ _K_
Lưu ý:

  * Output của convolutional layer sẽ qua hàm non-linear activation function trước khi trở thành input của convolutional layer tiếp theo.

  * Tổng số parameter của layer: Mỗi kernel có kích thước F*F*D và có 1 hệ số bias, nên tổng parameter của 1 kernel là F*F*D + 1. Mà convolutional layer áp dụng K kernel => Tổng số parameter trong layer này là K * (F*F*D + 1).


## Pooling layer

Pooling layer thường được dùng giữa các convolutional layer, để giảm kích thước dữ liệu nhưng vẫn giữ được các thuộc tính quan trọng. Việc giảm kích thước dữ liệu giúp giảm các phép tính toán trong model.
Bên cạnh đó, với phép pooling kích thước ảnh giảm, do đó lớp convolution học được các vùng có kích thước lớn hơn. Ví dụ như ảnh kích thước 224*224 qua pooling về 112*112 thì vùng 3*3 ở ảnh 112*112 tương ứng với vùng 6*6 ở ảnh ban đầu. Vì vậy qua các pooling thì kích thước ảnh nhỏ đi và convolutional layer sẽ học được các thuộc tính lớn hơn.
Gọi pooling size kích thước K*K. Input của pooling layer có kích thước H*W*D, ta tách ra làm D ma trận kích thước H*W. Với mỗi ma trận, trên vùng kích thước K*K trên ma trận ta tìm maximum hoặc average của dữ liệu rồi viết vào ma trận kết quả. Quy tắc về stride và padding áp dụng như phép tính convolution trên ảnh.
![](images/image9.png)
Hình 8.8: max pooling layer với size=(3,3), stride=1, padding=0
Nhưng hầu hết khi dùng pooling layer thì sẽ dùng size=(2,2), stride=2, padding=0. Khi đó output width và height của dữ liệu giảm đi một nửa, depth thì được giữ nguyên.
![](images/image10.png)
Hình 8.9: Sau pooling layer (2*2) [4]
Có 2 loại pooling layer phổ biến là: max pooling và average pooling.
![](images/image11.png)
Hình 8.10: Ví dụ về pooling layer
**Trong một số model người ta dùng convolutional layer với stride > 1 để giảm kích thước dữ liệu thay cho pooling layer.**

## Fully connected layer

Sau khi ảnh được truyền qua nhiều convolutional layer và pooling layer thì model đã học được tương đối các đặc điểm của ảnh (ví dụ mắt, mũi, khung mặt,...) thì tensor của output của layer cuối cùng, kích thước H*W*D, sẽ được chuyển về 1 vector kích thước (H*W*D, 1)
![](images/image12.png)
Sau đó ta dùng các fully connected layer để kết hợp các đặc điểm của ảnh để ra được output của model.

# Mạng VGG 16

VGG16 là mạng convolutional neural network được đề xuất bởi K. Simonyan and A. Zisserman, University of Oxford. Model sau khi train bởi mạng VGG16 đạt độ chính xác 92.7% top-5 test trong dữ liệu ImageNet gồm 14 triệu hình ảnh thuộc 1000 lớp khác nhau. Giờ áp dụng kiến thức ở trên để phân tích mạng VGG 16.
![](images/image13.png)
Hình 8.11: Kiến trúc VGG16 conv: convolutional layer, pool: pooling layer, fc: fully connected layer
Phân tích:

  * Convolutional layer: kích thước 3*3, padding=1, stride=1. Tại sao không ghi stride, padding mà vẫn biết? Vì mặc định sẽ là stride=1 và padding để cho output cùng width và height với input.

  * Pool/2 : max pooling layer với size 2*2

  * 3*3 conv, 64: thì 64 là số kernel áp dụng trong layer đấy, hay depth của output của layer đấy.

  * Càng các convolutional layer sau thì kích thước width, height càng giảm nhưng depth càng tăng.

# Public_045

# Transfer learning

Bạn có bài toán cần nhận diện 1000 người nổi tiếng ở Việt Nam, tuy nhiên dữ liệu để train chỉ khoảng 10 ảnh / 1 người. Số lượng dữ liệu là quá ít để train một mô hình CNN hoàn chỉnh.

Bạn tìm trên mạng thấy VGGFace2 dataset có 3.31 triệu ảnh của 9131 người, với trung bình 362.6 ảnh cho mỗi người. Họ làm bài toán tương tự đó là nhận diện ảnh từng người và họ đã train được CNN model với accuracy hơn 99%.

Bạn nhớ ra là trong convolutional neural network, convolutional layer có tác dụng lấy ra các đặc trưng của ảnh, và sau hàng loạt các convolutional layer + pooling layer (ConvNet) thì model sẽ học được các đặc điểm của ảnh, trước khi được cho vào fully connected layer => ConvNet trong VGGFace2 model cũng lấy ra được các đặc điểm của mặt người (tai, mũi, tóc,...) => Ta cũng có thể áp dụng phần ConvNet của VGGFace2 model vào bài toán nhận diện mặt người nổi tiếng ở Việt Nam để lấy ra các đặc điểm của mặt.

Quá trình sử dụng pre-trained model như trên gọi là transfer learning.

Các pre-trained model được sử dụng thường là các bài toán được train với dữ liệu lớn ví dụ ImageNet, dữ liệu chứa 1.2 triệu ảnh với 1000 thể loại khác nhau.

Có 2 loại transfer learning:

  * **Feature extractor** : Sau khi lấy ra các đặc điểm của ảnh bằng việc sử dụng ConvNet của pre-trained model, thì ta sẽ dùng linear classifier (linear SVM, softmax classifier,..) để phân loại ảnh. Hiểu đơn giản thì các đặc điểm ảnh (tai, mũi, tóc,...) giờ như input của bài toán linear regression hay logistic regression.

  * **Fine tuning** : Sau khi lấy ra các đặc điểm của ảnh bằng việc sử dụng ConvNet của pre-trained model, thì ta sẽ coi đây là input của 1 CNN mới bằng cách thêm các ConvNet và Fully Connected layer. Lý do là ConvNet của VGGFace 2 model có thể lấy ra được các thuộc tính của mặt người nói chung nhưng người Việt Nam có những đặc tính khác nên cần thêm 1 số Convnet mới để học thêm các thuộc tính của người Việt Nam.


![](images/image4.png)

Hình 11.1: Hiệu quả khi sử dụng transfer learning [2]

**Bài toán** : Ta muốn nhận diện ảnh của 17 loài hoa, mỗi loài hoa có khoảng 80 ảnh.

Sử dụng pre-trained model là VGG 16 của ImageNet. Mô hình VGG 16 mọi người có thể xem lại bài CNN. Mô hình VGG16 của ImageNet dataset, phân loại ảnh thuộc 1000 thể loại khác nhau. Nên có thể hiểu là nó đủ tổng quát để tách ra các đặc điểm của bức ảnh, cụ thể ở đây là hoa.

## Feature extractor

Ta chỉ giữ lại phần ConvNet trong CNN và bỏ đi FCs. Sau đó dùng output của ConvNet còn lại để làm input cho Logistic Regression với nhiều output, như trong hình 11.2.

Mô hình logistic regression với nhiều output có 2 dạng:

Dạng thứ nhất là một neural network, không có hidden layer, hàm activation ở output layer là softmax function, loss function là hàm categorical-cross entropy, giống như bài phân loại ảnh.

![](images/image2.png)

Hình 11.2: Bên trái là mô hình VGG16, bên phải là mô hình VGG16 chỉ bao gồm ConvNet (bỏ Fully Connected layer) [21]

![](images/image3.png)

Dạng thứ hai giống như bài logistic regression, tức là model chỉ phân loại 2 class. Mỗi lần ta sẽ phân loại 1 class với tất cả các class còn lại.

![](images/image10.png)

Hình 11.3: 1 vs all classification [13]

## Fine tuning

Ta chỉ giữ lại phần ConvNet trong CNN và bỏ đi FCs. Sau đó thêm các Fully Connected layer mới vào output của ConvNet như trong hình 11.4.

Khi train model ta chia làm 2 giai đoạn

**Giai đoạn 1** : Vì các Fully Connected layer ta mới thêm vào có các hệ số được khởi tạo ngẫu nhiên tuy nhiên các layer trong ConvNet của pre-trained model đã được train với ImageNet dataset nên ta sẽ không train (đóng băng/freeze) trên các layer trong ConvNet của model VGG16. Sau khoảng 20-30 epoch thì các hệ số ở các layer mới đã được học từ dữ liệu thì ta chuyển sang giai đoạn 2.

![](images/image9.png)

Hình 11.5: Freeze các layer của pre-trained model, chỉ train ở các layer mới [21]

**Giai đoạn 2** : Ta sẽ unfreeze các layer trên ConvNet của pre-trained model và train trên các layer của ConvNet của pre-trained model và các layer mới. Bạn có thể unfreeze tất cả các layer trong ConvNet của VGG16 hoặc chỉ unfreeze một vài layer cuối tùy vào thời gian và GPU bạn có.

![](images/image5.png)

Hình 11.6: Freeze các layer của pre-trained model, chỉ train ở các layer mới [21]

Accuracy của fine-tuning tốt hơn so với feature extractor tuy nhiên thời gian train của fine-tuning cũng lâu hơn rất nhiều. Giải thích đơn giản thì feature extractor chỉ lấy ra đặc điểm chung chung từ pre-trained model của ImageNet dataset cho các loài hoa, nên không được chính xác lắm. Tuy nhiên ở phần fine-tuning ta thêm các layer mới, cũng như train lại 1 số layer ở trong ConvNet của VGG16 nên model giờ học được các thuộc tính, đặc điểm của các loài hoa nên độ chính xác tốt hơn.

## Khi nào nên dùng transfer learning

Có 2 yếu tố quan trọng nhất để dùng transfer learning đó là kích thước của dữ liệu bạn có và sự tương đồng của dữ liệu giữa mô hình bạn cần train và pre-trained model.

  * Dữ liệu bạn có nhỏ và tương tự với dữ liệu ở pre-trained model. Vì dữ liệu nhỏ nên nếu dùng fine-tuning thì model sẽ bị overfitting. Hơn nữa là dữ liệu tương tự nhau nên là ConvNet của pre-trained model cũng lấy ra các đặc điểm ở dữ liệu của chúng ta. Do đó nên dùng feature extractor.

  * Dữ liệu bạn có lớn và tương tự với dữ liệu ở pre-trained model. Giờ có nhiều dữ liệu ta không sợ overfitting do đó nên dùng fine-tuning.

  * Dữ liệu bạn có nhỏ nhưng khác với dữ liệu ở pre-trained model. Vì dữ liệu nhỏ nên ta lên dùng feature extractor để tránh overfitting. Tuy nhiên do dữ liệu ta có và dữ liệu ở pre-trained model khác nhau, nên không nên dùng feature extractor với toàn bộ ConvNet của pre-trained model mà chỉ dùng các layer đầu. Lý do là vì các layer ở phía trước sẽ học các đặc điểm chung chung hơn (cạnh, góc,...), còn các layer phía sau trong ConvNet sẽ học các đặc điểm cụ thể hơn trong dataset (ví dụ mắt, mũi,..).

  * Dữ liệu bạn có lớn và khác với dữ liệu ở pre-trained model. Ta có thể train model từ đầu, tuy nhiên sẽ tốt hơn nếu ta khởi tạo các giá trị weight của model với giá trị của pre-trained model và sau đó train bình thường.


**Lưu ý**

  * Vì pre-trained model đã được train với kích thước ảnh cố định, nên khi dùng pre-trained model ta cần resize lại ảnh có kích ảnh bằng kích thước mà ConvNet của pre-trained model yêu cầu.

  * Hệ số learning rate của ConvNet của pre-trained model nên được đặt với giá trị nhỏ vì nó đã được học ở pre-trained model nên ít cần cập nhật hơn so với các layer mới thêm.


# Data augmentation

Ngoài transfer learning, có một kĩ thuật nữa giải quyết vấn đề có ít dữ liệu cho việc training model, đó là data augmentation. Augmentation là kĩ thuật tạo ra dữ liệu training từ dữ liệu mà ta đang có. Cùng xem một số kĩ thuật augmentation phổ biến với ảnh nhé.

Flip: Lật ngược ảnh theo chiều dọc hoặc chiều ngang

![](images/image7.png)

Hình 11.7: lật ngược ảnh theo chiều dọc

Rotation: Quay ảnh theo nhiều góc khác nhau

![](images/image6.png)

Hình 11.8: Rotate ảnh 30 độ

Scale: Phóng to hoặc thu nhỏ ảnh

![](images/image8.png)

Hình 11.9: Scale ảnh

Crop: Cắt một vùng ảnh sau đó resize vùng ảnh đấy về kích thước ảnh ban đầu

![](images/image8.png)

Hình 11.10: Crop ảnh

# Public_046

# Vectorization

Ngay từ bài đầu tiên về linear regression, tôi đã giới thiệu về việc biểu diễn và tính toán dưới dạng vector. Việc biểu diễn bài toán dưới dạng vector như vậy gọi là vectorization. Nó không chỉ giúp code gọn lại mà còn tăng tốc độ tính đoán một cách đáng kể khi thực hiện các phép tính trên vector, ma trận so với for-loop.
_# -*- coding: utf-8 -*-_
import numpy as np import time  
a = np.random.rand(10000000)  
b = np.random.rand(10000000)  
start = time.time()  
c = np.dot(a, b.T)  
end = time.time()  
print("Vectorization time : ", end-start)
start = time.time()  
c = 0  
for i in range(len(a)):  
c += a[i] * b[i]  
end = time.time()  
print("For-loop time : ", end-start)
Bạn sẽ thấy nếu dùng for-loop mất hơn 4s để nhân 2 vector trong khi dùng thư viện numpy để tính chỉ mất 0.01s. Tại sao lại như thế nhỉ?
Giả sử bạn có 10 tấn hàng cần vận chuyển từ A đến B và bạn có một xe tải với khả năng chở được 5 tấn mỗi lần. Vậy nếu chất đầy hàng mỗi lần chở thì chỉ cần 2 lần chạy là chuyển hết số hàng. Tuy nhiên nếu mỗi lần bạn chỉ chất 1 tấn hàng lên xe để chở đi thì xe cần đi tới 10 lần để chuyển hết số hàng.
Tương tự như vậy, khi nhân 2 vector ở trên bạn cần thực hiện 10000000 phép tính nhân 2 số. Giả sử máy tính có thể tính được tối đa 1000 phép tính nhân một lúc. Việc bạn dùng for-loop giống như mỗi thời điểm bạn chỉ yêu cầu máy tính thực hiện một phép nhân, nên để nhân 2 vector sẽ cần 10000000 đơn vị thời gian. Tuy nhiên thư viện numpy sẽ tối ưu việc tính toán bằng cách yêu cầu máy tính thực hiện 1000 phép tính một lúc, tức là chỉ cần ![](images/image1.png) =10000 đơn vị thời gian để hoàn thành phép nhân 2 vector. Vậy nên là việc vectorization thông thường sẽ tính toán nhanh hơn.

# Mini-batch gradient descent

## Mini-batch gradient descent là gì

Ở trong thuật toán gradient descent, tại bước thứ hai khi ta tính đạo hàm của loss function với các biến. Trong bài linear regression, ta dùng tất cả các dữ liệu trong dataset để tính đạo hàm rồi cập nhật bước 2:
![](images/image2.jpg)
Thuật toán gradient descent chạy tốt nhưng số lượng dữ liệu trong training set chỉ là 30. Tuy nhiên nếu dữ liệu có kích thước lớn như ảnh và số lượng lớn hơn ví dụ 5000 thì việc tính đạo hàm với loss function với toàn bộ dữ liệu sẽ rất tốn thời gian. Và mini-batch gradient descent ra đời để giải quyết vấn đề đấy.
Dựa vào số lượng dữ liệu cho mỗi lần thực hiện bước 2 trong gradient descent là người ta chia ra làm 3 loại:

  * Batch gradient descent: Dùng tất cả dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm.

  * Mini-batch gradient descent: Dùng một phần dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm.

  * Stochastic gradient descent: Chỉ dùng một dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm.


Ví dụ điểm thi đại học trung bình của một trường trung học phổ thông là 24 điểm. Batch gradient descent giống như tính điểm trung bình tất cả học sinh thi đại học năm nay của trường, con số sẽ tương đối gần 24, ví dụ 24,5. Mini-batch sẽ chọn ngẫu nhiên một số học sinh, ví dụ 32 học sinh để tính điểm trung bình thì điểm trung bình sẽ xa 24 hơn ví dụ 22. Tuy nhiên, Stochastic giống như chỉ chọn một học sinh làm điểm trung bình, thì lúc này điểm trung bình có thể khác xa con số 24 rất nhiều, ví dụ 18 hoặc 29. Việc điểm trung bình ở mini-batch hay stochastic khác so với điểm trung bình toàn trường gọi là nhiễu trong dữ liệu. Hay giải thích đơn giản là chỉ lấy 1 hoặc một phần dữ liệu thì không thể mô tả hết được tất cả dữ liệu.
Do đó hàm loss-function với hệ số learning_rate phù hợp thì batch gradient descent theo epoch sẽ giảm đều đặn. Vì có nhiễu trong dữ liệu nên mini-batch thì vẫn giảm nhưng có dao động và stochastic có giảm nhưng dao động cực kì lớn.
![](images/image3.jpg)
Hình 12.1: So sánh loss function khi dùng batch và mini-batch [13]
Hình dưới là biểu diễn biệc cập nhật hệ số trong gradient descent, điểm đỏ là giá trị nhỏ nhất ta cần tìm, các điểm ở ngoài cùng là giá trị khởi tạo của hệ số trong gradient descent. Ta có thể thấy vì không có nhiễu nên batch gradient descent thì hệ số cập nhật trực tiếp theo 1 đường thẳng. Mini-batch thì mất nhiều thời gian hơn và còn đi chệch hướng tuy nhiên thì vẫn đến được điểm đỏ. Còn stochastic thì đi khá lòng vòng để đến được điểm đỏ và vì dữ liệu quá nhiễu nên có thể thuật toán gradient descent chỉ quanh điểm đỏ mà không đến được điểm đỏ (minimum point).
![](images/image4.jpg)
Hình 12.2: Cập nhật loss function đến minimum point của các thuật toán [13]
Batch gradient descent thường được dùng khi số lượng dữ liệu trong training set nhỏ hơn 2000. Với lượng dữ liệu lớn thì mini-batch gradient descent được sử dụng. Nó có thể giải quyết được vấn đề lượng dữ liệu quá lớn như trong batch gradient descent, hơn nữa đỡ nhiễu và có thể dùng vectorization so với stochastic gradient descent nên thường được sử dụng trong deep learning.

## Các thông số trong mini-batch gradient descent

Ví dụ code trong bài 7, trong bài toán phân loại chữ số cho dữ liệu MNIST
H = model.fit(X_train, Y_train, validation_data=(X_val, Y_val), batch_size=32, epochs=10, verbose=1)
X_train, Y_train là dữ liệu và label cho training set. Tương tự X_val, Y_val là dữ liệu cho validation set.
**batch_size** : Là size trong mini-batch gradient descent, nghĩa là dùng bao nhiêu dữ liệu cho mỗi lần tính và cập nhật hệ số.
**steps_per_epoch** : Là bao nhiêu lần thực hiện bước 2 trong gradient descent trong mỗi epoch. Mặc định sẽ là số lượng dữ liệu chia cho batch_size. Hiểu đơn giản là mỗi epoch sẽ dùng hết các dữ liệu để tính gradient descent. **epochs** : số lượng epoch thực hiện trong quá trình training.
Vậy thực sự số lần thực hiện bước 2 trong gradient descent trong quá trình training là: epochs * steps_per_epoch.
Lời khuyên:

  * Batch_size nên được chọn là số mũ của 2 ví dụ 16, 32, 64, 128 để CPU/GPU tính toán tốt hơn. Giá trị mặc định là 32.

  * Nên vẽ đồ thị loss/epoch để chọn batch_size phù hợp.


# Bias và variance

## Bias, variance là gì

Bias: nghĩa là độ lệch, biểu thị sự chênh lệch giữa giá trị trung bình mà mô hình dự đoán và giá trị thực tế của dữ liệu.
Variance: nghĩa là phương sai, biểu thị độ phân tán của các giá trị mà mô hình dự đoán so với giá trị thực tế.
![](images/image5.jpg)
Giá trị thật dữ liệu (ground truth) ở giữa tâm các đường tròn. Các dấu X là các giá trị dự đoán. Ta thấy nếu high bias thì giá trị dự đoán rất xa tâm. Tuy nhiên nếu high variance thì các giá trị dự đoán phân tán rộng dẫn đến việc ra giá trị thực tế. => Ta mong muốn low bias và low variance.
![](images/image6.jpg)
Đây là bài toán logistic regression, cần tìm đường phân chia dữ liệu.

  * Ở hình 1, thì đường phân chia có khá nhiều điểm bị lỗi => sự chênh lệch giữa mô hình dự đoán và giá trị thực tế của dữ liệu cao => **high bias** , hay còn được gọi là **underfitting** , ý hiểu là mô hình hiện tại đơn giản hơn và chưa mô tả được mô hình của dữ liệu thực tế.

  * Ở hình 2, đường phân chia vẫn có lỗi nhưng ở mức chấp nhận được và nó có thể mô tả dữ liệu => **low bias, low variance**.

  * Ở hình 3, đường phân chia có thể dự đoán đúng tất cả các điểm trong training set nhưng vì nó không tổng quát hóa mô hình dữ liệu thực sự nên khi áp dụng dự đoán vào validation set thì sẽ có rất nhiều lỗi => **high variance** hay còn được gọi là **overfitting** , ý hiểu là mô hình hiện tại thực hiện tốt với dữ liệu trong training set nhưng dự đoán không tốt với validation set. Thực ra khái niệm high bias và high variance khá trìu tượng và nhiều lúc dùng nhầm lẫn giữa thống kê và machine learning. Nên khái niệm hay được dùng hơn là underfitting và overfitting.


![](images/image7.jpg)
Hình 12.3: Các điểm màu xanh là training set, điểm màu đỏ là validation set
Ví dụ khi luyện thi đại học, nếu bạn chỉ luyện khoảng 1-2 đề trước khi thi thì bạn sẽ bị underfitting vì bạn chưa hiểu hết cấu trúc, nội dung của đề thi. Tuy nhiên nếu bạn chỉ luyện kĩ 50 đề thầy cô giáo bạn soạn và đưa cho thì khả năng bạn sẽ bị overfitting với các đề mà thầy cô giáo các bạn soạn mà khi thi đại học có thể điểm số của các bạn vẫn tệ.

## Bias, variance tradeoff

Nếu model quá đơn giản thì ta sẽ bị high bias và low variance. Tuy nhiên nếu model quá phức tạp thì sẽ bị high variance và low bias. Đấy là bias, variance tradeoff. Do đó để train được model tốt ta cần cân bằng giữa bias và variance.

## Đánh giá bias and variance

Có 2 thông số thường được sử dụng để đánh giá bias and variance của mô hình là training set error và validation set error. Ví dụ error (1-accuracy) trong logistic regression.


| Train set error | 1% | 15% | 15% | 0.5% |
| --- | --- | --- | --- | --- |
| Val set error | 11% | 16% | 30% | 1% |
|  | High variance | High bias | High biasHigh variance | Low biasLow variance |

 

Ta mong muốn model là low bias và low variance. Cùng xem một số cách để giải quyết vấn đề high bias hoặc high variance nhé.
Giải quyết high bias (underfitting): Ta cần tăng độ phức tạp của model

  * Tăng số lượng hidden layer và số node trong mỗi hidden layer.

  * Dùng nhiều epoch hơn để train model. Giải quyết high variance (overfitting):

  * Thu thập thêm dữ liệu hoặc dùng data augmentation

  * Dùng regularization như: L1, L2, dropout


# Dropout

## Dropout là gì

Dropout với hệ số p nghĩa là trong quá trình train model, với mỗi lần thực hiện cập nhật hệ số trong gradient descent ta ngẫu nhiên loại bỏ p% số lượng node trong layer đấy, hay nói cách khác là giữ lại (1-p%) node. Mỗi layer có thể có các hệ số dropout p khác nhau.
![](images/image8.jpg)
Hình 12.4: So sánh model dropout và neural network thông thường [26]
Ví dụ mô hình neural network 1-2-1: 1 input layer, 2 hidden layer và 1 output layer. Ví dụ như hidden layer 1, ta dùng dropout với p = 0.6, nên chỉ giữ lại 2 trên 5 node cho mỗi lần cập nhật.

## Dropout hạn chế việc overfitting

Overfitting là mô hình đang dùng quá phức tạp so với mô hình thật của dữ liệu. Khi ta dùng dropout như hình trên thì rõ ràng mô hình bên phải đơn giản hơn => tránh overfitting.
Thêm vào đó, vì mỗi bước khi train model thì ngẫu nhiên (1-p%) các node bị loại bỏ nên model không thể phụ thuộc vào bất kì node nào của layer trước mà thay vào đó có xu hướng trải đều weight, giống như trong L2 regularization => tránh được overfitting.

## Lời khuyên khi dùng dropout

  * Hệ số p nên ở khoảng [0.2, 0.5] . Nếu p quá nhỏ thì không có tác dụng chống overfitting, tuy nhiên nếu p quá lớn thì gần như loại bỏ layer đấy và có thể dẫn đến underfitting.

  * Nên dùng model lớn, phức tạp hơn vì ta có dropout chống overfitting.

  * Dropout chỉ nên dùng cho Fully Connected layer, ít khi được dùng cho ConvNet layer

  * Hệ số p ở các layer nên tỉ lệ với số lượng node trong FC layer đó.


# Activation function

## Non-linear activation function

Hàm activation function được dùng sau bước tính tổng linear trong neural network hoặc sau convolutional layer trong CNN. Và hàm activation là non-linear function.
Linear function là gì? Theo wiki, "a linear function from the real numbers to the real numbers is a function whose graph is a line in the plane ", tóm lại linear function là một đường thẳng dạng y = a*x + b. Vậy sẽ ra sao nếu hàm activation trong neural network là một linear function?
Giả sử hàm activation dạng y = f(x) = 2*x + 3 và neural network như sau:
![](images/image9.jpg)
Hình 12.5: Mô hình neural network, 1-2-1.
_z_ ![](images/image10.png)
Tương tự _a_ ![](images/image11.png)
Do đó
_y_ ˆ![](images/image12.png)

_x_ ![](images/image13.png)

![](images/image14.png)
Tóm lại _y_ ˆ = _x_ ∗ _a_ + _b_ hay nói cách khác mô hình neural network chỉ là mô hình linear regression đơn giản => **Hàm activation function phải là non-linear function**.

## Vanishing và exploding gradient

Backpropagation là thuật toán được dùng để tính đạo hàm các hệ số trong neural network với loss function đề rồi áp dụng gradient descent để tìm các hệ số.
![](images/image15.jpg)
Hình 12.6: Mô hình neural network 2-3-3-1
![](images/image16.jpg)
Hình 12.7: Quá trình backpropagation
Ta có tổng quát:
$$
∂J∂Â(l)=∂J∂Ŷ⋅∏i=l+1nD(i)W(i)frac{partial J}{partial{widehat{A}}^{(l)}} = frac{partial J}{partialwidehat{Y}} cdot prod_{i = l + 1}^{n}{D^{(i)}W^{(i)}}
$$
Nhận xét:

  * Nếu các hệ số W và D đều nhỏ hơn 1 thì khi tính gradient ở các layer đầu ta sẽ phải nhân tích của rất nhiều số nhỏ hơn 1 nên giá trị sẽ tiến dần về 0 và bước cập nhật hệ số trong gradient descent trở nên vô nghĩa và các hệ số neural network sẽ không học được nữa. => **Vanishing gradient**

  * Nếu các hệ số W và D đều lớn hơn 1 thì khi tính gradient ở các layer đầu ta sẽ phải nhân tích của rất nhiều số lớn hơn 1 nên giá trị sẽ tiến dần về vô cùng và bước cập nhật hệ số trong gradient descent trở nên không chính xác và các hệ số neural network sẽ không học được nữa. => **Exploding gradient**


Cách giải quyết vaninshing/exproding gradient là lựa chọn các giá trị khởi tạo cho hệ số phù hợp và chọn activation function phù hợp.

## Một số activation thông dụng

### Sigmoid activation function

![](images/image17.jpg)
Hình 12.8: Hàm sigmoid
Đạo hàm hàm sigmoid là $$
σ(x)⋅(1−σ(x))≤14sigma(x) cdot left( 1 - sigma(x) right) leq frac{1}{4}
$$
Ví dụ ![](images/image18.png) nên nếu bạn nhìn vào công thức (1) ở trên thì ở những layer đầu tiên sẽ bị **vanishing gradient**.

### Tanh activation function

![](images/image19.jpg)
Hình 12.9: Hàm tanh
Hàm tanh: $$
g(x)=ex−e−xex+e−xg(x) = frac{e^{x} - e^{- x}}{e^{x} + e^{- x}}
$$, giá trị g(x) trong đoạn (-1,1)
Đạo hàm hàm tanh: $1−g2(x)≤11 - g^{2}(x) leq 1$. Do đó khi dùng tanh activation function sẽ bị vanishing gradient.

### ReLU activation function

![](images/image20.jpg)
Hình 12.10: Hàm ReLU
Hàm relu (rectified linear unit): _y_ = _max_ (0 _,x_ ) Nhận xét:

  * Hàm ReLU activation đơn giản để tính => thời gian train model nhanh hơn.

  * Đạo hàm là 1 với x >= 0 nên không bị vanishing gradient.


Tuy nhiên với các node có giá trị nhỏ hơn 0, qua ReLU activation sẽ thành 0, hiện tượng đấy gọi là "Dying ReLU". Nếu các node bị chuyển thành 0 thì sẽ không có ý nghĩa với bước linear activation ở lớp tiếp theo và các hệ số tương ứng từ node đấy cũng không được cập nhật với gradient descent. => Leaky ReLU ra đời.

### Leaky ReLU

![](images/image21.jpg)
Hình 12.11: Hàm Leaky ReLU
Hàm Leaky ReLU có các điểm tốt của hàm ReLU và giải quyết được vấn đề Dying ReLU bằng cách xét một độ dốc nhỏ cho các giá trị âm thay vì để giá trị là 0.
Lời khuyên: Mặc định nên dùng ReLU làm hàm activation. Không nên dùng hàm sigmoid.

# Batch Normalize

Một trong những giả định chính trong được đưa ra trong quá trình huấn luyện một mô hình học máy đó là phân phối của dữ liệu được giữ nguyên trong suốt quá trình training. Đối với các mô hình tuyến tính, đơn giản là ánh xạ input với output thích hợp, điều kiện này luôn được thỏa mãn. Tuy nhiên, trong trường hợp Neural Network với các lớp được xếp chồng lên nhau, ảnh hưởng của các hàm activation non-linear, điều kiện trên không còn đúng nữa.
Trong kiến trúc neural network, đầu vào của mỗi lớp phụ thuộc nhiều vào tham số của toàn bộ các lớp trước đó. Hậu quả là trong quá trình backprop, các trọng số của một lớp được cập nhật dẫn đến những thay đổi về mặt dữ liệu sau khi đi qua lớp đó, những thay đổi này bị khuyếch đại khi mạng trở nên sâu hơn và cuối cùng làm phân phối của bản đồ đặc trưng (feature map) thay đổi, đây được gọi là hiện tượng covariance shifting. Khi huấn luyện, các lớp luôn phải điều chỉnh trọng số để đáp ứng những thay đổi về phân phối dữ liệu nhận được từ các lớp trước, điều này làm chậm quá trình hội tụ của mô hình.

## Phân tích nguyên nhân

Vấn đề 1 : Khi dữ liệu chứa nhiều thành phần lớn hơn hoặc nhỏ hơn 0 và không phân bố quanh giá trị trung bình 0 (Non zero mean), kết hợp với việc phương sai lớn (high variance) làm cho dữ liệu chứa nhiều thành phần rất lớn hoặc rất nhỏ. Trong quá trình cập nhật trọng số bằng gradient descent, giá trị của dữ liệu ảnh hưởng trực tiếp lên giá trị đạo hàm (gradient), do đó làm giá trị gradient trở nên quá lớn hoặc qúa nhỏ, như chúng ta đã biết điều này không hề tốt chút nào. Hiện tượng trên xuất hiện khá phổ biến, phụ thuộc nhiều vào việc khởi tạo trọng số, và có xu hướng nghiêm trọng hơn khi mạng ngày càng sâu.
=> Cần một bước normalize các thành phần dữ liệu về cùng mean và chuẩn hóa variance.
Vấn đề 2 : Các hàm activation non-linear như sigmoid, relu, tanh,... đều có ngưỡng hay vùng bão hòa. Khi lan truyền thẳng, nếu dữ liệu có các thành phần quá lớn hoặc quá nhỏ, sau khi đi qua các hàm activation, các thành phần này sẽ rơi vào vùng bão hòa và có đầu ra giống nhau. Điều này dẫn đến luồng dữ liệu sau đó trở nên giống nhau khi lan truyền trong mạng (covariance
shifting), lúc này các lớp còn lại trong mạng không còn phân biệt được các đặc trưng khác nhau. Ngoài ra, đạo hàm tại ngưỡng của các hàm activation bằng 0, điều này cũng khiến mô hình bị vanishing gradient.
=> Cần một bước normalize dữ liệu trước khi đi qua hàm activation.
![](images/image22.jpg)
Hình 12.12: Đồ thị các hàm activation

## Batch Normalization ra đời

Batch normalization thực hiện việc chuẩn hóa (normalizing) và zero centering (mean substracting) dữ liệu trước khi đưa qua hàm activation (giá trị trung bình (mean) sẽ được đưa về 0 và phương sai (variance) sẽ được đưa về 1). Để thực hiện 2 công việc trên, batch normalization tính toán phương sai và độ lệch chuẩn của dữ liệu dựa trên các batchs, rồi sử dụng 2 tham số _γ_ và _β_ tinh chỉnh đầu ra.
Batch normalization:
_µ B _![](images/image23.png) _x_ ( _i_ )
![](images/image24.png)
_x_ ˆ![](images/image25.png)
_z_ ( _i_ ) = _γx_ ˆ+ _β_
Trong đó: _µ B _là giá trị trung bình của batch B
_σ 2B_ là phương sai của batch B
_x_ ˆ( _i_ ) là giá trị của mẫu thứ i trong batch B sau khi được normalize và zero centering
_z_ ( _i_ ) là đầu ra của mẫu thứ i trong batch B
_γ_ là scaling parameter của lớp
_β_ là shifting parameter của lớp
_ξ_ là smoothing parameter, tránh xảy ra việc chia cho 0, giá trị rất nhỏ
Chú ý: _γ_ và _β_ là 2 tham số được học trong quá trình training.

## Hiệu quả của batch normalization

  * Batch normalization đưa dữ liệu về zero mean và chuẩn hóa variance trước khi đưa qua activation function nhờ đó giải quyết các vấn đề vanishing gradient hay exploding gradient.

  * Batch normalization cho phép learning rate lớn trong quá trình huấn luyện.

  * Batch-Norm giảm thiểu sự ảnh hưởng của quá trình khởi tạo trọng số ban đầu.

  * Batch-Norm chuẩn hóa dữ liệu đầu ra của các layer giúp model trong quá trình huấn luyện không bị phụ thuộc vào một thành phần trọng số nhất định. Do đó, Batch-norm còn được sử dụng như một regularizer giúp giảm overfitting

# Public_047

# Bài toán object detection

Trong bài 7, sách đã giới thiệu về ứng dụng mô hình CNN cho bài toán phân loại ảnh, tuy nhiên các ảnh input của bài toán phân loại chỉ bao gồm 01 đối tượng cụ thể như chữ số hay 01 loài hoa.
![](images/image1.png)
Hình 13.1: Ví dụ ảnh trong bài toán phân loại ảnh
Tuy nhiên là ảnh trong cuộc sống bình thường thì không chỉ có 01 đối tượng mà thường chứa nhiều các đối tượng khác. Từ đó nảy sinh vấn đề cần tìm vị trí của từng đối tượng trong ảnh. Đó là bài toán object detection.
![](images/image2.png)
Hình 13.2: Ví dụ output của object detection [22]
Bài toán object detection có input là ảnh màu và output là vị trí của các đối tượng trong ảnh. Ta thấy nó bao gồm 2 bài toán nhỏ:

  * Xác định các bounding box (hình chữ nhật) quanh đối tượng.

  * Với mỗi bounding box thì cần phân loại xem đấy là đối tượng gì (chó, ngựa, ô tô,...) với bao nhiêu phần trăm chắc chắn.


Việc lựa chọn có bao nhiêu loại đối tượng thì phụ thuộc vào bài toán mà ta đang giải quyết.
Bạn tự hỏi liệu mô hình CNN có giải quyết được bài toán object detection không? Vấn đề chính là vì không biết trước có bao nhiêu đối tượng trong ảnh, nên không thiết kế được output layer hiệu quả => mô hình CNN truyền thống không giải quyết được => R-CNN (regional convolutional neural network) ra đời.

# Faster R-CNN

## R-CNN (Region with CNN feature)

Ý tưởng thuật toán R-CNN khá đơn giản

  * Bước 1: Dùng Selective Search algorithm để lấy ra khoảng 2000 bounding box trong input mà có khả năng chứa đối tượng.

  * Bước 2: Với mỗi bounding box ta xác định xem nó là đối tượng nào (người, ô tô, xe đạp,...)


### Selective search algorithm

Input của thuật toán là ảnh màu, output là khoảng 2000 region proposal (bounding box) mà có khả năng chứa các đối tượng.
Đầu tiên ảnh được segment qua thuật toán Graph Based Image Segmentation, vì thuật toán dựa vào lý thuyết đồ thị và không áp dụng deep learning nên sách không giải thích chi tiết, bạn có thể đọc theo link ở dưới để tìm hiểu thêm.
![](images/image3.png)
Hình 13.3: Output sau khi thực hiện graph based image segmentation [23]
Nhận xét: Ta không thể dùng mỗi màu trong output để làm 1 region proposal được vì:

  * Mỗi đối tượng trong ảnh có thể chứa nhiều hơn 1 màu.

  * Các đối tượng bị che mất một phần như cái đĩa dưới cái chén không thể xác định được. => Cần nhóm các vùng màu với nhau để làm region proposal.


Tiếp theo, các vùng màu được nhóm với nhau dựa trên độ tương đồng về màu sắc, hướng gradient, kích thước,...
Cuối cùng các region proposal được xác định dựa trên các nhóm vùng màu.

### Phân loại region proposal

Bài toán trở thành phân loại ảnh cho các region proposal. Do thuật toán selective search cho tới 2000 region proposal nên có rất nhiều region proposal không chứa đối tượng nào. Vậy nên ta cần thêm 1 lớp background (không chứa đối tượng nào). Ví dụ như hình dưới ta có 4 region proposal, ta sẽ phân loại mỗi bounding box là người, ngựa hay background.
![](images/image4.png)
Hình 13.4: Các bước trong RCNN [8]
Sau đó các region proposal được resize lại về cùng kích thước và thực hiện transfer learning với feature extractor, sau đó các extracted feature được cho vào thuật toán SVM để phân loại ảnh.
Bên cạnh đó thì extracted feature cũng được dùng để dự đoán 4 offset values cho mỗi cạnh. Ví dụ như khi region proposal chứa người nhưng chỉ có phần thân và nửa mặt, nửa mặt còn lại không có trong region proposal đó thì offset value có thể giúp mở rộng region proposal để lấy được toàn bộ người.

### Vấn đề với R-CNN

Hồi mới xuất hiện thì thuật toán hoạt động khá tốt cho với các thuật toán về computer vision trước đó nhờ vào CNN, tuy nhiên nó vẫn có khá nhiều hạn chế:

  * Vì với mỗi ảnh ta cần phân loại các class cho 2000 region proposal nên thời gian train rất lâu.

  * Không thể áp dụng cho real-time vì mỗi ảnh trong test set mất tới 47s để xử lý.


## Fast R-CNN

Khoảng 1.5 năm sau đó, Fast R-CNN được giới thiệu bởi cùng tác giả của R-CNN, nó giải quyết được một số hạn chế của R-CNN để cải thiện tốc độ.
Tương tự như R-CNN thì Fast R-CNN vẫn dùng selective search để lấy ra các region proposal. Tuy nhiên là nó không tách 2000 region proposal ra khỏi ảnh và thực hiện bài toán image classification cho mỗi ảnh. Fast R-CNN cho cả bức ảnh vào ConvNet (một vài convolutional layer + max pooling layer) để tạo ra convolutional feature map.
Sau đó các vùng region proposal được lấy ra tương ứng từ convolutional feature map. Tiếp đó được Flatten và thêm 2 Fully connected layer (FCs) để dự đoán lớp của region proposal và giá trị offset values của bounding box.
![](images/image5.png)
Hình 13.5: Các bước trong Fast RCNN [7]
Tuy nhiên là kích thước của các region proposal khác nhau nên khi Flatten sẽ ra các vector có kích thước khác nhau nên không thể áp dụng neural network được. Thử nhìn lại xem ở trên R-CNN đã xử lý như thế nào? Nó đã resize các region proposal về cùng kích thước trước khi dùng transfer learning. Tuy nhiên ở feature map ta không thể resize được, nên ta phải có cách gì đấy để chuyển các region proposal trong feature map về cùng kích thước => Region of Interest (ROI) pooling ra đời.

### Region of Interest (ROI) pooling

ROI pooling là một dạng của pooling layer. Điểm khác so với max pooling hay average pooling là bất kể kích thước của tensor input, ROI pooling luôn cho ra output có kích thước cố định được định nghĩa trước.
Ta kí hiệu a/b là phần nguyên của a khi chia cho b và a%b là phần dư của a khi chia cho b. Ví dụ: 10/3 = 3 và 10%3 = 1.
Gọi input của ROI pooling kích thước m*n và output có kích thước h*k (thông thường h, k nhỏ ví dụ 7*7).

  * Ta chia chiều rộng thành h phần, (h-1) phần có kích thước m/h, phần cuối có kích thước m/h + m%h.

  * Tương tự ta chia chiều dài thành k phần, (k-1) phần có kích thước n/k, phần cuối có kích thước n/k + n%k.


Ví dụ m=n=10, h=k=3, do m/h = 3 và m%h = 1, nên ta sẽ chia chiều rộng thành 3 phần, 2 phần có kích thước 3, và 1 phần có kích thước 4.
![](images/image6.png)
Sau đó với mỗi khối được tạo ra bằng các đường đỏ và cạnh, ta thực hiện max pooling lấy ra 1 giá trị.
![](images/image7.png)
Hình 13.6: Thực hiện ROI pooling
Ta có thể thấy là kích thước sau khi thực hiện ROI pooling về đúng h*k như ta mong muốn.

### Đánh giá Fast R-CNN

![](images/image8.png)
Hình 13.7: So sánh thời train train và test giữa R-CNN và Fast R-CNN [17]
Fast R-CNN khác với R-CNN là nó thực hiện feature map với cả ảnh sau đó với lấy các region proposal ra từ feature map, còn R-CNN thực hiện tách các region proposal ra rồi mới thực hiện CNN trên từng region proposal. Do đó Fast R-CNN nhanh hơn đáng kể nhờ tối ưu việc tính toán bằng Vectorization.
Tuy nhiên nhìn hình trên ở phần test time với mục Fast R-CNN thì thời gian tính region proposal rất lâu và làm chậm thuật toán => Cần thay thế thuật toán selective search. Giờ người ta nghĩ đến việc dùng deep learning để tạo ra region proposal => Faster R-CNN ra đời.

## Faster R-CNN

Faster R-CNN không dùng thuật toán selective search để lấy ra các region proposal, mà nó thêm một mạng CNN mới gọi là Region Proposal Network (RPN) để tìm các region proposal.
![](images/image9.png)
Hình 13.8: Kiến trúc mới Faster R-CNN [18]
Đầu tiên cả bức ảnh được cho qua pre-trained model để lấy feature map. Sau đó feature map được dùng cho Region Proposal Network để lấy được các region proposal. Sau khi lấy được vị trí các region proposal thì thực hiện tương tự Fast R-CNN.

### Region Proposal Network (RPN)

Input của RPN là feature map và output là các region proposal. Ta thấy các region proposal là hình chữ nhật.
Mà một hình chữ nhật được xác định bằng 2 điểm ở 2 góc, ví dụ A(x_min, y_min) và B(x_max, y_max). Nhận xét:

  * Khi RPN dự đoán ta phải rằng buộc x_min < x_max và y_min < y_max.

  * Hơn nữa các giá trị x,y khi dự đoán có thể ra ngoài khỏi bức ảnh


=> Cần một kĩ thuật mới để biểu diễn region propsal => Anchor ra đời.
Ý tưởng là thay vì dự đoán 2 góc ta sẽ dự đoán điểm trung tâm (x_center, y_center) và width, height của hình chữ nhật. Như vậy mỗi anchor được xác định bằng 4 tham số (x_center, y_center, width, height).
Vì không sử dụng Selective search nên RPN ban đầu cần xác định các anchor box có thể là region proposal, sau đó qua RPN thì chỉ output những anchor box chắc chắn chứa đối tượng.
![](images/image10.png)
Hình 13.9: Ví dụ về anchor [21]
Ảnh bên trái kích thước 400 * 600 pixel, các tâm của anchor box màu xanh, cách nhau 16 pixel => có khoảng (400*600)/(16*16) = 938 tâm. Do các object trong ảnh có thể có kích thước và tỉ lệ khác nhau nên với mỗi tâm ta định nghĩa 9 anchors với kích thước 64 × 64, 128 × 128, 256×256, mỗi kích thước có 3 tỉ lệ tương ứng: 1 : 1, 1 : 2 và 2 : 1.
Giống như hình bên phải với tâm ở giữa 3 kích thước ứng với màu da cam, xanh lam, xanh lục và với mỗi kích thước có 3 tỉ lệ.
=> Số lượng anchor box giờ là 938 * 9 = 8442 anchors. Tuy nhiên sau RPN ta chỉ giữ lại khoảng 1000 anchors box để thực hiện như trong Fast R-CNN.
**Việc của RPN là lấy ra các region proposal giống như selective search thôi chứ không phải là phân loại ảnh.**
Mô hình RPN khá đơn giản, feature map được cho qua Conv layer 3*3, 512 kernels. Sau đó với mỗi anchor lấy được ở trên, RPN thực hiện 2 bước:

  1. Dự đoán xem anchor đấy là foreground (chứa object) hay background (không chứa object)

  2. Dự đoán 4 offset value cho x_center, y_center, width, height cho các anchor.


Nhận xét: có rất nhiều anchor bị chồng lên nhau nên non-maxima suppression được dùng để loại bỏ các anchor chồng lên nhau.
Sau cùng dựa vào phần trăm dự đoán background RPN sẽ lấy N anchor (N có thể 2000, 1000, thậm chí 100 vẫn chạy tốt) để làm region proposal.

### Intersection over Union (IoU)

IoU được sử dụng trong bài toán object detection, để đánh giá xem bounding box dự đoán đối tượng khớp với ground truth thật của đối tượng.
![](images/image11.png)
Hình 13.10: Ví dụ về IoU [11]
Ví dụ về hệ số IoU, nhận xét:

  * Chỉ số IoU trong khoảng [0,1]

  * IoU càng gần 1 thì bounding box dự đoán càng gần ground truth

# Public_048

# Lời mở đầu

Bài toán nhận diện biển số xe Việt Nam là một bài toán không còn mới, đã được phát triển dựa trên các phương pháp xử lý ảnh truyền thống và cả những kỹ thuật mới sử dụng Deep Learning. Trong bài toán này tôi chỉ phát triển bài toán phát hiện biển số (một phần trong bài toán nhận diện biển số) dựa trên thuật toán YOLO-Tinyv4 với mục đích:

  * Hướng dẫn chuẩn bị dữ liệu cho bài toán Object Detection.

  * Hướng dẫn huấn luyện YOLO-TinyV4 dùng darknet trên Google Colab.


# Chuẩn bị dữ liệu

## Đánh giá bộ dữ liệu

Trong bài viết tôi sử dụng bộ dữ liệu biển số xe máy Việt Nam chứa 1750 ảnh, bạn đọc có thể tải tại [_đây._](https://thigiacmaytinh.com/tai-nguyen-xu-ly-anh/tong-hop-data-xu-ly-anh/?fbclid=IwAR2tajA5Ku83kIrb09ovhmb_68Zmdwo9KvV_CSNBCTbuIIsiK_FUM4W4Dh8)
![](images/image1.png)
Hình 14.1: Ảnh biển số trong bộ dữ liệu
Ảnh biển số xe được trong bộ dữ liệu được chụp từ một camera tại vị trí kiểm soát xe ra vào trong hầm. Do vậy:

  * Kích thước các biển số xe không có sự đa dạng, do khoảng cách từ camera đến biển số xe xấp xỉ gần bằng nhau giữa các ảnh.

  * Ảnh có độ sáng thấp và gần giống nhau do ảnh được chụp trong hầm chung cư.


=> Cần làm đa dạng bộ dữ liệu.

## Các phương pháp tăng sự đa dạng của bộ dữ liệu

### Đa dạng kích thước của biển số

Đa dạng kích thước bằng 2 cách:

  * Cách 1: Thu nhỏ kích thước biển bằng cách thêm biên kích thước ngẫu nhiên vào ảnh gốc, sau đó resize ảnh bằng kích thước ảnh ban đầu.

  * Cách 2: Crop ảnh chứa biển số với kích thước ngẫu nhiên, sau đó resize ảnh bằng kích thước ảnh ban đầu.


_# Cách1_ def add_boder(image_path, output_path, low, high):
_""" low: kích thước biên thấp nhất (pixel) hight: kích thước biên lớn nhất (pixel)_
_"""_
_# random các kích thước biên trong khoảng (low, high)_
top = random.randint(low, high)
bottom = random.randint(low, high)
left = random.randint(low, high)
right = random.randint(low, high)
image = cv2.imread(image_path)
original_width, original_height = image.shape[1], image.shape[0]
_#sử dụng hàm của opencv để thêm biên_
image = cv2.copyMakeBorder(image, top, bottom, left, right, cv2.BORDER_REPLICATE)
_#sau đó resize ảnh bằng kích thước ban đầu của ảnh_
image = cv2.resize(image, (original_width, original_height))
cv2.imwrite(output_path, image)
![](images/image2.png)
Hình 14.2: Ảnh thu được (bên phải) sau khi chạy hàm trên
_# Cách2_ def random_crop(image_path, out_path):
image = cv2.imread(image_path)
original_width, original_height = image.shape[1], image.shape[0]
x_center,y_center = original_height//2, original_width//2
x_left = random.randint(0, x_center//2)
x_right = random.randint(original_width-x_center//2, original_width)
y_top = random.randint(0, y_center//2)
y_bottom = random.randint(original_height-y_center//2, original_width)
_# crop ra vùng ảnh với kích thước ngẫu nhiên_
cropped_image = image[y_top:y_bottom, x_left:x_right]
_# resize ảnh bằng kích thước ảnh ban đầu_
cropped_image = cv2.resize(cropped_image, (original_width, original_height))
cv2.imwrite(out_path, cropped_image)
![](images/image3.png)
Hình 14.3: Ảnh thu được (bên phải) sau khi chạy hàm trên

### Thay đổi độ sáng của ảnh

def change_brightness(image_path, output_path, value):
_""" value: độ sáng thay đổi"""_
img=cv2.imread(image_path)
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
h, s, v = cv2.split(hsv)
v = cv2.add(v, value)
v[v > 255] = 255
v[v < 0] = 0
final_hsv = cv2.merge((h, s, v))
img = cv2.cvtColor(final_hsv, cv2.COLOR_HSV2BGR)
cv2.imwrite(output_path, img)
![](images/image4.png)
Hình 14.4: Độ sáng thay đổi (bên phải)

### Xoay ảnh

import imutils def rotate_image(image_path, range_angle, output_path):
_""" range_angle: Khoảng góc quay"""_
image = cv2.imread(image_path)
_#lựa chọn ngẫu nhiên góc quay_
angle = random.randint(-range_angle, range_angle)
img_rot = imutils.rotate(image, angle)
cv2.imwrite(output_path, img_rot)
![](images/image5.png)
Hình 14.5: Ảnh được xoay (bên phải)

## Gán nhãn dữ liệu

Tool gán nhãn ở đây tôi dùng là **labelImg** , bạn đọc có thể tải và đọc hướng dẫn sử dụng tại [_đây._](https://github.com/tzutalin/labelImg)
![](images/image6.png)
Hình 14.6: Xác định vùng biển chứa biển số
**LabelImg** hỗ trợ gán nhãn trên cả 2 định dạng PASCAL VOC và YOLO với phần mở rộng file annotation tương ứng là .xml và .txt.
Trong bài toán sử dụng mô hình YOLO, tôi lưu file annotation dưới dạng .txt.
![](images/image7.png)
Hình 14.7: Nội dung trong một file annotation
Mỗi dòng trong một file annotation bao gồm: <object-class> <x> <y> <width> <height>.
Trong đó: <x> <y> <width> <height> tương ứng là tọa độ trung tâm và kích thước của đối tượng. Các giá trị này đã được chuẩn hóa lại, do vậy giá trị luôn nằm trong đoạn [0,1]. object-class là chỉ số đánh dấu các classes.
Lưu ý: Với bài toán có nhiều nhãn, nhiều người cùng gán nhãn thì cần thống nhất với nhau trước về thứ tự nhãn. Nguyên nhân do trong file annotation chỉ lưu chỉ số (0,1,3,4,...) của nhãn chứ không lưu tên nhãn.
Sau khi gán nhãn xong các bạn để file annotation và ảnh tương ứng **vào cùng một thư mục**.

# Huấn luyện mô hình

## Giới thiệu về YOLO-Tinyv4 và darknet

### YOLO-Tinyv4

YOLOv4 là thuật toán Object Detection, mới được công bố trong thời gian gần đây với sự cải thiện về kết quả đáng kể so với YOLOv3.
![](images/image8.png)
Hình 14.8: Sự cải thiện của YOLOv4 ([ _source)_](https://arxiv.org/pdf/2004.10934.pdf)
YOLOv4 cho kết quả real-time khi chạy trên các nền tảng GPU cao cấp. Với mục đích trade-off giữa độ chính xác và tốc độ để có thể chạy trên các nền tảng CPU và GPU thấp hơn thì YOLO-Tinyv4 được ra đời.
![](images/image9.png)
Hình 14.9: YOLOv4 với YOLO-Tinyv4 ([ _source)_](https://github.com/AlexeyAB/darknet/issues/6067)
![](images/image10.png)
Hình 14.10: YOLO-Tinyv4 trên các nền tảng ([ _source)_](https://github.com/AlexeyAB/darknet/issues/6067)

### Darknet

**[_Darknet_](https://pjreddie.com/darknet/)** là một framework open source chuyên về Object Detection được viết bằng ngôn ngữ C và CUDA. Darknet dùng để huấn luyện các mô hình YOLO một cách nhanh chóng, dễ sử dụng.

# Public_049

Mục tiêu chính của chương này là giải thích rõ tầm quan trọng của việc phân tích thuật toán cùng với mối liên hệ và sự ảnh hưởng qua lại giữa dữ liệu và thuật toán. Để thực hiện được điều này, chúng ta sẽ bắt đầu từ những khái niệm và định nghĩa cơ bản về dữ liệu, thuật toán sau đó mở rộng sang những vấn đề quan trọng hơn độ phức tạp thuật toán, độ phức tạp chương trình. Cuối cùng, chúng ta sẽ xem xét đến quy trình giải quyết một vấn đề trong khoa học máy tính bằng thuật toán.

# Kiểu và cấu trúc dữ liệu 

Trước khi định nghĩa chính xác các khái niệm về kiểu dữ liệu ( _data types_ ), biến ( _variables_ ) ta xem xét lại với những gì ta đã từng biết trước đây trong toán học. Chẳng hạn khi ta giải phương trình:

𝑥2−2𝑦−2=1

Tiếp cận bằng toán học ta nói nghiệm của phương trình trên là tập các cặp ( _x_ , _y_ ) sao cho 𝑥2−2𝑦−2=1. Ví dụ cặp (1, -1) là một nghiệm của phương trình. Tiếp cận bằng tin học ta sẽ thấy phương trình trên có hai tên là _x_ và _y_. Nếu _x_ và _y_ có giá trị tương ứng là _1_ , _-1_ thì đó là một nghiệm của phương trình. Trong khoa học máy tính cũng gọi _x_ và _y_ là hai biến và các bộ giá trị của _x_ và _y_ được gọi là dữ liệu.

Hai biến _x_ và _y_ có thể nhận giá trị trong các miền khác nhau. Để giải được phương trình ta cần phải xác định được miền giá trị của hai biến _x_ và _y_. Ví dụ, _x_ , _y_ xác định trong miền các số nguyên (10, 20, 30,..), số thực (0.23, 0.55,…) hoặc (0, 1). Để xác định miền giá trị của các biến, trong khoa học máy tính sử dụng một từ khóa đại diện cho một tập các giá trị còn được gọi là một kiểu dữ liệu ( _a data type_ ). Ta sẽ bắt đầu bằng cách tổng quát hóa những khái niệm cơ bản này theo cách tiếp cận của khoa học máy tính.

## Kiểu dữ liệu 

**Kiểu dữ liệu ( _a data type_ )** là một tên hay từ khóa dùng để chỉ tập các đối tượng dữ liệu cùng các phép toán trên nó. Ví dụ trong C++, từ khóa _int_ dùng để chỉ tập các số nguyên có độ lớn biểu diễn bằng 2 byte (tùy thuộc vào các compiler) cùng với các phép toán số học, các phép toán so sánh, các phép toán cấp bít, các phép toán dịch chuyển bit. Từ khóa _float_ dùng để chỉ tập các số thực có độ chính xác đơn có độ lớn được biểu diễn bằng 4 byte (tùy thuộc vào các compiler) cùng với các phép toán số học, các phép toán so sánh. Không có phép lấy phần dư, các phép toán thao tác cấp bít với kiểu dữ liệu _float_. Kiểu dữ liệu được chia thành hai loại kiểu dữ liệu cơ bản hay còn gọi là kiểu dữ liệu nguyên thủy và các kiểu dữ liệu do người dùng định nghĩa.

**Kiểu dữ liệu nguyên thủy** ( _primitive data types_ ) các kiểu dữ liệu được định nghĩa bởi hệ thống ( _system defined data type_ ) được gọi là các kiểu dữ liệu nguyên thủy. Thông thường, các ngôn ngữ lập trình cung cấp ba kiểu dữ liệu nguyên thủy đó là ký tự ( _character_ ), số ( _numeric_ ), và kiểu logic ( _bool_ ). Kiểu dữ liệu ký tự được chia thành hai loại ký tự ASCII ( _char_ ) và ký tự unicode ( _wchar_t_ ). Kiểu dữ liệu số cũng được chia thành hai loại: số kiểu số nguyên ( _integer_ ) và kiểu số thực ( _real_ ). Kiểu số nguyên được chia thành ba loại: số nguyên nhỏ ( _int_ ), số nguyên lớn ( _long_ ), số nguyên rất lớn ( _long long_ ). Kiểu số thực được chia làm hai loại: số thực có độ chính xác đơn ( _float_ ) và số thực có độ chính xác kép ( _double_ ). Dữ liệu kiểu bool chỉ định nghĩa bộ hai giá trị đúng ( _true_ ) và sai ( _false_ ).

Đương nhiên, hai từ khóa khác nhau đại diện cho hai kiểu dữ liệu khác nhau. Quan sát này chỉ mang tính hình thức vì ta có thể quan sát được bằng mắt. Sự khác biệt bên trong giữa các kiểu dữ liệu là không gian bộ nhớ dùng để biểu diễn kiểu và các phép toán dành cho mỗi biến thuộc kiểu. Không gian nhớ dành cho kiểu phụ thuộc vào compiler của ngôn ngữ lập trình và hệ thống máy tính ta đang sử dụng. Chẳng hạn, kiểu dữ liệu _int_ một số compiler dùng 2 byte biểu diễn, một số compiler dùng 4 byte để biểu diễn. Các phép toán lấy phần dư ( _modulo_ ), dịch chuyển bít ( _bit operations_ ) định nghĩa cho các số _int_ , _long_ nhưng không định nghĩa cho các số _float_ và _double_. Để xác định độ lớn của kiểu ta có thể sử dụng hàm _sizeof_ ( _tên kiểu_ ). Ví dụ dưới đây dùng để xác định không gian nhớ dành cho kiểu.


| //Ví dụ 1.1.Xác định kích cỡ bộ nhớ biểu diễn
kiểu#include <iostream> using namespace std; int main(void){cout<<"KÍCH CỠ KIỂU CƠ BẢN"<<endl; cout<<"Kích cỡ
kiểu bool:"<<sizeof(bool)<<endl;cout<<" Kích cỡ kiểu
char:"<<sizeof(char)<<endl;cout<<" Kích cỡ kiểu
wchar_t:"<<sizeof(wchar_t)<<endl; cout<<" Kích cỡ kiểu
int:"<<sizeof(int)<<endl; cout<<" Kích cỡ kiểu
long:"<<sizeof(long)<<endl; cout<<" Kích cỡ kiểu long
long:"<<sizeof(long long)<<endl;cout<<" Kích cỡ kiểu float:"<<sizeof(float)<<endl;
cout<<" Kích cỡ kiểu
double:"<<sizeof(double)<<endl;} |
| --- |

 

**Kiểu dữ liệu do người dùng định nghĩa** ( _user defined data types_ ) là các kiểu dữ liệu được do người dùng xây dựng bằng cách tổ hợp các kiểu dữ liệu nguyên thủy theo một nguyên tắc nào đó. Chẳng hạn, kiểu mảng ( _array_ ) là dãy có thứ tự các phần tử ( _các biến_ ) có cùng chung một kiểu dữ liệu được tổ chức liên tục nhau trong bộ nhớ. Kiếu xâu ký tự (string) là một mảng mỗi phần tử là một ký tự và có ký tự kết thúc là ‘\0’. Như vậy, các kiểu dữ liệu không thuộc các kiểu dữ liệu nguyên thủy như mảng, cấu trúc, file đều được xem là các kiểu dữ liệu do người dùng định nghĩa.

**Cấu trúc dữ liệu ( _data structure_ )** là phương pháp biểu diễn các đối tượng ở thế giới thực thành một đối tượng dữ liệu được tổ chức và lưu trữ trong máy tính để có thể sử lý một cách hiệu quả. Theo nghĩa này, mảng ( _array_ ), danh sách liên kết ( _linked list_ ), ngăn xếp ( _stack_ ), hàng đợi ( _queue_ ), cây ( _tree_ ), đồ thị ( _graph_ )… đều được gọi là các cấu trúc dữ liệu. Dựa vào biểu diễn của các cấu trúc dữ liệu, khoa học máy tính chia các cấu trúc dữ liệu thành hai loại: các cấu trúc dữ liệu tuyến tính ( _linear data structures_ ) và các cấu trúc dữ liệu không tuyến tính ( _non-linear data structures_ ). Một cấu trúc dữ liệu được gọi là tuyến tính nếu việc truy cập các phần tử được thực hiện tuần tự nhưng không nhất thiết được tổ chức liên tục. Điều này có nghĩa, các cấu trúc dữ liệu mảng, danh sách liên kết đơn, danh sách liên kết kép đều là các cấu trúc dữ liệu tuyến tính. Một cấu trúc dữ liệu được gọi là không tuyến tính nếu các phần tử của nó được tổ chức và truy cập không tuần tự. Theo nghĩa này, các cấu trúc dữ liệu cây, graph đều là các cấu trúc dữ liệu không tuyến tính.

**Cấu trúc dữ liệu trừu tượng ( _Abstract Data types: ADTs_ )** là phương pháp kết hợp giữa cấu trúc dữ liệu cùng với các phép toán trên dữ liệu cụ thể của cấu trúc dữ liệu. Như vậy, mỗi kiểu dữ liệu ADTs bao gồm hai thành phần:

  * _Biểu diễn cấu trúc dữ liệu_.

  * _Xây dựng các phép toán trên dữ liệu_ _cụ thể_ _của cấu trúc dữ liệu._


Theo nghĩa này các cấu trúc dữ liệu danh sách liên kết ( _linked list_ ), ngăn xếp ( _stack_ ), hàng đợi ( _queue_ ), hàng đợi ưu tiên ( _priority queue_ ), cây nhị phân ( _binary tree_ ), đồ thị ( _graph_ ) đều là _ADTs_. Mỗi cấu trúc dữ liệu cụ thể cùng các thao tác trên nó sẽ được trình bày trong những chương tiếp theo của tài liệu.

Đối với mỗi cấu trúc dữ liệu trừu tượng, ta cần quan tâm và nắm bắt được những vấn đề sau:

  * **Định nghĩa** : nhằm xác định rõ cấu trúc dữ liệu ADTs ta đang quan tâm đến là gì.

  * **Biểu diễn** : nhằm định hình nên cấu trúc dữ liệu ADTs.

  * **Thao tác (phép toán)** : những thao tác và phép toán nào được cài đặt trên cấu trúc dữ liệu ADTs.

  * **Ứng dụng** : sử dụng cấu trúc dữ liệu ADTs để giải quyết lớp những bài toán nào trong khoa học máy tính.


## Biến 

Khi một cấu trúc dữ liệu được thiết lập thì thể hiện cụ thể của cấu trúc dữ liệu đó là các phần tử dữ liệu và ta thường gọi là biến. Biến trong tin học và biến trong toán học cũng có một số điểm khác biệt. Biến trong toán học hoàn toàn là một tên hình thức. Ngược lại, biến trong tin học có tên mang tính hình thức, nhưng tên này được lưu trữ tại một vị trí bộ nhớ xác định được gọi là địa chỉ của biến. Dựa vào địa chỉ của biến, giá trị của biến sẽ được lưu trữ tại địa chỉ ô nhớ dành cho biến trong khi xử lý dữ liệu.

**Biến ( _variables_ )**: là một tên thuộc kiểu. Trong đó, mỗi tên biến dùng để chỉ bộ ba thành phần: tên ( _name_ ), địa chỉ ( _address_ ), giá trị ( _value_ ). Chẳng hạn khi ta có khai báo _int a =10_ ; khi đó tên biến là _a_ , địa chỉ của biến là _& a_, giá trị của biến là _10_. Trong các ngôn ngữ lập trình, biến cũng được chia thành hai loại: biến toàn cục (global variables) và biến cục bộ (local variables).

Một biến được gọi là biến toàn cục nếu nó được khai báo ngoài tất cả các hàm kể cả hàm main(). Không gian nhớ dành cho biến toàn cục sẽ được cấp phát cho biến ngay từ khi bắt đầu thực hiện chương trình cho đến khi kết thúc thực hiện chương trình. Phạm vi sử dụng biến mang tính toàn cục. Người lập trình được phép truy cập và thay đổi giá trị của biến toàn cục ở bất kể vị trí nào trong chương trình. Một biến được gọi là biến cục bộ nếu nó được khai báo trong thân của hàm kể cả hàm main(). Không gian nhớ dành cho biến toàn cục chỉ được cấp phát sau mỗi lần kích hoạt hàm. Phạm vi sử dụng biến cục bộ chỉ được phép trong nội bộ hàm. Chú ý, khi tên biến toàn cục trùng với tên biến cục bộ thì ưu tiên xử lý dành cho biến cục bộ. Ví dụ dưới đây sẽ minh họa cho biến toàn cục và biến cục bộ.


| //Ví dụ 1.2.Biến toàn cục và biến cục bộ#include <iostream> using namespace std; int a = 10, b = 20;
int Swap (int &a, int & b){int t = a; a=b; b = t;}int main(void){Swap(a, b); //Tại điểm này ta thao tác với hai biến toàn cục a,
bcout<<"a = "<<a <<" b = "<<b<<endl; int
a = 5, b = 7; //Từ vị trí này trở điSwap(a,b);//Ta hoàn toàn thao tác với hai biến a, b cục bộcout<<"a = "<<a <<" b = "<<b<<endl;} |
| --- |

 

# Thuật toán và một số vấn đề liên quan 

Như đã trình bày trong Mục 1.1.1, cấu trúc dữ liệu là phương pháp biểu diễn các đối tượng ở thế giới thực thành một đối tượng trong máy tính. Còn thuật toán được hiểu là phương pháp xử lý các đối tượng dữ liệu đã được biểu diễn để đưa ra kết quả mong muốn. Ta có thể tổng quát hóa khái niệm thuật toán như sau.

**Định nghĩa thuật toán (Algorithm)** : Thuật toán _F_ giải bài toán _P_ là dãy các thao tác sơ cấp _F_ 1, _F_ 2,.., _F_ N trên tập dữ kiện đầu vào ( _Input_ ) để đưa ra được kết quả ra ( _Output_ ).

_F_ 1 _F_ 2.. _F_ N( _Input_ )  _Ouput_.

  * _F_ = _F_ 1 _F_ 2.. _F_ N được gọi là thuật toán giải bài toán _P_. Trong đó, mỗi _F_ i là các phép toán sơ cấp.

  * _Input_ được gọi là tập dữ kiện đầu vào hay tập thông tin đầu vào.

  * _Output_ là kết quả nhận được sau khi thực hiện thuật toán _F_ trên tập _Input_.


**Ví dụ**. Thuật toán tìm USCLN(a, b).

_int USCLN ( int a, int b)_ {// _đầu vào là số nguyên a, b_

_while (b!=0 )_ {// _lặp trong khi b khác 0_

_x = a % b; //lấy x là a mode b_

  1. _= b; //đặt a bằng b_

  2. _=x; //đặt b bằng x_


}

_return(a);//kết quả thực thi thuật toán_

}
**Những đặc trưng cơ bản của thuật toán** :

  * **Tính đơn định**. Ở mỗi bước của thuật toán, các thao tác sơ cấp phải hết sức rõ ràng, không tạo ra sự lộn xộn, nhập nhằng, đa nghĩa. Thực hiện đúng các bước của thuật toán trên tập dữ liệu đầu vào chỉ cho duy nhất một kết quả.

  * **Tính dừng**. Thuật toán không được rơi vào quá trình vô hạn. Thuật toán phải dừng lại và cho kết quả sau một số hữu hạn các bước.

  * **Tính đúng**. Sau khi thực hiện tất cả các bước của thuật toán theo đúng quy trình đã định, ta phải nhận được kết quả mong muốn với mọi bộ dữ liệu đầu vào. Kết quả đó được kiểm chứng bằng yêu cầu của bài toán.

  * **Tính phổ dụng**. Thuật toán phải dễ sửa đổi để thích ứng được với bất kỳ bài toán nào trong lớp các bài toán cùng loại và có thể làm việc trên nhiều loại dữ liệu khác nhau.

  * **Tính khả thi**. Thuật toán phải dễ hiểu, dễ cài đặt, thực hiện được trên máy tính với thời gian cho phép.


Đối với thuật toán ta cần quan tâm đến những vấn đề sau:

  * **Biểu diễn thuật toán:** xác định ngôn ngữ để biểu diễn thuật toán.

  * **Đánh giá độ phức tạp thuật toán** : ước lượng thời gian và không gian nhớ khi thực hiện thuật toán.

  * **Kiểm nghiệm thuật toán** : kiểm nghiệm thuật toán với các bộ dữ liệu thực khác nhau.

  * **Cài đặt thuật toán** : cài đặt thuật toán bằng ngôn ngữ lập trình cụ thể.


# Biểu diễn thuật toán 

Có ba ngôn ngữ chính để biểu diễn thuật toán: ngôn ngữ tự nhiên, ngôn ngữ máy tính và ngôn ngữ hình thức.

  * **Ngôn ngữ tự nhiên** là phương tiện giao tiếp giữa con người với con người. Ta có thể sử dụng chính ngôn ngữ này vào việc biểu diễn thuật toán.

  * **Ngôn ngữ máy tính** là phương tiện giao tiếp giữa máy tính và máy tính. Trong trường hợp này ta có thể sử dụng bất kỳ ngôn ngữ lập trình nào để biểu diễn thuật toán (C, Pascal, Java…).

  * **Ngôn ngữ hình thức**. Ngôn ngữ hình thức là phương tiện giao tiếp trung gian giữa con người và hệ thống máy tính. Ví dụ ngôn ngữ sơ đồ khối, ngôn ngữ tựa tự nhiên, ngôn ngữ đặc tả. Đặc điểm chung của các loại ngôn ngữ hình thức là việc sử dụng nó rất gần gũi với ngôn ngữ tự nhiên, rất gần gũi với ngôn ngữ máy tính. Tuy nhiên, ngôn ngữ hình thức lại không phụ thuộc vào ngôn ngữ tự nhiên, không phụ thuộc vào ngôn ngữ máy tính. Chính vì lý do này, ngôn ngữ hình thức được sử dụng phổ biến trong biểu diễn thuật toán.


Ví dụ dưới đây sẽ minh họa cho các ngôn ngữ biểu diễn thuật toán.


| //Ví dụ 1.3. Biểu diễn thuật toán bằng ngôn ngữ tự nhiênĐầu
vào (Input). Hai số tự nhiên a, b.Đầu ra (Output). Số nguyên u lớn nhất để a và b đều chia hết
cho u.Thuật toán (Euclide Algorithm):Bước 1. Đưa vào hai số tự nhiên a và b.Bước 2. Nếu b 0 thì chuyển đến bước 3, nếu b=0 thì thực
hiện bước 4.Bước 3. Đặt r = a mod b; a = b; b = r ; Quay quay trở lại
bước 2.Bước 4 (Output). Kết luận u=a là số nguyên cần tìm. |
| --- |

 
| //Ví dụ 1.4.Biểu diễn thuật toán bằng ngôn ngữ
máy tính (C++)int USCLN( int a, int b){while ( b != 0
){//lặp trong khi b khác 0r = a % b; //đặt r bằng phần dư của a/b= b; // đặt a bằng b= r; //đặt b bằng r}return(a);//trả lại giá trị a} |
| --- |
| //Ví dụ 1.5.Biểu diễn thuật toán bằng ngôn ngữ
hình thứcThuật toán Euclide:Đầu vào (Input): aN, aN.Đầu ra (Output): s = max { uN : a mod u =0 and b mod u
=0}.Format : s = Euclide (a, b). Actions:while (b0 ) do //lặp trong khi b khác 0r = a mod b; //đặt r bằng a mod b= b; //đổi giá trị của a thành b= r;// đổi giá trị của b thành rendwhile;//kết thúc cấu trúc lặp while return(a);//giá trị trả về
của hàmEndactions. |

 

Một số lưu ý trong khi biểu diễn thuật toán bằng ngôn ngữ hình thức:

  * Khi biểu diễn bằng ngôn ngữ hình thức ta được phép sử dụng cả ngôn ngữ tự nhiên hoặc ngôn ngữ máy tính thông dụng. Mỗi bước thực hiện của thuật toán không cần mô tả quá chi tiết mà chỉ cần mô tả một cách hình thức miễn là đầy đủ thông tin để chuyển đổi thành ngôn ngữ lập trình.

  * Đối với những thuật toán phức tạp nặng nề về tính toán, các công thức cần được mô tả một cách tường minh, có ghi chú rõ ràng.

  * Đối với các thuật toán kinh điển thì ta cần phải thuộc. Không bắt buộc phải chứng minh lại độ phức tạp của các thuật toán kinh điển.


#

# Public_050

# Khái niệm độ phức tạp thuật toán 

Thời gian thực hiện một giải thuật bằng chương trình máy tính phụ thuộc vào các yếu tố:

  * Kích thước dữ liệu đầu vào: một giải thuật hay một chương trình máy tính thực hiện trên tập dữ liệu có kích thước lớn hiển nhiên mất nhiều thời gian hơn thuật toán hoặc chương trình này thực hiện trên tập dữ liệu đầu vào có kích thước nhỏ.

  * Phần cứng của hệ thống máy tính: hệ thống máy tính có tốc độ cao thực hiện nhanh hơn trên hệ thống máy tính có tốc độ thấp.


Tuy nhiên, nếu ta quan niệm thời gian thực hiện của một thuật toán là số các phép toán sơ cấp thực hiện trong thuật toán đó thì phần cứng máy tính không còn là yếu tố ảnh hưởng đến quá trình xác định thời gian thực hiện của một thuật toán. Với quan niệm này, độ phức tạp thời gian thực hiện của một thuật toán chỉ còn phụ thuộc duy nhất vào độ dài dữ liệu đầu vào.

Gọi độ dài dữ liệu đầu vào là _T_ ( _n_ ). Khi đó, số lượng các phép toán sơ cấp để giải bài toán _P_ thực hiện theo thuật toán _F_ = _F_ 1 _F_ 2.. _F_ n trên độ dài dữ liệu _T_ ( _n_ ) là _F_ ( _T_ ( _n_ )). Để xác định số lượng các phép toán sơ cấp _F_ i ( _i_ = _1_ , _2_ , .., _n_ ) thực hiện trong thuật toán _F_ ta cần phải giải bài toán đếm để xác định _F_ ( _T_ ( _n_ )). Đây là bài toán vô cùng khó và không phải lúc nào cũng giải được []. Để đơn giản điều này, người ta thường tìm đến các phương pháp xấp xỉ để tính toán độ phức tạp thời gian của một thuật toán. Điều này có nghĩa, khi ta không thể xây dựng được công thức đếm _F_ ( _T_ ( _n_ )), nhưng ta lại có khẳng định chắc chắn _F_ ( _T_ ( _n_ )) không vượt quá một phiếm hàm biết trước _G_ ( _n_ ) thì ta nói _F_ ( _T_ ( _n_ )) thực hiện nhanh nhất là _G_ ( _n_ ).

**Tổng quát** , _cho hai hàm f_ ( _x_ ) _, g_ ( _x_ ) _xác định trên tập các số nguyên dương hoặc tập các số thực. Hàm f_ ( _x_ ) _được gọi là O_ ( _g_ ( _x_ )) _nếu tồn tại một hằng số C >0 và n0 sao cho:_

| _f_ ( _x_ )| ≤ _C_.| _g_ ( _x_ )| với mọi _x_ ≥ _n_ 0.

Điều này có nghĩa với các giá trị _x_ ≥ _n_ 0 hàm _f_ ( _x_ ) bị chặn trên bởi hằng số _C_ nhân với _g_ ( _x_ ). Nếu _f_ ( _x_ ) là thời gian thực hiện của một thuật toán thì ta nói giải thuật đó có cấp _g_ ( _x_ ) hay độ phức tạp thuật toán _f_ ( _x_ ) là _O_ ( _g_ ( _x_ )).

**Ghi chú**. Các hằng số _C_ , _n_ 0 thỏa mãn điều kiện trên là không duy nhất. Nếu có đồng thời _f_ ( _x_ ) là _O_ ( _g_ ( _x_ )) và _h_ ( _x_ ) thỏa mãn _g_ ( _x_ ) < _h_ ( _x_ ) với _x_ > _n_ 0 thì ta cũng có _f_ ( _x_ ) là _O_ ( _h_ ( _n_ )).

**Ví dụ 1.6**. Cho 𝑓(𝑥) = 𝑎𝑛𝑥𝑛 \+ 𝑎𝑛−1𝑥𝑛−1 \+ ⋯ + 𝑎1𝑥 + 𝑎0; trong đó, _a_ i là các số thực (i =0,1, 2, ..,n). Khi đó _f_ ( _x_ ) = _O_ ( _x_ n).

**Chứng minh**. Thực vậy, với mọi _x_ > _1_ ta có:

|𝑓(𝑥) = |𝑎𝑛𝑥𝑛 \+ 𝑎𝑛−1𝑥𝑛−1 \+ ⋯ + 𝑎1𝑥 + 𝑎0|

≤ |𝑎𝑛|𝑥𝑛 \+ |𝑎𝑛−1|𝑥𝑛−1 \+ ⋯ \+ |𝑎1|𝑥 + |𝑎0|

≤ |𝑎𝑛|𝑥𝑛 \+ |𝑎𝑛−1|𝑥𝑛 \+ ⋯ + |𝑎1|𝑥𝑛 \+ |𝑎0|𝑥𝑛

≤ 𝑥𝑛(|𝑎𝑛| + |𝑎𝑛−1| + ⋯ + |𝑎1| \+ |𝑎0|)

≤ 𝐶. 𝑥𝑛 = 𝑂(𝑥𝑛) . Trong đó, 𝐶 = (|𝑎𝑛| + |𝑎𝑛−1| + ⋯ + |𝑎1| \+ |𝑎0|).

# Một số quy tắc xác định độ phức tạp thuật toán 

Như đã đề cập ở trên, bản chất của việc xác định độ phức tạp thuật toán là giải bài toán đếm số lượng các phép toán sơ cấp thực hiện trong thuật toán đó. Do vậy, tất cả các phương pháp giải bài toán đếm thông thường đều được áp dụng trong khi xác định độ phức tạp thuật toán. Hai nguyên lý cơ bản để giải bài toán đếm là nguyên lý cộng và nguyên lý nhân cũng được mở rộng trong khi ước lượng độ phức tạp thuật toán.

**Nguyên tắc tổng:** Nếu _f_ 1( _x_ ) có độ phức tạp là O( _g_ 1( _x_ )) và _f_ 2( _x_ ) có độ phức tạp là O( _g_ 2( _x_ )) thì độ phức tạp của ( _f_ 1( _x_ ) + f2( _x_ ) là O( _Max_ ( _g_ 1( _x_ ), _g_ 2( _x_ )).

**Chứng minh**. Vì _f_ 1( _x_ ) có độ phức tạp là O( _g_ 1( _x_ ) nên tồn tại hằng số _C_ 1 và _k_ 1 sao cho | _f_ 1( _x_ )|| _g_ 1( _x_ )| với mọi _x_  _k_ 1. Vì _f_ 2( _x_ ) có độ phức tạp là O( _g_ 2( _x_ )) nên tồn tại hằng số _C_ 2 và _k_ 2 sao cho | _f_ 2( _x_ )|| _g_ 2( _x_ )| với mọi _x_  _k_ 2.

Ta lại có :
| _f_ 1( _x_ )+ _f_ 2( _x_ )|  | _f_ 1( _x_ )| + | _f_ 2( _x_ )|

 _C_ 1| _g_ 1( _x_ )| + _C_ 2| _g_ 2( _x_ )|

 _C_ | _g_ ( _x_ )| với mọi _x_ > _k_ ;

Trong đó, _C_ = _C_ 1 \+ _C_ 2; _g_ ( _x_ ) = _max_ ( _g_ 1( _x_ ), _g_ 2( _x_ )); _k_ = _max_ ( _k_ 1, _k_ 2).

**Tổng quát**. Nếu độ phức tạp của _f_ 1( _x_ ), _f_ 2( _x_ ),.., _f_ m( _x_ ) lần lượt là O( _g_ 1( _x_ )), O( _g_ 2( _x_ )),.., O( _g_ n( _x_ )) thì độ phức tạp của _f_ 1( _x_ ) + _f_ 2( _x_ ) \+ ..+ _f_ m( _x_ ) là O( _max_ ( _g_ 1( _x_ ), _g_ 2( _x_ ),.., _g_ m( _x_ )).

**Nguyên tắc nhân:** Nếu _f_ ( _x_ ) có độ phức tạp là O( _g_ ( _x_ ) thì độ phức tạp của _f_ n( _x_ ) là O( _g_ n( _x_ )). Trong đó:

_f_ n( _x_ ) = _f_ ( _x_ ). _f_ ( _x_ )…. _f_ ( _x_ ). //n lần _f_ ( _x_ ). _g_ n( _x_ ) = _g_ ( _x_ ). _g_ ( _x_ )… _g_ ( _x_ ).// _n_ lần _g_ ( _x_ )

**Chứng minh**. Thật vậy theo giả thiết _f_ ( _x_ ) là O( _g_ ( _x_ )) nên tồn tại hằng số _C_ và _k_ sao cho với mọi _x_ > _k_ thì | _f_ ( _x_ )| C.| _g_ ( _x_ ). Ta có:

|𝑓𝑛(𝑥)| = |𝑓1(𝑥). 𝑓2(𝑥) … 𝑓𝑛(𝑥)|

≤ |𝐶. 𝑔1(𝑥). 𝐶. 𝑔2(𝑥) … 𝐶. 𝑔𝑛(𝑥)|

≤ |𝐶𝑛. 𝑔𝑛(𝑥)| = 𝑂(𝑔𝑛(𝑥))

# Một số dạng hàm được dùng xác định độ phức tạp thuật toán 

Như đã đề cập ở trên, để xác định chính xác độ phức tạp thuật toán f(x) là bài toán

khó nên ta thường xấp xỉ độ phức tạp thuật toán với một phiếm hàm O(g(x)). Dưới đây là

một số phiếm hàm của O(g(x)).

**Bảng 1.1. Các dạng hàm xác định độ phức tạp thuật toán**

![](images/image1.jpg)

**Hình 1.1**. _Độ tăng của các hàm theo độ dài dữ liệu_

Dưới đây là một số qui tắc xác định O(g(x)):

  * Nếu một thuật toán có độ phức tạp hằng số thì thời gian thực hiện thuật toán đó không phụ thuộc vào độ dài dữ liệu.

  * Một thuật toán có độ phức tạp logarit của f(n) thì ta viết O(log(n)) mà không cần chỉ rõ cơ số của phép logarit.

  * Với P(n) là một đa thức bậc k thì O(P(n)) = O(nk).

  * Thuật toán có độ phức tạp đa thức hoặc nhỏ hơn được xem là những thuật toán thực tế có thể thực hiện được bằng máy tính. Các thuật toán có độ phức tạp hàm mũ, hàm giai thừa được xem là những thuật toán thực tế không giải được bằng máy tính.


# Độ phức tạp của các cấu trúc lệnh 

Để đánh giá độ phức tạp của một thuật toán đã được mã hóa thành chương trình máy tính ta thực hiện theo một số qui tắc sau.

**Độ phức tạp hằng số O(1):** đoạn chương trình không chứa vòng lặp hoặc lời gọi đệ qui có tham biến là một hằng số.

**Ví dụ 1.7**. Đoạn chương trình dưới đây có độ phức tạp hằng số. _for_ ( _i=1; i <=c; i++_) {

_< Tập các chỉ thị có độ phức tạp O(1)>;_

}

**Độ phức tạp O(n)** : Độ phức tạp của hàm hoặc đoạn code là O(n) nếu biến trong vòng lặp tăng hoặc giảm bởi mộ hằng số c.

**Ví dụ 1.8**. Đoạn code dưới đây có độ phức tạp hằng số. for (i=1; i<=n; i = i + c ) {

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

for (i=n; i>0; i = i - c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

**Độ phức tạp đa thức O(n** c **):** Độ phức tạp của _c_ vòng lặp lồng nhau, mỗi vòng lặp đều có độ phức tạp O(n) là **O(n** c **).**

**Ví dụ 1.9**. Đoạn code dưới đây có độ phức tạp O(n2).

for (i=1; i<=n; i = i + c ) { for (j=1; j<=n; j = j + c){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

}

for (i = n; i >0 ; i = i - c ) { for (j = i- 1; j>1; j = j -c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

} }

**Độ phức tạp logarit O(Log(n))** : Độ phức tạp của vòng lặp là log(n) nếu biểu thức khởi đầu lại của vòng lặp được chia hoặc nhân với một hằng số c.

**Ví dụ 1.10**. Đoạn code dưới đây có độ phức tạp Log(n). for (i=1; i <=n; i = i *c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

for (j=n; j >0 ; j = j / c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

**Độ phức tạp hằng số O(Log (Log(n))):** nếu biểu thức khởi đầu lại của vòng lặp được nhân hoặc chia cho một hàm mũ.

**Ví dụ 1.11**. Đoạn code dưới đây có độ phức tạp Log Log(n). for (i=1; j<=n; j*= Pow(i, c) ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

for (j=n; j>=0; j = j- Function(j) ){ //Function(j) =sqrt(j) hoặc lớn hơn 2.

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

**Độ phức tạp của chương trình** : độ phức tạp của một chương trình bằng số lần thực hiện một chỉ thị tích cực trong chương trình đó. Trong đó, một chỉ thị được gọi là tích cực trong chương trình nếu chỉ thị đó phụ thuộc vào độ dài dữ liệu và thực hiện không ít hơn bất kỳ một chỉ thị nào khác trong chương trình.

**Ví dụ 1.12**. Tìm độ phức tạp thuật toán sắp xếp kiểu Bubble-Sort? Void Bubble-Sort ( int A[], int n ) {

for ( i=1; i<n; i++) { for ( j = i+1; j<=n; j++){ if (A[i] > A[j]) {// _đây chính là chỉ thị tích cực_ t = A[i]; A[i] = A[j]; A[j] = t;

}

}

}

}

**Lời giả** i. Sử dụng trực tiếp nguyên lý cộng ta có:

  * Với i =1 ta cần sử dụng n-1 phép so sánh A[i] với A[j];

  * Với i = 2 ta cần sử dụng n-2 phép so sánh A[i] với A[j];

  * . . . . .

  * Với i = n-1 ta cần sử dụng 1 phép so sánh A[i] với A[j]; Vì vậy tổng số các phép toán cần thực hiện là:


S = (n-1) + (n-2) + . . . + 2 + 1 = n(n-1)/2 n2 = O(n2).

**Ghi chú**. Độ phức tạp thuật toán cũng là số lần thực hiện phép toán tích cực. Phép toán tích cực là phép toán thực hiện nhiều nhất đối với thuật toán.

# Quy trình giải quyết bài toán trên máy tính 

Để giải quyết một bài toán hoặc vấn đề trong tin học ta thực hiện thông qua 6 bước như sau:

**Bước 1. Xác định yêu cầu bài toán.** Xem xét bài toán cần xử lý vấn đề gì? Giả thiết nào đã được biết trước và lời giải cần đạt những yêu cầu gì? Ví dụ thời gian, hay không gian nhớ.

**Bước 2. Tìm cấu trúc dữ liệu thích hợp biểu diễn các đối tượng cần xử lý của bài toán.** Cấu trúc dữ liệu phải biểu diễn đầy đủ các đối tượng thông tin vào của bài toán. Các thao tác trên cấu trúc dữ liệu phải phù hợp với những thao tác của thuật toán được lựa chọn. Cấu trúc dữ liệu phải cài đặt được bằng ngôn ngữ lập trình cụ thể đáp ứng yêu cầu bài toán.

**Bước 3. Lựa chọn thuật toán.** Thuật toán phải đáp ứng được yêu của bài toán và phù hợp với cấu trúc dữ liệu đã được lựa chọn Bước 1.

**Bước 4. Cài đặt thuật toán.** Thuật toán cần được cài đặt bằng một ngôn ngữ lập trình cụ thể. Ngôn ngữ lập trình sử dụng phải có các cấu trúc dữ liệu đã lựa chọn.

**Bước 5. Kiểm thử chương trình.** Thử nghiệm thuật toán (chương trình) trên các bộ dữ liệu thực. Các bộ dữ liệu cần phải bao phủ lên tất cả các trường hợp của thuật toán.

**Bước 6. Tối ưu chương trìn** h: Cải tiến để chương trình tốt hơn.

.

# Public_051

Nội dung chính của chương trình bày một số lược đồ thuật toán kinh điển dùng để giải lớp các bài toán liệt kê, bài toán đếm, và bài toán tối ưu và bài toán tồn tại. Mỗi lược đồ thuật toán giải quyết một lớp các bài toán thỏa mãn một số tính chất nào đó. Đây là những lược đồ thuật toán quan trọng nhằm giúp người học vận dụng nó trong khi giải quyết các vấn đề trong tin học. Các lược đồ thuật toán được trình bày trong chương này bao gồm: thuật toán sinh, thuật toán đệ qui, thuật toán quay lui, thuật toán tham lam, thuật toán nhánh cận, thuật toán qui hoạch động.

# Mô hình thuật toán sinh (Generative Algorithm) 

Mô hình thuật toán sinh được dùng để giải lớp các bài toán liệt kê, bài toán đếm, bài toán tối ưu, bài toán tồn tại thỏa mãn hai điều kiện:

  * **Điều kiện 1:** _Có thể xác định được một thứ tự trên tập các cấu hình cần liệt kê của bài toán. Biết cấu hình đầu tiên, biết cấu hình cuối cùng._

  * **Điều kiện 2:** _Từ một cấu hình chưa phải cuối cùng, ta xây dựng được thuật toán sinh ra cấu hình đứng ngay sau nó._


Mô hình thuật toán sinh được biểu diễn thành hai bước: bước khởi tạo và bước lặp. Tại bước khởi tạo, cấu hình đầu tiên của bài toán sẽ được thiết lập. Điều này bao giờ cũng thực hiện được theo giả thiết của bài toán. Tại bước lặp, quá trình lặp được thực hiện khi gặp phải cấu hình cuối cùng. Điều kiện lặp của bài toán bao giờ cũng tồn tại theo giả thiết của bài toán. Hai chỉ thị cần thực hiện trong thân vòng lặp là đưa ra cấu hình hiện tại và sinh ra cấu hình kế tiếp. Mô hình sinh kế tiếp được thực hiện tùy thuộc vào mỗi bài toán cụ thể. Tổng quát, mô hình thuật toán sinh được thể hiện như dưới đây.

**Thuật toán Generation;**
**begin**
**Bước1 (Khởi tạo):**

_< Thiết lập cấu hình đầu tiên>;_

**Bước 2 (Bước lặp):**

**while** ( _< Lặp khi cấu hình chưa phải cuối cùng>_) **do**

_< Đưa ra cấu hình hiện tại>;_

_< Sinh ra cấu hình kế tiếp>;_ **endwhile** ;

**End**.

**Ví dụ 2.1**. Vector _X_ = ( _x_ 1, _x_ 2, .., _x_ n), trong đó _x_ i = 0, 1 được gọi là một xâu nhị phân có độ dài _n_. Hãy liệt kê các xâu nhị phân có độ dài _n_. Ví dụ với n=4, ta sẽ liệt kê được 24 xâu nhị phân độ dài 4 như trong Bảng 2.1.

**Bảng 2.1**. Các xâu nhị phân độ dài 4


| STT | X=(x1,x2,x3,x4) | STT | X=(x1,x2,x3,x4) |
| --- | --- | --- | --- |
| 0 | 0 0 0 0 | 8 | 1 0 0 0 |
| 1 | 0 0 0 1 | 9 | 1 0 0 1 |
| 2 | 0 0 1 0 | 10 | 1 0 1 0 |
| 3 | 0 0 1 1 | 11 | 1 0 1 1 |
| 4 | 0 1 0 0 | 12 | 1 1 0 0 |
| 5 | 0 1 0 1 | 13 | 1 1 0 1 |
| 6 | 0 1 1 0 | 14 | 1 1 1 0 |
| 7 | 0 1 1 1 | 15 | 1 1 1 1 |

 

**Lời giải:**

**Điều kiện 1** : Gọi thứ tự của xâu nhị phân _X_ =( _x_ 1, _x_ 2,.., _x_ n) là _f_ ( _X_ ). Trong đó, _f_ (X)= _k_ là số chuyển đồi xâu nhị _X_ thành số ở hệ cơ số 10. Ví dụ, xâu _X_ = (1, 0, 1, 1) được chuyển thành số hệ cơ số 10 là 11 thì ta nói xâu _X_ có thứ tự 11. Với cách quan niệm này, xâu đứng sau xâu có thứ tự 11 là 12 chính là xâu đứng ngay sau xâu _X_ = (1, 0, 1, 1). Xâu đầu tiên có thứ tự là _0_ ứng với xâu có _n_ số _0_. Xâu cuối cùng có thứ tự là _2_ n- _1_ ứng với xâu có _n_ số _1_. Như vậy, điều kiện 1 của thuật toán sinh đã được thỏa mãn.

**Điều kiện 2** : Về nguyên tắc ta có thể lấy _k_ = _f_ ( _X_ ) là thứ tự của một xâu bất kỳ theo nguyên tắc ở trên, sau đó lấy thứ tự của xâu kế tiếp là ( _k_ \+ _1_ ) và chuyển đổi ( _k_ + _1_ ) thành số ở hệ cơ số 10 ta sẽ được xâu nhị phân tiếp theo. Xâu cuối cùng sẽ là xâu có n số 1 ứng với thứ tự _k_ = _2_ n- _1._ Với cách làm này, ta có thể coi mỗi xâu nhị phân là một số, mỗi thành phần của xâu là một bít và chỉ cần cài đặt thuật toán chuyển đổi cơ số ở hệ 10 thành số ở hệ nhị phân. Ta có thể xây dựng thuật toán tổng quát hơn bằng cách xem mỗi xâu nhị phân là một mảng các phần tử có giá trị 0 hoặc 1. Sau đó, duyệt từ vị trí bên phải nhất của xâu nếu gặp số 1 ta chuyển thành 0 và gặp số 0 đầu tiên ta chuyển thành 1. Ví dụ với xâu X = (0, 1, 1, 1) được chuyển thành xâu X= (1, 0, 0, 0), xâu X = (1,0,0,0) được chuyển thành xâu X =(1, 0, 0, 1). Lời giải và thuật toán sinh xâu nhị phân kế tiếp được thể hiện trong chương trình dưới đây. Trong đó, thuật toán sinh xâu nhị phân kế tiếp từ một xâu nhị phân bất kỳ là hàm _Next_Bits_String_ ().

#include <iostream>
#include <iomanip> #define MAX 100 using namespace std; int X[MAX], n, dem = 0; // _sử dụng các biến toàn cục X[], n, OK, dem_ bool OK =true; void Init(void){ // _khởi tạo xâu nhị phân đầu tiên_

cout<<"Nhập n="; cin>>n;

for(int i = 1; i<=n; i++) // _thiết lập xâu với n số 0_

X[i]=0;

} void Result(void){ // _đưa ra xâu nhị phân hiện tại_ cout<<"\n Xâu thứ "<<++dem<<":";

for(int i=1; i<=n; i++)

cout<<X[i]<<setw(3);

} void Next_Bits_String(void){ // _thuật toán sinh xâu nhị phân kế tiếp_ int i=n;

while(i>0 && X[i]){ // _duyệt từ vị trí bên phải nhất_

X[i]=0; // _nếu gặp X[i] = 1 ta chuyển thành 0_

i--; // _lùi lại vị trí sau_

}

if (i>0) X[i]=1; // _gặp X[i] =0 đầu tiên ta chuyển thành 1_ else OK = false; // _kết thúc khi gặp xâu có n số 1_
}
int main(void){ // _đây là thuật toán sinh_ Init(); // _thiết lập cấu hình đầu tiên_ while(OK){// _lặp khi chưa phải cấu hình cuối cùng_ Result(); // _đưa ra cấu hình hiện tại_

Next_Bits_String(); // _sinh ra cấu hình kế tiếp_

}

}

**Ví dụ 2.2**. Liệt kê các tập con k phần tử của 1, 2, .., n.

**Lời giải.** Mỗi tập con k phần tử của 1, 2, .., N là một tổ hợp chập K của 1, 2,.., N. Ví dụ với n=5, k= 3 ta sẽ có C(n,k) tập con trong Bảng 2.2.

**Điều kiện 1**. Ta gọi tập con X =( _x_ 1,.. _x_ K) là đứng trước tập con Y =( _y_ 1, _y_ 2,.. _y_ K) nếu tìm được chỉ số t sao cho _x_ 1 = _y_ 1, _x_ 2 = _y_ 2,.., _x_ t-1 = _y_ t-1, _x_ t < _y_ t. Ví dụ tập con _X_ = ( _1, 2, 3_ ) đứng trước tập con _Y_ =( _1, 2, 4_ ) vì ta tìm được t=3 thỏa mãn _x_ 1 = _y_ 1, _x_ 2 = _y_ 2, _x_ 3<y3. Tập con đầu tiên là _X_ = (1 _, 2,.., k_ ), tập con cuối cùng là ( _n–k+1,.., N_ ). Như vậy điều kiện 1 của thuật toán sinh được thỏa mãn.

**Điều kiện 2**. Để ý rằng, tập con cuối cùng (n-k+1,..., n) luôn thỏa mãn đẳng thức X[i] = n – k + i. Ví dụ tập con cuối cùng X[] = (3, 4, 5) ta đều có: X[1] = 3 = 5 – 3 + 1; X[2] = 4 = 5 – 3 + 2; X[3] = 5 = 5 – 3 + 3. Để tìm tập con kế tiếp từ tập con bất kỳ ta chỉ cần duyệt từ phải qua trái tập con X[] = (x1, x2, .., xk) để xác định chỉ số i thỏa mãn điều kiện X[i] n – k + i. Ví dụ với X[] = (1, 4, 5), ta xác định được i=1 vì X[3] = 5 = 5-3+3, X[2] = 4 = 5-3+2, và X[1] = 1 5-3+1. Sau khi xác định được chỉ số i, tập con mới sẽ được sinh là Y[] = (y1,.., yi, ..., yk) ra thỏa mãn điều kiện: y1 = x1, y2 = x2,.., yi-1 = xi-1, yi = xi+1, và yj = xt + j – i với (j = j+1, ..., k).

**Bảng 2.2**. Tập con 3 phần tử của 1, 2, 3, 4, 5


| STT | Tập con |
| --- | --- |
| 1 | 1 2 3 |
| 2 | 1 2 4 |
| 3 | 1 2 5 |
| 4 | 1 3 4 |
| 5 | 1 3 5 |
| 6 | 1 4 5 |
| 7 | 2 3 4 |
| 8 | 2 3 5 |
| 9 | 2 4 5 |
| 10 | 3 4 5 |

 

Chương trình cài đặt thuật toán sinh tập con k phần tử được thể hiện như dưới đây.

Trong đó, thuật toán sinh tổ hợp kế tiếp có tên là Next_Combination().

#include <iostream>
#include <iomanip>  
#define MAX 100  
int X[MAX], n, k, dem=0;  
bool OK = true;  
using namespace std;
void Init(void){ //thiết lập tập con đầu tiên
cout<<"\n Nhập n, k:"; cin>>n>>k;
for(int i=1; i<=k; i++) //tập con đầu tiên là 1, 2, .., k
X[i] = i;

}

void Result(void){ // _đưa ra tập con hiện tại_ cout<<"\n Kết quả "<<++dem<<":";

for(int i=1; i<=k; i++) // _đưa ra_ _X_ [] _=_ ( _x_ 1 _, x_ 2 _, .., x_ k)

cout<<X[i]<<setw(3);

}
void Next_Combination(void){ // _sinh tập con k phần tử từ tập con bất kỳ_

int i = k; // _duyệt từ vị trí bên phải nhất của tập con_ while(i>0 && X[i]== n-k+i) // _tìm i sao cho x i n-k+i_

i--;

if (i>0){// _nếu chưa phải là tập con cuối cùng_

X[i]= X[i]+1; // _thay đổi giá trị tại vị trí i: x i = xi +_1 _;_ for(int j=i+1; j<=k; j++) // _các vị trí j từ i+1,.., k_ X[j] = X[i] + j - i; // được thay đổi là _x j = xi +j - i;_

}

else // _nếu là tập con cuối cùng_

OK = false; / _/ta kết thúc duyệt_
}

int main(void){

Init(); // _khởi tạo cấu hình đầu tiên_

while(OK){ // _lặp trong khi cấu hình chưa phải cuối cùng_ Result(); // _đưa ra cấu hình hiện tại_

Next_Combination(); // _sinh ra cấu hình kế tiếp_

}

}

**Ví dụ 2.3**. Liệt kê các hoán vị của 1, 2, .., n.

**Lời giải.** Mỗi hoán vị của 1, 2, .., N là một cách xếp có tính đến thứ tự của 1, 2,..,N. Số các hoán vị là N!. Ví dụ với N =3 ta có 6 hoán vị dưới đây.

**Bảng 2.3**. Hoán vị của 1, 2, 3.


| STT | Hoán vị |
| --- | --- |
| 1 | 1 2 3 |
| 2 | 1 3 2 |
| 3 | 2 1 3 |
| 4 | 2 3 1 |
| 5 | 3 1 2 |
| 6 | 3 2 1 |

 

**Điều kiện 1.** Có thể xác định được nhiều trật tự khác nhau trên các hoán vị. Tuy nhiên, thứ tự đơn giản nhất có thể được xác định như sau. Hoán vị X =(x1, x2,.., xn) được gọi là đứng sau hoán vị Y = (y1, y2,..,yn) nếu tồn tại chỉ số k sao cho x1 = y1, x2 = y2,…, xk-1 =yk-1, xk<yk. Ví dụ hoán vị X = (1, 2, 3 ) được gọi là đứng sau hoán vị Y =(1, 3, 2) vì tồn tại k =2 để x1 = y1, và x2<y2. Hoán vị đầu tiên là X[] = (1, 2, …, n), hoán vị cuối cùng là X[] = (n, n-1, …, 1).

**Điều kiện 2**. Được thể hiện thông qua hàm Next_Permutation() như chương trình dưới đây.

#include <iostream>
#include <iomanip> #define MAX 100 int X[MAX], n, dem=0; bool OK = true; using namespace std; void Init(void){ // _thiết lập hoán vị đầu tiên_ cout<<"\n Nhap n:"; cin>>n;

for(int i=1; i<=n; i++) // _thiết lập X_ [] _=_ ( _1, 2, ..,n_ )

X[i] = i;

} void Result(void){ // _đưa ra hoán vị hiện tại_ cout<<"\n Kết quả "<<++dem<<":";

for(int i=1; i<=n; i++)

cout<<X[i]<<setw(3);

}
void Next_Permutation(void){ // _sinh ra hoán vị kế tiếp_ int j = n-1; // _xuất phát từ vị trí j = n-1_
while(j>0 && X[j]>X[j+1]) // _tìm chỉ số j sao cho X[j] < X[j+1]_ j--;
if ( j > 0){ // _nếu chưa phải hoán vị cuối cùng_ int k = n; // _xuất phát từ vị trí k = n_

while(X[j]>X[k]) // _tìm chỉ số k sao cho X[j] < X[k]_

k--;

int t = X[j]; X[j] = X[k]; X[k]=t; // _đổi chỗ X[j] cho X[k]_ int r = j+1, s = n; while (r<=s){ // _lật ngược lại đoạn từ j+1,..,n_ t=X[r]; X[r]=X[s]; X[s]=t;

r++; s--;

}

}

else // _nếu là cấu hình cuối cùng_

OK = false; // _ta kết thúc duyệt_
}
int main(void){ // _đây là thuật toán sinh_ Init(); // _thiết lập cấu hình đầu tiên_
while(OK){ // _lặp trong khi cấu hình chưa phải cuối cùng_ Result(); // _đưa ra cấu hình hiện tại_

Next_Permutation(); // _sinh ra cấu hình kế tiếp_

}

}

# Mô hình thuật toán đệ qui (Recursion Algorithm) 

Một đối tượng được định nghĩa trực tiếp hoặc gián tiếp thông qua chính nó được gọi là phép định nghĩa bằng đệ qui. Thuật toán giải bài toán _P_ một cách trực tiếp hoặc gián tiếp thông qua bài toán _P_ ’ giống như _P_ được gọi là thuật toán đệ qui giải bài toán _P_. Một hàm được gọi là đệ qui nếu nó được gọi trực tiếp hoặc gián tiếp đến chính nó.

Tổng quát, một bài toán có thể giải được bằng đệ qui nếu nó thỏa mãn hai điều kiện:

  * **Phân tích được** _: Có thể giải được bài toán P bằng bài toán P’ giống như P. Bài tóa P’ và chỉ khác P ở dữ liệu đầu vào. Việc giải bài toán P’ cũng được thực hiện theo cách phân tích giống như P._

  * **Điều kiện dừng** _: Dãy các bài toán P’ giống như P là hữu hạn và sẽ dừng tại một bài toán xác định nào đó._


Thuật toán đệ qui tổng quát có thể được mô tả như sau:

_Thuật toán Recursion ( P )_ {

  1. _Nếu P thỏa mãn điều kiện dừng:_


< _Giải P với điều kiện dừng_ >;

  2. Nếu _P_ không thỏa mãn điều kiện dừng:


_< Giải P’ giống như P:Recursion(P’)>;_

}

**Ví dụ 2.4**. Tìm tổng của n số tự nhiên đầu tiên bằng phương pháp đệ qui.

**Lời giải**. Gọi Sn là tổng của n số tự nhiên. Khi đó:

  * **Bước phân tích** : dễ dàng phận thấy tổng n số tự nhiên Sn = n + Sn-1, với n1. • **Điều kiện dừng** : S0 = 0 nếu n = 0;


Từ đó ta có lời giải của bài toán như sau:

int Tong (int n ) {

if (n ==0 ) return(0); // _Điều kiện dừng_

else return(n + Tong(n-1)); // _Điều kiện phân tích được_

}

Chẳng hạn ta cần tìm tổng của 5 số tự nhiên đầu tiên, khi đó:

S = Tong(5)

= 5 + Tong(4)

= 5 + 4 + Tong(3)

= 5 + 4 + 3 + Tong(2)

= 5 + 4 + 3 + 2+ Tong(1)

= 5 + 4 + 3 + 2 + 1 + Tong(0)

= 5 + 4 + 3 + 2 + 1 + 0

= 15

**Ví dụ 2.5**. Tìm n!.

**Lời giải**. Gọi Sn là n!. Khi đó:

  * **Bước phân tích** : Sn = n*(n-1)! nếu n>0;

  * **Điều kiện dừng** : s0=1 nếu n=0.


Từ đó ta có lời giải của bài toán như sau:
long Giaithua (int n ) {

if (n ==0 ) return(1); // _Điều kiện dừng_

else return(n *Giaithua(n-1)); // _Điều kiện phân tích được_

} **Ví dụ 2.6.** Tìm ước số chung lớn nhất của a và b bằng phương pháp đệ qui.

**Lời giải**. Gọi d =USCLN(a,b). Khi đó:

  * **Bước phân tích** : nếu b0 thì d = USCLN(a, b) = USCLN(b, r), trong đó a =b, b = r = a mod b .

  * **Điều kiện dừng** : nếu b = 0 thì a là ước số chung lớn nhất của a và b. Từ đó ta có lời giải của bài toán như sau: int USCLN (int a, int b ) { if (a ==b ) return(a); // _Điều kiện dừng_ else { // _Điều kiện phân tích được_ int r = a % b; a = b; b = r; return(USCLN(a, b)); // _giải bài toán USCLN(a, b)_


}

}

# Public_052

# Mô hình thuật toán quay lui (Backtrack Algorithm)

Giả sử ta cần xác định bộ _X_ =( _x_ 1, _x_ 2,.., _x_ n) thỏa mãn một số ràng buộc nào đó. Ứng với mỗi thành phần _x_ i ta có _n_ i khả năng cần lựa chọn. Ứng với mỗi khả năng _j∈ni_ dành cho thành phần xi ta cần thực hiện:

  * _Kiểm tra xem khả năng j có được chấp thuận cho thành phần xi hay không? Nếu khả năng j được chấp thuận thì ta xác định thành phần xi theo khả năng j. Nếu i là thành phần cuối cùng (i=n) ta ghi nhận nghiệm của bài toán. Nếu i chưa phải cuối cùng ta xác định thành phần thứ i +1._

  * _Nếu không có khả năng j nào được chấp thuận cho thành phần xi thì ta quay lại bước trước đó (i-1) để thử lại các khả năng còn lại._


Thuật toán quay lui được mô tả như sau:
Thuật toán Back-Track ( int i ) {
for ( j =<Khả năng 1>; j <=ni; j++ ){ if (<chấp thuận khả năng j>) {
X[i] = <khả năng j>; if ( i ==n) Result(); else Back-Track(i+1);
}
}
**Ví dụ 2.7**. Duyệt các xâu nhị phân có độ dài n.
**Lời giải**. Xâu nhị phân _X_ = ( _x_ 1, _x_ 2,.., _x_ n)| xi =0, 1. Mỗi _x_ i∈X có hai lựa chọn xi=0, 1. Cả hai giá trị này đều được chấp thuận mà không cần có thêm bất kỳ điều kiện gì. Thuật toán được mô tả như sau:
void Try ( int i ) {
for (int j =0; j<=1; j++){ X[i] = j;
if (i ==n) Result(); else Try (i+1);
}
}
Khi đó, việc duyệt các xâu nhị phân có độ dài n ta chỉ cần gọi đến thủ tục Try(1). Cây quay lui được mô tả như Hình 2.1 dưới đây.
![](images/image1.png)
**Hình 2.1**. _Duyệt các xâu nhị phân độ dài 3_
Chương trình duyệt các xâu nhị phân có độ dài n bằng thuật toán quay lui được thể hiện như dưới đây.
#include <iostream> #include <iomanip> #define MAX 100 using namespace std; int X[MAX], n, dem=0;
void Init(){ // _thiết lập độ dài xâu nhị phân  
_cout<<"\n Nhập n="; cin>>n;
}
void Result(void){ // _In ra xâu nhị phân X[] = x_ 1 _, x_ 2 _,.., x_ n
cout<<"\n Kết quả "<<++dem<<":"; for(int i =1; i<=n; i++)
cout<<X[i]<<setw(3);
}
void Try(int i){ // _thuật toán quay lui_
for (int j=0; j<=1; j++){ // _duyệt các khả năng j dành cho x_ i
X[i]=j; // _thiết lập thành phần x_ i _là j_
if(i==n) // _nếu i là thành phần cuối cùng_
Result(); // _ta đưa ra kết quả_
else // _trong trường hợp khác_
Try(i+1); // _ta xác định tiếp thành phần x_ i+1
}
}
int main(void){ Init(); Try(1);}

**Ví dụ 2**. **8.** Duyệt các tập con K phần tử của 1, 2, .., N.

**Lời giải**. Mỗi tập con K phần tử _X_ = ( _x_ 1, _x_ 2,.., _x_ K) là bộ không tính đến thứ tự K phần tử của 1, 2, .., N. Mỗi _x_ i∈X có N-K+i lựa chọn. Các giá trị này đều được chấp thuận mà không cần có thêm bất kỳ điều kiện gì. Thuật toán được mô tả như sau:
void Try ( int i ) {
for (int j =X[i-1]+1; j<=N-K+ i; j++){ X[i] = j;
if (i ==K) Result(); else Try (i+1);
}
}
Khi đó, việc duyệt các tập con K phần tử của 1, 2, .., N ta chỉ cần gọi đến thủ tục Try(1). Cây quay lui được mô tả như hình dưới đây.
![](images/image2.png)
**Hình 2.2**. _Duyệt các tập con 3 phần tử của 1, 2, 3, 4, 5._
Chương trình liệt kê các tập con k phần tử của 1, 2, ..,n được thể hiện như sau. #include <iostream>
#include <iomanip> #define MAX 100 using namespace std;
int X[MAX], n, k, dem=0;
void Init(){// _thiết lập giá trị cho n, k_
cout<<"\n Nhập n, k: "; cin>>n>>k;
}
void Result(void){ cout<<"\n Kết quả "<<++dem<<":";// _đưa ra kết quả_
for(int i =1; i<=k; i++) cout<<X[i]<<setw(3);
}
void Try(int i){// _thuật toán quay lui_
for (int j=X[i-1]+1; j<=n-k+i; j++){ // _duyệt trên tập khả năng dành cho x_ i
X[i]=j; // _thiết lập thành phần xi là j_
if(i==k) // _nếu x_ i _đã là thành phần cuối_
Result(); // _ta đưa ra kết quả_
else // _trong trường hợp khác_
Try(i+1); // _ta đi xác định thành phần thứ x_ i+1
}
}
int main(void){
Init(); X[0] =0 ; Try(1);
}
**Ví dụ 2.9**. Duyệt các hoán vị của 1, 2, .., N.
**Lời giải**. Mỗi hoán vị _X_ = ( _x_ 1, _x_ 2,.., _x_ K) là bộ có tính đến thứ tự của 1, 2, .., N. Mỗi _x_ i∈X có N lựa chọn. Khi xi = j được lựa chọn thì giá trị này sẽ không được chấp thuận cho các thành phần còn lại. Để ghi nhận điều này, ta sử dụng mảng chuaxet[] gồm N phần tử. Nếu chuaxet[i] = True điều đó có nghĩa giá trị i được chấp thuận và chuaxet[i] = False tương ứng với giá trị i không được phép sử dụng. Thuật toán được mô tả như sau:
void Try ( int i ) {
for (int j=1; j<=N; j++){ if (chuaxet[j] ) {
X[i] = j;chuaxet[j] = False; if ( i ==N) Result();
else Try (i+1); Chuaxet[j] = True;
}
}
}
Khi đó, việc duyệt các hoán vị của 1, 2, .., N ta chỉ cần gọi đến thủ tục Try(1). Cây quay lui được mô tả như hình dưới đây.
![](images/image3.png)
**Hình 2.3**. Duyệt các hoán vị của 1, 2, 3.

Chương trình liệt kê tất cả các hoán vị của 1, 2, .., n được thể hiện như sau: |  
#include <iostream>

#include <iomanip> #define MAX 100  
using namespace std;  
int X[MAX], n, dem=0; bool chuaxet[MAX];
void Init(){// _thiết lập giá trị cho n_
cout<<"\n Nhập n="; cin>>n;
for(int i=1; i<=n; i++) // _thiết lập giá trị cho mảng chuaxet[]_
chuaxet[i]=true;
}
void Result(void){ // _Đưa ra hoán vị hiện tại_
cout<<"\n Kết quả "<<++dem<<":";
for(int i =1; i<=n; i++) cout<<X[i]<<setw(3);
}
void Try(int i){ // _thuật toán quay lui duyệt các hoán vị của 1, 2, .., n._
for (int j=1; j<=n; j++){ // _duyệt các khả năng j cho thành phần xi_
if(chuaxet[j]){ // _nếu khả năng j đúng chưa được dùng đến_ X[i]=j; // _thiết lập thành phần xi là j  
_chuaxet[j]=false; // _thiết lập chuaxet[j] đã được dùng_ if(i==n) // _nếu xi đã là thành phần cuối cùng_
Result();// _ta đưa ra kết quả_
else /// _trong trường hợp khác_
Try(i+1); // _ta xác định tiếp thành phần thứ i+1_
chuaxet[j]=true; // _nhớ hoàn trả lại giá trị cho chuaxet[j]_
}
}
}
int main(void){
Init(); Try(1);
}
**Ví dụ 2.10**. Bài toán N quân hậu. Trên bàn cờ kích cỡ N×N, hãy đặt N quân hậu mỗi quân trên 1 hàng sao cho tất cả các quân hậu đều không ăn được lẫn nhau.
**Lời giải**. Gọi X =(x1, x2,..,xn) là một hoán vị của 1, 2, .., n.. Khi đó, xi = j được hiểu là quân hậu hàng thứ i đặt ở cột j. Để các quân hậu khác không thể ăn được, quân hậu thứ i cần không được lấy trùng với bất kỳ cột nào, không được cùng đường chéo xuôi, không được cùng trên đường chéo ngược. Ta có n cột Cot = (c1,..cn), có Xuoi[2*n-1] đường chéo xuôi, Nguoc[2*n-1] đường chéo ngược. Quân hậu ở hàng _i_ được đặt vào cột _j_ nếu A[j] = True (chưa có quân hậu nào án ngữ cột j), Xuoi[i-j+n] = True (chưa có quân hậu nào án ngữ đường chéo i-j+n), Nguoc[i + j -1] = True (chưa có quân hậu nào án ngữ đường chéo ngược i + j-1).
Đường chéo xuôi Xuoi[i-j+n] Đường chéo ngược Nguoc[i+j-1]![](images/image4.png)
**Hình 2.4**. _Mô tả các đường chéo, xuôi đường chéo ngược_
Thuật toán quay lui giải bài toán n quân hậu được mô tả như dưới đây. void Try (int i){
for(int j=1; j<=n; j++){
if( Cot[j] && Xuoi[ i – j + n ] && Nguoc[i + j -1]){ X[i] =j; Cot[j]=FALSE;
Xuoi[ i - j + n]=FALSE; Nguoc[ i + j - 1]=FALSE; if(i==n) Result();
else Try(i+1); Cot[j] = TRUE;
Xuoi[ i - j + n] = TRUE; Nguoc[ i + j - 1] = TRUE;
}
}
}
Chương trình giải bài toán n quân hậu được thể hiện như dưới đây. #include <iostream>
#include <iomanip> #define MAX 100  
using namespace std;  
int X[MAX], n, dem=0;
bool COT[MAX], DCXUOI[MAX], DCNGUOC[MAX];;

void Init(){ // _thiết lập kích cỡ bàn cờ_

cout<<"\n Nhap n="; cin>>n;

for(int i=1; i<=n; i++){ // _thiết lập tất cả các cột đều chưa bị án ngữ_
COT[i]=true;
}
for(int i=1; i<2*n; i++){ // _thiết lập các đường chéo_ DCXUOI[i]=true; // _đường chéo xuôi chưa bị án ngữ_ DCNGUOC[i]=true; // _đường chéo ngược chưa bị án ngữ_
}
}
void Result(void){ // _đưa ra một phương án_ cout<<"\n Kết quả "<<++dem<<":"; for(int i =1; i<=n; i++)
cout<<X[i]<<setw(3);
}
void Try(int i){ // _đây là thuật toán quay lui_
for (int j=1; j<=n; j++){ // _duyệt các khả năng j đặt quân hậu vào hàng i_
if( COT[j] && DCXUOI[i-j+n]&& DCNGUOC[i+j-1]){
// _nếu đúng cột j, đường chéo xuôi i-j +n, đường chéo ngược i+j-1_
_// chưa bị án ngữ_
X[i]=j; // _ta đặt được quân hậu hàng i vào vột j_
COT[j] = false; // _cột j đã bị án ngữ_
DCXUOI[i-j+n]=false; // _đường chéo xuôi i-j+n bị án ngữ_ DCNGUOC[i+j-1]=false;// _đường chéo ngược i+j-1 bị án ngữ_ if(i==n) // _nếu đây là quân hậu hàng n_
Result();// _ta đưa ra phương án hiện tại_
else // _trong trường hợp khác_
Try(i+1); // _ta đặt tiếp quân hậu hành i+1_
COT[j] = true; // _nhớ trả lại giá trị cột j_
DCXUOI[i-j+n]=true; // _trả lại giá trị đường chéo xuôi_
DCNGUOC[i+j-1]=true; // _trả lại giá trị đường chéo ngược_
}
}
}
int main(void){ Init(); Try(1); }

# Public_053

Một trong những vấn đề quan trọng bậc nhất của khoa học máy tính là tìm kiếm thông tin. Có thể nói, hầu hết các hoạt động của người dùng hoặc các ứng dụng tin học đều liên quan đến tìm kiếm. Muốn tìm kiếm thông tinh nhanh, hiệu quả, chính xác ta cần có phương pháp tổ chức và sắp xếp dữ liệu tốt. Chính vì vậy, sắp xếp được xem như giai đoạn đầu chuẩn bị cho quá trình tìm kiếm. Nội dung chương này trình bày các thuật toán sắp xếp và tìm kiếm, bao gồm: các thuật toán sắp xếp đơn giản, các thuật toán sắp xếp nhanh, các thuật toán tìm kiếm tuyến tính, tìm kiếm nhị phân, tìm kiếm nội suy & tìm kiếm Jumping.

# Giới thiệu vấn đề

Bài toán tìm kiếm có thể được phát biểu như sau: Cho dãy gồm n đối tượng _r_ 1, _r_ 2,
.., _r_ n. Mỗi đối tượng _r_ i được tương ứng với một khóa _k_ i (1≤i ≤n). Nhiệm vụ của tìm kiếm là xây dựng thuật toán tìm đối tượng có giá trị khóa là _X_ cho trước. _X_ còn được gọi là khóa tìm kiếm hay tham biến tìm kiếm (argument). Bài toán tìm kiếm bao giờ cũng hoàn thành bởi một trong hai tình huống:

  * Nếu tìm thấy đối tượng có khóa _X_ trong tập các đối tượng thì ta nói phép tìm kiếm thành công (successful).

  * Nếu không tìm thấy đối tượng có khóa _X_ trong tập các đối tượng thì ta nói phép tìm kiếm không thành công (unsuccessful).


**Sắp xếp** là phương pháp bố trí lại các đối tượng theo một trật tự nào đó. Ví dụ bố trí theo thứ tự tăng dần hoặc giảm dần đối với dãy số, bố trị theo thứ tự từ điển đối với các xâu ký tự. Mục tiêu của sắp xếp là để lưu trữ và tìm kiếm đối tượng (thông tin) để đạt hiệu quả cao trong tìm kiếm. Có thể nói, sắp xếp là sân sau quả quá trình tìm kiếm. Muốn tìm kiếm và cung cấp thông tin nhanh thì ta cần phải sắp xếp thông tin sao cho hợp lý. Bài toán sắp xếp có thể được phát biểu như sau:
**Bài toán sắp xếp** : Cho dãy gồm n đối tượng r1, r2, .., rn. Mỗi đối tượng ri được tương ứng với một khóa ki (1≤i ≤n). Nhiệm vụ của sắp xếp là xây dựng thuật toán bố trí các đối tượng theo một trật tự nào đó của các giá trị khóa. Trật tự của các giá trị khóa có thể là tăng dần hoặc giảm dần tùy thuộc vào mỗi thuật toán tìm kiếm cụ thể.
Trong các mục tiếp theo, chúng ta xem tập các đối tượng cần sắp xếp là tập các số. Việc mở rộng các số cho các bản ghi tổng quát cũng được thực hiện tương tự bằng cách thay đổi các kiểu dữ liệu tương ứng. Cũng giống như tìm kiếm, việc làm này không làm mất đi bản chất của thuật toán.

# Các thuật toán sắp xếp đơn giản

Các thuật toán sắp xếp đơn giản được trình bày ở đây bao gồm:

  * Thuật toán sắp xếp kiểu lựa chọn (Selection Sort).

  * Thuật toán sắp xếp kiểu chèn trực tiếp (Insertion Sort).

  * Thuật toán sắp xếp kiểu sủi bọt (Bubble Sort)


## **Thuật toán Selection-Sort**

Thuật toán sắp xếp đơn giản nhất được đề cập đến là thuật toán sắp xếp kiểu chọn. Thuật toán thực hiện sắp xếp dãy các đối tượng bằng cách lặp lại việc tìm kiếm phần tử có giá trị nhỏ nhất từ thành phần chưa được sắp xếp trong mảng và đặt nó vào vị trí đầu tiên của dãy. Trên dãy các đối tượng ban đầu, thuật toán luôn duy trì hai dãy con: dãy con đã được sắp xếp là các phần tử bên trái của dãy và dãy con chưa được sắp xếp là các phần tử bên phải của dãy. Quá trình lặp sẽ kết thúc khi dãy con chưa được sắp xếp chỉ còn lại đúng một phần tử. Thuật toán được trình bày chi tiết trong Hình 3.1.

  1. **Biểu diễn thuật toán** ![](images/image1.png)


**Hình 3.1**. Thuật toán Selection Sort.

  2. **Độ phức tạp thuật toán**


Độ phức tạp thuật toán Selection Sort là O(N2), trong đó N là số lượng phần tử cần sắp xếp. Bạn đọc tự tìm hiểu phương pháp xác định độ phức tạp thuật toán Selection Sort trong các tài liệu tham khảo liên quan.

  3. **Kiểm nghiệm thuật toán**


![](images/image2.png)

  4. **Cài đặt thuật toán**


#include <iostream> #include <iomanip> using namespace std;
void swap(int *x, int *y){ // _đổi giá trị của x và y_
int temp = *x; *x = *y; *y = temp;
}
void SelectionSort(int arr[], int n){ // _thuật toán selection sort_
int i, j, min_idx; // _min_idx là vị trí để arr[min_index] nhỏ nhất_
for (i = 0; i < n-1; i++) { // _duyệt n-1 phần tử_
min_idx = i; // _vị trí số bé nhất tạm thời là i_
for (j = i+1; j < n; j++){ // _tìm vị trí số bé nhất arr[i+1],.., arr[n-1]_
if (arr[j] < arr[min_idx]) min_idx = j;
}
swap(&arr[min_idx], &arr[i]); _//tráo đổi arr[min_idx] và arr[i]_
}
}
void printArray(int arr[], int size){ // _hiển thị kết quả_
for (int i=0; i < size; i++) cout<<arr[i]<<setw(5);
cout<<endl;
}
int main(){ // _chương trình chính_
int arr[] = {64, 25, 12, 22, 11};
int n = sizeof(arr)/sizeof(arr[0]); SelectionSort(arr, n); cout<<"Dãy số được sắp: \n"; printArray(arr, n);
}

## Thuật toán Insertion Sort

Thuật toán sắp xếp kiểu chèn được thực hiện đơn giản theo cách của người chơi bài thông thường. Phương pháp được thực hiện như sau:

  * Lấy phần tử đầu tiên Arr[0] (quân bài đầu tiên) như vậy ta có dãy một phần tử được sắp.

  * Lấy phần tiếp theo (quân bài tiếp theo) Arr[1] và tìm vị trí thích hợp chèn Arr[1] vào dãy Arr[0] để có dãy hai phần tử đã được sắp.

  * Tổng quát, tại bước thứ i ta lấy phần tử thứ i và chèn vào dãy Arr[0],..,Arr[i-1] đã được sắp trước đó để nhận được dãy i phần tử được sắp. Quá trình sắp xếp sẽ kết thúc khi quân bài cuối cùng (i = n) được chèn đúng vị trí. Thuật toán Insertion Sort được mô tả chi tiết trong Hình 3.2.

1. **Biểu diễn thuật toán** ![](images/image3.png)


**Hình 3.2**. Thuật toán Insertion Sort

  2. **Độ phức tạp thuật toán**


Độ phức tạp thuật toán là O(N2), với N là số lượng phần tử. Thuật toán có thể cải tiến bằng cách sử dụng hàng đợi ưu tiên với độ phức tạp O(N.Log(N)).
**c) Kiểm nghiệm thuật toán**

  3. **Cài đặt thuật toán** #include <iostream> #include <iomanip> using namespace std;![](images/image4.jpg)


void insertionSort(int arr[], int n){ int i, key, j;
for (i = 1; i < n; i++){
key = arr[i]; j = i-1;
while (j >= 0 && arr[j] > key){ arr[j+1] = arr[j];
j = j-1;
}
arr[j+1] = key;
}
}
void printArray(int arr[], int n){
int i;cout<<"\n Day so duoc sap:"; for (i=0; i < n; i++)
cout<<arr[i]<<setw(3);
}
int main(){
int arr[] = {12, 11, 13, 5, 6};
int n = sizeof(arr)/sizeof(arr[0]); insertionSort(arr, n); printArray(arr, n);
}

# Public_054

# Thuật toán Bubble Sort

Thuật toán sắp xếp kiểu sủi bọt được thực hiện đơn giản bằng cách tráo đổi hai phần từ liền kề nhau nếu chúng chưa được sắp xếp. Thuật toán được mô tả chi tiết trong Hình 3.3.

## ![](images/image1.png) Biểu diễn thuật toán

**Hình 3.3**. Thuật toán Bubble Sort

## Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(N2), với N là số lượng phần tử. Bạn đọc tự tìm hiểu phương pháp ước lượng và chứng minh độ phức tạp thuật toán Bubble Sort trong các tài liệu liên quan.

## Kiểm nghiệm thuật toán

![](images/image2.png)

## Cài đặt thuật toán

#include <iostream>  
#include <iomanip>  
using namespace std;

void swap(int *x, int *y){ // _đổi chỗ hai số x và y_
int temp = *x; *x = *y;*y = temp;
}
void bubbleSort(int arr[], int n){ // _thuật toán bubble sort_
int i, j;
for (i = 0; i < n; i++) {

for (j = 0; j < n-i-1; j++) {

if (arr[j] > arr[j+1])

swap(&arr[j], &arr[j+1]);
}
}
}
void printArray(int arr[], int size){  
cout<<"\n Dãy được sắp:";  
for (int i=0; i < size; i++)
cout<<arr[i]<<setw(3);
}
int main(){
int arr[] = {64, 34, 25, 12, 22, 11, 90};
int n = sizeof(arr)/sizeof(arr[0]); bubbleSort(arr, n); printArray(arr, n);
}

# Thuật toán Quick Sort

Thuật toán sắp xếp Quick-Sort được thực hiện theo mô hình chia để trị (Divide and Conquer). Thuật toán được thực hiện xung quanh một phần tử gọi là chốt (key). Mỗi cách lựa chọn vị trí phần tử chốt trong dãy sẽ cho ta một phiên bản khác nhau của thuật toán. Các phiên bản (version) của thuật toán Quicksort bao gồm:

  * Luôn lựa chọn phần tử đầu tiên trong dãy làm chốt.

  * Luôn lựa chọn phần tử cuối cùng trong dãy làm chốt.

  * Luôn lựa chọn phần tử ở giữa dãy làm chốt.

  * Lựa chọn phần tử ngẫu nhiên trong dãy làm chốt.


Mấu chốt của thuật toán Quick-Sort là làm thế nào ta xây dựng được một thủ tục phân đoạn (Partition). Thủ tục Partition có hai nhiệm vụ chính:

  * Định vị chính xác vị trí của chốt trong dãy nếu được sắp xếp;

  * Chia dãy ban đầu thành hai dãy con: dãy con ở phía trước phần tử chốt bao gồm các phần tử nhỏ hơn hoặc bằng chốt, dãy ở phía sau chốt có giá trị lớn hơn chốt.


Thuật toán Partition được mô tả chi tiết trong Hình 3.4 với khóa chốt là phần tử cuối cùng của dãy. Phiên bản Quick Sort tương ứng được mô tả chi tiết trong Hình 3.5.

##  Biểu diễn thuật toán![](images/image3.png)

**Hình 3.4**. Thuật toán Partition với chốt là vị trí cuối cùng của dãy
![](images/image4.png)
**Hình 3.5**. Thuật toán Quick-Sort với chốt là vị trí cuối cùng của dãy

##  Độ phức tạp thuật toán

Độ phức tạp thuật toán trong trường hợp xấu nhất là O(N2), trong trường hợp tốt nhất là O(N.Log(N)), với N là số lượng phần tử. Bạn đọc tự tìm hiểu và chứng minh độ phức tạp thuật toán Quick Sort trong các tài liệu liên quan.

## Kiểm nghiệm thuật toán

![](images/image5.png)

**2.4. Cài đặt thuật toán** #include<iostream> #include<iomanip>

using namespace std;

void swap(int* a, int* b){ // _đổi chỗ a và b_
int t = *a; *a = *b; *b = t;
}
int partition (int arr[], int l, int h){ // _thuật toán partition chốt h_
int x = arr[h]; // _x chính là chốt_
int i = (l - 1); // _i lấy vị trí nhỏ hơn l_
for (int j = l; j <= h- 1; j++) {// _duyệt từ l đến h-1_
// If current element is smaller than or equal to pivot if (arr[j] <= x){ // _nếu arr[j] bé hơn hoặc bằng chốt_
i++; // _tăng i lên một đoen vị_
swap(&arr[i], &arr[j]); // _đổi chỗ arr[i] cho arr[j]_
}
}
swap(&arr[i + 1], &arr[h]); // _đổi chỗ cho arr[i+1] và arr[h]_
return (i + 1); // _đây là vị trí của chốt_
}
void quickSort(int arr[], int l, int h){ if (l < h){
int p = partition(arr, l, h); // _tìm vị trí của chốt_
quickSort(arr, l, p - 1);// _trị nửa bên trái_
quickSort(arr, p + 1, h);// _trị nửa bên phải_
}
}
void printArray(int arr[], int size){ // _thủ tục in kết quả_
int i; cout<<"\n _Dãy được sắp_ :"; for (i=0; i < size; i++)
cout<<arr[i]<<setw(3);
}
int main(){ // _chương trình chính_
int arr[] = {10, 27, 15, 29, 21, 11, 14, 18, 12, 17};
int n = sizeof(arr)/sizeof(arr[0]); quickSort(arr, 0, n-1); printArray(arr, n);
}

# Thuật toán Merge Sort

Giống như Quick-Sort, Merge-Sort cũng được xây dựng theo mô hình chia để trị (Divide and Conquer). Thuật toán chia dãy cần sắp xếp thành hai nửa. Sau đó gọi đệ qui lại cho mỗi nửa và hợp nhất lại các đoạn đã được sắp xếp. Thuật toán được tiến hành theo 4 bước dưới đây:

  * Tìm điểm giữa của dãy và chia dãy thành hai nửa.

  * Thực hiện Merge-Sort cho nửa thứ nhất.

  * Thực hiện Merge-Sort cho nửa thứ hai.

  * Hợp nhất hai đoạn đã được sắp xếp.


![](images/image6.png)

Mấu chốt của thuật toán Merge-Sort là làm thế nào ta xây dựng được một thủ tục hợp nhất (Merge). Thủ tục Merge thực hiện hòa nhập hai dãy đã được sắp xếp để tạo thành một dãy cũng được sắp xếp. Bài toán có thể được phát biểu như sau:
**Bài toán hợp nhất Merge** : Cho hai nửa của một dãy Arr[1,..,m] và A[m+1,..,r] đã được sắp xếp. Nhiệm vụ của ta là hợp nhất hai nửa của dãy Arr[1,..,m] và Arr[m+1,..,r] để trở thành một dãy Arr[1, 2,..,r] cũng được sắp xếp.
Thuật toán Merge được mô tả chi tiết trong Hình 3.6. Thuật toán Merge Sort được mô tả chi tiết trong Hình 3.7.
**Biểu diễn thuật toán:**

![](images/image7.png)

**Hình 3.6**. Thuật toán hợp nhất hai đoạn đã được sắp xếp.
![](images/image8.png)
**Hình 3.7**. Thuật toán Merge Sort

## Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(N.Log(N)) với N là số lượng phần tử. Bạn đọc tự tìm hiểu và chứng minh độ phức tạp thuật toán Merge Sort trong các tài liệu liên quan.

##  Kiểm nghiệm thuật toán![](images/image9.png)

## Cài đặt thuật toán 

#include<iostream>  
#include<iomanip>  
using namespace std;

void merge(int arr[], int l, int m, int r){// _thuật toán hợp nhất hai đoạn đã sắp xếp_
int i, j, k;
int n1 = m - l + 1; // _số lượng phần tử đoạn 1_
int n2 = r - m; // _số lượng phần tử đoạn 3_
int L[n1], R[n2]; // _tạo hai mảng phụ để lưu hai đoạn được sắp_
for(i = 0; i < n1; i++)// _lưu đoạn thứ nhất vào L[]_
L[i] = arr[l + i];
for(j = 0; j < n2; j++)// _lưu đoạn thứ hai vào R[]_
R[j] = arr[m + 1+ j];
i = 0; j = 0; k = l; // _bắt đầu hợp nhất_
while (i < n1 && j < n2){ // _quá trình hợp nhất_
if (L[i] <= R[j]){
arr[k] = L[i]; i++;

}

else {

arr[k] = R[j]; j++;

} k++;
}while (i < n1) { // _lấy các phần tử còn lại trong L[] vào arr[]_
arr[k] = L[i]; i++; k++;
}
while (j < n2){ // _lấy các phần tử còn lại trong R[] vào arr[]_
arr[k] = R[j]; j++; k++;
}
}
void mergeSort(int arr[], int l, int r){ // _thuật toán Merge Sort_
if (l < r){ // _nếu cận dưới còn bé hơn cận trên_
int m = l+(r-l)/2; // _tìm vị trí ở giữa đoạn l, r_ mergeSort(arr, l, m); // _trị nửa thứ nhất_ mergeSort(arr, m+1, r); // _trị nửa thứ hai_
merge(arr, l, m, r); // _hợp nhất hai đoạn đã được sắp_
}
}
void printArray(int Arr[], int size){ // _in kết quả_
int i;cout<<"\n Dãy được sắp:"; for (i=0; i < size; i++)
cout<<Arr[i]<<setw(3);
}
int main(){
int arr[] = {38, 27, 43, 3, 9, 82, 10};
int arr_size = sizeof(arr)/sizeof(arr[0]); mergeSort(arr, 0, arr_size \- 1); printArray(arr, arr_size);
}

# Thuật toán Heap Sort

Thuật toán Heap-Sort được thực hiện dựa trên cấu trúc dữ liệu Heap. Nếu ta muốn sắp xếp theo thứ tự tăng dần ta sử dụng cấu trúc Max Heap, ngược lại ta sử dụng cấu trúc Min-Heap. Vì Heap là một cây nhị phân đầy đủ nên việc biểu diễn Heap một cách hiệu quả có thể thực hiện được bằng mảng. Nếu ta xem xét phần tử thứ i trong mảng thì phần tử 2*i +1, 2*i +2 tương ứng là node con trái và node con phải của i.
Tư tưởng của Heap Sort giống như Selection Sort, chọn phần tử lớn nhất trong dãy đặt vào vị trí cuối cùng, sau đó lặp lại quá trình này cho các phần tử còn lại. Tuy nhiên, điểm khác biệt ở đây là phần tử lớn nhất của Heap luôn là phần tử đầu tiên trên Heap và các phần tử node trái và phải bao giờ cũng nhỏ hơn nội dung node gốc.
Thuật toán được thực hiện thông qua ba bước chính như sau:

  * Xây dựng Max Heap từ dữ liệu vào. Ví dụ với dãy A[] = {9, 7, 12, 8, 6, 5} thì Max Heap được xây dựng là A[] = {12, 8, 9, 7, 6, 5}.

  * Bắt đầu tại vị trí đầu tiên là phần tử lớn nhất của dãy. Thay thế, phần tử này cho phần tử cuối cùng ta nhận được dãy A[] = {5, 8, 9, 7, 6, 12}.

# Public_055

# Một số thuật toán tìm kiếm thông dụng

Tìm kiếm là lĩnh vực quan trọng của khoa học máy tính có mặt trong hầu hết các ứng dụng trên máy tính. Các thuật toán tìm kiếm được chia thành ba loại: tìm kiếm trên các đối tượng dữ liệu chưa được sắp xếp (tìm kiếm tuyến tính), tìm kiếm trên các đối tượng dữ liệu đã được sắp xếp (tìm kiếm nhị phân) và tìm kiếm xấp xỉ. Nội dung cụ thể của các phương pháp được thể hiện như dưới đây.

## Thuật toán tìm kiếm tuyến tính (Sequential Search)

Thuật toán tìm kiếm tuyến tính áp dụng cho tất cả các đối tượng dữ liệu chưa được sắp xếp. Để tìm vị trí của _x_ trong dãy A[] gồm _n_ phần tử, ta chỉ cần duyệt tuần tự trên dãy A[] từ phần tử đầu tiên đến phần tử cuối cùng. Nếu _x_ = A[ _i_ ] thì _i_ chính là vị trí của _x_ thuộc dãy A[]. Nếu duyệt đến phần tử cuối cùng vẫn chưa tìm thấy _x_ ta kết luận _x_ không có mặt trong dãy số A[]. Thuật toán được mô tả chi tiết trong Hình 3.9.

### Biểu diễn thuật toán

**Hình 3.9**. Thuật toán Sequential-Search.

### Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(n), với n là số lượng phần tử trong dãy A[].

### Kiểm nghiệm thuật toán

Ví dụ ta cần tìm x = 9 trong dãy A[] = {56, 3, 249, 518, 7, 26, 94, 651, 23, 9 }. Khi đó quá trình tìm kiếm được thể hiện như dưới đây.![](images/image5.jpg)

### Cài đặt thuật toán 

#include <iostream>
using namespace std;
int Sequential_Search( int A[], int n, int x){
for(int i=0; i<n; i++){
if ( x == A[i]) return i;
}
return -1;
}
int main(void){
int A[] = {9, 7, 12, 8, 6, 5};
int x = 15, n = sizeof(A)/sizeof(A[0]); int t = Sequential_Search(A,n,x); if(t>=0)cout<<"\n Vị trí của x:"<<t; else cout<<"\n Không tìm thấy x";
}

## Thuật toán tìm kiếm nhị phân

Thuật toán tìm kiếm nhị phân là phương pháp định vị phần tử _x_ trong một danh sách A[] gồm n phần tử đã được sắp xếp. Quá trình tìm kiếm bắt đầu bằng việc chia danh sách thành hai phần. Sau đó, so sách x với phần từ ở giữa. Khi đó có 3 trường hợp có thể xảy ra:

**Trường hợp 1** : nếu x bằng phần tử ở giữa A[mid], thì mid chính là vị trí của x trong danh sách A[].
**Trường hợp 2** : Nếu x lớn hơn phần tử ở giữa thì nếu x có mặt trọng dãy A[] thì ta chỉ cần tìm các phần tử từ mid+1 đến vị trí thứ n.
**Trường hợp 3** : Nếu x nhỏ hơn A[mid] thì x chỉ có thể ở dãy con bên trái của dãy A[].

Lặp lại quá trình trên cho đến khi cận dưới vượt cận trên của dãy A[] mà vẫn chưa tìm thấy _x_ thì ta kết luận _x_ không có mặt trong dãy A[]. Thuật toán được mô tả chi tiết trong Hình 3.10.

### Biểu diễn thuật toán

![](images/image2.png)
**Hình 3.10**. Thuật toán Binary-Search

### Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(log(n)), với n là số lượng phần tử của dãy A[].

### Kiểm nghiệm thuật toán

Ví dụ ta cần tìm x = 23 trong dãy A[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}. Khi đó quá trình được tiến hành như dưới đây.![](images/image9.jpg)

### Cài đặt thuật toán 

#include <iostream>  
using namespace std;
int Binary_Search( int A[], int n, int x) {//tìm vị trí của x trong dãy A[]
int low = 0; _//cận dưới của dãy khóa_
int hight = n-1; _//cận trên của dãy khóa_
int mid = (low+hight)/2; _//vị trí phần tử ở giữa_
while ( low <=hight) { // _lặp trong khi cận dưới nhỏ hơn cận trên_
if ( x > A[mid] ) _//nếu x lớn hơn phần tử ở giữa_
low = mid + 1; _//cận dưới dịch lên vị trí mid +1_
else if ( x < A[mid] ) _//nếu x nhỏ hơn phần tử ở giữa_
hight = mid -1; _//cận trên dịch xuống vị trí mid -1_
else
return(mid); // _đây chính là vị trí của x_
mid = (low + hight)/2; // _xác định lại vị trí ở giữa_
}
return(-1); // _không tìm thấy x trong A[]_.
}
int main(void){
int A[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
int x = 91, n = sizeof(A)/sizeof(A[0]); int t = Binary_Search(A,n,x); if(t>=0)cout<<"\n Vị trí của x:"<<t; else cout<<"\n không tìm thấy x";
}

## Thuật toán tìm kiếm nội suy

Thuật toán tìm kiếm kiểu nội suy (interpolation search) là cải tiến của thuật toán tìm kiếm nhị phân. Thuật toán tìm kiếm nhị phân luôn thực hiện so sánh khóa với phần tử ở giữa. Trong đó, thuật toán tìm kiếm nội suy định vị giá trị so sánh tùy thuộc vào giá trị của khóa cần tìm. Bằng cách này, giá trị của khóa cần tìm kiếm dù ở đầu dãy, cuối dãy hay vị trí bất kỳ thuật toán đều tìm được vị trí gần nhất để thực hiện so sánh. Thuật toán được mô tả chi tiết trong Hình 3.11.

### Biểu diễn thuật toán

![](images/image3.png)

**Hình 3.11**. Thuật toán Interpolation-Search

### Độ phức tạp thuật toán

Độ phức tạp trung bình của thuật toán tìm kiếm nội suy là O(log(n)), với n là số lượng phần tử của dãy A[]. Trong trường hợp xấu nhất, thuật toán có độ phức tạp là O(n).

### Kiểm nghiệm thuật toán

Bạn đọc tự tìm hiểu phương pháp kiểm nghiệm thuật toán tìm kiếm nội suy trong các tài liệu liên quan.

### Cài đặt thuật toán 

#include <iostream>  
using namespace std;
int interpolationSearch(int A[], int n, int x){// _thuật toán tìm kiếm nội suy_
int L = 0, H = (n - 1);// _cận dưới và cận trên của dãy_
if (x < A[L] || x > A[H])// _nếu điều này xảy ra_
return -1; // _chắc chắn x không có mặt trong dãy A[]_
while (L <= H){// _lặp trong khi cận dưới bé hơn cận trên_
int pos = L + (((H-L) /(A[H]-A[L]))*(x - A[L])); // _xác định vị trí_
if (A[pos] == x)// _nếu vị trí đúng là x_
return pos; // _đây là vị trí cần tìm_
if (A[pos] < x)// _nếu x lớn hơn A[pos]_
L = pos + 1; // _dịch cận dưới lên 1_
else // _nếu x bé hơn A[pos]_
H = pos - 1; // _giảm cận trên đi 1_
}
return -1; // _kết luận không tìm thấy_
}
int main(){
int A[] = {10, 12, 13, 16, 31, 33, 35, 42, 47};
int n = sizeof(A)/sizeof(A[0]); int x = 42; // _phần tử cần tìm_
int index = interpolationSearch(A, n, x); if (index != -1)// _nếu tìm thấy x_
cout<<"Vị trí:"<<index;
else
cout<<"Không tìm thấy x";
}

## Thuật toán tìm kiếm Jumping

Thuật toán tìm kiếm Jumping được thực hiện bằng cách so sánh phần tử cần tìm với bước nhảy là một hàm mũ. Nếu khóa cần tìm lớn hơn phần tử tại bước nhảy ta nhảy tiếp một khoảng cũng là một hàm mũ. Trong trường hợp, khóa cần tìm nhỏ hơn phần tử tại bước nhảy, ta quay lại bước trước đó và thực hiện phép tìm kiếm tuyến tính thuần túy. Thuật toán được mô tả chi tiết trong Hình 3.12.

### Biểu diễn thuật toán![](images/image4.png)

**Hình 3.12**. Thuật toán Jumping Search.

### Độ phức tạp thuật toán

Độ phức tạp thuật toán trong trường hợp tốt, xấu nhất là 𝑂(√𝑛). Trường hợp tốt nhất là O(log(n)), với n là số lượng phần tử của dãy A[].

### Kiểm nghiệm thuật toán

Giả sử ta cần tìm vị trí của x = 55 trong dãy số A[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, 233, 377, 610}. Khi đó, thuật toán được thực hiện như sau:
**Bước 1**. Ta tìm được step=4. So sánh 53 với vị trí số A[3]=2<55.
**Bước 2**. Dịch chuyển step = 8, so sánh 53 với vị trí số A[7]=13<55\. **Bước 3**. Dịch chuyển step = 16, so sánh 53 với vị trí số A[15]=610>55\. **Bước 4**. Vì 610>55 nên ta trở về bước trước đó cộng thêm 1 là 9.
**Bước 5**. Tìm kiếm tuyến tính từ vị trí 9 đến 15 ta nhận được kết quả là 10.

### **Cài đặt thuật toán**

#include <iostream> #include <cmath>
using namespace std;
int JumpSearch(int A[], int n, int x){ // _thuật toán Jumping Search_
int step = (int) sqrt(n); // _giá trị bước nhảy_
int prev = 0; // _giá trị bước nhảy trước_
int r = min(step,n)-1;//vị trí cần so sánh while (A[r]<x) {// _lặp trong khi A[r] <x_
prev = step; // _lưu lại giá trị bước trước_
step += (int)sqrt(n);// _tăng bước nhảy_
if (prev >= n) // _nếu điều này xảy ra_

return -1; // _x chắc chắn không có trong A[]_

r = min(step,n)-1; / _/tính toán lại vị trí cần so sánh_

}
while (A[prev] < x){// _tìm kiếm tuyến tính thông thường_
prev++;
if (prev == min(step, n)) return -1;
}
if (A[prev] == x) // _nếu tìm thấy x_
return prev;
return -1;// _không tìm thấy x_

}

int main(void){
int A[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, 233, 377, 610};
int x = 233, n = sizeof(A)/sizeof(A[0]); int index = JumpSearch(A, n,x);
if (index!=-1) cout<<"\n Vị trí:"<<index; else cout<<"\n Không tìm thấy x";
}

# Public_056

Như đã trình bày trong Chương 1, một kiểu dữ liệu trừu tượng (ADTs) được xác định khi ta xây dựng đầy đủ hai phần: cấu trúc dữ liệu cùng các phép toán trên cấu trúc dữ liệu đó. Nội dung của chương này trình bày ba kiểu dữ liệu trừu tượng quan trọng đó là danh sách liên kết, ngăn xếp và hàng đợi. Mỗi kiểu dữ liệu trừu tượng được xây dựng giải quyết lớp các vấn đề cụ thể của khoa học máy tính. Đối với người học, mỗi cấu trúc dữ liệu trừu tượng cần làm chủ được bốn điểm quan trọng sau:

  * Định nghĩa cấu trúc dữ liệu ADTs.

  * Biểu diễn cấu trúc dữ liệu ADTs.

  * Thao tác (phép toán) trên cấu trúc dữ liệu ADTs.

  * Ứng dụng của cấu trúc dữ liệu ADTs.


# Danh sách liên kết đơn (Single Linked List)

Như ta đã biết mảng ( _array_ ) là tập có thứ tự các phần tử có cùng chung một kiểu dữ liệu và được tổ chức liên tục nhau trong bộ nhớ. Ưu điểm lớn nhất của mảng là đơn giản và xử lý nhanh nhờ cơ chế truy cập phần tử trực tiếp vào các phần tử của mảng. Hạn chế lớn nhất của mảng là số lượng phần tử không thay đổi gây nên hiện tượng thừa bộ nhớ trong một số trường hợp và thiếu bộ nhớ trong một số trường hợp khác. Đối với một số bài toán có dữ liệu lớn, nhiều khi ta không đủ không gian nhớ tự do liên tục để cấp phát cho mảng. Để khắc phục hạn chế này ta có thể xây dựng kiểu dữ liệu danh sách liên kết đơn được định nghĩa, biểu diễn và thao tác như dưới đây.

## Định nghĩa danh sách liên kết đơn

Tập hợp các node thông tin được tổ chức rời rạc trong bộ nhớ. Trong đó, mỗi node gồm có hai thành phần:

  * Thành phần dữ liệu ( _data_ ): dùng để lưu trữ thông tin của node.

  * Thành phần con trỏ ( _pointer_ ): dùng để liên kết với node dữ liệu tiếp theo.


## Biểu diễn danh sách liên kết đơn

Để biểu diễn danh sách liên kết đơn ta sử dụng phương pháp định nghĩa cấu trúc tự trỏ của các ngôn ngữ lập trình. Giả sử thành phần thông tin của mỗi node được định nghĩa như một cấu trúc Item như sau:

struct Item {
<Kiểu 1> <Thành viên 1>;
<Kiểu 2> <Thành viên 2>;
……………………………;
<Kiểu N> <Thành viên N>;
};
Khi đó, danh sách liên kết đơn được định nghĩa như sau: struct node {
Item infor; // _Thành phần thông tin của node;_
struct node *next; // _thành phần con trỏ của node_
} *Start; // _Start là một danh sách liên kết đơn_

![](images/image1.png)

**Hình 3.1. Biểu diễn danh sách liên kết đơn**

## Thao tác trên danh sách liên kết đơn

Các thao tác trên danh sách liên kết đơn bao gồm:

  * Tạo node rời rạc có giá trị value cho danh sách liên kết đơn

  * Thêm một node vào đầu danh sách liên kết đơn.

  * Thêm một node vào cuối danh sách liên kết đơn.

  * Thêm node vào vị trí xác định trong danh sách liên kết đơn.

  * Loại node trong sách liên kết đơn.

  * Tìm node trong sách liên kết đơn.

  * Sắp xếp node trong danh sách liên kết đơn.

  * Sửa đổi nội dung node trong sách liên kết đơn.

  * Đảo ngược các node trong danh sách liên kết đơn.

  * Duyệt các node của danh sách liên kết đơn.


Để đơn giản, ta xem thành phần thông tin của node (Item) là một số nguyên. Khi đó, các thao tác trên danh sách liên kết đơn ta định nghĩa một lớp các thao tác như sau:

struct node { // _biểu diễn node_
int info; // _thành phần thông tin của node_
struct node *next; // _thành phần con trỏ của node_
}*start; // _danh sách liên kết đơn: *start._
class single_linked_list { // _biểu diễn lớp danh sách liên kết đơn_
public:
node* create_node(int);// _Tạo một node cho danh sách liên kết đơn_
void insert_begin(); // _thêm node vào đầu DSLKĐ_
void insert_pos(); // _thêm node tại vị trí cụ thể trên DSLKĐ_
void insert_last(); // _thêm node vào cuối DSLKĐ_
void delete_pos(); // _loại node tại vị trí cho trước trên DSLKĐ_
void sort(); // _sắp xếp nội dung các node theo thứ tự tăng dần_
void search(); // _tìm kiếm node trên DSLKĐ_
void update(); // _sửa đổi thông tin của node trên DSLKĐ_
void reverse(); // _đảo ngược danh sách liên kết đơn_
void display(); // _hiển thị nội dung DSLKĐ_
single_linked_list(){// _constructor của lớp single linked list_. start = NULL;// _chú ý start là biến toàn cục_
}
};

**Thao tác:** _tạo một node rời rạc có giá trị value cho DSLKĐ_ **.**

node *single_linked_list::create_node(int value){
struct node *temp; // _khai báo hai con trỏ node *temp_ temp = new(struct node); // _cấp phát miền nhớ cho temp_ if (temp == NULL){ // _nếu không đủ không gian nhớ_
cout<<“ _không đủ bộ nhớ để cấp phát_ "<<endl; return 0;
else {
temp->info = value;// _thiết lập thông tin cho node temp_
temp->next = NULL; // _thiết lập liên kết cho node temp_
return temp;// _trả lại node temp đã được thiết lập_
}

}

**Thao tác: _thêm node vào đầu DSLKĐ_.**

void single_linked_list::insert_begin(){ // _chèn node vào đầu DSLKĐ_
int value; cout<<“Nhập giá trị node:"; cin>>value; // _giá trị node cần chèn_
struct node *temp, *p; // _sử dụng hai con trỏ temp và p_
temp = create_node(value);// _tạo một node rời rạc có giá trị value_
if (start == NULL){ // _nếu danh sách liên kết rỗng_
start = temp; // _danh sách liên kết chính là node temp_
start->next = NULL; // _không có liêt kết với node khác_
}
else { // _nếu danh sách không rỗng_
p = start; // _p trỏ đến node đầu của start_
start = temp; // _node temp trở thành node đầu tiên của start_
start->next = p;// _các node còn lại chính là p_
}
}

Hình 3.2. dưới đây mô tả phép thêm node vào đầu danh sách liên kết đơn.

![](images/image2.png)

**Hình 3.2. Thêm node vào đầu danh sách liên kết đơn**

**Thao tác thêm node vào cuối danh sách liên kết đơn** :

void single_linked_list::insert_last() **{** // _thêm node vào cuối DSLKĐ_

int value;
cout<<“Nhập giá trị cho node: ";cin>>value; // _nhập giá trị node_
struct node *temp, *s; // _sử dung hai con trỏ temp và s_
temp = create_node(value);// _tạo node rời rạc có giá trị value_
if(start==NULL) {// _trường hợp DSLKĐ rỗng_
start = temp;
temp->next=NULL;
}
s = start; // _s trỏ đến node đầu danh sách_
while (s->next != NULL){ // _di chuyển s đến node cuối cùng_
s = s->next;
}
temp->next = NULL; // _temp không chỏ đi đâu nữa_ s->next = temp; // _thiết lập liên kết cho s_ cout<<“ _Hoàn thành thêm node vào cuối_ "<<endl;

}

![](images/image3.png)

**Hình 3.3. Thêm node vào cuối danh sách liên kết đơn**

**Thao tác thêm node vào vị trí pos của danh sách liên kết đơn** :

void single_linked_list::insert_pos() **{** // _thêm node vào vị trí pos_

int value, pos, counter = 0; cout<<"Nhap gia tri node:";cin>>value; struct node *temp, *s, *ptr; // _sử dụng ba con trỏ node_
temp = create_node(value);// _tạo node rời rạc có giá trị value_
cout<<“Nhập vị trí node cần thêm: ";cin>>pos; int i; s = start; // _s trỏ đến node đầu tiên_
while (s != NULL){ // _đếm số node của DSLKĐ_
s = s->next; counter++;

}

if (counter==0) {// _trường hợp DSLK đơn rỗng_
cout<<”Danh sách rỗng”; return;
}
if (pos == 1){ // _nếu pos là vị trí đầu tiên_

if (start == NULL){ // _trường hợp DSLKĐ rỗng_

start = temp; start->next = NULL;

}
else { // _thêm node temp vào đầu DSLKĐ_
ptr = start; start = temp; start->next = ptr;
}
}
else if (pos > 1 && pos <= counter){ // _trường hợp pos hợp lệ_
s = start; // _s trỏ đến node đầu tiên_
for (i = 1; i < pos; i++){ // _di chuyển đến node pos-1_
ptr = s; s = s->next;
}
ptr->next = temp; temp->next = s; // _thiết lập liên kết cho node_
}
else { cout<<“ _Vượt quá giới hạn DSLKĐ_ "<<endl; }

}

![](images/image4.png)

**Hình 3.4. Thêm node vào vị trí pos**

**Thao tác loại node tại vị trí pos** :

void single_linked_list::delete_pos() **{** // _loại node ở vị trí pos_

int pos, i, counter = 0;
if (start == NULL){ // _nếu danh sách liê kết đơn rỗng_
cout<<“Không thực hiện được"<<endl; return;
}
cout<<“ _Vị trí cần loại bỏ_ :";cin>>pos;
struct node *s, *ptr; s = start; // _s trỏ đến đầu danh sách_
if (pos == 1){// _nếu vị trí loại bỏ là node đầu tiên_
start = s->next; s->next=NULL; free(s);}
else {
while (s != NULL) { // _đếm số node của DSLKĐ_
s = s->next; counter++;}
if (pos > 0 && pos <= counter){ // _nếu vị trí pos hợp lệ_
s = start;// _s trỏ đến node đầu của danh sách_
for (i = 1;i < pos; i++){ // _di chuyển đến vị trí pos-1_
ptr = s; s = s->next;
}
ptr->next = s->next; // _thiết lập liên kết cho node_
}
else { cout<<"Vi tri ngoai danh sach"<<endl; } free(s); // _giải phóng s_
cout<<"Node da bi loai bo"<<endl;
}

}

![](images/image5.png)

**Hình 3.5. Thao tác loại node ở vị trí pos**

**Thao tác sửa đổi nội dung của node** :

void single_linked_list::update() **{** // _sửa đổi thông tin của node_

int value, pos, i;
if (start == NULL){ // _nếu danh sách LKĐ rỗng_
cout<<“ _Không thực hiện được_ "<<endl; return;
}
cout<<“Nhập vị trí node cần sửa:";cin>>pos; cout<<“ _Giá trị mới của node_ :";cin>>value; struct node *s, *ptr; // _sử dụng hai con trỏ s và ptr_ s = start; // _s trỏ đến node đầu tiên_
if (pos == 1) { start->info = value;} // _sửa luôn node đầu tiên_
else { // _nếu pos không phải là node đầu tiên_
for (i = 0;i < pos - 1;i++){// _chuyển s đến vị trí pos-1_
if (s == NULL){// _Nếu s là node cuối cùng_
cout<<"Vị trí "<<pos<<" _không hợp lệ_ “; return;
}
s = s->next;
}
s->info = value; // _Sửa đổi thông tin cho node_
}
cout<<“ _Hoàn thành việc sửa đổi_ "<<endl;

}

**Thao tác duyệt danh sách liên kết đơn** :

void single_linked_list::display() **{** // _hiển thị nội dung DSLKĐ_

struct node *temp; // _sử dụng một con trỏ temp_
if (start == NULL){ // _nếu danh sách rỗng_ cout<<“ _Có gì đâu mà hiển thị_ "<<endl; return;
}
temp = start; // _temp trỏ đến node đầu trong DSLKĐ_
cout<<“ _Nội dung DSLKĐ_ : "<<endl;
while (temp != NULL) { // _lặp cho đến node cuối cùng_ cout<<temp->info<<"->"; // _hiển thị thông tin node_ temp = temp->next; // _di chuyển đến node tiếp theo_
}
cout<<" _NULL_ "<<endl; // _node cuối cùng là NULL_

}

**Thao tác tìm node trong danh sách liên kết đơn** :

_**void single_linked_list::search(){**_ // _Tìm kiếm node_

int value, pos = 0; bool flag = false;
if (start == NULL){// _nếu danh sách rỗng_ cout<<“ _ta không có gì để tìm_ "<<endl; return;
}
cout<<“ _Nội dung node cần tìm_ :";cin>>value; struct node *s; s = start;// _s trỏ đến đầu danh sách_ while (s != NULL){ pos++;
if (s->info == value){// _Nếu s- >infor là value_
flag = true;
cout<<“ _Tìm thấy_ "<<value<<" _tại vị trí_ "<<pos<<endl;
}
s = s->next;
}
if (!flag) {// _đến cuối vẫn không thấy_
cout<<“ _Giá trị_ "<<value<<“ _không tồn tại_ "<<endl;
}

}

**Thao tác sắp xếp các node trong danh sách liên kết đơn** : void single_linked_list::sort() **{** // _sắp xếp theo nội dung các node_

struct node *ptr, *s; // _sử dụng hai con trỏ ptr và s_
int value; // _giá trị trung gian_
if (start == NULL){// _nếu danh sách rỗng_ cout<<“ _không có gì để sắp xếp_ "<<endl; return;
}
ptr = start;// _ptr trỏ đến node đầu danh sách_
while (ptr != NULL){ // _lặp trong khi ptr khác rỗng_
for (s = ptr->next; s !=NULL; s = s->next){ // _s là node tiếp theo_
if (ptr->info > s->info){// _nếu điều này xảy ra_
value = ptr->info;// _tráo đổi nội dung hai node_
ptr->info = s->info; s->info = value;
}
}
ptr = ptr->next;
}

}

**Thao tác đảo ngược các node của DSLKĐ** :

void single_linked_list::reverse() **{** // _đảo ngược danh sách_

struct node *ptr1, *ptr2, *ptr3; // _sử dụng ba con trỏ node_
if (start == NULL) {// _Nếu danh sách rỗng_
cout<<“ _ta không cần đảo_ "<<endl; return;
}
if (start->next == NULL){//Nếu danh sách chỉ có một node cout<<“ _đảo ngược là chính nó_ "<<endl; return;
}
ptr1 = start; // _ptr1 trỏ đến node đầu tiên_
ptr2 = ptr1->next;// _ptr2 trỏ đến node kế tiếp của ptr1_ ptr3 = ptr2->next;// _ptr3 trỏ đến nod kế tiếp của ptr2_ ptr1->next = NULL;// _Ngắt liên kết ptr1_
ptr2->next = ptr1;// _node ptr2 bây giờ đứng trước node ptr1_
while (ptr3 != NULL){// _Lặp nếu ptr3 khác rỗng_ ptr1 = ptr2; // _ptr1 lại bắt đầu tại vị trí ptr2_ ptr2 = ptr3; // _ptr2 bắt đầu tại vị trí ptr3_
ptr3 = ptr3->next; // _ptr3 trỏ đến node kế tiếp_
ptr2->next = ptr1; // _Thiết lập liên kết cho ptr2_
}
start = ptr2; // _node đầu tiên bây giờ là ptr2_

}

**//Chương trình cài đặt các thao tác trên danh sách liên kết đơn:**

#include<iostream> using namespace std;

struct node { // _biểu diễn danh sách liên kết đơn_

int info; // _thành phần thông tin_
struct node *next; // _thành phần liên kết_

}*start;

class single_linked_list { // _biểu diễn lớp single_linked_list_

public:
node* create_node(int);// _tạo node rời rạc có giá trị value_
void insert_begin();// _thêm node vào đầu danh sách liên kết đơn_
void insert_pos();// _thêm node vào vị trí pos trong danh sách liên kết đơn_
void insert_last();// _thêm node vào cuối danh sách liên kết đơn_ void delete_pos();// _loại node tại vị trí pos của sách liên kết đơn_ void sort();// _sắp xếp theo giá trị node cho danh sách liên kết đơn_ void search();// _tìm node trong danh sách liên kết đơn_
void update(); // _cập nhật thông tin cho node_
void reverse(); // _đảo ngược các node trong danh sách liên kết đơn_ void display(); // _duyệt danh sách liên kết đơn_ single_linked_list(){// _constructor của lớp_
start = NULL;
}

};

# Public_057

Đồ thị là một cấu trúc dữ liệu rời rạc bao gồm các đỉnh và các cạnh nối các cặp đỉnh này. Với quan niệm như trên, một mạng máy tính được xem như một đồ thị có mỗi đỉnh là một máy tính, có các cạnh là một liên kết giữa các máy tính khác nhau trong mạng. Các mạch điện, các hệ thống giao thông, các mạng xã hội đều được xem xét như một đồ thị. Có thể nói đồ thị được ứng dụng rộng rãi trong nhiều lĩnh vực khác nhau của khoa học máy tính. Nội dung chính của chương này đề cập đến phương pháp biểu diễn và các thuật toán trên đồ thị.

# Định nghĩa và khái niệm

Ta có thể phân chia đồ thị thành hai loại: đồ thị vô hướng (directed graph) và đồ thị có hướng (directed graph). Mỗi loại đồ thị lại được chia thành 3 loại: đơn đồ thị, đa đồ thị và giả đồ thị. Mỗi loại đồ thị có các thuật ngữ chung và những khái niệm riêng. Dưới đây là một số thuật ngữ cơ bản trên các loại đồ thị.

## Một số thuật ngữ cơ bản trên đồ thị

**Định nghĩa**. Bộ đô _G_ =< _V_ , _E_ >, trong đó _V_ = {1, 2 , .., n} là tập hợp hữu hạn được gọi là tập đỉnh, _E_ là tập có thứ tự hoặc không có thứ tự các cặp đỉnh trong V được gọi là tập cạnh.

**Đồ thị vô hướng**. Đồ thị G=<V, E> được gọi là đồ thị vô hướng nếu các cạnh thuộc E là các cặp không tính đến thứ tự các đỉnh trong V.

**Đơn đồ thị vô hướng**. Đồ thị G=<V, E> được gọi là đơn đồ thị vô hướng nếu G là đồ thị vô hướng và giữa hai đỉnh bất kỳ thuộc V có nhiều nhất một cạnh nối.

**Đa đồ thị vô hướng**. Đồ thị G=<V, E> được gọi là đơn đồ thị vô hướng nếu là đồ thị vô hướng và tồn tại một cặp đỉnh trong V có nhiều hơn một cạnh nối. Cạnh e1∈E, e2∈E được gọi là cạnh bội nếu chúng cùng chung cặp đỉnh.

**Giả đồ thị vô hướng.** Đồ thị G = <V, E> bao gồm V là tập đỉnh, E là họ các cặp không có thứ tự gồm hai phần tử (hai phần tử không nhất thiết phải khác nhau) trong V được gọi là các cạnh. Cạnh e được gọi là khuyên nếu có dạng e =(u, u), trong đó u là đỉnh nào đó thuộc V.

**Đơn đồ thị có hướng**. Đồ thị G = <V, E> bao gồm V là tập các đỉnh, E là tập các cặp có thứ tự gồm hai phần tử của V gọi là các cung. Giữa hai đỉnh bất kỳ của G tồn tại nhiều nhất một cung.

**Đa đồ thị có hướng**. Đồ thị G = <V, E> bao gồm V là tập đỉnh, E là cặp có thứ tự gồm hai phần tử của V được gọi là các cung. Hai cung e1, e2 tương ứng với cùng một cặp đỉnh được gọi là cung lặp.

**Giả đồ thị có hướng.** Đa đồ thị G = <V, E>, trong đó V là tập đỉnh, E là tập các cặp không có thứ tự gồm hai phần tử (hai phần tử không nhất thiết phải khác nhau) trong V được gọi là các cung. Cung e được gọi là khuyên nếu có dạng e =(u, u), trong đó u là đỉnh nào đó thuộc V.

## Một số thuật ngữ trên đồ thị vô hướng

**Đỉnh kề**. Hai đỉnh _u_ và _v_ của đồ thị vô hướng _G = <V, E>_ được gọi là kề nhau nếu ( _u,v_ ) là cạnh thuộc đồ thị _G_. Nếu _e =_ ( _u, v_ ) là cạnh của đồ thị _G_ thì ta nói cạnh này liên thuộc với hai đỉnh _u_ và _v_ , hoặc ta nói cạnh _e_ nối đỉnh _u_ với đỉnh _v_ , đồng thời các đỉnh _u_ và _v_ sẽ được gọi là đỉnh đầu của cạnh ( _u,v_ ).

**Bậc của đỉnh**. Ta gọi bậc của đỉnh _v_ trong đồ thị vô hướng là số cạnh liên thuộc với nó và ký hiệu là _deg_ ( _v_ ). Đỉnh có bậc là 0 được gọi là đỉnh cô lập. Đỉnh có đỉnh bậc 1 được gọi là đỉnh treo.

**Đường đi, chu trình**. Đường đi độ dài _n_ từ đỉnh _u_ đến đỉnh _v_ trên đồ thị vô hướng _G= <V, E>_ là dãy _x0, x1, . . ., xn-1, xn ,_ trong đó _n_ là số nguyên dương, _x0=u_ , _xn=v, (xi, xi+1)_ ∈ _E, i =0, 1, 2, . . ., n-1_. Đường đi có đỉnh đầu trùng với đỉnh cuối gọi là chu trình.

**Tính liên thông**. Đồ thị vô hướng được gọi là liên thông nếu luôn tìm được đường đi giữa hai đỉnh bất kỳ của nó.

**Thành phần liên thông**. Đồ thị vô hướng liên thông thì số thành phần liên thông là 1. Đồ thị vô hướng không liên thông thì số liên thông của đồ thị là số các đồ thị con của nó liên thông.

**Đỉnh trụ**. Đỉnh u∈V được gọi là đỉnh trụ nếu loại bỏ u cùng với các cạnh nối với u làm tăng thành phần liên thông của đồ thị.

**Cạnh cầu**. Cạnh (u,v) ∈E được gọi là cầu nếu loại bỏ (u,v) làm tăng thành phần liên thông của đồ thị.

**Đỉnh rẽ nhánh**. Đỉnh s được gọi là đỉnh rẽ nhánh (đỉnh thắt) của cặp đỉnh u, v nếu mọi đường đi từ u đến v đều qua s.

## Một số thuật ngữ trên đồ thị có hướng

**Đỉnh kề**. Nếu _e=_ ( _u,v_ ) là cung của đồ thị có hướng _G_ thì ta nói hai đỉnh _u_ và _v_ là kề nhau, và nói cung ( _u, v_ ) nối đỉnh _u_ với đỉnh _v,_ hoặc nói cung này đi ra khỏi đỉnh _u_ và đi vào đỉnh _v_. Đỉnh _u_ được gọi là đỉnh đầu, đỉnh _v_ được gọi là đỉnh cuối của cung ( _u,v_ ).

**Bán bậc của đỉnh**. Ta gọi bán bậc ra của đỉnh _v_ trên đồ thị có hướng là số cung của đồ thị đi ra khỏi _v_ và ký hiệu là _deg +_( _v_ ). Ta gọi bán bậc vào của đỉnh _v_ trên đồ thị có hướng là số cung của đồ thị đi vào _v_ và ký hiệu là _deg -_( _v_ ).

**Đường đi**. Đường đi độ dài _n_ từ đỉnh _u_ đến đỉnh _v_ trong đồ thị có hướng

_G= <V,A>_ là dãy _x0, x1, . . ., xn ,_ trong đó, _n_ là số nguyên dương, _u = x0, v = xn, (xi, xi+1)_

∈ _E._ Đường đi như trên có thể biểu diễn thành dãy các cung : _(x0, x1), (x1, x2), . . ., (xn-1, xn)._ Đỉnh _u_ được gọi là đỉnh đầu, đỉnh _v_ được gọi là đỉnh cuối của đường đi. Đường đi có đỉnh đầu trùng với đỉnh cuối ( _u=v_ ) được gọi là một chu trình. Đường đi hay chu trình được gọi là đơn nếu như không có hai cạnh nào lặp lại.

**Liên thông mạnh**. Đồ thị có hướng G=<V, E> được gọi là liên thông mạnh nếu giữa hai đỉnh bất kỳ u∈V, v∈V đều có đường đi từ u đến v.

**Liên thông yếu**. Ta gọi đồ thị vô hướng tương ứng với đồ thị có hướng G=<V, E> là đồ thị tạo bởi G và bỏ hướng của các cạnh trong G. Khi đó, đồ thị có hướng G=<V, E> được gọi là liên thông yếu nếu đồ thị vô hướng tương ứng với nó là liên thông.

**Thành phần liên thông mạnh**. Đồ thị con có hướng H =<V1, E1> được gọi là một thành phần liên thông mạnh của đồ thị có hướng G=<V, E> nếu V1⊆V, E1⊆E và H liên thông mạnh.

## Một số loại đồ thị đặc biệt

Dưới đây là một số dang đơn đồ thị vô hướng đặc biệt có nhiều ứng dụng khác nhau của thực tế.

**Đồ thị đầy đủ**. Đồ thị đầy đủ n đỉnh, ký hiệu là Kn, là đơn đồ thị vô hướng mà giữa hai đỉnh bất kỳ của nó đều có cạnh nối. Ví dụ đồ thị K3, K4, K5 trong Hình 5.1a.

**Đồ thị vòng**. Đồ thị vòng Cn (n≥3) có các cạnh (1,2), (2,3),..,(n-1,n), (n,1). Ví dụ đồ thị C3, C4, C5 trong Hình 5.1.b.

**Đồ thị bánh xe**. Đồ thị bánh xe Wn thu được bằng cách bổ sung một đỉnh nối với tất cả các đỉnh của Cn. Ví dụ đồ thị W3, W4, W5 trong Hình 5.1.c.

**Đồ thị hai phía**. Đồ thị G =<V, E> được gọi là đồ thị hai phía nếu tập đỉnh V của nó có thể phân hoạch thành hai tập X và Y sao cho mỗi cạnh của đồ thị chỉ có dạng ( _x_ , _y_ ), trong đó _x_ ∈ _X_ và _y_ ∈ _Y_. Ví dụ đồ thị K2,3, K33, K3,5 trong Hình 5.1.d.

![](images/image1.png)

**Hình 5.1**. Một số dạng đồ thị đặc biệt.

# Biểu diễn đồ thị

Để lưu trữ, xử lý hiệu quả ta cần có phương pháp biểu diễn đồ thị trên máy tính. Ba phương pháp biểu diễn thông dụng thường được ứng dụng trên đồ thị đó là: ma trận kề, danh sách cạnh và danh sách kề. Phương pháp biểu diễn cụ thể được thể hiện như dưới đây.

## Biểu diễn bằng ma trận kề

Phương pháp biểu diễn đồ thị bằng ma trận kề là phép làm tương ứng đồ thị G = <V, E> với một ma trận vuông cấp n. Các phần tử của ma trận kề được xác định như dưới đây.
$auv=I{(u,v)∈E}a_{uv} = I{(u,v) in E}$
Ví dụ với đồ thị cho bởi Hình 5.2 sẽ cho ta biểu diễn ma trận kề như sau:![](images/image2.png)![](images/image3.png)
**Hình 5.2**. Biểu diễn ma trận kề của đồ thị.

### Tính chất của ma trận kề:

  * Ma trận kề biểu diễn đồ thị vô hướng G = <V, E> là ma trận đối xứng.

  * Ma trận kề biểu diễn đồ thị có hướng G =<V, E> thường là không đối xứng.

  * Tổng các phần tử của ma trận kề biểu diễn đồ thị vô hướng G = <V, E> bằng _2.m_ , trong đó _m_ là số cạnh của đồ thị.

  * Tổng các phần tử của ma trận kề biểu diễn đồ thị có hướng G = <V, E> bằng đúng _m_ , trong đó _m_ là số cạnh của đồ thị.

  * Tổng các phần tử của hàng _u_ hoặc cột _u_ của ma trận kề biểu diễn đồ thị vô hướng G= <V, E> là bậc của đỉnh u (deg(u)).

  * Tổng các phần tử của hàng _u_ của ma trận kề biểu diễn đồ thị có hướng G= <V, E> là bán bậc ra của đỉnh u (deg+(u)).

  * Tổng các phần tử của cột _u_ của ma trận kề biểu diễn đồ thị có hướng G= <V, E> là bán bậc vào của đỉnh u (deg-(u)).


### Ưu điểm của ma trận kề:

  * Đơn giản dễ cài đặt trên máy tính bằng cách sử dụng một mảng hai chiều.

  * Dễ dàng kiểm tra được hai đỉnh _u, v_ có kề với nhau hay không bằng đúng một phép so sánh (a[u][v]≠0).


### Nhược điểm của ma trận kề:

  * Lãng phí bộ nhớ: bất kể số cạnh nhiều hay ít ta cần n2 đơn vị bộ nhớ để biểu diễn.

  * Không thể biểu diễn được với các đồ thị có số đỉnh lớn .

  * Để xem xét đỉnh đỉnh _u_ có những đỉnh kề nào cần mất n phép so sánh kể cả đỉnh u là đỉnh cô lập hoặc đỉnh treo.


## Biểu diễn đồ thị bằng danh sách cạnh

Phương pháp biểu diễn đồ thị G =<V, E> bằng cách liệt kê tất cả các cạnh của nó được gọi là phương pháp biểu diễn bằng danh sách cạnh. Đối với đồ thị có hướng ta liệt kê các cung tương ứng. Đối với đồ thị vô hướng ta chỉ cần liệt kê các cạnh (u,v)∈E mà không cần liệt kê các cạnh (v,u)∈E. Ví dụ về biểu diễn đồ thị bằng danh sách cạnh được cho trong Hình 5.3.![](images/image4.png)

**Hình 5.3**. Biểu diễn đồ thị bằng danh sách cạnh

### Tính chất của danh sách cạnh:

  * Đỉnh đầu luôn nhỏ hơn đỉnh cuối của mỗi cạnh đối với đồ thị vô hướng.

  * Đỉnh đầu không phải lúc nào cũng nhỏ hơn đỉnh cuối của mỗi cạnh đối với đồ thị có hướng.

  * Số các số có giá trị _u_ thuộc cả tập đỉnh đầu và tập đỉnh cuối các cạnh là bậc của đỉnh u đối với đồ thị vô hướng.

  * Số các số có giá trị _u_ thuộc cả tập đỉnh đầu các cạnh là bán bậc ra của đỉnh u đối với đồ thị có hướng.

  * Số các số có giá trị _u_ thuộc cả tập đỉnh cuối là bán bậc vào của đỉnh _u_ đối với đồ thị có hướng.


### Ưu điểm của danh sách cạnh:

  * Trong trường hợp đồ thị thưa (m<6n), biểu diễn bằng danh sách cạnh tiết kiệm được không gian nhớ.

  * Thuận lợi cho một số thuật toán chỉ quan tâm đến các cạnh của đồ thị.


### Nhược điểm của danh sách cạnh:

  * Khi cần duyệt các đỉnh kề với đỉnh u bắt buộc phải duyệt tất cả các cạnh của đồ thị. Điều này làm cho thuật toán có chi phí tính toán cao.


## Biểu diễn đồ thị bằng danh sách kề

Ta định nghĩa 𝐿𝑖𝑠𝑡(𝑢) = {𝑣 ∈ 𝑉: (𝑢, 𝑣) ∈ 𝐸} là danh sách các đỉnh kề với đỉnh _u_. Biểu diễn đồ thị bằng danh sách kề là phương pháp liệt kê tập đỉnh kề của mỗi đỉnh. Ví dụ về biểu diễn đồ thị bằng danh sách kề được cho trong Hình 5.4.

![](images/image5.png)
**Hình 5.4**. Biểu diễn đồ thị bằng danh sách kề.

### Tính chất của danh sách kề:

  * Lực lượng tập đỉnh kề của đỉnh _u_ là bậc của đỉnh _u_ đối với đồ thị vô hướng (deg( _u_ )=|List( _u_ )|.

  * Lực lượng tập đỉnh kề của đỉnh _u_ là bán bậc ra của đỉnh _u_ đối với đồ thị có hướng (deg+( _u_ )=|List( _u_ )|.

  * Số các số có giá trị _u_ thuộc tất cả các danh sách kề là bán bậc vào của đỉnh _u_


đối với đồ thị có hướng.

### Ưu điểm của danh sách kề:

  * Dễ dàng duyệt tất cả các đỉnh của một danh sách kề.

  * Dễ dàng duyệt các cạnh của đồ thị trong mỗi danh sách kề.

  * Tối ưu việc cài đặt một số giải thuật trên đồ thị.


### Nhược điểm của danh sách kề:

  * Khó khăn cho người học có kỹ năng lập trình yếu vì khi biểu diễn đồ thị ta phải dùng một mảng, mỗi phần tử của nó là một danh sách liên kết.

# Public_058

# Mô tả bài toán kiểm thử qua biểu đồ Venn

Kiểm thử chủ yếu liên quan tới hành vi của chương trình nơi mà hành vi phản ánh quan điểm về cấu trúc phổ biến đối với các nhà phát triển hệ thống hoặc phần mềm. Sự khác biệt là quan điểm cấu trúc tập trung vào “là cái gì”, còn quan điểm hành vi lại tập trung vào “làm gì”. Một trong những nguyên nhân gây khó cho người kiểm thử là các tài liệu cơ sở thường được viết bởi và viết cho người phát triển. Kết quả là các tài liệu này thường thiên về thông tin cấu trúc và coi nhẹ thông tin về hành vi của chương trình cần kiểm thử. Trong mục này, chúng ta sẽ phát triển một biểu đồ Venn đơn giản nhằm làm sáng tỏ một số vấn đề về kiểm thử. Chi tiết về biểu đồ Venn sẽ được trình bày trong chương 3.

![](images/image1.png)

**Hình 1.3: Các hành vi được cài đặt và được đặc tả.**

Xét một vũ trụ của hành vi chương trình cần kiểm thử, lưu ý rằng chúng ta đang quan tâm đến bản chất của việc kiểm thử. Cho trước một chương trình cùng đặc tả của nó. Gọi _S_ là tập các hành vi được đặc tả và _P_ là tập các hành vi của chương trình. Hình 1.3 mô tả mối quan hệ giữa vũ trụ các hành vi được lập trình và hành vi được đặc tả. Trong tất cả các hành vi có thể của chương trình, những hành vi được đặc tả nằm trong vòng tròn với nhãn _S_ , còn những hành vi được lập trình là ở trong vòng tròn với nhãn _P_ . Từ biểu đồ này, ta thấy rõ các bài toán mà người kiểm thử cần đối mặt là gì. Nếu có hành vi được đặc tả nhưng không được lập trình thì theo thuật ngữ trước đây, đấy là những sai lầm về bỏ quên. Tương tự, nếu có những hành vi được lập trình nhưng không được đặc tả, thì điều đó tương ứng với những sai lầm về nhiệm vụ, và chúng tương ứng với những lỗi xuất hiện sau khi đặc tả đã hoàn thành. Tương giao giữa _S_ và _P_ là phần đúng đắn, gồm có các hành vi vừa được đặc tả vừa được cài đặt. Chú ý rằng tính đúng đắn chỉ có nghĩa đối với đặc tả và cài đặt và là khái niệm mang tính tương đối.

![](images/image2.png)

**Hình 1.4: Các hành vi được cài đặt, được đặc tả và được kiểm thử.**

Vòng tròn mới (vòng tròn _T_ ) trong hình 1.4 là cho các ca kiểm thử. Lưu ý rằng tập các hành vi của chương trình nằm trọn trong vũ trụ chuyên đề của ta. Ở đây một ca kiểm thử cũng được coi là xác định một hành vi. Xét mối quan hệ giữa _S, P_ và _T_ . Có thể có các hành vi được đặc tả mà không được kiểm thử (các miền 2 và 5), các hành vi được đặc tả và được kiểm thử (các miền 1 và 4), và các ca kiểm thử tương ứng với các hành vi không được đặc tả (các miền 3 và 7).

Tương tự, có thể có các hành vi được lập trình mà không được kiểm thử (các miền 2 và 6), các hành vi được lập trình và được kiểm thử (các miền 1 và 3), và các ca kiểm thử tương ứng với các hành vi không được lập trình (các miền 4 và 7). Việc xem xét tất cả các miền này là hết sức quan trọng. Nếu có các hành vi được đặc tả mà không có các ca kiểm thử tương ứng, việc kiểm thử là chưa đầy đủ. Nếu có các ca kiểm thử tương ứng với các hành vi không được đặc tả, có thể có hai khả năng: hoặc đặc tả còn thiếu hoặc ca kiểm thử không đảm bảo. Theo kinh nghiệm, một người kiểm thử giỏi sẽ thường phát triển các ca kiểm thử thuộc loại đầu, và đấy chính là lý do người kiểm thử cần tham gia vào giai đoạn khảo duyệt đặc tả và thiết kế (xem chương 4).

Ta có thể thấy việc kiểm thử như là công việc của một nghệ nhân: người kiểm thử có thể làm gì để làm cho miền tương giao của các tập (miền 1) là lớn nhất có thể? Làm thế nào để xác định các ca kiểm thử trong tập _T_ ? Câu trả lời là các ca kiểm thử cần được xác định bởi một phương pháp kiểm thử. Chính khuôn khổ này cho phép ta so sánh tính hiệu quả của các phương pháp kiểm thử khác nhau như sẽ được giới thiệu trong các chương 5, 6 và 7.

# Việc xác định các ca kiểm thử

Có hai cách tiếp cận cơ bản để xác định các ca kiểm thử là kiểm thử chức năng hay kiểm thử hộp đen (black-box testing) và kiểm thử cấu trúc hay kiểm thử hộp trắng (white-box testing). Mỗi cách tiếp cận có các phương pháp xác định các ca kiểm thử khác nhau và được gọi chung là các phương pháp kiểm thử.

## Kiểm thử chức năng

Kiểm thử chức năng (kiểm thử hộp đen) dựa trên quan niệm rằng bất kỳ chương trình nào cũng được coi là một hàm ánh xạ các giá trị từ miền dữ liệu đầu vào tới miền dữ liệu đầu ra của nó. Khái niệm này được dùng chung trong kỹ thuật khi các hệ thống đều được coi là các hộp đen. Chính điều này dẫn đến thuật ngữ kiểm thử hộp đen, trong đó nội dung của hộp đen (việc cài đặt) không được biết hoặc không cần quan tâm, và chức năng của hộp đen được hiểu theo các dữ liệu đầu vào và dữ liệu đầu ra của nó. Trong thực tế, chúng ta thường thao tác hiệu quả với những kiến thức về hộp đen. Chính điều này là trung tâm của khái niệm định hướng đối tượng. Chẳng hạn, hầu hết mọi người lái xe thành thạo với kiến thức hộp đen.

![](images/image3.png)

**Hình 1.5: Một hộp đen kỹ thuật.**

Với cách tiếp cận của kiểm thử chức năng, để xác định các ca kiểm thử, thông tin duy nhất được dùng là đặc tả của phần mềm cần kiểm thử. Có hai lợi điểm chính của các ca kiểm thử được sinh ra bởi cách tiếp cận kiểm thử chức năng: chúng độc lập với việc phần mềm được cài đặt thế nào, và vì thế khi cài đặt thay đổi thì các ca kiểm thử vẫn dùng được, đồng thời các ca kiểm thử được phát triển song song và độc lập với việc cài đặt hệ thống. Do đó, cách tiếp cận này rút gọn được thời gian phát triển của dự án. Điểm yếu của cách tiếp cận này là các ca kiểm thử thường có thể có tính dư thừa đáng kể trong các ca kiểm thử và vấn đề hố phân cách.

Hình 1.6 mô tả các ca kiểm thử được xác định bởi các phương pháp kiểm thử chức năng khác nhau. Phương pháp A xác định một tập các ca kiểm thử lớn hơn so với phương pháp B. Lưu ý rằng đối với cả hai phương pháp này, tập các ca kiểm thử đều chứa trọn trong tập các hành vi được đặc tả.

Do các phương pháp kiểm thử chức năng đều dựa trên các hành vi đặc tả, các phương pháp này khó có thể xác định được các hành vi không được đặc tả. Trong chương 5 ta sẽ so sánh các ca kiểm thử sinh bởi các phương pháp kiểm thử chức năng khác nhau cho các ví dụ được mô tả trong chương 2.

**Hình 1.6: So sánh các phương pháp xác định các ca kiểm thử chức năng.** ![](images/image4.png)

Trong chương 5, chúng ta sẽ khảo sát các cách tiếp cận chủ yếu cho các phương pháp kiểm thử chức năng bao gồm phân tích giá trị biên, kiểm thử tính bền vững, phân tích trường hợp xấu nhất, kiểm thử giá trị đặc biệt, kiểm thử phân lớp tương đương của miền dữ liệu đầu vào, lớp tương đương của miền dữ liệu đầu ra, kiểm thử dựa trên bảng quyết định. Điều xuyên suốt trong các kỹ thuật này là tất cả đều dựa trên thông tin xác định về các thành phần đang được kiểm thử. Cơ sở toán học trình bày trong chương 3 chủ yếu được áp dụng cho cách tiếp cận kiểm thử chức năng.

## Kiểm thử cấu trúc

Kiểm thử cấu trúc (kiểm thử hộp trắng) là cách tiếp cận khác để xác định các ca kiểm thử. Biểu tượng hộp trong suốt (hộp trắng) là thích hợp cho cách tiếp cận này vì sự khác nhau cốt lõi của cách tiếp cận này so với kiểm thử hộp đen là việc cài đặt của hộp đen (mã nguồn) được cung cấp và được dùng làm cơ sở để xác định các ca kiểm thử. Việc hiểu biết được bên trong của hộp đen cho phép người kiểm thử dựa trên việc cài đặt để xác định các ca kiểm thử. Kiểm thử cấu trúc đã trở thành chủ đề của một lý thuyết tương đối mạnh. Để hiểu rõ kiểm thử cấu trúc, các khái niệm về lý thuyết đồ thị tuyến tính được trình bày trong chương 3 là cần thiết. Với những khái niệm này, người kiểm thử có thể mô tả chính xác các yêu cầu kiểm thử và hệ thống cần kiểm thử. Do có cơ sở lý thuyết mạnh, kiểm thử cấu trúc cho phép định nghĩa chính xác và sử dụng các độ đo về độ bao phủ. Các độ đo về độ phủ cho phép khẳng định tường minh phần mềm đã được kiểm thử tới mức nào và do đó giúp cho việc quản lý quá trình kiểm thử tốt hơn.

**Hình 1.7: So sánh các phương pháp xác định ca kiểm thử đối với kiểm thử cấu trúc.** ![](images/image5.png)

Hình 1.7 phản ánh các ca kiểm thử được xác định bởi hai phương pháp kiểm thử cấu trúc khác nhau. Giống như trước đây, phương pháp A xác định tập các ca kiểm thử lớn hơn so với phương pháp B. Có chắc là tập các ca kiểm thử lớn hơn là tốt hơn không? Đây là một câu hỏi thú vị và kiểm thử cấu trúc cung cấp các giải pháp để tìm câu trả lời cho vấn đề này.

Lưu ý rằng cả hai phương pháp A và B đều cho các tập các ca kiểm thử nằm trọn trong tập các hành vi được lập trình. Do các ca kiểm thử của các phương pháp này được sinh ra dựa trên chương trình nên rất khó để xác định các lỗi liên quan đến các hành vi đã được đặc tả nhưng không được lập trình. Tuy nhiên, dễ thấy rằng tập các ca kiểm thử cấu trúc là tương đối nhỏ so với tập tất cả các hành vi được lập trình.

Chúng ta sẽ tìm hiểu các so sánh đánh giá về các ca kiểm thử được sinh bởi các phương pháp kiểm thử cấu trúc khác nhau ở mục 1.4.3. Một số phương pháp kiểm thử cấu trúc (kiểm thử dòng điều khiển, kiểm thử dòng dữ liệu và kiểm thử dựa trên lát cắt) sẽ được giới thiệu chi tiết trong các chương 6 và 7.

## Tranh luận về kiểm thử chức năng so với kiểm thử cấu trúc

Cho trước hai cách tiếp cận khác nhau để xác định các ca kiểm thử, câu hỏi tự nhiên được đặt ra là phương pháp nào tốt hơn? Cho đến nay chúng ta vẫn chưa có câu trả lời thỏa đáng cho câu hỏi này.

Nói về kiểm thử cấu trúc, Robert Poston viết: công cụ này lãng phí thời gian của người kiểm thử vì từ những năm bảy mươi (của thế kỷ trước) nó chẳng trợ giúp tốt việc thực hành kiểm thử phần mềm và đừng có đưa nó vào bộ công cụ của người kiểm thử [Pos91]. Nhằm bảo vệ cho việc kiểm thử cấu trúc, Edward Miller [Mil91] viết: Độ bao phủ nhánh (một độ đo độ bao phủ của kiểm thử), nếu đạt được 85% hoặc cao hơn, có thể xác định số lỗi gấp đôi so với số lỗi phát hiện bởi kiểm thử trực quan (kiểm thử chức năng).

![](images/image6.png)

**Hình 1.8: Nguồn các ca kiểm thử.**

Biểu đồ Venn được mô tả trong hình 1.8 có thể giúp ta trả lời câu hỏi mà cuộc tranh luận này đã đề cập. Chúng ta cần khẳng định lại rằng mục đích của cả hai cách tiếp cận trên là để xác định các ca kiểm thử. Kiểm thử chức năng chỉ dùng đặc tả để xác định ca kiểm thử, trong khi kiểm thử cấu trúc dùng mã nguồn của chương trình (cài đặt) để làm cơ sở xác định các ca kiểm thử. Những bàn luận trước đây cho thấy chẳng có cách tiếp cận nào là đủ tốt.

Xét các hành vi chương trình: nếu tất cả các hành vi được đặc tả vẫn chưa được cài đặt, kiểm thử cấu trúc sẽ không thể nhận biết được điều đó. Ngược lại, nếu các hành vi được cài đặt chưa được đặc tả, điều đó chẳng khi nào có thể được phơi bày nhờ kiểm thử chức năng. Một con vi rút là một ví dụ tốt về các hành vi không được đặc tả. Câu trả lời sơ bộ cho câu hỏi trên là cả hai cách tiếp cận đều là rất cần thiết; còn câu trả lời cẩn thận hơn là cách kết hợp khôn khéo giữa hai cách tiếp cận này sẽ cung cấp niềm tin cho kiểm thử chức năng và độ đo của kiểm thử cấu trúc. Ta đã khẳng định ở trên rằng kiểm thử chức năng có khiếm khuyết về tính dư thừa và hố phân cách. Nếu kiểm thử chức năng được tiến hành kết hợp với các số đo về độ phủ của kiểm thử cấu trúc thì khiếm khuyết trên có thể được phát hiện và giải quyết.

Quan điểm biểu đồ Venn cho việc kiểm thử đặt ra câu hỏi về quan hệ giữa tập các ca kiểm thử ( _T_ ) với các tập _S_ và _P_ của các hành vi cài đặt và đặc tả như thế nào? Rõ ràng, các ca kiểm thử trong _T_ được xác định bởi phương pháp xác định ca kiểm thử được dùng. Một câu hỏi rất hay cần đặt ra là thế thì phương pháp này thích hợp và hiệu quả ra sao. Ta có thể đóng lại vòng luẩn quẩn này bằng những lời bàn trước đây. Với đường đi từ lỗi đến sai, thất bại và sự cố, nếu biết loại lỗi nào ta hay phạm, và loại sai nào hay có trong phần mềm được kiểm thử, ta có thể dùng thông tin này để lựa chọn phương pháp thích hợp để xác định các ca kiểm thử. Chính điểm này làm cho việc kiểm thử thành một nghệ thuật.

# Phân loại các lỗi và sai

Các định nghĩa về lỗi và sai được trình bày trong mục 1.1 xoay quanh sự phân biệt giữa quy trình và sản phẩm. Trong khi quy trình cho chúng ta biết cần làm điều gì đó như thế nào thì sản phẩm là kết quả cuối cùng của quy trình. Kiểm thử phần mềm và đảm bảo chất lượng phần mềm (Software Quality Assurance - SQA) gặp nhau ở điểm là SQA cố gắng cải tiến chất lượng sản phẩm bằng việc cải tiến quy trình. Theo nghĩa này thì kiểm thử là các hoạt động định hướng sản phẩm. SQA quan tâm nhiều hơn đến việc giảm thiểu lỗi trong quá trình phát triển, còn kiểm thử quan tâm chủ yếu đến phát hiện sai trong sản phẩm. Cả hai nguyên lý này đều sử dụng định nghĩa về các loại sai. Các sai được phân loại theo nhiều cách khác nhau: giai đoạn phát triển khi cái sai tương ứng xuất hiện, các hậu quả của các thất bại tương ứng, độ khó cho việc giải quyết, độ rủi ro của việc không giải quyết được, v.v. Một cách phân loại được ưa thích là dựa trên việc xuất hiện bất thường: chỉ một lần, thỉnh thoảng, xuất hiện lại hoặc lặp đi lặp lại nhiều lần. Hình 1.9 minh họa một cách phân loại sai [Bor84] dựa trên độ nghiêm trọng của hậu quả mà các lỗi gây ra.

# Public_059

# Kiểm thử tích hợp

Các chương trước chủ yếu tập trung vào các kỹ thuật kiểm thử các hàm đơn lẻ, còn gọi là kiểm thử đơn vị. Kiểm thử tích hợp tập trung vào việc kiểm thử khi ghép nối các đơn vị này, hay tổng quát hơn là các mô-đun đã được kiểm thử đơn vị. Kiểm thử ở mức này gọi là kiểm thử tích hợp. Kiểm thử tích hợp giúp kiểm tra sự tương thích giữa các mô-đun. Kiểm thử hệ thống và kiểm thử chấp thuận ở phần sau sẽ kiểm tra toàn bộ hệ thống so với đặc tả và yêu cầu của người sử dụng.
Một mô-đun phần mềm (hay còn gọi là một thành phần) là một phần tử tương đối độc lập trong một hệ thống. Khái niệm mô-đun mang tính tương đối. Mô-đun có thể đơn giản là một hàm, một thủ tục, một lớp, hay một tập các phần tử cơ bản này kết hợp với nhau
để cung cấp một dịch vụ tích hợp mới. Các mô-đun thường có giao diện rõ ràng để giao tiếp với các mô-đun khác. Một hệ thống là một tập các mô-đun kết nối với nhau theo một cách nhất định để thực hiện một mục đích đã đặt ra.
Trong các dự án lớn có hàng chục hoặc hàng trăm người lập trình, hệ thống thường được chia thành các mô-đun để nhiều nhóm cùng phát triển. Các mô-đun thường được kiểm thử độc lập và kiểm thử ở mức này gọi là kiểm thử đơn vị. Người lập trình thường chịu trách nhiệm thực hiện kiểm thử đơn vị. Các kỹ thuật kiểm thử hộp đen (kiểm thử chức năng) và kiểm thử hộp trắng (kiểm thử cấu trúc) chủ yếu để kiểm thử ở mức này. Sau khi các đơn vị được kiểm thử xong, chúng được ghép với nhau để tạo thành mô-đun lớn hơn, hay hệ thống con, hoặc thành hệ thống phần mềm tùy độ lớn và phức tạp của hệ thống. Việc ghép này không hề đơn giản vì lúc này các lỗi ở mức giao diện giữa các mô-đun có thể xảy ra. Việc kiểm tra lỗi trong quá trình ghép này là kiểm thử tích hợp và kiểm thử hệ thống. Kiểm thử tích hợp thường phải được thực hiện trước và làm trong nội bộ đội phát triển. Khi kiểm thử tích hợp đã ổn định, kiểm thử hệ thống mới được tiến hành để đảm bảo hệ thống hoạt động tốt ở môi trường thật.
Ba lý do chính chúng ta cần kiểm thử tích hợp là:

  * Các mô-đun có thể do các nhóm khác nhau làm. Dù đã có thống nhất với nhau từ trước về giao diện của các mô-đun, việc hiểu sai, nhầm lẫn, và chủ quan nhiều khi vẫn xảy ra trên thực tế. Phần sau chúng ta sẽ xem những nguyên nhân có thể gây ra lỗi giao diện này.

  * Các mô-đun thường được kiểm thử với các hàm giả trước khi tích hợp, hoặc là với hàm giả (stub), hoặc hàm giả gọi (driver). Các hàm giả (stub) chỉ trả về giá trị kết quả với một số tham số định trước, mô phỏng một vài trường hợp của hàm thật. Các hàm giả gọi (driver) gọi nhiều mô-đun khác theo


các đường đi khác nhau nên nếu hàm giả gọi này không được kiểm thử hết tất cả các đường đi thì khó có thể khẳng định việc thay hàm giả gọi bằng hàm thật chắc chắn không sinh ra lỗi.

  * Một số mô-đun bản chất là phức tạp nên dễ có lỗi hơn. Chúng ta cần xác định mô-đun gây ra lỗi nhiều nhất.


Kiểm thử tích hợp kết thúc khi toàn bộ các mô-đun được tích hợp đầy đủ với nhau, các lỗi phát hiện được sửa chữa. Khi hệ thống có nhiều mô-đun thì cũng có nhiều cách ghép chúng lại. Các cách ghép khác nhau sẽ kéo theo các phương pháp kiểm thử tích hợp khác nhau và mỗi trong chúng đều có các ưu nhược điểm. Các phần sau chúng ta sẽ xem xét các yếu tố gây lỗi tích hợp, các phương pháp ghép nối các mô-đun chính, và ưu nhược điểm của việc kiểm thử tích hợp tương ứng.

## Các loại giao diện và lỗi giao diện

Mô-đun hóa là một nguyên lý quan trọng trong thiết kế phần mềm và các mô-đun tương tác với nhau qua các giao diện để thực hiện các yêu cầu chức năng của hệ thống. Một giao diện giữa hai mô-đun cho phép một mô-đun truy cập dịch vụ cung cấp bởi mô-đun kia. Giao diện có cả cơ chế chuyển điều khiển (thực thi) và chuyển dữ liệu giữa các mô-đun. Ba loại giao diện chính chúng ta thường gặp là:

  * **Giao diện gọi hàm/thủ tục (procedure call):** một hàm trong một mô-đun gọi một hàm trong một mô-đun khác. Phía gọi sẽ chuyển điều khiển cho mô-đun được gọi. Phía gọi cũng có thể chuyển dữ liệu cho hàm được gọi. Ngược lại hàm được gọi cũng có thể chuyển dữ liệu trả về cho hàm gọi khi nó trả điều khiển về cho hàm gọi.


Trong ví dụ dưới đây, khi thực thi lệnh đầu tiên trong hàm main(), điều khiển sẽ được được chuyển cho hàm print_str() và dữ liệu là xâu ký tự "Hello␣World!" cũng được chuyển cho hàm được gọi (hàm print_str). Giao diện ở đây chính là chữ ký/khai báo hàm void print_str(char*).
**Đoạn mã 10.1: Giao diện gọi hàm/thủ tục**
# include <stdio .h>
void print_str( char* str){ printf("% s", str);
}
int main ( void ){
print_str(" Hello ␣World !"); return 0;
}

  * **Giao diện bộ nhớ chia sẻ (shared memory):** một khối bộ nhớ được chia sẻ giữa hai mô-đun. Khối bộ nhớ này có thể do một trong hai mô-đun cấp phát, hoặc cũng có thể do một mô-đun thứ ba cấp phát. Một mô-đun sẽ ghi dữ liệu lên khối bộ nhớ và mô-đun kia đọc dữ liệu từ khối bộ nhớ.


Trong ví dụ dưới đây hàm main và hàm print_str sử dụng bộ nhớ chia sẻ là biến str để trao đổi dữ liệu giữa các hàm này. Hàm main() ghi dữ liệu và hàm print_str() đọc dữ liệu. Trong trường hợp này, bộ nhớ cho biến str không được cấp phát mà sử dụng hằng ký tự.
**Đoạn mã 10.2: Giao diện bộ nhớ chia sẻ**
# include <stdio .h> char* str;
void print_str ()
{
printf("% s", str);
}
int main ( void )
{
str = " Hello ␣World !"; print_str ();
return 0;
}

  * **Giao diện truyền thông điệp (message passing):** một mô-đun tạo một thông điệp và gửi thông điệp đó cho một mô-đun khác. Dạng này rất phổ biến trong các hệ thống có nhiều tiến trình, khách-chủ hay các hệ thống trên nền Web, dịch vụ Web.


Trong Đoạn mã 10.3 chương trình tạo một đường ống (bằng hàm pipe()) để tiến trình cha liên lạc với tiến trình con (sinh ra bởi hàm fork()). Sau khi sinh ra tiến trình con, tiến trình cha truyền một xâu ký tự vào đường ống và tiến trình con sử dụng vòng lặp để đọc dữ liệu từ đường ống và in ra màn hình.
Lỗi giao diện là lỗi gắn với các cấu trúc tồn tại bên ngoài môi trường của mô-đun nhưng được mô-đun đó sử dụng [BP84]. Một số lỗi giao diện này được phân loại như sau [PE85]:

  1. _Không đủ chức năng:_ lỗi này do một mô-đun giả thiết sai về mô-đun kia. Mô-đun cung cấp dịch vụ không hoạt động như mô-đun sử dụng mong đợi - cố tình hoặc ngoài ý muốn của người lập trình mô-đun cung cấp dịch vụ.


  1. _Thay đổi tính năng:_ một mô-đun được sửa đổi nhưng các mô- đun sử dụng nó không được điều chỉnh theo nên chức năng của hệ thống bị ảnh hưởng.


**Đoạn mã 10.3: Giao diện truyền thông điệp**
_// ----------------------------------------------_
_// Excerpt from " Linux Programmer’s Guide - Chapter~6"_
_//( C) opyright 1994 -1995 , Scott Burkett_
_// ----------------------------------------------_
# include <stdio .h> # include <unistd .h>
# include <sys / types .h>
int main ( int argc , char* argv [] ) { int fd [2], nbytes ;
pid_t childpid ;
char string [] = " Hello , ␣world !\ n", readbuffer [80];
pipe ( fd );
_// fd [0] is opened for reading ( input side);_
_// fd [1] is opened for writing ( output side)._
if (( childpid = fork ()) == -1) { perror( " fork " );
exit( 1 );
}
if ( childpid == 0) {
_// child closes input side of pipe , & writes_
close ( fd [0]);
_// Send " string" through the out. side of pipe_
write ( fd [1], string , ( strlen ( string )+ 1 ));
}
else {
_// parent proc. closes out. side of pipe ,\ & reads_
close ( fd [1]);
_// Read in a string from the pipe_
nbytes = read ( fd [0], readbuffer , sizeof( readbuffer ));
_// Print the obtained string_
printf(" parent: received ␣string :\% s", readbuffer );
}
return 0;
}

  1. _Sử dụng giao diện không đúng:_ một mô-đun đã sử dụng không đúng giao diện của mô-đun được gọi. Với giao diện hàm việc sử dụng sai này có thể do truyền tham số không đúng thứ tự.


  1. _Hiểu giao diện không đầy đủ:_ một mô-đun khi thiết kế đã giả thiết một số điều kiện của tham số đầu vào, nhưng phía gọi lại không để ý đến giả thiết này nên đã truyền các tham số nằm ngoài giả thiết. Ví dụ hàm tìm kiếm nhị phân giả sử đầu vào là một mảng được sắp, nhưng phía gọi không sắp xếp mảng này trước khi gọi thì lỗi xảy ra thuộc kiểu này.


  1. _Không xử lý lỗi trả về:_ một mô-đun được gọi có thể trả về một mã lỗi nhưng mô-đun gọi lại không kiểm tra lỗi, coi nó là kết quả. Hoặc mô-đun được gọi bổ sung thêm mã lỗi trả về nhưng mô-đun gọi chưa kịp biết/sửa.


  1. _Hiệu ứng phụ với tham số hoặc tài nguyên:_ một mô-đun có thể sử dụng tài nguyên không mô tả trong giao diện. Ví dụ một mô-đun sử dụng file tạm tên là "temp", nhưng khi tích hợp một mô-đun khác cũng sử dụng file tạm với tên này sẽ gây lỗi xung đột. Hay ví dụ hàm strdup trong ngôn ngữ C cấp phát bộ nhớ mới và trả về con trỏ đến xâu mới. Nếu bên gọi không giải phóng bộ nhớ thì lỗi dò bộ nhớ sẽ xảy ra.


  1. _Các vấn đề phi chức năng:_ Các yêu cầu phi chức năng như tốc độ chỉ được nêu ra khi chúng có thể gây vấn đề. Các yêu cầu này ngay cả khi không nêu ra thì chúng ta vẫn ngầm định là chúng phải chạy không quá chậm. Khi tích hợp các vấn đề này mới thường phát sinh.


## Tích hợp dựa trên cấu trúc mô-đun

Một chương trình trong ngôn ngữ C hay Java thường có hàm main, hàm này sẽ gọi các hàm khác trong thân của nó. Các hàm khác này
lỗi gọi tiếp các hàm khác nữa. Rộng hơn là một hệ thống có nhiều mô-đun thì theo cấu trúc phân cấp này chúng tạo thành một cấu trúc hình cây như trong Hình 10.1. Sơ đồ lớp trong nhiều ngôn ngữ hướng đối tượng sẽ có cấu trúc này.
![](images/image1.png)
**Hình 10.1: Cấu trúc phân cấp mô-đun.**
Khi đã có các đơn vị là đỉnh của cây chúng ta có thể lắp dần chúng với nhau và kiểm thử tích hợp trong quá trình lắp. Thứ tự lắp các mô-đun vào cây sẽ dẫn đến các chiến lược kiểm thử tương ứng. Có bốn cách ghép thông dụng là từ trên xuống (top down), dưới lên (bottom up), song song của cả trên xuống và dưới lên gọi là bánh kẹp (sandwich), và một cách đơn giản khác là chỉ kiểm thử sau khi đã ghép hết tất cả các mô-đun (bigbang). Nhược điểm của kiểm thử theo kiểu bigbang là khi có lỗi thì chúng ta rất khó để xác định vị trí của lỗi (khó định vị lỗi). Nếu chúng ta ghép dần dần và kiểm thử luôn thì khi có lỗi xuất hiện, chúng ta tập trung vào các mô-đun vừa ghép với nhau sẽ dễ xác định lỗi hơn. Chú ý ở đây chúng ta giả sử các mô-đun đã được kiểm thử đơn vị xong, nên kiểm thử tích hợp có thể coi là kiểm thử giao diện giữa các mô-đun.

# Public_060

Chương này trình bày một số ví dụ mà sẽ được dùng trong các chương tiếp theo nhằm minh họa cho các phương pháp kiểm thử. Các ví dụ này gồm: bài toán tam giác và hàm NextDate tương đối phức tạp về mặt lôgic. Các ví dụ này liên quan đến một số vấn đề mà người kiểm thử sẽ gặp trong quá trình kiểm thử. Khi bàn về kiểm thử tích hợp và kiểm thử hệ thống trong chương 10, ta sẽ dùng ví dụ về một phiên bản đơn giản của máy rút tiền tự động (ATM).
Trong chương này các ví dụ mức đơn vị, cài đặt bằng ngôn ngữ C, sẽ được trình bày cho mục đích kiểm thử cấu trúc. Các mô tả mức hệ thống của máy ATM dưới dạng một tập các sơ đồ dòng dữ liệu và máy hữu hạn trạng thái sẽ được trình bày trong các chương tiếp theo.

# Bài toán tam giác

Kể từ ngày được công bố lần đầu dưới dạng một ví dụ của kiểm thử cách đây 30 năm [Gru73], bài toán tam giác đã được nhắc tới trong nhiều bài báo và sách về kiểm thử, chẳng hạn trong các tài liệu [Gru73, BL75, Mye75, S.82, AJ83, AJ84, Mal87, Bil88].

## Phát biểu bài toán

Bài toán tam giác nhận ba số nguyên làm các dữ liệu đầu vào; các dữ liệu này là số đo các cạnh của một tam giác. Đầu ra của chương trình là loại của tam giác xác định bởi ba cạnh ứng với các số đo này: tam giác đều, tam giác cân, tam giác thường, hoặc không là tam giác. Ta sẽ dùng các từ tiếng Anh làm dữ liệu đầu ra tương ứng cho các loại này như lấy từ ví dụ nguyên thủy: Equilateral, Isosceles, Scalene, hoặc NotATriangle. Bài toán này đôi khi được mở rộng với đầu ra thứ năm là tam giác vuông (right triangle). Trong các bài tập, ta sẽ dùng bài toán mở rộng như vậy.

## Nhận xét

Một trong các lý do làm bài toán này được sử dụng rất phổ biến có thể là vì nó tiêu biểu cho việc định nghĩa không đầy đủ làm phương hại đến việc trao đổi thông tin giữa khách hàng, người phát triển và người kiểm thử. Đặc tả này giả thiết rằng người phát triển biết các chi tiết về tam giác, đặc biệt tính chất sau của tam giác: tổng của hai cạnh bất kỳ cần thực sự lớn hơn cạnh còn lại. Nếu _a, b_ và _c_ ký hiệu cho ba cạnh của tam giác thì tính chất trên được biểu diễn chính xác bằng ba bất đẳng thức toán học _a < b_ \+ _c_ , _b < a_ \+ _c_ và _c < a_ \+ _b_. Nếu bất kỳ một trong ba bất đẳng thức này không được thỏa mãn thì _a, b_ và _c_ không tạo thành ba cạnh của một tam giác. Nếu cả ba cạnh đều bằng nhau, chúng tạo thành tam giác đều, nếu chỉ có một cặp cạnh bằng nhau, chúng tạo thành tam giác cân và nếu không có cặp cạnh nào bằng nhau thì chúng là độ dài ba cạnh của một tam giác thường. Một người kiểm thử giỏi có thể làm rõ ý nghĩa bài toán này hơn nữa bằng việc đặt giới hạn cho các độ dài của các cạnh. Ví dụ, câu trả lời nào cho trường hợp khi đưa vào
chương trình ba số _−_ 5 _, −_ 4 và _−_ 3? Ta sẽ đòi hỏi là các cạnh phải ít nhất là bằng 1, và khi đó ta cũng có thể khai báo giới hạn của cận trên, chẳng hạn 20000.

## Cài đặt truyền thống

Cài đặt truyền thống của ví dụ cổ điển này có kiểu tựa FORTRAN [S.82]. Tuy nhiên, chúng tôi chuyển cài đặt của ví dụ này sang ngôn ngữ C để thống nhất với các ví dụ khác trong giáo trình này. Sơ đồ khối của ví dụ này được biểu thị trong hình 2.1. Các số của khối trong sơ đồ này tương ứng với các chú giải trong chương trình sau đây. Một cài đặt có cấu trúc hơn sẽ được cho trong mục 2.1.4.
Biến match được dùng để ghi nhận sự bằng nhau giữa các cặp cạnh. Nếu hai cạnh bằng nhau, chẳng hạn _a_ = _c_ , thì chỉ cần so sánh _a_ \+ _c_ với _b_ (do _b >_ 0, _a_ \+ _b > c_ sẽ phải thỏa mãn vì _a_ = _c_ ). Nhờ quan sát này, chúng ta có thể rút gọn số các so sánh cần làm. Cái giá phải trả cho tính hiệu quả này chỉ là sự rõ ràng và dễ kiểm thử!.
Trong các chương tiếp theo, ta sẽ thấy lợi thế của phiên bản này khi bàn đến các đường đi thực thi được của chương trình. Đó là lý do tốt nhất để giữ lại bản này.
int main(){
int a, b, c, match;
printf("Enter 3 sides (a, b, c) of a triangle \n"); printf("a = ");
scanf("%d",&a);
printf("b = ");
scanf("%d",&b);
printf("c = ");
scanf("%d",&c);
printf ("Side A is %d\n", a); printf ("Side B is %d\n", b);
![](images/image1.png)
**Hình 2.1: Sơ đồ khối cho cài đặt chương trình tam giác truyền thống.**
printf ("Side C is %d\n", c); match = 0;
if(a == b) {1}
match = match + 1; {2}
if(a == c) {3}
match = match + 2; {4}
if(b == c) {5}
match = match + 3; {6}
if(match == 0) {7}
if((a+b) <= c) {8}
printf("Not a Triangle"); {12.1} else if((b+c) <= a) {9}
printf("Not a Triangle"); {12.2} else if((a+c) <= b) {10} printf("Not a Triangle"); {12.3}
else printf("Triangle is Scalene");{11}
else
if(match == 1) {13}
if((a+c) <= b) {14}
printf("Not a Triangle"); {12.4} else printf("Triangle is Isosceles"); {15.1}
else
if(match == 2) {16}
if((a+c) <= b) {17}
printf("Not a Triangle"); {12.5}
else printf("Triangle’s Isoscel.");{15.2} 
else if(match == 3) {18} if((b+c) <= a) {19}
printf("Not a Triangle"); {12.6} else
printf("Triangle’s Isoscel.");{15.3} 
else printf("Triangle’s Equilat."); {20}
return 0;
}//the end.
Lưu ý là có sáu cách để đi đến nút “Not A Triangle” (12.1 – 12.6) và có ba cách để đi đến nút “Isosceles” (15.1 – 15.3).

## Cài đặt có cấu trúc

Hình 2.2 là một mô tả sơ đồ dòng dữ liệu của chương trình tam giác. Ta có thể cài đặt bằng một chương trình chính và bốn thủ tục. Vì ta sẽ dùng ví dụ này cho việc kiểm thử đơn vị, bốn thủ tục đã được kết hợp thành một chương trình C. Các dòng chú giải liên kết các đoạn mã với việc phân rã cho trong hình 2.2.
int main(){
int a, b, c, IsATriangle;
//Function 1: Get Input
printf("Enter 3 sides (integers) of a triangle"); printf("a = ");
scanf("%d",&a);
printf("b = ");
scanf("%d",&b);
printf("c = ");
scanf("%d",&c);
printf ("Side A is %d\n", a); printf ("Side B is %d\n", b); printf ("Side C is %d\n", c);
//Function 2: Is A Triangle?
if((a < b + c) && (b < a + c) && (c < a + b)) IsATriangle = 1;
else IsATriangle = 0;
//Function 3: Determine Triangle Type if(IsATriangle)
if((a == b) && (b == c)) printf("Triangle is Equilateral");
else if((a != b) && (a != c) && (b != c))
printf("Triangle is Scalene"); else printf("Triangle is Isosceles");
else printf("Not a Triangle");
return 0;
}//the end
Lưu ý: Function 4 và Output Controller đã được kết hợp thành các lệnh trong Function 3.
**Hình 2.2: Sơ đồ dòng dữ liệu cho cài đặt có cấu trúc của chương trình tam giác.** ![](images/image2.png) **  
**

# Hàm NextDate (ngày kế tiếp)

Độ phức tạp của chương trình tam giác nằm ở các mối quan hệ giữa dữ liệu đầu vào và dữ liệu đầu ra. Hàm NextDate nhằm minh họa một loại độ phức tạp khác: mối quan hệ giữa các biến đầu vào.

## Phát biểu bài toán

NextDate là một hàm có ba biến biểu diễn ngày, tháng và năm là day, month và year. Hàm này trả về ngày kế tiếp của ngày đầu vào. Các biến day, month, year có các giá trị số thỏa mãn các ràng buộc: 1 _≤_ day _≤_ 31 _,_ 1 _≤_ month _≤_ 12 _,_ 1812 _≤_ year _≤_ 2012.

## Nhận xét

Có hai nguyên nhân tạo nên độ phức tạp của hàm NextDate: độ phức tạp nêu trong các ràng buộc trên đây của miền dữ liệu đầu vào, và quy tắc phân biệt giữa năm nhuận và năm không nhuận. Do trung bình một năm có 365 _,_ 2422 ngày, năm nhuận được dùng để giải quyết ngày “vượt trội”. Nếu ta chấp thuận cứ bốn năm lại có một năm nhuận thì sẽ có một sai số nhỏ. Lịch Gregorian (đề xuất năm 1582 bởi Giáo hoàng Gregory) giải quyết vấn đề này bằng cách điều chỉnh các năm nhuận theo năm thế kỷ (những năm chia hết cho 100). Do đó, một năm là nhuận nếu nó chia hết cho 4 nhưng không là năm thế kỷ. Các năm thế kỷ là nhuận khi và chỉ khi nó là bội của 400 [Ing61, fS91]. Do đó các năm 1992, 1996 và 2000 là năm nhuận, nhưng năm 1900 lại không phải là năm nhuận.
Hàm NextDate cũng minh họa một khía cạnh của kiểm thử phần mềm. Ta thường thấy các ví dụ về luật Zipf - nói rằng 80% các hoạt động xảy ra tại chỉ 20% của không gian. Ta cũng thấy ở đây phần lớn mã nguồn (80% các hoạt động) được dành cho các năm nhuận (20% của không gian).

# Public_061

Chương này giới thiệu các kỹ thuật khảo sát đặc tả và mã nguồn. Mã nguồn được phát triển dựa trên đặc tả và vì thế việc khảo sát đặc tả cần được tiến hành trước khi phát triển mã nguồn để tránh các rủi ro về các lỗi có thể có trong đặc tả về sản phẩm phần mềm. Vì đặc tả không thể thực thi được trên máy nên chúng ta chỉ có thể phát hiện các lỗi bằng các kỹ thuật khảo sát đặc tả. Tuy nhiên, mã nguồn thì có thể thực thi được và có thể được kiểm thử thông qua việc chạy trên máy. Vì vậy, liệu chúng ta có cần phải khảo sát mã nguồn trước không? Câu trả lời là rất cần vì khảo sát giúp ta phát hiện các lỗi sớm, các lỗi về lôgic, các lỗi về cấu trúc và giúp đề xuất các ca kiểm thử hiệu quả hơn. Khảo sát mã nguồn và không tiến hành phần mềm để phát hiện lỗi trong quá trình phát triển phần mềm được gọi là kiểm thử hộp trắng tĩnh (static white-box testing). Đây là một kỹ thuật kiểm thử bổ sung vào các kỹ thuật kiểm thử khác để đảm bảo chất lượng phần mềm. Còn khảo sát đặc tả được liệt vào phạm trù của kiểm thử hộp đen tĩnh (static black-box testing) vì việc này thường được tiến hành khi chưa có mã nguồn

# Khảo sát đặc tả

Đặc tả phần mềm là một tài liệu quan trọng, mô tả các chức năng mà phần mềm cần có cũng như các ràng buộc mà phần mềm cần thỏa mãn. Tài liệu này được tạo ra từ nhiều nguồn khác nhau như thông qua các nghiên cứu về nhu cầu sử dụng của người dùng, về các biểu mẫu, về thị trường, v.v. Việc tài liệu này được tạo ra thế nào và viết ra dưới dạng nào không phải là mối quan tâm của người kiểm thử, miễn là nó đã được đúc kết thành một tài liệu mô tả sản phẩm để phát triển và người kiểm thử sẽ tiến hành các khảo sát trên tài liệu này để tìm các lỗi đặc tả có thể có. Cũng có trường hợp đặc tả không được viết ra. Trong trường hợp này, nó ở trong đầu của người thiết kế và lập trình, và người kiểm thử phải khảo sát các tài liệu này bằng việc phỏng vấn họ. Mục này giới thiệu hai kỹ thuật khảo sát đặc tả là duyệt đặc tả mức cao và duyệt đặc tả mức thấp nhằm nâng cao chất lượng của các đặc tả phần mềm. Đây là những công việc đầu tiên và không thể thiếu trước khi tiến hành các hoạt động đảm bảo chất lượng về sau.

## Tiến hành duyệt đặc tả mức cao

Định nghĩa một sản phẩm phần mềm là một việc khó. Đặc tả thường liên quan đến nhiều thứ chưa biết, việc xây dựng đặc tả lấy vô số đầu vào thay đổi, kết hợp chúng với nhau để tạo nên một tài liệu mô tả sản phẩm mới. Quá trình này là khoa học không chính xác và rất dễ mắc sai lầm.

Bước thứ nhất để kiểm thử đặc tả không phải đi vào chi tiết ngay để tìm lỗi mà là xem xét nó từ mức cao. Hãy khảo sát đặc tả để tìm các lỗi cơ bản lớn, những lỗi về bỏ sót trước đã. Việc xem xét đặc tả lúc này là theo quan điểm nghiên cứu nhiều hơn là kiểm thử. Chỉ khi đã hiểu những “tại sao” và “làm thế nào” ở đằng sau đặc tả, bạn mới có thể phản biện tốt các chi tiết trong nó. Sau đây là các kỹ thuật để tiến hành duyệt đặc tả mức cao.

### Hãy là khách hàng của sản phẩm

Khi nhận một tài liệu đặc tả để kiểm thử, điều dễ nhất người kiểm thử cần làm là hãy giả định mình là khách hàng của sản phẩm. Vì thế, trước hết cần tìm hiểu ai sẽ là khách hàng của sản phẩm. Hãy nói chuyện với những người chào hàng và ma-ket-ting cho sản phẩm để tìm hiểu về người dùng cuối cùng của sản phẩm. Nếu sản phẩm là trung gian trong một dự án phần mềm khác, hãy tìm hiểu ai sẽ dùng nó và nói chuyện với họ.

Điều quan trọng là cần phải hiểu khách hàng chờ đợi gì ở sản phẩm này. Thỏa mãn yêu cầu người dùng là yếu tố chất lượng quan trọng nhất. Để hiểu yêu cầu người dùng không nhất thiết phải là một chuyên gia trong lĩnh vực ứng dụng. Tuy nhiên, hiểu biết chút ít về nó sẽ giúp cho việc kiểm thử tốt hơn.

Không được giả thiết bất cứ cái gì khi tìm hiểu về đặc tả. Khi ta khảo sát một phần của đặc tả và không hiểu thì không được cho là nó đúng. Ta sẽ dùng đặc tả để thiết kế các ca kiểm thử sau này. Vì thế, nếu không hiểu được đặc tả thì sẽ không thiết kế tốt các ca kiểm thử. Xem xét đặc tả theo quan điểm người dùng giúp ta phát hiện những lỗi bỏ sót hoặc sai với yêu cầu của họ. Một điều cần lưu ý là tính an ninh và bảo mật thường được giả thiết bởi người dùng. Khi giả định là người dùng, người kiểm thử không được bỏ qua yêu cầu này.

### Hãy nghiên cứu các chuẩn và hướng dẫn hiện hành

Trên thế giới đã có nhiều nghiên cứu về cách con người sử dụng máy tính, và hiện nay đã có những chuẩn cả về phần cứng lẫn phần mềm về giao diện với người sử dụng, tương tác người máy, v.v. Vì thế, người phát triển phần mềm tốt nhất hãy tuân thủ nghiêm ngặt các chuẩn này. Các chuẩn về tương tác người máy được cải tiến để đáp ứng tốt nhất các yêu cầu của người dùng. Sau đây là một số chuẩn có thể nghiên cứu để áp dụng trong đặc tả phần mềm:  
**Hợp thức các thuật ngữ và quy ước.** Nếu phần mềm được làm riêng cho một công ty nào đó hãy sử dụng các thuật ngữ và quy ước của họ.

  * **Yêu cầu công nghiệp.** Trong mỗi lĩnh vực ứng dụng như y tế, dược phẩm, tài chính, v.v. đều có các chuẩn riêng và nghiêm ngặt của họ mà phần mềm phải tuân thủ.

  * **Chuẩn quy định bởi chính phủ.** Chính phủ có những quy định, đặc biệt trong các lĩnh vực quốc phòng, an ninh và quản lý mà phần mềm phải tuân thủ.

  * **Giao diện đồ họa với người sử dụng (GUI).** Các phần mềm chạy trong Windows hoặc Macintosh phải tuân thủ các quy định về giao diện đồ họa của các hệ điều hành này.

  * **Chuẩn bảo mật.** Phần mềm có thể phải thỏa mãn một số quy định về bảo mật mà cần phải được chứng nhận và cấp phép.


Người kiểm thử cần nắm được các chuẩn này để kiểm thử xem phần mềm có thỏa mãn hay không, có gì bị bỏ qua hay không. Các chuẩn này được coi là một phần của đặc tả khi thẩm định phần mềm.

### Hãy xem xét và kiểm thử các phần mềm tương tự

Một trong các phương pháp để hiểu phần mềm của ta sẽ như thế nào là nghiên cứu các sản phẩm tương tự. Đó có thể là sản phẩm cạnh tranh hoặc sản phẩm nào đó giống như sản phẩm ta đang phát triển. Rất có thể điều đó đã được làm bởi người quản lý dự án hoặc chính người viết đặc tả cho sản phẩm ta đang phát triển. Các phần mềm không thể giống hệt nhau (là lý do để ta xây dựng sản phẩm tương tự), nhưng việc nghiên cứu các sản phẩm tương tự này giúp ta xây dựng cách tiếp cận kiểm thử sản phẩm của mình.

Những điểm cần tìm kiếm khi xem xét các sản phẩm tương tự bao gồm:

Ôm

  * **Kích cỡ.** Các đặc trưng sẽ nhiều hơn hay ít hơn? Chương trình sẽ ít hay nhiều lệnh hơn, việc kiểm thử có bị ảnh hưởng bởi kích cỡ không?


  * **Độ phức tạp.** Tương tự như kích cỡ, độ phức tạp sẽ cao hơn hay thấp hơn, và điều đó ảnh hưởng thế nào đến kiểm thử?


  * **Tính khả kiểm thử.** Liệu ta có đủ tài nguyên, thời gian và trình độ để kiểm thử phần mềm như vậy?


  * **Chất lượng và độ tin cậy.** Liệu phần mềm này đại diện cho chất lượng của phần mềm đang xây dựng, độ tin cậy sẽ cao hơn hay thấp hơn?


  * **Tính bảo mật.** Phần mềm cạnh tranh này có tính bảo mật so với sản phẩm ta đang phát triển thế nào?


Ta sẽ thu được nhiều kinh nghiệm để khảo sát đặc tả của sản phẩm của mình bằng việc xem xét các vấn đề trên.

## Các kỹ thuật kiểm thử đặc tả ở mức thấp

Sau khi đã hoàn thành việc khảo sát đặc tả bậc cao, ta hiểu rõ hơn về sản phẩm của mình và những yếu tố bên ngoài ảnh hưởng đến thiết kế của sản phẩm phần mềm. Khi được trang bị những thông tin này, chúng ta sẽ tiếp tục khảo sát đặc tả ở mức thấp và chi tiết hơn. Mục này sẽ giải thích các chi tiết cần tiến hành nhằm đạt được mục tiêu này.

### Danh sách các hạng mục cần thẩm định về các thuộc tính của đặc tả

Một đặc tả sản phẩm phần mềm được xây dựng tốt cần thỏa mãn tám thuộc tính sau đây:

  * **Đầy đủ.** Liệu đặc tả còn thiếu cái gì không? Đã đủ chi tiết chưa? Liệu nó đã bao gồm mọi điều cần thiết để không phụ thuộc vào tài liệu khác?

  * **Trúng đích.** Liệu nó đã cung cấp lời giải đúng đắn cho bài toán, liệu nó đã xác định đầy đủ các mục tiêu và không có lỗi.

  * **Chính xác, không nhập nhằng và rõ ràng.** Mô tả có chính xác không, có rõ ràng và dễ hiểu không, liệu còn có gì là nhập nhằng với ý nghĩa không xác định?

  * **Tương thích.** Các đặc trưng và chức năng được mô tả có bị xung đột với nhau không?

  * **Hợp lệ.** Các khẳng định có thực sự cần thiết để mô tả đặc trưng sản phẩm không? Có gì thừa không? Có thể truy ngược về yêu cầu của người dùng không?

  * **Khả thi.** Liệu đặc tả có thể được cài đặt trong khuôn khổ nhân lực, công cụ, tài nguyên, thời gian và kinh phí cho phép hay không?

  * **Phi mã lệnh.** Trong đặc tả không được dùng các câu lệnh hoặc thuật ngữ cho người lập trình. Ngôn ngữ dùng trong đặc tả phải là phổ biến với người dùng.

  * **Khả kiểm thử.** Liệu các đặc trưng có thể kiểm thử được? Liệu đã cung cấp đủ thông tin để có thể kiểm thử và xây dựng các ca kiểm thử?


Khi xây dựng đặc tả phần mềm, hãy duyệt đặc tả (văn bản, hình vẽ, v.v.) và đánh giá xem nó có thỏa mãn các thuộc tính nêu trên chưa.

### Danh sách các hạng mục cần thẩm định về các thuật ngữ của đặc tả

Bên cạnh danh sách các thuộc tính trên đây là danh sách các từ hay có vấn đề cần tìm trong đặc tả khi phản biện. Sự xuất hiện của các từ này có thể tiết lộ rằng các đặc trưng được mô tả chưa được suy nghĩ thấu đáo và không gặp đủ các thuộc tính trên đây. Hãy tìm các từ này trong đặc tả và xem xét cẩn thận xem có lỗi ở đó không.

  * **Luôn luôn, mỗi một, tất cả, không có, không bao giờ.** Những từ như vậy mô tả sự tuyệt đối và chắc chắn. Hãy xét xem tình trạng có đúng như vậy không, có trường hợp nào vi phạm các khẳng định đó hay không.


  * **Tất nhiên, do đó, rõ ràng là, hiển nhiên là.** Các từ này được dùng để thuyết phục người khác chấp nhận cái gì đó. Đừng có rơi vào các bẫy đó.


  * **Nào đó, đôi khi, thông thường, thường gặp, hầu hết.** Các từ này là nhập nhằng, không có nghĩa rõ ràng và không thể kiểm thử, chẳng hạn bạn phải kiểm thử tính “đôi khi” thế nào?


  * **Vân vân, chẳng hạn, như vậy.** Các từ này thường mô tả thứ mà không thể kiểm thử được.


  * **Tốt, nhanh, rẻ, hiệu quả, ổn định.** Những từ không định lượng như vậy sẽ mô tả các hạng mục không thể kiểm thử được nếu không được làm chi tiết hóa sau này.


  * **Xử lý, từ chối, bỏ qua, bị khử.** Những thuật ngữ này thường dấu trong nó những chức năng cần phải đặc tả đầy đủ.


  * **Nếu ... thì (thiếu trái lại).** Trường hợp “trái lại” có thể bị bỏ quên. Hãy tránh các khẳng định như vậy.


Trên đây là kỹ thuật kiểm thử hộp đen tĩnh, tức là phản biện đặc tả của sản phẩm, tìm xem đặc tả có lỗi không. Khi đặc tả đã được hoàn thành và đã được phản biện, mã nguồn của chương trình được phát triển dựa trên đặc tả này. Bây giờ, chúng ta sẽ sử dụng kỹ thuật tương tự để phản biện/khảo sát mã nguồn.

# Khảo sát mã nguồn

Mục này giới thiệu các kỹ thuật cơ sở để tiến hành kiểm chứng thiết kế và mã nguồn của phần mềm. Nội dung chính của mục này bao gồm việc phân tích lợi ích của công việc, các kiểu khảo sát mã nguồn, một số hướng dẫn về chuẩn lập trình, và cách chung để khảo sát mã nguồn nhằm tìm lỗi.

## Khảo sát thiết kế và mã nguồn hay là việc kiểm thử hộp trắng tĩnh

Kiểm thử tĩnh tức là việc kiểm thử chỉ gồm việc khảo sát mà không cần tiến hành chương trình, còn kiểm thử hộp trắng là việc kiểm thử có trong tay mã nguồn của chương trình. Vì thế kiểm thử hộp trắng tĩnh chính là việc khảo sát thiết kế và mã nguồn của chương trình. Công việc này bao gồm một quy trình để khảo sát một cách cẩn thận và có phương pháp đối với thiết kế, kiến trúc và mã nguồn của phần mềm để tìm lỗi mà không cần tiến hành phần mềm. Công việc này còn có tên khác nữa là _phân tích cấu trúc_.

# Public_062

# Kiểm thử giá trị biên

Kiểm thử giá trị biên (boundary value testing) là một trong những kỹ thuật được áp dụng phổ biển nhất trong cách tiếp cận kiểm thử chức năng (kiểm thử hộp đen). Trong thực tế, các lỗi hay xảy ra ở các giá trị biên hoặc cận biên của các biến đầu vào của chương trình cần kiểm thử. Kỹ thuật kiểm thử giá trị biên được đề xuất nhằm phát hiện những lỗi này. Chúng ta sẽ coi một chương trình là một hàm toán học với đầu vào của chương trình tương ứng với các tham số của hàm và đầu ra của chương trình là giá trị trả về của hàm. Vì hàm toán học là ánh xạ từ miền xác định của hàm đến miền giá trị của hàm, chúng ta sẽ tập trung vào các giá trị biên và cận biên của hai miền đầu vào và đầu ra này của hàm để xây dựng các ca kiểm thử. Khi chúng ta dùng biên đầu ra tức là chúng ta cho các kết quả mong đợi nằm ở trên biên và cận biên đầu ra.

## Giá trị biên

Giả sử _y_ = _f_ ( _x_ 1 _, x_ 2) với _x_ 1 _, x_ 2 _, y_ ∈ N là một hàm toán học của một chương trình. Khi đó thông thường _x_ 1 và _x_ 2 có miền xác định thể hiện bằng các biên. Ví dụ:

_a_ ≤ _x_ 1 ≤ _b_ và _c_ ≤ _x_ 2 ≤ _d_

trong đó _a, b, c, d_ là các hằng số nào đó. Phần tô đậm trong hình 5.2 thể hiện miền xác định của hai biến này.

![](images/image1.png)

**Hình 5.2: Miền xác định của hàm hai biến.**

Ý tưởng kiểm thử giá trị biên xuất phát từ quan sát nhiều lỗi xảy ra với các giá trị biên này, khi chúng ta không kiểm tra khoảng giá trị hợp lệ của dữ liệu được nhập vào, hay do lỗi lập trình hoặc đặc tả làm các biểu thức điều kiện không chính xác. Ví dụ, đúng ra phải là dấu <= nhưng người lập trình hoặc đặc tả lại chỉ viết < hoặc ngược lại. Kiểm thử với các giá trị biên giúp chúng ta phát hiện các lỗi này. Trong nhiều trường hợp các biên này là ẩn, không được viết rõ ra trong yêu cầu nên lập trình viên dễ mắc lỗi không kiểm tra các giá trị đầu vào, hoặc không kiểm tra kết quả có hợp lệ không trước khi trả về.

Để tăng khả năng phát hiện lỗi, kiểm thử giá trị biên thường lấy năm ca kiểm thử cho mỗi biến là các giá trị: cực đại, cực tiểu, các giá trị cạnh chúng trong miền xác định (gọi là cận biên hoặc cạnh biên), và một giá trị ở giữa miền xác định đại diện cho giá trị thông thường. Chúng ta đánh chỉ số cho chúng lần lượt là _max_ , _min_ , _min_ +, _max_ − và _nom_. Hình 5.3 minh họa các giá trị này.

Thông thường lỗi chương trình xảy ra ngay khi có một sai sót trong phần mềm, chứ không cần kết hợp của nhiều sai sót mới gây ra lỗi. Khi đó các ca kiểm thử theo phương pháp kiểm thử giá trị biên được xây dựng bằng cách lấy một bộ giá trị _nom_ của các biến, rồi lần lượt thay mỗi giá trị đó của từng biến bằng giá trị biên và

![](images/image2.png)

**Hình 5.3: Các ca kiểm thử phân tích giá trị biên cho một hàm hai biến.**

cận biên để tạo ra ca kiểm thử mới. Ví dụ với hàm _f_ trên ta có bộ kiểm thử sau, thể hiện trên Hình 5.3.

{( _x_ 1 _nom, x_ 2 _nom_ ) _,_

( _x_ 1 _min, x_ 2 _nom_ ) _,_ ( _x_ 1 _min_ + _, x_ 2 _nom_ ) _,_ ( _x_ 1 _max−, x_ 2 _nom_ ) _,_ ( _x_ 1 _max, x_ 2 _nom_ ) _,_ ( _x_ 1 _nom, x_ 2 _min_ ) _,_ ( _x_ 1 _nom, x_ 2 _min_ +) _,_ ( _x_ 1 _nom, x_ 2 _max−_ ) _,_ ( _x_ 1 _nom, x_ 2 _max_ )}

Tổng quát hóa kiểm thử giá trị biên cho hàm _n_ biến số và mỗi biến có các giá trị biên và cận biên khác nhau ta có thể dễ thấy sẽ có 1 \+ 4 _n_ ca kiểm thử vì xuất phát từ một ca kiểm thử gồm các giá trị trung bình của các biến, ta thay nó bằng bốn giá trị biên và cận biên: _min_ , _min_ +, _max_ , và _max_ −. Với _n_ biến sẽ tạo thêm 4 _n_ bộ kiểm thử. Do đó tổng số ca kiểm thử là 1 + 4 _n_. Tuy nhiên tùy theo miền xác định của biến mà số lượng này thực tế có thể ít hơn. Ví dụ biến nguyên thuộc khoảng [1 _,_ 2] thì không có cận biên và không có giá trị ở giữa. Với cách tạo bộ kiểm thử giá trị biên này, mỗi giá trị biên và cận biên xuất hiện một lần với các giá trị trung bình của các biến còn lại, chứ không phải tổ hợp các bộ giá

trị của các biên. Tổ hợp của các biên được gọi là kiểm thử giá trị biên mạnh sẽ được thảo luận trong phần tiếp theo.

Trong thực tế, miền xác định của các biến không chỉ là các miền số, nên chúng ta cần có các vận dụng thích hợp để xác định các giá trị biên tinh tế hơn. Ví dụ trong chương trình NextDate biến tháng month có thể là số nguyên trong khoảng từ 1 đến 12. Nhưng không phải ngôn ngữ lập trình nào cũng cho phép khai báo miền xác định của biến trong khoảng này. Chúng ta cũng có thể dùng kiểu liệt kê (enumeration) để khai báo các tháng bằng tên Januray, ..., December và chúng ta vẫn có giá trị biên và cận biên. Tuy nhiên như trong ngôn ngữ lập trình Java chúng ta phải dùng biến kiểu nguyên int và không khai báo miền giá trị cho chúng được, thì chúng ta sẽ phải dùng các cận của kiểu làm biên. Trong Java, biên của số nguyên là Interger.MIN_VALUE và Interger.MAX_VALUE. Trong ngôn ngữ lập trình C, chúng ta cũng có các khoảng giá trị này.

Với biến kiểu Boolean, các giá trị của miền chỉ có TRUE và FALSE, chúng ta không có cận biên và giá trị ở giữa. Với kiểu xâu ký tự, mảng, hay danh sách, tập hợp (collection), chúng ta có thể dựa vào chiều dài/kích thước để làm các giá trị biên. Với các kiểu cấu trúc dữ liệu khác chúng ta có thể xây dựng các giá trị biên và cận biên dựa theo các thành phần của cấu trúc.

**Ưu nhược điểm:** Khi các biến của hàm là độc lập, không có quan hệ ràng buộc lẫn nhau, thì kiểm thử giá trị biên tỏ ra hiệu quả. Nhưng khi chúng có quan hệ phụ thuộc nào đó thì phương pháp này dễ tạo ra các ca kiểm thử không hợp lý, vì các giá trị cực đại, cực tiểu có thể không kết hợp với nhau để tạo thành ca kiểm thử hợp lệ.

Ví dụ, khi _x_ 1 và _x_ 2 của hàm _f_ trên có các ràng buộc là _x_ 1 ∈ [1 _,_ 100], _x_ 2 ∈ [1 _,_ 100] and _x_ 1 \+ _x_ 2 ≤ 120 thì một biến đạt cực đại sẽ không thể kết hợp với một biến khác ở giá trị trung bình. Nếu chúng ta xuất phát 

từ ca kiểm thử của hai giá trị trung bình (50 _,_ 50) thì khi thay giá trị đầu bằng giá trị cực đại sẽ tạo ra ca kiểm thử (100 _,_ 50). Ca kiểm thử này không thỏa mãn quan hệ _x_ 1 \+ _x_ 2 ≤ 120. Ví dụ khác với hàm NextDate thì biến ngày, tháng và năm có ràng buộc. Một số tháng có 31 ngày, một số lại có 30 ngày. Năm nhuận lại có ràng buộc với số ngày trong tháng hai. Nếu không xét sự phụ thuộc này kiểm thử giá trị biên không tạo ra được ca kiểm thử ngày 28 tháng 2 năm 2012, vì 28 không là biên và cận biên của khoảng ngày từ 1 đến 31.

Kiểm thử giá trị biên cũng không quan tâm đến tính chất, đặc trưng của hàm, đồng thời cũng không xét đến ngữ nghĩa của biến hay quan hệ giữa các biến. Nó chỉ máy móc lấy các giá trị biên, cận biên và trung bình để tổ hợp tạo ra các ca kiểm thử. Nên khi áp dụng chúng ta cần xác định sơ bộ các tính chất trên của hàm có không.

Ưu điểm của phương pháp này là đơn giản và có thể tự động hóa việc sinh các ca kiểm thử khi chúng ta đã xác định được các biên của các biến. Với nhiều kiểu dữ liệu cơ bản có sẵn chúng ta cũng có thể xây dựng sẵn các biên này để sử dụng.

## Một số dạng kiểm thử giá trị biên

### Kiểm thử giá trị biên mạnh

Kiểm thử giá trị biên mạnh là mở rộng của kiểm thử giá trị biên bằng việc bổ sung các giá trị cận biên bên ngoài miền xác định. Ngoài 5 giá trị biên đã nêu ở phần trước chúng ta lấy thêm các giá trị cận biên ở ngoài miền xác định là _max_ \+ và _min_ − như trong Hình 5.4. Các ca kiểm thử này sẽ giúp ta kiểm tra chương trình với dữ liệu không hợp lệ, nằm ngoài khoảng mong đợi. Ví dụ khi nhập ngày 32/1/2013 chương trình cần có thông báo lỗi thích hợp.

Các ca kiểm thử mạnh này giúp chúng ta kiểm tra xem chương trình có xử lý các ngoại lệ hay kiểm tra biến đầu vào hay không.

Với các ngôn ngữ lập trình không kiểm tra kiểu khi biên dịch hay dữ liệu được nhập vào bên ngoài, do người sử dụng đưa vào hoặc lấy từ hệ thống khác, việc này là rất cần thiết. Rất nhiều lập trình viên mới vào nghề thường xuyên không kiểm tra dữ liệu đầu vào nên chương trình chỉ chạy với dữ liệu nhập đúng như suy nghĩ của người lập trình. Hậu quả của việc này không chỉ đơn thuần là chương trình bị sai, mà thường gây vi phạm bộ nhớ, dẫn đến tắt chương trình (crash), và là một trong những lỗ hổng an ninh dễ bị khai thác.

![](images/image3.png)

**Hình 5.4: Các ca kiểm thử mạnh cho hàm hai biến.**

### Kiểm thử giá trị biên tổ hợp

Ở trên, chúng ta chỉ tạo các ca kiểm thử với giá trị biên và cận biên cho từng biến. Nếu chúng ta mở rộng với hai hoặc với tất cả các biến đều được đẩy đến giá trị biên và cận biên thì chúng ta sẽ tạo ra được các ca kiểm thử giá trị biên tổ hợp. Tức là từ bộ giá trị 5 phần tử _min_ , _min_ +, _nom_ , _max_ − và _max_ của mỗi biến ta lấy tích Đề-các (Cartesian) của chúng để tạo ra các ca kiểm thử. Hình 5.5 minh họa các ca kiểm thử giá trị biên tổ hợp của hàm hai biến.

![](images/image4.png)

**Hình 5.5: Các ca kiểm thử biên tổ hợp của hàm hai biến.**

Có thể thấy cách tổ hợp các biên và cận biên này sẽ kiểm tra kỹ hơn kiểm thử giá trị biên thông thường. Tuy nhiên số ca kiểm thử theo cách này tăng lên đáng kể, lên đến 5 _n_ ca kiểm thử so với 4 _n_ \+ 1 ca theo kiểm thử biên thông thường.

Tương tự như kiểm thử giá trị biên mạnh, ta có thể mở rộng kiểm thử biên tổ hợp với bộ 7 giá trị của kiểm thử giá trị biên mạnh. Chúng ta sẽ kiểm tra được kỹ hơn nhưng cũng mất nhiều công sức hơn, đến 7 _n_ ca kiểm thử.

### Kiểm thử các giá trị đặc biệt

Kiểm thử các giá trị đặc biệt cũng là một phương pháp phổ biến. Đây cũng là phương pháp trực quan nhất và không theo một khuôn dạng cụ thể nào. Dựa trên hiểu biết về bài toán và miền ứng dụng kết hợp với kinh nghiệm cá nhân, người kiểm thử đưa ra các giá trị kiểm thử. Do đó không có hướng dẫn cụ thể nào cho phương pháp này. Mức độ hiệu quả của phương pháp này phụ thuộc nhiều vào khả năng của người kiểm thử. Trên thực tế các đơn vị phát triển phần mềm vẫn áp dụng phương pháp này, vì nhiều khi nó giúp phát hiện lỗi nhanh, không tốn nhiều công sức.

# Public_063

# Kiểm thử bằng bảng quyết định

Kỹ thuật kiểm thử lớp tương đương và kiểm thử giá trị biên thích hợp cho các hàm có các biến đầu vào không có quan hệ ràng buộc với nhau. Kỹ thuật kiểm thử dựa trên bảng quyết định sẽ phù hợp cho các hàm có các hành vi khác nhau dựa trên tính chất của bộ giá trị của đầu vào. Nói cách khác, kỹ thuật này phù hợp với các hàm/chương trình có các biến đầu vào phụ thuộc lẫn nhau.
Kiểm thử dựa trên bảng quyết định là phương pháp chính xác nhất trong các kỹ thuật kiểm thử chức năng. Bảng quyết định là phương pháp hiệu quả để mô tả các sự kiện, hành vi sẽ xảy ra khi một số điều kiện thỏa mãn.

## Bảng quyết định

Cấu trúc của một bảng quyết định chia thành bốn phần chính như trong Bảng 5.9, bao gồm:

  * Các biểu thức điều kiện _C_ 1 _, C_ 2 _, C_ 3;


  * Giá trị điều kiện T, F, –;


  * Các hành động _A_ 1 _, A_ 2 _, A_ 3 _, A_ 4; và


  * Giá trị hành động, có (xảy ra) hay không. Chúng ta ký hiệu X để chỉ hành động là có xảy ra ứng với các điều kiện tương ứng của cột.


Khi lập bảng quyết định, chúng ta thường tìm các điều kiện có thể xảy ra để xét các tổ hợp của chúng mà từ đó chúng ta sẽ xác định được các ca kiểm thử tương ứng cho các điều kiện được thỏa mãn. Các hành động xảy ra chính là kết quả mong đợi của ca kiểm thử đó.
Bảng quyết định với các giá trị điều kiện chỉ là T, F, và – được gọi là _bảng quyết định lôgic_. Chúng ta có thể mở rộng các giá trị này bằng các tập giá trị khác, ví dụ 1, 2, 3, 4, khi đó chúng ta có _bảng quyết định tổng quát_.
Bảng 5.10 là một ví dụ đơn giản về một bảng quyết định để khắc phục sự cố máy in. Khi máy in có sự cố, chúng ta sẽ xem xét tình trạng dựa trên các điều kiện trong bảng là đúng (T) hay sai (F), từ đó xác định được cột duy nhất có các điều kiện thỏa mãn, và thực hiện các hành động khắc phục sự cố tương ứng.

**Bảng 5.9: Ví dụ về một bảng quyết định**

![](images/image1.png)
Chú ý là ở đây thứ tự các điều kiện và thứ tự thực hiện hành động không quan trọng, nên chúng ta có thể đổi vị trí các hàng. Với các hành động cũng vậy, tuy nhiên tùy trường hợp chúng ta có thể làm mịn hơn bằng việc đánh số thứ tự hành động xảy ra thay cho dấu X để chỉ ra hành động nào cần làm trước. Với bảng quyết định tổng quát, các giá trị của điều kiện không chỉ nhận giá trị đúng (T) hoặc sai (F), khi đó ta cần tăng số cột để bao hết các tổ hợp có thể của các điều kiện.

**Bảng 5.10: Bảng quyết định để khắc phục sự cố máy in**

![](images/image2.png)

**Kỹ thuật thực hiện:** Để xác định các ca kiểm thử dựa trên bảng quyết định, ta dịch các điều kiện thành các đầu vào và các hành động thành các đầu ra. Đôi khi các điều kiện sẽ xác định các lớp tương đương của đầu vào và các hành động tương ứng với các mô-đun xử lý chức năng đang kiểm thử. Do đó mỗi cột tương ứng với một ca kiểm thử. Vì tất cả các cột bao phủ toàn bộ các tổ hợp đầu vào nên chúng ta có một bộ kiểm thử đầy đủ.
Trên thực tế không phải tổ hợp đầu vào nào cũng là hợp lệ, do đó khi sử dụng bảng quyết định người ta thường bổ sung thêm một giá trị đặc biệt “–” để đánh dấu các điều kiện không thể cùng xảy ra này. Các giá trị – (không quan tâm) có thể hiểu là luôn sai, không hợp lệ. Nếu các điều kiện chỉ là T và F ta có 2 _n_ cột qui tắc. Mỗi giá trị “–” sẽ đại diện cho hai cột. Để dễ kiểm tra không sót cột nào ta có thể thêm hàng đếm “Số luật” như trong Bảng 5.11 và khi tổng hàng này bằng 2 _n_ ta biết số cột qui tắc đã đủ.

**Bảng 5.11: Bảng quyết định cho hàm Triangle**

![](images/image3.png)

## Ví dụ minh họa

**Kiểm thử bằng bảng quyết định cho hàm Triangle:** Sử dụng bảng quyết định được mô tả ở Bảng 5.11, ta có 11 ca kiểm thử nhằm kiểm tra tính đúng đắn của hàm Triangle. Cụ thể, có ba (3) trường hợp không hợp lệ, ba (3) trường hợp không phải là tam giác, một (1) trường hợp tam giác đều, một (1) trường hợp tam giác thường và ba (3) trường hợp tam giác cân. Bảng 5.12 là kết
quả chi tiết về các ca kiểm thử này. Nếu ta thêm điều kiện kiểm tra bất đẳng thức tam giác ta sẽ có thêm ba (3) ca kiểm thử nữa (trường hợp một cạnh có độ dài bằng tổng hai cạnh còn lại).

**Bảng 5.12: Ca kiểm thử bằng bảng quyết định cho hàm Triangle**


| TT | a | b | c | Kết quả mong đợi |
| --- | --- | --- | --- | --- |
| 1 | 4 | 1 | 2 | Không phải tam giác |
| 2 | 1 | 4 | 2 | Không phải tam giác |
| 3 | 1 | 2 | 4 | Không phải tam giác |
| 4 | 5 | 5 | 5 | Tam giác đều |
| 5 | ? | ? | ? | Không khả thi |
| 6 | ? | ? | ? | Không khả thi |
| 7 | 2 | 2 | 3 | Tam giác cân |
| 8 | ? | ? | ? | Không khả thi |
| 9 | 2 | 3 | 2 | Tam giác cân |
| 10 | 3 | 2 | 2 | Tam giác cân |
| 11 | 3 | 4 | 5 | Tam giác thường |

 

**Kiểm thử bằng bảng quyết định cho hàm NextDate:** Có nhiều cách xác định các điều kiện. Ví dụ chúng ta sẽ đặc tả ngày và tháng trong năm và quy đổi về dạng của một năm nhuận hay một năm thông thường giống như trong lần thử đầu tiên, do đó năm 1900 sẽ không có gì đặc biệt. Các miền tương đương bây giờ như sau:

  * M1 = { tháng _|_ tháng có 30 ngày }


  * M2 = { tháng _|_ tháng có 31 ngày, trừ tháng 12 }


  * M3 = { tháng _|_ tháng 12 }


  * M4 = { tháng _|_ tháng 2 } 


Ngày

  * D1 = {ngày _|_ 1 _≤_ ngày _≤_ 27 }


  * D2 = {ngày _|_ ngày = 28 }


  * D3 = {ngày _|_ ngày = 29 }


  * D4 = {ngày _|_ ngày = 30 }


  * D5 = {ngày _|_ ngày = 31 } 


Năm

  * Y1 = {năm _|_ năm nhuận }


  * Y2 = {năm _|_ năm thông thường }


Trong khi tích Đề-các sẽ tạo ra 40 bộ giá trị nếu áp dụng kiểm thử lớp tương đương mạnh, bảng quyết định được lập như Bảng 5.13 chỉ cần 22 bộ giá trị ứng với 22 ca kiểm thử. Có 22 quy tắc, so với 36 trong thử lần hai. Chúng ta có một bảng quyết định với 22 quy tắc. Năm quy tắc đầu tiên cho tháng có 30 ngày. Hai bộ tiếp theo (6-10 và 11-15) cho tháng có 31 ngày, với các tháng khác Tháng Mười Hai và với Tháng Mười Hai.

# Public_064

Trong chương này, chúng ta sẽ tìm hiểu chi tiết về phương pháp kiểm thử dòng điều khiển (control flow testing) nhằm phát hiện các lỗi tiềm ẩn bên trong chương trình/đơn vị chương trình cần kiểm thử. Các lỗi này thường khó phát hiện bởi các kỹ thuật kiểm thử chức năng hay kiểm thử hộp đen được trình bày trong chương 5. Để áp dụng phương pháp này, chúng ta cần phân tích mã nguồn và xây dựng các ca kiểm thử ứng với các dòng điều khiển của chương trình/đơn vị chương trình. Các độ đo hay tiêu chí kiểm thử cho phương pháp này cũng sẽ được giới thiệu.

# Kiểm thử hộp trắng

Kiểm thử hộp trắng sử dụng các chiến lược cụ thể và sử dụng mã nguồn của chương trình/đơn vị phần mềm cần kiểm thử nhằm kiểm tra xem chương trình/đơn vị phần mềm có thực hiện đúng so với thiết kế và đặc tả hay không. Trong khi các phương pháp kiểm thử hộp đen hay kiểm thử chức năng chỉ cho phép phát hiện các lỗi/khiếm khuyết có thể quan sát được, kiểm thử hộp trắng cho phép phát hiện các lỗi/khiếm khuyết tiềm ẩn bên trong chương trình/đơn vị phần mềm. Các lỗi này thường khó phát hiện bởi các phương pháp kiểm thử hộp đen. Khác với các phương pháp kiểm thử hộp đen nơi mà các ca kiểm thử được sinh ra từ đặc tả của hệ thống, các ca kiểm thử trong các phương pháp kiểm thử hộp trắng được sinh ra từ mã nguồn. Kiểm thử hộp đen và kiểm thử hộp trắng không thể thay thế cho nhau mà chúng cần được sử dụng kết hợp với nhau trong một quy trình kiểm thử thống nhất nhằm đảm bảo chất lượng phần mềm. Tuy nhiên, để áp dụng các phương pháp kiểm thử hộp trắng, người kiểm thử không chỉ cần hiểu rõ giải thuật mà còn cần có các kỹ năng và kiến thức tốt về ngôn ngữ lập trình được dùng để phát triển phần mềm, nhằm hiểu rõ mã nguồn của chương trình/đơn vị phần mềm cần kiểm thử. Do vậy, việc áp dụng các phương pháp kiểm thử hộp trắng thường tốn thời gian và công sức nhất là khi chương trình/đơn vị phần mềm có kích thước lớn. Vì lý do này, các phương pháp kiểm thử hộp trắng chủ yếu được sử dụng cho kiểm thử đơn vị [D.95].
Hai phương pháp được sử dụng trong kiểm thử hộp trắng là kiểm thử dòng điều khiển (control flow testing) và kiểm thử dòng dữ liệu (data flow testing). Phương pháp kiểm thử dòng điều khiển tập trung kiểm thử tính đúng đắn của các giải thuật sử dụng trong các chương trình/đơn vị phần mềm. Phương pháp kiểm thử dòng dữ liệu tập trung kiểm thử tính đúng đắn của việc sử dụng các biến dữ liệu sử dụng trong chương trình/đơn vị phần mềm. Trong chương này, chúng ta sẽ tìm hiểu chi tiết về phương pháp kiểm thử dòng điều khiển. Phương pháp kiểm thử dòng dữ liệu sẽ được giới thiệu trong chương 7.

# Đồ thị dòng điều khiển

Phương pháp kiểm thử dòng điều khiển dựa trên khái niệm đồ thị dòng điều khiển (control flow graph). Đồ thị này được xây dựng từ mã nguồn của chương trình/đơn vị chương trình. Đồ thị dòng điều khiển là một đồ thị có hướng gồm các đỉnh tương ứng với các câu lệnh/nhóm câu lệnh và các cạnh là các dòng điều khiển giữa các câu lệnh/nhóm câu lệnh. Nếu _i_ và _j_ là các đỉnh của đồ thị dòng điều khiển thì tồn tại một cạnh từ _i_ đến _j_ nếu lệnh tương ứng với _j_ có thể được thực hiện ngay sau lệnh tương ứng với _i_.
Xây dựng một đồ thị dòng điều khiển từ một chương trình/đơn vị chương trình khá đơn giản. Hình 6.1 mô tả các thành phần cơ bản của đồ thị dòng điều khiển bao gồm điểm bắt đầu của đơn vị chương trình, khối xử lý chứa các câu lệnh khai báo hoặc tính toán, điểm quyết định ứng với các câu lệnh điều kiện trong các khối lệnh rẽ nhánh hoặc lặp, điểm nối ứng với các câu lệnh ngay sau các lệnh rẽ nhánh, và điểm kết thúc ứng với điểm kết thúc của đơn vị chương trình. Các cấu trúc điều khiển phổ biến của chương trình được mô tả trong Hình 6.2. Chúng ta sẽ sử dụng các thành phần cơ bản và các cấu trúc phổ biến này để dễ dàng xây dựng đồ thị dòng điều khiển cho mọi đơn vị chương trình viết bằng mọi ngôn ngữ lập trình.
**Hình 6.1: Các thành phần cơ bản của đồ thị chương trình.** ![](images/image1.png)
**Hình 6.2: Các cấu trúc điều khiển phổ biến của chương trình.** ![](images/image2.png)
Chúng ta thử xem cách dựng đồ thị dòng điều khiển cho đơn vị chương trình có mã nguồn bằng ngôn ngữ C như Hình 6.3. Chúng ta đánh số các dòng lệnh của đơn vị chương trình và lấy số này làm đỉnh của đồ thị. Điểm xuất phát của đơn vị chương trình ứng với câu lệnh khai báo hàm foo. Đỉnh 1 ứng với câu lệnh khai báo biến _e_. Các đỉnh 2 và 3 ứng với câu lệnh if. Đỉnh 4 ứng với câu lệnh khai báo biến _x_ trong khi các đỉnh 5 và 6 ứng với câu lệnh if. Đỉnh 7,8 đại diện cho hai câu lệnh 7 và 8. Trong trường hợp này, chúng ta không tách riêng thành hai đỉnh vì đây là hai câu lệnh tuần tự nên chúng ta ghép chúng thành một đỉnh nhằm tối thiểu số đỉnh của đồ thị dòng điều khiển. Với cách làm này, chúng ta xây dựng được đồ thị dòng điều khiển với số đỉnh nhỏ nhất. Chúng ta sẽ sử dụng đồ thị này để phân tích và sinh các ca kiểm thử nên đồ thị càng ít đỉnh thì độ phức tạp của thuật toán phân tích càng nhỏ.

![](images/image3.png)

**Hình 6.3: Mã nguồn của hàm** foo **và đồ thị dòng điều khiển của nó.**

# Các độ đo kiểm thử

Kiểm thử chức năng (kiểm thử hộp đen) có hạn chế là chúng ta không biết có thừa hay thiếu các ca kiểm thử hay không so với chương trình cài đặt và thiếu thừa ở mức độ nào. Độ đo kiểm thử là một công cụ giúp ta đo mức độ bao phủ chương trình của một tập ca kiểm thử cho trước. Mức độ bao phủ của một bộ kiểm thử (tập các ca kiểm thử) được đo bằng tỷ lệ các thành phần thực sự được kiểm thử so với tổng thể sau khi đã thực hiện các ca kiểm thử. Thành phần liên quan có thể là câu lệnh, điểm quyết định, điều kiện con, đường thi hành hay là sự kết hợp của chúng. Độ bao phủ càng lớn thì độ tin cậy của bộ kiểm thử càng cao. Độ đo này giúp chúng ta kiểm soát và quản lý quá trình kiểm thử tốt hơn. Mục tiêu của chúng ta là kiểm thử với số ca kiểm thử tối thiểu nhưng đạt được độ bao phủ tối đa. Có rất nhiều độ đo kiểm thử đang được sử dụng hiện nay, dưới đây là ba độ đo kiểm thử đang được sử dụng phổ biến nhất trong thực tế [Lee03].
**Độ đo kiểm thử cấp 1 (** _C_ 1 **):** mỗi câu lệnh được thực hiện ít nhất một lần sau khi chạy các ca kiểm thử (test cases). Ví dụ, với hàm foo có mã nguồn như trong Hình 6.3, ta chỉ cần hai ca kiểm thử như Bảng 6.1 là đạt 100% độ phủ cho độ đo _C_ 1 với EO (expected output) là giá trị đầu ra mong đợi và RO (real output) là giá trị đầu ra thực tế (giá trị này sẽ được điền khi thực hiện ca kiểm thử).
**Bảng 6.1: Các ca kiểm thử cho độ đo** _C_ 1 **của hàm** foo


| ID | Inputs | EO | RO | Note |
| --- | --- | --- | --- | --- |
| tc1 | 0, 1, 2, 3 | 0 |  |  |
| tc2 | 1, 1, 2, 3 | 1 |  |  |

 

**Độ đo kiểm thử cấp 2 (** _C_ 2 **):** các điểm quyết định trong đồ thị dòng điều khiển của đơn vị kiểm thử đều được thực hiện ít nhất một lần cả hai nhánh đúng và sai. Ví dụ, Bảng 6.2 mô tả các trường hợp cần kiểm thử để đạt được 100% độ phủ của độ đo _C_ 2 ứng với hàm foo được mô tả trong Hình 6.3.
**Bảng 6.2: Các trường hợp cần kiểm thử của độ đo** _C_ 2 **với hàm** foo


| Điểm quyết định | Điều kiện tương ứng | Đúng | Sai |
| --- | --- | --- | --- |
| 2 | a==0 | tc1 | tc2 |
| 5 | (a == b) || (c == d) | tc2 | ? |

 

Như vậy, với hai ca kiểm thử trong độ đo kiểm thử cấp 1 (tc1 và tc2), ta chỉ kiểm thử được 3/4 = 75% ứng với độ đo kiểm thử cấp 2. Chúng ta cần một ca kiểm thử nữa ứng với trường hợp sai của điều kiện (a == b) || (c == d) nhằm đạt được 100% độ phủ của độ đo _C_ 2. Bảng 6.3 mô tả các ca kiểm thử cho mục đích này.
**Bảng 6.3: Các ca kiểm thử cho độ đo** _C_ 2 **của hàm** foo


| ID | Inputs | EO | RO | Note |
| --- | --- | --- | --- | --- |
| tc1 | 0, 1, 2, 3 | 0 |  |  |
| tc2 | 1, 1, 2, 3 | 1 |  |  |
| tc3 | 1, 2, 1, 2 | Lỗi chia cho 0 |  |  |

 

**Độ đo kiểm thử cấp 3 (** _C_ 3 **):** Với các điều kiện phức tạp (chứa nhiều điều kiện con cơ bản), việc chỉ quan tâm đến giá trị đúng sai là không đủ để kiểm tra tính đúng đắn của chương trình ứng với điều kiện phức tạp này. Ví dụ, nếu một điều kiện phức tạp gồm hai điều kiện con cơ bản, chúng ta có bốn trường hợp cần kiểm thử chứ không phải hai trường hợp đúng sai như độ đo _C_ 2. Với các đơn vị chương trình có yêu cầu cao về tính đúng đắn, việc tuân thủ độ đo _C_ 3 là hết sức cần thiết. Điều kiện để đảm bảo độ đo này là các điều kiện con thuộc các điều kiện phức tạp tương ứng với các điểm quyết định trong đồ thị dòng điều khiển của đơn vị cần kiểm thử đều được thực hiện ít nhất một lần cả hai nhánh đúng và sai. Ví dụ, Bảng 6.4 mô tả các trường hợp cần kiểm thử để đạt được 100% độ phủ của độ đo _C_ 3 ứng với hàm foo được mô tả trong Hình 6.3. Như vậy, với ba ca kiểm thử trong độ đo kiểm thử cấp 2 (tc1, tc2 và tc3), ta chỉ kiểm thử được 7/8 = 87,5% ứng với độ đo kiểm thử cấp 3. Chúng ta cần một ca kiểm thử nữa ứng với trường hợp sai của điều kiện con cơ bản (c == d) nhằm đạt được 100% độ phủ của độ đo _C_ 3. Bảng 6.5 mô tả các ca kiểm thử cho mục đích này.
**Bảng 6.4: Các trường hợp cần kiểm thử của độ đo** _C_ 3 **với hàm** foo


| Điểm quyết định | Điều kiện tương ứng | Đúng | Sai |
| --- | --- | --- | --- |
| 2 | a==0 | tc1 | tc2 |
| 5 | (a == b) | tc2 | tc3 |
| 5 | (c == d) | ? | tc2 |

 

**Bảng 6.5: Các ca kiểm thử cho độ đo** _C_ 3 **của hàm** foo


| ID | Inputs | EO | RO | Note |
| --- | --- | --- | --- | --- |
| tc1 | 0, 1, 2, 3 | 0 |  |  |
| tc2 | 1, 1, 2, 3 | 1 |  |  |
| tc3 | 1, 2, 1, 2 | Lỗi chia cho 0 |  |  |
| tc4 | 1, 2, 1, 1 | 1 |  |  |

# Public_065

# Kiểm thử dựa trên lát cắt

Kiểm thử dòng dữ liệu như đã trình bày ở trên là một phương pháp tốt nhằm phát hiện các lỗi tiềm tàng bên trong các đơn vị chương trình. Tuy nhiên, độ phức tạp của phương pháp này rất lớn. Với các đơn vị chương trình có kích thước lớn, phương pháp này khá tốn kém. Trong thực tế, để áp dụng phương pháp này, chúng ta không cần phân tích tất cả các câu lệnh thuộc đơn vị chương trình cần kiểm thử. Với mỗi biến, chỉ có một tập con các câu lệnh có liên quan (khai báo, gán giá trị và sử dụng) đến biến này. Dựa trên quan sát này, phương pháp kiểm thử chương trình dựa trên lát cắt được đề xuất nhằm giảm thiểu độ phức tạp trong việc sinh các ca kiểm thử của phương pháp kiểm thử dòng dữ liệu.

## Ý tưởng về kiểm thử dựa trên lát cắt

Các lát cắt chương trình đã từng có những bước thăng trầm trong ngành công nghệ phần mềm kể từ đầu những năm 1980. Chúng được đề xuất bởi Weiser [Mar81, Mar84], được dùng như là một phương pháp tiếp cận bảo trì phần mềm, và gần đây nhất chúng được sử dụng như là một cách để kết dính các chức năng. Một phần sự linh hoạt này là do tính tự nhiên cũng như mục đích rõ ràng của lát cắt chương trình.
Thông thường, một lát cắt chương trình là một phần chương trình có ảnh hưởng tới giá trị của biến tại một vị trí trong chương trình. Hình 7.7 là một ví dụ về một lát cắt chương trình ứng với biến _sum_ (phần bên phải). Lát cắt này có được bằng cách lựa chọn các câu lệnh có ảnh hưởng đến biến _sum_ từ đoạn chương trình phía bên trái. Các câu lệnh int product = 1;, product = product*i;, và printf("product␣=␣%d",product); không có ảnh hưởng đến biến
_sum_ nên đã bị loại bỏ khỏi lát cắt này.
Chúng ta sẽ bắt đầu bằng việc định nghĩa thế nào là một lát cắt chương trình. Giả sử ta có một chương trình ký hiệu là _P_ , đồ thị của chương trình là _G_ ( _P_ ), và tập các biến của chương trình là _V_ . Sau đây, chúng ta sẽ tìm hiểu chi tiết về kỹ thuật kiểm thử dựa trên lát cắt.
**Hình 7.7: Một ví dụ về lát cắt chương trình.**
![](images/image1.png)
**Định nghĩa 7.29.** (Lát cắt.) Cho một chương trình _P_ và _V_ là tập các biến trong chương trình này. Một lát cắt trên _V_ tại câu lệnh _n_ , kí hiệu _S_ ( _V, n_ ), là tập tất các lệnh trong _P_ có góp phần làm thay đổi giá trị của tập biến trong _V_ .
Tuy nhiên, định nghĩa trên còn khá chung chung nên rất khó để xác định _S_ ( _V, n_ ). Định nghĩa sau giúp chúng ta giải quyết vấn đề này.
**Định nghĩa 7.30.** (Lát cắt chương trình.) Cho một chương trình _P_ với đồ thị chương trình _G_ ( _P_ ) (trong đó các câu lệnh và các đoạn câu lệnh được đánh số) và một tập các biến _V_ trong _P_ , lát cắt trên tập biến _V_ tại đoạn câu lệnh _n_ , ký hiệu là _S_ ( _V, n_ ), là tập các số nút của tất cả các câu lệnh và đoạn câu lệnh trong _P_ “trước thời điểm” _n_ “ảnh hưởng” đến các giá trị của các biến trong _V_ tại đoạn mã lệnh thứ _n_ [Jor13].
Trong định nghĩa trên, thuật ngữ “các đoạn câu lệnh” có nghĩa là một câu lệnh có thể là một câu lệnh phức do vậy ta có thể tách các câu lệnh này thành từng câu lệnh riêng biệt. Ví dụ, câu lệnh phức int intMin=0, intMax=100; sẽ được tách thành hai câu lệnh đơn int intMin=0; và int intMax=100;. Khái niệm “trước thời điểm” _n_ “ảnh hưởng” không có nghĩa là thứ tự các câu lệnh mà là thời điểm trước khi câu lệnh đó được thực hiện. Ví dụ, trong hàm tính tổng các số chẵn nhỏ hơn _n_ như Đoạn mã 7.3, câu lệnh i++; đứng sau nhưng lại ảnh hưởng trực tiếp đến câu lệnh result += i;.
**Đoạn mã 7.3: Hàm tính tổng các số chẵn nhỏ hơn** _n_
int Tong Cac So Chan ( int n){ int i = 0;
int result = 0; while ( i < n){
if( i%2 == 0){
result += i;
} i++;
}
return result;
}
Ý tưởng của các lát cắt là để tách một chương trình thành các thành phần, mỗi một thành phần có một số ý nghĩa nhất định. Các phần ảnh hưởng tới giá trị của các biến đã được giới thiệu trong mục 7.1.5 bằng việc sử dụng các định nghĩa và sử dụng của từng biến ( _Def_ , _C_ - _use_ , _P_ - _use_ ), nhưng chúng ta cần phải tinh chỉnh lại một số hình thức sử dụng biến. Cụ thể là mối quan hệ sử dụng ( _Use_ ) của biến gắn liền với năm hình thức sử dụng như sau.

  * _P_ - _use_ : Biến được sử dụng trong các câu lệnh rẽ nhánh. Ví dụ, if(x>0){...}


  * _C_ - _use_ : Biến được sử dụng trong các câu lệnh tính toán. Ví dụ, x = x + y;


  * _O_ - _use_ : Biến được sử dụng cho các câu lệnh hiển thị hoặc trả về kết quả. Ví dụ, return x; hoặc printf("%d",x);

  * _L_ - _use_ : Biến được sử dụng như một con trỏ trỏ đến các địa chỉ hoặc chỉ số của mảng. Ví dụ, int x =100, *ptr; ptr = &x;

  * _I_ - _use_ : Biến được sử dụng như các biến đếm (trong các vòng lặp). Ví dụ, i++;


Chúng ta cũng có hai dạng xác định giá trị cho các biến như sau:

  * _I_ - _def_ : xác định từ đầu vào (từ bàn phím, truyền tham số, v.v.)


  * _A_ - _def_ : xác định từ phép gán


Giả sử lát cắt _S_ ( _V, n_ ) là một lát cắt trên một biến, ở đây tập
_V_ chỉ chứa một biến _v_ duy nhất. Nếu nút _n_ chứa một định nghĩa của _v_ thì ta thêm _n_ vào lát cắt _S_ ( _V, n_ ). Ngược lại, nếu nút _n_ chứa một sử dụng của biến _v_ ∈ _V_ thì _n_ không được thêm vào lát cắt _S_ ( _V, n_ ). Những nút chứa _P_ - _use_ và _C_ - _use_ của các biến khác (không phải biến _v_ trong tập _V_ ) mà ảnh hưởng trực tiếp hoặc gián tiếp tới giá trị của biến _v_ thì được thêm vào tập _V_ . Đối với lát cắt _S_ ( _V, n_ ), những định nghĩa và sử dụng của các biến sau được thêm vào lát cắt _S_ ( _V, n_ ).

  * Tất cả các _I_ - _def_ và _A_ - _def_ của biến _v_

  * Tất cả các _C_ - _use_ và _P_ - _use_ của biến _v_ sao cho nếu loại bỏ nó sẽ làm thay đổi giá trị của _v_


  * Tất cả các _P_ - _use_ và _C_ - _use_ của các biến khác (không phải biến _v_ ) sao cho nếu loại bỏ nó thì sẽ làm thay đổi giá trị của biến _v_


  * Loại bỏ khỏi lát cắt các _I_ - _use_ , _L_ - _use_ và _O_ - _use_ của biến _v_

  * Loại bỏ toàn bộ các câu lệnh không được thực thi như các câu lệnh khai báo biến

  * Kiểm tra các hằng số, nếu hằng số đó ảnh hưởng đến biến _v_


thì ta thêm hằng số đó vào lát cắt

## Ví dụ áp dụng

Quay trở lại với ví dụ về hàm ReturnAverage được trình bày ở Đoạn mã 7.2 trong mục 7.1.4, để áp dụng kỹ thuật kiểm thử dựa trên lát cắt, chúng ta phân mảnh hàm này như Đoạn mã 7.4. Tiếp đến, chúng ta xây dựng đồ thị của hàm sau khi phân mảnh như hình 7.8. Sau đó, chúng ta cũng sẽ định nghĩa lại các định nghĩa ( _Def_ ) và sử dụng ( _Use_ ) của các biến trong các bảng 7.3 và 7.4. Và cuối cùng, các lát cắt trên từng biến của hàm sẽ được tính toán.
**Đoạn mã 7.4: Mã nguồn hàm** ReturnAverage **sau khi phân mảnh** double Return Average ( int value [], int AS , int MIN , int MAX ){
int i = 0; int ti = 0; int tv = 0; int sum = 0; double av;
while ( ti < AS && value [ i] != -999) { ti++;
if ( value [ i] >= MIN && value [ i] <= MAX ) { tv ++;
sum = sum + value [ i];
} i++;
} _// end while_
if ( tv > 0)

# Public_066

Chương này giới thiệu phương pháp và một số công cụ hỗ trợ kiểm thử dựa trên mô hình nhằm tăng tính hiệu quả và độ chính xác của các hoạt động kiểm thử. Kiểm thử dựa trên mô hình có thể sử dụng với nhiều mục đích khác nhau trong việc tự động hóa các hoạt động kiểm thử. Chúng tôi giới thiệu phương pháp này nhằm kiểm tra tính đúng đắn của việc lập trình so với thiết kế. Các phương pháp và công cụ hỗ trợ kiểm thử dựa trên mô hình có vai trò hết sức quan trọng trong việc nâng cao chất lượng của các sản phẩm và tăng tính cạnh tranh cho các công ty phần mềm.

# Khái niệm về kiểm thử dựa trên mô hình

Có nhiều khái niệm khác nhau về kiểm thử dựa trên mô hình. Tựu trung lại, chúng ta có thể hiểu kiểm thử dựa trên mô hình là một phương pháp kiểm thử nơi mà các ca kiểm thử được sinh ra từ mô hình đặc tả hành vi của hệ thống đang được kiểm thử. Mô hình này được biểu diễn bằng máy hữu hạn trạng thái, ôtômat, đặc tả đại số, biểu đồ trạng thái bằng UML, v.v.

Quá trình kiểm thử dựa trên mô hình được bắt đầu bằng việc xác định yêu cầu của hệ thống từ đó xây dựng mô hình dựa vào các yêu cầu và chức năng của hệ thống. Việc xây dựng mô hình còn phải dựa trên các yếu tố dữ liệu đầu vào và đầu ra. Mô hình này được sử dụng để sinh đầu vào cho các ca kiểm thử. Tiếp đến, chúng ta sẽ sinh giá trị đầu ra mong muốn ứng với mỗi bộ đầu vào. Khi kết thúc bước này, chúng ta đã có các ca kiểm thử. Các kịch bản kiểm thử sẽ được thiết kế và thực thi nhằm phát hiện các lỗi/khiếm khuyết của sản phẩm bằng cách so sánh đầu ra thực tế với đầu ra mong đợi tương ứng của ca kiểm thử. Từ các kết quả kiểm thử, chúng ta sẽ quyết định hành động tiếp theo như sửa đổi mô hình hoặc dừng kiểm thử.

Hình 8.1 mô tả các bước của quy trình kiểm thử dựa trên mô hình, bao gồm:

**Hình 8.1: Quy trình kiểm thử dựa trên mô hình [KJ02].** ![](images/image1.png)

  * Sinh mô hình dựa trên các yêu cầu và chức năng của hệ thống.


  * Sinh các ca kiểm thử (bộ đầu vào và giá trị đầu ra mong đợi cho mỗi ca kiểm thử).


  * Chạy các kịch bản kiểm thử để phát hiện các lỗi/khiếm khuyết của sản phẩm.

  * So sánh kết quả đầu ra thực tế với kết quả đầu ra dự kiến.


  * Quyết định hành động tiếp theo (sửa đổi mô hình, tạo thêm ca kiểm thử, dừng kiểm thử, đánh giá chất lượng của phần mềm).


# Các phương pháp đặc tả mô hình

Để áp dụng phương pháp kiểm thử dựa trên mô hình, chúng ta cần xây dựng mô hình đặc tả chính xác hành vi của hệ thống cần kiểm thử. Mô hình này được đặc tả bằng một trong các phương pháp hình thức như: máy hữu hạn trạng thái, biểu đồ trạng thái, máy trạng thái UML, chuỗi Markov, văn phạm, bảng quyết định,

v.v. Trong mục này, chúng ta sẽ tìm hiểu một số phương pháp hình thức phổ biến được sử dụng để đặc tả mô hình của các hệ thống.

## Máy hữu hạn trạng thái

Máy hữu hạn trạng thái (Finite State Machine - FSM) được biết đến như là phương pháp đặc tả phổ biến nhất cho thiết kế và kiểm thử phần mềm nói riêng và các hệ thống nói chung. FSM rất hiệu quả trong việc đặc tả hành vi dựa trên việc chuyển trạng thái của các hệ thống. Một cách hình thức, FSM được định nghĩa như sau.

**Định nghĩa 8.1** (Máy hữu hạn trạng thái) **.** Máy hữu hạn trạng thái là một bộ bốn ( _S, Act, T, q_ 0), trong đó _S_ là tập hữu hạn các trạng thái, _T_ là tập các chuyển trạng thái, _Act_ là các tập các sự kiện (còn có tên khác là bảng ký hiệu) và _q_ 0 là trạng thái khởi tạo.

![](images/image2.png)

**Hình 8.2: Một ví dụ về máy hữu hạn trạng thái.**

**Bảng 8.1: Bảng chuyển của máy hữu hạn trạng thái trong hình 8.2**


|  | off | dim | normal | bright |
| --- | --- | --- | --- | --- |
| off |  |  | turn on |  |
| dim | turn off |  | incr. intensity |  |
| normal | turn off | decr. intensity |  | incr. intensity |
| bright | turn off |  | decr. intensity |  |

 

Hình 8.2 mô tả một ví dụ về một máy hữu hạn trạng thái đặc tả hành vi của một hệ thống chuyển công tắc đèn [KJ02]. Trong hình này, _off_ là trạng thái khởi đầu của hệ thống. Ở trạng thái này, đèn đang bị tắt. Với đầu vào là _turn on_ , hệ thống sẽ chuyển đến trạng thái _normal_ với đèn có độ sáng bình thường. Tại trạng thái này, chúng ta có thể tắt đèn (ứng với đầu vào _turn off_ và hệ thống sẽ chuyển về trạng thái _off_ ), tăng độ sáng của đèn (ứng với đầu vào _increase intensity_ và hệ thống sẽ chuyển về trạng thái _bright_ ) và giảm độ sáng của đèn (ứng với đầu vào _decrease intensity_ và hệ thống sẽ chuyển về trạng thái _dim_ ). Tại các trạng thái _dim_ và _bright_ , chúng ta có thể tắt đèn, tăng và giảm độ sáng tương ứng. Bảng 8.1 là một dạng đặc tả khác của máy hữu hạn trạng thái trên dưới dạng bảng chuyển. Chúng ta sẽ dùng cấu trúc dữ liệu này làm đầu vào cho các công cụ kiểm thử tự động.

## Ôtômat đơn định hữu hạn trạng thái

Tương tự như FSM, ôtômat đơn định hữu hạn trạng thái (Deter- ministic Finite state Automaton - DFA) cũng rất hiệu quả trong việc đặc tả hành vi dựa trên việc chuyển trạng thái của các hệ thống. Một cách hình thức, DFA được định nghĩa như sau.

**Định nghĩa 8.2** (Ôtômat đơn định hữu hạn trạng thái) **.** Ôtômat đơn định hữu hạn trạng thái là một bộ năm ( _S, Act, T, q_ 0 _, F_ ), trong đó: _S_ , _T_ , _Act_ và _q_ 0 được định nghĩa như trong định nghĩa của FSM, và _F_ ⊆ _S_ là tập các trạng thái kết thúc.

Một ví dụ minh họa về việc áp dụng DFA cho đặc tả hành vi của hệ thống trong kiểm thử dựa trên mô hình sẽ được giới thiệu trong mục 8.6.

## Biểu đồ trạng thái

Hình 8.3 mô tả ví dụ về một biểu đồ trạng thái đặc tả hành vi của một máy nghe nhạc. Trong biểu đồ này, trạng thái _CD_Insert_ gồm hai trạng thái con (Include/Select Track và Include/Mode). Hai trạng thái này hoạt động đồng thời. Khi chèn một CD vào máy nghe nhạc, chúng ta có thể chọn bài hát và xem thông tin của nó hoặc chúng ta có thể chọn bài hát và nghe. Cả hai chế độ này được thực hiện tại cùng một thời điểm. Một cách khác, chúng ta có thể nói _CD_Insert_ là một “trạng thái ghép nối” với tính đồng thời. Đây chính là sự khác biệt chính của biểu đồ trạng thái so với máy hữu hạn trạng thái. Bởi cách biểu diễn này, biểu đồ trạng thái có thể đặc tả hệ thống với ít trạng thái hơn và vì vậy nó giảm độ phức tạp cho quá trình đặc tả và kiểm thử/kiểm chứng sau này.

**Hình 8.3: Một ví dụ về biểu đồ trạng thái [BBH05].** ![](images/image3.png)

## Máy trạng thái UML

Các phương pháp đặc tả hình thức như máy hữu hạn trạng thái, biểu đồ trạng thái, v.v. giúp ta đặc tả các hệ thống một cách chính xác với ý nghĩa duy nhất (vì chúng sử dụng các công cụ toán học). Tuy nhiên, các phương pháp này thường khó được áp dụng trong công nghiệp vì chúng đòi hỏi các chuyên gia về đặc tả hình thức.

Máy trạng thái UML được xem là giải pháp tốt để giải quyết vấn đề này. Nó có thể được sử dụng để đặc tả hành vi động (chuyển trạng thái) của các lớp đối tượng, các ca sử dụng (use cases), các hệ thống con và thậm chí là toàn bộ hệ thống. Tuy nhiên, máy trạng thái UML thường được sử dụng cho các lớp đối tượng. Theo [AJ00], biểu đồ cộng tác đặc tả bằng UML là một mô hình quan trọng trong việc kiểm thử hệ thống bởi mô hình này đặc tả chính xác hành vi (tương tác giữa các đối tượng) của hệ thống cần kiểm thử.

Trong UML, một trạng thái ứng với một điều kiện quan trọng của một đối tượng. Trạng thái này được quyết định bởi các giá trị hiện thời của đối tượng, các mối quan hệ với các đối tượng khác và các hành động (phương thức) mà đối tượng này thực hiện. Một phép chuyển trạng thái là mối quan hệ giữa hai trạng thái. Một phép chuyển trạng thái trong UML bao gồm một sự kiện được kích hoạt, điều kiện và hành động tương ứng. Các sự kiện được kích hoạt của các phép chuyển trạng thái có thể là một trong các sự kiện sau:

  * Một lời gọi ứng với một phương thức


  * Một tín hiệu nhận được từ các trạng thái khác trong máy trạng thái


  * Một sự thay đổi giá trị của một thuộc tính nào đó của một đối tượng


  * Hết thời gian (timeout)


Hình 8.4 là ví dụ về một máy trạng thái UML đặc tả hành vi của hệ thống quản lý bán hàng.

**Hình 8.4: Một ví dụ về máy trạng thái UML.** ![](images/image4.png)

## Các phương pháp đặc tả khác

Ngoài những phương pháp đặc tả trên, có rất nhiều phương pháp đặc tả khác đã được đề xuất. Một số phương pháp đặc tả phổ biến như: mạng Petri (xem mục 3.6.3.2), chuỗi Markov, văn phạm, bảng quyết định/cây quyết định, ngôn ngữ ràng buộc đối tượng (OCL), các ngôn ngữ đặc tả đại số (Z, OBJ, v.v.), v.v. Phụ thuộc vào phương pháp và công cụ kiểm thử, chúng ta sẽ lựa chọn phương pháp đặc tả hệ thống tương ứng.

# Public_067

Kiểm thử đang được xem là giải pháp chủ yếu nhằm đảm bảo chất lượng cho các sản phẩm phần mềm. Tuy nhiên, các hoạt động kiểm thử hiện nay chủ yếu được thực hiện một cách thủ công và tiêu tốn khoảng 30-50% tài nguyên (thời gian, nhân lực và chi phí) của quá trình phát triển sản phẩm phần mềm. Hơn nữa, độ phức tạp của các phần mềm ngày càng tăng và trong môi trường cạnh tranh như hiện nay đòi hỏi các công ty phần mềm phải áp dụng các phương pháp và công cụ nhằm tự động hóa các hoạt động kiểm thử. Hơn nữa, các công cụ kiểm thử tự động là một giải pháp hữu hiệu cho kiểm thử hồi quy. Chương này giới thiệu tổng quan về kiểm thử tự động và các công cụ hỗ trợ nhằm giải quyết vấn đề này.

# Tổng quan về kiểm thử tự động

Một thực tế đáng buồn hiện nay là chất lượng của hầu hết các sản phẩm phần mềm rất thấp. Hàng năm, chúng ta phải chịu thiệt hại nhiều tỷ đô la do các lỗi phần mềm gây ra [oST02a, G.95]. Theo thống kê của NIST công bố năm 2002 [oST02b], chất lượng phần mềm thấp đã gây thiệt hại cho kinh tế Mỹ 60 tỷ đô la mỗi năm và tiêu tốn khoảng 22 tỷ đô la cho việc phát triển các công cụ nhằm phát hiện các lỗi và kiểm thử tự động. Có hai lý do chính dẫn đến tình trạng này. Thứ nhất, hầu hết các công cụ hiện nay đều tập trung vào việc thực thi tự động các ca kiểm thử (auto-test execution) trong khi vấn đề cốt lõi của kiểm thử là các phương pháp và kỹ thuật sinh các ca kiểm thử vẫn còn thiếu. Thứ hai, các công cụ hiện nay chưa hỗ trợ một cách hiệu quả cho kiểm thử hồi quy (regression testing). Một khi phần mềm bị tiến hóa/thay đổi, chúng ta cần kiểm thử lại sản phẩm. Làm thế nào để sử dụng lại các ca kiểm thử đã có và sinh ra các ca kiểm thử mới một cách hiệu quả đang là một vấn đề mở và chưa có giải pháp thỏa đáng. Hơn nữa, một trong những vấn đề khó nhất của kiểm thử tự động đó là việc sinh các giá trị đầu ra mong đợi tương ứng với các đầu vào của các ca kiểm thử. Đây là một bài toán khó và chưa có giải pháp hiệu quả nhằm giải quyết vấn đề này.
Giải pháp chủ yếu để giải quyết các vấn đề trên là đề xuất các phương pháp và công cụ hỗ trợ tối đa các hoạt động trong quy trình kiểm thử phần mềm. Trong quy trình kiểm thử, chúng ta cần một số công cụ ứng với các pha và các mục tiêu kiểm thử khác nhau. Ví dụ, để tự động hóa chiến lược kiểm thử hộp đen, phương pháp kiểm thử dựa trên mô hình (model-based testing) đang được biết đến như là một giải pháp tin cậy và hiệu quả [MRA04, KJ02, BFM04]. Với kiểm thử hộp trắng, ứng với mỗi phương pháp khác nhau chúng ta cũng có rất nhiều công cụ hỗ trợ. Ngoài ra, một số công cụ hỗ trợ kiểm thử các tính chất phi chức năng như độ an toàn, bảo mật, hiệu năng và khả năng chịu tải, v.v., cũng đã được phát triển và sử dụng rộng rãi.
Kiểm thử tự động là quá trình thực hiện một cách tự động các bước trong một kịch bản kiểm thử. Kiểm thử tự động bằng một công cụ nhằm rút ngắn thời gian kiểm thử. Mục đích của kiểm thử tự động là giảm thiểu thời gian, công sức và kinh phí trong khi vẫn tăng độ tin cậy, tăng tính hiệu quả và giảm sự nhàm chán cho người kiểm thử trong quá trình kiểm thử sản phẩm phần mềm. Kiểm thử tự động sẽ được sử dụng khi dự án không đủ tài nguyên (thời gian, nhân lực và chi phí), phải thực hiện kiểm thử hồi quy khi sản phẩm được sửa đổi hoặc nâng cấp và cần kiểm thử lại các tính năng đã thực hiện tốt trước đó, kiểm tra khả năng vận hành của sản phẩm trong các môi trường đặc biệt (đo tốc độ xử lý trung bình ứng với mỗi yêu cầu, xác định khả năng chịu tải tối đa, xác định cấu hình tối thiểu để thực thi hệ thống, kiểm tra các cơ chế an ninh và an toàn, v.v.).

# Kiến trúc của một bộ công cụ kiểm thử tự động

Trong thức tế, có rất nhiều bộ công cụ hỗ trợ kiểm thử tự động được phát triển nhằm góp phần giải quyết các vấn đề khó khăn của quy trình kiểm thử. Hình 9.1 mô tả kiến trúc chung nhất của một bộ kiểm thử tự động [Som10]. Trong kiến trúc này, các công cụ kiểm thử được tích hợp trong một quy trình thống nhất nhằm hỗ trợ đầy đủ các hoạt động kiểm thử trong quy trình kiểm thử các sản phẩm phần mềm.
**Hình 9.1: Kiến trúc chung của một bộ kiểm thử tự động.** ![](images/image1.png)
Các công cụ cơ bản trong kiến trúc này bao gồm:

  * **Quản lý kiểm thử:** công cụ này cho phép quản lý việc thực hiện/thực thi các ca kiểm thử. Nó giám sát việc thực hiện từng ca kiểm thử ứng với bộ giá trị đầu vào, giá trị đầu ra mong muốn và giá trị đầu ra thực tế. JUnit là một ví dụ điển hình về công cụ này.

  * **Sinh các ca kiểm thử:** Đây là một trong những công cụ quan trọng nhất của các bộ kiểm thử tự động. Tùy thuộc vào các kỹ thuật kiểm thử được áp dụng, công cụ này sẽ sinh ra tập các ca kiểm thử (chưa gồm giá trị đầu ra mong muốn) cho chương trình/đơn vị chương trình cần kiểm thử. Các ca kiểm thử được sinh ra chỉ chứa giá trị đầu vào để thực hiện nó. Các giá trị này có thể được lựa chọn trong cơ sở dữ liệu hoặc được sinh một cách ngẫu nhiên.


  * **Sinh giá trị đầu ra mong muốn:** Các ca kiểm thử được sinh ra bởi công cụ trên chỉ chứa các giá trị ứng với các biến đầu vào. Công cụ này cho phép sinh ra giá trị đầu ra mong muốn ứng với mỗi bộ dữ liệu đầu vào của mỗi ca kiểm thử. Giá trị đầu ra mong muốn này sẽ được sử dụng để so sánh với giá trị đầu ra thực tế khi thực hiện ca kiểm thử này nhằm phát hiện ra các lỗi/khiếm khuyết của sản phẩm.

  * **So sánh kết quả kiểm thử:** Công cụ này so sánh giá trị đầu ra thực tế và giá trị đầu ra mong muốn của mỗi ca kiểm thử khi nó được thực hiện trên chương trình/đơn vị chương trình cần kiểm thử. Đối với mục đích kiểm thử phi chức năng, chúng ta không thể sử dụng cách làm này. Các giải pháp cho bài toán này sẽ được trình bày chi tiết trong chương 10.


  * **Tạo báo cáo kiểm thử:** Một trong những ưu điểm của các bộ công cụ kiểm thử tự động là nó có cơ chế sinh báo cáo kiểm thử một cách chính xác và nhất quán. Dựa vào kết quả của công cụ so sánh kết quả kiểm thử, công cụ này sẽ tự động sinh ra báo cáo kết quả kiểm thử theo định dạng mong muốn của đơn vị phát triển.


  * **Phân tích động:** Công cụ này cung cấp một cơ chế nhằm kiểm tra việc thực hiện của các câu lệnh của chương trình cần kiểm thử nhằm phát hiện ra các lỗi và phát hiện các câu lệnh/đoạn lệnh không được thực hiện bởi một tập các ca kiểm thử cho trước. Công cụ này cũng rất hiệu quả trong việc đánh giá tính hiệu quả của một bộ kiểm thử cho trước.


  * **Bộ mô phỏng:** Có nhiều loại mình mô phỏng được cung cấp trong các bộ kiểm thử tự động. Mục đích của các công cụ này là mô phỏng quá trình thực hiện của chương trình cần kiểm thử. Ví dụ, các công cụ mô phỏng giao diện người dùng cho phép thực hiện tự động các tương tác giữa người dùng và sản phẩm. Selenium1 là một ví dụ về một công cụ mô phỏng giao diện người dùng cho các ứng dụng Web.


Trong thực tế, các bộ công cụ kiểm thử tự động có thể có thêm một số công cụ khác như cho phép đặc tả các tính chất của hệ thống cần kiểm thử, vân vân. Một số bộ công cụ chỉ hỗ trợ một số công cụ trong các công cụ đã liệt kê ở trên.
Các công cụ hỗ trợ kiểm thử tự động rất đa dạng và phục vụ nhiều mục đích khác nhau. Hình 9.2 thể hiện các loại công cụ kiểm thử tự động ứng với từng pha trong quy trình phát triển phần mềm.

  * **Các công cụ quản lý:** các công cụ này phục vụ pha lập trình và quản lý quá trình này như quản lý phiên bản, quản lý thay đổi, v.v.

  * **Các công cụ phân tích tĩnh:** các công cụ này phục vụ pha lập trình và cho phép phân tích mã nguồn để tìm các lỗi hay gặp.

  * **Các công cụ phân tích độ phủ:** các công cụ này hỗ trợ pha kiểm thử đơn vị và cho phép phân tích độ bao phủ của một bộ kiểm thử đối với mã nguồn.

  * **Các công cụ gỡ lỗi:** các công cụ này cho phép định vị các lỗi được phát hiện bởi một ca kiểm thử.

  * **Các công cụ phân tích động:** các công cụ này hỗ trợ cả pha kiểm thử đơn vị và kiểm thử tích hợp. Chúng cho phép sinh ra các ca kiểm thử từ mã nguồn và thực thi chúng nhằm phát hiện các lỗi lập trình.

  * **Các công cụ mô phỏng, kiểm thử hiệu năng:** các công cụ này trợ giúp kiểm thử tự động hệ thống và kiểm thử chấp nhận. Chúng cho phép kiểm thử một số yêu cầu về hiệu năng của hệ thống như tính hiệu quả trong sử dụng tài nguyên, tính an toàn và bảo mật, khả năng chịu tải, v.v.

  * **Các công cụ thực thi và đánh giá các ca kiểm thử:** các công cụ này cho phép thực hiện/thực thi các ca kiểm thử và giám sát việc thực hiện từng ca kiểm thử ứng với bộ giá trị đầu vào, giá trị đầu ra mong muốn và giá trị đầu ra thực tế nhằm tạo báo cáo kiểm thử.

# Public068

# Thu thập và Tiền xử lý Dữ liệu Hình Ảnh

Để một hệ thống thị giác máy tính hoạt động hiệu quả, dữ liệu hình ảnh chất lượng cao là nền tảng quan trọng nhất. Việc thu thập dữ liệu không chỉ đơn thuần là “chụp ảnh”, mà đòi hỏi một quy trình bài bản:

  * Nguồn dữ liệu đa dạng: Kết hợp ảnh từ camera dây chuyền sản xuất, dữ liệu cảm biến quang học, và các bộ dữ liệu công khai như ImageNet hoặc Open Images.

  * Tiêu chuẩn hóa bối cảnh: Đảm bảo nhiều góc chụp, ánh sáng khác nhau, và các điều kiện sản xuất khác nhau để mô hình có khả năng tổng quát tốt.

  * Định dạng thống nhất: Giữ định dạng hình ảnh đồng nhất (JPEG/PNG) và độ phân giải tối thiểu Full HD nhằm duy trì chi tiết cần thiết cho phân tích.


Sau khi thu thập, dữ liệu phải trải qua tiền xử lý để tăng tính ổn định:

  * Cân bằng dữ liệu: Dùng kỹ thuật oversampling hoặc augmentation như xoay, lật, điều chỉnh độ sáng.

  * Loại bỏ nhiễu: Ứng dụng các bộ lọc như Gaussian blur hoặc median filter để giảm nhiễu cảm biến.

  * Chuẩn hóa kích thước: Đưa tất cả ảnh về cùng kích thước đầu vào của mô hình, thường là 224×224 hoặc 512×512 pixel.


Quy trình này đảm bảo dữ liệu “sạch”, đa dạng và nhất quán, là nền tảng để huấn luyện các mô hình thị giác máy tính công nghiệp đạt hiệu quả cao.

# Xây dựng Kiến trúc Mô hình

Sau khi có dữ liệu chất lượng, bước tiếp theo là thiết kế và lựa chọn kiến trúc mô hình phù hợp. Việc chọn kiến trúc dựa trên mục tiêu cụ thể:

  * Phân loại hình ảnh: Các kiến trúc CNN như ResNet, EfficientNet, DenseNet nổi bật nhờ khả năng trích xuất đặc trưng mạnh mẽ.

  * Phát hiện vật thể: Các mô hình YOLO (phiên bản mới nhất YOLOv8) hay Faster R-CNN được sử dụng để phát hiện lỗi sản phẩm trên dây chuyền.

  * Phân đoạn ảnh: U-Net, DeepLab, hay Mask R-CNN phù hợp cho việc khoanh vùng chính xác các vùng khuyết tật.

  * Xu hướng mới: Vision Transformer (ViT) và các mô hình hybrid CNN–Transformer giúp mô hình hiểu mối liên hệ xa trong ảnh, cải thiện hiệu năng trong môi trường phức tạp.


Chiến lược huấn luyện:

  * Pretraining + Fine-tuning: Khởi đầu với mô hình đã huấn luyện trên ImageNet, sau đó tinh chỉnh trên dữ liệu nội bộ.

  * Regularization: Dùng dropout, weight decay để giảm overfitting.

  * Augmentation online: Tạo biến thể ảnh trong suốt quá trình huấn luyện để tăng khả năng tổng quát.


Quá trình này giúp mô hình đạt độ chính xác cao trong thời gian huấn luyện tối ưu, đồng thời giảm yêu cầu về tài nguyên.

# Tích hợp và Triển khai Thực Tế

Sau khi mô hình đạt hiệu suất mong muốn, bước triển khai vào môi trường công nghiệp đòi hỏi sự phối hợp chặt chẽ giữa phần mềm và phần cứng:

  * Giao tiếp thời gian thực: Dịch vụ inference nên được triển khai dưới dạng API (REST/gRPC) để xử lý video trực tiếp từ camera.

  * Đồng bộ với PLC/SCADA: Hệ thống cần tương thích với các bộ điều khiển công nghiệp để tự động loại bỏ sản phẩm lỗi hoặc điều chỉnh dây chuyền.

  * Xử lý tại biên (Edge Computing): Đưa mô hình đã nén (quantization, pruning) lên các thiết bị như NVIDIA Jetson để giảm độ trễ và tiết kiệm băng thông.


Triển khai không chỉ là chạy mô hình, mà còn liên quan đến kiến trúc hệ thống:

  * Tách biệt microservices cho từng nhiệm vụ (xử lý hình ảnh, lưu trữ, giao diện).

  * Thiết kế dashboard trực quan cho phép kỹ sư giám sát luồng dữ liệu, trạng thái từng camera, và kết quả kiểm tra theo thời gian thực.


# Giám sát, Cập nhật và Bảo trì

Môi trường sản xuất thay đổi liên tục, từ ánh sáng cho tới cấu hình máy móc, dẫn đến hiện tượng drift dữ liệu – khi phân phối dữ liệu thực tế khác so với dữ liệu huấn luyện ban đầu.

  * Theo dõi drift dữ liệu: Sử dụng công cụ như EvidentlyAI hoặc WhyLabs để cảnh báo khi thống kê dữ liệu đầu vào thay đổi.

  * Huấn luyện định kỳ: Lập lịch huấn luyện lại (ví dụ hàng tháng) với dữ liệu mới để mô hình luôn phản ánh thực tế.

  * A/B Testing: Triển khai song song hai phiên bản mô hình để so sánh hiệu suất trước khi cập nhật chính thức.


Về bảo mật:

  * Mã hóa luồng video (TLS/SSL).

  * Phân quyền người dùng và ghi log chi tiết để truy xuất quyết định của mô hình khi cần điều tra.


Việc giám sát và bảo trì liên tục đảm bảo hệ thống hoạt động ổn định, tránh giảm hiệu năng khi môi trường thay đổi.

# Tối ưu Chi phí và Mở Rộng Hệ Thống

Để giải pháp thị giác máy tính bền vững và có thể mở rộng:

  * Điện toán đám mây lai: Kết hợp cloud và edge giúp giảm chi phí băng thông nhưng vẫn đảm bảo khả năng xử lý khối lượng lớn khi cần.

  * Mô hình kinh doanh linh hoạt: “Computer Vision as a Service” – tính phí dựa trên số lượng khung hình hoặc camera đang hoạt động.

  * Tự động hóa quản trị: Sử dụng hạ tầng như Kubernetes để tự động scale khi số lượng camera tăng, giảm thiểu can thiệp thủ công.

  * Chuẩn hóa tài liệu kỹ thuật: Xây dựng bộ quy trình vận hành chuẩn (SOP) giúp việc nhân rộng sang nhiều nhà máy diễn ra nhanh chóng.


Một hệ thống được tối ưu chi phí và linh hoạt trong mở rộng sẽ dễ dàng thích ứng khi doanh nghiệp phát triển hoặc khi yêu cầu sản xuất tăng cao.

# Public069

Dữ liệu chuỗi thời gian (time series) xuất hiện trong hầu hết các lĩnh vực: từ tín hiệu cảm biến công nghiệp, log máy chủ, giao dịch tài chính cho đến dữ liệu khí tượng. Khác với dữ liệu dạng bảng thông thường, chuỗi thời gian đòi hỏi các phương pháp thu thập và quản lý đặc thù để đảm bảo tính liên tục, đồng bộ và chất lượng. Dưới đây là các phương pháp và nguyên tắc triển khai chi tiết, đủ để xây dựng một hệ thống bền vững và có khả năng mở rộng.

# Xác định Nguồn Dữ Liệu và Yêu Cầu Kỹ Thuật

  * Nguồn dữ liệu cảm biến công nghiệp: cảm biến nhiệt độ, áp suất, độ ẩm, rung động từ dây chuyền sản xuất.

  * Nguồn dữ liệu số hóa khác: log hệ thống, dữ liệu giao dịch thời gian thực từ ngân hàng, sàn giao dịch.

  * Yêu cầu quan trọng:

* Độ chính xác của thời gian ghi nhận (timestamp) phải thống nhất múi giờ và đồng bộ với đồng hồ chuẩn (NTP).

* Đảm bảo tần suất ghi nhận ổn định (1 Hz, 10 Hz hoặc cao hơn tùy ứng dụng).

* Khả năng mở rộng khi số lượng cảm biến hoặc thiết bị tăng gấp nhiều lần.


Các tổ chức cần lập kế hoạch ngay từ đầu về băng thông mạng, chuẩn truyền dữ liệu (MQTT, OPC-UA, gRPC) và phương án chống mất dữ liệu khi đường truyền gặp sự cố.

# Thu Thập Dữ Liệu Thời Gian Thực

  * Hạ tầng thu thập

* Sử dụng gateway IoT để gom dữ liệu từ nhiều cảm biến, thực hiện lọc và chuẩn hóa trước khi gửi về máy chủ.

* Dùng giao thức truyền tin gọn nhẹ như MQTT để giảm độ trễ.

  * Đảm bảo tính toàn vẹn

* Thêm checksum hoặc chữ ký số trong gói dữ liệu.

* Cơ chế retry tự động nếu mất gói, lưu tạm (buffer) tại thiết bị biên để tránh mất mát.

  * Đồng bộ thời gian

* Thiết lập NTP cho toàn bộ thiết bị.

* Kiểm tra lệch giờ định kỳ, đặc biệt quan trọng trong các phân tích tương quan giữa nhiều nguồn dữ liệu.


# Tiền Xử Lý và Làm Giàu Dữ Liệu

Trước khi lưu trữ, dữ liệu cần được xử lý để phục vụ phân tích lâu dài:

  * Làm sạch dữ liệu:

* Loại bỏ các điểm bất thường do lỗi cảm biến (outlier).

* Điền giá trị thiếu bằng phương pháp nội suy tuyến tính hoặc spline.

  * Chuẩn hóa đơn vị: tất cả cảm biến phải quy về cùng hệ đo (°C, bar, v.v.) để dễ so sánh.

  * Tạo đặc trưng (feature engineering):

* Tính toán trung bình trượt, phương sai, các chỉ số theo khung thời gian (5 phút, 1 giờ).

* Sinh nhãn sự kiện (ví dụ: “máy dừng”, “nhiệt độ vượt ngưỡng”) cho các bài toán dự đoán.

  * Nén và mã hóa: Dùng định dạng như Parquet hoặc Protobuf để giảm dung lượng mà vẫn đảm bảo truy vấn nhanh.


# Hệ Thống Lưu Trữ và Quản Lý

  * Cơ sở dữ liệu chuỗi thời gian (TSDB)

* Lựa chọn InfluxDB, TimescaleDB hoặc QuestDB cho khả năng ghi dữ liệu hàng triệu điểm/giây.

* Hỗ trợ truy vấn theo khoảng thời gian, downsampling tự động.

  * Quản lý phiên bản và phân vùng

* Thiết lập chính sách TTL (time-to-live) để lưu dữ liệu chi tiết trong thời gian nhất định rồi nén hoặc tổng hợp.

* Dùng sharding hoặc partitioning theo ngày/tháng để tăng tốc độ truy vấn.

  * Bảo mật và quyền truy cập

* Mã hóa dữ liệu khi truyền và khi lưu.

* Kiểm soát truy cập theo vai trò (Role-Based Access Control) để giới hạn người xem hoặc chỉnh sửa.


# Giám Sát, Bảo Trì và Khả Năng Mở Rộng

  * Giám sát luồng dữ liệu:

* Dùng các công cụ như Prometheus, Grafana để theo dõi tốc độ ghi, độ trễ, số gói lỗi.

* Thiết lập cảnh báo khi có bất thường, ví dụ lưu lượng giảm đột ngột.

  * Chiến lược mở rộng

* Kiến trúc microservices cho phép thêm node ghi/đọc mà không ảnh hưởng dịch vụ hiện tại.

* Dùng cloud-native (Kubernetes) để tự động cân bằng tải.

  * Sao lưu và phục hồi

* Sao lưu định kỳ sang các vùng địa lý khác nhau.

* Thử nghiệm phục hồi để đảm bảo RPO (Recovery Point Objective) và RTO (Recovery Time Objective) đạt yêu cầu.


  * Giám sát luồng dữ liệu:

* Dùng các công cụ như Prometheus, Grafana để theo dõi tốc độ ghi, độ trễ, số gói lỗi.

* Thiết lập cảnh báo khi có bất thường, ví dụ lưu lượng giảm đột ngột.

  * Chiến lược mở rộng

* Kiến trúc microservices cho phép thêm node ghi/đọc mà không ảnh hưởng dịch vụ hiện tại.

* Dùng cloud-native (Kubernetes) để tự động cân bằng tải.

  * Sao lưu và phục hồi

* Sao lưu định kỳ sang các vùng địa lý khác nhau.

* Thử nghiệm phục hồi để đảm bảo RPO (Recovery Point Objective) và RTO (Recovery Time Objective) đạt yêu cầu.

# Public070

Công nghệ 5G không chỉ là thế hệ tiếp theo của mạng di động mà còn là nền tảng cho một hệ sinh thái kết nối khổng lồ, hỗ trợ từ truyền thông siêu tốc đến Internet vạn vật (IoT) công nghiệp. Việc triển khai 5G đòi hỏi phương pháp kỹ thuật và quản lý chặt chẽ để bảo đảm hiệu năng, bảo mật và khả năng mở rộng lâu dài. Phần dưới đây trình bày chi tiết các phương pháp và nguyên tắc giúp xây dựng và vận hành hệ thống 5G toàn diện.

# Kiến Trúc Mạng 5G và Thành Phần Cốt Lõi

Mạng 5G được thiết kế với cấu trúc mở và linh hoạt hơn hẳn 4G, bao gồm:

  * **Mạng truy nhập vô tuyến (RAN – Radio Access Network)**

* Sử dụng các trạm gNodeB với công nghệ Massive MIMO, beamforming để tăng tốc độ và độ phủ sóng.

* Hỗ trợ băng tần đa dạng: dưới 6 GHz (Sub-6) và mmWave (24–100 GHz) cho các yêu cầu băng thông cực cao.

  * **Mạng lõi (5GC – 5G Core)**

* Thiết kế hoàn toàn theo hướng dịch vụ (Service-Based Architecture – SBA).

* Cho phép **network slicing** , tách mạng thành nhiều “lát” phục vụ từng ứng dụng: IoT băng hẹp, dịch vụ băng thông cao, hay truyền thông siêu tin cậy (URLLC).

  * **Edge Computing**

* Đưa xử lý dữ liệu tới gần người dùng, giảm độ trễ xuống dưới 1 ms, hỗ trợ các ứng dụng như xe tự lái hoặc phẫu thuật từ xa.


# Phương Pháp Quy Hoạch và Triển Khai Hạ Tầng

  * **Khảo sát và lập kế hoạch tần số**

* Đánh giá môi trường địa hình, mật độ dân cư, nhu cầu dịch vụ để xác định dải tần phù hợp.

* Phân tích nhiễu sóng, lập sơ đồ phủ sóng tối ưu.

  * **Triển khai gNodeB**

* Sử dụng mô hình small cell dày đặc để tận dụng băng tần cao, đặc biệt với mmWave.

* Tích hợp công nghệ beamforming để tập trung tín hiệu, giảm tiêu thụ năng lượng.

  * **Điện toán biên (MEC)**

* Xây dựng trung tâm xử lý tại các điểm nút mạng để giảm băng thông đường trục.

* Hỗ trợ các ứng dụng đòi hỏi độ trễ thấp như AR/VR, game thời gian thực.

  * **Tích hợp Cloud-Native**

* Sử dụng container (Docker/Kubernetes) để triển khai 5G Core, dễ dàng mở rộng hoặc cập nhật dịch vụ.


# Quản Lý Chất Lượng Dịch Vụ và Bảo Mật

  * **Đảm bảo QoS (Quality of Service)**

* Phân chia network slicing cho từng loại dịch vụ:

  * eMBB (Enhanced Mobile Broadband) cho video 8K, VR.

  * URLLC (Ultra-Reliable Low Latency Communications) cho xe tự lái, điều khiển robot.

  * mMTC (massive Machine Type Communications) cho hàng triệu cảm biến IoT.

  * **Bảo mật đa lớp**

* Mã hóa đầu cuối giữa thiết bị và mạng lõi.

* Hệ thống phát hiện xâm nhập thời gian thực, kiểm soát truy cập theo vai trò.

* Quản lý chứng chỉ cho hàng tỷ thiết bị IoT kết nối.

  * **Giám sát và phân tích**

* Dùng AI/ML để phát hiện bất thường trong lưu lượng.

* Cảnh báo sớm khi có dấu hiệu tấn công DDoS hoặc suy giảm hiệu năng.


# Tối Ưu Hiệu Năng và Chi Phí Vận Hành

  * **Tự động hóa O-RAN**

* Kiến trúc Open RAN cho phép nhiều nhà cung cấp thiết bị cùng tham gia, giảm chi phí đầu tư.

* AI hỗ trợ tự điều chỉnh thông số mạng dựa trên nhu cầu thực tế.

  * **Năng lượng và bền vững**

* Tích hợp năng lượng tái tạo (mặt trời, gió) cho các trạm gốc ở vùng xa.

* Chế độ ngủ động (sleep mode) cho cell khi không có lưu lượng để tiết kiệm điện.

  * **Khả năng mở rộng**

* Hỗ trợ từ mạng thành phố đến mạng chuyên dụng cho nhà máy, bệnh viện, khu công nghiệp.

* Mô hình “Network-as-a-Service” cho phép doanh nghiệp thuê hạ tầng 5G theo nhu cầu.


# Ứng Dụng Công Nghiệp và Dân Dụng

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

# Public071

Internet vạn vật (IoT) đang mở rộng với tốc độ chưa từng có, kết nối hàng chục tỷ thiết bị từ cảm biến công nghiệp, thiết bị y tế đến phương tiện giao thông và hạ tầng thành phố thông minh. Việc quản lý và bảo mật mạng lưới IoT quy mô lớn đòi hỏi phương pháp kỹ thuật toàn diện, kết hợp từ khâu thiết kế kiến trúc đến giám sát, phản ứng sự cố. Dưới đây là nội dung chuyên sâu, được mở rộng chi tiết nhằm cung cấp cái nhìn đầy đủ cho việc xây dựng và vận hành một hệ thống IoT bền vững, đủ dài cho tài liệu khoảng 10 trang Word.

# Kiến Trúc Hệ Thống và Phương Pháp Triển Khai

Để phục vụ hàng triệu thiết bị kết nối đồng thời, kiến trúc IoT cần đảm bảo **tính phân cấp** , **khả năng mở rộng** , và **độ tin cậy cao**.

  * **Lớp thiết bị (Device Layer)**

* Bao gồm cảm biến, bộ truyền động, thiết bị đeo, phương tiện, camera giám sát.

* Thiết bị phải hỗ trợ giao thức nhẹ (MQTT, CoAP) và cơ chế bảo mật phần cứng như TPM hoặc Secure Element.

* Quản lý nguồn điện: thiết kế tối ưu năng lượng, chế độ ngủ sâu (deep sleep) để kéo dài tuổi thọ pin.

  * **Lớp mạng (Network Layer)**

* Hỗ trợ đa dạng giao thức: Wi-Fi 6, 5G, LPWAN (LoRaWAN, NB-IoT) tùy ứng dụng.

* Áp dụng định tuyến động và tự phục hồi khi có nút hỏng (mesh network).

* Tích hợp SDN (Software Defined Networking) để điều khiển luồng dữ liệu linh hoạt.

  * **Lớp xử lý và ứng dụng (Edge/Cloud Layer)**

* Edge computing giảm độ trễ, xử lý sơ bộ dữ liệu tại thiết bị biên.

* Cloud IoT platform (AWS IoT, Azure IoT Hub, Google IoT Core) lưu trữ và phân tích dữ liệu ở quy mô petabyte.

* Hỗ trợ microservices và container để dễ mở rộng, cập nhật dịch vụ mà không gây gián đoạn.


# Phương Pháp Quản Lý Thiết Bị Ở Quy Mô Hàng Triệu Node

Việc vận hành một mạng IoT khổng lồ cần hệ thống quản lý tập trung nhưng linh hoạt:

  * **Đăng ký và cung cấp (Provisioning)**

* Tự động cấp chứng chỉ số cho thiết bị mới.

* Xác minh danh tính thiết bị qua PKI (Public Key Infrastructure).

  * **Giám sát từ xa**

* Theo dõi tình trạng pin, chất lượng kết nối, tình trạng cảm biến.

* Cảnh báo khi thiết bị ngắt kết nối hoặc gửi dữ liệu bất thường.

  * **Quản lý cấu hình và cập nhật (OTA – Over-the-Air)**

* Cập nhật firmware đồng loạt mà không cần tiếp cận vật lý.

* Hỗ trợ cập nhật vi sai (delta update) để tiết kiệm băng thông.

  * **Phân nhóm và ưu tiên**

* Phân loại thiết bị theo vị trí địa lý, loại dịch vụ, hoặc mức độ quan trọng.

* Cho phép triển khai bản vá trước cho nhóm thiết bị trọng yếu.


# Bảo Mật Đa Lớp Cho Mạng IoT

Với số lượng thiết bị khổng lồ, bảo mật trở thành ưu tiên hàng đầu:

  * **Bảo mật thiết bị đầu cuối**

* Khởi động an toàn (secure boot) đảm bảo chỉ phần mềm đáng tin cậy được chạy.

* Mã hóa lưu trữ nội bộ để bảo vệ dữ liệu khi thiết bị bị đánh cắp.

  * **Bảo mật truyền thông**

* Giao thức TLS/DTLS cho kết nối TCP/UDP.

* Xác thực hai chiều giữa thiết bị và máy chủ.

  * **Phát hiện và phản ứng sự cố**

* Hệ thống IDS/IPS chuyên cho IoT, sử dụng học máy để phát hiện hành vi bất thường.

* Cơ chế cách ly thiết bị nghi ngờ bị tấn công để ngăn lan truyền.

  * **Quản lý khóa và chứng chỉ**

* Tự động luân chuyển khóa định kỳ.

* Hủy chứng chỉ ngay khi phát hiện thiết bị bị xâm nhập.


# Giám Sát Hoạt Động và Phân Tích Dữ Liệu Lớn

Khi số lượng thiết bị lên đến hàng triệu, lượng dữ liệu thu thập mỗi ngày có thể đạt đến hàng trăm terabyte:

  * **Thu thập và lưu trữ dữ liệu**

* Sử dụng cơ sở dữ liệu time-series như InfluxDB hoặc TimescaleDB cho dữ liệu cảm biến.

* Hệ thống lưu trữ phân tán (HDFS, Object Storage) cho dữ liệu phi cấu trúc như video.

  * **Thu thập và lưu trữ dữ liệu**

* Sử dụng cơ sở dữ liệu time-series như InfluxDB hoặc TimescaleDB cho dữ liệu cảm biến.

* Hệ thống lưu trữ phân tán (HDFS, Object Storage) cho dữ liệu phi cấu trúc như video.

  * **Thu thập và lưu trữ dữ liệu**

* Sử dụng cơ sở dữ liệu time-series như InfluxDB hoặc TimescaleDB cho dữ liệu cảm biến.

* Hệ thống lưu trữ phân tán (HDFS, Object Storage) cho dữ liệu phi cấu trúc như video.

  * **Phân tích và trực quan hóa**

* Dùng Apache Spark hoặc Flink để xử lý luồng dữ liệu thời gian thực.

* Dashboard Grafana, Kibana cho phép giám sát theo thời gian thực và lịch sử.

  * **Phát hiện bất thường bằng AI**

* Huấn luyện mô hình học máy để dự đoán lỗi thiết bị.

* Cảnh báo sớm giúp giảm thời gian gián đoạn dịch vụ.


# Chiến Lược Bền Vững và Tuân Thủ Quy Định

  * **Quy định và tiêu chuẩn**

* Tuân thủ các tiêu chuẩn quốc tế như ISO/IEC 27001, GDPR cho quyền riêng tư.

* Đảm bảo thiết bị đạt chứng nhận CE, FCC trước khi thương mại hóa.

  * **Tối ưu chi phí vận hành**

* Mô hình “IoT as a Service” cho phép doanh nghiệp chỉ trả tiền theo mức sử dụng.

* Tận dụng nguồn năng lượng tái tạo và pin mặt trời cho thiết bị ở vùng xa.

  * **Kế hoạch phục hồi thảm họa**

* Sao lưu dữ liệu ở nhiều khu vực địa lý.

* Kịch bản khôi phục nhanh khi xảy ra mất điện, cháy nổ hoặc tấn công mạng quy mô lớn.

# Public072

# Giới thiệu tổng quan

Học Tăng Cường Sâu (Deep Reinforcement Learning – DRL) là sự kết hợp giữa Học Tăng Cường (Reinforcement Learning – RL) và Mạng Nơ-ron Sâu (Deep Neural Networks). Đây là một hướng đi đột phá cho phép hệ thống học từ **tương tác trực tiếp với môi trường** , đưa ra các quyết định tối ưu mà không cần mô hình hóa chính xác toàn bộ động lực học.

Trong bối cảnh robot công nghiệp, DRL cho phép:

  * Robot **tự khám phá** chiến lược điều khiển để tối ưu hóa hiệu suất.

  * **Thích ứng linh hoạt** khi điều kiện môi trường hoặc cấu hình hệ thống thay đổi.

  * **Giảm phụ thuộc** vào các chuyên gia thiết kế thuật toán điều khiển thủ công.


Cốt lõi của DRL là **quy trình học qua thử-sai** : hệ thống tự động điều chỉnh chính sách để tối đa hóa phần thưởng (reward) tích lũy trong thời gian dài.

# Kiến trúc hệ thống DRL

Một hệ thống DRL tiêu chuẩn trong robot công nghiệp thường bao gồm:

  * **Agent (Tác nhân):** Bộ não của robot, thực thi thuật toán DRL để chọn hành động.

  * **Environment (Môi trường):** Không gian làm việc, có thể là thực tế (nhà máy, kho hàng) hoặc mô phỏng (Gazebo, MuJoCo).

  * **State (Trạng thái):** Dữ liệu cảm biến gồm vị trí, vận tốc, dữ liệu hình ảnh, tín hiệu lực, v.v.

  * **Action (Hành động):** Tín hiệu điều khiển như xoay khớp tay, dịch chuyển, kẹp hoặc nhả vật.

  * **Reward (Phần thưởng):** Con số định lượng để đánh giá hiệu quả của hành động, ví dụ “hoàn thành nhiệm vụ trong thời gian ngắn” hoặc “giữ độ chính xác cao”.


Quy trình lặp: Agent quan sát trạng thái → thực hiện hành động → nhận phần thưởng → cập nhật chính sách → lặp lại.

# Thuật toán DRL tiêu biểu và phân tích

Các thuật toán DRL phổ biến:

## Deep Q-Network (DQN)

  * Kết hợp Q-learning với mạng nơ-ron sâu.

  * Xấp xỉ hàm giá trị Q(s,a) để tìm hành động tối ưu.

  * Dùng replay buffer để ổn định huấn luyện.


## Policy Gradient Methods (ví dụ: REINFORCE, A2C, A3C)

  * Tối ưu trực tiếp chính sách π(a|s).

  * Thích hợp cho không gian hành động liên tục.


## Actor-Critic

  * Actor chọn hành động, Critic đánh giá chất lượng.

  * Cải thiện tốc độ và tính ổn định so với chỉ dùng Policy Gradient.


## Proximal Policy Optimization (PPO)

  * Cân bằng giữa hiệu suất và độ ổn định.

  * Phổ biến trong các ứng dụng robot phức tạp.


Các thuật toán này có thể được kết hợp với kiến trúc mạng nơ-ron hiện đại như CNN (xử lý hình ảnh), LSTM/GRU (xử lý chuỗi tín hiệu) để nâng cao khả năng nhận diện trạng thái.

# Ứng dụng trong robot công nghiệp

DRL đã được ứng dụng thành công trong nhiều mảng:

  * **Lắp ráp tự động:**  
Cánh tay robot học cách điều chỉnh lực và vị trí để lắp ráp các chi tiết cực kỳ nhỏ với sai số dưới 0.1 mm.

  * **Quản lý kho thông minh:**  
Robot tự tìm đường tối ưu, tránh va chạm, tiết kiệm thời gian di chuyển trong kho diện tích lớn.

  * **Hàn và sơn tự động:**  
Học đường đi và áp suất phun để đảm bảo lớp sơn/hàn đồng đều trên bề mặt phức tạp.

  * **Bảo trì và kiểm tra:**  
Robot gắn camera học cách di chuyển trong không gian hẹp, kiểm tra lỗi sản phẩm mà không cần lập trình tỉ mỉ.


# Quy trình triển khai thực tế

## Mô phỏng trước khi thử nghiệm thực tế  
Sử dụng các nền tảng như Gazebo, PyBullet, hoặc Isaac Gym để giảm chi phí và rủi ro. Quá trình huấn luyện có thể kéo dài hàng trăm nghìn bước, nên mô phỏng là lựa chọn tiết kiệm.

## Transfer Learning (Chuyển giao học tập)  
Sau khi huấn luyện trên mô phỏng, mô hình được tinh chỉnh để thích ứng với robot thực, khắc phục chênh lệch giữa môi trường ảo và thực tế.

##  Thiết kế phần thưởng (Reward Shaping)

  * Chia nhỏ nhiệm vụ thành nhiều giai đoạn.

  * Phạt nặng các hành động nguy hiểm (quá tốc độ, va chạm).

  * Thưởng dần theo mức độ tiến bộ để học nhanh hơn.


## Đảm bảo an toàn và ràng buộc vật lý  
Áp dụng giới hạn tốc độ, lực, vùng hoạt động. Cảm biến lực và công tắc khẩn cấp cần được tích hợp để ngăn sự cố.

# Thách thức kỹ thuật

  * **Chi phí tính toán:**  
Huấn luyện DRL đòi hỏi GPU/TPU mạnh và thời gian tính toán dài.

  * **Khả năng tổng quát hóa:**  
Robot cần hoạt động tốt trong nhiều tình huống khác nhau, đòi hỏi dữ liệu đa dạng.

  * **Tích hợp cảm biến đa dạng:**  
Camera, LiDAR, cảm biến lực, IMU… tạo ra dòng dữ liệu khổng lồ cần xử lý theo thời gian thực.

  * **Quản lý dữ liệu và nhật ký huấn luyện:**  
Lưu trữ, phân tích log để tối ưu thuật toán.


# Hướng phát triển tương lai

  * **World Model + DRL:**  
Robot tự xây dựng mô hình thế giới nội tại để dự đoán trạng thái tương lai, giảm nhu cầu tương tác thật.

  * **Học tự giám sát (Self-Supervised RL):**  
Sử dụng dữ liệu không gán nhãn để khởi tạo chính sách ban đầu.

  * **Edge Computing & Triển khai gọn nhẹ:**  
Lượng tử hóa mô hình (model quantization) giúp chạy trên phần cứng hạn chế như bộ điều khiển nhúng.

  * **Kết hợp với Học Liên Kết (Federated RL):**  
Nhiều robot học chung mà không cần chia sẻ dữ liệu thô, tăng tính bảo mật.

# Public073

# Bối cảnh và động lực

Trong ngành y tế, việc ứng dụng trí tuệ nhân tạo (AI) vào chẩn đoán, dự đoán và phân tích dữ liệu bệnh nhân ngày càng phổ biến. Tuy nhiên, dữ liệu y tế thường chứa thông tin cá nhân cực kỳ nhạy cảm (hồ sơ bệnh án, hình ảnh y khoa, kết quả xét nghiệm), chịu ràng buộc bởi các quy định nghiêm ngặt như HIPAA (Mỹ), GDPR (châu Âu) và các tiêu chuẩn bảo mật dữ liệu quốc gia.

Vấn đề: Các bệnh viện, phòng khám và tổ chức nghiên cứu muốn hợp tác để xây dựng mô hình AI có độ chính xác cao, nhưng không thể chia sẻ dữ liệu thô do rào cản pháp lý và đạo đức.

Giải pháp: Học Liên Kết (Federated Learning – FL) cho phép huấn luyện mô hình chung trên nhiều nguồn dữ liệu phân tán mà không cần chuyển dữ liệu ra khỏi cơ sở lưu trữ cục bộ.

#  Federated learning là gì?

Federated Learning là một phương pháp nhằm đào tạo các mô hình AI mà không cần bất kỳ ai nhìn thấy hoặc tác động vào dữ liệu của bạn. Điều này giúp bạn có thể sử dụng thông tin mà không cần chia sẻ dữ liệu thật sự, để phục vụ cho các ứng dụng AI mới. 

# Nguyên lý hoạt động của Federated Learning

Federated Learning được triển khai theo mô hình “huấn luyện phân tán – tổng hợp tập trung”:

  1. Khởi tạo mô hình toàn cục (Global Model):  
Máy chủ trung tâm (server) gửi mô hình khởi tạo đến từng máy khách (client).

  2. Huấn luyện cục bộ (Local Training):  
Mỗi cơ sở y tế huấn luyện mô hình trên dữ liệu của riêng mình.

  3. Gửi trọng số (Model Updates):  
Chỉ các thông số/gradient đã cập nhật được gửi về máy chủ, không truyền dữ liệu thô.

  4. Tổng hợp (Aggregation):  
Máy chủ dùng thuật toán như _Federated Averaging_ để hợp nhất các trọng số, tạo ra mô hình toàn cục mới.

  5. Lặp lại:  
Quá trình này tiếp tục cho đến khi mô hình hội tụ.


#  Lợi ích trong y tế

  * Bảo mật và quyền riêng tư:  
Dữ liệu bệnh nhân không bao giờ rời khỏi bệnh viện, giảm nguy cơ rò rỉ.

  * Đa dạng dữ liệu:  
Mô hình được huấn luyện trên dữ liệu phong phú từ nhiều vùng miền, nâng cao khả năng tổng quát hóa.

  * Tuân thủ pháp lý:  
Đáp ứng các quy định bảo mật nghiêm ngặt mà vẫn hợp tác được giữa nhiều tổ chức.


# Kiến trúc và thành phần chính

  * Central Server (Máy chủ trung tâm): Quản lý mô hình toàn cục, điều phối việc tổng hợp trọng số.

  * Clients (Máy khách): Bệnh viện, phòng thí nghiệm hoặc thiết bị y tế thông minh.

  * Secure Communication Layer: Giao thức truyền thông bảo mật (SSL/TLS) để gửi thông số mô hình.

  * Aggregation Algorithm: Thuật toán như _FedAvg_ , _FedProx_ để cân bằng chênh lệch dữ liệu giữa các khách.


# Các phương pháp bảo mật nâng cao

  1. Differential Privacy (DP):  
Thêm nhiễu vào gradient hoặc trọng số trước khi gửi về server, che giấu thông tin cá nhân.

  2. Secure Multi-Party Computation (SMPC):  
Cho phép nhiều bên tính toán chung mà không tiết lộ dữ liệu riêng.

  3. Homomorphic Encryption:  
Mã hóa dữ liệu sao cho vẫn có thể tính toán trực tiếp trên dữ liệu mã hóa.

  4. Trusted Execution Environment (TEE):  
Sử dụng phần cứng bảo mật để đảm bảo chỉ các quá trình được phép mới có thể truy cập thông tin.


# Ứng dụng thực tiễn

  * Chẩn đoán hình ảnh y khoa:  
Huấn luyện mô hình phân tích MRI, CT từ nhiều bệnh viện để phát hiện ung thư sớm.

  * Dự đoán nguy cơ bệnh mãn tính:  
Kết hợp dữ liệu hồ sơ bệnh án điện tử từ nhiều cơ sở để dự đoán tiểu đường, tim mạch.

  * Theo dõi thiết bị đeo y tế:  
Đồng bộ dữ liệu cảm biến từ hàng nghìn thiết bị đeo để phát hiện sớm rối loạn tim.


# Thách thức kỹ thuật

  * Dữ liệu không đồng nhất (Non-IID):  
Mỗi bệnh viện có đặc điểm dân số, thiết bị và quy trình thu thập dữ liệu khác nhau.

  * Kết nối mạng:  
Cần đường truyền ổn định và bảo mật.

  * Chi phí tính toán cục bộ:  
Một số cơ sở y tế có hạ tầng hạn chế, khó chạy mô hình lớn.

  * Cân bằng quyền lực giữa các bên:  
Đảm bảo công bằng giữa các bệnh viện lớn nhỏ khi đóng góp dữ liệu.

  * Kết nối mạng:  
Cần đường truyền ổn định và bảo mật.

  * Chi phí tính toán cục bộ:  
Một số cơ sở y tế có hạ tầng hạn chế, khó chạy mô hình lớn.

  * Cân bằng quyền lực giữa các bên:  
Đảm bảo công bằng giữa các bệnh viện lớn nhỏ khi đóng góp dữ liệu.

  * Kết nối mạng:  
Cần đường truyền ổn định và bảo mật.

  * Chi phí tính toán cục bộ:  
Một số cơ sở y tế có hạ tầng hạn chế, khó chạy mô hình lớn.

  * Cân bằng quyền lực giữa các bên:  
Đảm bảo công bằng giữa các bệnh viện lớn nhỏ khi đóng góp dữ liệu.


#  Hướng phát triển tương lai

  * Federated Learning kết hợp Edge Computing:  
Đưa FL xuống thiết bị di động, thiết bị đeo y tế để huấn luyện trực tiếp trên biên mạng.

  * Hybrid Federated + Transfer Learning:  
Dùng transfer learning để giảm số vòng huấn luyện liên kết.

  * Tích hợp Blockchain:  
Đảm bảo tính minh bạch, bất biến trong ghi nhận quá trình huấn luyện và cập nhật mô hình.

  * Mô hình lượng tử hóa:  
Giảm kích thước trọng số để tiết kiệm băng thông và thời gian truyền.

# Public074

#  Giới thiệu và bối cảnh

Mạng di động thế hệ thứ sáu (6G) được kỳ vọng mang lại tốc độ truyền tải dữ liệu hàng trăm gigabit/giây, độ trễ dưới 1 mili giây, và khả năng kết nối hàng tỷ thiết bị IoT. Tuy nhiên, việc tối ưu hóa cấu trúc mạng 6G – từ phân bổ tài nguyên phổ tần, định tuyến dữ liệu, đến quản lý năng lượng – đặt ra những bài toán tính toán khổng lồ, thường là NP-hard, khó giải quyết bằng máy tính cổ điển.

Điện toán lượng tử (Quantum Computing), với khả năng khai thác hiện tượng chồng chập và rối lượng tử, hứa hẹn giải quyết các bài toán tối ưu này nhanh hơn cấp số nhân so với phương pháp truyền thống.

# Cơ sở lý thuyết điện toán lượng tử

  * Qubit: Đơn vị thông tin cơ bản, tồn tại ở trạng thái chồng chập (0 và 1 đồng thời).

  * Cổng lượng tử (Quantum Gate): Thao tác toán học biến đổi trạng thái qubit, tương tự như cổng logic trong máy tính cổ điển.

  * Rối lượng tử (Entanglement): Liên kết giữa các qubit giúp tính toán song song và truyền thông tin nhanh.

  * Đo lường (Measurement): Quá trình chuyển trạng thái lượng tử thành kết quả nhị phân.


Nhờ các đặc tính này, máy tính lượng tử có thể khám phá không gian nghiệm khổng lồ của các bài toán tối ưu phức tạp.

# Các tính năng vượt trội của 6G so với 5G:

  * Tốc độ vượt trội: Mạng 6G được kỳ vọng sẽ đạt tốc độ truyền dữ liệu lên đến 1 Terabit/giây (Tbps), nhanh hơn gấp 100-500 lần so với 5G. Tốc độ này cho phép tải xuống phim 4K trong vài giây hoặc thậm chí truyền tải hình ảnh голограмма 3D theo thời gian thực.

  * Độ trễ cực thấp: Độ trễ của mạng 6G được dự đoán sẽ giảm xuống dưới 1 micro giây (µs), gần như bằng không. Điều này rất quan trọng cho các ứng dụng yêu cầu phản hồi tức thời, chẳng hạn như thực tế ảo (VR), thực tế tăng cường (AR), lái xe tự động và điều khiển từ xa các thiết bị công nghiệp.

  * Băng thông siêu rộng: 6G sẽ sử dụng các băng tần tần số cao hơn, bao gồm cả sóng milimet và Terahertz (THz), cho phép truyền tải một lượng lớn dữ liệu cùng một lúc. Điều này sẽ đáp ứng nhu cầu ngày càng tăng về băng thông của các ứng dụng như truyền phát video 8K/16K, trò chơi trực tuyến và Internet vạn vật (IoT) quy mô lớn.

  * Khả năng kết nối vạn vật: 6G được thiết kế để kết nối hàng tỷ thiết bị IoT, từ cảm biến trong nhà thông minh đến thiết bị công nghiệp và xe tự lái. Điều này sẽ tạo ra một mạng lưới kết nối rộng khắp, cho phép thu thập và phân tích dữ liệu theo thời gian thực, tối ưu hóa hiệu suất và tạo ra các dịch vụ thông minh.

  * Kết nối không gian: Ngoài kết nối mặt đất, 6G còn hướng đến việc tích hợp các mạng vệ tinh và máy bay không người lái, mở rộng phạm vi phủ sóng đến những vùng sâu vùng xa và khu vực biển đảo. Điều này sẽ đảm bảo kết nối liên tục và ổn định cho người dùng ở bất kỳ đâu.

  * Tích hợp trí tuệ nhân tạo (AI): AI sẽ đóng vai trò then chốt trong việc quản lý và tối ưu hóa mạng 6G. AI sẽ giúp phân bổ tài nguyên mạng một cách thông minh, dự đoán và ngăn chặn các sự cố, cũng như tối ưu hóa hiệu suất của các ứng dụng.

  * Bảo mật nâng cao: Với sự gia tăng của các thiết bị kết nối và lượng dữ liệu được truyền tải, bảo mật trở thành một yếu tố cực kỳ quan trọng. 6G sẽ tích hợp các công nghệ bảo mật tiên tiến để đảm bảo an toàn cho dữ liệu người dùng và ngăn chặn các cuộc tấn công mạng.


# Bài toán tối ưu trong mạng 6G

Các kịch bản tiêu biểu:

  * Phân bổ phổ tần (Spectrum Allocation): Tìm cách chia phổ tần hạn chế cho hàng triệu thiết bị.

  * Định tuyến dữ liệu động: Chọn đường truyền tốt nhất trong thời gian thực để giảm tắc nghẽn.

  * Quản lý năng lượng: Tối ưu công suất phát để tiết kiệm năng lượng mà vẫn đảm bảo chất lượng dịch vụ.

  * Lập lịch truy cập (Scheduling): Điều phối truy cập giữa các thiết bị IoT đa dạng.


Những bài toán này đều đòi hỏi giải các bài toán tối ưu tổ hợp với quy mô cực lớn.

# Ứng dụng thuật toán lượng tử

  1. Quantum Approximate Optimization Algorithm (QAOA):

* Giải các bài toán tối ưu tổ hợp như phân bổ phổ tần.

* Sử dụng mạch lượng tử lai (hybrid quantum-classical).

  2. Variational Quantum Eigensolver (VQE):

* Tìm nghiệm gần đúng của các hệ thống phức tạp, hữu ích cho tối ưu năng lượng.

  3. Grover’s Algorithm:

* Tăng tốc tìm kiếm trong cơ sở dữ liệu, giúp định tuyến và tra cứu nhanh.

  4. Quantum Annealing:

* Tương tự tối ưu hóa bậc thang, đặc biệt hiệu quả cho bài toán lập lịch lớn.


#  Kiến trúc triển khai thực tế

  * Mô hình lai (Hybrid Quantum-Classical):  
Phần lượng tử giải quyết các thành phần tối ưu nặng, trong khi phần cổ điển xử lý giao thức mạng.

  * Tích hợp Cloud-Quantum:  
Các trạm gốc 6G có thể truy cập dịch vụ máy tính lượng tử đám mây (IBM Q, D-Wave) để thực hiện tính toán.

  * Edge Computing:  
Đưa các thuật toán lượng tử nhẹ xuống rìa mạng để giảm độ trễ.


# Lợi ích tiềm năng

  * Tốc độ tính toán: Giải bài toán NP-hard trong thời gian khả thi.

  * Tiết kiệm năng lượng: Phân bổ tài nguyên tối ưu giảm lãng phí.

  * Khả năng mở rộng: Phù hợp với lượng thiết bị IoT khổng lồ trong kỷ nguyên 6G.


# Thách thức

  * Hạ tầng phần cứng lượng tử:  
Máy tính lượng tử vẫn hạn chế về số lượng qubit và độ bền.

  * Thuật toán chuyên biệt:  
Cần phát triển thuật toán phù hợp bài toán mạng viễn thông.

  * Tích hợp hệ thống:  
Đồng bộ giữa mạng lượng tử và mạng cổ điển đòi hỏi chuẩn giao thức mới.


#  Hướng nghiên cứu tương lai

  * Lượng tử hóa mạng (Quantum Networking):  
Tích hợp kênh truyền lượng tử cho truyền thông siêu an toàn.

  * AI lượng tử (Quantum Machine Learning):  
Sử dụng mạng lượng tử để học và tối ưu hóa động.

  * Chống nhiễu lượng tử:  
Tăng độ ổn định cho mạch lượng tử để triển khai thực tế.

# Public075

Các nhà nghiên cứu tại Viện Công nghệ New Jersey (NJIT) đã sử dụng trí tuệ nhân tạo (AI) để giải quyết vấn đề quan trọng trong việc lưu trữ năng lượng trong tương lai. Theo đó, công cụ AI cung cấp giải pháp thay thế bền vững với chi phí hợp lý cho pin lithium-ion. Kết quả nghiên cứu đã được công bố trên tạp chí _Cell Reports Physical Science_.

Nhóm nghiên cứu đã áp dụng thành công kỹ thuật AI tạo sinh để nhanh chóng khám phá các vật liệu xốp mới có khả năng cách mạng hóa pin đa hóa trị. Loại pin này sử dụng các nguyên tố dồi dào như magiê, canxi, nhôm và kẽm, mang đến giải pháp thay thế triển vọng và tiết kiệm chi phí cho pin lithium-ion đang gặp khó khăn về nguồn cung trên toàn cầu và tính bền vững.

Không giống pin lithium-ion truyền thống chỉ dựa vào các ion lithium mang điện tích dương, pin đa hóa trị sử dụng các nguyên tố có ion mang hai hoặc thậm chí ba điện tích dương. Điều này có nghĩa là pin đa hóa trị lưu trữ nhiều năng lượng hơn đáng kể nên trở thành giải pháp lưu trữ năng lượng hấp dẫn trong tương lai. Tuy nhiên, các ion đa hóa trị có kích thước và điện tích lớn dẫn đến khó tích hợp chúng hiệu quả vào vật liệu pin.

# Bối cảnh và động lực

Sự phát triển của lưới điện thông minh (Smart Grid) và nhu cầu tích hợp năng lượng tái tạo như gió, mặt trời đòi hỏi các giải pháp lưu trữ năng lượng hiệu quả. Năng lượng tái tạo có tính dao động cao: khi mặt trời lặn hoặc gió yếu, nguồn cung giảm đột ngột. Hệ thống lưới điện thông minh cần các công nghệ pin thế hệ mới để:

  * Cân bằng cung – cầu điện.

  * Giảm tải trong giờ cao điểm.

  * Đảm bảo độ ổn định và độ tin cậy cho toàn hệ thống.


# Hạn chế của pin truyền thống

Pin lithium-ion (Li-ion) đã trở thành chuẩn mực trong nhiều năm qua, nhưng:

  * Giới hạn về mật độ năng lượng và chu kỳ sạc xả.

  * Nguy cơ cháy nổ do chất điện phân lỏng.

  * Chi phí nguyên liệu tăng cao, đặc biệt là cobalt và lithium.


Điều này thúc đẩy nghiên cứu các pin thế hệ mới có khả năng an toàn hơn, tuổi thọ dài hơn và thân thiện với môi trường.

# Xu hướng chi phí và công nghệ:

Công nghệ pin lithium-ion (Li-ion) vẫn chiếm ưu thế tuyệt đối trong các dự án BESS hiện nay nhờ mật độ năng lượng cao, độ tin cậy và chi phí ngày càng giảm. Giá pin lithium-ion tiếp tục giảm so với giai đoạn trước, nhưng từ 2023-2025 xu hướng giảm đã chậm lại.

Theo thống kê: Giá thành pack pin Li-ion (là quá trình lắp ráp các Cells Pin Lithium, bảng mạch bảo vệ, đầu nối, vỏ ngoài, v.v... để tạo thành một bộ pin hoàn chỉnh) hiện nay vào khoảng 150-160 USD/kWh (giảm mạnh so với mức trên 1.000 USD/kWh cách đây một thập kỷ).

Các hệ thống BESS phổ biến có thời lượng lưu trữ 2-4 giờ, phù hợp với nhu cầu cân bằng phụ tải và hấp thụ NLTT dư thừa. Trong khi đó, các công nghệ lưu trữ dài hạn (LDES) như pin dòng (flow battery), sodium-ion, hay hydro đang được nghiên cứu và thử nghiệm để đáp ứng nhu cầu lưu trữ trên 8 giờ.

# Các công nghệ pin thế hệ mới

## Pin Thể Rắn (Solid-State Battery)

  * Đặc điểm: Sử dụng chất điện phân rắn thay vì lỏng.

  * Ưu điểm:

* Mật độ năng lượng cao hơn 2–3 lần pin Li-ion.

* An toàn hơn, giảm nguy cơ cháy nổ.

* Chu kỳ sạc xả dài.

  * Thách thức: Chi phí sản xuất cao, khó mở rộng công nghiệp.


## Pin Sodium-Ion (Na-ion)

  * Đặc điểm: Sử dụng natri (Na) – nguyên liệu rẻ và dồi dào.

  * Ưu điểm:

* Chi phí thấp.

* Hoạt động tốt ở nhiệt độ thấp.

  * Ứng dụng: Lưu trữ quy mô lớn trong lưới điện.


## Pin Lưu Lượng (Flow Battery)

  * Cơ chế: Năng lượng lưu trữ trong dung dịch điện phân lỏng chứa ion kim loại.

  * Ưu điểm:

* Dễ mở rộng dung lượng chỉ bằng việc tăng kích thước bể chứa.

* Tuổi thọ hàng chục nghìn chu kỳ.

  * Nhược điểm: Mật độ năng lượng thấp, cần diện tích lớn.


## Pin Lithium-Sulfur (Li-S)

  * Ưu điểm: Mật độ năng lượng cao gấp 5 lần Li-ion, nguyên liệu lưu huỳnh rẻ.

  * Thách thức: Sự hình thành polysulfide gây suy giảm dung lượng.


# Tích hợp pin vào lưới điện thông minh

  * Điều độ năng lượng (Energy Dispatch): Tự động nạp/xả pin để cân bằng tải.

  * Dự báo nguồn tái tạo: Kết hợp AI để dự đoán sản lượng gió, mặt trời và điều chỉnh lưu trữ.

  * Microgrid: Các lưới điện nhỏ độc lập dùng pin để hoạt động khi mất điện từ lưới chính.


# Lợi ích đối với lưới điện thông minh

  * Ổn định điện áp và tần số: Đáp ứng nhanh các dao động tải.

  * Giảm chi phí vận hành: Tối ưu hóa mua bán điện trên thị trường.

  * Hỗ trợ năng lượng tái tạo: Tích trữ điện dư vào ban ngày, cung cấp khi thiếu.


# Thách thức và giải pháp

  * Chi phí đầu tư: Cần giảm giá thành pin thể rắn và pin Li-S.

  * Chuỗi cung ứng nguyên liệu: Phát triển khai thác natri, lưu huỳnh bền vững.

  * Quản lý tái chế: Thiết lập hệ thống thu hồi và tái chế pin an toàn.


# Hướng phát triển tương lai

  * Kết hợp trí tuệ nhân tạo: Dự đoán tuổi thọ pin và điều khiển sạc thông minh.

  * Pin lai (Hybrid Battery): Kết hợp nhiều công nghệ (Na-ion + Flow) để cân bằng hiệu suất và chi phí.

  * Tiêu chuẩn hóa toàn cầu: Thiết lập giao thức kết nối pin với lưới điện để dễ triển khai.

# Public076

# Bối cảnh và động lực phát triển

Trong kỷ nguyên chuyển đổi số toàn diện, dữ liệu trở thành tài sản cốt lõi của doanh nghiệp và chính phủ. Cùng lúc, hạ tầng mạng ngày càng phức tạp: từ điện toán đám mây, đa đám mây (multi-cloud), tới Internet vạn vật (IoT) và 5G/6G. Sự phức tạp này mở rộng bề mặt tấn công, khiến các kỹ thuật phòng thủ truyền thống khó theo kịp.

Các cuộc tấn công hiện đại như ransomware-as-a-service, deepfake phishing, và APT (Advanced Persistent Threat) có thể ẩn mình hàng tháng, thậm chí hàng năm, trước khi gây ra thiệt hại. Việc dựa vào chữ ký (signature-based detection) hay danh sách chặn tĩnh (static blocklists) không còn đủ.

Trí tuệ nhân tạo mang lại bước nhảy vọt: học từ dữ liệu, phát hiện hành vi bất thường, và tự động phản ứng trước mối đe dọa gần như thời gian thực.

#  Kiến trúc tổng thể của hệ thống phòng thủ AI

Một giải pháp AI an ninh mạng toàn diện thường bao gồm nhiều lớp:

## Tầng thu thập dữ liệu

  * Nguồn dữ liệu: nhật ký hệ thống (syslog), gói tin mạng, sự kiện bảo mật từ các thiết bị IoT, truy cập đám mây.

  * Chuẩn hóa: hợp nhất định dạng từ nhiều nguồn, loại bỏ dữ liệu nhiễu và trùng lặp.


## Tầng phân tích và học máy

  * Giám sát (Supervised Learning): sử dụng dữ liệu đã gắn nhãn (ví dụ, gói tin tấn công) để dự đoán tấn công đã biết.

  * Không giám sát (Unsupervised/Anomaly Detection): tìm kiếm mẫu hành vi bất thường, hữu ích với các cuộc tấn công 0-day.

  * Học bán giám sát và tự giám sát: giảm phụ thuộc vào dữ liệu gắn nhãn khan hiếm.

  * Học tăng cường (Reinforcement Learning): cho phép hệ thống tự điều chỉnh chính sách phản ứng dựa trên kết quả.


## Tầng phát hiện thời gian thực

  * AI phân tích luồng dữ liệu liên tục, đưa ra cảnh báo gần như tức thời.

  * Kết hợp với các hệ thống Intrusion Detection/Prevention (IDS/IPS) để tự động chặn lưu lượng độc hại.


## Tầng phản ứng và tự động hóa

  * Tự động cách ly thiết bị nghi nhiễm.

  * Cập nhật quy tắc tường lửa động.

  * Tích hợp nền tảng SOAR (Security Orchestration, Automation and Response) để phối hợp hành động đa hệ thống.


#  Kỹ thuật AI nổi bật và vai trò

  * Deep Neural Networks (DNN): Khả năng học biểu diễn phi tuyến tính cao, thích hợp cho dữ liệu mạng phức tạp.

  * Recurrent Neural Networks (RNN, LSTM, GRU): Xuất sắc trong phân tích chuỗi thời gian, ví dụ phát hiện tấn công DDoS dựa trên luồng lưu lượng.

  * Graph Neural Networks (GNN): Mô hình hóa quan hệ giữa các nút mạng, giúp phát hiện botnet hoặc hành vi lan truyền của mã độc.

  * Generative Adversarial Networks (GAN): Sinh dữ liệu tấn công giả để huấn luyện mô hình phòng thủ, nâng cao khả năng chống đỡ trước kịch bản mới.


# .Ứng dụng thực tiễn đa dạng

## Phát hiện xâm nhập thông minh

  * AI thay thế chữ ký tĩnh, phát hiện 0-day exploit và tấn công chưa từng ghi nhận.


## Phòng chống lừa đảo (Anti-Phishing)

  * Phân tích ngôn ngữ email, hành vi người gửi, và liên kết URL để phát hiện phishing tinh vi.


## Phân tích mã độc tự động

  * Học từ đặc trưng hành vi chạy của malware, kể cả khi mã được nén hoặc làm rối.


## Bảo vệ IoT

  * Mạng cảm biến, thiết bị đeo y tế và camera IP thường thiếu lớp bảo mật truyền thống, AI có thể theo dõi hành vi để ngăn botnet.


## Tự động ứng phó sự cố

  * Khi phát hiện vi phạm, hệ thống có thể tự cô lập máy chủ, vô hiệu hóa tài khoản bị xâm nhập, đồng thời gửi báo cáo chi tiết.


# Lợi ích chiến lược

  * Phát hiện nhanh và chính xác: Giảm thời gian trung bình phát hiện (MTTD) từ hàng giờ xuống chỉ vài giây.

  * Khả năng thích ứng: Mô hình liên tục học từ dữ liệu mới, không bị giới hạn bởi danh sách chặn tĩnh.

  * Tối ưu chi phí nhân lực: Giảm tải cho đội ngũ SOC (Security Operation Center), tập trung vào quyết định chiến lược.

  * Khả năng mở rộng: Xử lý khối lượng dữ liệu từ hàng triệu điểm cuối mà vẫn đảm bảo tốc độ.


# Thách thức và hạn chế

  * Thiếu dữ liệu gắn nhãn: Việc phân loại lưu lượng độc hại đòi hỏi chuyên gia, tốn kém thời gian.

  * Tấn công đối kháng (Adversarial Attack): Hacker có thể tạo dữ liệu giả đánh lừa mô hình.

  * Quyền riêng tư và tuân thủ pháp lý: Thu thập và xử lý dữ liệu phải tuân theo chuẩn GDPR, HIPAA.

  * Khả năng giải thích (Explainability): Các mô hình sâu thường khó giải thích, gây khó khăn khi cần bằng chứng pháp lý.


#  Hướng nghiên cứu và phát triển tương lai

  * Explainable AI (XAI): Cung cấp lý do, bằng chứng rõ ràng cho từng cảnh báo để chuyên gia bảo mật kiểm chứng.

  * Federated Learning: Nhiều tổ chức cùng huấn luyện mô hình chung mà không chia sẻ dữ liệu thô, bảo vệ quyền riêng tư.

  * Multi-Agent Systems: Nhiều tác nhân AI hợp tác, trao đổi thông tin tấn công trên quy mô toàn cầu.

  * Kết hợp Blockchain: Ghi lại nhật ký bảo mật bất biến, tạo bằng chứng không thể chối cãi.

  * AI kết hợp lượng tử (Quantum AI): Tăng tốc huấn luyện mô hình khổng lồ trong thời gian gần như thực.


# Ví dụ thực tế tiêu biểu

  * Google Chronicle & Microsoft Sentinel: Sử dụng AI để phân tích hàng petabyte dữ liệu bảo mật, phát hiện tấn công trong vài phút.

  * Darktrace: Ứng dụng Machine Learning không giám sát để phát hiện bất thường trong hành vi người dùng và thiết bị.

  * IBM QRadar + Watson: Tích hợp NLP của Watson để đọc, hiểu và liên kết thông tin từ hàng triệu tài liệu bảo mật.

# Public077

#  Bối cảnh và nhu cầu cấp thiết

Chuỗi cung ứng toàn cầu là mạng lưới phức tạp liên kết nhà sản xuất, nhà cung ứng nguyên liệu, kho bãi, các công ty vận tải, và nhà bán lẻ. Mỗi sản phẩm, từ dược phẩm, thực phẩm, đến linh kiện điện tử, có thể trải qua hàng chục quốc gia và hàng trăm điểm trung gian.

Tuy nhiên, quá trình này gặp nhiều thách thức:

  * Thiếu minh bạch: Khó xác định chính xác nguồn gốc, đặc biệt với thực phẩm tươi sống hoặc thuốc.

  * Nguy cơ giả mạo: Sản phẩm giả, kém chất lượng dễ dàng thâm nhập.

  * Dữ liệu phân tán: Mỗi bên lưu trữ thông tin riêng, không đồng bộ, gây chậm trễ.

  * Chi phí xác thực cao: Việc đối soát thủ công giấy tờ, chứng từ kéo dài thời gian giao hàng và tăng chi phí.


Blockchain nổi lên như giải pháp tạo một “sổ cái phân tán” toàn cầu, minh bạch, chống chỉnh sửa, cho phép tất cả bên liên quan truy cập cùng một phiên bản dữ liệu sự thật.

#  Nguyên lý hoạt động cốt lõi của Blockchain

## Cấu trúc khối (Block):

  * Mỗi khối chứa dữ liệu giao dịch, thông tin lô hàng, thời gian, chữ ký số.

  * Khối mới được thêm sau khi đạt đồng thuận của mạng lưới.


## Chuỗi liên kết (Chain):

  * Các khối nối với nhau bằng hàm băm (hash), đảm bảo không thể chỉnh sửa lùi.


## Cơ chế đồng thuận:

  * Tùy quy mô, chuỗi cung ứng có thể dùng Proof of Stake (PoS), Practical Byzantine Fault Tolerance (PBFT) hoặc Proof of Authority (PoA) để xác nhận giao dịch nhanh, tiết kiệm năng lượng.


## Hợp đồng thông minh (Smart Contract):

  * Các điều khoản giao dịch được lập trình sẵn.

  * Tự động thanh toán, phát lệnh giao hàng khi điều kiện đạt chuẩn.


# Ứng dụng chi tiết trong chuỗi cung ứng

##  Truy xuất nguồn gốc minh bạch

  * Mỗi lần sản phẩm di chuyển, thông tin như nhiệt độ bảo quản, địa điểm, thời gian được ghi vào blockchain.

  * Người tiêu dùng chỉ cần quét mã QR để biết toàn bộ lịch sử sản phẩm.

  * Ví dụ: IBM Food Trust giúp Walmart truy xuất nguồn gốc xoài từ nông trại đến kệ hàng chỉ trong 2,2 giây (so với 6 ngày trước đây).


## Chống giả mạo và gian lận

  * Sản phẩm gắn mã định danh duy nhất, dữ liệu không thể sửa đổi.

  * Ngành dược phẩm: blockchain giúp đảm bảo thuốc không bị thay thế hay tráo đổi.


## Tự động hóa thanh toán và hợp đồng

  * Khi hàng hóa đến đúng địa điểm, cảm biến IoT cập nhật dữ liệu, Smart Contract tự động giải ngân.

  * Giảm nhu cầu trung gian tài chính, giảm chi phí giao dịch quốc tế.


##  Tối ưu vận chuyển và tồn kho

  * Dữ liệu thời gian thực giúp nhà quản lý dự báo nhu cầu, giảm hàng tồn, và điều phối xe vận chuyển hiệu quả.

  * Tích hợp với hệ thống AI để tối ưu tuyến đường, giảm phát thải carbon.


## Đảm bảo tuân thủ và kiểm toán

  * Chứng nhận an toàn thực phẩm, tiêu chuẩn môi trường, hóa đơn đều được ghi bất biến.

  * Giúp công ty đáp ứng các quy định như FDA, EU Food Law, hoặc ISO 9001.


#  Lợi ích chiến lược vượt trội

  * Minh bạch toàn diện: Mọi bên tham gia truy cập cùng một nguồn dữ liệu, hạn chế tranh chấp.

  * Tốc độ xử lý nhanh: Rút ngắn thời gian thông quan từ nhiều ngày xuống vài giờ.

  * Giảm chi phí trung gian: Cắt bỏ các khâu đối soát thủ công và đơn vị trung gian tài chính.

  * Tăng niềm tin người tiêu dùng: Minh bạch nguồn gốc sản phẩm, bảo vệ thương hiệu.


#  Thách thức triển khai

  1. Quy mô giao dịch khổng lồ:

* Hàng tỷ giao dịch đòi hỏi blockchain có khả năng mở rộng, cần giải pháp layer 2 hoặc sidechain.

  2. Bảo mật dữ liệu nhạy cảm:

* Phải kết hợp mã hóa, quyền truy cập theo vai trò, và kênh truyền riêng tư để bảo vệ bí mật thương mại.

  3. Chi phí và chuẩn hóa:

* Cần chuẩn giao tiếp chung giữa các quốc gia, doanh nghiệp và nền tảng.

  4. Tích hợp hệ thống hiện hữu:

* Đòi hỏi API linh hoạt và chiến lược chuyển đổi dần để tránh gián đoạn hoạt động.


#  Trường hợp điển hình

  * TradeLens (Maersk & IBM):  
Hơn 100 nhà khai thác cảng và hải quan toàn cầu tham gia, giúp giảm 40% thời gian thông quan.

  * De Beers:  
Theo dõi từng viên kim cương từ mỏ đến cửa hàng, ngăn chặn “kim cương xung đột”.

  * Walmart – IBM Food Trust:  
Đảm bảo thực phẩm tươi an toàn, truy xuất nguồn gốc trong vài giây.


#  Tương lai và xu hướng

  * Kết hợp IoT: Cảm biến tự động ghi dữ liệu nhiệt độ, độ ẩm, vị trí vào blockchain theo thời gian thực.

  * Blockchain liên chuỗi (Interoperability): Cho phép nhiều blockchain (Hyperledger, Ethereum, Corda) tương tác liền mạch.

  * AI + Blockchain: Phân tích dữ liệu chuỗi cung ứng để dự báo nhu cầu, nhận diện rủi ro.

  * Tính bền vững: Sử dụng blockchain để chứng minh sản phẩm thân thiện môi trường và giảm phát thải

# Public078

# Giới thiệu

Trong bối cảnh Công nghiệp 4.0, các nhà máy thông minh ngày càng phụ thuộc vào hệ thống cảm biến, robot hợp tác, và thiết bị IoT. Mỗi giây, hàng tỷ dữ liệu về nhiệt độ, áp suất, độ rung, âm thanh, hình ảnh được tạo ra. Việc truyền toàn bộ lượng dữ liệu này về trung tâm đám mây để xử lý không chỉ tốn băng thông mà còn tạo ra độ trễ không thể chấp nhận cho các ứng dụng thời gian thực như điều khiển robot hay giám sát an toàn.

Điện toán biên (Edge Computing) giải quyết vấn đề bằng cách đưa khả năng tính toán và phân tích dữ liệu tới sát nguồn phát sinh – ngay tại thiết bị hoặc gateway trong nhà máy – giúp giảm thiểu độ trễ, giảm tải cho đường truyền và tăng tính bảo mật. Đây là nền tảng cho các ứng dụng tự động hóa, sản xuất linh hoạt, và phản ứng nhanh trong môi trường công nghiệp hiện đại.

# Edge Computing là gì?

**Edge Computing** , hay còn gọi là **điện toán biên** , là một mô hình điện toán phân tán, trong đó khả năng xử lý và lưu trữ dữ liệu được đưa đến gần các thiết bị hoặc khu vực tạo ra dữ liệu. Cách tiếp cận này nhằm giảm độ trễ trong quá trình xử lý và giúp tiết kiệm băng thông mạng.

Khái niệm Edge Computing có nguồn gốc từ các mạng phân phối nội dung (CDN), được phát triển vào cuối những năm 1990 để tối ưu hóa việc phân phối nội dung web và video bằng cách sử dụng các máy chủ gần người dùng. Theo thời gian, các CDN này đã được mở rộng chức năng để lưu trữ không chỉ dữ liệu mà cả ứng dụng và các phần của ứng dụng tại rìa mạng, từ đó hình thành nên các dịch vụ điện toán biên đầu tiên, chẳng hạn như xử lý và phân tích dữ liệu theo thời gian thực.

Một kiến trúc Edge Computing điển hình thường bao gồm ba tầng chính:

  * **Tầng đám mây (hoặc tầng trung tâm)** : đảm nhiệm việc lưu trữ và xử lý toàn bộ dữ liệu quy mô lớn.

  * **Tầng biên (tầng xử lý)** : thực hiện xử lý dữ liệu gần thời gian thực, ngay tại vị trí gần với nơi dữ liệu được tạo ra.

  * **Tầng thiết bị (tầng cảm biến)** : phụ trách thu thập dữ liệu ban đầu và thực hiện các tác vụ xử lý đơn giản tại chỗ.


# Nguyên lý hoạt động

Thay vì phụ thuộc hoàn toàn vào các trung tâm dữ liệu đám mây tập trung, Edge Computing phân phối năng lực xử lý đến các nút biên. Các thiết bị này có thể là:

  * Bộ định tuyến thông minh, mini server, hoặc gateway công nghiệp.

  * Máy chủ biên được đặt ngay trong nhà máy hoặc trạm sản xuất.


Quy trình điển hình:

  1. Cảm biến và thiết bị IoT thu thập dữ liệu tại dây chuyền.

  2. Dữ liệu được xử lý sơ bộ hoặc chạy mô hình AI trực tiếp tại nút biên.

  3. Chỉ thông tin quan trọng hoặc dữ liệu đã tổng hợp mới được gửi về đám mây để lưu trữ lâu dài, phân tích nâng cao, hoặc huấn luyện mô hình lớn.


Điều này tạo nên kiến trúc phân tán, giúp hệ thống vừa đảm bảo phản hồi nhanh, vừa tận dụng sức mạnh tính toán đám mây khi cần.

# Lợi ích trong công nghiệp 4.0

  * Độ trễ cực thấp: Quyết định sản xuất hoặc cảnh báo an toàn có thể đưa ra trong vài mili giây, quan trọng cho robot tự hành và dây chuyền tốc độ cao.

  * Tiết kiệm băng thông: Giảm đáng kể dữ liệu phải gửi về trung tâm, cắt chi phí đường truyền và giảm nguy cơ tắc nghẽn.

  * Bảo mật dữ liệu: Dữ liệu nhạy cảm về quy trình sản xuất, công thức, bản thiết kế… không phải rời khỏi nhà máy, giảm rủi ro rò rỉ.

  * Khả năng tự chủ: Khi mạng Internet gặp sự cố, hệ thống biên vẫn hoạt động độc lập, đảm bảo dây chuyền không bị gián đoạn.

  * Tính mở rộng: Dễ dàng thêm mới thiết bị hoặc dây chuyền mà không ảnh hưởng đến toàn bộ hệ thống.


# Ứng dụng tiêu biểu

  * Robot hợp tác (Cobots): Các robot có thể xử lý hình ảnh và cảm biến tại chỗ để tránh va chạm và phối hợp an toàn với công nhân.

  * Bảo trì dự đoán (Predictive Maintenance): Phân tích rung động, âm thanh, nhiệt độ trực tiếp tại biên giúp phát hiện sớm hỏng hóc, giảm thời gian ngừng máy.

  * Kiểm soát chất lượng sản phẩm: Camera công nghiệp chạy mô hình thị giác máy tính ngay trên nút biên để loại bỏ sản phẩm lỗi trong thời gian thực.

  * Quản lý năng lượng: Hệ thống edge tối ưu tiêu thụ điện theo thời gian thực, giảm chi phí vận hành.

  * Thực tế tăng cường (AR) cho bảo dưỡng: Thiết bị biên cung cấp dữ liệu trực tiếp cho kính AR của kỹ sư, hỗ trợ thao tác chính xác.


# Kiến trúc hệ thống

Một kiến trúc điển hình gồm:

  * Thiết bị IoT/Cảm biến: Thu thập dữ liệu thô liên tục.

  * Nút Edge/Gateway: Mini server hoặc thiết bị chuyên dụng có GPU/TPU nhỏ, chạy thuật toán AI để lọc và phân tích dữ liệu ngay lập tức.

  * Đám mây: Lưu trữ lịch sử, huấn luyện mô hình lớn và điều phối toàn hệ thống.


Kết hợp với mạng 5G/6G, việc truyền dữ liệu giữa biên và đám mây trở nên linh hoạt và đáng tin cậy, hỗ trợ các ứng dụng đòi hỏi băng thông cao.

# Công nghệ liên quan

  * Container và Kubernetes tại biên: Giúp triển khai, nâng cấp ứng dụng AI nhanh chóng và đồng nhất.

  * TinyML và Edge AI: Mô hình học máy gọn nhẹ tối ưu cho phần cứng giới hạn.

  * Bảo mật đầu-cuối (End-to-End Encryption): Bảo vệ dữ liệu trong toàn bộ quá trình thu thập, xử lý và truyền tải.

  * Chuẩn giao thức công nghiệp (OPC UA, MQTT): Đảm bảo khả năng tương thích giữa nhiều nhà sản xuất thiết bị.


# Thách thức triển khai

  * Quản lý phân tán: Hàng trăm hoặc hàng nghìn nút biên đòi hỏi giải pháp quản lý tập trung, tự động cập nhật phần mềm và vá lỗi.

  * Bảo mật đa tầng: Cần xác thực thiết bị, phân quyền truy cập, phát hiện xâm nhập ở cả cấp cảm biến và gateway.

  * Chi phí đầu tư: Thiết bị phần cứng mạnh, chịu được môi trường khắc nghiệt, đòi hỏi vốn đầu tư ban đầu đáng kể.

  * Đồng bộ dữ liệu: Phải thiết kế cơ chế đồng bộ khi kết nối Internet không ổn định.


# Xu hướng tương lai

  * AI tự học tại biên: Thiết bị không chỉ suy luận mà còn huấn luyện mô hình nhỏ trên dữ liệu cục bộ.

  * Kết hợp Blockchain: Ghi lại dữ liệu sản xuất bất biến, tăng độ tin cậy cho các đối tác trong chuỗi cung ứng.

  * Tích hợp năng lượng tái tạo: Hệ thống biên sử dụng nguồn năng lượng xanh, vận hành bền vững và giảm phát thải carbon.

  * Edge-to-Cloud Continuum: Ranh giới giữa biên và đám mây mờ dần, cho phép chia sẻ tài nguyên động tùy theo tải công việc.

# Public079

# Giới thiệu

Phân tích ảnh y tế là một trong những ứng dụng quan trọng nhất của trí tuệ nhân tạo trong y học hiện đại. Các kỹ thuật truyền thống dựa trên đặc trưng thủ công (hand-crafted features) thường thiếu chính xác và khó tổng quát hóa cho các loại bệnh khác nhau. Mạng Thần Kinh Tích Chập (CNN) đã mở ra kỷ nguyên mới cho thị giác máy tính trong y tế, với khả năng học trực tiếp các đặc trưng từ dữ liệu hình ảnh lớn, từ đó hỗ trợ bác sĩ chẩn đoán nhanh và chính xác hơn.

CNN được áp dụng trong nhiều dạng dữ liệu y khoa: ảnh X-quang, MRI (Magnetic Resonance Imaging), CT (Computed Tomography), ảnh siêu âm, và ảnh hiển vi tế bào. Nhờ khả năng tự động trích xuất đặc trưng, CNN đã trở thành nền tảng của nhiều hệ thống hỗ trợ quyết định y khoa (Clinical Decision Support Systems).

# Nguyên lý hoạt động

CNN hoạt động dựa trên các lớp tích chập (convolutional layers) và lớp gộp (pooling layers) nhằm phát hiện các mẫu không gian trong hình ảnh.

  * Lớp tích chập (Convolutional Layer): Sử dụng bộ lọc (kernel) để phát hiện đặc trưng cục bộ như cạnh, đường viền, hình dạng.

  * Lớp gộp (Pooling Layer): Giảm chiều dữ liệu, giữ lại thông tin quan trọng, tăng tính bất biến với dịch chuyển.

  * Lớp kết nối đầy đủ (Fully Connected Layer): Kết hợp các đặc trưng đã học để phân loại bệnh lý.

  * Hàm kích hoạt phi tuyến (ReLU, Sigmoid, Softmax): Giúp mô hình học được các quan hệ phức tạp.


Điểm mạnh của CNN trong y tế là khả năng học đặc trưng phù hợp từ chính dữ liệu bệnh án, thay vì phụ thuộc vào chuyên gia thiết kế đặc trưng thủ công.

# Cấu trúc mạng CNN

Mạng CNN là một tập hợp các lớp Convolution chồng lên nhau và sử dụng các hàm nonlinear activation như ReLU và tanh để kích hoạt các trọng số trong các node. Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo.

Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo. Trong mô hình mạng truyền ngược (feedforward neural network) thì mỗi neural đầu vào (input node) cho mỗi neural đầu ra trong các lớp tiếp theo.

Mô hình này gọi là mạng kết nối đầy đủ (fully connected layer) hay mạng toàn vẹn (affine layer). Còn trong mô hình CNNs thì ngược lại. Các layer liên kết được với nhau thông qua cơ chế convolution.

Layer tiếp theo là kết quả convolution từ layer trước đó, nhờ vậy mà ta có được các kết nối cục bộ. Như vậy mỗi neuron ở lớp kế tiếp sinh ra từ kết quả của filter áp đặt lên một vùng ảnh cục bộ của neuron trước đó.

Mỗi một lớp được sử dụng các filter khác nhau thông thường có hàng trăm hàng nghìn filter như vậy và kết hợp kết quả của chúng lại. Ngoài ra có một số layer khác như pooling/subsampling layer dùng để chắt lọc lại các thông tin hữu ích hơn (loại bỏ các thông tin nhiễu).

Trong quá trình huấn luyện mạng (traning) CNN tự động học các giá trị qua các lớp filter dựa vào cách thức mà bạn thực hiện. Ví dụ trong tác vụ phân lớp ảnh, CNNs sẽ cố gắng tìm ra thông số tối ưu cho các filter tương ứng theo thứ tự raw pixel > edges > shapes > facial > high-level features. Layer cuối cùng được dùng để phân lớp ảnh.

![Cấu trúc của mạng CNN](images/image1.png)

Trong mô hình CNN có 2 khía cạnh cần quan tâm là **tính bất biến** (Location Invariance) và **tính kết hợp** (Compositionality). Với cùng một đối tượng, nếu đối tượng này được chiếu theo các gốc độ khác nhau (translation, rotation, scaling) thì độ chính xác của thuật toán sẽ bị ảnh hưởng đáng kể.

Pooling layer sẽ cho bạn tính bất biến đối với phép dịch chuyển (translation), phép quay (rotation) và phép co giãn (scaling). Tính kết hợp cục bộ cho ta các cấp độ biểu diễn thông tin từ mức độ thấp đến mức độ cao và trừu tượng hơn thông qua convolution từ các filter.

Đó là lý do tại sao CNNs cho ra mô hình với độ chính xác rất cao. Cũng giống như cách con người nhận biết các vật thể trong tự nhiên.

Mạng CNN sử dụng 3 ý tưởng cơ bản:

  * **các trường tiếp nhận cục bộ** (local receptive field)

  * **trọng số chia sẻ** (shared weights)

  * **tổng hợp** (pooling).


## Trường tiếp nhận cục bộ (local receptive field)

Đầu vào của mạng CNN là một ảnh. Ví dụ như ảnh có kích thước 28×28 thì tương ứng đầu vào là một ma trận có 28×28 và giá trị mỗi điểm ảnh là một ô trong ma trận. Trong mô hình mạng ANN truyền thống thì chúng ta sẽ kết nối các neuron đầu vào vào tầng ảnh.

Tuy nhiên trong CNN chúng ta không làm như vậy mà chúng ta chỉ kết nối trong một vùng nhỏ của các neuron đầu vào như một filter có kích thước 5×5 tương ứng (28- 5 + 1) 24 điểm ảnh đầu vào. Mỗi một kết nối sẽ học một trọng số và mỗi neuron ẩn sẽ học một bias. Mỗi một vùng 5×5 đấy gọi là một trường tiếp nhận cục bộ.

![A diagram of a brain function AI-generated content may be incorrect.](images/image2.png)

Một cách tổng quan, ta có thể tóm tắt các bước tạo ra 1 hidden layer bằng các cách sau:

  1. **Tạo ra neuron ẩn đầu tiên trong lớp ẩn 1** ![A diagram of a test AI-generated content may be incorrect.](images/image3.png)

  2. **Dịch filter qua bên phải một cột sẽ tạo được neuron ẩn thứ 2.** ![A diagram of a number of circles AI-generated content may be incorrect.](images/image4.png)


với bài toán nhận dạng ảnh người ta thường gọi ma trận lớp đầu vào là feature map, trọng số xác định các đặc trương là shared weight và độ lệch xác định một feature map là shared bias. Như vậy đơn giản nhất là qua các bước trên chúng ta chỉ có 1 feature map. Tuy nhiên trong nhận dạng ảnh chúng ta cần nhiều hơn một feature map.![A diagram of a machine AI-generated content may be incorrect.](images/image5.png)

Như vậy, local receptive field thích hợp cho việc phân tách dữ liệu ảnh, giúp chọn ra những vùng ảnh có giá trị nhất cho việc đánh giá phân lớp.

## Trọng số chia sẻ (shared weight and bias)

Đầu tiên, các trọng số cho mỗi filter (kernel) phải giống nhau. Tất cả các nơ-ron trong lớp ẩn đầu sẽ phát hiện chính xác feature tương tự chỉ ở các vị trí khác nhau trong hình ảnh đầu vào. Chúng ta gọi việc map từ input layer sang hidden layer là một feature map. Vậy mối quan hệ giữa số lượng Feature map với số lượng tham số là gì?

_Chúng ta thấy mỗi fearture map cần 25 = 5×5 shared weight và 1 shared bias. Như vậy mỗi feature map cần 5×5+1 = 26 tham số. Như vậy nếu có 10 feature map thì có 10×26 = 260 tham số. Chúng ta xét lại nếu layer đầu tiên có kết nối đầy đủ nghĩa là chúng ta có 28×28=784 neuron đầu vào như vậy ta chỉ có 30 neuron ẩn. Như vậy ta cần 28x28x30 shared weight và 30 shared bias. Tổng số tham số là 28x28x30+30 tham số lớn hơn nhiều so với CNN. Ví dụ vừa rồi chỉ mô tả để thấy được sự ước lượng số lượng tham số chứ chúng ta không so sánh được trực tiếp vì 2 mô hình khác nhau. Nhưng điều chắc chắn là nếu mô hình có số lượng tham số ít hơn thì nó sẽ chạy nhanh hơn._

Xem tiếp...

Tóm lại, một convolutional layer bao gồm các feature map khác nhau. Mỗi một feature map giúp detect một vài feature trong bức ảnh. Lợi ích lớn nhất của trọng số chia sẻ là giảm tối đa số lượng tham số trong mạng CNN.

## Lớp tổng hợp (pooling layer)

Lớp pooling thường được sử dụng ngay sau lớp convulational để đơn giản hóa thông tin đầu ra để giảm bớt số lượng neuron.

![A diagram of a diagram of a diagram AI-generated content may be incorrect.](images/image1.png)

Thủ tục pooling phổ biến là max-pooling, thủ tục này chọn giá trị lớn nhất trong vùng đầu vào 2×2.![A diagram of a diagram AI-generated content may be incorrect.](images/image6.png)

Như vậy qua lớp Max Pooling thì số lượng neuron giảm đi phân nửa. Trong một mạng CNN có nhiều Feature Map nên mỗi Feature Map chúng ta sẽ cho mỗi Max Pooling khác nhau. Chúng ta có thể thấy rằng Max Pooling là cách hỏi xem trong các đặc trưng này thì đặc trưng nào là đặc trưng nhất. Ngoài Max Pooling còn có L2 Pooling.

Cuối cùng ta đặt tất cả các lớp lại với nhau thành một CNN với đầu ra gồm các neuron với số lượng tùy bài toán.

![A diagram of a block diagram AI-generated content may be incorrect.](images/image7.png)

2 lớp cuối cùng của các kết nối trong mạng là một lớp đầy đủ kết nối (fully connected layer) . Lớp này nối mọi nơron từ lớp max pooled tới mọi nơron của tầng ra.

# Ứng dụng trong phân tích ảnh y tế

  * Chẩn đoán bệnh phổi từ ảnh X-quang: CNN có thể phát hiện viêm phổi, lao, hoặc COVID-19 với độ chính xác cao.

  * Phát hiện khối u từ MRI và CT: Hỗ trợ xác định kích thước, vị trí, và giai đoạn của khối u não, gan, hoặc phổi.

  * Phân đoạn polyp và tổn thương nội soi: CNN giúp phát hiện polyp ruột kết sớm, hỗ trợ phòng ngừa ung thư.

  * Nhận diện tế bào bất thường từ ảnh hiển vi: Ứng dụng trong xét nghiệm máu hoặc tế bào học (cytology).

  * Hỗ trợ phẫu thuật thông minh: Kết hợp CNN với hình ảnh thời gian thực từ camera nội soi để dẫn hướng phẫu thuật.


# Kiến trúc CNN phổ biến trong y tế

  * LeNet và AlexNet: Các mô hình khởi đầu, thường dùng cho dữ liệu ít phức tạp.

  * VGGNet, ResNet, DenseNet: Khả năng học sâu, xử lý dữ liệu ảnh y tế có độ phân giải cao.

  * U-Net: Chuyên biệt cho bài toán phân đoạn ảnh y tế, nổi bật trong phân đoạn MRI, CT và ảnh nội soi.

  * EfficientNet: Cân bằng hiệu quả giữa độ chính xác và tốc độ tính toán, phù hợp cho hệ thống y tế thời gian thực.


Ngoài ra, các mô hình mới như Vision Transformer (ViT) đang dần kết hợp với CNN để nâng cao khả năng xử lý hình ảnh y tế phức tạp.

# Lợi ích trong y tế

  * Chẩn đoán nhanh hơn: CNN phân tích hàng nghìn hình ảnh chỉ trong vài phút, hỗ trợ bác sĩ tiết kiệm thời gian.

  * Độ chính xác cao: Phát hiện những chi tiết tinh vi mà mắt thường có thể bỏ sót.

  * Hỗ trợ quyết định lâm sàng: Giúp bác sĩ có thêm bằng chứng trong quá trình chẩn đoán.

  * Giảm chi phí: Tự động hóa quy trình đọc phim, giảm tải cho nhân lực y tế.

  * Cá nhân hóa điều trị: Kết hợp CNN với dữ liệu bệnh nhân để dự đoán đáp ứng thuốc hoặc kết quả điều trị.


# Thách thức và hạn chế

  * Thiếu dữ liệu gắn nhãn: Dữ liệu y tế lớn nhưng việc gắn nhãn yêu cầu bác sĩ, tốn kém thời gian.

  * Chênh lệch dữ liệu (Data Shift): Mô hình huấn luyện trên dữ liệu bệnh viện này có thể hoạt động kém trên bệnh viện khác.

  * Giải thích mô hình (Explainability): CNN thường bị coi là “hộp đen”, khó giải thích kết quả cho bác sĩ.

  * Vấn đề đạo đức và pháp lý: Liên quan đến bảo mật dữ liệu bệnh nhân và trách nhiệm pháp lý khi AI chẩn đoán sai.

  * Yêu cầu tính toán cao: Đào tạo CNN cần GPU/TPU mạnh, khó triển khai tại bệnh viện nhỏ.


# Xu hướng tương lai

  * CNN kết hợp với Explainable AI (XAI): Tạo bản đồ nhiệt (heatmap) hiển thị vùng ảnh mà mô hình tập trung, giúp bác sĩ hiểu và tin tưởng hơn.

  * Học chuyển giao (Transfer Learning): Sử dụng mô hình tiền huấn luyện từ tập dữ liệu lớn để áp dụng vào lĩnh vực y tế, giảm nhu cầu dữ liệu nhãn.

  * Liên kết với Federated Learning: Nhiều bệnh viện cùng huấn luyện mô hình CNN mà không cần chia sẻ dữ liệu bệnh nhân, đảm bảo quyền riêng tư.

  * Ứng dụng mô hình nhẹ (Lightweight CNN): Tối ưu để chạy trên thiết bị cầm tay, máy siêu âm di động hoặc edge device trong bệnh viện.

  * Kết hợp CNN và Transformer: Tận dụng khả năng trích xuất đặc trưng cục bộ (CNN) và quan hệ toàn cục (Transformer) để nâng cao độ chính xác.

# Public080

# Giới thiệu

Phát triển thuốc truyền thống thường kéo dài 10–15 năm và tiêu tốn hàng tỷ đô la. Quy trình bao gồm nghiên cứu cơ bản, xác định mục tiêu (target), thiết kế phân tử, thử nghiệm lâm sàng và phê duyệt. Quá trình này tốn kém do phải sàng lọc hàng triệu hợp chất để tìm ra vài phân tử tiềm năng.

Trí tuệ nhân tạo tạo sinh (Generative AI) – bao gồm các mô hình như Generative Adversarial Networks (GANs), Variational Autoencoders (VAEs) và Diffusion Models – đã mở ra khả năng tạo ra các phân tử mới đáp ứng tiêu chí dược lý mong muốn, rút ngắn đáng kể thời gian và chi phí.

# Trí tuệ nhân tạo tạo sinh là gì?

_Trí tuệ nhân tạo tạo sinh_ (Generative AI) là một lĩnh vực của trí tuệ nhân tạo tập trung vào việc tạo ra dữ liệu mới, dựa trên dữ liệu đã được học trước đó. Dữ liệu này có thể bao gồm văn bản, hình ảnh, âm thanh, video, hoặc các loại nội dung khác. Các mô hình Generative AI không chỉ nhận biết và phân loại thông tin, mà còn có khả năng sáng tạo, mô phỏng và tái hiện thông tin. Một số ví dụ phổ biến nhất của trí tuệ nhân tạo tạo sinh là ChatGPT tạo văn bản, DeepFake mô phỏng khuôn mặt người trong video. Các mô hình này thường sở hữu một số đặc điểm cơ bản là:

  * Khả năng sáng tạo: Tạo ra nội dung mới, độc đáo dựa trên các mẫu đã học.

  * Tính thích ứng cao: Có thể áp dụng vào nhiều lĩnh vực, từ sáng tạo nội dung (viết báo, tạo hình ảnh) đến nghiên cứu khoa học (tạo mô hình phân tử).

  * Sử dụng dữ liệu huấn luyện: Chất lượng nội dung tạo ra phụ thuộc nhiều vào quy mô và độ đa dạng của tập dữ liệu đã học.

  * Dựa trên mô hình học sâu (Deep Learning): Thường sử dụng các kiến trúc mạng nơ-ron tiên tiến như GANs, VAEs và Transformers.

  * Hạn chế sự giải thích: Mô hình thường được xem là hộp đen, khó giải thích rõ ràng lý do tại sao nó tạo ra kết quả cụ thể.


# Trí tuệ nhân tạo tạo sinh hoạt động như thế nào?

Việc triển khai giải pháp trí tuệ nhân tạo tạo sinh cho mọi trường hợp sử dụng yêu cầu phải có nhiều nỗ lực từ các nhà khoa học và nhà phát triển. Đó là vì GenAI được thực hiện nhờ các bộ dữ liệu lớn và các thuật toán trí tuệ nhân tạo được đào tạo phức tạp. Công nghệ này được xây dựng và triển khai cùng với trí tuệ nhân tạo và xử lý ngôn ngữ tự nhiên (NLP), cho phép trí tuệ nhân tạo xử lý và hiểu ngôn ngữ của con người. GenAI và NLP cùng nhau có thể hiểu được lời nhắc người dùng để tạo ra phản hồi thích hợp, cho dù là văn bản, video, hình ảnh hay âm thanh.

Các giải pháp trí tuệ nhân tạo tạo sinh sử dụng các hệ thống trí tuệ nhân tạo được gọi là [các mô hình ngôn ngữ lớn (LLM)](https://www.intel.vn/content/www/vn/vi/learn/large-language-models.html), sử dụng mạng thần kinh sâu để xử lý và tạo văn bản. Chúng được đào tạo trên lượng dữ liệu khổng lồ, tìm ra sự tương đồng giữa các loại dữ liệu và thông tin để tạo ra và cung cấp các kết quả đầu ra mới, mạch lạc.

LLM dựa vào cấu trúc transformer để xử lý các chuỗi đầu vào một cách song song, giúp cải thiện hiệu năng và tốc độ so với mạng nơ-ron cổ điển. Quy trình đào tạo mô hình cũng tiếp nhận thông tin từ các nhà khoa học dữ liệu và các chuyên gia về chủ đề giúp hướng dẫn quá trình học tập của thuật toán và dẫn dắt nó đến kết quả chính xác hơn.

Để hiện thực hóa các giải pháp trí tuệ nhân tạo tạo sinh, doanh nghiệp có thể đào tạo các mô hình từ đầu hoặc chọn mô hình đã được đào tạo sẵn có thể điều chỉnh theo nhu cầu cụ thể. Ví dụ: có thể đào tạo thuật toán chatbot GenAI theo các thuộc tính cụ thể của cơ sở khách hàng và mô hình kinh doanh của tổ chức. Hoặc một mô hình có mục đích tạo ra văn bản để tiếp thị nội dung có thể được chuyên môn hóa hoặc tinh chỉnh để tập trung vào một ngành và đối tượng cụ thể. Nhiều mô hình dành riêng cho từng lĩnh vực cũng đang nổi lên với tốc độ nhanh chóng. Các mô hình này được đào tạo trên các bộ dữ liệu nhỏ hơn, nhắm mục tiêu cụ thể hơn so với các mô hình lớn hơn. Kết quả mới đây cho thấy các mô hình nhỏ hơn này có thể tái tạo độ chính xác của các mô hình lớn hơn nếu được đào tạo dựa trên dữ liệu được chọn lọc cẩn thận.

Các nhà phát triển cũng có thể sử dụng chức năng [tạo tăng cường truy xuất (RAG)](https://www.intel.vn/content/www/vn/vi/learn/what-is-rag.html) để bổ sung cho các mô hình được đào tạo trước với dữ liệu cập nhật, độc quyền và bí mật từ cơ sở dữ liệu vector trong quá trình suy luận. Điều này đơn giản hóa quy trình tùy chỉnh và cập nhật, cũng như cho phép gán nguồn thông tin được tạo ra.

Dưới đây là tổng quan tóm lược (mặc dù nâng cao về kỹ thuật) về ba loại mô hình trí tuệ nhân tạo tạo sinh phổ biến:

  * **Mạng đối nghịch tạo sinh (GAN):** Các mạng này liên quan đến hai mạng thần kinh, một bộ tạo và một bộ phân biệt, được đào tạo đồng thời. Bộ tạo tạo ra các phiên bản dữ liệu mới, trong khi bộ phân biệt đánh giá chúng so với một bộ dữ liệu thực. Mục tiêu của bộ tạo là tạo ra dữ liệu không thể phân biệt được với dữ liệu thực, trong khi mục tiêu của bộ phân biệt là phân biệt chính xác giữa hai dữ liệu này. Theo thời gian, bộ tạo được cải thiện, tạo ra dữ liệu ngày càng thực tế.

  * **Bộ tự mã hóa biến thể (VAE):** VAE kết hợp các nguyên tắc từ mạng nơ-ron và mô hình xác suất để tạo ra các phiên bản dữ liệu mới thông qua quy trình mã hóa và giải mã. Mô hình VAE bắt đầu bằng cách nén dữ liệu đầu vào thành một đại diện đơn giản hóa các đặc điểm của nó. Sau đó, nó giải mã phiên bản đơn giản hóa đó, cố gắng tái cấu trúc dữ liệu đầu vào về dạng ban đầu. Thông qua quy trình này, VAE học được các tính năng và thông số cơ bản của dữ liệu, giúp nó tạo ra các kết quả đầu ra thực tế và có thể tùy chỉnh nhiều hơn.

  * **Mô hình transformer:** Các mô hình như Generative Pre-trained Transformer (GPT) có thể tạo ra văn bản mạch lạc và liên quan đến bối cảnh. Các mô hình này, ban đầu được thiết kế dành cho các công việc xử lý ngôn ngữ tự nhiên, được đào tạo trên các bộ dữ liệu lớn và có thể hoàn thành các lời nhắc văn bản, dịch ngôn ngữ, trả lời các câu hỏi và thậm chí có thể tạo ra các văn bản sáng tạo.


Nhiều chiến lược khác nhau có thể được sử dụng trong quá trình tạo ra để cân bằng giữa tính sáng tạo và sự gắn kết trong kết quả đầu ra. Hiện có nhiều nghiên cứu nhằm mục đích làm cho các mô hình này minh bạch hơn, giảm thiên kiến và cải thiện độ chính xác thực tế. Hiện cũng đã có chuyển động hướng đến các mô hình có thể đồng thời làm việc với nhiều loại dữ liệu, chẳng hạn như văn bản, hình ảnh và âm thanh.

# Cách Generative AI hỗ trợ thiết kế thuốc

Generative AI có thể học từ cơ sở dữ liệu hóa học khổng lồ để hiểu mối quan hệ giữa cấu trúc phân tử và tính chất dược học.

  * Mô hình tạo ra các phân tử mới có đặc điểm tối ưu: khả năng gắn kết với protein mục tiêu, tính ổn định, và ít độc tính.

  * Sử dụng reinforcement learning để tối ưu dần các phân tử dựa trên phản hồi từ các mô phỏng sinh học.

  * Kết hợp mô phỏng động lực học phân tử (molecular dynamics) và AI tạo sinh giúp dự đoán tương tác phân tử nhanh hơn.


# Ứng dụng thực tế

  * Tìm hợp chất kháng virus mới: Generative AI đã được sử dụng để đề xuất phân tử ức chế protein của SARS-CoV-2 trong giai đoạn đầu dịch COVID-19.

  * Kháng sinh thế hệ mới: Tìm ra hợp chất Halicin bằng mô hình học sâu, hiệu quả chống vi khuẩn kháng thuốc.

  * Thuốc điều trị ung thư: AI gợi ý cấu trúc phân tử tương tác đặc hiệu với thụ thể tế bào ung thư, hỗ trợ thiết kế thuốc đích (targeted therapy).

  * Tối ưu hóa thuốc sẵn có: Đề xuất biến thể cấu trúc để cải thiện dược động học hoặc giảm tác dụng phụ.


# Quy trình tích hợp AI trong phát triển thuốc

  * Xác định mục tiêu (Target Identification): AI phân tích dữ liệu gen và proteomics để tìm đích tác động.

  * Sinh phân tử mới (Molecule Generation): Mô hình tạo sinh đề xuất hàng nghìn cấu trúc phân tử.

  * Đánh giá in silico: Mô phỏng tính chất hóa lý, độ hòa tan, tính độc.

  * Tổng hợp và thử nghiệm: Các phân tử triển vọng được tổng hợp trong phòng thí nghiệm và thử nghiệm in vitro/in vivo.


# Ưu điểm nổi bật

  * Tốc độ vượt trội: Rút ngắn thời gian sàng lọc từ nhiều năm xuống vài tháng.

  * Tiết kiệm chi phí: Giảm đáng kể chi phí nghiên cứu ban đầu.

  * Khả năng khám phá không gian hóa học rộng: Khám phá hàng tỷ cấu trúc mà phương pháp truyền thống khó tiếp cận.

  * Cá nhân hóa y học: Đề xuất thuốc phù hợp với đặc điểm gen của từng nhóm bệnh nhân.


# Thách thức

  * Độ tin cậy của mô hình: Phân tử do AI đề xuất cần xác thực thực nghiệm.

  * Dữ liệu đào tạo: Cần cơ sở dữ liệu hóa học lớn, chuẩn hóa, chất lượng cao.

  * Vấn đề pháp lý và đạo đức: Quy định về bằng sáng chế, quyền sở hữu trí tuệ và trách nhiệm khi thuốc thất bại.

  * Khả năng giải thích: Khó hiểu tại sao mô hình chọn một cấu trúc cụ thể.


# Xu hướng tương lai

  * Kết hợp Generative AI và Quantum Computing: Tăng độ chính xác của mô phỏng lượng tử trong tương tác phân tử.

  * Học liên kết (Federated Learning): Cho phép nhiều viện nghiên cứu cùng huấn luyện mô hình mà không chia sẻ dữ liệu bí mật.

  * Tự động hóa phòng thí nghiệm (Lab Automation): Tích hợp robot tổng hợp hóa học với AI để khép kín quy trình thiết kế–thử nghiệm.

  * AI đa mô thức (Multimodal AI): Kết hợp dữ liệu gen, hình ảnh tế bào, và văn bản y khoa để thiết kế thuốc đa mục tiêu.

# Public081

# Giới thiệu

Khám phá vật liệu mới là nền tảng của nhiều lĩnh vực công nghệ, từ pin thế hệ mới, vật liệu siêu dẫn, hợp kim nhẹ cho hàng không vũ trụ đến các vật liệu nano tiên tiến. Quá trình truyền thống đòi hỏi nhiều năm thử nghiệm trong phòng thí nghiệm, tốn kém và khó mở rộng.

Mạng Nơ-ron Đồ Thị (Graph Neural Networks – GNN) đang nổi lên như công cụ mạnh mẽ cho khoa học vật liệu tính toán. Bởi vì cấu trúc của vật liệu – bao gồm nguyên tử và liên kết – tự nhiên được biểu diễn dưới dạng đồ thị (graph), GNN có thể trực tiếp học các đặc trưng này để dự đoán tính chất vật lý, hóa học và điện tử của vật liệu mới.

# Nguyên lý hoạt động

  * Biểu diễn vật liệu dưới dạng đồ thị:

* Nút (Node): Đại diện cho các nguyên tử.

* Cạnh (Edge): Biểu diễn liên kết hóa học hoặc khoảng cách không gian giữa các nguyên tử.

  * Lan truyền thông tin (Message Passing):

* Mỗi nút cập nhật biểu diễn của mình dựa trên thông tin từ các nút láng giềng.

* Quá trình lặp lại nhiều tầng để học đặc trưng toàn cục.

  * Đọc đồ thị (Graph Readout):

* Tạo biểu diễn vector cho toàn bộ cấu trúc vật liệu, từ đó dự đoán các tính chất như độ bền, độ dẫn điện, hoặc năng lượng dải.


Các kiến trúc GNN phổ biến: Graph Convolutional Network (GCN), Graph Attention Network (GAT), Message Passing Neural Network (MPNN), và SchNet – mô hình được thiết kế riêng cho dữ liệu hóa học và vật liệu.

# So Sánh GNN Với Các Mô Hình Khác

Mạng Nơ-ron Đồ Thị (GNN) là một trong những mô hình học máy hiện đại, và để hiểu rõ hơn về giá trị của nó, chúng ta có thể so sánh GNN với một số mô hình học sâu khác như CNN (Mạng Nơ-ron Tích Chập) và RNN (Mạng Nơ-ron Hồi Tiếp).

## So Sánh GNN và CNN

  * **Cấu Trúc Dữ Liệu:** CNN thường xử lý dữ liệu có cấu trúc dạng lưới (ví dụ: hình ảnh), trong khi GNN xử lý dữ liệu có cấu trúc dạng đồ thị.

  * **Khả Năng Mô Hình Hóa Quan Hệ:** GNN xuất sắc trong việc nắm bắt các mối quan hệ phức tạp giữa các nút, điều mà CNN không thể thực hiện một cách hiệu quả.

  * **Ứng Dụng:** CNN thường được sử dụng trong nhận diện hình ảnh, trong khi GNN phù hợp hơn cho các tác vụ như phân tích mạng xã hội và hóa học.


## So Sánh GNN và RNN

  * **Cấu Trúc Dữ Liệu:** RNN chủ yếu xử lý dữ liệu tuần tự (như chuỗi thời gian), trong khi GNN làm việc với dữ liệu có cấu trúc đồ thị.

  * **Khả Năng Tương Tác:** GNN có thể mô hình hóa mối quan hệ giữa nhiều đối tượng cùng một lúc, trong khi RNN thường chỉ xem xét một chuỗi tại một thời điểm.

  * **Hiệu Quả:** GNN có thể hiệu quả hơn trong các tác vụ cần sự hiểu biết về quan hệ phức tạp giữa các phần tử, trong khi RNN thường hiệu quả trong việc dự đoán tiếp theo trong chuỗi dữ liệu.


Tóm lại, GNN không chỉ là một sự thay thế mà còn là một công cụ bổ sung mạnh mẽ cho các mô hình học sâu hiện có, mở ra nhiều khả năng mới trong việc phân tích và xử lý dữ liệu phức tạp.

![So Sánh GNN Với Các Mô Hình Khác](images/image1.png)

# Ứng Dụng Của GNN Trong Thực Tiễn

Mạng Nơ-ron Đồ Thị (GNN) đã chứng minh được tính hiệu quả của mình trong nhiều lĩnh vực khác nhau. Dưới đây là một số ứng dụng nổi bật của GNN trong thực tiễn:

  * Phân Tích Mạng Xã Hội: GNN được sử dụng để phân tích cấu trúc và mối quan hệ trong các mạng xã hội. Nó có thể giúp dự đoán hành vi của người dùng, xác định cộng đồng và phân tích sự lan truyền thông tin.

  * Hệ Thống Gợi Ý: Trong các nền tảng thương mại điện tử và dịch vụ trực tuyến, GNN có thể cải thiện hệ thống gợi ý bằng cách hiểu rõ hơn về mối quan hệ giữa người dùng và sản phẩm, từ đó cung cấp gợi ý chính xác hơn.

  * Nhận Diện Hình Ảnh: GNN được áp dụng trong lĩnh vực thị giác máy tính để nhận diện các đối tượng phức tạp trong hình ảnh, dựa trên các mối quan hệ giữa các điểm ảnh.

  * Hóa Học và Sinh Học: Trong nghiên cứu hóa học, GNN có thể được sử dụng để mô hình hóa các mối quan hệ giữa các phân tử, giúp phát hiện các hợp chất mới và dự đoán tính chất hóa học của chúng.

  * Dự Đoán Thời Tiết: GNN cũng có thể áp dụng trong lĩnh vực khí tượng để dự đoán các hiện tượng thời tiết phức tạp, bằng cách phân tích các dữ liệu không gian và thời gian.


Những ứng dụng này cho thấy GNN không chỉ là một công nghệ hứa hẹn mà còn đang dần trở thành một công cụ quan trọng trong nhiều lĩnh vực, mang lại lợi ích lớn cho nghiên cứu và phát triển.

# 

# Ứng dụng trong khám phá vật liệu

  * Pin thế hệ mới: GNN dự đoán tính dẫn ion và ổn định nhiệt của vật liệu điện cực và chất điện phân rắn.

  * Vật liệu siêu dẫn: Phân tích cấu trúc tinh thể để tìm các hợp chất có nhiệt độ tới hạn cao.

  * Hợp kim nhẹ cho hàng không: Dự đoán độ bền kéo, khả năng chịu nhiệt của hợp kim titan và nhôm.

  * Vật liệu nano và xúc tác: Xác định các cấu trúc bề mặt tối ưu cho phản ứng hóa học hoặc lưu trữ năng lượng.

  * Polyme chức năng: Dự đoán tính chất cơ học và điện của polyme mới cho thiết bị điện tử dẻo.


# Lợi ích nổi bật

  * Tốc độ khám phá nhanh: Giảm đáng kể thời gian từ ý tưởng đến thử nghiệm, từ nhiều năm xuống vài tháng.

  * Tiết kiệm chi phí: Giảm nhu cầu tổng hợp và thử nghiệm hàng nghìn mẫu trong phòng thí nghiệm.

  * Khả năng tổng quát hóa cao: Mô hình học từ dữ liệu đa dạng, có thể dự đoán tính chất của vật liệu chưa từng được biết đến.

  * Khám phá không gian hóa học rộng: Khả năng khảo sát hàng tỷ cấu trúc tinh thể tiềm năng.


# Thách thức

  * Dữ liệu hạn chế: Cần cơ sở dữ liệu vật liệu chất lượng cao như Materials Project hoặc Open Quantum Materials Database.

  * Độ chính xác mô phỏng: Tính chất dự đoán cần được xác thực bằng thí nghiệm hoặc tính toán ab initio.

  * Khả năng giải thích: Kết quả dự đoán phải giải thích được để hướng dẫn các nhà khoa học vật liệu.

  * Tích hợp với quy trình thí nghiệm: Cần tự động hóa phòng thí nghiệm để kiểm chứng nhanh các vật liệu được đề xuất.


# Xu hướng tương lai

  * Kết hợp với Học Tăng Cường (Reinforcement Learning): Tìm kiếm cấu trúc tối ưu dựa trên phản hồi của các mô phỏng.

  * AI đa mô thức: Kết hợp dữ liệu từ nhiễu xạ tia X, phổ Raman, và mô phỏng lượng tử.

  * Tích hợp với điện toán lượng tử: Tăng độ chính xác khi dự đoán tính chất điện tử phức tạp.

  * Tự động hóa toàn quy trình: GNN đề xuất, robot phòng thí nghiệm tổng hợp, và hệ thống đo đạc xác minh – tạo thành vòng lặp khám phá khép kín.


# Trường hợp nghiên cứu tiêu biểu

  * Materials Project & SchNet: Sử dụng GNN để dự đoán năng lượng hình thành, giúp xác định hàng nghìn vật liệu ổn định mới.

  * DeepMind – AlphaFold và GNN: Dù AlphaFold tập trung vào protein, kỹ thuật tương tự đã truyền cảm hứng cho mô hình GNN trong dự đoán cấu trúc tinh thể phức tạp.

  * Stanford Materials Cloud: Áp dụng GNN để dự đoán vật liệu siêu dẫn ở nhiệt độ cao, hỗ trợ nghiên cứu năng lượng sạch.

# Public082

# Giới thiệu

Biến đổi khí hậu toàn cầu đang làm gia tăng tần suất và cường độ của các hiện tượng thời tiết cực đoan: bão siêu mạnh, lũ lụt, hạn hán kéo dài, sóng nhiệt khốc liệt. Để dự báo chính xác và đưa ra cảnh báo sớm, các nhà khoa học cần mô phỏng bầu khí quyển, đại dương và đất liền ở quy mô hành tinh với độ phân giải rất cao.

Tính toán hiệu năng cao (High-Performance Computing – HPC) cung cấp siêu máy tính với hàng trăm nghìn lõi xử lý song song, giúp giải quyết các mô hình phương trình động lực học chất lưu, tương tác khí quyển–đại dương và hóa học khí quyển trong thời gian khả thi. HPC trở thành nền tảng cốt lõi cho nghiên cứu khí hậu và hệ thống dự báo thời tiết toàn cầu.

# HPC là gì? High Performance Computing là gì?

**HPC (High Performance Computing)** , hay tính toán hiệu năng cao, là một lĩnh vực sử dụng các hệ thống máy tính để giải quyết các bài toán phức tạp, đòi hỏi khối lượng tính toán lớn trong thời gian ngắn. Thông thường, HPC kết hợp nhiều máy tính hoặc các cụm máy chủ ([server cluster](https://vietnix.vn/server-cluster-la-gi/)) để làm việc đồng thời, giúp rút ngắn thời gian xử lý so với các hệ thống thông thường. HPC thường được sử dụng trong các lĩnh vực như khoa học, kỹ thuật, y tế, nghiên cứu và trí tuệ nhân tạo, nơi yêu cầu tài nguyên tính toán cao và tốc độ xử lý nhanh chóng.

![HPC (High Performance Computing)](images/image1.png)HPC (High Performance Computing)

# Thành phần của hệ thống HPC

**Cấu trúc của hệ thống HPC** thường bao gồm các thành phần tương tự như một **phòng máy chủ** hoặc trung tâm dữ liệu, với hàng chục, hàng trăm, hoặc thậm chí hàng nghìn thiết bị ngoại vi và [server](https://vietnix.vn/server-la-gi/) được kết nối với nhau. Hệ thống này được chia thành ba loại **nút** chính dựa trên chức năng của chúng:

Một cụm HPC cho AI

  * **Máy tính hoặc cụm máy tính (Compute Nodes)** : Đây là bộ não của hệ thống HPC, thực hiện các phép tính phức tạp và xử lý các tác vụ tính toán. Các nút tính toán chứa các máy chủ với [CPU](https://vietnix.vn/cpu-la-gi/)/[GPU](https://vietnix.vn/gpu-la-gi/) mạnh mẽ, giúp xử lý các bài toán nhanh chóng và hiệu quả.

  * **Hệ thống lưu trữ dữ liệu (Storage Nodes)** : Được thiết kế để xử lý và lưu trữ dữ liệu, kết quả tính toán và các tài nguyên cần thiết cho quá trình tính toán với tốc độ cao. Các nút này thường sử dụng ổ [SSD](https://vietnix.vn/ssd-la-gi/) hoặc các hệ thống lưu trữ phân tán.


Hạ tầng mạng (Network Nodes)

  * **Hạ tầng mạng (Network Nodes)** : Sử dụng mạng tốc độ cao (như InfiniBand) để truyền tải dữ liệu nhanh chóng giữa các nút trong cụm HPC, cũng như giúp các máy chủ và nút tính toán giao tiếp với nhau và kết nối với các hệ thống bên ngoài.

  * **Phần mềm quản lý** : Bao gồm hệ điều hành, phần mềm lập lịch tác vụ (job scheduler) và các công cụ tối ưu hóa hiệu năng cho các ứng dụng HPC.


Một hệ thống HPC hoạt động như một siêu máy tính gắn kết, nơi tổng thể của hệ thống mạnh mẽ hơn rất nhiều so với chỉ tổng các bộ phận của nó. Hệ thống này cho phép xử lý các bài toán yêu cầu tài nguyên tính toán lớn và tốc độ xử lý nhanh trong các lĩnh vực như khoa học, nghiên cứu, kỹ thuật và trí tuệ nhân tạo.

Thành phần của hệ thống HPC

# Cơ sở kỹ thuật của HPC cho mô phỏng khí hậu

  * Kiến trúc siêu máy tính song song:

* Hàng chục nghìn CPU/GPU kết nối bằng mạng tốc độ cao (InfiniBand).

* Khả năng xử lý hàng petaflop đến exaflop.

  * Phân tán miền (Domain Decomposition):

* Trái Đất được chia thành các ô lưới 3D nhỏ (grid cell) cho khí quyển, đại dương.

* Mỗi nút HPC xử lý một tập hợp ô lưới, truyền thông liên tục với các nút khác.

  * Mô hình phương trình đạo hàm riêng:

* Giải Navier–Stokes cho dòng chảy khí quyển.

* Ghép nối với mô hình hóa bức xạ, mây, aerosol, sinh học đại dương.


# Ứng dụng trong mô phỏng khí hậu dài hạn

  * Dự báo biến đổi khí hậu 100 năm: Mô phỏng kịch bản phát thải khác nhau (RCP, SSP) để dự đoán nhiệt độ, mực nước biển, tần suất bão.

  * Đánh giá tác động khu vực: Mô hình độ phân giải cao (1–5 km) cho phép dự báo lũ quét, sóng nhiệt cụ thể từng vùng.

  * Hỗ trợ chính sách: Cung cấp dữ liệu cho các hiệp định quốc tế như Paris Agreement, giúp chính phủ hoạch định giảm phát thải.


# Ứng dụng trong dự báo thời tiết cực đoan

  * Dự báo bão: HPC cho phép mô phỏng quỹ đạo và cường độ bão trong vài giờ, cải thiện độ chính xác cảnh báo sớm.

  * Cảnh báo lũ và mưa lớn: Mô hình thủy văn kết hợp khí tượng chạy trên siêu máy tính để ước tính lượng mưa, mực nước sông.

  * Theo dõi cháy rừng: Mô phỏng lan truyền lửa và khói theo gió, hỗ trợ sơ tán và điều động lực lượng cứu hỏa.


# Công nghệ hỗ trợ

  * GPU và tính toán dị thể: Kết hợp CPU và GPU tăng tốc giải phương trình động lực học.

  * Machine Learning kết hợp HPC: Dùng AI để tinh chỉnh mô hình, giảm sai số dự báo.

  * Cloud-HPC Hybrid: Tận dụng tài nguyên đám mây cho các chiến dịch mô phỏng lớn đột xuất.

  * Hệ thống lưu trữ tốc độ cao: Cần băng thông hàng trăm GB/s để ghi nhận hàng petabyte dữ liệu đầu ra.


# Lợi ích và tác động

  * Tăng độ chính xác: Độ phân giải cao (dưới 1 km) giúp dự báo chi tiết tới từng thành phố.

  * Giảm thời gian tính toán: Từ hàng tuần xuống còn vài giờ cho các kịch bản khẩn cấp.

  * Hỗ trợ quyết định chiến lược: Giúp chính phủ, doanh nghiệp lập kế hoạch ứng phó thiên tai và biến đổi khí hậu.

  * Nâng cao nghiên cứu khoa học: Cho phép mô hình hóa các hiện tượng phức tạp như tương tác khí hậu–băng, khí hậu–sinh học.


# Thách thức

  * Chi phí đầu tư: Xây dựng và vận hành siêu máy tính tốn hàng trăm triệu USD.

  * Tiêu thụ năng lượng lớn: Yêu cầu giải pháp làm mát và nguồn điện bền vững.

  * Đồng bộ dữ liệu toàn cầu: Cần chuẩn dữ liệu chung và mạng truyền tốc độ cao giữa các trung tâm khí tượng.

  * Đào tạo nhân lực: Đòi hỏi chuyên gia lập trình song song và khoa học khí hậu.


# Xu hướng tương lai

  * Exascale Computing: Siêu máy tính đạt trên 10^18 phép tính/giây cho mô hình toàn cầu độ phân giải vài trăm mét.

  * AI-HPC kết hợp: AI học từ kết quả mô phỏng để tạo “mô hình thay thế” (surrogate models) nhanh hơn nhưng vẫn chính xác.

  * Năng lượng xanh cho HPC: Tận dụng năng lượng tái tạo, làm mát bằng chất lỏng để giảm dấu chân carbon.

  * Mô phỏng đa vật lý: Ghép khí quyển, đại dương, băng, sinh học, kinh tế để tạo dự báo toàn diện về tác động khí hậu.

# Public083

# Giới thiệu

6G được dự đoán sẽ ra mắt vào khoảng năm 2030, tiếp nối thành công của 5G và mở ra kỷ nguyên kết nối tốc độ terabit/giây, độ trễ siêu thấp và khả năng tích hợp AI ở mọi tầng mạng. Không chỉ là nâng cấp về băng thông, 6G hứa hẹn tạo nên hạ tầng truyền thông toàn cầu, kết hợp trí tuệ nhân tạo, tính toán lượng tử, và truyền thông quang – vệ tinh, phục vụ các ứng dụng từ metaverse, Internet vạn vật công nghiệp, đến điều khiển robot từ xa với độ chính xác thời gian thực.

# 6G là gì? Tổng quan về mạng và công nghệ 6G

6G (không dây thế hệ thứ sáu) là sự kế thừa của công nghệ di động 5G . Mạng 6G sẽ có thể sử dụng tần số cao hơn mạng 5G và cung cấp dung lượng cao hơn đáng kể và độ trễ thấp hơn nhiều . Một trong những mục tiêu của internet 6G sẽ là hỗ trợ giao tiếp với độ trễ micro giây. Tốc độ này nhanh hơn 1.000 lần – hoặc độ trễ là 1/1000 – so với thông lượng một phần nghìn giây .

Thị trường công nghệ 6G được kỳ vọng sẽ tạo điều kiện cho những cải tiến lớn về hình ảnh, công nghệ hiện diện và nhận biết vị trí . Hoạt động kết hợp với trí tuệ nhân tạo ( AI ), cơ sở hạ tầng tính toán của 6G sẽ tự động xác định vị trí tốt nhất để tính toán xảy ra; điều này bao gồm các quyết định về lưu trữ , xử lý và chia sẻ dữ liệu .

# Ưu điểm của 6G so với 5G là gì?

6G dự kiến ​​sẽ hỗ trợ tốc độ dữ liệu 1 terabyte mỗi giây. Các điểm truy cập sẽ có thể phục vụ nhiều khách hàng đồng thời thông qua đa truy cập phân chia theo tần số trực giao . Mức dung lượng và độ trễ này sẽ mở rộng hiệu suất của các ứng dụng 5G và mở rộng phạm vi khả năng hỗ trợ các ứng dụng sáng tạo trong kết nối không dây, nhận thức, cảm biến và hình ảnh.

Tần số cao hơn của 6G sẽ cho phép tốc độ lấy mẫu nhanh hơn nhiều , ngoài việc cung cấp thông lượng tốt hơn đáng kể và tốc độ dữ liệu cao hơn. Sự kết hợp của các sóng dưới mm (ví dụ, bước sóng nhỏ hơn một milimét) và tính chọn lọc tần số để xác định tốc độ hấp thụ điện từ tương đối có thể dẫn đến những tiến bộ đáng kể trong công nghệ cảm biến không dây.

Điện toán biên di động (MEC) sẽ được tích hợp vào tất cả các mạng 6G, trong khi nó phải được thêm vào các mạng 5G hiện có. Điện toán biên và lõi sẽ được tích hợp liền mạch hơn như một phần của khung cơ sở hạ tầng tính toán / truyền thông kết hợp vào thời điểm mạng 6G được triển khai. Cách tiếp cận này sẽ mang lại nhiều lợi thế tiềm năng khi công nghệ 6G đi vào hoạt động, bao gồm cải thiện khả năng tiếp cận các khả năng của AI.

# Khi nào có Internet 6G?

Internet 6G dự kiến ​​sẽ ra mắt thương mại vào năm 2030. Công nghệ này sử dụng nhiều hơn mạng truy cập vô tuyến phân tán ( RAN ) và phổ terahertz (THz) để tăng dung lượng, giảm độ trễ và cải thiện việc chia sẻ phổ tần. Trong khi một số cuộc thảo luận ban đầu đã diễn ra để xác định 6G, các hoạt động nghiên cứu và phát triển (R&D) đã bắt đầu một cách nghiêm túc vào năm 2020.

Ví dụ, Trung Quốc đã phóng vệ tinh thử nghiệm 6G được trang bị hệ thống THz, trong khi các công ty công nghệ khổng lồ Huawei Technologies và China Global được cho là có kế hoạch phóng vệ tinh 6G tương tự vào năm 2021. Nhiều vấn đề liên quan đến việc triển khai vô tuyến sóng milimet cho 5G phải được giải quyết kịp thời cho các nhà thiết kế mạng để giải quyết những thách thức của 6G.

# 6G sẽ hoạt động như thế nào?

Dự kiến, các giải pháp cảm biến không dây 6G sẽ sử dụng có chọn lọc các tần số khác nhau để đo mức độ hấp thụ và điều chỉnh tần số cho phù hợp. Phương pháp này có thể thực hiện được vì các nguyên tử và phân tử phát ra và hấp thụ bức xạ điện từ ở các tần số đặc trưng, ​​và các tần số phát xạ và hấp thụ là như nhau đối với bất kỳ chất nào.

![6G sẽ hoạt động như thế nào?](images/image1.png)

6G sẽ có ý nghĩa lớn đối với nhiều phương pháp tiếp cận của chính phủ và ngành đối với an toàn công cộng và bảo vệ tài sản quan trọng như:

  * phát hiện mối đe dọa;

  * theo dõi sức khỏe;

  * tính năng và nhận dạng khuôn mặt ;

  * ra quyết định trong các lĩnh vực như thực thi pháp luật và hệ thống tín dụng xã hội;

  * đo chất lượng không khí;

  * cảm nhận khí và độc tính.


Những cải tiến trong các lĩnh vực này cũng sẽ mang lại lợi ích cho công nghệ di động, cũng như các công nghệ mới nổi như thành phố thông minh, xe tự lái, thực tế ảo và thực tế tăng cường.

# Đặc trưng công nghệ cốt lõi

  * Tốc độ dữ liệu siêu cao: Dự kiến đạt 1 Tbps, gấp hàng chục lần 5G, cho phép truyền tải video 16K, thực tế ảo (VR/AR) mượt mà.

  * Độ trễ dưới 0,1 mili giây: Hỗ trợ phẫu thuật từ xa, điều khiển xe tự hành trên toàn cầu.

  * Phổ tần Terahertz (THz): Khai thác dải tần 0,1–10 THz, cung cấp băng thông cực lớn nhưng yêu cầu giải pháp khuếch đại và anten tiên tiến.

  * Tích hợp vệ tinh – mặt đất: Tạo vùng phủ sóng toàn cầu, đặc biệt ở đại dương và khu vực hẻo lánh.

  * Mạng định nghĩa bằng phần mềm (SDN) và ảo hóa (NFV): Cho phép cấu hình linh hoạt và quản lý tự động.


# Vai trò của trí tuệ nhân tạo trong 6G

AI không chỉ là ứng dụng chạy trên mạng, mà còn là thành phần lõi:

  * Tối ưu hóa phổ tần động: AI phân tích nhu cầu và điều kiện môi trường để phân bổ phổ tần tự động.

  * Điều khiển mạng tự trị: Hệ thống tự học, tự cấu hình, tự khắc phục sự cố mà không cần can thiệp con người.

  * Dự đoán lưu lượng và bảo trì chủ động: AI dự báo tắc nghẽn, điều phối tài nguyên trước khi sự cố xảy ra.

  * Bảo mật thông minh: Phát hiện tấn công mạng, xác thực người dùng và thiết bị theo thời gian thực.


# Ứng dụng tiêu biểu

  * Thực tế ảo toàn cảnh (Immersive XR/Metaverse): 6G cung cấp băng thông và độ trễ cần thiết cho trải nghiệm ảo siêu chân thực.

  * Xe tự hành toàn cầu: Giao tiếp giữa phương tiện và hạ tầng đường bộ với độ trễ cực thấp.

  * Y tế từ xa nâng cao: Phẫu thuật robot thời gian thực, chia sẻ dữ liệu hình ảnh y tế dung lượng lớn ngay lập tức.

  * Internet vạn vật công nghiệp (IIoT): Điều khiển dây chuyền sản xuất, giám sát hàng triệu cảm biến trong thời gian thực.

  * Truyền thông lượng tử kết hợp 6G: Tăng cường bảo mật với phân phối khóa lượng tử (QKD).


# Hạ tầng kỹ thuật

  * Anten thông minh MIMO khổng lồ: Tối ưu hóa chùm sóng để đạt băng thông cao và giảm nhiễu.

  * Tích hợp quang – không dây: Sử dụng liên kết quang học tự do (FSO) cho đường truyền tốc độ cực cao.

  * Điện toán biên (Edge Computing): Đưa AI và xử lý dữ liệu gần người dùng để giảm độ trễ và tiết kiệm băng thông.

  * Điện toán lượng tử và AI: Tăng tốc giải bài toán tối ưu hóa mạng và bảo mật.


# Thách thức triển khai

  * Tiêu thụ năng lượng: Mạng 6G yêu cầu giải pháp năng lượng xanh và thiết bị tiết kiệm điện.

  * Chuẩn hóa toàn cầu: Cần sự hợp tác của nhiều quốc gia, tổ chức viễn thông để thống nhất tiêu chuẩn.

  * Chi phí đầu tư lớn: Cơ sở hạ tầng anten THz, vệ tinh và thiết bị người dùng mới đòi hỏi vốn khổng lồ.

  * Bảo mật: Dù AI hỗ trợ, mạng càng thông minh càng dễ bị tấn công tinh vi hơn.


# Xu hướng tương lai

  * AI gốc mạng (Native AI): Mọi lớp của mạng 6G, từ vật lý đến ứng dụng, đều được điều khiển bởi AI.

  * Hợp nhất đất – trời – biển – không gian: Mạng 6G cung cấp kết nối liền mạch cho mọi môi trường.

  * Tích hợp Blockchain: Đảm bảo tính minh bạch và an toàn cho các giao dịch dữ liệu khổng lồ.

  * Mạng xanh bền vững: Sử dụng năng lượng tái tạo, công nghệ thu hồi năng lượng (energy harvesting).

# Public084

# Giới thiệu

Xe tự hành đang trở thành tâm điểm của ngành giao thông thông minh. Để hoạt động an toàn trong môi trường phức tạp, phương tiện phải nhận thức xung quanh nhanh, chính xác và tin cậy. Trọng tâm của khả năng này là thị giác máy tính (computer vision) – công nghệ giúp xe “nhìn” và “hiểu” thế giới thông qua camera, radar, LiDAR và cảm biến đa dạng.

Thế hệ tiếp theo của xe tự hành yêu cầu hệ thống thị giác máy tính vượt xa các mô hình hiện tại, hỗ trợ nhận diện thời gian thực, dự đoán hành vi, và ra quyết định tự động trong điều kiện thời tiết, ánh sáng và giao thông phức tạp.

# Cấu phần chính của hệ thống thị giác

  * Cảm biến đa phương thức:

* Camera RGB/IR: Thu thập hình ảnh màu và hồng ngoại, xử lý chi tiết môi trường.

* LiDAR: Tạo bản đồ 3D chính xác của môi trường, đo khoảng cách và hình dạng vật thể.

* Radar sóng mm: Hoạt động tốt trong sương mù, mưa, tuyết, bổ trợ cho camera.

* Cảm biến siêu âm: Hỗ trợ đỗ xe, đo khoảng cách gần.

  * Xử lý cảm biến hợp nhất (Sensor Fusion):

* Kết hợp dữ liệu từ nhiều cảm biến để có bức tranh toàn cảnh, giảm sai số từng loại cảm biến.

  * Mô-đun thị giác máy tính:

* Phát hiện đối tượng (Object Detection): Nhận diện người đi bộ, xe cộ, biển báo.

* Phân đoạn ngữ nghĩa (Semantic Segmentation): Phân loại từng điểm ảnh để xác định làn đường, vỉa hè.

* Theo dõi chuyển động (Object Tracking): Dự đoán quỹ đạo vật thể di chuyển.


# Thuật toán và mô hình AI

##  Mạng CNN

  * Mạng CNN là một tập hợp các lớp Convolution chồng lên nhau và sử dụng các hàm nonlinear activation như ReLU và tanh để kích hoạt các trọng số trong các node. Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo.

  * Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo. Trong mô hình mạng truyền ngược (feedforward neural network) thì mỗi neural đầu vào (input node) cho mỗi neural đầu ra trong các lớp tiếp theo.

  * Mô hình này gọi là mạng kết nối đầy đủ (fully connected layer) hay mạng toàn vẹn (affine layer). Còn trong mô hình CNNs thì ngược lại. Các layer liên kết được với nhau thông qua cơ chế convolution.

  * Layer tiếp theo là kết quả convolution từ layer trước đó, nhờ vậy mà ta có được các kết nối cục bộ. Như vậy mỗi neuron ở lớp kế tiếp sinh ra từ kết quả của filter áp đặt lên một vùng ảnh cục bộ của neuron trước đó.

  * Mỗi một lớp được sử dụng các filter khác nhau thông thường có hàng trăm hàng nghìn filter như vậy và kết hợp kết quả của chúng lại. Ngoài ra có một số layer khác như pooling/subsampling layer dùng để chắt lọc lại các thông tin hữu ích hơn (loại bỏ các thông tin nhiễu).

  * Trong quá trình huấn luyện mạng (traning) CNN tự động học các giá trị qua các lớp filter dựa vào cách thức mà bạn thực hiện. Ví dụ trong tác vụ phân lớp ảnh, CNNs sẽ cố gắng tìm ra thông số tối ưu cho các filter tương ứng theo thứ tự raw pixel > edges > shapes > facial > high-level features. Layer cuối cùng được dùng để phân lớp ảnh.

  * ![Cấu trúc của mạng CNN](images/image1.png)

  * Trong mô hình CNN có 2 khía cạnh cần quan tâm là **tính bất biến** (Location Invariance) và **tính kết hợp** (Compositionality). Với cùng một đối tượng, nếu đối tượng này được chiếu theo các gốc độ khác nhau (translation, rotation, scaling) thì độ chính xác của thuật toán sẽ bị ảnh hưởng đáng kể.

  * Pooling layer sẽ cho bạn tính bất biến đối với phép dịch chuyển (translation), phép quay (rotation) và phép co giãn (scaling). Tính kết hợp cục bộ cho ta các cấp độ biểu diễn thông tin từ mức độ thấp đến mức độ cao và trừu tượng hơn thông qua convolution từ các filter.

  * Đó là lý do tại sao CNNs cho ra mô hình với độ chính xác rất cao. Cũng giống như cách con người nhận biết các vật thể trong tự nhiên.

  * Mạng CNN sử dụng 3 ý tưởng cơ bản:

  * **các trường tiếp nhận cục bộ** (local receptive field)

  * **trọng số chia sẻ** (shared weights)

  * **tổng hợp** (pooling).


##  Recurrent Neural Network

![A diagram of a network AI-generated content may be incorrect.](images/image2.png)

  * Các x ở đây đại diện cho dữ liệu đầu vào lần lượt (được chia theo time step).

  * xt _xt_ ​ đại diện cho time step thứ t, và yt _yt_ ​ là output của một step. Ví dụ, x2 _x_ 2​ sẽ là vector đại diện của từ thứ 2 trong câu văn bản.

  * Hình ảnh dưới đây cho thấy rõ hơn điều gì thực sự xảy ra trong một step.

  *   * **Hidden state** ht _ht_ ​ (trong một số tài liệu tường ký hiện st _st_ ​). Đây chính là bộ nhớ của mạng. ht _ht_ ​ là tổng hợp thông tin của hidden state trước ( ht−1 _ht_ −1​) cộng với input tại time step t ( xt _xt_ ​). Activation function ở đây $g_1$chủ yếu là tanh hoặc ReLu.

  * ht=g1(Whh∗ht−1+Whx∗xt+bh) _ht_ ​= _g_ 1( _Whh_ ​∗ _ht_ −1​+ _Whx_ ​∗ _xt_ ​+ _bh_ ​)

  * Hoặc có thể viết gọn hơn:

  * ht=g1((WhhWhx)(ht−1xt)) _ht_ ​= _g_ 1(( _Whh_ ​ _Whx_ ​)( _ht_ −1​ _xt_ ​​))

  * ht=g1((W)(ht−1xt)) _ht_ ​= _g_ 1(( _W_ )( _ht_ −1​ _xt_ ​​))

  * **Output của từng time step yt _yt_ ​** : Tại 1 block của mạng RNN có 2 đầu ra. Trong đó, ht _ht_ ​ là tổng hợp thông tin của các state trước để tiếp tục truyền đi trong chuỗi mạng, và ta có thêm yt _yt_ ​ là output của từng time step một. Ở đây g2 _g_ 2​ thường là hàm softmax.

  * yt=g2(Wyh∗ht+by) _yt_ ​= _g_ 2( _Wyh_ ​∗ _ht_ ​+ _by_ ​)


# Ứng dụng và kịch bản thực tế

  * Điều khiển trên đường cao tốc: Nhận dạng phương tiện di chuyển nhanh, dự đoán làn đường.

  * Môi trường đô thị đông đúc: Xử lý tình huống bất ngờ như người đi bộ băng qua đường, xe đạp di chuyển ngược chiều.

  * Thời tiết khắc nghiệt: Cần thuật toán chịu nhiễu tốt trong mưa lớn, tuyết dày, hoặc ánh sáng yếu.

  * Đỗ xe tự động: Nhận diện vật cản nhỏ, khoảng trống, biển báo trong không gian hẹp.


# Thách thức kỹ thuật

  * Đa dạng môi trường: Khác biệt về điều kiện ánh sáng, thời tiết, hạ tầng đường xá giữa các quốc gia.

  * Xử lý thời gian thực: Đòi hỏi phần cứng GPU/TPU mạnh, tối ưu hóa mô hình để giảm độ trễ dưới 50 ms.

  * An toàn và tin cậy: Hệ thống phải có cơ chế dự phòng khi một hoặc nhiều cảm biến hỏng.

  * Dữ liệu huấn luyện khổng lồ: Cần hàng triệu km dữ liệu lái xe, bao gồm tình huống hiếm gặp.

  * Tấn công đối kháng (Adversarial Attacks): Cần bảo vệ trước việc kẻ xấu dùng biển báo giả hay tín hiệu gây nhiễu.


# Xu hướng phát triển

  * Edge AI trong xe: Xử lý trực tiếp trên thiết bị thay vì gửi về đám mây, giảm độ trễ và tăng tính riêng tư.

  * LiDAR thế hệ mới chi phí thấp: Giúp phổ cập xe tự hành.

  * Mô hình học tự giám sát (Self-Supervised Learning): Giảm nhu cầu dữ liệu gắn nhãn tốn kém.

  * Hợp tác xe – hạ tầng (V2X): Xe trao đổi dữ liệu trực tiếp với đèn tín hiệu, camera giao thông, và các phương tiện khác.

  * Giải thích mô hình (Explainable AI): Cho phép hiểu quyết định của hệ thống để hỗ trợ kiểm định an toàn.


# Tác động xã hội và kinh tế

  * An toàn giao thông: Giảm tai nạn do lỗi con người.

  * Hiệu quả vận tải: Giảm ùn tắc, tối ưu hóa lộ trình và tiết kiệm nhiên liệu.

  * Dịch vụ di chuyển mới: Robotaxi, giao hàng tự động, xe buýt tự lái.

  * Quy định pháp lý: Cần khung pháp luật cho bảo hiểm, trách nhiệm tai nạn và quyền riêng tư.

# Public085

# Giới thiệu

Nhà máy thông minh – nền tảng của Công nghiệp 4.0 – đòi hỏi mức độ tự động hóa và linh hoạt cao hơn bao giờ hết. Trong môi trường sản xuất hiện đại, dây chuyền phải thích ứng nhanh với thay đổi sản phẩm, khối lượng và yêu cầu chất lượng. Robot công nghiệp tự học chính là giải pháp: thay vì lập trình cứng, robot có khả năng học hỏi từ dữ liệu, tự tối ưu hành động và cộng tác an toàn với con người, tạo nên một thế hệ robot linh hoạt, thông minh và hiệu quả.

# Các loại thuật toán được sử dụng trong robot truyền thống

## Bất kỳ lúc nào A * Thuật toán

Thuật toán A * là một thuật toán tìm kiếm đường đi được sử dụng để tìm đường đi tối ưu nhất giữa hai điểm, tức là với chi phí nhỏ nhất.

Bất cứ lúc nào A * Algorithm có chi phí thời gian linh hoạt và có thể trả về đường đi ngắn nhất ngay cả khi nó bị gián đoạn vì nó tạo ra một giải pháp không tối ưu trước và sau đó tối ưu hóa nó.

Điều này cho phép ra quyết định nhanh hơn vì robot có thể xây dựng dựa trên các tính toán trước đó thay vì bắt đầu từ đầu.

![Hoạt hình tiến bộ của Astar](images/image1.gif)

### Cách sử dụng?

Nó thực hiện điều này bằng cách hình thành một 'cây' kéo dài từ nút bắt đầu cho đến khi các tiêu chí kết thúc được kích hoạt, có nghĩa là có sẵn một con đường ít tốn kém hơn.

Lưới 2D được tạo ra với các chướng ngại vật và ô bắt đầu và ô mục tiêu được thiết kế theo chiều nhọn.

Thuật toán xác định 'giá trị' của một nút bằng f là tổng các tham số g (chi phí di chuyển từ nút bắt đầu đến nút được đề cập) và h (chi phí di chuyển từ nút được đề cập đến nút đích).

### Ứng dụng

Rất nhiều trò chơi và bản đồ dựa trên web sử dụng thuật toán này để tìm đường đi ngắn nhất một cách hiệu quả. Nó cũng có thể được sử dụng cho rô bốt di động.

Bạn cũng có thể giải quyết các vấn đề phức tạp như [Newton – Raphson](https://www.sciencedirect.com/topics/mathematics/newton-raphson-method) phép lặp được áp dụng để tìm căn bậc hai của một số.

Nó cũng được sử dụng trong các bài toán về quỹ đạo để dự đoán chuyển động và va chạm của một vật thể trong không gian.

##  Thuật toán D *

D *, D * và D * Lite tiêu điểm là các thuật toán tìm kiếm tăng dần để tìm đường đi ngắn nhất giữa hai điểm.

Tuy nhiên, chúng là sự kết hợp của các thuật toán A * và những khám phá mới cho phép họ thêm thông tin vào bản đồ của mình cho những chướng ngại vật chưa biết.

Sau đó, họ có thể tính toán lại một tuyến đường dựa trên thông tin mới, giống như Mars Rover.

![Hình minh họa Lập kế hoạch đường dẫn thuật toán D Lite](images/image2.png)

### Cách sử dụng?

Hoạt động của D * Algorithm tương tự như A *, đầu tiên thuật toán xác định f, h và tạo một danh sách mở và đóng.

Sau đó, Thuật toán D * xác định giá trị g của nút hiện tại bằng cách sử dụng giá trị g của các nút lân cận của nó.

Mỗi nút lân cận đưa ra phỏng đoán về giá trị g hiện tại của một nút và giá trị g ngắn nhất được điều chỉnh thành giá trị g mới.

### Ứng dụng

D * và các biến thể của nó được sử dụng rộng rãi cho rô bốt di động và [xe tự trị](https://hashdork.com/vi/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng-xe-t%E1%BB%B1-h%C3%A0nh/) dẫn đường.

Các hệ thống định vị như vậy bao gồm một hệ thống nguyên mẫu được thử nghiệm trên tàu Mars rovers Cơ hội và Tinh thần và hệ thống định vị đã giành được [Thách thức đô thị DARPA](https://www.darpa.mil/about-us/timeline/darpa-urban-challenge).

##  Thuật toán PRM

PRM, hay lộ trình xác suất, là một đồ thị mạng lưới các đường đi có thể có dựa trên các không gian trống và bị chiếm dụng trên một bản đồ nhất định.

Chúng được sử dụng trong các hệ thống lập kế hoạch phức tạp và cũng để tìm ra các con đường chi phí thấp xung quanh các chướng ngại vật.

PRM sử dụng một mẫu ngẫu nhiên các điểm trên bản đồ của họ nơi thiết bị rô bốt có thể di chuyển và sau đó tính toán đường đi ngắn nhất.

![Các nút PRM được tạo ngẫu nhiên trong không gian tự do và các cạnh của nó được vẽ như vậy](images/image3.png)

### Cách sử dụng?

PRM bao gồm giai đoạn xây dựng và truy vấn.

Trong giai đoạn đầu, một lộ trình được vẽ biểu đồ gần đúng với các chuyển động có thể có trong một môi trường. Một cấu hình ngẫu nhiên sau đó được tạo và kết nối với một số hàng xóm.

Cấu hình bắt đầu và mục tiêu được kết nối với biểu đồ trong giai đoạn truy vấn. Đường dẫn sau đó thu được bởi một [Con đường ngắn nhất của Dijkstra](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/) truy vấn.

### Ứng dụng

PRM được sử dụng trong các nhà lập kế hoạch cục bộ, trong đó thuật toán tính toán một đường thẳng giữa hai điểm, cụ thể là điểm ban đầu và điểm mục tiêu.

Thuật toán cũng có thể được sử dụng để cải thiện các ứng dụng lập kế hoạch đường đi và phát hiện va chạm.

## Thuật toán Zero Moment Point (ZMP)

Zero Moment Point (kỹ thuật ZMP) là một thuật toán được sử dụng bởi robot để giữ cho tổng quán tính ngược với phản lực của sàn.

Thuật toán này sử dụng khái niệm tính toán ZMP và áp dụng nó để cân bằng robot hai chân. Sử dụng thuật toán này trên bề mặt sàn nhẵn dường như cho phép robot đi lại như thể không có giây phút nào.

Các công ty sản xuất như ASIMO (Honda) sử dụng kỹ thuật này.

![Điểm Zero Moment ZMP và hiệu chỉnh quỹ đạo của nó](images/image4.png)

### Cách sử dụng?

Chuyển động của rô bốt đi bộ được lập kế hoạch bằng cách sử dụng phương trình mômen động lượng. Nó đảm bảo rằng chuyển động khớp được tạo ra đảm bảo sự ổn định tư thế động học của robot.

Độ ổn định này được định lượng bằng khoảng cách của điểm không mô men (được tính toán bằng thuật toán) trong ranh giới của vùng ổn định được xác định trước.

### Ứng dụng

Điểm zero moment có thể được sử dụng làm thước đo để đánh giá độ ổn định chống lại sự cố lật của robot như iRobot PackBot khi điều hướng đường dốc và chướng ngại vật.

## Thuật toán điều khiển vi phân tích phân tỷ lệ (PID)

Điều khiển vi sai tích phân tỷ lệ hoặc PID, tạo một vòng phản hồi cảm biến để điều chỉnh cài đặt cho các thành phần cơ khí bằng cách tính toán giá trị lỗi.

Các thuật toán này kết hợp cả ba hệ số cơ bản, tức là tỷ lệ, tích phân và đạo hàm để tạo ra tín hiệu điều khiển.

Nó hoạt động trong thời gian thực và áp dụng các chỉnh sửa khi cần thiết. Điều này có thể được nhìn thấy trong [xe tự lái](https://hashdork.com/vi/tesla-fsd-%E2%80%8B%E2%80%8Bbeta-v10/).

![Sơ đồ bộ điều khiển PID](images/image5.png)

### Cách sử dụng?

Bộ điều khiển PID sử dụng ba thuật ngữ điều khiển là ảnh hưởng tỷ lệ, tích phân và đạo hàm trên đầu ra của nó để áp dụng điều khiển chính xác và tối ưu.

Bộ điều khiển này liên tục tính toán một giá trị lỗi là sự khác biệt giữa điểm đặt mong muốn và một biến quá trình đo được.

Sau đó, nó áp dụng một hiệu chỉnh để giảm thiểu lỗi theo thời gian bằng cách điều chỉnh biến điều khiển.

# Đặc trưng của robot tự học

  * Khả năng học tăng cường (Reinforcement Learning): Robot khám phá hành động mới, nhận phản hồi từ môi trường để cải thiện chiến lược điều khiển.

  * Học chuyển giao (Transfer Learning): Kỹ năng học được ở một nhiệm vụ (ví dụ lắp ráp linh kiện) có thể chuyển sang nhiệm vụ tương tự khác, rút ngắn thời gian đào tạo.

  * Thị giác máy tính tích hợp: Camera 3D và cảm biến độ sâu giúp robot nhận diện vật thể, vị trí và hướng, cho phép gắp nhặt vật liệu không định hình.

  * Cảm biến xúc giác và lực: Giúp điều chỉnh lực cầm nắm, giảm nguy cơ hư hỏng sản phẩm.

  * Điện toán biên (Edge AI): Xử lý dữ liệu và ra quyết định trực tiếp tại robot, giảm độ trễ so với gửi dữ liệu lên đám mây.


# Ứng dụng trong nhà máy thông minh

  * Lắp ráp linh kiện phức tạp: Robot học từ mẫu và tự điều chỉnh quỹ đạo khi vị trí linh kiện thay đổi.

  * Hàn và sơn tự động: Học cách tối ưu đường hàn/sơn cho các sản phẩm có hình dạng khác nhau.

  * Đóng gói và phân loại: Sử dụng thị giác để phân loại hàng hóa theo kích thước, màu sắc, tình trạng bề mặt.

  * Bảo trì và kiểm tra: Robot tự di chuyển, quét cảm biến, phát hiện hỏng hóc trong dây chuyền.

  * Cộng tác người – máy (Cobots): Làm việc an toàn cùng công nhân, học cách phối hợp và chia sẻ nhiệm vụ.


# Lợi ích nổi bật

  * Linh hoạt sản xuất: Dễ dàng thích nghi khi thay đổi mẫu mã, số lượng sản phẩm.

  * Tăng năng suất: Giảm thời gian ngừng máy và sai sót do con người.

  * Tiết kiệm chi phí dài hạn: Dù đầu tư ban đầu cao, nhưng giảm chi phí bảo trì, đào tạo và lập trình về sau.

  * Cải thiện an toàn: Robot xử lý các nhiệm vụ nguy hiểm, giảm tai nạn lao động.


# Công nghệ nền tảng

  * Mạng nơ-ron sâu (Deep Neural Networks): Giúp robot nhận diện vật thể và lập kế hoạch đường đi tối ưu.

  * Học tự giám sát (Self-Supervised Learning): Cho phép robot tận dụng dữ liệu chưa gắn nhãn để học cách cầm nắm và di chuyển.

  * Mô phỏng thực tế ảo (Simulation-to-Real Transfer): Huấn luyện robot trong môi trường ảo rồi chuyển kỹ năng sang thế giới thực, giảm chi phí thử nghiệm.

  * Kết nối IoT công nghiệp: Robot liên tục trao đổi dữ liệu với hệ thống quản lý sản xuất (MES) và kho dữ liệu lớn.


# Thách thức

  * Độ tin cậy và an toàn: Robot phải bảo đảm an toàn tuyệt đối khi làm việc chung với con người.

  * Chi phí đầu tư ban đầu: Phần cứng, cảm biến và hệ thống AI chất lượng cao đòi hỏi vốn lớn.

  * Quản lý dữ liệu khổng lồ: Cần hạ tầng lưu trữ và xử lý dữ liệu mạnh mẽ.

  * Chuẩn hóa và tích hợp: Phải tương thích với nhiều hệ thống điều khiển và phần mềm nhà máy khác nhau.


# Tác động kinh tế – xã hội

  * Tái cấu trúc lực lượng lao động: Giảm công việc lặp lại nguy hiểm, nhưng đòi hỏi đào tạo lại nhân sự cho các vị trí quản lý và giám sát robot.

  * Tăng sức cạnh tranh toàn cầu: Doanh nghiệp có thể sản xuất với tốc độ cao, chất lượng ổn định, giảm chi phí xuất khẩu.

  * Hỗ trợ sản xuất bền vững: Robot tối ưu năng lượng, giảm lãng phí nguyên liệu.


# Xu hướng tương lai

  * Robot tự học đa kỹ năng: Chuyển đổi giữa nhiều tác vụ mà không cần lập trình lại.

  * Kết hợp với trí tuệ nhân tạo tạo sinh: Robot có thể tự đề xuất cách sắp xếp dây chuyền mới hoặc thiết kế công cụ tùy biến.

  * Liên kết đám mây – biên: Mô hình huấn luyện lớn trên đám mây, suy luận nhanh tại robot.

  * Cộng tác liên robot: Nhiều robot giao tiếp và học lẫn nhau, tối ưu toàn bộ quy trình sản xuất

# Public086

# Giới thiệu

Thành phố thông minh của tương lai cần một hệ thống năng lượng xanh, ổn định và bền vững, trong đó nguồn năng lượng tái tạo như điện mặt trời, gió, thủy triều và sinh khối đóng vai trò chủ lực. Tuy nhiên, đặc tính dao động và khó dự đoán của các nguồn này – như mây che mặt trời hay gió thay đổi – gây khó khăn lớn cho việc cân bằng cung cầu và đảm bảo chất lượng điện.

Trí tuệ nhân tạo (AI) cung cấp giải pháp đột phá, cho phép dự báo, tối ưu hóa và tự động điều phối năng lượng tái tạo trong thời gian thực. Hệ thống AI được triển khai từ cấp hộ gia đình đến lưới điện thành phố, giúp giảm chi phí, nâng cao hiệu suất và giảm phát thải carbon.

# Năng lượng tái tạo là gì, các loại năng lượng tái tạo bao gồm dạng nào?

Năng lượng tái tạo là các nguồn tự nhiên như ánh sáng mặt trời, mưa, gió, thủy triều, và được phân loại thành nhiều dạng như [năng lượng mặt trời](https://vuphong.vn/nang-luong-mat-troi-la-gi/), [năng lượng gió](https://vuphong.vn/thu-vi-ve-dien-gio/), năng lượng thủy triều, [năng lượng địa nhiệt](https://vuphong.vn/dien-dia-nhiet-huong-den-phat-trien-ben-vung/), [năng lượng sinh khối](https://vuphong.vn/uu-nhuoc-diem-cua-nang-luong-hoa-thach/), v.v. Đây là [nguồn năng lượng sạch](https://vuphong.vn/phat-trien-cac-nguon-nang-luong-sach/), thân thiện với môi trường và có tính bền [vững](https://vuphong.vn/vu-phong-quyet-tam-vung-buoc-chuyen-minh-vuon-tam-dai-chung/) cao.

Năng lượng tái tạo đang được xem là những **năng lượng sạch** nhất hành tinh và là tương lai của [ngành năng lượng](https://vuphong.vn/tong-quan-nganh-cong-nghiep-nang-luong-viet-nam/) toàn cầu. Chúng có nhiều thế mạnh so với năng lượng hóa thạch và tất nhiên cũng đi kèm một vài nhược điểm. Dưới đây là những ưu nhược điểm của năng lượng tái tạo:

# Ưu, nhược điểm của năng lượng tái tạo

## Ưu điểm của năng lượng tái tạo

Ưu điểm đầu tiên của năng lượng tái tạo là có thể tái tạo được, trữ lượng vô cùng lớn, có thể vô tận. Các dạng năng lượng như mặt trời, gió, [địa nhiệt,](https://vuphong.vn/dien-dia-nhiet-huong-den-phat-trien-ben-vung/) sóng biển, mưa… có sẵn và tự do sử dụng, không mất chi phí nhiên liệu. [Năng](https://vuphong.vn/uu-nhuoc-diem-cua-nang-luong-tai-tao/) lượng sinh khối cũng có trữ lượng lớn và chi phí nhiên liệu thấp. So với các nguồn năng lượng truyền thống như than đá, dầu mỏ, khí đốt tự nhiên… đang ngày càng cạn kiệt, chỉ đáp ứng nhu cầu năng lượng của con người thêm khoảng 50-70 năm, ưu điểm này là một thế mạnh vượt trội.

Nhiều số liệu cho thấy sử dụng nguồn năng lượng tái tạo để sản xuất điện mang lại hiệu quả cao hơn nhiều so với sử dụng năng lượng thông thường. Các dạng năng lượng thông thường để được chuyển hóa thành điện sẽ được đốt cháy quá quá trình phức tạp tại nhà máy nhiệt điện nhưng không bao giờ có thể chuyển hóa 100%. Thực tế một lượng lớn nhiệt sau khi được sinh ra sẽ bị phân tán và lãng phí. Ví dụ ở Anh, sản xuất điện từ khí gas, có đến 54% lượng nhiệt bị lãng phí trong quá trình sản xuất điện, lượng điện bị lãng phí trong sản xuất từ than đá là 66%, ở năng lượng hạt nhân là 65%… Còn ở năng lượng tái tạo, không hề lãng phí chút năng lượng nào trong quá trình sinh điện vì dù có hiệu suất thấp hơn nhưng chúng vô tận.

![chứng nhận ISO](images/image1.jpeg) _Năng lượng tái tạo sạch, vô tận, có thể khai thác rộng rãi ở mọi khu vực trên trái đất là những ưu điểm của năng lượng tái tạo (Ảnh minh họa internet)_

Các dạng năng lượng tái tạo đều là những năng lượng sạch, thân thiện với môi trường, phát[ thải](https://vuphong.vn/giam-khi-thai/) ít carbon trong quá trình sản xuất, chuyển đổi. Chính vì vậy, năng lượng tái tạo được biết đến là giải pháp chống lại sự biến đổi khí hậu đang ngày càng tác động nghiêm trọng đến cuộc sống của con người, giúp bảo vệ hệ sinh thái chung. Ít tác động đến môi trường tự nhiên, không gây ô nhiễm không khí, không làm gia tăng sự nóng lên của khí hậu toàn cầu, hiệu ứng nhà kính… là một ưu điểm của năng lượng tái tạo mà con người đang rất cần.

Ưu điểm thứ 3 của năng lượng tái tạo là phong phú, có thể khai thác rộng rãi ở mọi khu vực khác nhau trên trái đất. Ví dụ với năng lượng mặt trời, người ta có thể khai thác nó ở bất cứ nơi nào, miễn là nơi đó có ánh sáng mặt trời, có thể dùng để tạo ra nhiệt làm nước nóng, sưởi ấm, tạo điện nhờ [hệ thống điện mặt trời](https://vuphong.vn/dien-mat-troi/) với những [tấm pin năng lượng mặt trời](https://vuphong.vn/pin-nang-luong-mat-troi/)… Hay với [năng lượng gió](https://vuphong.vn/nha-may-dien-nang-luong-tai-tao/#section_two), nguồn năng lượng này đã được sử dụng hàng trăm năm nay để di chuyển thuyền buồm, khinh khí cầu, làm các cối xay gió cho hệ thống tưới tiêu… hay xu hướng hiện nay là [sản xuất điện năng](https://vuphong.vn/dien-nang-luong-mat-troi-lan-rong-khap-cac-vung-que/) từ gió ở rất nhiều quốc gia trên thế giới.

Ngoài ra, tùy vào từng dạng năng lượng tái tạo mà nó còn có những ưu điểm riêng, ví dụ như năng lượng gió chiếm rất ít không gian; sử dụng năng lượng sinh khối từ các phế phẩm nông nghiệp, công nghiệp giúp giảm các bãi chôn xử lý rác, việc phát triển các loại cây trồng cung cấp cho năng lượng sinh khối còn tăng lượng oxy, giảm [CO2](https://vuphong.vn/khi-co2-la-gi/) cho môi trường…

## Nhược điểm của năng lượng tái tạo

Tuy có nhiều ưu điểm lớn nhưng năng lượng tái tạo cũng tồn tại một số nhược điểm, chẳng hạn như:

Do chịu tác động từ tự nhiên nên năng lượng tái tạo có tính ổn định thấp hơn so với các nguồn năng lượng truyền thống. Chỉ có thể khai thác năng lượng mặt trời vào ban ngày vào những ngày có mặt trời, còn ban đêm hay những ngày trời âm u, mưa thì hệ thống sẽ không hoạt động. Hay với năng lượng gió, các tua-bin gió chỉ có thể sinh điện vào những thời điểm có tốc độ gió thổi trong khoảng 4-25 m/s. Tốc độ gió phải tối thiểu 4 m/s thì các tua-bin gió mới bắt đầu chạy đều và phát điện, nhưng nếu vượt qua 25 m/s thì các tua-bin sẽ ngừng hoạt động để tránh hỏng hóc trong điều kiện gió mạnh.

# Vai trò của AI trong quản lý năng lượng tái tạo

  * Dự báo sản lượng điện:

* Sử dụng mô hình học máy và học sâu (Deep Learning) để dự đoán sản lượng từ tấm pin mặt trời hoặc tuabin gió dựa trên dữ liệu thời tiết, độ bức xạ mặt trời, tốc độ gió.

* Cải thiện độ chính xác dự báo từ vài giờ đến nhiều ngày, giúp lên kế hoạch vận hành lưới điện.

  * Tối ưu hóa phân phối:

* AI phân tích tình trạng tải, giá điện, nhu cầu tiêu thụ để phân phối nguồn điện tái tạo tới các khu vực ưu tiên.

* Thuật toán tối ưu đa mục tiêu giảm thất thoát truyền tải và chi phí vận hành.

  * Quản lý lưu trữ năng lượng:

* Điều phối sạc/xả pin quy mô lớn để cân bằng cung cầu theo thời gian thực.

* Dự đoán tuổi thọ pin, tự động luân phiên để kéo dài tuổi thọ hệ thống.

  * Điều khiển lưới điện vi mô (Microgrid):

* AI cho phép từng khu vực tự quản lý năng lượng, hoạt động độc lập khi lưới chính gặp sự cố.

* Tự động chuyển đổi giữa nguồn tái tạo, pin lưu trữ và điện lưới truyền thống.


# Hạ tầng công nghệ

  * Mạng cảm biến IoT: Thu thập dữ liệu thời tiết, trạng thái pin, dòng điện và tiêu thụ của từng tòa nhà.

  * Điện toán biên (Edge Computing): Xử lý dữ liệu ngay tại trạm biến áp hoặc tòa nhà để phản ứng nhanh, giảm độ trễ.

  * Nền tảng đám mây: Lưu trữ và phân tích dữ liệu lớn, huấn luyện mô hình AI toàn thành phố.

  * Giao thức chuẩn mở: Đảm bảo các thiết bị từ nhiều nhà sản xuất giao tiếp trơn tru.


# Ứng dụng thực tế

  * Thành phố Masdar (UAE): AI tối ưu hóa hệ thống điện mặt trời kết hợp lưu trữ năng lượng, giảm 20% chi phí vận hành.

  * Singapore: Sử dụng AI để điều phối lưới điện thông minh, dự báo nhu cầu tiêu thụ từng khu dân cư.

  * Đan Mạch: AI dự báo sản lượng gió, cho phép quốc gia này đáp ứng hơn 50% nhu cầu điện từ năng lượng tái tạo.


# Lợi ích kinh tế – môi trường

  * Giảm phát thải CO₂: Sử dụng tối đa năng lượng tái tạo, giảm phụ thuộc nhiên liệu hóa thạch.

  * Ổn định lưới điện: Dự báo và điều phối tốt giúp giảm nguy cơ mất điện, tăng chất lượng điện năng.

  * Tiết kiệm chi phí: Tối ưu hóa vận hành, giảm chi phí bảo trì và nâng cấp hạ tầng.

  * Nâng cao chất lượng sống: Cung cấp nguồn điện bền vững cho giao thông công cộng, chiếu sáng thông minh và dịch vụ dân sinh.


# Thách thức triển khai

  * Bảo mật dữ liệu: Hệ thống IoT và AI cần bảo vệ trước tấn công mạng.

  * Độ tin cậy dự báo: Điều kiện thời tiết biến đổi bất thường có thể gây sai lệch.

  * Chi phí đầu tư ban đầu: Cần hạ tầng cảm biến, pin lưu trữ và máy chủ tính toán mạnh.

  * Quản lý chính sách: Cần khung pháp lý hỗ trợ chia sẻ dữ liệu và vận hành liên vùng.


# Xu hướng tương lai

  * AI tự thích nghi (Self-Adaptive AI): Học liên tục từ dữ liệu thời tiết, tiêu thụ điện và giá thị trường để tối ưu điều khiển.

  * Blockchain kết hợp AI: Giao dịch năng lượng ngang hàng (P2P) minh bạch và an toàn.

  * Tích hợp xe điện (Vehicle-to-Grid): Sử dụng pin xe điện như nguồn lưu trữ di động, AI điều phối sạc/xả thông minh.

  * Mô phỏng số toàn thành phố (Digital Twin): Tạo bản sao ảo của hệ thống năng lượng để dự báo và thử nghiệm trước khi triển khai.

# Public087

Ô nhiễm không khí hiện đang là một trong những thách thức môi trường nghiêm trọng nhất tại Việt Nam, đặc biệt tại các đô thị lớn như Hà Nội và Thành phố Hồ Chí Minh. Sự gia tăng nồng độ bụi mịn PM2.5 vượt ngưỡng cho phép tại nhiều khu vực không chỉ ảnh hưởng trực tiếp đến sức khỏe cộng đồng mà còn đe dọa sự phát triển kinh tế - xã hội bền vững. Trong bối cảnh toàn cầu đang ứng phó với biến đổi khí hậu và các hệ lụy của quá trình đô thị hóa nhanh, nhận diện rõ thực trạng, xác định chính xác nguyên nhân, đánh giá mức độ đóng góp của từng nguồn thải và hiệu quả các giải pháp đã triển khai là cơ sở quan trọng để xây dựng chính sách phù hợp, góp phần nâng cao hiệu lực quản lý chất lượng không khí quốc gia.

# Giới thiệu

Ô nhiễm không khí đô thị là một trong những thách thức nghiêm trọng nhất đối với sức khỏe cộng đồng và phát triển bền vững. Nồng độ bụi mịn (PM2.5, PM10), khí NO₂, SO₂, CO và O₃ gia tăng do giao thông dày đặc, công nghiệp, và biến đổi khí hậu. Các thành phố lớn thường phải đối mặt với tình trạng mù khói, gây ra hàng triệu ca tử vong sớm mỗi năm và thiệt hại kinh tế khổng lồ.

Để giảm thiểu tác động, cần hệ thống giám sát liên tục, dự báo chính xác và phản ứng nhanh. Trí tuệ nhân tạo (AI) đóng vai trò trung tâm, cho phép phân tích dữ liệu môi trường khổng lồ, dự đoán mức ô nhiễm, và đề xuất biện pháp điều tiết giao thông, công nghiệp một cách kịp thời.

# Đánh giá tổng quan về tình hình ô nhiễm không khí

Trong những năm gần đây, tình trạng ô nhiễm không khí tại Việt Nam có xu hướng gia tăng rõ rệt, đặc biệt tại các đô thị lớn và khu vực phát triển công nghiệp. Ô nhiễm bụi - đặc biệt là bụi mịn PM2.5 được ghi nhận là thành phần ô nhiễm chính, với nồng độ trung bình năm tại nhiều khu vực thường xuyên vượt giới hạn cho phép theo Quy chuẩn kỹ thuật quốc gia QCVN 05:2023/BTNMT. Điều này đặt ra những thách thức lớn đối với công tác quản lý môi trường không khí, nhất là trong bối cảnh phát triển kinh tế nhanh, mật độ dân số đô thị cao và hạ tầng chưa đồng bộ.

Dữ liệu quan trắc tự động, liên tục từ năm 2021 đến 2024 cho thấy, các trạm tại Hà Nội ghi nhận giá trị PM2.5 trung bình năm vượt từ 1,1 đến 2,1 lần giới hạn cho phép. Các đô thị lân cận như Bắc Ninh, Bắc Giang, Hà Nam, Hưng Yên, Hải Dương, Thái Nguyên và Thái Bình cũng có mức vượt từ 1,1 đến 2,0 lần. Trong khi đó, các đô thị miền Trung và Tây Nguyên nhìn chung vẫn đạt tiêu chuẩn, mặc dù một số ngày trong năm vẫn ghi nhận giá trị PM2.5 vượt ngưỡng trung bình 24 giờ. Tại TP. Hồ Chí Minh, năm 2024 cho thấy, giá trị trung bình năm đạt ngưỡng cho phép, nhưng trong giai đoạn 2021-2023, nồng độ tại trạm Lãnh sự quán Hoa Kỳ vẫn vượt khoảng 1,1 lần.

Tỷ lệ số ngày có nồng độ PM2.5 vượt giới hạn tại các đô thị miền Bắc cao hơn rõ rệt so với các khu vực miền Trung và miền Nam. Năm 2024, trạm 556 Nguyễn Văn Cừ (Hà Nội) ghi nhận 33,04% số ngày vượt chuẩn; các trạm Hùng Vương (Thái Nguyên), Phủ Lý (Hà Nam), Nguyễn Văn Linh (Hưng Yên) và một số trạm khác ghi nhận tỷ lệ dao động từ 18% đến 36%.

Ô nhiễm không khí có tính chu kỳ rõ rệt theo mùa. Tại miền Bắc, mức độ ô nhiễm tăng cao vào mùa đông và đầu xuân (từ tháng 10 đến tháng 3 năm sau), khi điều kiện khí tượng bất lợi như nghịch nhiệt xuất hiện thường xuyên, làm hạn chế khả năng khuếch tán các chất ô nhiễm. Tại miền Nam, ô nhiễm giảm mạnh trong mùa mưa và tăng trở lại vào mùa khô, trong khi tại miền Trung, sự dao động theo mùa ít rõ rệt hơn.

Về các thông số ô nhiễm khác, hầu hết giá trị trung bình năm của NO₂, SO₂ và trung bình 1 giờ của CO đều nằm trong giới hạn cho phép. Tuy nhiên, một số trạm ghi nhận giá trị O₃ trung bình 1 giờ vượt chuẩn, đặc biệt vào các thời điểm trưa nắng, phản ánh tác động của các phản ứng quang hóa trong điều kiện đô thị hóa cao.

# Hệ thống cảm biến và dữ liệu

  * Mạng lưới cảm biến IoT: Hàng nghìn cảm biến cố định và di động đặt trên cột đèn, phương tiện công cộng, tòa nhà.

  * Dữ liệu vệ tinh: Ảnh quang học và hồng ngoại từ các vệ tinh như Sentinel-5P, MODIS, cung cấp thông tin toàn thành phố và vùng lân cận.

  * Nguồn dữ liệu phụ trợ: Dữ liệu giao thông, thời tiết, hoạt động công nghiệp, dân số, và bản đồ địa hình.

  * Tích hợp đa tầng: AI kết hợp dữ liệu cảm biến mặt đất với dữ liệu vệ tinh và dự báo khí tượng để tạo bức tranh chất lượng không khí toàn diện.


# Vai trò của AI trong giám sát và dự báo

  * Dự báo ngắn và dài hạn:

* Mô hình học sâu (LSTM, Transformer) dự đoán nồng độ PM2.5, O₃ trong vài giờ hoặc vài ngày tới.

* Dự báo theo mùa, phát hiện xu hướng dài hạn liên quan đến biến đổi khí hậu.

  * Phát hiện bất thường:

* AI nhanh chóng xác định sự cố như cháy rừng, rò rỉ hóa chất, hoặc sự kiện giao thông đặc biệt.

* Cảnh báo tự động cho chính quyền và người dân.

  * Phân tích nguyên nhân và tối ưu chính sách:

* Mô hình học máy tìm mối liên hệ giữa nguồn phát thải và điều kiện khí tượng.

* Đề xuất giải pháp như hạn chế xe cá nhân, điều chỉnh giờ sản xuất công nghiệp.

  * Tối ưu hóa giao thông và năng lượng:

* AI điều khiển đèn tín hiệu, định tuyến giao thông để giảm ùn tắc và phát thải.

* Dự báo nhu cầu năng lượng, khuyến khích sử dụng điện từ nguồn tái tạo khi mức ô nhiễm cao.


# Ứng dụng thực tế

  * Bắc Kinh và Thượng Hải: AI dự báo ô nhiễm 72 giờ, hỗ trợ chính quyền đưa ra lệnh hạn chế phương tiện.

  * London: Hệ thống CityAir kết hợp cảm biến di động và AI để thông báo chất lượng không khí theo từng khu phố.

  * Los Angeles: AI phân tích dữ liệu giao thông và thời tiết, tối ưu hóa đèn tín hiệu nhằm giảm phát thải CO₂.


# Lợi ích

  * Bảo vệ sức khỏe cộng đồng: Cảnh báo sớm giúp người dân hạn chế hoạt động ngoài trời, giảm nguy cơ bệnh hô hấp.

  * Hỗ trợ hoạch định chính sách: Cung cấp dữ liệu đáng tin cậy cho chính phủ và các tổ chức môi trường.

  * Giảm chi phí y tế: Giảm gánh nặng bệnh tật liên quan đến ô nhiễm.

  * Tăng tính minh bạch: Người dân tiếp cận thông tin chất lượng không khí thời gian thực qua ứng dụng.


# Thách thức

  * Độ chính xác dữ liệu: Cảm biến giá rẻ có thể bị sai lệch, cần AI hiệu chỉnh liên tục.

  * Bảo mật và quyền riêng tư: Dữ liệu di động và vị trí người dân cần được bảo vệ.

  * Tính bền vững: Hệ thống cảm biến và máy chủ phải hoạt động liên tục, tiêu thụ năng lượng lớn.

  * Tích hợp đa ngành: Cần phối hợp giữa giao thông, công nghiệp, y tế, và chính quyền đô thị.


# Xu hướng tương lai

  * Digital Twin cho thành phố: Tạo bản sao ảo của đô thị để mô phỏng và thử nghiệm chính sách trước khi áp dụng thực tế.

  * AI tự thích nghi: Mô hình tự học liên tục từ dữ liệu mới để duy trì độ chính xác cao.

  * Kết hợp Blockchain: Đảm bảo tính toàn vẹn và minh bạch cho dữ liệu không khí công cộng.

  * Ứng dụng di động cá nhân hóa: AI cung cấp khuyến nghị sức khỏe cụ thể cho từng người dựa trên vị trí và tình trạng y tế.

# Public088

Tế bào gốc trong cơ thể người xử lý thông tin di truyền với độ tin cậy và tốc độ vượt trội. Để làm được điều này, chúng tiếp cận các đoạn DNA cụ thể trong nhân tế bào. Các nhà nghiên cứu tại Viện Công nghệ Karlsruhe (KIT) đã nghiên cứu cách thức hoạt động của quá trình xử lý thông tin dựa trên DNA. Kết quả của họ cho thấy quá trình này tương đương với các quy trình trong máy tính hiện đại và do đó có thể được dùng làm mô hình cho các chip máy tính mới dựa trên DNA. Bài báo được công bố trên Biên niên sử của Viện Hàn lâm Khoa học New York. (DOI: 10.1111/nyas.15415)

Tế bào người chứa khoảng 20.000 gen trên một chuỗi DNA dài hai mét - được cuộn chặt trong một nhân tế bào có kích thước khoảng mười micromet. Để so sánh, kích thước này tương đương với một sợi chỉ dài 40 km được nhét vào một quả bóng đá. Bất chấp không gian hạn chế này, tế bào gốc vẫn có thể tìm và kích hoạt đúng gen chỉ trong vài phút. Những gen này khác nhau tùy theo từng tế bào. Việc kích hoạt chính xác là rất quan trọng, vì sai sót trong việc lựa chọn gen có thể dẫn đến bệnh tật hoặc chết tế bào.

Các nghiên cứu của các nhà nghiên cứu KIT đã chỉ ra rằng ngưng tụ sinh học phân tử cho phép kích hoạt nhanh chóng nhưng đáng tin cậy các gen chính xác. "Ngưng tụ sinh học phân tử là những giọt nhỏ hình thành tại các vị trí cụ thể trên DNA – tương tự như những giọt nước đọng trên gương phòng tắm sau khi tắm nước nóng – và hoạt động giống như dầu trong nước", Giáo sư Lennart Hilbert từ Viện Hệ thống Sinh học và Hóa học KIT (IBCS) giải thích. "Chúng chứa các cỗ máy phân tử, tức là một tập hợp các phân tử cụ thể cần thiết cho việc kích hoạt gen." Quá trình này gợi nhớ đến một nguyên lý cốt lõi của khoa học máy tính làm nền tảng cho máy tính và điện thoại thông minh hiện đại: kiến ​​trúc Von Neumann. Trong kiến ​​trúc này, một bộ xử lý duy nhất có thể truy cập rất nhanh vào một địa chỉ duy nhất trong bộ nhớ lớn, thường được gọi là RAM. Các nhà nghiên cứu hiện muốn chuyển giao nguyên lý này sang các chip máy tính nhân tạo dựa trên DNA để có thể kiểm soát, ví dụ, các ứng dụng công nghệ sinh học và y sinh.

# Giới thiệu

Trong nhiều thập kỷ, ngành công nghệ thông tin phụ thuộc vào **silicon** và định luật Moore. Tuy nhiên, khi kích thước transistor chạm tới giới hạn vật lý, các nhà khoa học tìm đến những phương pháp tính toán hoàn toàn mới. **Máy tính sinh học dựa trên DNA** nổi lên như một bước ngoặt, khai thác khả năng lưu trữ và xử lý thông tin tự nhiên của phân tử sinh học.

DNA – với khả năng lưu trữ dữ liệu cực lớn và tự nhân bản – mở ra viễn cảnh các “máy tính sống” hoạt động bên trong tế bào, thực hiện tính toán, ra quyết định và thậm chí tự sửa chữa. Đây là nền tảng cho y học cá nhân hóa, công nghệ gene và các hệ thống thông minh có thể hoạt động ngay bên trong cơ thể con người.

# Máy tính sinh học: Định nghĩa và ý nghĩa

Máy tính sinh học (hay còn gọi là máy tính hữu cơ) là một lĩnh vực nghiên cứu đang phát triển, tập trung vào việc sử dụng các thành phần sinh học, như tế bào, protein, DNA để tạo ra các hệ thống tính toán. Nói một cách đơn giản, thay vì dựa vào các linh kiện điện tử như silicon, máy tính sinh học sử dụng các vật liệu và cơ chế của thế giới tự nhiên.

# Ưu điểm vượt trội của máy tính sinh học

So với máy tính truyền thống, máy tính sinh học sở hữu nhiều lợi thế độc đáo:

  * **Hiệu năng vượt trội:** Các tế bào thần kinh có thể hoạt động với tốc độ và hiệu quả cao hơn nhiều so với các vi mạch silicon. Điều này hứa hẹn tạo ra những máy tính với khả năng xử lý thông tin nhanh hơn, tiết kiệm năng lượng hơn.

  * **Khả năng tự sửa chữa:** Tế bào sống có khả năng tự tái tạo và sửa chữa các hư hỏng. Điều này giúp máy tính sinh học trở nên bền bỉ hơn, ít bị lỗi hỏng hơn so với máy tính truyền thống.

  * **Linh hoạt và thích nghi:** Máy tính sinh học có thể được thiết kế để thích nghi với các môi trường khắc nghiệt và biến đổi, điều mà các máy tính silicon khó có thể làm được.


# Nguyên lý cơ bản

  * **Đại diện dữ liệu:** Chuỗi nucleotide A, T, C, G của DNA đóng vai trò như “bit” sinh học, mỗi cặp base có thể mã hóa thông tin nhị phân.

  * **Xử lý thông tin:** Phản ứng hóa học như lai ghép (hybridization), tách chuỗi, hoặc enzyme cắt DNA đóng vai trò như các cổng logic (AND, OR, NOT).

  * **Tính toán song song tự nhiên:** Hàng tỷ phân tử DNA trong một ống nghiệm có thể thực hiện hàng tỷ phép tính đồng thời – khả năng song song vượt xa máy tính truyền thống.

  * **Tự nhân bản và sửa lỗi:** Khả năng sao chép của DNA cho phép nhân rộng dữ liệu và tự sửa chữa, nâng cao độ bền.


# Ưu thế nổi bật

  * **Mật độ lưu trữ khổng lồ:** 1 gram DNA có thể lưu trữ khoảng 215 petabyte dữ liệu – gấp hàng triệu lần ổ cứng hiện nay.

  * **Tiêu thụ năng lượng thấp:** Phản ứng hóa sinh tiêu tốn ít năng lượng hơn nhiều so với siêu máy tính.

  * **Độ bền vượt thời gian:** DNA có thể tồn tại hàng nghìn năm nếu bảo quản đúng điều kiện.

  * **Tính chất sinh học tự nhiên:** Có thể tương tác trực tiếp với môi trường sinh học, đặc biệt phù hợp cho ứng dụng y học.


# Ứng dụng trong y sinh học

  * **Chẩn đoán bệnh tại chỗ:** Máy tính DNA bên trong tế bào có thể phát hiện dấu hiệu bệnh (ví dụ: nồng độ protein, RNA đặc hiệu) và phát tín hiệu cảnh báo sớm.

  * **Điều trị chính xác:** Khi phát hiện tế bào ung thư, hệ thống DNA có thể giải phóng thuốc hoặc kích hoạt cơ chế tự hủy của tế bào bệnh.

  * **Theo dõi liên tục:** Các “sensor sinh học” chạy bằng DNA có thể giám sát nồng độ đường, hormone, hoặc chỉ số miễn dịch theo thời gian thực.

  * **Lưu trữ hồ sơ y tế:** DNA nhân tạo có thể lưu trữ lịch sử điều trị, xét nghiệm, và thông tin gen của bệnh nhân ngay trong cơ thể.


# Các thành tựu nghiên cứu nổi bật

  * **DNA Storage của Microsoft & University of Washington:** Lưu trữ dữ liệu số vào DNA nhân tạo và giải mã lại với độ chính xác cao.

  * **Máy tính DNA của Caltech:** Sử dụng phản ứng enzyme để giải bài toán logic phức tạp trong ống nghiệm.

  * **DNA Origami Nanorobot:** Robot nano bằng DNA có thể vận chuyển thuốc và mở ra khi gặp tín hiệu phân tử đặc hiệu.


# Thách thức triển khai

  * **Tốc độ tính toán:** Dù xử lý song song mạnh mẽ, thời gian phản ứng hóa học vẫn chậm so với điện tử học tốc độ cao.

  * **Độ chính xác và sai số:** Lỗi lai ghép hoặc đột biến có thể gây sai kết quả.

  * **Chi phí tổng hợp DNA:** Dù giảm nhanh, hiện vẫn cao cho ứng dụng quy mô lớn.

  * **An toàn sinh học:** Cần kiểm soát nghiêm ngặt để tránh rủi ro sinh học và lây nhiễm.

  * **Chuẩn hóa và tích hợp:** Chưa có chuẩn chung để kết nối máy tính DNA với hệ thống điện tử truyền thống.


# Tương lai và xu hướng

  * **Hybrid Bio-Electronic Systems:** Kết hợp vi mạch silicon với DNA để tận dụng cả tốc độ điện tử và mật độ lưu trữ sinh học.

  * **Y học cá nhân hóa:** Máy tính DNA hoạt động trong cơ thể để phát hiện và điều trị bệnh theo thời gian thực, giảm nhu cầu nhập viện.

  * **Tính toán lượng tử sinh học:** Nghiên cứu sự giao thoa giữa cơ học lượng tử và phản ứng sinh học để tăng tốc tính toán.

  * **Sản xuất quy mô lớn:** Công nghệ tổng hợp DNA tự động và giá rẻ sẽ đưa biocomputing vào các ứng dụng công nghiệp và thương mại.

# Public089

# Giới thiệu

Siêu dẫn là hiện tượng khi một vật liệu dẫn điện **không có điện trở** , nghĩa là dòng điện có thể chạy mãi mãi mà không mất năng lượng. Trong nhiều thập kỷ, các vật liệu siêu dẫn chỉ hoạt động ở nhiệt độ cực thấp (gần 0 K), đòi hỏi làm lạnh bằng heli lỏng đắt đỏ.

Tuy nhiên, những nghiên cứu gần đây đã cho thấy khả năng xuất hiện của **vật liệu siêu dẫn ở nhiệt độ phòng** , mở ra kỷ nguyên truyền tải điện **không tổn thất** , tăng hiệu suất cho lưới điện toàn cầu và cách mạng hóa các ngành công nghiệp từ y tế, năng lượng đến máy tính lượng tử.

# Vật liệu siêu dẫn là gì?

Siêu dẫn là một hiện tượng xảy ra khi vật thể ở nhiệt độ đủ thấp và từ trường đủ nhỏ. Lúc này mức điện trở của vật dẫn trở về bằng 0, khiến nội từ trường bị suy giảm theo hiệu ứng Meissner. 

Trong vật lý, để tạo ra hiện tượng siêu dẫn, người ta sẽ tạo ra một lực hút giữa các electron truyền dẫn. Từ đó làm sản sinh việc trao đổi phonon tạo ra từ cặp electron tương quan. 

Ngoài ra còn tồn tại một vật chất siêu dẫn có tính dẫn nhiệt cao hơn lý thuyết và thấp hơn so với nhiệt độ thường trong phòng. Tuy nhiên những nghiên cứu về chất siêu dẫn nhiệt độ cao vẫn chưa hoàn chỉnh.

# Lịch sử hình thành vật liệu siêu dẫn:

Năm 1911, trong một lần thực hiện thí nghiệm với thủy ngân, nhà vật lý Hà Lan – Maoneis đã vô tình phát hiện ra khi ở nhiệt độ -269°C, thuỷ ngân sẽ có điện trở bằng không. Lúc này ông gọi đó là tính siêu dẫn. 

Việc tìm ra được một hiện tượng mới lạ này đã mở ra các khám phá quan trọng trong ngành khoa học kỹ thuật. Các nhà khoa học bắt đầu sử dụng chất siêu dẫn để chế tạo ra các vật chất có từ tính mạnh. Với mục đích phục vụ cho các lĩnh vực khoa học kỹ thuật và sản xuất khác nhau trong đời sống. Tuy nhiên, “đời không như là mơ”, việc ứng dụng tính siêu dẫn lên các kim loại thuần khiết như chì, thiếc… lại cho từ trường rất nhỏ.

Đến những năm 30 của thế kỷ XX, sau nhiều năm nghiên cứu không ngừng, các nhà khoa học đã tìm ra được một loại nguyên tố mới nếu cho vào các kim loại thuần khiết sẽ tạo được một loại hợp kim mà ở đó cường độ dòng điện và cường độ từ trường được tăng lên nhiều.

Giai đoạn năm 1930, các nhà khoa học Liên Xô bắt tay vào chế tạo hợp kim siêu dẫn có giới hạn từ trường đạt 2 tesla. Hai hợp kim siêu dẫn này gọi là hợp kim niobi – ziriconi, và hợp kim vanđi – gali.

Ngoài ra, còn có một số oxit kim loại kiểu cấu trúc A – 15. Ưu điểm của các vật chất siêu dẫn ở giai đoạn này chính là không có điện trở, nhờ đó vừa có thể làm giảm tĩnh điện, không gây ra những tổn thất nhiệt, vừa có thể tích nhỏ và công suất lớn.

Tiếp đến là giai đoạn những năm 60 của thế kỷ XX, các nhà khoa học đã nghiên cứu và chế tạo được loại vật liệu siêu dẫn có từ trường đạt đến 10 tesla. Từ đó được ứng dụng rộng trong các lĩnh vực đòi hỏi công nghệ kỹ thuật cao như cộng hưởng từ hạt nhân, máy gia tốc, buồng bọt, máy phát điện… Thế nhưng một nhược điểm của vật liệu siêu dẫn chính là chỉ hoạt động hiệu quả ở điều kiện nhiệt độ rất thấp. Điều này khiến các kỹ sư đối mặt với nhiều thách thức như tốn nhiều chi phí để tạo nên môi trường có nhiệt độ.

Giai đoạn năm 1957, các nhà khoa học đưa ra lý thuyết BCS nhằm giải thích hiện tượng siêu dẫn. Theo đó, lý thuyết BCS cho rằng lý do dẫn đến hiện tượng siêu dẫn là do ở môi trường nhiệt độ cực thấp, các điện tử tự do trong chất siêu dẫn sẽ sắp xếp nối tiếp nhau tạo thành chuỗi dài. Lúc này, các điện tử sẽ chuyển động định hướng bên trong khiến chất siêu dẫn không còn lực trở của dòng điện tử, từ đó hình thành nên dòng điện không có trở lực.

Giai đoạn năm 1986, hai kỹ sư Muler và Bainos của công ty IBM Mỹ và Thụy Điển đã khám phá ra được oxit các kim loại lantan – bari – đồng có đặc tính siêu dẫn ở nhiệt độ tương đối cao ngay cả trong điều kiện phòng thí nghiệm. Chính những nghiên cứu này đã nhen nhóm một tia hy vọng về tương lai của việc ứng dụng vật liệu siêu dẫn trong sản xuất và đời sống.

Đến nay, có không ít các nhà khoa học ở nhiều nước triển khai nghiên cứu cách nâng cao giới hạn nhiệt độ siêu dẫn. Tiêu biểu trong số đó là nhà khoa học quốc tịch Mỹ gốc Hoa – Chu Kinh Hoà và nhà khoa học Trung Quốc – Triệu Trung Hiền.

# Nguyên lý siêu dẫn

  * **Điện trở bằng 0:** Khi vật liệu đạt trạng thái siêu dẫn, các electron ghép cặp thành **cặp Cooper** , di chuyển mà không va chạm.

  * **Hiệu ứng Meissner:** Vật liệu siêu dẫn đẩy từ trường ra ngoài, tạo hiện tượng “nổi” nam châm – nền tảng cho tàu đệm từ.

  * **Chuyển pha lượng tử:** Khi nhiệt độ, áp suất hoặc thành phần hóa học đạt điều kiện thích hợp, vật liệu chuyển từ trạng thái bình thường sang siêu dẫn.


# Tiến bộ mới trong vật liệu siêu dẫn nhiệt độ phòng

  * **Hydride giàu hydro:** Hợp chất lưu huỳnh-hydro hoặc carbon-hydro được nén ở áp suất hàng triệu atm đã cho thấy siêu dẫn ở ~15 °C.

  * **Siêu dẫn áp suất thấp:** Nghiên cứu mới hướng tới vật liệu hoạt động ở điều kiện gần áp suất khí quyển, giúp ứng dụng thực tế.

  * **Kết hợp với công nghệ tính toán AI:** Mô hình học sâu dự đoán cấu trúc tinh thể và tính chất điện tử, rút ngắn thời gian khám phá.


# Ứng dụng trong truyền tải điện

  * **Lưới điện không tổn thất:** Dây dẫn siêu dẫn truyền tải điện hàng nghìn km mà không mất mát, giảm lãng phí hàng tỷ USD mỗi năm.

  * **Trạm biến áp và máy phát:** Thiết bị nhỏ gọn, hiệu suất cao, giảm chi phí bảo trì.

  * **Lưu trữ năng lượng từ gió, mặt trời:** Vật liệu siêu dẫn hỗ trợ pin từ trường siêu dẫn (SMES), cho phép nạp/xả cực nhanh.


# Ứng dụng ngoài truyền tải điện

  * **Tàu đệm từ (Maglev):** Tốc độ trên 600 km/h, vận hành êm ái và tiết kiệm năng lượng.

  * **Máy cộng hưởng từ MRI:** Giảm chi phí vận hành khi không cần helium lỏng.

  * **Máy tính lượng tử:** Siêu dẫn nhiệt độ phòng giúp qubit ổn định hơn, giảm yêu cầu làm lạnh phức tạp.

  * **Động cơ điện công suất cao:** Cho hàng không, tàu thủy, giảm trọng lượng và nâng hiệu suất.


# Thách thức triển khai

  * **Ổn định vật liệu:** Giữ tính siêu dẫn ở điều kiện môi trường bình thường vẫn là bài toán khó.

  * **Sản xuất hàng loạt:** Quy trình chế tạo cần kiểm soát cấu trúc tinh thể và tạp chất ở mức nguyên tử.

  * **Chi phí đầu tư ban đầu:** Dù vận hành tiết kiệm, giai đoạn chuyển đổi hạ tầng đòi hỏi vốn lớn.

  * **Chuẩn hóa an toàn:** Vật liệu mới cần được kiểm chứng lâu dài trước khi đưa vào lưới điện quốc gia.


# Tác động kinh tế – xã hội

  * **Cách mạng năng lượng:** Giảm thất thoát truyền tải từ mức 8–10% hiện nay xuống gần 0%, tiết kiệm hàng trăm tỷ USD.

  * **Giảm phát thải carbon:** Hiệu suất cao đồng nghĩa với ít năng lượng hóa thạch hơn.

  * **Khuyến khích năng lượng tái tạo:** Truyền tải xa giúp điện gió, điện mặt trời từ vùng hẻo lánh đến đô thị dễ dàng.

  * **Tạo ngành công nghiệp mới:** Từ thiết bị y tế, giao thông, đến máy tính siêu hiệu năng.


# Xu hướng tương lai

  * **Khám phá vật liệu bằng AI:** Học sâu và tính toán lượng tử hỗ trợ tìm kiếm hợp chất siêu dẫn áp suất thấp.

  * **Kết hợp nano và 2D materials:** Graphene và các vật liệu lớp hứa hẹn tính siêu dẫn độc đáo.

  * **Hạ tầng lưới điện thế hệ mới:** Chuẩn hóa toàn cầu để tích hợp dây dẫn siêu dẫn vào mạng lưới hiện tại.

  * **Ứng dụng dân dụng:** Thiết bị gia dụng tiết kiệm điện, phương tiện cá nhân siêu hiệu quả.

# Public090

“Cách tốt nhất để dự đoán tương lai là tạo ra nó.” – Peter Drucker, nhà tư vấn quản lý và tác giả nổi tiếng.

Chúng ta đang chứng kiến ​​một sự thay đổi lớn trong lĩnh vực điện toán, hướng tới một phương pháp mới sao chép cách thức hoạt động của bộ não chúng ta. Lĩnh vực này, [tính toán neuromorphic](https://www.editverse.com/vi/t%C6%B0%C6%A1ng-lai-c%E1%BB%A7a-ai-trong-ch%E1%BA%A9n-%C4%91o%C3%A1n-y-t%E1%BA%BF-m%C3%A1y-m%C3%B3c-s%E1%BA%BD-thay-th%E1%BA%BF-b%C3%A1c-s%C4%A9/), có thể thay đổi cách chúng ta giải quyết các vấn đề phức tạp và sử dụng trí tuệ nhân tạo (AI).

Nó được lấy cảm hứng từ cấu trúc của bộ não và cách nó hoạt động. **Điện toán hình thần kinh** muốn tạo ra các mạch và hệ thống điện tử tốt hơn trong những việc như nhìn, đưa ra quyết định và học tập. Bằng cách sử dụng cách xử lý thông tin hiệu quả của bộ não, chúng ta có thể làm cho máy tính sử dụng ít năng lượng hơn và hoạt động tốt hơn trong nhiều nhiệm vụ.

# Giới thiệu

Trong khi máy tính truyền thống dựa trên kiến trúc Von Neumann (phân tách bộ xử lý và bộ nhớ), bộ não con người xử lý thông tin một cách song song, phân tán và cực kỳ tiết kiệm năng lượng. Máy tính neuromorphic được thiết kế để bắt chước cơ chế này, tạo ra các chip mô phỏng neuron và synapse sinh học, mở đường cho trí tuệ nhân tạo (AI) có khả năng học, suy nghĩ và thích nghi giống như não người nhưng tiêu thụ năng lượng chỉ bằng một phần nhỏ của siêu máy tính hiện đại.

# Điện toán mô phỏng thần kinh là gì?

Điện toán mô phỏng thần kinh là một lĩnh vực kết hợp sinh học, vật lý, toán học, khoa học máy tính và kỹ thuật. Nó nhằm mục đích tạo ra các hệ thống thần kinh nhân tạo hoạt động giống như bộ não con người. [Kỹ thuật cấu trúc thần kinh](https://www.techtarget.com/searchenterpriseai/definition/neuromorphic-computing) xem xét cấu trúc và chức năng của não có thể giúp tạo ra các hệ thống máy tính tốt hơn như thế nào.

# Định nghĩa và nguồn cảm hứng từ bộ não con người

Bộ não con người cực kỳ phức tạp, với hàng tỷ tế bào thần kinh và hàng nghìn tỷ kết nối. _Điện toán hình thần kinh_ cố gắng bắt chước cách xử lý thông tin của não. Nó tập trung vào cách các tế bào thần kinh làm việc cùng nhau và sử dụng [Mạng lưới thần kinh tăng đột biến](https://www.editverse.com/vi/tr%C3%AD-tu%E1%BB%87-nh%C3%A2n-t%E1%BA%A1o-v%C3%A0-h%E1%BB%8Dc-m%C3%A1y-c%C3%A1ch-m%E1%BA%A1ng-h%C3%B3a-s%E1%BB%B1-th%E1%BA%ADt-v%C3%A0-huy%E1%BB%81n-tho%E1%BA%A1i-v%E1%BB%81-ch%E1%BA%A9n-%C4%91o%C3%A1n-y-t%E1%BA%BF/) để xử lý các nhiệm vụ dựa trên thời gian.

  1. Các khía cạnh chính của kỹ thuật thần kinh


  * Mô phỏng tính chất tương tự của tính toán sinh học

  * Hiểu vai trò của tế bào thần kinh trong nhận thức

  * Bằng cách sử dụng **Mạng lưới thần kinh tăng đột biến** cho **tính toán thời gian**

  * Thiết kế _Kiến trúc lấy cảm hứng từ não_ cho hiệu quả và mạnh mẽ _Máy tính nhận thức_

  * Tận dụng _Mạng lưới thần kinh nhân tạo_ để tạo ra _Kỹ thuật thần kinh_ hệ thống


Hệ thống thần kinh được tạo ra để hoạt động giống như tế bào thần kinh và khớp thần kinh trong não. Điều này có thể làm cho chúng hoạt động hiệu quả hơn, dễ thích ứng hơn và có thể xử lý lỗi tốt hơn máy tính truyền thống.


| đặc tính | Điện toán thần kinh | Máy tính truyền thống |
| --- | --- | --- |
| Công suất tiêu thụ | Hiệu quả năng lượng cao, hoạt động chỉ bằng một phần năng lượng mà
các hệ thống truyền thống yêu cầu | Tốn nhiều năng lượng, với siêu máy tính nhanh nhất thế giới cần 21
triệu watt điện |
| Phương pháp tiếp cận xử lý | Tiến trình song song, với các nơ-ron và khớp thần
kinh xử lý đồng thời cả bộ nhớ và tính toán | Xử lý tuần tự, với kiến ​​trúc von Neumann tách biệt bộ nhớ và
CPU |
| Phản hồi thời gian thực | Có khả năng phản hồi “tức thời”, lý tưởng cho việc xử lý dữ liệu cảm
biến thời gian thực và các ứng dụng IoT | Thời gian phản hồi chậm hơn do chu kỳ liên tục giữa bộ xử lý và bộ
nhớ |
| Pattern Recognition | Vượt trội trong việc nhận dạng mẫu nhờxử lý song song ồ
ạtkhả năng | Khả năng nhận dạng mẫu hạn chế so với các hệ thống hình thái thần
kinh |

 

Bất chấp những thách thức như độ chính xác, hạn chế về phần mềm và các vấn đề về truy cập, _Điện toán thần kinh_ đang được khám phá cho nhiều mục đích sử dụng. Chúng bao gồm AI, hệ thống tự trị, chất bán dẫn mới và học sâu.

_“Câu hỏi về hiệu quả sử dụng năng lượng được cho là chìa khóa để giải mã những bí mật của bộ não và hiểu được cách nó đạt được mức độ hoạt động cao như vậy với mức tiêu thụ năng lượng tối thiểu.”_

# Sức mạnh siêu máy tính của bộ não

Bộ não con người là một kỳ quan thiên nhiên kỳ thú, hoạt động như một siêu máy tính. Nó chỉ sử dụng công suất 20 watt nhưng có thể thực hiện những nhiệm vụ đáng kinh ngạc. Những nhiệm vụ này bao gồm xử lý thông tin, nhận thức thế giới và đưa ra quyết định. Điều này hiệu quả hơn nhiều so với các siêu máy tính nhanh nhất thế giới vốn cần 21 triệu watt.

Các nhà khoa học rất quan tâm đến cách thức hoạt động của bộ não. Họ nghiên cứu các phương pháp tính toán của nó để cải thiện các thuật toán và máy tính trong tương lai. Bằng cách xem xét cách bộ não sử dụng [tiến trình song song](https://www.bbc.com/news/articles/cx99qv2w1ddo), _tính toán thời gian_ , và là _tiết kiệm năng lượng_ , họ hy vọng sẽ đạt được những tiến bộ lớn trong _Bộ não như siêu máy tính_.


| Máy tính thần kinh | HIỆU QUẢ | Công suất tiêu thụ |
| --- | --- | --- |
| Điểm Hala | 380 nghìn tỷ hoạt động khớp thần kinh mỗi giây | Tiết kiệm năng lượng gấp 100 lần so với máy thông thường |
| DeepSouth | 228 nghìn tỷ hoạt động khớp thần kinh mỗi giây | Chỉ chiếm sáu giá đỡ trong một thùng máy chủ tiêu chuẩn |
| Biên giới doanh nghiệp Hewlett Packard | Hơn một triệu tỷ phép tính mỗi giây | Có diện tích 680 mét vuông và cần 22.7 megawatt để chạy |

 

_Bộ não như siêu máy tính_ tiết kiệm năng lượng hơn nhiều so với các siêu máy tính cũ. Điều này cho thấy tiềm năng to lớn của điện toán mô phỏng thần kinh. Khi các nhà nghiên cứu tiếp tục cải tiến công nghệ này, chúng ta có thể mong đợi một tương lai nơi máy tính và AI hoạt động hiệu quả và mạnh mẽ hơn, lấy cảm hứng từ bộ não con người.

# Nguyên lý hoạt động

  * Neuron nhân tạo phần cứng: Các mạch điện mô phỏng điện thế màng, xung điện và quá trình kích hoạt của neuron sinh học.

  * Synapse điện tử: Dùng memristor hoặc các vật liệu có thể thay đổi điện trở để ghi nhớ trọng số kết nối – tương tự synapse thật.

  * Xử lý song song và sự kiện (event-driven): Dữ liệu được truyền khi có xung điện, giảm lãng phí năng lượng so với đồng hồ xung liên tục.

  * Tự học trong phần cứng: Học Hebbian và Spike-Timing Dependent Plasticity (STDP) cho phép chip tự điều chỉnh trọng số như não.


# Ưu thế vượt trội

  * Hiệu quả năng lượng cao: Tiêu thụ vài mW cho hàng triệu neuron, lý tưởng cho thiết bị di động hoặc cảm biến IoT.

  * Độ trễ thấp: Xử lý trực tiếp trong phần cứng, loại bỏ bottleneck giữa bộ nhớ và CPU.

  * Khả năng học trực tuyến: Thích nghi với dữ liệu mới mà không cần huấn luyện lại toàn bộ mạng.

  * Tích hợp cảm biến: Có thể đặt trực tiếp vào camera, robot, thiết bị y tế.


# Ứng dụng thực tế

  * Robot tự hành: Phản ứng nhanh với môi trường, nhận diện đối tượng và điều hướng với mức tiêu thụ điện cực thấp.

  * Thiết bị IoT thông minh: Cảm biến môi trường, thiết bị đeo sức khỏe hoạt động hàng tháng chỉ bằng pin nhỏ.

  * Thị giác máy tính thời gian thực: Nhận diện hình ảnh và âm thanh nhanh, hỗ trợ xe tự hành hoặc drone.

  * Y tế và cấy ghép thần kinh: Chip neuromorphic giao tiếp trực tiếp với hệ thần kinh, hỗ trợ phục hồi chức năng vận động.


# Công nghệ nền tảng

  * Memristor: Phần tử mạch điện có khả năng nhớ điện trở, lưu trữ trọng số synapse bền bỉ.

  * Vật liệu 2D: Graphene và oxide kim loại cho tốc độ và độ bền cao.

  * Hệ thống lập trình sự kiện: Ngôn ngữ và framework tối ưu cho mạng spiking neural network (SNN).

  * Chip tiên phong: Intel Loihi, IBM TrueNorth, BrainScaleS của châu Âu.


# Thách thức

  * Chuẩn hóa phần mềm: Cần công cụ lập trình và thuật toán tối ưu cho mạng neuron dạng spiking.

  * Sản xuất hàng loạt: Công nghệ memristor và vật liệu mới chưa phổ biến ở quy mô công nghiệp.

  * Khả năng mở rộng: Cần duy trì tính ổn định khi số lượng neuron đạt hàng tỷ.

  * Hệ sinh thái ứng dụng: Phải phát triển phần mềm, hệ điều hành và công cụ hỗ trợ tương thích.


# Tác động tương lai

  * AI tiết kiệm năng lượng: Tạo điều kiện cho hàng tỷ thiết bị AI biên hoạt động bền vững, không cần đám mây.

  * Điện toán giống não người: Mở đường cho các hệ thống nhận thức, suy luận gần với con người.

  * Kết hợp với học tự giám sát: Giúp chip học từ dòng dữ liệu liên tục mà không cần gắn nhãn.

  * Tích hợp trong y sinh: Thiết bị cấy ghép thần kinh và giao diện não–máy (BCI) trở nên khả thi và an toàn hơn.

# Public091

# Giới thiệu

Pin năng lượng rắn (Solid-State Battery – SSB) được xem là bước tiến quan trọng trong ngành lưu trữ năng lượng, hứa hẹn **mật độ năng lượng cao** , **độ an toàn vượt trội** và **tuổi thọ dài** so với pin lithium-ion truyền thống. Thay vì sử dụng chất điện phân lỏng dễ cháy, pin thể rắn dùng **chất điện phân rắn** , mở ra tương lai cho xe điện, thiết bị di động và lưới điện lưu trữ quy mô lớn.

# Pin thể rắn là gì?

**Pin thể rắn** (Solid-State Battery) là một bước tiến công nghệ đột phá trong ngành lưu trữ năng lượng, với cấu trúc hoàn toàn khác biệt so với pin truyền thống. Thay vì sử dụng chất điện phân dạng lỏng như trong pin Lithium-ion, pin thể rắn dùng chất điện phân ở trạng thái rắn – đây chính là điểm khác biệt cốt lõi tạo nên loạt lợi thế vượt trội về hiệu suất, độ an toàn và mật độ năng lượng.

Chất điện phân rắn có thể là các hợp chất gốm, polymer, sulfide hay oxide… đóng vai trò trung gian truyền dẫn các ion lithium giữa hai cực âm (anode) và cực dương (cathode). Trong quá trình sạc, ion lithium di chuyển từ cực dương sang cực âm, và ngược lại trong quá trình phóng điện – quy trình này sinh ra dòng điện cung cấp năng lượng cho thiết bị.

# Cấu trúc và nguyên lý hoạt động

  * **Cực dương (Cathode):** Thường làm từ oxit kim loại chứa lithium.

  * **Cực âm (Anode):** Có thể sử dụng lithium kim loại tinh khiết, tăng đáng kể dung lượng.

  * **Chất điện phân rắn:** Gốm, polymer hoặc sulfide dẫn ion, thay thế hoàn toàn dung dịch lỏng.

  * **Cơ chế truyền ion:** Ion lithium di chuyển qua chất điện phân rắn trong quá trình sạc/xả, tương tự pin truyền thống nhưng an toàn hơn và giảm kháng nội.


![Mô phỏng cấu tạo của pin thể rắn](images/image1.jpeg) _Hình ảnh mô phỏng cấu tạo của pin ở thể rắn_

# Ưu điểm vượt trội

  * **Mật độ năng lượng cao:** Có thể đạt mức 400–500 Wh/kg, tăng 50–80% so với pin lithium-ion.

  * **An toàn:** Không chứa dung dịch dễ cháy, giảm nguy cơ cháy nổ.

  * **Sạc nhanh:** Đặc tính điện hóa ổn định cho phép sạc đầy trong thời gian ngắn.

  * **Tuổi thọ dài:** Giảm hình thành dendrite, kéo dài số chu kỳ sạc lên hàng nghìn lần.

  * **Hoạt động trong dải nhiệt rộng:** Hiệu suất tốt ngay cả ở nhiệt độ thấp.


# Ứng dụng thực tế

  * **Xe điện (EV):** Gia tăng quãng đường di chuyển, giảm thời gian sạc và tăng độ an toàn.

  * **Thiết bị điện tử di động:** Kéo dài tuổi thọ pin cho điện thoại, laptop, thiết bị đeo.

  * **Lưu trữ năng lượng tái tạo:** Ổn định lưới điện, tích trữ điện từ gió và mặt trời với chi phí thấp hơn.

  * **Hàng không và vũ trụ:** Giảm trọng lượng và tăng độ tin cậy cho vệ tinh và máy bay điện.


# Thách thức triển khai

  * **Chi phí sản xuất cao:** Quy trình chế tạo và vật liệu tiên tiến (như gốm sulfide) đòi hỏi công nghệ phức tạp.

  * **Giao diện điện cực – điện phân:** Tiếp xúc kém có thể làm giảm hiệu suất và tuổi thọ pin.

  * **Quy mô công nghiệp:** Cần dây chuyền sản xuất hàng loạt ổn định và đồng nhất.

  * **Vấn đề dendrite:** Dù giảm nhiều, vẫn cần kiểm soát để ngăn lithium hình thành sợi dẫn điện gây chập.


# Tiến bộ nghiên cứu

  * **Toyota và QuantumScape:** Công bố pin thể rắn mẫu có mật độ năng lượng gấp đôi pin lithium-ion.

  * **Samsung Advanced Institute:** Thiết kế lớp phủ bạc-carbon để cải thiện tiếp xúc điện cực.

  * **Viện nghiên cứu châu Âu:** Khám phá chất điện phân sulfide cho khả năng dẫn ion cao và linh hoạt cơ học.


# Tác động kinh tế – xã hội

  * **Thúc đẩy xe điện toàn cầu:** Giảm chi phí và tăng phạm vi di chuyển, đẩy nhanh quá trình khử carbon.

  * **Giảm ô nhiễm môi trường:** Tuổi thọ dài và khả năng tái chế cao giảm rác thải pin.

  * **Ổn định lưới điện xanh:** Hỗ trợ tích hợp năng lượng tái tạo quy mô lớn, giảm phụ thuộc nhiên liệu hóa thạch.


# Pin thể rắn trong tương lai

Với ưu nhược điểm pin thể rắn, loại pin này đã và đang được cân nhắc ứng dụng trong nhiều lĩnh vực khác nhau trong cuộc sống. Trong đó, [pin thể rắn được kỳ vọng sẽ làm thay đổi ngành công nghiệp xe điện](https://vinfastauto.com/vn_vi/pin-the-ran-nguon-goc-huu-co-lam-thay-doi-tuong-lai-xe-dien). Nó cho phép xe điện thu gọn được tối đa diện tích và giảm trọng lượng của xe xuống tới mức thấp nhất. Ngoài ra, loại pin này còn giúp giảm thời gian sạc điện cũng như có độ an toàn và tin cậy cao hơn. Chính vì thế, sự ra đời của pin thể rắn dự kiến sẽ thúc đẩy mạnh ngành xe điện trên thế giới. 

Một nghiên cứu đáng chú ý gần đây về pin thể rắn đó chính là pin được làm từ muối do nhóm nghiên cứu đến từ Đại học Nottingham của Vương quốc Anh cùng 6 cơ quan nghiên cứu khác của Trung Quốc công bố. Theo đó, muối rắn sẽ được sử dụng làm chất điện phân và cả chất phân tách. Đây được xem là bước tiến mới cho tương lai sản xuất pin thể rắn, vì giảm giá thành pin và vô cùng thân thiện với môi trường.

![VinFast hợp tác ProLogium sản xuất pin thể rắn đầu tiên tại Việt Nam](images/image2.jpeg) _VinFast hợp tác ProLogium sản xuất pin thể rắn đầu tiên tại Việt Nam (Nguồn: Sưu tầm)_

Tại Việt Nam, nhận thấy những tiềm năng, ưu điểm của pin thể rắn, vào tháng 03/03/2021, [**nhà sản xuất xe máy ô tô điện hàng đầu VinFast**](https://vinfastauto.com/) đã ký kết biên bản hợp tác chiến lược với ProLogium (Đài Loan) - Công ty đầu tiên trên thế giới có dây chuyền thử nghiệm ứng dụng công nghệ pin thể rắn cho ô tô.

# Public092

Siêu vật liệu là vật liệu nhân tạo với cấu trúc vi mô hoặc nano, cho phép điều khiển sóng điện từ, âm học và cơ học nhờ tham số hiệu dụng bất thường. Đơn vị cấu trúc tuần hoàn của siêu vật liệu có kích thước nhỏ hơn bước sóng, cho phép thiết kế cloaking, superlens, anten siêu mỏng và các ứng dụng khác.

# Giới thiệu

Siêu vật liệu (Metamaterial) là một trong những lĩnh vực tiên phong nhất trong khoa học vật liệu và công nghệ sóng. Khác với vật liệu tự nhiên vốn có giới hạn về hằng số điện môi, từ tính hay tính dẫn điện, siêu vật liệu được tạo ra bằng cách thiết kế cấu trúc nhân tạo ở cấp độ nano và micro, cho phép kiểm soát sóng điện từ theo những cách “phi tự nhiên”.

Khi thế giới hướng tới mạng 6G, hoạt động ở dải tần Terahertz (0.1–10 THz), các kỹ thuật truyền thống như anten kim loại hay ăng-ten MIMO khổng lồ sẽ gặp giới hạn vật lý. Siêu vật liệu chính là giải pháp mang tính đột phá, cho phép tạo ra các anten thông minh, bề mặt phản xạ tái cấu hình (RIS) và các hệ thống điều khiển sóng điện từ linh hoạt, giúp hiện thực hóa tốc độ truyền dữ liệu hàng terabit/giây và độ trễ dưới 1 mili giây mà 6G đòi hỏi.

# Định nghĩa và phân loại

Siêu vật liệu được phân loại theo tính chất sóng mà chúng điều khiển:

  * **Siêu vật liệu điện từ (electromagnetic metamaterials):** cho phép thiết lập εeff và μeff âm hoặc không đồng nhất, ứng dụng trong cloaking và superlensing.

  * **Siêu vật liệu âm học (acoustic metamaterials):** sử dụng cấu trúc cộng hưởng Helmholtz hoặc ống dẫn âm để điều khiển tốc độ và hướng truyền sóng âm, phục vụ cách âm và cloaking âm.

  * **Siêu vật liệu cơ học (mechanical metamaterials):** sở hữu các đặc tính cơ học phi truyền thống như hệ số Poisson âm (auxetic) hoặc cứng/nhu mềm tùy biến.

  * **Siêu vật liệu quang học (optical metamaterials):** hoạt động ở bước sóng ánh sáng khả kiến và cận hồng ngoại, đòi hỏi cấu trúc nano với kích thước nhỏ hơn 100 nm để điều khiển giao thoa và phân cực ánh sáng.


Mỗi loại siêu vật liệu có cơ chế hoạt động và phạm vi ứng dụng riêng, nhưng đều dựa trên nguyên lý đồng nhất hóa (homogenization) để mô tả tính chất trung bình của môi trường nhân tạo thông qua các tham số hiệu dụng (effective parameters).

# Nguyên lý hoạt động và mô hình hóa

Nguyên lý cốt lõi của siêu vật liệu là sự cộng hưởng của đơn vị cấu trúc. Với siêu vật liệu điện từ, các split-ring resonator (SRR) và mảng dây kim loại (wire arrays) tạo ra cộng hưởng từ và điện, dẫn đến εeff hoặc μeff âm trong vùng tần số hẹp.

Mô hình hóa siêu vật liệu thường sử dụng các phương trình Maxwell hiệu dụng, trong đó các tham số εeff và μeff được tính từ đáp ứng của đơn vị cấu trúc. Phương trình phân tán (dispersion relation) xác định mối quan hệ giữa véc-tơ sóng k và tần số ω, cho phép dự đoán khoảng băng thông và tính ổn định của cộng hưởng.

  * **Công thức hiệu dụng:** εeff=f(χe), μeff=f(χm), trong đó χ là độ từ cảm và điện cảm.

  * **Dispersion relation:** k(ω) xác định tốc độ pha và tốc độ nhóm, ảnh hưởng đến khả năng truyền và hấp thụ sóng.

  * **Hiệu ứng cộng hưởng đa bậc:** thiết kế nhiều cộng hưởng để mở rộng băng thông và giảm tổn hao (losses).


# Các phương pháp chế tạo

Chế tạo siêu vật liệu đòi hỏi công nghệ vi chế tạo chính xác để tạo ra cấu trúc lặp lại tuần hoàn với kích thước từ micro đến nano. Các phương pháp chính gồm:

  1. **Gia công MEMS và photolithography:** sử dụng cho tần số vi sóng và THz, công nghệ CMOS-compatible cho phép tích hợp trên chip bán dẫn.

  2. **In 3D vi cấu trúc (two-photon polymerization):** cho phép chế tạo cấu trúc 3D phức tạp ở quy mô sub-micron, phục vụ siêu vật liệu quang học ([ScienceDirect](https://www.sciencedirect.com/science/article/pii/S0030401818301362)).

  3. **Tự tổ chức (self-assembly) và in phun nano:** sử dụng vật liệu block copolymers hoặc colloidal nanoparticles để tạo màng mỏng siêu vật liệu trên diện rộng với chi phí thấp.


| Phương pháp | Kích thước cấu trúc | Ưu điểm | Nhược điểm |
| --- | --- | --- | --- |
| Photolithography | 100 nm–10 µm | Độ chính xác cao, khả năng tích hợp | Chi phí cao, diện tích nhỏ |
| Two-photon polymerization | 100 nm–1 µm | Khả năng 3D phức tạp | Tốc độ chậm, đắt đỏ |
| Self-assembly | 10 nm–1 µm | Quy mô lớn, chi phí thấp | Độ đồng nhất hạn chế |

 

# Siêu vật liệu điện từ

Siêu vật liệu điện từ (electromagnetic metamaterials) tận dụng cấu trúc đơn vị cộng hưởng để mô phỏng tham số hiệu dụng εeff và μeff âm hoặc giá trị bất thường. Split-ring resonator (SRR) tạo cộng hưởng từ, trong khi mảng dây kim loại (wire array) tạo cộng hưởng điện, kết hợp để đạt được vùng tần số với khúc xạ âm ([Nature](https://www.nature.com/articles/35095038)).

Đặc tính phân tán (dispersion) của siêu vật liệu điện từ được mô tả bởi phương trình:

k2=ω2μeff(ω) εeff(ω)

Trong đó, k là véc-tơ sóng, ω là tần số, μeff(ω) và εeff(ω) thay đổi theo tần số, cho phép thiết kế băng thông cộng hưởng hẹp hoặc mở rộng bằng cách bố trí đa cộng hưởng trong một đơn vị cell.

  * **Negative refraction:** góc khúc xạ phản chiều với góc tới, cho phép chế tạo siêu ống kính (superlens) vượt giới hạn nhiễu xạ.

  * **Hyperbolic dispersion:** iso-frequency surface dạng hyperboloid hỗ trợ mật độ trạng thái quang học cao và truyền dẫn sóng evanescent.

  * **Metasurfaces:** siêu vật liệu hai chiều điều khiển pha ánh sáng theo mặt phẳng, ứng dụng trong điều chế sóng và quang học phẳng.


# Nguyên lý hoạt động

  * Cấu trúc siêu nhỏ: Siêu vật liệu gồm những phần tử lặp (unit cell) nhỏ hơn nhiều so với bước sóng tín hiệu. Nhờ vậy, thay vì chỉ hấp thụ hay phản xạ sóng như vật liệu thường, chúng có thể thay đổi pha, biên độ và hướng truyền theo thiết kế.

  * Chỉ số khúc xạ âm: Một trong những đặc điểm nổi bật là khả năng tạo ra chỉ số khúc xạ âm (negative refractive index), nghĩa là sóng có thể “bẻ cong” theo hướng ngược lại so với quy luật thông thường.

  * Metasurface: Thay vì khối 3D cồng kềnh, siêu vật liệu có thể được chế tạo thành các lớp mỏng 2D (metasurface), dày chỉ vài nanomet nhưng có khả năng kiểm soát sóng mạnh mẽ, dễ tích hợp lên thiết bị di động hoặc vệ tinh.

  * Điều khiển động (Dynamic Tuning): Với sự hỗ trợ của graphene và vật liệu 2D, các đặc tính điện từ có thể thay đổi theo điện áp, ánh sáng hay từ trường bên ngoài, tạo nên bề mặt thông minh có khả năng điều chỉnh theo thời gian thực.


# Ứng dụng trong mạng 6G

## Anten siêu vật liệu tái cấu hình:

  * Các anten 6G cần băng thông lớn, đa hướng và linh hoạt. Siêu vật liệu cho phép thiết kế anten có thể chuyển đổi mẫu bức xạ, tập trung sóng về hướng người dùng hoặc phân tán khi cần thiết.

  * Thay vì cần hàng trăm anten riêng lẻ, một anten phủ metasurface có thể thay thế toàn bộ nhờ khả năng lập trình.


## Bề mặt phản xạ thông minh (Reconfigurable Intelligent Surface – RIS):

  * Trong đô thị, tín hiệu thường bị tòa nhà che chắn. RIS phủ siêu vật liệu có thể “bẻ cong” sóng, chuyển hướng tín hiệu đến đúng người dùng.

  * Điều này giúp tăng vùng phủ sóng, giảm “điểm chết” và tiết kiệm năng lượng phát sóng.


## Lọc và bảo mật tín hiệu:

  * Siêu vật liệu cho phép tạo ra bộ lọc tần số hẹp và kênh truyền an toàn, giảm nguy cơ nghe lén.

  * Đây là bước quan trọng khi 6G được ứng dụng trong y tế từ xa, tài chính và quân sự.


## Giao tiếp Terahertz (THz):

  * Sóng THz dễ bị hấp thụ bởi môi trường, nhưng siêu vật liệu có thể tăng cường khả năng truyền và hội tụ.

  * Nhờ đó, liên lạc 6G có thể đạt tốc độ hàng trăm gigabit đến terabit/giây, đáp ứng cho metaverse và AI thời gian thực.


# Ứng dụng ngoài viễn thông

  * Tàng hình radar và sóng: Siêu vật liệu có thể khiến vật thể trở nên “vô hình” với radar bằng cách làm lệch hướng sóng, ứng dụng trong quân sự.

  * Thấu kính siêu phân giải (Superlens): Vượt giới hạn nhiễu xạ ánh sáng, cho phép quan sát chi tiết tế bào hoặc cấu trúc nano.

  * Pin mặt trời siêu hiệu quả: Tăng khả năng hấp thụ ánh sáng vào tế bào quang điện.

  * Cảm biến sinh học: Dùng cộng hưởng plasmon bề mặt để phát hiện virus, protein hoặc hóa chất ở nồng độ cực thấp.

  * Vật liệu cách âm: Không chỉ điều khiển sóng điện từ, siêu vật liệu còn ứng dụng trong điều khiển sóng âm, giảm tiếng ồn đô thị.


# Thách thức nghiên cứu và thương mại hóa

  * Sản xuất quy mô nano: Tạo cấu trúc nano đồng nhất ở diện tích lớn là cực kỳ khó khăn và tốn kém.

  * Độ bền vật liệu: Siêu vật liệu dễ bị hư hỏng khi tiếp xúc môi trường khắc nghiệt, cần cải tiến về cơ học.

  * Chi phí: Vật liệu graphene, vàng nano hay oxide hiếm đắt đỏ, chưa thể triển khai đại trà.

  * Tích hợp tiêu chuẩn 6G: Các hãng viễn thông cần thống nhất chuẩn RIS, metasurface để đảm bảo tính tương thích toàn cầu.

  * Điều khiển động: Dù ý tưởng metasurface động đã xuất hiện, việc chế tạo sản phẩm ổn định vẫn còn ở giai đoạn thử nghiệm.


# Xu hướng tương lai

  * Metamaterial lai (Hybrid): Kết hợp graphene với các oxide kim loại để vừa rẻ vừa hiệu quả.

  * Metasurface điều khiển AI: AI tối ưu hóa cách điều khiển RIS theo thời gian thực để đảm bảo kết nối tốt nhất.

  * Tích hợp trong vệ tinh và drone: Siêu vật liệu nhẹ, mỏng, phù hợp cho hệ thống viễn thông không gian.

  * Ứng dụng dân dụng: Anten thông minh cho smartphone, router Wi-Fi 7/8, và thiết bị IoT.

  * Kết hợp lượng tử: Siêu vật liệu có thể mở đường cho truyền thông lượng tử và các thiết bị quang học lượng tử thế hệ mới.


# Tác động kinh tế – xã hội

  * Mạng phủ sóng toàn diện: Giảm chi phí hạ tầng 6G khi cần ít trạm phát hơn.

  * Internet tốc độ siêu cao: Đáp ứng nhu cầu thực tế ảo, metaverse, và công nghiệp 4.0.

  * An ninh quốc gia: Hỗ trợ hệ thống radar tàng hình, thông tin quân sự bảo mật.

  * Y tế và giáo dục: Tạo môi trường ảo chất lượng cao cho phẫu thuật từ xa, học tập từ xa.

  * Kinh tế xanh: Giảm tiêu thụ năng lượng trong viễn thông nhờ tối ưu sóng

# Public093

# Giới thiệu

Máy tính điện tử truyền thống dựa trên electron đã đạt tới giới hạn về tốc độ và tiêu thụ năng lượng, đặc biệt khi xử lý các mô hình trí tuệ nhân tạo (AI) khổng lồ với hàng tỷ tham số. **Máy tính quang học (Photonic Computing)** nổi lên như một giải pháp đột phá, khai thác **photon** – hạt ánh sáng – để truyền và xử lý thông tin.

Photon di chuyển gần như **tức thời** và không sinh nhiệt đáng kể, giúp máy tính quang học đạt **tốc độ xử lý cao gấp hàng trăm lần** và giảm tiêu thụ năng lượng so với mạch điện tử. Công nghệ này được coi là nền tảng cho **AI thế hệ tiếp theo** , điện toán lượng tử lai và các trung tâm dữ liệu siêu hiệu suất.

# Vì sao lại là photon?

  * Photon – hạt ánh sáng – sở hữu nhiều ưu điểm vượt trội:

* Di chuyển nhanh gần như không tổn hao, dễ dàng truyền tải qua cáp quang và không cần làm lạnh đến nhiệt độ cực thấp như các qubit siêu dẫn.

* Khả năng chống nhiễu tốt, giúp duy trì trạng thái lượng tử (coherence) lâu hơn.

* Tích hợp hạ tầng viễn thông quang học sẵn có, mở ra tiềm năng ứng dụng rộng rãi trong mạng lượng tử và điện toán phân tán.


Cách hoạt động của máy tính lượng tử quang tử. Máy tính lượng tử quang tử không dựa trên mạch bán dẫn truyền thống, mà sử dụng:

  * **Qubit quang tử** : mã hóa thông tin vào trạng thái phân cực, pha hoặc số photon.

  * **Mạng lưới quang tử (photonic circuits)** : chip silicon tích hợp với bộ chia chùm (beam splitter), bộ dịch pha (phase shifter) để điều khiển photon.

  * **Phép đo lượng tử** : sử dụng cảm biến siêu nhạy để đọc kết quả tính toán.


# Nguyên lý hoạt động

  * **Truyền dữ liệu bằng photon:** Thay vì electron chạy qua dây dẫn, photon di chuyển qua các sợi quang hoặc mạch quang tích hợp.

  * **Tính toán trong miền quang:** Các phần tử như **bộ tách chùm, giao thoa kế Mach–Zehnder** và **lưới dẫn sóng silicon** thực hiện các phép nhân–cộng ma trận trực tiếp bằng ánh sáng.

  * **Xử lý song song tự nhiên:** Nhiều bước sóng (đa kênh) có thể truyền đồng thời trong một sợi quang, cho phép **tính toán song song khối lượng lớn**.

  * **Chuyển đổi quang–điện:** Kết hợp cảm biến quang và bộ tách tín hiệu điện để tương thích với hệ thống điện tử hiện có.


# Ưu thế vượt trội

  * **Tốc độ cực cao:** Truyền dữ liệu gần tốc độ ánh sáng, băng thông hàng terabit/giây.

  * **Tiêu thụ năng lượng thấp:** Giảm nhiệt và nhu cầu làm mát so với chip điện tử.

  * **Khả năng mở rộng:** Hỗ trợ mô hình AI lớn mà không tăng đột biến chi phí năng lượng.

  * **Xử lý song song:** Đa kênh quang cho phép tính toán đồng thời nhiều phép toán ma trận – cốt lõi của huấn luyện deep learning.


# Ứng dụng trong trí tuệ nhân tạo

  * **Huấn luyện mô hình lớn:** Giảm thời gian huấn luyện từ nhiều tuần xuống vài ngày.

  * **Suy luận thời gian thực:** Hỗ trợ AI biên (edge AI) và robot tự hành với độ trễ cực thấp.

  * **Xử lý hình ảnh và video:** Tăng tốc các mạng CNN và Transformer cho thị giác máy tính.

  * **Xử lý ngôn ngữ tự nhiên:** Đẩy nhanh các tác vụ như dịch tự động, tổng hợp văn bản.


# Hạ tầng công nghệ

  * **Mạch quang tích hợp (Photonic Integrated Circuit – PIC):** Kết hợp hàng nghìn linh kiện quang trên chip silicon.

  * **Laser bán dẫn siêu nhỏ:** Cung cấp nguồn photon ổn định cho tính toán.

  * **Vật liệu đặc biệt:** Silicon nitride, graphene và hợp chất III-V cho phép điều khiển ánh sáng chính xác.

  * **Ghép nối với điện toán lượng tử:** Photon có thể truyền qubit lượng tử bền vững hơn electron.


# Thách thức hiện tại

  * **Kích thước và độ chính xác chế tạo:** Yêu cầu công nghệ in nano chính xác cao.

  * **Tương thích với phần mềm:** Cần thư viện và thuật toán tối ưu cho mạch quang.

  * **Chi phí ban đầu:** Sản xuất chip quang vẫn đắt hơn silicon truyền thống.

  * **Chuyển đổi quang–điện:** Mỗi lần chuyển đổi làm giảm hiệu suất, cần giải pháp lai tối ưu.


# Tiến bộ nghiên cứu và thương mại hóa

  * **Lightmatter & Lightelligence:** Phát triển bộ gia tốc AI quang học, đạt hiệu năng vượt GPU cao cấp.

  * **MIT & Stanford:** Trình diễn mạng nơ-ron quang học trên chip, huấn luyện trực tiếp bằng ánh sáng.

  * **Google & Microsoft:** Nghiên cứu kết hợp quang học với điện toán lượng tử cho trung tâm dữ liệu.


# Tác động kinh tế – xã hội

  * **Trung tâm dữ liệu xanh:** Giảm tiêu thụ điện hàng tỷ kWh mỗi năm.

  * **Thúc đẩy AI khổng lồ:** Cho phép các mô hình ngôn ngữ, hình ảnh vượt mức hiện tại mà vẫn khả thi về chi phí.

  * **Y tế và khoa học:** Tăng tốc phân tích gen, mô phỏng thuốc, và xử lý hình ảnh y khoa.

  * **Viễn thông và tài chính:** Hỗ trợ giao dịch tốc độ cực cao và mạng 6G/7G tương lai.


# Xu hướng tương lai

  * **Chip quang – điện lai (Hybrid Photonic-Electronic):** Kết hợp điểm mạnh của cả hai thế giới.

  * **Vật liệu 2D:** Graphene và perovskite nâng cao độ bền và linh hoạt.

  * **AI tự tối ưu thiết kế mạch:** Dùng học sâu để bố trí linh kiện quang tối ưu cho từng tác vụ.

  * **Máy tính quang lượng tử:** Kết hợp tính chất photon và qubit cho siêu máy tính thế hệ mới.


#  **Tương lai gần**

  * Các công ty như PsiQuantum, Xanadu và QuiX Quantum đang đua nhau phát triển các nguyên mẫu máy tính lượng tử quang tử có thể mở rộng. Một số thử nghiệm đã chứng minh khả năng đạt “tính ưu việt lượng tử” (quantum advantage) trong những bài toán mẫu. Nếu vượt qua các thách thức kỹ thuật, đây có thể là con đường khả thi nhất để hiện thực hóa máy tính lượng tử thương mại trong thập kỷ tới.

  * Máy tính lượng tử quang tử chính là cuộc cách mạng dựa trên ánh sáng, có thể định hình lại toàn bộ ngành khoa học, công nghệ và nền kinh tế tri thức toàn cầu.

# Public094

# Giới thiệu

Vũ trụ học tính toán là lĩnh vực liên ngành kết hợp vật lý thiên văn, toán học, khoa học máy tính và trí tuệ nhân tạo để giải mã lịch sử hình thành và tiến hóa của vũ trụ. Nếu kính thiên văn cho chúng ta hình ảnh của bầu trời như nó hiện ra hôm nay, thì vũ trụ học tính toán cho phép “tua ngược thời gian”, tái dựng những giai đoạn sớm nhất của vũ trụ từ sau Vụ Nổ Lớn (Big Bang), đồng thời dự đoán tương lai hàng chục tỷ năm tới.

Các mô phỏng này tái hiện sự giãn nở không gian, tương tác của vật chất tối, năng lượng tối, và khí baryon để trả lời các câu hỏi cốt lõi: Làm thế nào các thiên hà đầu tiên hình thành? Vì sao chúng phân bố thành mạng lưới vũ trụ (cosmic web) khổng lồ? Và tương lai của vũ trụ – dãn nở vô hạn hay co sụp – sẽ ra sao?

# Bối cảnh lịch sử

  * Thập niên 1960–1980: Các mô phỏng đầu tiên chỉ xử lý vài trăm đến vài nghìn hạt, tập trung vào sự hình thành cụm thiên hà.

  * Thập niên 1990: Sự phát triển của siêu máy tính cho phép mô phỏng hàng triệu hạt, lần đầu tiên thể hiện mạng lưới vũ trụ giống quan sát thực.

  * Thế kỷ 21: Các dự án như Millennium Simulation và Illustris nâng quy mô lên hàng chục tỷ hạt, mô tả chi tiết hình thành thiên hà, lỗ đen siêu nặng, và luồng gió thiên hà.

  * Hiện nay: Với sức mạnh exascale (10¹⁸ phép tính/giây), mô phỏng có thể đồng thời theo dõi cấu trúc vĩ mô và các quá trình vi mô như sự hình thành sao, bùng nổ siêu tân tinh, và phản hồi của lỗ đen.


# Công nghệ và phương pháp

  * Phương trình Einstein: Mô tả sự giãn nở không gian-thời gian và ảnh hưởng của năng lượng tối.

  * Mô phỏng N-body: Tính toán lực hấp dẫn giữa hàng tỷ “hạt” đại diện cho cụm vật chất tối và thiên hà.

  * Thủy động lực học vũ trụ (Cosmological Hydrodynamics): Giải phương trình Navier–Stokes cho khí baryon, mô phỏng quá trình làm mát, hình thành sao, và gió thiên hà.

  * Thuật toán đa tỷ lệ: Kết hợp độ phân giải cao cho vùng thiên hà nhỏ và độ phân giải thấp cho không gian rộng để cân bằng độ chính xác và chi phí.

  * AI và Machine Learning: Tăng tốc mô phỏng, nén dữ liệu, và nhận dạng mẫu trong hàng petabyte dữ liệu.


# Học máy trong Vũ trụ học

Học máy là một lĩnh vực phát triển nhanh chóng và có tiềm năng tạo ra bước đột phá trong nghiên cứu vũ trụ học. Bằng cách áp dụng các thuật toán học máy vào các bộ dữ liệu khổng lồ, các nhà nghiên cứu có thể rút ra những hiểu biết và mô hình mà phương pháp truyền thống khó hoặc không thể phát hiện.

## Giới thiệu về Học máy trong Vũ trụ học

Trong vũ trụ học, học máy thường bao gồm việc sử dụng các thuật toán học có giám sát hoặc không giám sát để phân tích các tập dữ liệu lớn.

Học có giám sát: Huấn luyện mô hình trên tập dữ liệu đã gắn nhãn, nơi các nhãn là những đại lượng đã biết như tham số vũ trụ học hoặc đặc tính của thiên hà.

Học không giám sát: Tìm kiếm các mẫu hoặc cấu trúc trong dữ liệu mà không cần biết trước các nhãn.

Một trong những ứng dụng chính của học máy trong vũ trụ học là ước lượng các tham số vũ trụ học từ các tập dữ liệu lớn. Ví dụ, các thuật toán học máy có thể được dùng để phân tích sự phân bố của các thiên hà hoặc các đặc tính của bức xạ phông vi sóng vũ trụ (CMB) nhằm suy ra giá trị của các tham số như hằng số Hubble hoặc mật độ vật chất tối.

## Ứng dụng của Học máy trong Ước lượng Tham số Vũ trụ học

Học máy đã được áp dụng cho nhiều loại dữ liệu vũ trụ khác nhau, bao gồm bức xạ phông vi sóng vũ trụ, khảo sát thiên hà và quan sát thấu kính hấp dẫn. Một số ví dụ tiêu biểu:

Ước lượng tham số vũ trụ học: Sử dụng thuật toán học máy để ước lượng các tham số như hằng số Hubble, mật độ vật chất tối và mật độ năng lượng tối.

Phân loại thiên hà: Phân loại các thiên hà theo loại, chẳng hạn như thiên hà xoắn ốc hay thiên hà elip.

Phân tích thấu kính hấp dẫn: Phân tích đặc tính của các hệ thấu kính hấp dẫn, như phân bố khối lượng của các thiên hà đóng vai trò thấu kính.

## Hướng phát triển trong tương lai cho Học máy trong Vũ trụ học

Việc ứng dụng học máy vào vũ trụ học đang phát triển nhanh với nhiều triển vọng thú vị:

Kết hợp học máy với phương pháp truyền thống: Học máy có thể kết hợp với các phương pháp truyền thống như suy luận Bayes để nâng cao độ chính xác và độ tin cậy trong ước lượng tham số vũ trụ học.

Phân tích các bộ dữ liệu mới: Ứng dụng học máy cho các bộ dữ liệu sắp có như Square Kilometre Array (SKA) hay Kính thiên văn Khảo sát Bầu trời Lớn (LSST) để khám phá những mẫu hình và hiểu biết mới.

Phát triển thuật toán học máy mới: Thiết kế các thuật toán học máy được tối ưu hóa riêng cho nhu cầu của vũ trụ học, chẳng hạn như phân tích cấu trúc quy mô lớn hoặc nghiên cứu đặc tính của bức xạ phông vi sóng vũ trụ.

# 

# Siêu máy tính và dự án tiêu biểu

  * Illustris & IllustrisTNG: Mô phỏng hơn 30 tỷ hạt trong khối lập phương rộng 300 triệu năm ánh sáng, tái hiện chi tiết quá trình từ Big Bang tới hiện tại.

  * Millennium Simulation: Điểm mốc quan trọng trong việc nghiên cứu vai trò của vật chất tối và sự hình thành mạng lưới vũ trụ.

  * Frontier (Mỹ) & Fugaku (Nhật): Siêu máy tính exascale cho phép giải các mô hình vật lý phức tạp với độ chính xác chưa từng có, mở đường cho việc mô phỏng toàn bộ lịch sử vũ trụ với độ phân giải cao.


# Ứng dụng khoa học

  * Giải mã vật chất tối và năng lượng tối: So sánh mô phỏng với quan sát (như dữ liệu từ Kính James Webb, Euclid) để ước tính tỷ lệ và tính chất của các thành phần bí ẩn này.

  * Dự báo quan sát thiên văn: Giúp các nhà thiên văn lên kế hoạch cho các chiến dịch quan sát, tối ưu vị trí đặt kính và thời điểm chụp.

  * Nguồn gốc lỗ đen siêu nặng: Tái hiện quá trình các hạt khí sụp đổ thành lỗ đen khổng lồ ở tâm thiên hà.

  * Hình thành mạng lưới vũ trụ: Giải thích vì sao các thiên hà không phân bố đều mà kết thành sợi, nút, và khoảng trống khổng lồ.


# Thách thức

  * Khối lượng dữ liệu khổng lồ: Một mô phỏng hiện đại tạo ra hàng petabyte dữ liệu, đòi hỏi hệ thống lưu trữ và thuật toán nén tiên tiến.

  * Độ chính xác mô hình: Cần cân bằng giữa quy mô vũ trụ (hàng tỷ năm ánh sáng) và các quá trình nhỏ như bùng nổ siêu tân tinh.

  * Chi phí tính toán: Một mô phỏng quy mô lớn có thể tiêu tốn hàng triệu giờ CPU và hàng triệu USD chi phí vận hành.

  * Kết hợp dữ liệu quan sát: Việc đồng bộ với những phát hiện mới từ các kính thiên văn thế hệ tiếp theo (JWST, SKA) đòi hỏi mô hình linh hoạt.


# Tác động và tương lai

  * Kiến thức vũ trụ sâu hơn: Kiểm chứng hoặc bác bỏ các giả thuyết như Vũ trụ lạm phát, Big Rip, hoặc đa vũ trụ.

  * Giáo dục và phổ biến khoa học: Tạo phim 3D, thực tế ảo cho phép “du hành” trong mô phỏng vũ trụ, giúp công chúng hiểu về Big Bang và cấu trúc thiên hà.

  * Hợp tác liên ngành: Thúc đẩy phát triển thuật toán tính toán song song, lưu trữ dữ liệu khổng lồ, và trí tuệ nhân tạo.

  * Exascale và máy tính lượng tử: Kết hợp siêu máy tính exascale với điện toán lượng tử sẽ mở đường cho mô phỏng từng hạt nguyên tử trong thời kỳ vũ trụ sơ khai.

# Public095

# Giới thiệu

Terraforming là quá trình **cải tạo khí hậu, bề mặt và sinh quyển của một hành tinh** để biến nó trở nên giống Trái Đất, đủ điều kiện cho sự sống của con người và các loài sinh vật khác. Trong số các hành tinh của Hệ Mặt Trời, **Sao Hỏa** được coi là ứng viên tiềm năng nhất vì có ngày dài tương tự Trái Đất, sự hiện diện của nước đóng băng và bầu khí quyển mỏng nhưng giàu CO₂ – yếu tố quan trọng cho việc tạo hiệu ứng nhà kính.

Ý tưởng này không chỉ mang tính khoa học viễn tưởng mà còn là **kế hoạch dài hạn của nhân loại** để đảm bảo sự tồn tại khi Trái Đất đối mặt với khủng hoảng môi trường hoặc thảm họa vũ trụ.

# Định hướng hiện tại: Sao Hỏa

Ngày nay, hành tinh khả thi nhất cho việc cải tạo địa hình (terraforming) có vẻ là Sao Hỏa. Robert Zubrin, người sáng lập Mars Society, đã trình bày một kế hoạch chi tiết có tên **Mars Direct** , khởi đầu bằng một sứ mệnh đưa con người trở lại Sao Hỏa.  
Lý do chính cho việc cải tạo hành tinh là để tạo ra các thế giới thích hợp cho sự sinh sống của con người. Tuy nhiên, một số nhà nghiên cứu tin rằng việc xây dựng các **không gian sống nhân tạo trong vũ trụ (space habitats)** sẽ là giải pháp kinh tế hơn cho việc định cư không gian.

Nếu nghiên cứu về **công nghệ nano và các quy trình hóa học tiên tiến** tiếp tục phát triển, việc cải tạo toàn bộ hành tinh có thể trở nên khả thi trong vài thế kỷ thay vì hàng thiên niên kỷ. Ngược lại, có thể sẽ hợp lý hơn nếu **chỉnh sửa cơ thể con người** để họ không cần môi trường giàu oxy/nitơ và trọng lực 1G như Trái Đất, từ đó giảm nhu cầu cải tạo hành tinh hoặc ít nhất giảm mức độ cần thay đổi môi trường của các hành tinh khác.

( _Ghi chú_ : Vấn đề khí nhà kính hiện nay cũng cho thấy nhân loại vô tình đang “cải tạo” chính Trái Đất, đưa nồng độ CO₂ trở lại mức của hàng triệu năm trước.)

# Paraterraforming – Khái niệm “Worldhouse”

Paraterraforming, hay còn gọi là **“nhà toàn cầu”** , là ý tưởng xây dựng một mái che khổng lồ bao phủ dần phần lớn diện tích có thể sử dụng của một hành tinh. Cấu trúc này gồm:

  * **Mái trong suốt** được giữ ở độ cao từ một vài km trở lên.

  * **Áp suất khí quyển bên trong** đạt mức có thể thở, được cố định bằng các tháp và cáp neo định kỳ.


Công nghệ xây dựng kiểu này đã được biết đến từ thập niên 1960.

**Ưu điểm của Paraterraforming**

  * **Hiệu quả đầu tư tức thì** : Các khu vực được bao phủ có thể được sử dụng ngay từ đầu, mở rộng dần theo nhu cầu.

  * **Tính mô-đun cao** : Có thể phát triển từng phần, phù hợp với tốc độ tăng dân số hoặc nhu cầu cụ thể.

  * **Giảm yêu cầu khí quyển** : Vì có lớp mái rắn, ngay cả các thiên thể không thể giữ bầu khí quyển, như tiểu hành tinh, cũng có thể trở thành môi trường sống.


# Thách thức môi trường trên Sao Hỏa

  * **Áp suất khí quyển cực thấp:** Chỉ bằng 0,6% Trái Đất, không thể duy trì nước ở dạng lỏng.

  * **Nhiệt độ lạnh giá:** Trung bình -60 °C, đêm xuống có thể -125 °C.

  * **Thiếu từ trường:** Không có lớp bảo vệ chống bức xạ vũ trụ và gió Mặt Trời.

  * **Bầu khí quyển mỏng:** Chủ yếu CO₂, thiếu oxy cho hô hấp.

  * **Nước dạng băng:** Tồn tại ở cực và dưới bề mặt, cần khai thác quy mô lớn.


# Phương pháp cải tạo Sao Hỏa

## Tăng áp suất khí quyển:

  * Giải phóng CO₂ từ băng cực và đá carbonat bằng gương phản xạ Mặt Trời hoặc vụ nổ hạt nhân kiểm soát.

  * Mục tiêu tạo hiệu ứng nhà kính để làm ấm bề mặt.


## Gia nhiệt hành tinh:

  * Sử dụng gương không gian khổng lồ tập trung ánh sáng Mặt Trời.

  * Thả khí nhà kính nhân tạo (perfluorocarbons) để giữ nhiệt.


## Tạo từ trường nhân tạo:

  * Đặt nam châm khổng lồ tại điểm L1 (giữa Mặt Trời và Sao Hỏa) để che chắn gió Mặt Trời, giảm mất khí quyển.


## Sản xuất oxy và nước:

  * Ứng dụng công nghệ điện phân CO₂ để tách oxy.

  * Khai thác băng dưới bề mặt và vận chuyển băng từ các vệ tinh như Europa hoặc Enceladus.


## Giới thiệu sinh vật quang hợp:

  * Sử dụng vi khuẩn lam (cyanobacteria) và tảo chịu lạnh để tạo oxy tự nhiên và tăng độ dày khí quyển.


# Công nghệ hỗ trợ

  * **Robot tự động và AI:** Thực hiện khai thác tài nguyên, lắp đặt cơ sở hạ tầng trước khi con người định cư.

  * **In 3D quy mô lớn:** Xây dựng căn cứ, đường ống và các cấu trúc che chắn bức xạ.

  * **Lò phản ứng hạt nhân nhỏ gọn:** Cung cấp năng lượng liên tục cho các quá trình gia nhiệt và điện phân.

  * **Công nghệ sinh học tổng hợp:** Tạo vi khuẩn và cây trồng chịu điều kiện khí hậu khắc nghiệt.


# Tác động và rủi ro

  * **Khoa học và đạo đức:** Tranh luận về việc thay đổi hành tinh có thể phá hủy sự sống bản địa (nếu tồn tại).

  * **Chi phí khổng lồ:** Ước tính hàng nghìn tỷ USD và nhiều thập kỷ, thậm chí hàng thế kỷ.

  * **Rủi ro kỹ thuật:** Sự cố trong kiểm soát khí hậu có thể gây hiệu ứng không lường trước, như bão bụi toàn cầu hoặc mất ổn định quỹ đạo.

  * **Chính trị và pháp lý:** Cần thỏa thuận quốc tế để tránh tranh chấp sở hữu và khai thác tài nguyên.


# Lộ trình khả thi

  * **Giai đoạn 1 – Khảo sát và căn cứ tự cung tự cấp:** Sử dụng tàu vũ trụ chở hàng hóa và robot khai thác nước băng.

  * **Giai đoạn 2 – Gia tăng khí quyển cục bộ:** Xây dựng các mái vòm sinh sống, tăng áp suất bên trong trước khi mở rộng ra ngoài.

  * **Giai đoạn 3 – Cải tạo toàn cầu:** Khi công nghệ đủ trưởng thành, triển khai gương không gian, khí nhà kính và từ trường nhân tạo.

  * **Giai đoạn 4 – Định cư quy mô lớn:** Con người có thể sống ngoài mái vòm, trồng cây, thiết lập xã hội lâu dài.


# Địa kỹ thuật (Geoengineering) – “Terraforming” Trái Đất

**Địa kỹ thuật** là việc cố ý thay đổi môi trường Trái Đất trên quy mô lớn – một dạng “cải tạo” hành tinh của chính chúng ta. Nhiều tranh luận cho rằng nền văn minh nhân loại đã vô tình biến đổi khí hậu Trái Đất thông qua việc thải khí nhà kính công nghiệp, và đã có các đề xuất chủ động để đối phó, ví dụ:

  * **Gương khổng lồ ngoài quỹ đạo** : Điều chỉnh lượng bức xạ Mặt Trời (insolation) mà Trái Đất nhận được – tăng hoặc giảm tùy nhu cầu.

  * **Lưu trữ CO₂ quy mô lớn** : Tiêm hoặc chôn CO₂ vào các tầng địa chất hoặc trầm tích đáy biển.

  * **Thay đổi suất phản chiếu (albedo)** : Phủ vật liệu phản xạ hoặc hấp thụ lên bề mặt Trái Đất để điều chỉnh nhiệt lượng.

  * **Điều chỉnh lượng mưa** : Tạo ra các biển nhân tạo nhằm tác động đến mô hình khí hậu và lượng mưa.


# Tương lai lâu dài

Dù còn xa vời, tiến trình terraform Sao Hỏa mang lại **lợi ích khoa học và công nghệ khổng lồ** : từ phát triển năng lượng sạch, vật liệu siêu bền, tới đột phá về công nghệ sinh học. Những nghiên cứu này cũng giúp cải thiện hiểu biết về **biến đổi khí hậu trên Trái Đất** , cung cấp giải pháp đối phó với khủng hoảng môi trường toàn cầu.

# Public096

# Giới thiệu

Nhiệt hạch (fusion) là quá trình hai hạt nhân nhẹ kết hợp thành một hạt nhân nặng hơn, giải phóng năng lượng khổng lồ – cơ chế cung cấp ánh sáng và nhiệt của Mặt Trời. Khác với phân hạch (fission) trong các nhà máy điện hạt nhân hiện nay, nhiệt hạch không tạo ra chất thải phóng xạ lâu dài và tiềm ẩn nguy cơ tan chảy lõi thấp hơn nhiều.

Con người đã theo đuổi giấc mơ “mặt trời nhân tạo” hàng thập kỷ vì nó hứa hẹn nguồn năng lượng gần như vô hạn, an toàn và không phát thải carbon, có khả năng thay thế hoàn toàn nhiên liệu hóa thạch.

# Nguyên lý cơ bản

  * Phản ứng Deuterium–Tritium (D–T): Hai đồng vị của hydro (deuterium và tritium) hợp nhất ở nhiệt độ hơn 100 triệu °C, tạo ra helium và neutron năng lượng cao.

  * Điều kiện cần thiết:

* Nhiệt độ cực cao để các hạt nhân vượt qua lực đẩy Coulomb.

* Áp suất và mật độ đủ lớn để duy trì phản ứng.

* Thời gian giam giữ đủ lâu (Lawson Criterion) để năng lượng sinh ra nhiều hơn năng lượng đầu vào.


# Tại sao các nhà khoa học nghiên cứu năng lượng nhiệt hạch (nuclear fusion)?

Ngay từ khi lý thuyết về phản ứng nhiệt hạch được hiểu rõ vào những năm 1930, các nhà khoa học – và ngày càng nhiều kỹ sư – đã theo đuổi mục tiêu tái tạo và khai thác nguồn năng lượng này. Lý do là nếu có thể tái tạo phản ứng nhiệt hạch trên Trái Đất ở quy mô công nghiệp, nó có thể cung cấp nguồn năng lượng sạch, an toàn và gần như vô hạn với chi phí hợp lý để đáp ứng nhu cầu của thế giới.

Phản ứng nhiệt hạch có khả năng tạo ra năng lượng gấp **bốn lần so với phân hạch** (đang được dùng trong các nhà máy điện hạt nhân) và gần **bốn triệu lần so với việc đốt dầu hoặc than** tính theo cùng khối lượng nhiên liệu.

Hầu hết các thiết kế lò phản ứng nhiệt hạch đang được phát triển đều sử dụng **hỗn hợp deuteri và triti** – các nguyên tử hydro chứa thêm nơtron. Về lý thuyết, chỉ cần vài gram hai loại nhiên liệu này có thể tạo ra **1 terajoule năng lượng** , tương đương lượng năng lượng một người ở quốc gia phát triển cần dùng trong khoảng **60 năm**.

## Nguồn nhiên liệu dồi dào và an toàn

  * **Deuteri** có thể được chiết xuất từ nước biển với chi phí thấp.

  * **Triti** có thể được tạo ra từ phản ứng của nơtron sinh ra trong quá trình nhiệt hạch với lithium tự nhiên phong phú.


Nguồn nhiên liệu này đủ để cung cấp cho nhân loại **hàng triệu năm**. Các lò phản ứng nhiệt hạch tương lai cũng **an toàn về bản chất** và không được kỳ vọng tạo ra chất thải phóng xạ hoạt tính cao hay tồn tại lâu dài.  
Ngoài ra, do quá trình nhiệt hạch **khó khởi động và duy trì** , không có nguy cơ phản ứng dây chuyền ngoài tầm kiểm soát hay tan chảy lò. Nếu có sự cố, plasma sẽ **tự ngừng phản ứng** , mất năng lượng nhanh chóng và tắt trước khi gây hư hại nghiêm trọng cho lò.

Đáng chú ý, cũng giống như phân hạch, nhiệt hạch **không thải ra khí CO₂ hay khí nhà kính** , nên có thể trở thành **nguồn điện ít carbon lâu dài** từ nửa sau thế kỷ này.

![A diagram of a nuclear fusion AI-generated content may be incorrect.](images/image1.jpeg)

# Nóng hơn cả Mặt Trời

Trong khi lực hấp dẫn khổng lồ của Mặt Trời tự nhiên kích hoạt phản ứng nhiệt hạch, thì trên Trái Đất – **thiếu lực hấp dẫn này** – cần nhiệt độ **cao hơn cả lõi Mặt Trời** để phản ứng xảy ra.  
Cụ thể, chúng ta cần nhiệt độ trên **100 triệu độ C** để khiến deuteri và triti hợp nhất, đồng thời phải kiểm soát áp suất và lực từ tính để **giam giữ plasma ổn định** và duy trì phản ứng đủ lâu nhằm tạo ra **nhiều năng lượng hơn mức tiêu tốn để khởi động**.

Hiện nay, các thí nghiệm đã đạt được điều kiện rất gần với yêu cầu của lò phản ứng nhiệt hạch. Tuy nhiên, các nhà khoa học vẫn cần **cải thiện khả năng giam giữ và ổn định của plasma** để duy trì phản ứng lâu dài và tạo ra năng lượng bền vững.  
Các nhà khoa học và kỹ sư trên khắp thế giới tiếp tục nghiên cứu, phát triển **vật liệu mới** và thiết kế **công nghệ tiên tiến** nhằm đạt được mục tiêu **năng lượng nhiệt hạch ròng dương (net fusion energy)** trong tương lai.

# Công nghệ lò phản ứng

## Tokamak:

  * Sử dụng từ trường hình xuyến (donut) để giam giữ plasma siêu nóng.

  * Dự án tiêu biểu: ITER ở Pháp, hợp tác quốc tế với mục tiêu tạo ra 500 MW công suất từ 50 MW đầu vào.


## Stellarator:

  * Thiết kế từ trường xoắn phức tạp, giúp plasma ổn định hơn và vận hành liên tục.

  * Dự án: Wendelstein 7-X (Đức).


## Giam giữ quán tính (Inertial Confinement):

  * Sử dụng laser hoặc chùm ion cường độ cao nén viên nhiên liệu nhỏ đến mật độ cực lớn.

  * Dự án: National Ignition Facility (NIF) tại Mỹ, đã đạt bước đột phá “ignition” vào năm 2022.


## Khởi nghiệp thương mại:

  * Các công ty như Commonwealth Fusion Systems, Tokamak Energy, Helion Energy đang phát triển lò phản ứng nhỏ gọn, hứa hẹn thương mại hóa sớm hơn dự án quốc gia.


# Ưu điểm nổi bật

  * Nhiên liệu dồi dào: Deuterium có thể tách từ nước biển, tritium có thể sinh từ lithium – nguồn cung gần như vô hạn.

  * An toàn: Phản ứng dừng lại khi có sự cố, không xảy ra “meltdown” như phân hạch.

  * Không phát thải carbon: Gần như không tạo khí nhà kính.

  * Ít chất thải phóng xạ lâu dài: Vật liệu cấu trúc có thể tái chế sau vài thập kỷ.


# Thách thức kỹ thuật

  * Giam giữ plasma ổn định: Plasma ở 100 triệu °C khó kiểm soát, dễ gây nhiễu loạn.

  * Vật liệu chịu nhiệt và bức xạ: Tường buồng phản ứng phải chịu neutron năng lượng cao liên tục.

  * Hiệu suất kinh tế: Cần đạt “breakeven” – sản lượng năng lượng lớn hơn đầu vào – và chi phí cạnh tranh với điện gió, điện mặt trời.


# Tiến bộ gần đây

  * Kỷ lục NIF 2022: Lần đầu tiên năng lượng đầu ra lớn hơn đầu vào của laser, chứng minh tính khả thi của nhiệt hạch.

  * ITER: Dự kiến vận hành plasma đầu tiên vào cuối thập kỷ này, tạo nền tảng cho nhà máy điện thương mại.

  * Công nghệ nam châm siêu dẫn HTS: Cho phép tạo từ trường mạnh hơn, giảm kích thước lò tokamak và chi phí.


# Tác động kinh tế – xã hội

  * Nguồn năng lượng sạch toàn cầu: Có thể cung cấp điện liên tục 24/7, thay thế than, dầu, khí.

  * Giảm phụ thuộc nhiên liệu hóa thạch: Đảm bảo an ninh năng lượng quốc gia.

  * Ứng dụng khoa học: Plasma nhiệt hạch hỗ trợ nghiên cứu vật lý hạt, y học hạt nhân, và sản xuất vật liệu mới.

  * Thúc đẩy công nghệ cao: Từ siêu dẫn, vật liệu chịu nhiệt đến AI điều khiển plasma.


# Tương lai

Nếu các mục tiêu thương mại đạt được, trong vài thập kỷ tới, nhà máy nhiệt hạch có thể trở thành nguồn năng lượng chính của nhân loại. Sự kết hợp giữa AI điều khiển, vật liệu siêu bền, và máy tính lượng tử sẽ rút ngắn thời gian phát triển, đưa “mặt trời nhân tạo” từ phòng thí nghiệm ra thế giới.

# Public097

**Hydro (Hiđrô) – Nguyên tố đơn giản và phong phú nhất vũ trụ**

Hiđrô là nguyên tố đơn giản nhất và cũng phổ biến nhất trong vũ trụ. Nó là thành phần chính của **nước** , **dầu mỏ** , **khí tự nhiên** , và **mọi dạng sống**.  
Tuy nhiên, mặc dù rất đơn giản và phong phú, hiđrô hiếm khi tồn tại tự nhiên dưới dạng khí trên Trái Đất; nó gần như luôn **kết hợp với các nguyên tố khác**.

Hiđrô có thể được tạo ra từ:

  * **Dầu mỏ và khí tự nhiên**

  * **Sinh khối (biomass)**

  * Hoặc bằng cách **tách phân tử nước** (điện phân) sử dụng **năng lượng tái tạo** như điện mặt trời hay điện gió.


**Giải phóng năng lượng từ hiđrô**

Khi đã có hiđrô ở dạng phân tử (H₂), năng lượng chứa trong nó có thể được giải phóng bằng cách **phản ứng với oxy để tạo thành nước**. Việc này có thể thực hiện qua:

  * **Động cơ đốt trong truyền thống**

  * Hoặc **pin nhiên liệu (fuel cell)** : thiết bị chuyển đổi trực tiếp năng lượng của hiđrô thành **điện năng** với **hiệu suất cao** và **tổn thất năng lượng thấp**.


**Vai trò của hiđrô**

Do đó, **hiđrô là một chất mang năng lượng** – nó được dùng để **vận chuyển, lưu trữ và cung cấp năng lượng** được sản xuất từ các nguồn khác.  
Điều này khiến hiđrô trở thành một thành phần quan trọng trong các giải pháp năng lượng sạch và bền vững cho tương lai.

# Giới thiệu

Trong bối cảnh thế giới tìm kiếm giải pháp giảm phát thải carbon, hydro nổi lên như một nguồn năng lượng sạch đầy tiềm năng. Pin nhiên liệu hydro (Hydrogen Fuel Cell – HFC) chuyển hóa hydro và oxy thành điện năng, sản phẩm phụ duy nhất là nước tinh khiết, không thải khí CO₂.

Công nghệ này được kỳ vọng sẽ đóng vai trò quan trọng trong giao thông vận tải – từ xe hơi, xe tải, tàu biển đến hàng không – cũng như trong lưu trữ năng lượng quy mô lớn, góp phần hiện thực hóa mục tiêu trung hòa carbon toàn cầu.

# Nguyên lý hoạt động

  * Phản ứng điện hóa: Hydro (H₂) được đưa vào cực âm (anode), tách thành proton và electron.

  * Dòng electron: Electron di chuyển qua mạch ngoài, tạo ra dòng điện.

  * Tái hợp ở cực dương: Proton và electron kết hợp với oxy (O₂) tạo thành nước (H₂O).

  * Sản phẩm phụ: Chỉ có nước và nhiệt, hoàn toàn không phát thải carbon.


# Ưu điểm vượt trội

  * Không phát thải CO₂: Sản phẩm chỉ là nước, đáp ứng tiêu chuẩn khí thải nghiêm ngặt.

  * Năng lượng cao: Mật độ năng lượng của hydro cao hơn pin lithium-ion, thích hợp cho phương tiện di chuyển xa.

  * Sạc nhanh: Nạp hydro chỉ mất vài phút, tương tự tiếp nhiên liệu truyền thống.

  * Hoạt động trong điều kiện lạnh: Ít bị ảnh hưởng bởi nhiệt độ so với pin điện hóa thông thường.


# Ứng dụng trong giao thông

## Xe hơi và xe tải hạng nặng:

  * Các hãng như Toyota (Mirai), Hyundai (Nexo) đã thương mại hóa xe chạy pin nhiên liệu.

  * Xe tải đường dài của Nikola và Hyundai Xcient phục vụ vận tải xuyên quốc gia.


## Tàu biển:

  * Pin nhiên liệu cung cấp năng lượng cho tàu chở hàng, giảm ô nhiễm cảng biển.

  * Dự án Hydroville và các nghiên cứu của Maersk đang chứng minh tính khả thi.


## Hàng không:

  * Máy bay nhỏ chạy bằng pin nhiên liệu hydro đã bay thử nghiệm.

  * Các hãng như Airbus đặt mục tiêu ra mắt máy bay thương mại hydro vào năm 2035.


## Tàu hỏa và xe buýt đô thị:

  * Chạy tuyến dài, giảm tiếng ồn và không thải khí độc hại tại khu dân cư.


# Hạ tầng và công nghệ hỗ trợ

  * Sản xuất hydro xanh: Dùng điện tái tạo (gió, mặt trời) để điện phân nước, tạo hydro không phát thải.

  * Lưu trữ và vận chuyển: Công nghệ nén hoặc hóa lỏng hydro ở -253 °C, hoặc lưu trữ dưới dạng amoniac để dễ vận chuyển.

  * Trạm nạp hydro: Mạng lưới trạm tiếp nhiên liệu nhanh và an toàn, hiện đang mở rộng ở châu Âu, Mỹ, Nhật Bản.


# Thách thức hiện nay

  * Chi phí cao: Sản xuất hydro xanh và chế tạo pin nhiên liệu vẫn đắt hơn so với nhiên liệu hóa thạch.

  * Hạ tầng hạn chế: Số lượng trạm nạp hydro còn ít, khó đáp ứng nhu cầu đại trà.

  * Hiệu suất năng lượng: Quá trình sản xuất, lưu trữ, vận chuyển hydro làm giảm hiệu suất tổng thể so với điện trực tiếp.

  * An toàn: Hydro là khí nhẹ, dễ rò rỉ và dễ cháy, đòi hỏi quy trình lưu trữ nghiêm ngặt.


# Tiến bộ và triển vọng

  * Công nghệ điện phân giá rẻ: Giảm chi phí hydro xanh nhờ màng điện phân mới và năng lượng tái tạo rẻ hơn.

  * Pin nhiên liệu rắn: Tăng hiệu suất và độ bền.

  * Chính sách hỗ trợ: EU, Mỹ, Nhật, Hàn Quốc đầu tư hàng tỷ USD để phát triển “nền kinh tế hydro”.

  * Kết hợp với năng lượng tái tạo: Tận dụng hydro làm kho lưu trữ cho lưới điện gió và mặt trời.


# Tác động kinh tế – xã hội

  * Giảm phát thải giao thông: Đặc biệt quan trọng cho xe tải, tàu biển, hàng không – các lĩnh vực khó điện khí hóa hoàn toàn.

  * An ninh năng lượng: Giảm phụ thuộc vào dầu mỏ, tăng tính tự chủ năng lượng quốc gia.

  * Tạo việc làm công nghệ cao: Xây dựng trạm nạp, nhà máy hydro, và dây chuyền sản xuất pin nhiên liệu.


# Tương lai

Trong hai thập kỷ tới, khi chi phí hydro xanh giảm và hạ tầng mở rộng, pin nhiên liệu hydro có thể trở thành xương sống của giao thông sạch toàn cầu, bổ sung và cạnh tranh với xe điện pin lithium-ion, tạo ra hệ sinh thái năng lượng bền vững.

# Public098

# Giới thiệu

Siêu tụ điện (Supercapacitor hay Ultracapacitor) là thiết bị lưu trữ năng lượng điện hóa có khả năng sạc và xả cực nhanh, cung cấp công suất tức thì cao gấp nhiều lần pin truyền thống. Khác với pin lithium-ion vốn dựa trên phản ứng hóa học, siêu tụ điện lưu trữ năng lượng dưới dạng điện trường tĩnh, giúp chúng đạt tuổi thọ hàng triệu chu kỳ và hoạt động tốt trong dải nhiệt rộng.

Khi nhu cầu về giao thông bền vững tăng mạnh, siêu tụ điện trở thành giải pháp bổ sung hoặc thay thế pin trong xe điện, xe buýt đô thị, tàu điện, thậm chí máy bay cỡ nhỏ.

# Siêu tụ điện (Supercapacitors)

Siêu tụ điện là các thiết bị điện tử được dùng để **tích trữ lượng điện tích cực lớn**. Chúng còn được gọi là **tụ điện hai lớp (double-layer capacitors)** hoặc **ultracapacitors**.

## Cơ chế hoạt động

Khác với tụ điện thông thường sử dụng chất điện môi, siêu tụ điện lưu trữ năng lượng nhờ **hai cơ chế** :

  1. **Điện dung hai lớp (double-layer capacitance)** – có nguồn gốc **tĩnh điện**.

  2. **Giả điện dung (pseudocapacitance)** – có nguồn gốc **điện hóa học**.


Nhờ kết hợp cả hai, siêu tụ điện vừa hoạt động như **tụ điện** vừa giống **pin thông thường**.

## Thông số ấn tượng

  * **Điện dung cực lớn** : Có thể đạt tới **12.000 F**.

  * So sánh: **Điện dung tự thân của Trái Đất** chỉ khoảng **710 µF** , nhỏ hơn hơn 15 triệu lần so với một siêu tụ điện.

  * **Điện áp sạc tối đa** : Thường nằm trong khoảng **2,5 – 2,7 V** , thấp hơn so với tụ điện tĩnh điện thông thường.

  * **Tính phân cực** : Là thiết bị **có cực tính** , cần được đấu nối đúng chiều giống như tụ điện điện giải.


## Ứng dụng

Nhờ **tốc độ nạp và xả cực nhanh** , siêu tụ điện đặc biệt hữu ích trong các ứng dụng yêu cầu **cung cấp hoặc hấp thụ năng lượng tức thời**.  
Trong một số trường hợp, **siêu tụ điện có thể thay thế hoàn toàn pin** , đem lại ưu điểm về tuổi thọ cao và hiệu suất sạc/xả vượt trội.

# Nguyên lý hoạt động

  * Lớp điện kép (Electric Double-Layer): Năng lượng được lưu trữ nhờ sự tích tụ ion ở bề mặt điện cực, không xảy ra phản ứng hóa học.

  * Điện dung lớn: Vật liệu xốp như than hoạt tính, graphene tạo diện tích bề mặt khổng lồ, tăng khả năng tích điện.

  * Siêu tụ lai (Hybrid Supercapacitor): Kết hợp cơ chế tụ điện và pin để tăng mật độ năng lượng mà vẫn giữ khả năng sạc nhanh.


# Ưu điểm nổi bật

  * Sạc/xả cực nhanh: Chỉ vài giây đến vài phút để nạp đầy.

  * Tuổi thọ dài: Hơn 1 triệu chu kỳ, trong khi pin lithium-ion chỉ vài nghìn.

  * Công suất cao: Phát công suất lớn tức thì, lý tưởng cho các ứng dụng cần dòng điện đột ngột.

  * Hoạt động trong dải nhiệt rộng: -40 °C đến +65 °C mà ít suy giảm hiệu suất.

  * Bảo dưỡng thấp và an toàn: Không nguy cơ cháy nổ do phản ứng hóa học.


# Ứng dụng trong giao thông

  * Xe buýt điện đô thị: Siêu tụ điện sạc nhanh tại trạm dừng, đủ năng lượng cho chặng tiếp theo, giảm thời gian chờ.

  * Tàu điện và metro: Thu hồi năng lượng phanh (regenerative braking) và cung cấp công suất tăng tốc.

  * Xe hybrid và xe thể thao: Bổ sung năng lượng đột xuất khi tăng tốc, giảm tải cho pin chính.

  * Máy bay nhỏ và drone: Cung cấp công suất cao cho cất cánh, hạ cánh, và cơ động nhanh.

  * Xe đua Formula E: Sử dụng siêu tụ điện để lưu trữ và giải phóng năng lượng tái tạo từ phanh.


# Tích hợp với pin truyền thống

  * Hệ thống song song: Siêu tụ xử lý các xung công suất cao, trong khi pin đảm nhận lưu trữ năng lượng dài hạn.

  * Tăng tuổi thọ pin: Giảm căng thẳng dòng điện và nhiệt cho pin, kéo dài thời gian sử dụng.

  * Tối ưu hiệu suất năng lượng tái tạo: Kết hợp với pin lưu trữ trong lưới điện gió, mặt trời.


# Vật liệu tiên tiến

  * Graphene: Diện tích bề mặt lớn, dẫn điện cao, cải thiện đáng kể mật độ năng lượng.

  * Carbon aerogel: Khối lượng nhẹ, cấu trúc nano giúp tăng điện dung.

  * Siêu tụ điện lai lithium-ion: Kết hợp điện cực than hoạt tính và điện cực pin lithium để tăng mật độ năng lượng lên gần mức pin.


# Thách thức

  * Mật độ năng lượng thấp hơn pin: Hiện chỉ bằng khoảng 10–20% so với lithium-ion, hạn chế cho hành trình dài.

  * Chi phí vật liệu tiên tiến: Graphene chất lượng cao và quy trình sản xuất nano còn đắt đỏ.

  * Quản lý điện áp: Cần mạch điều khiển phức tạp để cân bằng và bảo vệ cell.


# Tác động kinh tế – xã hội

  * Giảm thời gian sạc phương tiện công cộng: Giúp xe buýt, tàu điện vận hành liên tục, giảm tắc nghẽn.

  * Bảo vệ môi trường: Tuổi thọ dài và khả năng tái chế tốt hơn pin hóa học, giảm rác thải độc hại.

  * Thúc đẩy công nghiệp vật liệu: Tạo động lực cho nghiên cứu graphene và công nghệ sản xuất nano.


# Tương lai

  * Siêu tụ năng lượng cao: Nghiên cứu vật liệu 2D và composite để đạt mật độ năng lượng gần ngang pin.

  * Sạc không dây công suất lớn: Hỗ trợ sạc nhanh cho xe điện đang di chuyển.

  * Kết hợp AI quản lý năng lượng: Tối ưu việc phân phối dòng điện giữa pin và siêu tụ, tăng hiệu suất toàn hệ thống.

  * Ứng dụng đại trà: Khi giá thành giảm, siêu tụ có thể trở thành giải pháp chính cho giao thông công cộng và thiết bị di động.

# Public099

# Giới thiệu

Sự bùng nổ của xe điện và lưu trữ năng lượng tái tạo khiến nhu cầu lithium tăng mạnh, kéo theo giá thành cao và rủi ro về nguồn cung. **Pin natri-ion (Sodium-Ion)** nổi lên như một giải pháp thay thế chiến lược nhờ **nguồn natri dồi dào** , giá rẻ và phân bố rộng rãi trên Trái Đất. Công nghệ này được xem là **lựa chọn quan trọng** để giảm phụ thuộc vào lithium và đáp ứng nhu cầu lưu trữ quy mô lớn cho lưới điện.

# Pin Natri-Ion (Sodium-Ion Battery) là gì?

Pin natri-ion là loại pin sử dụng **ion natri** (các hạt mang điện tích dương) thay vì **ion lithium** để lưu trữ và giải phóng năng lượng. Công nghệ này bắt đầu cho thấy tiềm năng thương mại từ những năm 1990 như một **giải pháp thay thế cho pin lithium-ion** , vốn đang phổ biến trong điện thoại và xe điện.

![Diagram showing negatively charged chlorine ions moving towards the ...](images/image1.jpeg)

# Cơ chế hoạt động của pin natri-ion

Giống như mọi loại pin, pin natri-ion (Na-ion) gồm ba thành phần chính:

  * **Cực dương và cực âm (cathode & anode)**

  * **Chất điện phân** : cho phép các ion (hạt mang điện tích) di chuyển giữa hai cực.


Pin natri-ion hoạt động tương tự pin lithium-ion, chỉ khác là **ion natri thay cho ion lithium**. Vật liệu làm **điện cực và điện phân** có ảnh hưởng lớn đến **hiệu suất và tuổi thọ** , nên các nhà nghiên cứu liên tục thử nghiệm các tổ hợp mới để tìm ra giải pháp tối ưu về **chi phí – hiệu năng – độ an toàn**. Thông thường, **cực dương (cathode)** và **chất điện phân** chứa natri.

![Sodium Ion Batteries UPSC.](images/image2.jpeg)

  * **Cấu trúc tương tự pin lithium-ion:** Bao gồm cực dương (cathode), cực âm (anode), chất điện phân và màng ngăn.

  * **Ion natri (Na⁺):** Di chuyển qua chất điện phân giữa hai cực trong quá trình sạc và xả.

  * **Khác biệt chính:** Bán kính ion natri lớn hơn lithium, đòi hỏi vật liệu điện cực và cấu trúc tối ưu để duy trì hiệu suất.


# Ưu điểm vượt trội

  * **Nguồn nguyên liệu dồi dào:** Natri chiếm ~2,3% lớp vỏ Trái Đất, khai thác rẻ hơn nhiều so với lithium.

  * **Chi phí thấp:** Giảm giá thành pin, đặc biệt quan trọng cho lưu trữ năng lượng lưới điện.

  * **Hiệu suất nhiệt độ thấp tốt:** Hoạt động ổn định ở môi trường lạnh hơn so với nhiều pin lithium-ion.

  * **Tính bền vững cao:** Giảm rủi ro địa chính trị liên quan đến khai thác lithium và cobalt.


# Ứng dụng

  * **Lưu trữ năng lượng tái tạo:** Dự trữ điện từ gió, mặt trời quy mô lớn với chi phí hợp lý.

  * **Xe điện đô thị:** Phù hợp cho xe tầm ngắn, xe máy điện, xe buýt thành phố.

  * **Thiết bị điện tử tiêu dùng:** Pin dự phòng, thiết bị IoT, nơi chi phí quan trọng hơn mật độ năng lượng.

  * **Lưới điện vi mô (Microgrid):** Giải pháp lưu trữ tại các vùng xa hoặc đảo, nơi cần chi phí thấp và tuổi thọ cao.


# Tiến bộ nghiên cứu

  * **CATL (Trung Quốc):** Giới thiệu pin natri-ion thương mại đầu tiên, mật độ năng lượng ~160 Wh/kg.

  * **Faradion (Anh):** Phát triển công nghệ an toàn, không cần hệ thống làm mát phức tạp.

  * **Hiện tượng kết hợp (Hybrid Systems):** Tích hợp natri-ion với lithium-ion để cân bằng chi phí và mật độ năng lượng.


# Thách thức

  * **Mật độ năng lượng thấp hơn lithium:** Hiện chỉ bằng 60–70% pin lithium-ion, hạn chế cho xe điện đường dài.

  * **Vật liệu điện cực:** Cần nghiên cứu anode/cathode mới để cải thiện dung lượng và tuổi thọ.

  * **Quy mô sản xuất:** Công nghệ mới, cần đầu tư lớn cho chuỗi cung ứng và nhà máy.

  * **Chuẩn hóa công nghiệp:** Chưa có tiêu chuẩn toàn cầu về kích thước và hiệu suất.


# Tác động kinh tế – xã hội

  * **Giảm phụ thuộc vào lithium và cobalt:** Giúp ổn định chuỗi cung ứng toàn cầu.

  * **Hạ giá thành lưu trữ năng lượng tái tạo:** Thúc đẩy điện gió, điện mặt trời, giảm phát thải carbon.

  * **Tạo việc làm mới:** Xây dựng nhà máy pin natri-ion và khai thác natri quy mô lớn.


# Tương lai

Trong 5–10 năm tới, khi công nghệ vật liệu cải thiện và quy mô sản xuất tăng, **pin natri-ion** có thể trở thành giải pháp chính cho lưu trữ năng lượng lưới điện và các phương tiện giao thông đô thị, bổ sung cho pin lithium-ion chứ không hoàn toàn thay thế.

# Public100

Trong các hệ thống công nghệ hiện đại, **máy móc có thể học về vị trí vật lý và thu thập dữ liệu** về cách con người di chuyển và hành xử trong không gian. Dữ liệu này được dùng để **tự động hóa và tối ưu hóa** nhiều nhiệm vụ của con người, tạo nền tảng cho sự phát triển của **công nghệ điện toán không gian (spatial computing)**.

Với sự hỗ trợ của công nghệ này, **máy tính và hệ thống có thể hòa nhập tự nhiên vào môi trường xung quanh**. Apple xem đây là **bước đột phá tiếp theo của ngành máy tính** , minh chứng qua việc tung ra **Apple Vision Pro** – hệ điều hành không gian và kính AR/VR tiên tiến.

# Giới thiệu

Điện toán không gian (Spatial Computing) là nền tảng kết hợp giữa thế giới vật lý và kỹ thuật số, cho phép con người tương tác với dữ liệu và môi trường ảo trong không gian 3D thực. Thay vì chỉ nhìn màn hình phẳng, người dùng trải nghiệm, thao tác và di chuyển trong môi trường số như thật.

Công nghệ này kết hợp thực tế ảo (VR), thực tế tăng cường (AR), cảm biến IoT, và AI nhận thức không gian, mở ra kỷ nguyên mới cho giáo dục, y tế, sản xuất, thương mại và giải trí.

# Spatial Computing là gì?

“Spatial computing” là khái niệm chỉ **giao diện người dùng ba chiều** , nơi công nghệ tạo ra một **lớp không gian số** để gửi và nhận dữ liệu, đồng thời tương tác với thế giới thực. Công nghệ này giúp con người **kết hợp thế giới số và thế giới thật** một cách tự nhiên, trực quan.

Spatial computing bao gồm nhiều công nghệ tiên tiến như:

  * **Thực tế hỗn hợp (Mixed Reality – MR)**

  * **Thực tế mở rộng (Extended Reality – XR)**

  * **Thực tế ảo (Virtual Reality – VR)**

  * **Thực tế tăng cường (Augmented Reality – AR)**


Trong nghiên cứu và phân tích không gian, phần mềm chuyên dụng có thể tạo **đồ thị không gian** từ các đỉnh (vertices) và cạnh (edges), phục vụ cho **hệ thống thông tin địa lý (GIS)** hay các phân tích dạng đồ thị.

# Cách hoạt động của Spatial Computing

  * **Computer Vision (Thị giác máy tính)** : Giúp phần mềm hiểu được nội dung hình ảnh, không chỉ dừng lại ở việc quét điểm ảnh.

  * **Machine Learning & AI**: Thu thập và phân tích dữ liệu không gian để phát hiện mẫu, tự động hóa quy trình và đưa ra phản hồi thông minh.

  * **Fusion of Sensors (Tích hợp cảm biến)** : Kết hợp dữ liệu từ nhiều cảm biến như camera, GPS để có thông tin đầy đủ.

  * **Spatial Mapping System** : Dùng dữ liệu từ camera/sensor để tạo **bản đồ 3D** của môi trường.

  * **Haptic System** : Phản hồi xúc giác (rung, chạm) giúp con người nhận biết tín hiệu từ thiết bị.

  * **Robotics System** : Robot sử dụng dữ liệu không gian để di chuyển, làm việc và hỗ trợ làm việc từ xa.

  * **Edge Computing** : Xử lý dữ liệu ngay tại “rìa” mạng, giảm phụ thuộc vào trung tâm dữ liệu.

  * **IoT (Internet of Things)** : Các thiết bị vật lý trong mạng nội bộ tận dụng dữ liệu không gian để hiểu môi trường và nâng cao trải nghiệm người dùng.


# Thiết bị đeo và Headset trong Spatial Computing

Headset là phần cứng quan trọng, **đeo quanh đầu và che mắt** , chiếu hình ảnh mô phỏng vào tầm nhìn. **Cảm biến chuyển động** nhận biết hướng nhìn để điều chỉnh hình ảnh theo thời gian thực.  
Các tính năng như **nhận diện giọng nói, cử chỉ tay, theo dõi ánh mắt** giúp tương tác tự nhiên hơn.

**Một số thiết bị tiêu biểu** :

  * **Microsoft HoloLens** : Công nghệ hologram tích hợp theo dõi mắt, giọng nói, cử chỉ và lập bản đồ không gian, phục vụ cộng tác doanh nghiệp.

  * **Apple Vision Pro** : Hệ điều hành không gian cho phép điều khiển bằng tay, mắt, giọng nói; hỗ trợ giải trí, ứng dụng, gọi video, trò chơi.

  * **Meta Quest Pro** : Kính MR cho trải nghiệm nhập vai trong game, giải trí, làm việc và kết nối cộng đồng.


# Thành phần cốt lõi

  * Thực tế ảo (VR): Tạo thế giới số hoàn toàn, người dùng nhập vai qua kính VR.

  * Thực tế tăng cường (AR): Chồng hình ảnh số lên môi trường thực, cho phép tương tác trực tiếp.

  * Cảm biến và định vị: Camera 3D, LiDAR, radar, GPS chính xác cao giúp ghi nhận chuyển động, cử chỉ và vị trí.

  * Điện toán biên (Edge Computing): Xử lý dữ liệu tại chỗ, giảm độ trễ cho trải nghiệm thời gian thực.

  * AI nhận thức không gian: Nhận diện đối tượng, lập bản đồ không gian, dự đoán hành vi.


# Ứng dụng tiêu biểu

  * Y tế và phẫu thuật từ xa: Bác sĩ thực hiện ca mổ trong môi trường 3D với dữ liệu bệnh nhân trực tiếp, hỗ trợ robot phẫu thuật.

  * Giáo dục và đào tạo: Lớp học ảo, thí nghiệm 3D, mô phỏng quy trình công nghiệp.

  * Công nghiệp và sản xuất: Hướng dẫn lắp ráp, bảo trì máy móc qua kính AR, giảm lỗi và tăng năng suất.

  * Kiến trúc và bất động sản: Trải nghiệm không gian ảo của tòa nhà trước khi xây dựng.

  * Thương mại và bán lẻ: Cửa hàng ảo cho phép khách hàng “thử” sản phẩm trong không gian thực của họ.

  * Giải trí và thể thao: Game nhập vai, buổi hòa nhạc ảo, sự kiện eSports sống động.


# Lợi ích kinh tế – xã hội

  * Tăng hiệu suất làm việc: Giảm thời gian thiết kế, thử nghiệm, đào tạo.

  * Tiết kiệm chi phí: Giảm nhu cầu di chuyển, vật liệu, và rủi ro khi mô phỏng quy trình phức tạp.

  * Tạo ngành nghề mới: Phát triển nội dung 3D, kỹ sư không gian ảo, thiết kế tương tác.

  * Nâng cao giáo dục và y tế: Cung cấp môi trường học tập và chăm sóc sức khỏe tiếp cận toàn cầu.


# Hạ tầng công nghệ

  * Thiết bị đeo: Kính AR/VR, găng tay xúc giác, bộ định vị toàn thân.

  * Mạng 5G/6G: Băng thông siêu cao, độ trễ thấp cho trải nghiệm mượt mà.

  * Điện toán đám mây: Lưu trữ và xử lý dữ liệu 3D khổng lồ.

  * Chuẩn dữ liệu mở: Tương thích đa nền tảng, cho phép chia sẻ và đồng bộ giữa các ứng dụng.


# Thách thức

  * Chi phí thiết bị: Kính VR/AR chất lượng cao vẫn đắt.

  * Độ trễ và băng thông: Cần mạng siêu tốc và hạ tầng mạnh để xử lý dữ liệu thời gian thực.

  * Quyền riêng tư và bảo mật: Dữ liệu vị trí và chuyển động cá nhân nhạy cảm, cần chính sách bảo vệ nghiêm ngặt.

  * Sáng tạo nội dung: Đòi hỏi kỹ năng thiết kế 3D và lập trình phức tạp.


# Xu hướng tương lai

  * Thiết bị nhẹ và gọn: Kính AR dạng kính mắt thông thường, pin lâu hơn.

  * Tích hợp AI và học máy: Tự động nhận diện và tái tạo môi trường thực với độ chính xác cao.

  * Tương tác đa giác quan: Hỗ trợ cảm giác chạm, âm thanh 3D, mùi hương.

  * Metaverse chuyên biệt: Ứng dụng cho giáo dục, y tế, thương mại chứ không chỉ giải trí.

  * Hợp tác từ xa nâng cao: Cuộc họp ảo với hình đại diện 3D chân thực, tăng tính kết nối toàn cầu.

# Public_101

# Phát biểu bài toán

Trong học sâu, một bài toán cơ bản là huấn luyện mô hình mạng nơ-ron sâu để tối ưu hóa tham số mô hình nhằm giảm thiểu hàm mất mát (loss function). Bài toán này được biểu diễn như sau:

$θ*=argminθL(θ)theta^{*} = argmin_{theta}{L(theta)}$

Trong đó:

  * $θtheta$: Là các tham số của mô hình

  * $L(θ)L(theta)$: Là hàm mất mát đo lường độ chênh lệch giữa dự đoán của mô hình và nhãn thực tế.


Thuật toán Stochastic Gradient Descent (SGD) thường được sử dụng để giải quyết bài toán trên bằng cách cập nhật các tham số dựa trên gradient của hàm mất mát theo công thức:

$$
θ←θ−η•∇L(θ)theta leftarrow  theta -  eta bullet nabla L(theta)
$$

Trong đó:

  * η: Tốc độ học (learning rate).

  * ∇L(θ): Gradient của hàm mất mát.


Thuật toán SGD (tuần tự) hoạt động theo các bước sau:

_Bước 1: Khởi tạo tham số ban đầu với giá trị ngẫu nhiên._

_Bước 2: Lặp lại qua các epoch:_

  * _Chia tập dữ liệu thành các batch nhỏ._

  * _Lặp qua từng batch:_

_\+ Tính gradient trên batch._

_\+ Cập nhật_


_Bước 3: Kết thúc khi số epoch đạt ngưỡng hoặc hàm mất mát không còn cải thiện._

Mã giả:

Initialize parameters θ
For epoch in range(max_epochs):
For batch in dataset:
Compute gradient: grad = ∇L(θ)
Update parameters: θ = θ - η * grad
End For
End For

Khi áp dụng thuật toán Stochastic Gradient Descent (SGD) để huấn luyện mô hình học sâu, việc tính toán gradient trên từng mini-batch giúp giảm tải so với Gradient Descent toàn bộ dữ liệu, nhưng vẫn đòi hỏi tài nguyên tính toán đáng kể. Đặc biệt, với các tập dữ liệu lớn và mô hình phức tạp, quá trình huấn luyện kéo dài do số lượng phép tính gradient tăng lên, làm chậm quá trình hội tụ và ảnh hưởng đến hiệu suất tổng thể.

Một máy tính đơn lẻ khó có thể đáp ứng được yêu cầu tính toán cao trong thời gian hợp lý, do hạn chế về năng lực xử lý và khả năng khai thác tài nguyên phần cứng. Do đó, cần có phương pháp song song hóa SGD để phân chia khối lượng công việc giữa nhiều tiến trình hoặc máy tính, tận dụng hiệu quả tài nguyên tính toán và giảm thời gian huấn luyện.

Báo cáo này tập trung nghiên cứu hai thiết kế song song chính trong song song hóa dữ liệu (Data Parallelism)—thiết kế tập trung và thiết kế phân tán. Mục tiêu là đánh giá hiệu suất huấn luyện, độ chính xác mô hình và khả năng mở rộng trong môi trường tính toán hiệu năng cao (HPC), từ đó cung cấp cái nhìn chi tiết về hai cách tiếp cận này.

# T **huật Toán Song Song**

Để tối ưu hóa thuật toán Stochastic Gradient Descent (SGD) trong môi trường phân tán, hai thiết kế song song chính được triển khai: Thiết kế tập trung (Centralized Design) và Thiết kế phân tán (Decentralized Design). Cả hai phương pháp nhằm mục tiêu giảm thời gian huấn luyện và đảm bảo độ chính xác mô hình.

## Thiết kế tập trung (Centralized Design)

Thiết kế tập trung dựa trên việc sử dụng một tiến trình trung tâm (master node) để quản lý toàn bộ quá trình huấn luyện. Master chịu trách nhiệm khởi tạo và điều phối các tham số mô hình, đồng thời nhận kết quả từ các tiến trình còn lại (worker nodes). Các worker thực hiện tính toán gradient cục bộ dựa trên phần dữ liệu được phân công, sau đó gửi kết quả này về master. Master sẽ tổng hợp thông tin từ các worker, cập nhật tham số mô hình, và phát truyền lại tham số đã cập nhật để tiếp tục vòng huấn luyện. Cách tiếp cận này giúp duy trì tính nhất quán của mô hình và đảm bảo quy trình huấn luyện được đồng bộ hóa.

**Luồng hoạt động:**

  * Master khởi tạo các tham số mô hình và phát truyền chúng đến các worker.

  * Mỗi worker huấn luyện trên dữ liệu của mình, tính toán gradient cục bộ và gửi kết quả về master.

  * Master tổng hợp gradient từ các worker, cập nhật tham số mô hình và truyền lại cho các worker.

  * Quá trình lặp lại cho đến khi hoàn tất số lượng epoch hoặc đạt điều kiện dừng.


**Mã giả** :

Master Node:

1\. Initialize model parameters θ.

2\. Broadcast θ to all worker nodes.

3\. Repeat for each epoch:

a. Gather gradients {∇L(θ)_i} from all worker nodes.

b. Compute weighted average of gradients:

∇L(θ) = Σ(w_i * ∇L(θ)_i) / Σ(w_i)

c. Update parameters: θ = θ - η * ∇L(θ).

d. Broadcast updated θ to all worker nodes.

4\. Output final model θ.

Worker Node:

1\. Receive initial model parameters θ from master.

2\. Repeat for each epoch:

a. Compute gradient ∇L(θ)_i on local dataset.

b. Send ∇L(θ)_i to master.

c. Receive updated θ from master.

3\. Terminate.

Thiết kế tập trung có ưu điểm lớn ở tính quản lý tập trung, giúp dễ triển khai và theo dõi trạng thái của toàn bộ hệ thống. Đây là phương pháp phù hợp khi số lượng worker nhỏ, do việc xử lý và tổng hợp thông tin ở master không gây quá tải. Tuy nhiên, nhược điểm chính là master dễ trở thành điểm cổ chai (bottleneck) khi số lượng worker lớn, dẫn đến hiệu suất giảm. Đồng thời, chi phí truyền thông giữa master và các worker tăng đáng kể khi số lượng tiến trình tăng, gây ảnh hưởng đến khả năng mở rộng của hệ thống.

## Thiết kế phân tán (Decentralized Design)

Thiết kế phân tán (Decentralized Design) loại bỏ hoàn toàn vai trò của master node, đảm bảo tất cả các tiến trình (nodes) tham gia bình đẳng vào quá trình tính toán và tổng hợp thông tin. Các nodes khởi tạo tham số mô hình giống nhau và thực hiện huấn luyện trên dữ liệu cục bộ. Thông qua cơ chế Allgather, các nodes chia sẻ gradient hoặc trọng số với nhau, sau đó mỗi node tính toán giá trị trung bình từ thông tin thu thập được để cập nhật tham số mô hình. Cách tiếp cận này tạo ra một quy trình đồng đẳng, trong đó các tiến trình hoạt động độc lập nhưng vẫn duy trì tính nhất quán của mô hình.

**Luồng hoạt động** :

1\. Tất cả các nodes khởi tạo tham số mô hình giống nhau.

2\. Mỗi node huấn luyện trên tập dữ liệu cục bộ, tính toán gradient.

3\. Các nodes sử dụng Allgather để chia sẻ gradient hoặc trọng số.

4\. Mỗi node cập nhật tham số mô hình dựa trên giá trị trung bình thu thập được.

5\. Quá trình lặp lại cho đến khi hoàn tất.

**Mã giả** :

All Nodes:

1\. Initialize model parameters θ.

2\. Repeat for each epoch:

a. Compute gradient ∇L(θ)_i on local dataset.

b. Share gradients using Allgather.

c. Compute average gradient:

∇L(θ) = Σ(∇L(θ)_i) / N

(where N is the number of nodes).

d. Update parameters: θ = θ - η * ∇L(θ).

3\. Output final model θ.

Thiết kế phân tán có ưu điểm vượt trội trong việc loại bỏ điểm cổ chai (bottleneck) thường gặp ở master node, giúp cải thiện khả năng mở rộng khi số lượng nodes tăng. Các nodes hoạt động đồng đẳng, không phụ thuộc vào một trung tâm, từ đó tăng tính linh hoạt và khả năng chịu lỗi của hệ thống. Tuy nhiên, nhược điểm lớn nhất của thiết kế này là chi phí truyền thông cao hơn, do tất cả các nodes đều phải chia sẻ thông tin với nhau. Đồng thời, việc triển khai và đồng bộ hóa các nodes cũng phức tạp hơn, đặc biệt trong các hệ thống lớn và đa dạng về tài nguyên.

# Public_102

## 1\. Định nghĩa

![A diagram of a network AI-generated content may be incorrect.](images/image1.png)

Hình 1. Linear-Chain CRFs dạng factor với các ô vuông là các hàm phụ thuộc giữa các nút

Gọi X là biến ngẫu nhiên đại diện cho chuỗi dữ liệu đầu vào cần được gán nhãn, Y là biến ngẫu nhiên đại diện cho chuỗi nhãn tương ứng với chuỗi dữ liệu X. Tất cả các thành phần $YiY_{i}$ của Y thuộc một tập nhãn hữu hạn $𝒴mathcal{Y}$ (tập các nhãn có thể có). $ΩxOmega_{x}$ là các trường hợp có thể có của chuỗi X, $ΩyOmega_{y}$ là các trường hợp có thể có của chuỗi nhãn Y.

Giả định cả X và Y đều được coi là biến ngẫu nhiên phân phối chung (jointly distributed), nghĩa là chúng có mối liên hệ xác suất với nhau, và xác suất $P(X,Y)P(X,Y)$ là dương nghiêm ngặt ($P(X=x,Y=y)>0,∀x,yP(X =  x,Y = y) > 0, forall x, y$).

CRFs [8] là một mô hình phân biệt, tập trung vào việc xây dựng mô hình xác suất có điều kiện P(Y|X). CRFs dự đoán chuỗi nhãn Y dựa trên chuỗi dữ liệu X đã cho. CRFs không cố gắng mô hình hóa xác suất của X (tức là P(X)), mà chỉ quan tâm đến xác suất của Y khi biết X.

Định nghĩa: Cho đồ thị $G=(V,E)G = (V,E)$ sao cho $Y=(Yv)v∈VY = left( Y_{v} right)_{v  in  V}$, nghĩa là $YY$ được chỉ mục hóa theo các đỉnh của đồ thị $GG$. Khi đó, cặp $(X,Y)(X,Y)$ là một trường ngẫu nhiên điều kiện (conditional random fields - CRFs) trong trường hợp, khi biết $XX$, các biến ngẫu nhiên $YvY_{v}$​ thỏa mãn tính chất Markov đối với đồ thị:

$$
P(Yv|X,Yw,w≠v)=P(Yv|X,Yw,w∼v)Pleft( Y_{v} middle| X, Y_{w},w neq v right) =  Pleft( Y_{v} middle| X, Y_{w},wsim v right)
$$

trong đó $w∼vwsim v$ có nghĩa là $ww$ và $vv$ là các đỉnh kề nhau trong đồ thị $GG$. Hay nói cách khác trạng thái của các đỉnh trong đồ thị chỉ phụ thuộc vào các điểm lân cận.

=> CRFs là một trường hợp đặc biệt của MRF, trong có các nút có thể chia thành 2 tập riêng biệt X, Y. Và xác suất của chuỗi nhãn Y được xác định dựa trên toàn bộ chuỗi quan sát X. Do X là các biến quan sát lên cấu trúc đồ thị của X là tùy ý và Y và các biến y ∈ Y có thể phụ thuộc vào bất kì biến nào trong X.

Trong trường hợp CRFs có X, Y là các chuỗi X = (X1, …, Xn), Y = (Y1,…, Yn) và đồ thị G là cây mà các đỉnh có bậc không quá 2 (chuỗi tuyến tính) thì được gọi là trường ngẫu nhiên có điều kiện tuyến tính (Linear-Chain CRFs).

![A diagram of a network AI-generated content may be incorrect.](images/image2.png)

Hình 2. Ví dụ minh họa Linear-Chain CRFs trong bài toán gán nhãn thực thể có tên

Hình 2 là một ví dụ về Linear-Chain CRFs được sử dụng trong bài toán gán nhãn thực thể có tên (tìm xem từ nào là tên riêng – PER, từ nào là tên địa danh – LOC). Ở đây, các từ trong câu đầu vào cần được gán nhãn sẽ có vai trò là chuỗi X, các nhãn cần được gán cho từng từ trong câu đầu vào sẽ là chuỗi Y. Các nhãn này sẽ nhận một trong các giá trị: PER-Tên riêng, LOC-Địa điểm, O-Không xác định. Theo tích chất Markov thì nhãn của từ hiện tại chỉ phụ thuộc vào nhãn trước, nhãn sau và câu đầu vào.

## 2\. Xây dựng mô hình xác suất P(Y|X) 

Với giả định $P(X=x,Y=y)P(X =  x,Y = y)$ là dương nghiêm ngặt, theo định lý Hammersley–Clifford [9], ta có:

$$
E(x,y)=−∑ci∈Cfi(ci)E(x,y) =   - sum_{c_{i} in C}^{}f_{i}left( c_{i} right)
$$

$$
P(X=x,Y=y)=1Ze−E(x,y)P(X =  x,Y = y) =  frac{1}{Z}e^{- E(x,y)}
$$

$$
Z=∑x∈Ωx,y∈Ωye−E(x,y){Z =  sum_{x  in  Omega_{x}, y  in  Omega_{y}}^{}e^{- E(x,y)}}
$$

Trong đó C là tập tất cả các nhóm đầy đủ của đồ thị G (một **nhóm đầy đủ** trong đồ thị vô hướng là một tập hợp các đỉnh mà giữa tất cả các cặp đỉnh trong tập hợp đó đều tồn tại một cạnh), $fif_{i}$ là hàm năng lượng của cụm $cic_{i}$ chỉ ra khả năng xảy ra các mối quan hệ trong cụm. Z là hằng số chuẩn hóa để tạo phân phối xác suất hợp lệ (<1). $E(x,y)E(x,y)$ là hàm năng lượng được sử dụng để đánh giá mức độ "tốt" của một cặp giá trị $(x,y)(x,y)$ cụ thể của các biến ngẫu nhiên X, Y. Cặp giá trị $(x,y)(x,y)$ có $E(x,y)E(x,y)$ thấp hơn được coi là tốt hơn.

Dựa vào công thức trên kết hợp định lý Bayes, ta suy ra phân phối của chuỗi nhãn Y khi biết X có dạng sau:

$$
P(Y=y|X=x)=P(Y=y,X=x)P(X=x)=e−E(x,y)Z∑y′∈Ωye−E(x,y′)ZPleft( Y = y middle| X =  x right) =  frac{P(Y = y,X =  x)}{P(X =  x)} =  frac{frac{e^{- E(x,y)}}{Z}}{frac{sum_{y^{'} in  Omega_{y}}^{}e^{- Eleft( x,y^{'} right)}}{Z}}
$$

$=e−E(x,y)Z(x)=  frac{e^{- E(x,y)}}{Z(x)}$
$$
=exp(∑ci∈Cfi(ci))Z(x)=   frac{expleft( sum_{c_{i} in C}^{}f_{i}left( c_{i} right) right)}{Z(x)}
$$

$$
Z(x)=∑y′∈Ωye−E(x,y′)Z(x) =  sum_{y^{'} in  Omega_{y}}^{}e^{- E(x,y')}
$$

Với Linear-Chain CRFs, tập các cụm là 2 đỉnh của các cạnh và các đỉnh lẻ, khi đó, ta có:

$$
E(x,y)=−(∑(i−1,i)∈Ef(yi−1,yi,x,i)+∑yi∈yg(yi,x,i))E(x,y) =   - left( sum_{(i - 1, i) in E}^{}fleft( y_{i - 1}, y_{i}, x,i right) +  sum_{y_{i} in y}^{}gleft( y_{i}, x,i right) right)
$$

Để đơn giản, ta thêm 2 nhãn vào đầu và cuối chuỗi nhãn: Y0 = <Start>. Trong Linear-Chain CRFs, hàm năng lượng cho các cạnh là tổng hợp các hàm đặc trưng cạnh $fkf_{k}$ và hàm năng lượng cho đỉnh là tổng hợp các hàm đặc trưng của đỉnh $gkg_{k}$.

$$
E(x,y)=−(∑i=1n∑kλkfk(yi−1,yi,x,i)+∑i=1n∑kμkgk(yi,x,i))E(x,y) =   - left( sum_{i = 1}^{n}{sum_{k}^{}{lambda_{k} f_{k}left( y_{i - 1}, y_{i}, x,i right)}} +  sum_{i = 1}^{n}{sum_{k}^{}{mu_{k} g_{k}left( y_{i}, x,i right)}} right)
$$

$$
pθ(Y=y|X=x)=exp(∑i=1n∑kλkfk(yi−1,yi,x,i)+∑i=1n∑kμkgk(yi,x,i))Zθ(x)p_{theta}left( Y = y middle| X =  x right) =   frac{expleft( sum_{i = 1}^{n}{sum_{k}^{}{lambda_{k} f_{k}left( y_{i - 1}, y_{i}, x,i right)}} +  sum_{i = 1}^{n}{sum_{k}^{}{mu_{k} g_{k}left( y_{i}, x,i right)}} right)}{Z_{theta}(x)}
$$

$$
Zθ(x)=∑y′∈Ωyexp(∑i=1n∑kλkfk(y′i−1,y′i,x,i)+∑i=1n∑kμkgk(y′i,x,i))Z_{theta}(x) =  sum_{y^{'} in  Omega_{y}}^{}{expleft( sum_{i = 1}^{n}{sum_{k}^{}{lambda_{k} f_{k}left( {y'}_{i - 1}, {y'}_{i}, x,i right)}} +  sum_{i = 1}^{n}{sum_{k}^{}{mu_{k} g_{k}left( {y'}_{i}, x,i right)}} right)}
$$

Các hàm đặc trưng $fkf_{k}$và $gkg_{k}$ được cho trước và cố định, thường là chỉ báo cho 1 đặc trưng ví dụ 1 hàm đặc trưng sẽ trả về giá trị 1 khi $XiX_{i}$ viết hoa chữ cái đầu và $YiY_{i}$ có nhãn là “N” ngược lại sẽ trả về 0.

Trọng số $λklambda_{k}$, $μkmu_{k}$ của hàm đặc trưng là một hệ số điều chỉnh mức độ ảnh hưởng của hàm đặc trưng đến năng lượng của cấu hình. Trọng số càng cao, hàm đặc trưng càng có ảnh hưởng lớn đến xác suất của chuỗi nhãn.

## 3\. Linear-Chain CRFs dạng ma trận 

Giả sử, $$
𝒴={C1,…,Cl}mathcal{Y} =  left{ C_{1},ldots,C_{l} right}
$$, $$
𝒴′=𝒴∪{<Start>}mathcal{Y}^{'} =  mathcal{Y cup}left{ < Start > right}
$$. Xác xuất có điều kiện của chuỗi Y có thể được biểu diễn dưới dạng ma trận. Tại mỗi vị trí i trong chuỗi quan sát x, ta định nghĩa một ma trận biến ngẫu nhiên kích thước $$
|𝒴′|×|𝒴′|left| mathcal{Y'} right| times left| mathcal{Y'} right|
$$, $$
Mi(x)=[Mi(Cj,Ck|x)],Cj,Ck∈𝒴M_{i}(x) =  leftlbrack M_{i}left( C_{j},C_{k} middle| x right) rightrbrack,  C_{j},C_{k} in  mathcal{Y}
$$.

Mỗi phần tử $Mi(Cj,Ck|x)M_{i}left( C_{j},C_{k} middle| x right)$ đại diện cho một giá trị xác suất chưa chuẩn hóa. $Mi(x)M_{i}(x)$ là biến ngẫu nhiên mà giá trị phụ thuộc vào chuỗi quan sát X.

$$
Mi(Cj,Ck|x)=exp(∑kλkfk(Yi−1=Cj,yi=Ck,x,i)+∑kμkgk(Yi=Cj,x,i))M_{i}left( C_{j},C_{k} middle| x right)  =  expleft( sum_{k}^{}{lambda_{k}f_{k}left( Y_{i - 1} = C_{j}, y_{i} = C_{k}, x,i right)} +  sum_{k}^{}{mu_{k}g_{k}left( Y_{i} = C_{j}, x,i right)} right)
$$

Với cách biểu diễn trên, $Zθ(x)Z_{theta}(x)$ có thể viết lại dưới dạng sau với $1|𝒴′|×11_{left| mathcal{Y'} right| times 1}$ là ma trận kích thước $|𝒴′|left| mathcal{Y'} right|$ hàng và 1 cột có các giá trị bằng 1:

$$
Zθ(x)=(M1(x)×M2(x)×...×Mn+1×1|𝒴′|×1)0,0Z_{theta}(x) =  left( M_{1}(x) times M_{2}(x) times ... times {M_{n + 1} times 1}_{left| mathcal{Y'} right| times 1} right)_{0,0}
$$

Công thức xác suất có điều kiện có thể biểu diễn dưới dạng ma trận:

$$
pθ(Y=y|X=x)=∏i=1nMi(yi−1,yi|x)((∏i=1nMi(x))×1|𝒴′|×1)0,0p_{theta}left( Y = y middle| X =  x right) =   frac{prod_{i = 1}^{n}{M_{i}left( y_{i - 1},y_{i} middle| x right)}}{left( left( prod_{i = 1}^{n}{M_{i}(x)} right){times 1}_{left| mathcal{Y'} right| times 1} right)_{0, 0}}
$$

Biểu diễn này hữu ích trong việc huấn luyện và suy luận mô hình CRFs.

![A diagram of a graph AI-generated content may be incorrect.](images/image3.png)

Hình 3. Linear-Chain CRFs biều diễn dưới dạng factor với các factor được coi là ma trận chuyển đổi

Hình 3 là một ví dụ mình họa của linear-Chain CRFs biểu diễn dưới dạng factor cho bài toán POS tiếng Việt (gán nhãn động từ - v, danh từ - n, đại từ - p, trạng từ - d). Ở đây, câu đầu vào có 5 từ và mỗi 1 từ sẽ được gán nhãn từ loại tương ứng. Chuỗi từ loại chính là chuỗi Y. Giữa mỗi cặp nhãn cần gán kề nhau sẽ có một ma trận thể hiện khả năng mà giá trị nhán được gán khi biết nhãn của từ liền kề.

# Public_103

  1. **Giải thích:**


Tương tự CRFs, Linear-Chain CRFs phân loại chuỗi dựa trên xác suất $P(Y|X)Pleft( Y middle| X right)$. Với chuỗi x cho trước, CRFs sẽ tìm ra chuỗi y sao cho xác suất $P(Y=y|X=x)Pleft( Y = y middle| X =  x right)$ là lớn nhất.

$$
ŷ=argmaxyP(y|x)widehat{y} =  {argmax}_{y} Pleft( y middle| x right)
$$

Xác suất $P(Y|X)Pleft( Y middle| X right)$ được xây dựng thông qua việc định nghĩa các hàm đặc trưng $fkf_{k}$và $gkg_{k}$ và xác định giá trị $λklambda_{k}$, $μkmu_{k}$. Các trọng số được tối ưu trong quá trình huấn huyện với tập dữ liệu huấn luyện. Nói cách khác, quá trình huấn luyện CRFs là quá trình học phân phối xác suất $P(Y|X)Pleft( Y middle| X right)$ của tập dữ liệu huấn luyện.

Việc tối ưu hóa các trọng số $$
θ=(λ1,…,λk;μ1,…,μk)theta = (lambda_{1}, ldots,lambda_{k};mu_{1},ldots,mu_{k})
$$ tương đương với việc tìm kiếm hàm năng lượng tối ưu cho mô hình. Mô hình CRFs sẽ điều chỉnh các trọng số để hàm đặc trưng phản ánh chính xác mối quan hệ giữa chuỗi quan sát và chuỗi nhãn, từ đó đưa ra dự đoán chính xác nhất. Do đó, hàm đặc trưng đóng vai trò then chốt trong việc xác định mối quan hệ giữa chuỗi quan sát x và chuỗi nhãn y. Việc lựa chọn và thiết kế hàm đặc trưng phù hợp với bài toán cụ thể là rất quan trọng để đảm bảo mô hình có thể học được các mẫu quan trọng từ dữ liệu và đưa ra dự đoán chính xác.

### 2\. Huấn luyện 

Việc huấn luyện thường sử dụng phương pháp MLE (Maximum Likelihood Estimation) để tối ưu hóa các trọng số $$
θ=(λ1,…,λk;μ1,…,μk)theta = (lambda_{1}, ldots,lambda_{k};mu_{1},ldots,mu_{k})
$$ từ tập huấn luyện $$
D={(x(𝕚),y(𝕚))}i=1ND = left{ left( x^{(mathbb{i})},y^{(mathbb{i})} right) right}_{i = 1}^{N}
$$. Mục tiêu của quá trình huấn luyện là tìm ra bộ trọng số $θtheta$ để hàm mục tiêu log-likelihood $L(θ)L(theta)$ là lớn nhất.

$$
L(θ)=∑i=1Nlog(Pθ(y(𝕚)|x(𝕚)))L(theta) = sum_{i = 1}^{N}{logleft( P_{theta}left( y^{(mathbb{i})} middle| x^{(mathbb{i})} right) right)}
$$

$$
=∑i=1N(∑t=1n(∑kλkfk(yt−1(i),yt(i),x(𝕚),t)+∑kμkgk(yt(i),x(𝕚),t))−log(Zθ(x(𝕚))))=  sum_{i = 1}^{N}left( sum_{t = 1}^{n}left( sum_{k}^{}{{lambda_{k}f}_{k}left( y_{t - 1}^{(i)}, y_{t}^{(i)}, x^{(mathbb{i})},t right)} + sum_{k}^{}{mu_{k}g_{k}left( y_{t}^{(i)}, x^{(mathbb{i})},t right)} right)  -  logleft( Z_{theta}left( x^{(mathbb{i})} right) right) right)
$$

Việc tối ưu hóa hàm mục tiêu có thể sử dụng các phương pháp tối ưu dựa trên việc tính gradient như Gradient Descent, Stochastic Gradient Descent (SGD), L-BFGS (Limited-memory BFGS). Do đó chúng ta cần tính gradient của $L(θ)L(theta)$.

$$
∂L∂λk=∑i=1N(∑t=1nfk(yt−1(i),yt(i),x(𝕚),t)−1Zθ(x(𝕚))∂Zθ∂λk)frac{partial Ltext{  }}{text{ }partiallambda_{ktext{  }}} = text{ }sum_{i = 1}^{N}left( sum_{t = 1}^{n}{f_{k}left( y_{t - 1}^{(i)}, y_{t}^{(i)}, x^{(mathbb{i})},t right)}  -  frac{1}{Z_{theta}left( x^{(mathbb{i})} right)}frac{partial Z_{theta}}{partiallambda_{ktext{  }}} right)
$$

$$
1Zθ(x(𝕚))∂Zθ∂λk=1Zθ(x(𝕚))∑y′∈Ωy(∑t=1nfk(y′t−1,y′t,x(𝕚),t)e−E(x(𝕚),y′))frac{1}{Z_{theta}left( x^{(mathbb{i})} right)}frac{partial Z_{theta}text{  }}{text{ }partiallambda_{ktext{  }}} = frac{1}{Z_{theta}left( x^{(mathbb{i})} right)}sum_{y^{'} in  Omega_{y}}^{}left( sum_{t = 1}^{n}{f_{k}left( {y'}_{t - 1}, {y'}_{t}, x^{(mathbb{i})},t right)}e^{- Eleft( x^{(mathbb{i})},y^{'} right)} right)
$$

$$
=∑y′∈Ωy(∑t=1nfk(y′t−1,y′t,x(𝕚),t)e−E(x(𝕚),y′)Zθ(x(𝕚)))= sum_{y^{'} in  Omega_{y}}^{}left( sum_{t = 1}^{n}{f_{k}left( {y'}_{t - 1}, {y'}_{t}, x^{(mathbb{i})},t right)}frac{e^{- Eleft( x^{(mathbb{i})},y^{'} right)}}{Z_{theta}left( x^{(mathbb{i})} right)} right)
$$
$$
=∑y′∈Ωy(∑t=1nfk(y′t−1,y′t,x(𝕚),t)P(y′|x(𝕚)))= sum_{y^{'} in  Omega_{y}}^{}left( sum_{t = 1}^{n}{f_{k}left( {y'}_{t - 1}, {y'}_{t},x^{(mathbb{i})},t right)}Pleft( y' middle| x^{(mathbb{i})} right) right)
$$
$$
=∑t=1n∑y′∈Ωyfk(y′t−1,y′t,x(𝕚),t)P(y′|x(𝕚))=  sum_{t = 1}^{n}{sum_{y^{'} in  Omega_{y}}^{}{f_{k}left( {y'}_{t - 1}, {y'}_{t},x^{(mathbb{i})},t right)Pleft( y' middle| x^{(mathbb{i})} right)}}
$$

$$
⇒∂L∂λk=∑i=1N∑t=1n(fk(yt−1(i),yt(i),x(𝕚),t)−∑y′∈Ωyfk(y′t−1,y′t,x(𝕚),t)P(y′|x(𝕚)))Rightarrow frac{partial Ltext{  }}{text{ }partiallambda_{ktext{  }}} = text{ }sum_{i = 1}^{N}{sum_{t = 1}^{n}left( f_{k}left( y_{t - 1}^{(i)}, y_{t}^{(i)}, x^{(mathbb{i})},t right) - sum_{y^{'} in  Omega_{y}}^{}{f_{k}left( {y'}_{t - 1}, {y'}_{t}, x^{(mathbb{i})},t right)Pleft( y^{'} middle| x^{(mathbb{i})} right)} right)}
$$

Gọi $Ex(fk)E_{x}left( f_{k} right)$ là kì vòng hàm đặc trưng $fkf_{k}$ theo phân phối xác suất $P(y|x)Pleft( y middle| x right)$:

$$
Ex(fk)=∑t=1n∑y′∈Ωyfk(y′t−1,y′t,x(𝕚),t)P(y′|x(𝕚))E_{x}left( f_{k} right) =  sum_{t = 1}^{n}{sum_{y^{'} in  Omega_{y}}^{}{f_{k}left( {y'}_{t - 1}, {y'}_{t}, x^{(mathbb{i})},t right)Pleft( y^{'} middle| x^{(mathbb{i})} right)}}
$$

$$
⇒∂L∂λk=∑i=1N(∑t=1nfk(yt−1(i),yt(i),x(𝕚),t)+Ex(i)(fk))Rightarrow frac{partial Ltext{  }}{text{ }partiallambda_{ktext{  }}} = text{ }sum_{i = 1}^{N}left( sum_{t = 1}^{n}{f_{k}left( y_{t - 1}^{(i)}, y_{t}^{(i)}, x^{(mathbb{i})},t right)} +  E_{x^{(i)}}left( f_{k} right) right)
$$

Tương tự ta cũng có gradient cho $μkmu_{k}$:

$$
Ex(gk)=∑t=1n∑y′∈Ωygk(y′t,x(𝕚),t)P(y′|x(𝕚))E_{x}left( g_{k} right) =  sum_{t = 1}^{n}{sum_{y^{'} in  Omega_{y}}^{}{g_{k}left( {y'}_{t}, x^{(mathbb{i})},t right)Pleft( y^{'} middle| x^{(mathbb{i})} right)}}
$$

$$
∂L∂μk=∑i=1N(∑t=1ngk(yt(i),x(𝕚),t)+Ex(i)(gk))frac{partial Ltext{  }}{text{ }partialmu_{k}} = text{ }sum_{i = 1}^{N}left( sum_{t = 1}^{n}{g_{k}left( y_{t}^{(i)}, x^{(mathbb{i})},t right)} +  E_{x^{(i)}}left( g_{k} right) right)
$$

Nếu tính trực tiếp kì vọng của các hàm đặc trưng từ công thức trên thì độ phức tạp tính toán sẽ là hàm mũ $$
(O(n×|𝒴|n))left( Oleft( n times left| mathcal{Y} right|^{n} right) right)
$$. Do đó không khả thi khi số lượng nhãn và bộ dữ liệu lớn. Để giảm độ phức tạp tính toán ta biến đổi công thức trên thành dạng sau:

$$
Ex(fk)=∑t=1n∑y′∈Ωyfk(y′t−1,y′t,x(𝕚),t)P(y′|x(𝕚))E_{x}left( f_{k} right) =  sum_{t = 1}^{n}{sum_{y^{'} in  Omega_{y}}^{}{f_{k}left( {y'}_{t - 1}, {y'}_{t}, x^{(mathbb{i})},t right)Pleft( y^{'} middle| x^{(mathbb{i})} right)}}
$$
$$
=∑t=1n∑y′,y″∈𝒴fk(y′,y″,x(𝕚),t)P(Yt−1=y′,Yt=y″|x(𝕚))= sum_{t = 1}^{n}{sum_{y^{'}, y^{''} in  mathcal{Y}}^{}{f_{k}left( y', y'', x^{(mathbb{i})},t right)Pleft( Y_{t - 1} = y^{'}, Y_{t} = y'' middle| x^{(mathbb{i})} right)}}
$$

Trong đó $$
P(Yt−1=y′,Yt=y″|x(𝕚))Pleft( Y_{t - 1} = y^{'}, Y_{t} = y'' middle| x^{(mathbb{i})} right)
$$ là xác xuất biên của $Yt−1=y′,Yt=y″Y_{t - 1} = y^{'}, Y_{t} = y''$ khi biết chuỗi quan sát $x(𝕚)x^{(mathbb{i})}$, tức xác suất để cặp nhãn $(y′,y″)(y', y'')$ được gán tại vị trí t-1 và t khi biết $x(𝕚)x^{(mathbb{i})}$ mà không quan tâm đến các nhãn còn lại. Xác suất biên này có thể được tính trong thời gian đa thức bằng thuật toán Forward-Backward.

Tương tự cho $μkmu_{k}$:

$$
Ex(gk)=∑t=1n∑y′∈𝒴gk(y′,x(𝕚),t)P(Yt=y′|x(𝕚))E_{x}left( g_{k} right) =  sum_{t = 1}^{n}{sum_{y^{'} in  mathcal{Y}}^{}{g_{k}left( y', x^{(mathbb{i})},t right)Pleft( Y_{t} = y^{'} middle| x^{(mathbb{i})} right)}}
$$

### 3\. Thuật toán Forward-Backward áp dụng trong tính gradient

![A diagram of a network AI-generated content may be incorrect.](images/image1.png)

Hình 3.1. Minh họa thuật toán Forward-Backward trong việc xác suất biên tại 1 nút

Ý tưởng của thuật toán Forward-Backward là tính xác suất biên dựa vào việc tính xác suất tiến $αi(x)alpha_{i}(x)$ và xác suất lùi $βi(x)beta_{i}(x)$. Hình 8 mô tả ý tưởng tính xác suất biên $P(Y2=v|x)Pleft( Y_{2} =  v middle| x right)$ và hình 9 mô tả ý tưởng cách tính xác suất biên $$
P(Yt−1=y′,Yt=y″|x)Pleft( Y_{t - 1} = y^{'}, Y_{t} = y'' middle| x right)
$$ cho bài toán POS. Mỗi một đường đi từ <S> đến <T> là 1 trường hợp của chuỗi Y. Trọng số của của mỗi cạnh được tính theo công thức $Mi(Cj,Ck|x)M_{i}left( C_{j},C_{k} middle| x right)$ đã trình bày ở phần trước thể hiện khả năng nhãn của từ liền kề khi biết trước nhãn, trọng số của 1 đường đi là tích các trọng số cạnh mà đường đi qua.

$$
pθ(Y=y|X=x)=pθ(pathy|X=x)=TrọngsốcủapathyZθ(x)p_{theta}left( Y = y middle|  X = x right) =  p_{theta}left( path_{y} middle|  X = x right) =  frac{Trọng số của path_{y}}{Z_{theta}(x)}
$$

Xác suất biên $P(Y2=v|x)Pleft( Y_{2} =  v middle| x right)$ sẽ là tổng xác suất của tất cả các đường đi đi qua v tại $Y2Y_{2}$ hay tổng trọng số các đường đi đó. Ta có thể phân tích tổng này thành tích của 2 tổng $α2(v|x)alpha_{2}left( v middle| x right)$ và $β2(v|x)beta_{2}left( v middle| x right)$.

$$
P(Y2=v|x)=α2(v|x)×β2(v|x)Pleft( Y_{2} =  v middle| x right) =  alpha_{2}left( v middle| x right) times beta_{2}left( v middle| x right)
$$

Trong đó $α2(v|x)alpha_{2}left( v middle| x right)$ là tổng trọng số tất cả các đường đi từ <S> đến v tại $Y2Y_{2}$, $β2(v|x)beta_{2}left( v middle| x right)$ là tổng trọng số tất cả các đường đi từ v tại $Y2Y_{2}$ đến <T>.

Để tính $α2(v|x)alpha_{2}left( v middle| x right)$ ta sẽ tính $α1alpha_{1}$ của tất cả các giá trị của Y1 rồi nhân với trọng số chuyển đổi thành nhãn v tương ứng với từng giá trị (v => v, n => v, p => v, d => v). Như vậy thì $αialpha_{i}$ sẽ được tính dựa theo $αi−1alpha_{i - 1}$ và quá trình này là quá trình tiến của thuật toán Forward-Backward. Tương tự $βibeta_{i}$ cũng được tính toán dựa trên quy hoạch động và quá trình này là quá trình lùi.

Tổng quát, ta có chuỗi $Y=(Y0,…,Yn)Y =  left( Y_{0}, ldots,Y_{n} right)$, gọi $$
Yi:j=(Yi,…,Yj)với0≤i<j≤nY_{i:j} =  left( Y_{i}, ldots,Y_{j} right) với 0 leq i < j leq n
$$.

Ta có:

$$
αt(Yt=y′|x)={∑y0:t−1′∏i=1tMi(y′i−1,y′i|x),với1<t≤nM1(<Start>,y′1|x),vớit=1alpha_{t}left( Y_{t} = y^{'} middle| x right) = left{ begin{array}{r}
sum_{y_{0:t - 1}^{'}}^{}{prod_{i = 1}^{t}{M_{i}left( {y^{'}}_{i - 1},{y^{'}}_{i} middle| x right)}},  với 1 < t leq n  
M_{1}left( < Start > ,{y^{'}}_{1} middle| x right) ,  với t = 1
end{array} right.
$$

$$
βt(Yt=y′|x)={∑yt+1:n′∏i=t+1nMi(y′i−1,y′i|x),với1≤t<n−1∑y″∈𝒴Mt(y′,y″|x),vớit=n−11,vớit=nbeta_{t}left( Y_{t} = y^{'} middle| x right) =  left{ begin{array}{r}
sum_{y_{t + 1:n}^{'}}^{}{prod_{i = t + 1}^{n}{M_{i}left( {y^{'}}_{i - 1},{y^{'}}_{i} middle| x right)}},   với 1 leq t < n - 1 
sum_{y^{''} in  mathcal{Y}}^{}{M_{t}left( y',y'' middle| x right)},    với t = n - 1 
1 ,                                  với t = n
end{array} right.
$$

Ta chứng minh $$
αt(Yt=y′|x)=∑y′t−1∈𝒴αt−1(Yt−1=y′t−1|x)×Mt(y′t−1,y′|x)alpha_{t}left( Y_{t} = y^{'} middle| x right) =  sum_{{y^{'}}_{t - 1} in mathcal{Y}}^{}{alpha_{t - 1}left( Y_{t - 1} = {y^{'}}_{t - 1} middle| x right)} times M_{t}left( {y^{'}}_{t - 1},y^{'} middle| x right)
$$ với $1<t≤n 1 < t leq n$, thật vậy:

$$
αt(Yt=y′|x)=∑y0:t−2′∑y′t−1∈𝒴∏i=1t−1Mi(y′i−1,y′i|x)×Mt(y′t−1,y′t|x)alpha_{t}left( Y_{t} = y^{'} middle| x right) = sum_{y_{0:t - 2}^{'}}^{}{sum_{{y^{'}}_{t - 1} in mathcal{Y}}^{}{prod_{i = 1}^{t - 1}{M_{i}left( {y^{'}}_{i - 1},{y^{'}}_{i} middle| x right) times}}}M_{t}left( {y^{'}}_{t - 1},{y^{'}}_{t} middle| x right)
$$
$$
=∑y′t−1∈𝒴(∑y0:t−2′∏i=1t−1Mi(y′i−1,y′i|x))×Mt(y′t−1,y′t|x)= sum_{{y^{'}}_{t - 1} in mathcal{Y}}^{}left( sum_{y_{0:t - 2}^{'}}^{}{prod_{i = 1}^{t - 1}{M_{i}left( {y^{'}}_{i - 1},{y^{'}}_{i} middle| x right)}} right) times M_{t}left( {y^{'}}_{t - 1},{y^{'}}_{t} middle| x right)
$$
$$
=∑y′t−1∈𝒴αt−1(Yt−1=y′t−1|x)×Mt(y′t−1,y′|x)=  sum_{{y^{'}}_{t - 1} in mathcal{Y}}^{}{alpha_{t - 1}left( Y_{t - 1} = {y^{'}}_{t - 1} middle| x right)} times M_{t}left( {y^{'}}_{t - 1},y^{'} middle| x right)
$$

Tương tự, với$1≤t<n−1 1 leq t < n - 1$ta cũng có:

$$
βt(Yt=y′|x)=∑y′t+1∈𝒴Mt+1(y′,y′t+1|x)βt+1(Yt+1=y′t+1|x)beta_{t}left( Y_{t} = y^{'} middle| x right) =  sum_{{y^{'}}_{t + 1} in mathcal{Y}}^{}{{M_{t + 1}left( y^{'}, {y^{'}}_{t + 1} middle| x right)beta}_{t + 1}left( Y_{t + 1} = {y^{'}}_{t + 1} middle| x right)}
$$

Với cách biểu diễn dưới dạng ma trận công thức $$
αt(Yt=y′|x)alpha_{t}left( Y_{t} = y^{'} middle| x right)
$$ và $$
βt(Yt=y′|x)beta_{t}left( Y_{t} = y^{'} middle| x right)
$$ có thể biểu diễn dưới dạng tích ma trận và vector với $Mi(x)<Start>{M_{i}(x)}_{< Start >}$ là vetor hàng ứng vói nhãn $<Start>< Start >$, $1|𝒴′|×11_{left| mathcal{Y'} right| times 1}$ là ma trận các giá trị 1 kích thước $|𝒴′|×1left| mathcal{Y'} right| times 1$:

$$
αt(Yt=y′|x)={(Mi(x)<Start>×∏i=2tMi(x))0,y′,với1<t≤nMi(x)<Start>,y′,vớit=1alpha_{t}left( Y_{t} = y^{'} middle| x right) = left{ begin{array}{r}
left( {M_{i}(x)}_{< Start >} times prod_{i = 2}^{t}{M_{i}(x)} right)_{0,y'}    , với 1 < t leq n  
{M_{i}(x)}_{< Start > ,y^{'}} ,                           với t = 1
end{array} right.
$$

$$
βt(Yt=y′|x)={((∏i=1t+1Mi(x))×1|𝒴′|×1)y′,0,với1≤t<n1,vớit=nbeta_{t}left( Y_{t} = y^{'} middle| x right) = left{ begin{array}{r}
left( left( prod_{i = 1}^{t + 1}{M_{i}(x)} right){times 1}_{left| mathcal{Y'} right| times 1} right)_{y', 0}    , với 1 leq t < n  
1 ,                                              với t = n
end{array} right.
$$

Công thức xác xuất biên biểu diễn bằng xác suất tiến và lùi có dạng:

$$
P(Yt=y′|x)=αt(Yt=y′|x)×βt(Yt=y′|x)Zθ(x)Pleft( Y_{t} = y^{'} middle| x right) = frac{alpha_{t}left( Y_{t} = y^{'} middle| x right) times beta_{t}left( Y_{t} = y^{'} middle| x right)}{Z_{theta}(x)}
$$

![A diagram of a neural network AI-generated content may be incorrect.](images/image2.png)

Hình 3.2. Minh họa thuật toán Forward-Backward trong việc xác suất biên tại 1 cạnh

Tương tự với xác suất biên $$
P(Yt−1=y′,Yt=y″|x)Pleft( Y_{t - 1} = y^{'}, Y_{t} = y'' middle| x right)
$$, ta có:

$$
P(Yt−1=y′,Yt=y″|x)=αt−1(Yt−1=y′|x)×Mt(y′,y″|x)×βt(Yt=y″|x)Zθ(x)Pleft( Y_{t - 1} = y^{'}, Y_{t} = y'' middle| x right) =  frac{alpha_{t - 1}left( Y_{t - 1} = y^{'} middle| x right) times M_{t}left( y',y'' middle| x right) times beta_{t}left( Y_{t} = y^{''} middle| x right)}{Z_{theta}(x)}
$$

Bằng phương pháp quy hoạch động, ta có thể tính các xác suất biên với độ phức tạp $$
O(n×|𝒴|2)Oleft( n times left| mathcal{Y} right|^{2} right)
$$ và chính là độ phức tạp khi tính kì vọng của các hàm đặc trưng.

### 4\. Thuật toán Viterbi áp dụng trong suy luận Linear-Chain CRFs

Xác định chuỗi $ŷwidehat{y}$ có xác suất xảy ra cao nhất khi biết x:

$$
ŷ=argmaxyP(y|x)=argmaxy∏i=1nMi(yi−1,yi|x)Zθ(x)widehat{y} =  {argmax}_{y} Pleft( y middle| x right) =  {argmax}_{y}frac{prod_{i = 1}^{n}{M_{i}left( y_{i - 1},y_{i} middle| x right)}}{Z_{theta}(x)}
$$

Vì $Zθ(x)Z_{theta}(x)$ là hằng số khi biết nên việc xác định chuỗi $ŷwidehat{y}$ có xác suất xảy ra cao nhất khi biết x tương đương với xác định chuỗi $ŷwidehat{y}$ để $$
∏i=1nMi(yi−1,yi|x)prod_{i = 1}^{n}{M_{i}left( y_{i - 1},y_{i} middle| x right)}
$$ lớn nhất:

$$
ŷ=argmaxy∏i=1nMi(yi−1,yi|x)widehat{y} =  {argmax}_{y}prod_{i = 1}^{n}{M_{i}left( y_{i - 1},y_{i} middle| x right)}
$$

Việc tìm $ŷwidehat{y}$ có thể tính trong thời gian $$
O(n×|𝒴|2)Oleft( n times left| mathcal{Y} right|^{2} right)
$$ với thuật toán quy hoạch động Viterbi. Thuật toán Viterbi được mô tả bằng mã giả trong hình 10.

![A screenshot of a math program AI-generated content may be incorrect.](images/image3.png)

Hình 4.1: Thuật toán Viterbi cho suy luận Linear-chain CRFs

$Mi(x)M_{i}(x)$ là ma trận đã được trình bày trong phần 3 với hàng 0 và cột 0 tương ứng với nhãn <Start>.

![A diagram of a neural network AI-generated content may be incorrect.](images/image4.png)

Hình 4.2: Hình minh họa thuật toán Viterbi cho POS

Hình 4.2 là minh họa quá trình suy luận Viterbi cho POS. Giả sử sau khi huấn luyện ta đã có được trọng số của các đường đi $MiM_{i}$. Với đầu câu đầu vào có 4 từ, và cần gán nhãn cho 4 từ này một nhãn từ loại là 1 trong 4 giá trị: v, n, p, d. Ở đây, mỗi một miền tương đương với 1 từ cần được gán nhãn và số đỉnh trong miền là nhãn có thể có của từ, ví dụ, miền Y1 có 4 đỉnh là v, n, p, d tương đương với 4 giá trị có thể gán cho từ đầu tiên của câu. Một đường đi hợp lệ là đường đi đi qua duy nhất một đỉnh trong mỗi miền. Thuật toán Viterbi sẽ tìm đường sao cho trọng số là lớn nhất (tương đương với xác suất chuỗi nhãn là lớn nhất.

Ý tưởng của Viterbi là đường đi lớn nhất đến một đỉnh sẽ bao gồm đường đi lớn nhất đến đỉnh trước nó. Xuất phát từ ý tưởng này, để tìm đường đi lớn nhất đến miền Y4, ta sẽ tính đường đi lớn nhất đến các đỉnh của miền Y3, sau đó từ các đỉnh của Y3 ta tính trọng số đến các đỉnh của Y4 và chọn ra đường đi có trọng số lớn nhât. Tương tự đường đi có trọng số lớn nhất đến các đỉnh trong Y3 có thể tính qua đường đi có trọng số lớn nhất đến các đỉnh trong Y2, ….

# Public_104

## Khái niệm cơ bản về Hidden Markov Model (HMM)

Hidden Markov Model (HMM) là một mô hình thống kê được sử dụng để phân tích các chuỗi dữ liệu có tính chất tuần tự, trong đó trạng thái thực của hệ thống (trạng thái ẩn) không thể quan sát trực tiếp, nhưng có thể suy ra thông qua các quan sát (observations). HMM kết hợp hai quá trình ngẫu nhiên:

  * Một quá trình Markov ẩn, mô tả sự chuyển đổi giữa các trạng thái ẩn.

  * Một quá trình phát xạ, liên kết mỗi trạng thái ẩn với một tập các quan sát theo một phân phối xác suất.


HMM thường được biểu diễn thông qua các thành phần sau:

  * **Tập trạng thái ẩn (Hidden States):** Đại diện cho các trạng thái không quan sát được của hệ thống.

  * **Ma trận xác suất chuyển trạng thái (State Transition Matrix):** Xác định xác suất chuyển từ một trạng thái ẩn này sang trạng thái ẩn khác.

  * **Ma trận xác suất phát xạ (Emission Probability Matrix):** Mô tả xác suất của một quan sát cụ thể dựa trên trạng thái hiện tại.

  * **Phân phối xác suất ban đầu (Initial State Distribution):** Xác định trạng thái khởi đầu của hệ thống.


## Sự khác biệt giữa Markov Chain và HMM

Markov Chain là một mô hình toán học đơn giản hơn HMM, trong đó:

  * Trạng thái của Markov Chain là có thể quan sát trực tiếp.

  * Xác suất chuyển trạng thái chỉ phụ thuộc vào trạng thái hiện tại, không quan tâm đến các trạng thái trước đó.


Ngược lại, HMM phức tạp hơn:

  * Trạng thái ẩn của HMM không thể quan sát trực tiếp, mà chỉ có thể suy đoán thông qua các quan sát.

  * HMM bổ sung thêm quá trình phát xạ, liên kết các trạng thái ẩn với dữ liệu quan sát.


Ví dụ minh họa: Trong Markov Chain, nếu ta đang xem một chuỗi các điều kiện thời tiết (nắng, mưa), bạn có thể quan sát trực tiếp điều kiện thời tiết tại từng thời điểm. Trong HMM, các điều kiện thời tiết có thể được ẩn (không trực tiếp quan sát được), nhưng ta có thể suy luận từ các quan sát như mức độ ẩm, nhiệt độ, hoặc áp suất không khí.

## Vai trò và ứng dụng của HMM trong các bài toán thực tiễn

HMM đóng vai trò quan trọng trong nhiều lĩnh vực nghiên cứu và ứng dụng, đặc biệt là trong xử lý chuỗi dữ liệu. Một số ứng dụng điển hình của HMM bao gồm:

**2.1.1. Xử lý ngôn ngữ tự nhiên (Natural Language Processing - NLP):**

  * Gắn thẻ từ loại (POS Tagging): Dự đoán nhãn ngữ pháp (danh từ, động từ,...) của các từ trong câu.

  * Nhận dạng thực thể (Named Entity Recognition): Xác định tên riêng, địa danh, hoặc tổ chức trong văn bản.


**2.1.2. Nhận dạng giọng nói (Speech Recognition):**

  * Mô hình hóa các chuỗi âm thanh để chuyển đổi thành văn bản.

3. **Phân tích sinh học (Bioinformatics):**

  * Dự đoán cấu trúc protein từ chuỗi axit amin.

  * Phân tích trình tự DNA để xác định gen.


**2.1.4. Phát hiện bất thường (Anomaly Detection):**

  * Dự đoán lỗi trong hệ thống máy tính hoặc mạng lưới.

  * Phát hiện gian lận trong các giao dịch tài chính.


**2.1.5. Ứng dụng trong thời gian thực:**

  * Phân tích dữ liệu cảm biến trong hệ thống IoT (Internet of Things).

  * Dự đoán trạng thái hoạt động trong các hệ thống điều khiển tự động.


Nhờ khả năng kết hợp tính xác suất và dự đoán trạng thái, HMM trở thành một công cụ mạnh mẽ trong việc mô hình hóa các quá trình phức tạp mà các trạng thái ẩn không thể quan sát trực tiếp.

# **Cấu trúc cơ bản của Hidden Markov Model**

## **Mô hình Markov và trạng thái ẩn**

Hidden Markov Model (HMM) là sự mở rộng của mô hình Markov truyền thống, trong đó trạng thái của hệ thống không thể quan sát trực tiếp, mà chỉ có thể được suy luận từ các quan sát (emissions). Một hệ thống được mô tả bởi HMM có các trạng thái ẩn liên kết với một tập hợp các quan sát cụ thể thông qua xác suất phát xạ.

Trong HMM, hai quá trình ngẫu nhiên được kết hợp:

  * **Quá trình Markov ẩn:** Mô tả sự chuyển đổi giữa các trạng thái ẩn theo xác suất.

  * **Quá trình phát xạ:** Liên kết mỗi trạng thái ẩn với các quan sát thông qua phân phối xác suất phát xạ.


HMM thường được biểu diễn dưới dạng một đồ thị có hướng, trong đó các nút là trạng thái và các cạnh thể hiện xác suất chuyển đổi giữa các trạng thái.

## **Các thành phần chính của HMM**

Một HMM được định nghĩa bởi bốn thành phần chính:

### **Tập trạng thái (Hidden States)**

Tập trạng thái ẩn của HMM được ký hiệu là S={S1,S2,…,SN}, trong đó:

  * Si​: Trạng thái ẩn thứ iii.

  * N: Số lượng trạng thái ẩn.


Tại mỗi thời điểm, hệ thống sẽ nằm ở một trong các trạng thái Si​, nhưng trạng thái này không thể quan sát trực tiếp mà chỉ có thể suy ra từ các quan sát.

Ví dụ: Trong bài toán nhận dạng giọng nói, các trạng thái ẩn có thể là các âm vị (phonemes) mà người nói đang phát âm.

### **Ma trận chuyển trạng thái (State Transition Matrix)**

Ma trận chuyển trạng thái, ký hiệu là A=[aij], là một ma trận vuông kích thước N×N, trong đó:

  * aij=P(Sj∣Si): Xác suất chuyển từ trạng thái Si sang trạng thái Sj​.

  * $∑j=1Naij=1sum_{j = 1}^{N}{a_{ij} = 1}$: Tổng các xác suất từ một trạng thái phải bằng 1.


Ma trận A biểu diễn các mối quan hệ giữa các trạng thái ẩn trong mô hình.

Ví dụ: Trong một chuỗi thời tiết, xác suất chuyển từ trạng thái "nắng" sang "mưa" là một phần của ma trận chuyển trạng thái.

### **Ma trận xác suất phát xạ (Emission Probability Matrix)**

Ma trận xác suất phát xạ, ký hiệu là B=[bj(k)], là một ma trận kích thước N×M, trong đó:

  * bj(k) = P(Ok ∣ Sj): Xác suất quan sát Ok​ xảy ra khi hệ thống ở trạng thái Sj​.

  * O ={O1,O2,…,OM}: Tập các quan sát có thể xảy ra, với M là số lượng quan sát.


Ma trận B mô tả mối quan hệ giữa trạng thái ẩn và quan sát.

Ví dụ: Trong bài toán nhận dạng giọng nói, các quan sát có thể là các đặc trưng âm thanh (spectral features) được trích xuất từ tín hiệu âm thanh.

### **Phân phối xác suất ban đầu (Initial State Distribution)**

Phân phối xác suất ban đầu, ký hiệu là π={π1,π2,…,πN}, trong đó:

  * πi = P(Si): Xác suất hệ thống bắt đầu ở trạng thái Si​.

  * $∑i=1Nπi=1:sum_{i = 1}^{N}{pi_{i} = 1}:$ Tổng xác suất của tất cả các trạng thái ban đầu phải bằng 1.


Phân phối π cung cấp thông tin về trạng thái khởi đầu của hệ thống trước khi các quan sát được thực hiện.

## **Công thức tổng quát của HMM**

Một HMM được định nghĩa bởi các tham số λ=(A,B,π), trong đó:

  * A = [aij]: Ma trận chuyển trạng thái.

  * B = [bj(k)]: Ma trận xác suất phát xạ.

  * π = {πi}: Phân phối xác suất ban đầu.


Cho một chuỗi quan sát O={O1,O2,…,OT} với chiều dài T, xác suất của chuỗi quan sát được tính theo công thức:

$$
P(O|λ)=∑QP(O,Q|λ)=∑QP(Q|λ)•P(O|Q,λ)P(O | lambda) =  sum_{Q}^{}{P(O,Q | lambda)} =  sum_{Q}^{}{P(Q | lambda)  bullet P (O |Q, lambda)}
$$

Trong đó:

  * Q = {Sq1,Sq2,…,SqT}: Một chuỗi trạng thái ẩn.

  * Tổng ΣQ ​ được tính trên tất cả các chuỗi trạng thái có thể xảy ra.


Công thức này cho phép ta tính xác suất quan sát của một chuỗi và xác định chuỗi trạng thái ẩn tối ưu.

# **Ba bài toán cơ bản của Hidden Markov Model (HMM)**

Hidden Markov Model (HMM) được sử dụng để giải quyết ba bài toán cơ bản trong các ứng dụng thực tế. Các bài toán này là trung tâm của việc áp dụng HMM vào việc phân tích dữ liệu tuần tự. Dưới đây là chi tiết từng bài toán.

## **Bài toán 1: Đánh giá (Evaluation)**

**Mục tiêu:**  
Tính xác suất của một chuỗi quan sát O={O1,O2,…,OT} đã cho, dựa trên mô hình HMM λ=(A,B,π).

**Ý nghĩa:**  
Bài toán này giúp đánh giá mức độ phù hợp của một chuỗi quan sát với một mô hình HMM cụ thể. Đây là bước cần thiết để so sánh và lựa chọn mô hình tốt nhất từ các mô hình cạnh tranh.

**Công thức:**  
Xác suất của chuỗi quan sát P(O ∣ λ) được tính bằng cách tổng hợp xác suất trên tất cả các chuỗi trạng thái ẩn Q={q1,q2,…,qT}:

$$
P(O|λ)=∑QP(P,Q|λ)P(O | lambda) =  sum_{Q}^{}{P(P,Q | lambda)}
$$

**Thách thức:**  
Việc tính toán trực tiếp rất phức tạp, vì số lượng các chuỗi trạng thái Q tăng theo hàm mũ với chiều dài T của chuỗi quan sát.

**Giải pháp:**  
Sử dụng thuật toán **Forward** :

  * Thuật toán này tính toán xác suất một cách hiệu quả bằng cách sử dụng phương pháp đệ quy.

  * Độ phức tạp được giảm từ O(NT) xuống O(N2T), trong đó N là số trạng thái ẩn.


## **Bài toán 2: Giải mã (Decoding)**

**Mục tiêu:**  
Tìm chuỗi trạng thái ẩn tối ưu Q∗={q1∗,q2∗,…,qT∗} tương ứng với chuỗi quan sát O, sao cho:

$$
Q*=argmaxQP(Q|O,λ)Q^{*} = {argmax_{Q}}{P(Q |O,lambda)  }
$$

**Ý nghĩa:**  
Bài toán này giúp xác định chuỗi trạng thái ẩn khả dĩ nhất, giải thích tốt nhất cho chuỗi quan sát. Đây là một bước quan trọng trong các ứng dụng như nhận dạng giọng nói và phân tích chuỗi sinh học.

**Thách thức:**  
Việc tìm kiếm chuỗi trạng thái tối ưu yêu cầu tối ưu hóa toàn cục trên toàn bộ chuỗi thời gian.

**Giải pháp:**  
Sử dụng thuật toán **Viterbi** :

  * Thuật toán này dựa trên lập trình động, tìm chuỗi trạng thái tối ưu bằng cách lưu trữ các giá trị tối đa tại mỗi bước.

  * Độ phức tạp của thuật toán là O(N2T).


## **Bài toán 3: Học (Learning)**

**Mục tiêu:**  
Ước lượng các tham số của mô hình λ=(A,B,π) từ một tập dữ liệu quan sát O={O(1),O(2),…,O(K)}.

**Ý nghĩa:**  
Bài toán này giúp xây dựng một mô hình HMM phù hợp từ dữ liệu quan sát, phục vụ cho việc phân tích và dự đoán.

**Thách thức:**  
Không thể tối ưu trực tiếp P(O∣λ) vì các trạng thái ẩn không được quan sát trực tiếp.

**Giải pháp:**  
Sử dụng thuật toán **Baum-Welch** hoặc **Expectation-Maximization (EM)** :

  * Thuật toán này lặp lại hai bước:

1. **E-step (Expectation):** Tính xác suất kỳ vọng cho các trạng thái ẩn dựa trên các tham số hiện tại.

2. **M-step (Maximization):** Cập nhật các tham số A,B,π để tối đa hóa xác suất quan sát P(O∣λ).

  * Thuật toán hội tụ đến một cực đại cục của P(O∣λ).

# Public_105

# T **huật toán liên quan đến Hidden Markov Model (HMM)**

Các thuật toán liên quan đến HMM là trung tâm của việc áp dụng mô hình trong các bài toán thực tiễn. Dưới đây là ba thuật toán quan trọng, mỗi thuật toán giải quyết một trong ba bài toán cơ bản của HMM.

## **Thuật toán Forward và Backward**

### **Mục đích:**

Tính xác suất của một chuỗi quan sát O={O1,O2,…,OT} dựa trên một mô hình HMM λ=(A,B,π).

### **Thuật toán Forward**

Forward algorithm tính xác suất P(O ∣ λ) bằng cách sử dụng đệ quy.

  * **Biến forward** αt(i): Xác suất của chuỗi quan sát một phần O1,O2,…,Ot và hệ thống ở trạng thái Si tại thời điểm t:


$$
αt(i)=P(O1,O2,…Ot,qt=Si|λ)alpha_{t}(i) =  P(O_{1},O_{2},ldots O_{t},q_{t} = S_{i}|lambda)
$$

  * **Quy trình tính toán:**

1. **Khởi tạo:**


$$
αt(i)=πibi(O1),1≤i≤Nalpha_{t}(i) =  pi_{i}b_{i}left( O_{1} right), 1 leq  i  leq  N
$$

  2. **Đệ quy:**


$$
αt+1(j)=∑i=1Nαt(i)αijbj(Ot+1),1≤j≤N,1≤t≤T−1alpha_{t + 1}(j) = sum_{i = 1}^{N}{alpha_{t}(i)alpha_{ij}b_{j}(O_{t + 1})}, 1 leq j  leq N, 1 leq t  leq T - 1
$$

  3. **Kết thúc:**


$$
P(O|λ)=∑i=1NαT(i)P(O | lambda) =  sum_{i = 1}^{N}{alpha_{T}(i)}
$$

  * **Độ phức tạp:** O(N2T).


### **Thuật toán Backward**

Backward algorithm hỗ trợ tính toán tương tự nhưng từ cuối chuỗi quan sát trở về đầu.

  * **Biến backward** βt(i): Xác suất của chuỗi quan sát từ Ot+1,Ot+2,…,OT​, với trạng thái qt=Si tại thời điểm t:


βt(i) = P(Ot+1,Ot+2,…,OT∣qt = Si,λ)

  * **Quy trình tính toán:**

1. **Khởi tạo:**


βT(i) = 1, 1 ≤ i ≤ N

  2. **Đệ quy:**


$$
βt(i)=∑j=1Naijbj(Ot+1)βt+1(j),1≤t≤T−1beta_{t}(i) =  sum_{j = 1}^{N}{a_{ij}b_{j}left( O_{t + 1} right)beta_{t + 1}(j), 1  leq t  leq T - 1}
$$

  3. **Kết thúc:** Tính xác suất tổng quát:


$$
P(O|λ)=∑i=1Nπibi(O1)β1(i)P(O | lambda) =  sum_{i = 1}^{N}{pi_{i}b_{i}left( O_{1} right)beta_{1}(i)}
$$

  * **Độ phức tạp:** O(N2T).


## **Thuật toán Viterbi**

### **Mục đích:**

Tìm chuỗi trạng thái ẩn tối ưu Q∗={q1∗,q2∗,…,qT∗} giải thích tốt nhất chuỗi quan sát O.

### **Quy trình tính toán:**

  * **Biến trạng thái** δt(i): Xác suất lớn nhất của chuỗi trạng thái dẫn đến Si​ tại thời điểm t:


$$
δt(i)=maxq1,q2,…,qt−1P(q1,q2,…,qt=Si,O1,O2,…,Ot|λ)delta_{t}(i) =  max_{q_{1},q_{2},ldots,q_{t - 1}}{Pleft( q_{1},q_{2},ldots,q_{t} =  S_{i}, O_{1},O_{2},ldots, O_{t }| lambda right)}
$$

  * **Bước thực hiện:**

1. **Khởi tạo:**


δ1(i) = πibi(O1) , 1 ≤ i ≤ N
$ψ1(j)=0,1≤i≤Npsi_{1}(j) = 0,  1  leq  i  leq  N$

  2. **Đệ quy:**


$$
δt+1(j)=Nmaxi=1δt(i)aijbj(Ot+1),1≤j≤N,1≤t≤T−1delta_{t + 1}(j) =  begin{array}{r}
N 
max 
i = 1
end{array}{delta_{t}(i)a_{ij}b_{j}left( O_{t + 1} right),  1 leq j leq N, 1 leq t leq T - 1}
$$
$$
ψt+1(j)=argNmaxi=1δt(i)aij,1≤j≤Npsi_{t + 1}(j) = arg{begin{array}{r}
N 
max 
i = 1
end{array}delta_{t}(i)a_{ij}  , }1 leq j leq N
$$

  3. **Kết thúc:**


$$
P(Q*,O|λ)=Nmaxi=1δT(i)Pleft( Q^{*}, O  right| lambda) =  begin{array}{r}
N 
max 
i = 1
end{array}{delta_{T}(i)}
$$
$$
qT*=argNmaxi=1δT(i)q_{T}^{*} = argbegin{array}{r}
N 
max 
i = 1
end{array}{delta_{T}(i)}
$$

  4. **Truy vết trạng thái tối ưu:**


$$
qt*=ψt+1(qt+1*),t=T−1,T−2,…,1q_{t}^{*} = psi_{t + 1}left( q_{t + 1}^{*} right), t = T - 1, T - 2, ldots, 1
$$

  * **Độ phức tạp:** O(N2T).


# **Các giả định của Hidden Markov Model (HMM)**

Hidden Markov Model (HMM) dựa trên hai giả định cơ bản, giúp đơn giản hóa việc mô hình hóa và tính toán xác suất trong các bài toán thực tế. Mặc dù những giả định này có thể không hoàn toàn chính xác trong mọi trường hợp, chúng vẫn đủ mạnh để mô tả nhiều hệ thống thực tế một cách hiệu quả.

## **Giả định Markov (Markov Assumption)**

### **Định nghĩa:**

Giả định Markov phát biểu rằng trạng thái hiện tại qtq_tqt​ chỉ phụ thuộc vào trạng thái ngay trước đó qt−1​, không phụ thuộc vào các trạng thái trước đó trong chuỗi.

P(qt∣qt−1,qt−2,…,q1) = P(qt ∣ qt−1)

### **Ý nghĩa:**

  * Giả định này giảm độ phức tạp của mô hình, chỉ yêu cầu xét mối quan hệ giữa hai trạng thái liên tiếp thay vì toàn bộ chuỗi trạng thái.

  * Trong thực tế, giả định Markov có thể hiểu là một hệ thống "có trí nhớ ngắn hạn", nơi trạng thái hiện tại chứa đủ thông tin để dự đoán trạng thái tiếp theo.


### **Hạn chế:**

  * Hệ thống thực tế có thể bị ảnh hưởng bởi nhiều trạng thái trong quá khứ, không chỉ bởi trạng thái ngay trước đó. Tuy nhiên, việc tăng bậc của mô hình Markov (Markov bậc cao hơn) có thể giúp giảm bớt hạn chế này, nhưng làm tăng độ phức tạp tính toán.


## **Giả định độc lập quan sát (Independence Assumption)**

### **Định nghĩa:**

Giả định này cho rằng mỗi quan sát OtO_tOt​ tại thời điểm ttt chỉ phụ thuộc vào trạng thái hiện tại qtq_tqt​, không phụ thuộc vào các quan sát khác hoặc các trạng thái khác trong chuỗi.

P(Ot ∣ qt,qt−1,Ot−1,… ) = P(Ot ∣ qt)

### **Ý nghĩa:**

  * Giả định này cho phép ta mô hình hóa mối quan hệ giữa trạng thái ẩn và quan sát một cách độc lập, giảm đáng kể độ phức tạp khi tính toán xác suất.

  * Đây là một trong những lý do HMM được áp dụng rộng rãi trong các bài toán như nhận dạng giọng nói và gắn thẻ từ loại.


### **Hạn chế:**

  * Trong thực tế, các quan sát thường có mối liên hệ phụ thuộc với nhau, đặc biệt trong các chuỗi dữ liệu có tính chất tuần tự cao. Giả định này có thể không hoàn toàn chính xác, nhưng thường được chấp nhận để đơn giản hóa mô hình.


Hai giả định Markov và độc lập quan sát là nền tảng của Hidden Markov Model, giúp mô hình này trở thành một công cụ đơn giản nhưng mạnh mẽ để mô tả các chuỗi dữ liệu tuần tự. Mặc dù có những hạn chế nhất định, chúng cho phép HMM áp dụng hiệu quả trong các bài toán thực tế với độ phức tạp tính toán thấp.

# **Ứng dụng của Hidden Markov Model (HMM) vào Gắn thẻ từ loại (POS Tagging)**

Gắn thẻ từ loại (Part-of-Speech Tagging - POS Tagging) là một bài toán quan trọng trong xử lý ngôn ngữ tự nhiên (NLP), nhằm gán nhãn ngữ pháp (danh từ, động từ, tính từ,...) cho từng từ trong câu. Hidden Markov Model (HMM) là một phương pháp phổ biến để giải quyết bài toán này nhờ khả năng mô hình hóa chuỗi trạng thái ẩn (các nhãn từ loại) dựa trên chuỗi quan sát (các từ trong câu).

## **Mô hình HMM cho POS Tagging**

Để áp dụng HMM vào bài toán POS Tagging, chúng ta cần xác định các thành phần của mô hình:

  * **Tập trạng thái ẩn (S):**

* Là tập các nhãn từ loại (POS tags), ví dụ:  
S={NN (danh từ),VB (động từ),JJ (tính từ),… }.

  * **Tập quan sát (O):**

* Là tập các từ trong câu, ví dụ: O={The, cat, runs, fast}

  * **Phân phối xác suất ban đầu (π):**

* Xác suất một từ trong câu bắt đầu với một từ loại cụ thể: πi=P(S1=i)  
Ví dụ: Một câu thường bắt đầu bằng các nhãn như DT (mạo từ) hoặc NN (danh từ).

  * **Ma trận chuyển trạng thái (A):**

* Xác suất chuyển từ nhãn từ loại này sang nhãn từ loại khác: aij=P(St+1=j∣St=i)  
Ví dụ: Sau một danh từ (NN), khả năng cao sẽ là một động từ (VB) hoặc mạo từ (DT).

  * **Ma trận xác suất phát xạ (B):**

* Xác suất một nhãn từ loại phát sinh một từ cụ thể: bj(Ot)=P(Ot∣St=j)  
Ví dụ: Xác suất từ "runs" thuộc nhãn động từ (VB) sẽ cao hơn các nhãn khác.


## **Thuật toán Viterbi để giải bài toán POS Tagging**

POS Tagging sử dụng thuật toán Viterbi để tìm chuỗi nhãn từ loại tối ưu S∗={S1∗,S2∗,…,ST∗} tương ứng với chuỗi quan sát O={O1,O2,…,OT}.

### **Quy trình thực hiện:**

**B1: Khởi tạo:** Tại thời điểm t=1:
δ1(i)=πi⋅bi(O1), ψ1(i)=0

  * δ1(i): Xác suất lớn nhất khi bắt đầu với trạng thái Si​.

  * ψ1(i): Truy vết trạng thái trước đó, tại thời điểm khởi đầu, giá trị này bằng 0.


**B2: Đệ quy:** Từ t=2 đến T (số lượng từ trong câu):
$$
δt(j)=maxi[δt−1(i)•aij•bj(Ot)],ψt(j)=argmaxi[δt−1(i)•aij]delta_{t}(j) =  max_{i}{leftlbrack delta_{t - 1}(i) bullet a_{ij} bullet b_{j}(O_{t}) rightrbrack, psi_{t}(j) =  argmax_{i}leftlbrack delta_{t - 1}(i) bullet a_{ij} rightrbrack}
$$

  * δt(j): Xác suất lớn nhất dẫn đến trạng thái Sj​ tại thời điểm t.

  * ψt(j): Truy vết trạng thái Si​ tốt nhất trước Sj​.


**B3: Kết thúc:** Tại thời điểm cuối T:

$$
ST*=argmaxiδT(i)S_{T}^{*} =  argmax_{i}{delta_{T}(i)}
$$

**B4: Truy vết:** Từ t=T−1 đến t=1:

$$
St*=ψt+1(St+1*)S_{t}^{*} =  psi_{t + 1}(S_{t + 1}^{*})
$$

St∗=ψt+1(St+1∗)S_t^* = \psi_{t+1}(S_{t+1}^*)St∗​=ψt+1​(St+1∗​)

  * Kết quả là chuỗi nhãn từ loại tối ưu S∗={S1∗,S2∗,…,ST∗}.


## **Ví dụ minh họa**

**Đề bài:** Cho câu quan sát:

O={"The", "cat", "runs"}

Với tập nhãn từ loại:

S={DT (mạo từ),NN (danh từ),VB (động từ)}

Các tham số mô hình:

  * π={P(DT)=0.6,P(NN)=0.3,P(VB)=0.1}.

  * Ma trận chuyển trạng thái:


$$
A=[P(DT→DT)P(DT→NN)P(DT→VB)P(NN→DT)P(NN→NN)P(NN→VB)P(VB→DT)P(VB→NN)P(VB→VB)]=[00.70.30.10.40.50.60.30.1]A =  begin{bmatrix}
P(DT rightarrow  DT) & P(DT rightarrow  NN) & P(DT rightarrow  VB) 
P(NN rightarrow  DT) & P(NN rightarrow  NN) & P(NN rightarrow  VB) 
P(VB rightarrow  DT) & P(VB rightarrow  NN) & P(VB rightarrow  VB)
end{bmatrix} =  begin{bmatrix}
0 & 0.7 & 0.3 
0.1 & 0.4 & 0.5 
0.6 & 0.3 & 0.1
end{bmatrix}
$$

  * Ma trận phát xạ:

$$
B =  begin{bmatrix}
P(O | DT) 
P(O | NN) 
P(O | VB)
end{bmatrix} =  begin{bmatrix}
Pleft( text{"The"} right) = 0.5, P("text{cat"})  =  0.1,
P("runs")  =  0.1 
Pleft( text{"The"} right) = 0.1, P("text{cat"})  =  0.6,
P("runs")  =  0.1 
Pleft( text{"The"} right) = 0.1, P("text{cat"})  =  0.1,
P("runs")  =  0.8
end{bmatrix}
$$


**Giải:**

  * **Khởi tạo:**


$$
δ1(DT)=πDT•bDT("The")=0.6•0.5=0.3delta_{1}(DT) =  pi_{DT} bullet b_{DT}left( text{"The"} right) = 0.6 bullet 0.5 = 0.3
$$
$$
δ1(NN)=πNN•bNN("The")=0.3•0.1=0.03delta_{1}(NN) =  pi_{NN} bullet b_{NN}left( text{"The"} right) = 0.3 bullet 0.1 = 0.03
$$
$$
δ1(VB)=πVB•bVB("The")=0.1•0.1=0.01delta_{1}(VB) =  pi_{VB} bullet b_{VB}left( text{"The"} right) = 0.1 bullet 0.1 = 0.01
$$

  * **Đệ quy (tại** t=2 **):**


$$
delta_{2}(NN) =  maxleftlbrack
delta_{1}(DT) bullet a_{DT rightarrow NN}, delta_{1}(NN) bullet
a_{NN rightarrow NN}, delta_{1}(VB) bullet a_{VB rightarrow NN}
rightrbrack bullet b_{NN}("cat")
$$

  * **Tiếp tục:**  
Lặp lại các bước trên cho đến t=3 để tìm chuỗi nhãn tối ưu.

# Public_106

Thuật toán tìm kiếm không có thông tin được xem xét trước tiên là tìm kiếm theo chiều rộng (Breadth-first search, viết tắt là BFS), một dạng tìm kiếm vét cạn.

  1. **Nguyên tắc:**


Tìm kiếm theo chiều rộng là trong số những nút biên lựa chọn nút nông nhất (gần nút gốc nhất) để mở rộng. Như vậy, trước hết tất cả các nút có độ sâu bằng 0 (nút gốc) được mở rộng, sau đó tới các nút có độ sâu bằng 1 được mở rộng, rồi tới các nút có độ sâu bằng 2, và tiếp tục như vậy. Ở đây, độ sâu được tính bằng số nút nằm trên đường đi từ nút gốc tới nút đang xét.

Có thể nhận thấy, để thực hiện nguyên tắc tìm kiếm theo chiều rộng, ta cần lựa chọn nút được thêm vào sớm hơn trong danh sách nút biên O để mở rộng. Điều này có thể thực hiện dễ dàng bằng cách dùng một hàng đợi FIFO để lưu các nút biên.

Thuật toán tìm theo chiều rộng được thể hiện trên hình 1. Khác với thuật toán tìm kiếm tổng quát ở trên, tập nút biên O được tổ chức dưới dạng hàng đợi FIFO: các nút mới sinh ra được thêm vào cuối của O tại bước 3 của mỗi vòng lặp; nút đầu tiên của O sẽ được lấy ra để mở rộng như tại bước 1 của vòng lặp của thuật toán trên hình vẽ. Bước 2 của vòng lặp kiểm tra điều kiện đích và trả về kết quả trong trường hợp nút lấy ra từ O là nút đích. Thuật toán kết thúc trong hai trường hợp: 1) khi lấy được nút đích từ O; và 2) khi tập O rỗng. Hai trường hợp này tương ứng với hai lệnh return ở trong và ngoài vòng lặp.

Con trỏ ngược: khi mở rộng một nút ta cần sử dụng con trỏ ngược để ghi lại nút cha của nút vừa được mở ra. Con trỏ này được sử dụng để tìm ngược lại đường đi về trạng thái xuất phát khi tìm được trạng thái đích. Khi cài đặt thuật toán, mỗi nút được biểu diễn bằng một cấu trúc dữ liệu có chứa một con trỏ ngược trỏ tới nút cha.

Sau khi tìm được nút đích, có thể khôi phục đường đi tới nút đó bằng cách lần theo các con trỏ ngược, bắt đầu từ nút đích.


| BFS (Q,S,G,P)Đầu vào: bài toán tìm kiếmĐầu ra: trạng thái đíchKhởi tạo:O←S// trong thuật toán này,Olà hàng đợi FIFO-----------------------------While (Okhông rỗng) do1. Chọn nút đầu tiênntừOvà xóankhỏiO2. Ifn∈G, return (đường đi tới n)3. ThêmP(n) vào cuốiOReturn: Không có lời giải |
| --- |

 

Hình 1. Thuật toán tìm kiếm theo chiều rộng

  2. **Các cải tiến:**


Một số cải tiến sau đây có thể sử dụng kết hợp với thuật toán tìm theo chiều rộng vừa trình bày.

Tránh xem xét lại các nút đã mở rộng. Việc xem xét lại các nút đã mở rộng có thể dẫn tới vòng lặp. Mặc dù vòng lặp không ảnh hưởng tới khả năng tìm ra lời giải của tìm theo chiều rộng, xong việc có vòng lặp và xem xét lại các nút làm tăng độ phức tạp tính toán do phải khảo sát nhiều nút hơn. Vấn đề này có thể giải quyết bằng cách sử dụng tập đóng tương tự trong thuật toán Graph Search. Một trạng thái đã có mặt trong tập đóng hoặc tập biên sẽ không được thêm vào tập biên nữa. Người đọc có thể tự kiểm tra kết quả của thuật toán trong trường hợp có sử dụng kiểm tra tập đóng và tập biên với trường hợp không kiểm tra bằng cách thực hiện thuật toán với ví dụ trên hình 2.1

Kiểm tra đích trước khi thêm vào tập biên. Trong thuật toán tổng quát, việc kiểm tra điều kiện đích được thực hiện khi nút được lấy ra khỏi O để mở rộng. Thay vào đó, ta có thể kiểm tra trước khi thêm nút vào O. Ưu điểm của cách làm này là giảm bớt số lượng nút cần lưu trong nút biên cũng như số nút được mở rộng. Cụ thể về số lượng nút cần mở rộng khi thực hiện kiểm tra đích trước sẽ được trình bày trong phần tính chất của thuật toán ở bên dưới.

**Ví dụ:** Xét ví dụ tìm đường đi từ nút S tới nút G trên đồ thị ở hình 2.1 (để đơn giản, ví dụ này sử dụng đồ thị có hướng; quá trình tìm đường đi trên đồ thị vô hướng được thực hiện tương tự, trừ việc từ một nút có thể di chuyển sang nút cha của nút đó)

Hình 2.1: Ví dụ đồ thị cho bài toán tìm đường đi ![](images/image1.png)

Một số bước đầu tiên của thuật toán, có sử dụng việc lưu và kiểm tra tập nút đóng, được thể hiện dưới dạng các cây tìm kiếm như trên hình 2.2. Lưu ý: để thống nhất trong việc trình bày, trong số các nút có vai trò giống nhau, tức là có cùng độ sâu, nút đứng trước trong bảng chữ cái sẽ được mở rộng trước. Quy tắc này không được quy định trong thuật toán và chỉ để tiện cho trình bày.

![](images/image2.png)

Hình 2.9. Một số cây tìm kiếm sinh ra khi tìm kiếm theo chiều rộng. Các cây được thể hiện theo thứ tự từ trái sang phải, từ trên xuống dưới. Nút mở rộng tiếp theo được đánh dấu bằng mũi tên

Kết quả thực hiện các bước của thuật toán cũng có thể theo dõi qua thứ tự mở rộng các nút và nội dung danh sách tập nút biên. Dưới đây là minh họa cho thứ tự mở rộng nút và tập biên cho ví dụ trên hình 2.1 (có sử dụng tập nút đóng). Để tiện cho trình bầy, ta sẽ quy định phía bên trái là đầu của hàng đợi O và phía bên phải là cuối của hàng đợi O. Như vậy các nút được thêm vào từ phía bên phải và lấy ra từ bên trái. Con trỏ tới nút cha sẽ được viết dưới dạng chỉ số bên cạnh mỗi nút


| Nút được mở rộng | Tập biên O (hàng đợi FIFO trong trường hợp này) |
| --- | --- |
|  | S |
| S | AS , BS , CS , ES |
| AS | BS , CS , ES, DA |
| BS | CS , ES, DA, FB |
| CS | ES , DA, FB , HC |
| ES | DA , FB, HC, GE |
| DA | FB, HC, GE |
| FB | HC , GE |
| HC | GE |
| GE | Đích |

 

Sau đó, sử dụng con trỏ ngược, theo đó E là nút cha của G, S là nút cha của E, ta tìm được đường đi G ← E ← S.

  3. **Tính chất của tìm theo chiều rộng:**


Đối chiếu với các tiêu chuẩn ở trên, tìm kiếm theo chiều rộng có những tính chất sau:

• Thuật toán có tính đầy đủ, tức là nếu bài toán có lời giải, tìm kiếm theo chiều rộng đảm bảo tìm ra lời giải. Thật vậy, nếu lời giải nằm ở độ sâu hữu hạn d thì thuật toán sẽ đạt tới lời giải đó sau khi đã khảo sát hết các nút nông hơn, trừ khi yếu tố rẽ nhánh b là vô hạn. Tìm theo chiều rộng là tìm kiếm vét cạn, trong đó các nút có độ sâu nhỏ hơn được xem xét trước.

• Tính tối ưu: thuật toán đảm bảo tìm ra lời giải có độ sâu nhỏ nhất. Tuy nhiên, trong trường hợp giá thành đường đi giữa các nút không bằng nhau thì điều này chưa đảm bảo tìm ra đường đi ngắn nhất. Cụ thể, trong ví dụ trên, thuật toán tìm ra đường đi SEG có độ sâu bằng 2 (nhỏ nhất) nhưng có độ dài 154, trong khi đường đi ngắn nhất SBFG có độ dài 132.

• Độ phức tạp tính toán: với mức độ rẽ nhánh là b và độ sâu lời giải d, thuật toán sinh ra O (bd +1) nút trước khi tìm ra lời giải hay O(bd) nút nếu kiểm tra đích trước khi thêm nút vào tập biên. Độ phức tạp này là lớn và tăng rất nhanh khi b và d tăng.

Giả sử rằng, mỗi trạng thái khi được phát triển sẽ sinh ra b trạng thái kề. Như vậy từ nút gốc sẽ sinh ra b nút với độ sâu 1, các nút này lại sinh ra b2 nút với độ sâu 2, và tiếp tục như vậy. Giả sử nút đích của bài toán nằm ở độ sâu d. Trong trường hợp xấu nhất, nút đích nằm cuối cùng trong số các nút ở độ sâu này và do vậy ta cần mở rộng tất cả nút ở độ sâu d trước khi tìm ra đích, tức là sinh ra bd + 1 nút ở độ sâu d +1. Như vậy, tổng số nút cần mở rộng để tìm ra nút đích là (tính cả nút gốc):

_**1 + b + b2 + ... + bd +1 = O(bd +1)**_

Nếu tiến hành kiểm tra điều kiện đích trước khi thêm vào tập biên như đề cập ở trên, ta sẽ không phải sinh ra các nút ở độ sâu d + 1 và do vậy số nút cần sinh ra chỉ c n là O(bd).

• Yêu cầu bộ nhớ: thuật toán cần lưu O (bd +1) nút trong tập biên sau khi đã mở rộng tất cả các nút ở độ sâu d. Nếu sử dụng tập các nút đóng thì tập này cần lưu O(bd) nút. Như vậy độ phức tạp bộ nhớ của tìm kiếm rộng là O (bd +1).

Như vậy, ưu điểm của tìm theo chiều rộng là tính đầy đủ và tối ưu nếu giá thành đường đi như nhau. Nhược điểm của thuật toán này là độ phức tạp tính toán lớn và yêu cầu về bộ nhớ lớn. Trong hai nhược điểm sau, độ phức tạp về bộ nhớ lớn là nghiêm trọng hơn do không thể kiếm được máy tính có bộ nhớ đủ lớn để chạy thuật toán, trong khi ta có thể đợi thêm thời gian để chờ thuật toán chạy xong nếu thời gian chạy không quá lâu. Trên thực thế, thuật toán tìm theo chiều rộng chỉ có thể sử dụng cho các bài toán có kích thước rất nhỏ (b và d không quá 10).

# Public_107

  1. **Giới thiệu:**


Trong Machine Learning nói riêng và Toán Tối Ưu nói chung, chúng ta thường xuyên phải tìm giá trị nhỏ nhất (hoặc đôi khi là lớn nhất) của một hàm số nào đó. Ví dụ như các hàm mất mát trong hai bài [Linear Regression](https://machinelearningcoban.com/2016/12/28/linearregression/) và [K-means Clustering](https://machinelearningcoban.com/2017/01/01/kmeans/). Nhìn chung, việc tìm global minimum của các hàm mất mát trong Machine Learning là rất phức tạp, thậm chí là bất khả thi. Thay vào đó, người ta thường cố gắng tìm các điểm local minimum, và ở một mức độ nào đó, coi đó là nghiệm cần tìm của bài toán.

Các điểm local minimum là nghiệm của phương trình đạo hàm bằng 0. Nếu bằng một cách nào đó có thể tìm được toàn bộ (hữu hạn) các điểm cực tiểu, ta chỉ cần thay từng điểm local minimum đó vào hàm số rồi tìm điểm làm cho hàm có giá trị nhỏ nhất ( _đoạn này nghe rất quen thuộc, đúng không?_ ). Tuy nhiên, trong hầu hết các trường hợp, việc giải phương trình đạo hàm bằng 0 là bất khả thi. Nguyên nhân có thể đến từ sự phức tạp của dạng của đạo hàm, từ việc các điểm dữ liệu có số chiều lớn, hoặc từ việc có quá nhiều điểm dữ liệu.

Hướng tiếp cận phổ biến nhất là xuất phát từ một điểm mà chúng ta coi là _gần_ với nghiệm của bài toán, sau đó dùng một phép toán lặp để _tiến dần_ đến điểm cần tìm, tức đến khi đạo hàm gần với 0. Gradient Descent (viết gọn là GD) và các biến thể của nó là một trong những phương pháp được dùng nhiều nhất.

Vì kiến thức về GD khá rộng nên tôi xin phép được chia thành hai phần. Phần 1 này giới thiệu ý tưởng phía sau thuật toán GD và một vài ví dụ đơn giản giúp các bạn làm quen với thuật toán này và vài khái niệm mới. Phần 2 sẽ nói về các phương pháp cải tiến GD và các biến thể của GD trong các bài toán mà số chiều và số điểm dữ liệu lớn. Những bài toán như vậy được gọi là _large-scale_.

**2\. Gradient Descent cho hàm 1 biến**

Quay trở lại hình vẽ ban đầu và một vài quan sát tôi đã nêu. Giả sử xt là điểm ta tìm được sau vòng lặp thứ t. Ta cần tìm một thuật toán để đưa xt về càng gần x∗ càng tốt.

Trong hình đầu tiên, chúng ta lại có thêm hai quan sát nữa:

  * Nếu đạo hàm của hàm số tại xt: f′(xt)>0 thì xt nằm về bên phải so với x∗ (và ngược lại). Để điểm tiếp theo xt+1 gần với x∗ hơn, chúng ta cần di chuyển xt về phía bên trái, tức về phía _âm_. Nói các khác, **chúng ta cần di chuyển ngược dấu với đạo hàm** :xt+1=xt+ΔTrong đó Δ là một đại lượng ngược dấu với đạo hàm f′(xt).

  * xt càng xa x∗ về phía bên phải thì f′(xt) càng lớn hơn 0 (và ngược lại). Vậy, lượng di chuyển Δ, một cách trực quan nhất, là tỉ lệ thuận với −f′(xt).


Hai nhận xét phía trên cho chúng ta một cách cập nhật đơn giản là: xt+1=xt−ηf′(xt)

Trong đó η (đọc là _eta_ ) là một số dương được gọi là _learning rate_ (tốc độ học). Dấu trừ thể hiện việc chúng ta phải _đi ngược_ với đạo hàm (Đây cũng chính là lý do phương pháp này được gọi là Gradient Descent - _descent_ nghĩa là _đi ngược_ ). Các quan sát đơn giản phía trên, mặc dù không phải đúng cho tất cả các bài toán, là nền tảng cho rất nhiều phương pháp tối ưu nói chung và thuật toán Machine Learning nói riêng.

Ví dụ đơn giản với Python

Xét hàm số f(x)=x2+5sin(x) với đạo hàm f′(x)=2x+5cos(x) (một lý do tôi chọn hàm này vì nó không dễ tìm nghiệm của đạo hàm bằng 0 như hàm phía trên). Giả sử bắt đầu từ một điểm x0 nào đó, tại vòng lặp thứ t, chúng ta sẽ cập nhật như sau:xt+1=xt−η(2xt+5cos(xt))

Như thường lệ, tôi khai báo vài thư viện quen thuộc

_# To support both python 2 and python 3_

**from** __future__ **import** division, print_function, unicode_literals

**import** math

**import** numpy **as** np

**import** matplotlib.pyplot **as** plt

Tiếp theo, tôi viết các hàm số :

  * grad để tính đạo hàm

  * cost để tính giá trị của hàm số. Hàm này không sử dụng trong thuật toán nhưng thường được dùng để kiểm tra việc tính đạo hàm của đúng không hoặc để xem giá trị của hàm số có giảm theo mỗi vòng lặp hay không.

  * myGD1 là phần chính thực hiện thuật toán Gradient Desent nêu phía trên. Đầu vào của hàm số này là learning rate và điểm bắt đầu. Thuật toán dừng lại khi đạo hàm có độ lớn đủ nhỏ.


**def** **grad** (x):

**return** 2 ***** x **+** 5 ***** np.cos(x)

**def** **cost** (x):

**return** x ****** 2 **+** 5 ***** np.sin(x)

**def** **myGD1** (eta, x0):

x **=** [x0]

**for** it **in** range(100):

x_new **=** x[ **-** 1] **-** eta ***** grad(x[ **-** 1])

**if** abs(grad(x_new)) **<** 1e-3:

**break**

x.append(x_new)

**return** (x, it)

Điểm khởi tạo khác nhau

Sau khi có các hàm cần thiết, tôi thử tìm nghiệm với các điểm khởi tạo khác nhau là x0=−5 và x0=5.

(x1, it1) **=** myGD1(.1, **-** 5)

(x2, it2) **=** myGD1(.1, 5)

**print** ('Solution x1 = %f, cost = %f, obtained after %d iterations' **%** (x1[ **-** 1], cost(x1[ **-** 1]), it1))

**print** ('Solution x2 = %f, cost = %f, obtained after %d iterations' **%** (x2[ **-** 1], cost(x2[ **-** 1]), it2))

Solution x1 = -1.110667, cost = -3.246394, obtained after 11 iterations

Solution x2 = -1.110341, cost = -3.246394, obtained after 29 iterations

Vậy là với các điểm ban đầu khác nhau, thuật toán của chúng ta tìm được nghiệm gần giống nhau, mặc dù với tốc độ hội tụ khác nhau. Dưới đây là hình ảnh minh họa thuật toán GD cho bài toán này ( _xem tốt trên Desktop ở chế độ full màn hình_ ).


| ![Ảnh có chứa văn bản, Sơ đồ, biểu đồ, hàng Nội dung do AI tạo ra có thể không chính xác.](images/image1.gif) | ![Ảnh có chứa văn bản, biểu đồ, Sơ đồ, hàng Nội dung do AI tạo ra có thể không chính xác.](images/image2.gif) |
| --- | --- |

 

Từ hình minh họa trên ta thấy rằng ở hình bên trái, tương ứng với x0=−5, nghiệm hội tụ nhanh hơn, vì điểm ban đầu x0 gần với nghiệm x∗≈−1 hơn. Hơn nữa, với x0=5 ở hình bên phải, _đường đi_ của nghiệm có chứa một khu vực có đạo hàm khá nhỏ gần điểm có hoành độ bằng 2. Điều này khiến cho thuật toán _la cà_ ở đây khá lâu. Khi vượt qua được điểm này thì mọi việc diễn ra rất tốt đẹp.

Learning rate khác nhau

Tốc độ hội tụ của GD không những phụ thuộc vào điểm khởi tạo ban đầu mà còn phụ thuộc vào _learning rate_. Dưới đây là một ví dụ với cùng điểm khởi tạo x0=−5 nhưng learning rate khác nhau:


| ![Ảnh có chứa văn bản, Sơ đồ, biểu đồ, hàng Nội dung do AI tạo ra có thể không chính xác.](images/image3.gif) | ![Ảnh có chứa văn bản, Sơ đồ, biểu đồ, hàng Nội dung do AI tạo ra có thể không chính xác.](images/image4.gif) |
| --- | --- |

 

Ta quan sát thấy hai điều:

  1. Với _learning rate_ nhỏ η=0.01, tốc độ hội tụ rất chậm. Trong ví dụ này tôi chọn tối đa 100 vòng lặp nên thuật toán dừng lại trước khi tới _đích_ , mặc dù đã rất gần. Trong thực tế, khi việc tính toán trở nên phức tạp, _learning rate_ quá thấp sẽ ảnh hưởng tới tốc độ của thuật toán rất nhiều, thậm chí không bao giờ tới được đích.

  2. Với _learning rate_ lớn η=0.5, thuật toán tiến rất nhanh tới _gần đích_ sau vài vòng lặp. Tuy nhiên, thuật toán không hội tụ được vì _bước nhảy_ quá lớn, khiến nó cứ _quẩn quanh_ ở đích.


Việc lựa chọn _learning rate_ rất quan trọng trong các bài toán thực tế. Việc lựa chọn giá trị này phụ thuộc nhiều vào từng bài toán và phải làm một vài thí nghiệm để chọn ra giá trị tốt nhất. Ngoài ra, tùy vào một số bài toán, GD có thể làm việc hiệu quả hơn bằng cách chọn ra _learning rate_ phù hợp hoặc chọn _learning rate_ khác nhau ở mỗi vòng lặp. Tôi sẽ quay lại vấn đề này ở phần 2.

**3\. Gradient Descent cho hàm nhiều biến**

Giả sử ta cần tìm global minimum cho hàm f(θ) trong đó θ ( _theta_ ) là một vector, thường được dùng để ký hiệu tập hợp các tham số của một mô hình cần tối ưu (trong Linear Regression thì các tham số chính là hệ số w). Đạo hàm của hàm số đó tại một điểm θ bất kỳ được ký hiệu là ∇θf(θ) (hình tam giác ngược đọc là _nabla_ ). Tương tự như hàm 1 biến, thuật toán GD cho hàm nhiều biến cũng bắt đầu bằng một điểm dự đoán θ0, sau đó, ở vòng lặp thứ t, quy tắc cập nhật là:

θt+1=θt−η∇θf(θt)

Hoặc viết dưới dạng đơn giản hơn: θ=θ−η∇θf(θ).

Quy tắc cần nhớ: **luôn luôn đi ngược hướng với đạo hàm**.

Việc tính toán đạo hàm của các hàm nhiều biến là một kỹ năng cần thiết. Một vài đạo hàm đơn giản có thể được [tìm thấy ở đây](https://machinelearningcoban.com/math/#bang-cac-dao-ham-co-ban).

Quay lại với bài toán Linear Regression

Trong mục này, chúng ta quay lại với bài toán [Linear Regression](https://machinelearningcoban.com/2016/12/28/linearregression/) và thử tối ưu hàm mất mát của nó bằng thuật toán GD.

Hàm mất mát của Linear Regression là:L(w)=12N||y−¯Xw||22

**Chú ý** : hàm này có khác một chút so với hàm tôi nêu trong bài [Linear Regression](https://machinelearningcoban.com/2016/12/28/linearregression/). Mẫu số có thêm N là số lượng dữ liệu trong training set. Việc lấy trung bình cộng của lỗi này nhằm giúp tránh trường hợp hàm mất mát và đạo hàm có giá trị là một số rất lớn, ảnh hưởng tới độ chính xác của các phép toán khi thực hiện trên máy tính. Về mặt toán học, nghiệm của hai bài toán là như nhau.

Đạo hàm của hàm mất mát là:∇wL(w)=1N¯XT(¯Xw−y) (1)

Sau đây là ví dụ trên Python và một vài lưu ý khi lập trình

Load thư viện

_# To support both python 2 and python 3_

**from** __future__ **import** division, print_function, unicode_literals

**import** numpy **as** np

**import** matplotlib

**import** matplotlib.pyplot **as** plt

np.random.seed(2)

Tiếp theo, chúng ta tạo 1000 điểm dữ liệu được chọn _gần_ với đường thẳng y=4+3x, hiển thị chúng và tìm nghiệm theo công thức:

X **=** np.random.rand(1000, 1)

y **=** 4 **+** 3 ***** X **+** .2 ***** np.random.randn(1000, 1) _# noise added_

_# Building Xbar_

one **=** np.ones((X.shape[0],1))

Xbar **=** np.concatenate((one, X), axis **=** 1)

A **=** np.dot(Xbar.T, Xbar)

b **=** np.dot(Xbar.T, y)

w_lr **=** np.dot(np.linalg.pinv(A), b)

**print** ('Solution found by formula: w = ',w_lr.T)

_# Display result_

w **=** w_lr

w_0 **=** w[0][0]

w_1 **=** w[1][0]

x0 **=** np.linspace(0, 1, 2, endpoint **=** True)

y0 **=** w_0 **+** w_1 ***** x0

_# Draw the fitting line_

plt.plot(X.T, y.T, 'b.') _# data_

plt.plot(x0, y0, 'y', linewidth **=** 2) _# the fitting line_

plt.axis([0, 1, 0, 10])

plt.show()

Solution found by formula: w = [[ 4.00305242 2.99862665]]

![Ảnh có chứa ảnh chụp màn hình, hàng Nội dung do AI tạo ra có thể không chính xác.](images/image5.png)

Đường thẳng tìm được là đường có màu vàng có phương trình y≈4+2.998x.

Tiếp theo ta viết đạo hàm và hàm mất mát:

**def** **grad** (w):

N **=** Xbar.shape[0]

**return** 1 **/** N ***** Xbar.T.dot(Xbar.dot(w) **-** y)

**def** **cost** (w):

N **=** Xbar.shape[0]

**return** .5 **/** N ***** np.linalg.norm(y **-** Xbar.dot(w), 2) ****** 2;

Kiểm tra đạo hàm

Việc tính đạo hàm của hàm nhiều biến thông thường khá phức tạp và rất dễ mắc lỗi, nếu chúng ta tính sai đạo hàm thì thuật toán GD không thể chạy đúng được. Trong thực nghiệm, có một cách để kiểm tra liệu đạo hàm tính được có chính xác không. Cách này dựa trên định nghĩa của đạo hàm (cho hàm 1 biến):f′(x)=limε→0f(x+ε)−f(x)ε

Một cách thường được sử dụng là lấy một giá trị ε rất nhỏ, ví dụ 10−6, và sử dụng công thức:f′(x)≈f(x+ε)−f(x−ε)2ε (2)

Cách tính này được gọi là _numerical gradient_.

**Câu hỏi: Tại sao công thức xấp xỉ hai phía trên đây lại được sử dụng rộng rãi, sao không sử dụng công thức xấp xỉ đạo hàm bên phải hoặc bên trái?**

Có hai các giải thích cho vấn đề này, một bằng hình học, một bằng giải tích.

Giải thích bằng hình học

Quan sát hình dưới đây:

![Ảnh có chứa Nhiều màu sắc, tác phẩm nghệ thuật, ánh sáng Nội dung do AI tạo ra có thể không chính xác.](images/image6.png)

Trong hình, vector màu đỏ là đạo hàm _chính xác_ của hàm số tại điểm có hoành độ bằng x0. Vector màu xanh lam (có vẻ là hơi tím sau khi convert từ .pdf sang .png) thể hiện cách xấp xỉ đạo hàm phía phải. Vector màu xanh lục thể hiện cách xấp xỉ đạo hàm phía trái. Vector màu nâu thể hiện cách xấp xỉ đạo hàm hai phía. Trong ba vector xấp xỉ đó, vector xấp xỉ hai phía màu nâu là gần với vector đỏ nhất nếu xét theo hướng.

Sự khác biệt giữa các cách xấp xỉ còn lớn hơn nữa nếu tại điểm x, hàm số bị _bẻ cong_ mạnh hơn. Khi đó, xấp xỉ trái và phải sẽ khác nhau rất nhiều. Xấp xỉ hai bên sẽ _ổn định_ hơn.

Giải thích bằng giải tích

Chúng ta cùng quay lại một chút với Giải tích I năm thứ nhất đại học: [Khai triển Taylor](http://mathworld.wolfram.com/TaylorSeries.html).

Với ε rất nhỏ, ta có hai xấp xỉ sau:

f(x+ε)≈f(x)+f′(x)ε+f”(x)2ε2+…

và:f(x−ε)≈f(x)−f′(x)ε+f”(x)2ε2−…

Từ đó ta có:f(x+ε)−f(x)ε≈f′(x)+f”(x)2ε+⋯=f′(x)+O(ε) (3)

f(x+ε)−f(x−ε)2ε≈f′(x)+f(3)(x)6ε2+⋯=f′(x)+O(ε2) (4)

Từ đó, nếu xấp xỉ đạo hàm bằng công thức (3) (xấp xỉ đạo hàm phải), sai số sẽ là O(ε). Trong khi đó, nếu xấp xỉ đạo hàm bằng công thức (4) (xấp xỉ đạo hàm hai phía), sai số sẽ là O(ε2)≪O(ε) nếu ε nhỏ.

Cả hai cách giải thích trên đây đều cho chúng ta thấy rằng, xấp xỉ đạo hàm hai phía là xấp xỉ tốt hơn.

Với hàm nhiều biến

Với hàm nhiều biến, công thức (2) được áp dụng cho từng biến khi các biến khác cố định. Cách tính này thường cho giá trị khá chính xác. Tuy nhiên, cách này không được sử dụng để tính đạo hàm vì độ phức tạp quá cao so với cách tính trực tiếp. Khi so sánh đạo hàm này với đạo hàm chính xác tính theo công thức, người ta thường giảm số chiều dữ liệu và giảm số điểm dữ liệu để thuận tiện cho tính toán. Một khi đạo hàm tính được rất gần với _numerical gradient_ , chúng ta có thể tự tin rằng đạo hàm tính được là chính xác.

Dưới đây là một đoạn code đơn giản để kiểm tra đạo hàm và có thể áp dụng với một hàm số (của một vector) bất kỳ với cost và grad đã tính ở phía trên.

**def** **numerical_grad** (w, cost):

eps **=** 1e-4

g **=** np.zeros_like(w)

**for** i **in** range(len(w)):

w_p **=** w.copy()

w_n **=** w.copy()

w_p[i] **+=** eps

w_n[i] **-=** eps

g[i] **=** (cost(w_p) **-** cost(w_n)) **/** (2 ***** eps)

**return** g

**def** **check_grad** (w, cost, grad):

w **=** np.random.rand(w.shape[0], w.shape[1])

grad1 **=** grad(w)

grad2 **=** numerical_grad(w, cost)

**return** True **if** np.linalg.norm(grad1 **-** grad2) **<** 1e-6 **else** False

**print** ( 'Checking gradient...', check_grad(np.random.rand(2, 1), cost, grad))

Checking gradient... True

( _Với các hàm số khác, bạn đọc chỉ cần viết lại hàm grad và cost ở phần trên rồi áp dụng đoạn code này để kiểm tra đạo hàm. Nếu hàm số là hàm của một ma trận thì chúng ta thay đổi một chút trong hàm numerical_grad, tôi hy vọng không quá phức tạp_ ).

Với bài toán Linear Regression, cách tính đạo hàm như trong (1) phía trên được coi là đúng vì sai số giữa hai cách tính là rất nhỏ (nhỏ hơn 10−6). Sau khi có được đạo hàm chính xác, chúng ta viết hàm cho GD:

**def** **myGD** (w_init, grad, eta):

w **=** [w_init]

**for** it **in** range(100):

w_new **=** w[ **-** 1] **-** eta ***** grad(w[ **-** 1])

**if** np.linalg.norm(grad(w_new)) **/** len(w_new) **<** 1e-3:

**break**

w.append(w_new)

**return** (w, it)

w_init **=** np.array([[2], [1]])

(w1, it1) **=** myGD(w_init, grad, 1)

**print** ('Solution found by GD: w = ', w1[ **-** 1].T, ',\nafter %d iterations.' **%** (it1 **+** 1))

Solution found by GD: w = [[ 4.01780793 2.97133693]] ,

after 49 iterations.

Sau 49 vòng lặp, thuật toán đã hội tụ với một nghiệm khá gần với nghiệm tìm được theo công thức.

Dưới đây là hình động minh họa thuật toán GD.


| ![Ảnh có chứa văn bản, hàng, ảnh chụp màn hình, Sơ đồ Nội dung do AI tạo ra có thể không chính xác.](images/image7.gif) | ![Ảnh có chứa văn bản, ảnh chụp màn hình, Nhiều màu sắc Nội dung do AI tạo ra có thể không chính xác.](images/image8.gif) |
| --- | --- |

 

Trong hình bên trái, các đường thẳng màu đỏ là nghiệm tìm được sau mỗi vòng lặp.

Trong hình bên phải, tôi xin giới thiệu một thuật ngữ mới: _đường đồng mức_.

Đường đồng mức (level sets)

Với đồ thị của một hàm số với hai biến đầu vào cần được vẽ trong không gian ba chiều, nhều khi chúng ta khó nhìn được nghiệm có khoảng tọa độ bao nhiêu. Trong toán tối ưu, người ta thường dùng một cách vẽ sử dụng khái niệm _đường đồng mức_ (level sets).

Nếu các bạn để ý trong các bản độ tự nhiên, để miêu tả độ cao của các dãy núi, người ta dùng nhiều đường cong kín bao quanh nhau như sau:

Ví dụ về đường đồng mức trong các bản đồ tự nhiên. (Nguồn: [Địa lý 6: Đường đồng mức là những đường như thế nào?](http://vforum.vn/diendan/showthread.php?90166-Dia-ly-6-Duong-dong-muc-la-nhung-duong-nhu-the-nao-))

Các vòng nhỏ màu đỏ hơn thể hiện các điểm ở trên cao hơn.

Trong toán tối ưu, người ta cũng dùng phương pháp này để thể hiện các bề mặt trong không gian hai chiều.

Quay trở lại với hình minh họa thuật toán GD cho bài toán Liner Regression bên trên, hình bên phải là hình biểu diễn các level sets. Tức là tại các điểm trên cùng một vòng, hàm mất mát có giá trị như nhau. Trong ví dụ này, tôi hiển thị giá trị của hàm số tại một số vòng. Các vòng màu xanh có giá trị thấp, các vòng tròn màu đỏ phía ngoài có giá trị cao hơn. Điểm này khác một chút so với đường đồng mức trong tự nhiên là các vòng bên trong thường thể hiện một thung lũng hơn là một đỉnh núi (vì chúng ta đang đi tìm giá trị nhỏ nhất).

Tôi thử với _learning rate_ nhỏ hơn, kết quả như sau:


| ![Ảnh có chứa văn bản, hàng, ảnh chụp màn hình, Sơ đồ Nội dung do AI tạo ra có thể không chính xác.](images/image9.gif) | ![Ảnh có chứa văn bản, ảnh chụp màn hình, Nhiều màu sắc Nội dung do AI tạo ra có thể không chính xác.](images/image10.gif) |
| --- | --- |

 

Tốc độ hội tụ đã chậm đi nhiều, thậm chí sau 99 vòng lặp, GD vẫn chưa tới gần được nghiệm tốt nhất. Trong các bài toán thực tế, chúng ta cần nhiều vòng lặp hơn 99 rất nhiều, vì số chiều và số điểm dữ liệu thường là rất lớn.

**4\. Một ví dụ khác**

Để kết thúc phần 1 của Gradient Descent, tôi xin nêu thêm một ví dụ khác.

![Ảnh có chứa cầu vồng, Nhiều màu sắc, ảnh chụp màn hình Nội dung do AI tạo ra có thể không chính xác.](images/image11.gif)

Hàm số f(x,y)=(x2+y−7)2+(x−y+1)2 có hai điểm local minimum màu xanh lục tại (2,3) và (−3,−2), và chúng cũng là hai điểm global minimum. Trong ví dụ này, tùy vào điểm khởi tạo mà chúng ta thu được các nghiệm cuối cùng khác nhau.

**5\. Thảo luận**

Dựa trên GD, có rất nhiều thuật toán phức tạp và hiệu quả hơn được thiết kế cho những loại bài toán khác nhau. Vì bài này đã đủ dài, tôi xin phép dừng lại ở đây. Mời các bạn đón đọc bài Gradient Descent phần 2 với nhiều kỹ thuật nâng cao hơn.

**6\. Tài liệu tham khảo**

  1. [An overview of gradient descent optimization algorithms](http://sebastianruder.com/optimizing-gradient-descent/)

  2. [An Interactive Tutorial on Numerical Optimization](http://www.benfrederickson.com/numerical-optimization/)

  3. [Gradient Descent by Andrew NG](https://www.youtube.com/watch?v=eikJboPQDT0)

# Public_108

  1. **Giới thiệu**


Bài báo này đề xuất phương pháp định vị và tránh vật cản cho robot di động hoạt động trong môi trường đa vật thể dựa trên thuật toán học tăng cường. Mô hình robot di động gồm đầy đủ các thông số hình học và thông số vật lý được xây dựng trên nền tảng phần mềm Gazebo. Các hoạt động huấn luyện cho mô hình để robot tự tìm đường di chuyển được thực hiện cho cả thuật toán Q-Learning và thuật toán SARSA. Kết quả thử nghiệm được so sánh giữa hai thuật toán để đánh giá hiệu quả và chất lượng của các hoạt động huấn luyện.

**2\. Cơ sở lý thuyết**

Phương pháp học tăng cường tập trung vào việc học hướng tới mục tiêu từ sự tương tác khác nhau. Thực thể thực hiện quá trình học tập sẽ không biết trước hành động cần phải thực hiện, thay vào đó phải tự khám phá ra hành động nào mang lại phần thưởng lớn nhất bằng cách kiểm tra các hành động này thông qua phương pháp thử sai. Các thành phần cơ bản trong học tăng cường bao gồm:

  * Tác nhân (Agent): đóng vai trò trong việc giải quyết các vấn đề ra quyết định, tác động dưới sự không chắc chắn.

  * Môi trường (Environment): là những gì tồn tại bên ngoài tác nhân, tiếp nhận các tác độc từ tác nhân và tạo ra phần thưởng và những quan sát.

  * Hành động (Actions): tập hợp các phương thức hành động mà tác nhân tác động đến môi trường.

  * Trạng thái (State): trạng thái của tác nhân sau khi tác động qua lại với môi trường.

  * Phần thưởng (Reward): là giá trị thu được tương ứng với mỗi cặp Trạng thái - Hành động của tác nhân nhận được khi thực hiện tương tác với môi trường.

  * Tập (Episode): một chu kỳ bao gồm các tương tác giữa tác nhân và môi trường từ thời điểm bắt đầu đến kết thúc.

  * Chính sách (Policy): là hàm biểu diễn sự tương quan giữa những quan sát thu được từ môi trường và hành động cần thực hiện.


Trong đó, tác nhân và môi trường là hai thành phần cốt lõi của một mô hình học tăng cường. Hai thành phần này tương tác liên tục với nhau theo trình tự: Tác nhân thực hiện các tương tác tới môi trường thông qua các hành động, từ đó môi trường tác động lại các hành động của tác nhân. Môi trường lưu trữ các luồng thông tin khác nhau và phản hồi cho tác nhân một “giá trị khen thưởng” sau mỗi hành động của tác nhân. Giá trị này biểu hiện mức độ hiệu quả từng hành động của tác nhân trong quá trình hoàn thành nhiệm vụ. Mục đích của phương pháp học tăng cường là tác nhân tìm ra được chính sách tối đa hoá giá trị phần thưởng tích luỹ trong thời gian dài. Trong hướng tiếp cận của bài báo, tác giả chỉ ra tính hiệu quả của phương thức triển khai mô hình đề xuất dựa trên hai thuật toán học tăng cường Q-Learning và SARSA.

2.1. Thuật toán Q-Learning

Q-Learning là một thuật toán học tăng cường thực hiện phương thức cập nhật giá trị (values-based) dựa trên cập nhật hàm giá trị từ phương trình Bellman [14]. Phương trình Bellman tính toán giá trị kỳ vọng của trạng thái như sau:

![](images/image1.png)

(1)

  * Trong đó: ![](images/image2.png) là giá trị tối ưu trả về từ giá trị kỳ vọng theo trạng thái st theo chính sách thực hiện π; maxQπ là giá trị Q lớn nhất thể hiện hành động at tại trạng thái st theo chính sách π.


Phương trình tính toán giá trị Q kỳ vọng thực hiện một hành động at tại trạng thái st dựa trên phương trình Bellman:

(2) ![](images/image3.png)

  * Trong đó: ![](images/image4.png) là giá trị kỳ vọng của phần thưởng mà phương trình hướng đến nhằm tối ưu cho mỗi cặp trạng thái st và hành động at tại thời điểm t; rt là phần thưởng tức thời nhận lại được tại thời điểm t; γlà hằng số chiết khấu xác định mức độ quan trọng được trao cho phần thưởng hiện tại và phần thưởng trong tương lai;![](images/image5.png) là giá trị kỳ vọng lớn nhất có thể xảy ra của Q tại trạng thái ![](images/image6.png) với mọi hành động a.


Q-Learning là một thuật toán Off-policy, quá trình học của mô hình chủ yếu dựa trên giá trị của chính sách tối ưu và độc lập với các hành động của chủ thể. Off-policy được định nghĩa là tác nhân tuân theo một chính sách quyết định cho việc lựa chọn hành động để đạt trạng thái ![](images/image6.png)từ trạng thái st . Kể từ trạng thái![](images/image6.png), tác nhân sử dụng một chính sách khác cho khâu quyết định này. Phương trình của thuật toán Q-Learning được trình bày như sau: ![](images/image7.png)

Q*(s, a) trong (3) là giá trị kỳ vọng (phần thưởng của chiết khấu tích lũy trong việc thực hiện hành động a ở trạng thái s và sau đó tuân theo chính sách tối ưu. Hành động từ mỗi trạng thái thu được của thuật toán Q-Learning được xác định bởi quy trình ra quyết định Markov (MDP) [15, 16]. Các bước triển khai thuật toán được trình bày như trong bảng 1.

![](images/image8.png)

2.2. Thuật toán SARSA

Tương tự Q-Learning, SARSA là một thuật toán học tăng cường tuân thủ theo phương thức cập nhật Value-based và được tính toán dựa trên phương trình Bellman. Tuy nhiên, SARSA là một thuật toán On-policy. Thuật toán On-policy là thuật toán đánh giá và cải thiện cùng một chính sách π, hay nói cách khác tác nhân học và tuân theo một chính sách duy nhất xuyên suốt quá trình đào tạo.

SARSA là một thuật toán chỉ định rằng tại trạng thái thời điểm st , thực hiện hành động at , tiếp đó phần thưởng rt được nhận lại và kết thúc với trạng thái ![](images/image9.png) , đồng thời thực hiện hành động ![](images/image10.png) . Do đó, chuỗi giá trị ![](images/image11.png) đại diện cho chính tên gọi của thuật toán. Điểm khác biệt duy nhất là thành phần ![](images/image12.png), thay vì tối đa hoá cập nhật dựa trên giá trị Q kỳ vọng cao nhất ![](images/image13.png)trong bảng giá trị kinh nghiệm như Q-Learning. SARSA được thiết lập thêm bước cập nhật hành động tại thời điểm kế tiếp. Phương trình cơ bản của thuật toán SARSA được trình bày như trong (4) và các bước triển khai thuật toán được mô tả trong bảng 2.

![](images/image14.png)

![](images/image15.png)

# Public_109

### Tầm quan trọng của việc khai thác thông tin tuần tự trong dữ liệu người dùng

Hệ gợi ý tuần tự là một trong những hướng nghiên cứu quan trọng trong lĩnh vực hệ gợi ý, tập trung vào việc khai thác thông tin từ chuỗi hành vi của người dùng để dự đoán hành động tiếp theo. Khác với các hệ gợi ý truyền thống chỉ dựa trên thông tin tĩnh, như lịch sử tương tác tổng quát hoặc các thuộc tính người dùng, hệ gợi ý tuần tự tận dụng các thay đổi động trong sở thích và hành vi người dùng theo thời gian.

Nhờ sự phát triển của học sâu, các phương pháp hiện đại như GRU4Rec, SASRec và BERT4Rec đã cải thiện đáng kể khả năng khai thác thông tin tuần tự:

  * **GRU4Rec** : Giúp mã hóa chuỗi sự kiện tuần tự, nhưng còn hạn chế trong việc xử lý chuỗi dài.

  * **SASRec** : Loại bỏ hạn chế của RNN bằng cách sử dụng self-attention để nắm bắt các mối quan hệ giữa các sự kiện mà không bị giới hạn bởi khoảng cách.

  * **BERT4Rec** : Mở rộng SASRec với khả năng khai thác ngữ cảnh hai chiều, tối ưu hóa thông tin từ cả phía trước và phía sau trong chuỗi.


Việc áp dụng các phương pháp này đã mở ra khả năng gợi ý chính xác và hiệu quả hơn, đặc biệt trong các môi trường thực tế như thương mại điện tử, nơi hành vi người dùng thay đổi nhanh chóng và có tính cá nhân hóa cao.

### Cấu trúc GRU

Để xử lý vấn đề gradient biến mất hoặc bùng nổ khi chuỗi trở nên quá dài, các biến thể như GRU (Gated Recurrent Unit) và LSTM (Long Short-Term Memory) đã được giới thiệu. Chúng sử dụng các cổng kiểm soát (gates) để điều chỉnh dòng thông tin trong quá trình lan truyền ngược.

GRU sử dụng hai cổng chính, gồm **cổng cập nhật** (zt​) và **cổng xoá bỏ** (rt​), để kiểm soát dòng thông tin trong quá trình cập nhật trạng thái ẩn. Công thức cập nhật trạng thái trong GRU được định nghĩa như sau:

  * Cổng cập nhật:

$$
zt=σ(Wz•[ht−1,xt]+bz)z_{t} = sigmaleft( W_{z} bullet leftlbrack h_{t - 1},x_{t} rightrbrack + b_{z} right)
$$


Cổng này xác định tỷ lệ thông tin từ trạng thái cũ ht−1​ cần giữ lại để sử dụng trong trạng thái hiện tại.

  * Cổng xóa bỏ:

$$
rt=σ(Wr•[ht−1,xt]+br)r_{t} = sigmaleft( W_{r} bullet leftlbrack h_{t - 1},x_{t} rightrbrack + b_{r} right)
$$


Cổng xoá bỏ kiểm soát mức độ ảnh hưởng của trạng thái trước đó ht−1​ khi tạo trạng thái mới.

  * Trạng thái ứng viên:

$$
h̃t=tanh(Wh•[rt⨀ht−1,xt]+bh){widetilde{h}}_{t} = tanhleft( W_{h} bullet leftlbrack {r_{t} bigodot h}_{t - 1},x_{t} rightrbrack + b_{h} right)
$$


Trạng thái ứng viên $h̃t{widetilde{h}}_{t}$​ là biểu diễn trung gian, chịu tác động bởi cổng xoá bỏ $rtr_{t}$​ và thông tin đầu vào $xtx_{t}$​.

  * Trạng thái ẩn cuối cùng:

$$
ht=zt⨀ht−1+(1−zt)⨀h̃th_{t} = {z_{t} bigodot h}_{t - 1} + left( 1 - z_{t} right) bigodot {widetilde{h}}_{t}
$$


Trạng thái cuối cùng $hth_{t}$​ là sự kết hợp giữa trạng thái trước đó $ht−1h_{t - 1}$​ (được điều chỉnh bởi $ztz_{t}$) và trạng thái ứng viên $h̃t{widetilde{h}}_{t}$.

![Diagram of the gated recurrent unit RNN (GRU RNN) unit. Diagram of the... | Download Scientific Diagram](images/image1.jpeg)

  * Ở đây:

* $xtx_{t}$ là đầu vào tại thời điểm 𝑡 (ví dụ: embedding của sản phẩm).

* $ht−1h_{t - 1}$ là trạng thái ẩn tại thời điểm trước đó.

* $σsigma$ là hàm sigmoid, còn tanh làm hàm kích hoạt phi tuyến.

* $Wz,Wr,WhW_{z},W_{r},W_{h}$là các trọng số cần học.

* $bz,br,bhb_{z},b_{r},b_{h}$ là bias.

  * Dự đoán đầu ra: Dựa trên trạng thái ẩn $hth_{t}$​, GRU dự đoán phần tử tiếp theo trong chuỗi thông qua một lớp softmax:


$$
yt=softmax(Wy•ht+by)y_{t} = softmax(W_{y} bullet h_{t} + b_{y})
$$

Hàm mất mát thường được sử dụng là cross-entropy giữa phân phối dự đoán yt​ và nhãn thực yt∗​.

### GRU4Rec

Cấu trúc mạng sử dụng trong GRU4Rec được tổ chức theo các tầng sau:

  * Tầng đầu vào (Input Layer): Nhận chuỗi nhấp chuột của người dùng.

  * Tầng nhúng (Embedding Layer): Biểu diễn sản phẩm dưới dạng vector nhúng và có thể áp dụng dropout để giảm overfitting.

  * Tầng hồi tiếp (Recurrent Layer - GRU): Mô hình hóa thông tin tuần tự dựa trên GRU.

  * Tầng fully connected: Hợp nhất thông tin từ trạng thái ẩn của GRU.

  * Tầng đầu ra (Output Layer): Có thể sử dụng hàm softmax hoặc linear để dự đoán sản phẩm tiếp theo.


![A diagram of a process AI-generated content may be incorrect.](images/image2.png)

_Kiến trúc tổng quát của mạng sử dụng trong GRU4Rec, bao gồm các tầng xử lý từ đầu vào đến đầu ra_

# Public_110

### SASRec

SASRec (Self-Attentive Sequential Recommendation) là một mô hình gợi ý tuần tự dựa trên self-attention, được thiết kế để thay thế các phương pháp truyền thống như Markov Chains (MCs) và Recurrent Neural Networks (RNNs) trong việc dự đoán hành vi người dùng. Không giống như các mô hình RNN có tính tuần tự cao và khó xử lý song song, SASRec sử dụng self-attention để chọn lọc các tương tác quan trọng trong lịch sử người dùng, đồng thời tận dụng sức mạnh tính toán song song của GPU.

**Kiến trúc của SASRec**

![](images/image1.png)

Kiến trúc của SASRec dựa trên mô hình Transformer Decoder, cụ thể là multi-head self-attention để học các mối quan hệ giữa các mục trong chuỗi tương tác của người dùng. Mô hình bao gồm các thành phần chính sau:

  1. Embedding Layer:


  * Mỗi mục sản phẩm $vtv_{t}$ được ánh xạ thành một vector nhúng $ete_{t}$.

  * Một positional embedding được thêm vào để mô hình hóa thứ tự của các mục trong chuỗi.


  2. Self-Attention Layer:


  * Sử dụng scaled dot-product attention để xác định trọng số giữa các mục trong chuỗi:

$$
Attention(Q,K,V)=softmax(QKTd)VAttention(Q,K,V) =  softmaxleft( frac{QK^{T}}{sqrt{d}} right)V
$$

Trong đó:

* Q, K, V là ma trận truy vấn (query), khóa (key) và giá trị (value) được ánh xạ từ các mục trước đó.

* d là kích thước của vector nhúng để chuẩn hóa giá trị attention.

  * Mô hình sử dụng masked attention để ngăn chặn việc nhìn thấy tương lai, đảm bảo tính tuần tự trong dự đoán.


  3. Position-wise Feed-Forward Network (FFN):


  * Mỗi mục sau khi được xử lý bởi self-attention sẽ đi qua một mạng Feed-Forward để học biểu diễn tốt hơn.


  4. Output layer:


  * Sử dụng softmax để tính xác suất mục tiếp theo mà người dùng có thể tương tác.


Mô hình SASRec có thể được biểu diễn dưới dạng công thức như sau:

$$
H=MultiHeadSelfAttention(E+P)H = MultiHeadSelfAttention(E + P)
$$

$Ĥ=FeedForward(H)widehat{H} = FeedForward(H)$

$$
yt=softmax(Wy•Ĥ+by)y_{t} =  softmax(W_{y} bullet widehat{H} + b_{y})
$$

trong đó:

  * E là ma trận nhúng của các mục.

  * P là Positional Embedding.

  * H là đầu ra từ self-attention.

  * $Ĥwidehat{H}$ là đầu ra từ feed-forward network.


Hình dưới đây minh họa cách SASRec sử dụng self-attention để xử lý chuỗi dữ liệu tuần tự. Các khối màu xanh biểu diễn các lớp Transformer (Trm) thực hiện self-attention, trong khi các khối màu hồng đại diện cho embedding input ban đầu của các mục:

![](images/image2.png)
_Kiến trúc SASRec, thể hiện cách self-attention kết nối các mục trong chuỗi tuần tự để học biểu diễn gợi ý._

### BERT4Rec

BERT4Rec là một mô hình gợi ý tuần tự dựa trên kiến trúc Transformer, được thiết kế để học biểu diễn ngữ cảnh hai chiều (bidirectional context) nhằm cải thiện độ chính xác trong dự đoán sản phẩm tiếp theo mà người dùng có thể quan tâm. Khác với các mô hình gợi ý tuần tự truyền thống như RNN-based methods và SASRec, BERT4Rec không giới hạn trong việc học thông tin từ quá khứ mà có thể tận dụng toàn bộ chuỗi lịch sử để tạo ra biểu diễn mạnh mẽ hơn.

Các phương pháp trước đó, như SASRec, sử dụng self-attention nhưng vẫn là một mô hình unidirectional, tức là chỉ dựa vào thông tin từ các mục trước đó để dự đoán mục tiếp theo. Trong khi đó, BERT4Rec áp dụng kiến trúc bidirectional Transformer, giúp mô hình hóa hành vi người dùng bằng cách tận dụng cả ngữ cảnh phía trước và phía sau của một mục được quan tâm​.

  5. **Kiến trúc của BERT4Rec**


BERT4Rec được xây dựng dựa trên stacked bidirectional Transformer layers. Tại mỗi lớp, mô hình liên tục cập nhật biểu diễn của từng vị trí bằng cách trao đổi thông tin giữa tất cả các vị trí trong chuỗi thông qua self-attention mechanism. So với các mô hình RNN truyền thống, phương pháp này giúp BERT4Rec loại bỏ giới hạn của gradient vanishing/exploding trong RNN, cùng với đó tận dụng được toàn bộ lịch sử người dùng, không chỉ dựa vào quá khứ. Phương phá này cũng có thể xử lý song song trên GPU, giúp huấn luyện nhanh hơn.

Mỗi tầng Transformer trong BERT4Rec bao gồm:

  1. Multi-Head Self-Attention (MHSA): Cho phép mô hình tập trung vào nhiều khía cạnh khác nhau của dữ liệu tuần tự.

  2. Position-wise Feed-Forward Network (PFFN): Áp dụng các biến đổi phi tuyến lên từng phần tử trong chuỗi.

  3. Layer Normalization & Residual Connections: Giúp cải thiện quá trình tối ưu hóa.


Biểu diễn đầu vào của BERT4Rec bao gồm:

  * Item Embedding: Biểu diễn nhúng của sản phẩm.

  * Positional Embedding: Mô hình hóa vị trí của sản phẩm trong chuỗi.

![A diagram of a flowchart AI-generated content may be incorrect.](images/image3.png)

  * Segment Embedding (loại bỏ trong BERT4Rec): Khác với BERT trong NLP, BERT4Rec không sử dụng nhúng phân đoạn do chỉ làm việc với một chuỗi tương tác duy nhất​BERT4Rec.


![](images/image4.png)

  1. **Mục tiêu Cloze trong BERT4Rec**


Một điểm khác biệt quan trọng của BERT4Rec so với các mô hình trước đó là sử dụng Cloze objective, thay vì dự đoán trực tiếp mục tiếp theo như RNN hoặc SASRec. Cụ thể, BERT4Rec ẩn ngẫu nhiên một số mục trong chuỗi đầu vào và huấn luyện mô hình để dự đoán lại chúng. Công thức tối ưu hóa được biểu diễn như sau:

$$
L=−∑t∈MlogP(vt|S{vt};θ)L =   -  sum_{t in M}^{}{logPleft( v_{t} middle| Stext{{}v_{t} right};theta)}
$$

Trong đó:

  * M là tập hợp các vị trí bị ẩn

  * S là chuỗi tương tác của người dùng

  * θ là tham số mô hình

  * $vtv_{t}$ là sản phẩm cần dự đoán.

# Public_111

Trong các phần trước ta đã làm quen với vấn đề suy diễn xác suất, trong đó cho trước một số bằng chứng _E_ 1, …, _E n_, cần tính xác suất điều kiện _P_ ( _Q_ | _E_ 1, …, _E n_) để kết luận về câu truy vấn _Q_.

Xác suất điều kiện trên có thể tính được nếu biết toàn bộ xác suất đồng thời của các biến ngẫu nhiên. Tuy nhiên, trên thực tế, các bài toán thường có số lượng biến ngẫu nhiên lớn, dẫn tới số lượng xác suất đồng thời tăng theo hàm mũ. Do vậy, liệt kê và sử dụng bảng xác suất đồng thời đầy đủ để suy diễn là không thực tế.

Để khắc phục khó khăn trên, trong phần này ta sẽ xem xét cách sử dụng mạng Bayes như một mô hình biểu diễn xác suất rút gọn và cách thực hiện suy diễn xác suất trên mạng Bayes.

### **1.Khái niệm mạng Bayes**

Để tiện cho việc trình bày khái niệm mạng Bayes, xét một ví dụ sau3.

_Một người đi làm về và muốn dự đoán xem ở nhà có người không thông qua một số dấu hiệu có thể quan sát được. Cho biết một số dữ kiện sau:_

\- _Nếu cả nhà đi vắng thì thường bật đèn ngoài sân. Tuy nhiên, đèn ngoài sân có thể được cả trong một số trường hợp có người ở nhà, ví dụ khi có khách đến chơi._ \- _Nếu cả nhà đi vắng thì thường buộc chó ở sân sau._

\- _Tuy nhiên chó có thể được buộc ở sân sau cả khi có người ở nhà nếu như chó bị đau bụng._

\- _Nếu chó buộc ở ngoài thì có thể nghe tiếng sủa, tuy nhiên có thể nghe tiếng sủa (của chó hàng xóm) cả khi chó không buộc ở ngoài._

Để thực hiện suy diễn xác suất cho bài toán trên, trước tiên cần xây dựng mô hình xác suất. Ta sẽ sử dụng năm biến ngẫu nhiên sau để thể hiện các dữ kiện liên quan tới bài toán.

O: không ai ở nhà

L: đèn sáng
D: chó ở ngoài
B: chó bị ốm.
H: nghe thấy tiếng sủa.

Việc phân tích bài toán cho thấy:

\- Nếu biết D thì H không phụ thuộc vào O, L, B.
\- Nếu biết B thì D độc lập với O.
\- O và B độc lập với nhau

Tiếp theo, ta xây dựng một đồ thị, trong đó mỗi biến ngẫu nhiên ở trên được biểu diễn bởi một nút như trên hình vẽ dưới đây (hình 4.1). Các nút được nối với nhau bằng những cung có hướng sao cho hai hai nút có quan hệ phụ thuộc được nối bởi một cung và hướng của cung thể hiện chiều tác động của nút gốc tới nút đích. Với đồ thị có hướng, ta có thể xác định quan hệ giữa các nút như sau: nếu tồn tại cung có hướng từ nút A tới nút B thì nút A được gọi là nút cha (mẹ) và nút B là nút con.

![](images/image1.png)

Hình 4.1: Một ví dụ mạng Bayes

Sau khi có đồ thị, ta thêm vào _bảng xác suất điều kiện_. Bảng xác suất điều kiện thể hiện xác suất của biến khi biết giá trị cụ thể của các biến ở các nút cha mẹ. Trong trường hợp nút không có cha mẹ, xác suất trở thành xác suất tiền nghiệm. Để thuận tiện, bảng xác suất điều kiện được thể hiện ngay trên hình vẽ cùng với đồ thị.

Đồ thị vừa xây dựng cùng với các bảng xác suất điều kiện tạo thành mạng Bayes cho bài toán trong ví dụ trên.

_**Định nghĩa:**_ Mạng Bayes là một mô hình xác suất bao gồm 2 phần

\- Phần thứ nhất là một đồ thị có hướng không chứa chu trình, trong đó mỗi nút tương ứng với một biến ngẫu nhiên, các cung thể hiện mối quan hệ phụ thuộc giữa các biến.

\- Phần thứ hai là các bảng xác suất điều kiện: mỗi nút có một bảng xác suất điều kiện cho biết xác suất các giá trị của biến khi biết giá trị các nút cha mẹ.

Cấu trúc của đồ thị trong mạng Bayes thể hiện mối quan hệ phụ thuộc hoặc độc lập giữa các biến ngẫu nhiên của bài toán. Hai nút được nối với nhau bởi một cung khi giữa hai nút có quan hệ trực tiếp với nhau, trong đó giá trị nút gốc ảnh hưởng tới giá trị nút đích.

Lưu ý rằng trong cấu trúc của mạng Bayes không cho phép có chu trình. Hạn chế này ảnh hưởng tới khả năng mô hình hóa của mạng Bayes trong một số trường hợp tuy nhiên cho phép đơn giản hóa việc xây dựng và suy diễn trên mạng Bayes.

Bảng xác suất điều kiện xác định cụ thể ảnh hưởng của các nút cha mẹ tới giá trị nút con. Ở đây ta chỉ xét trường hợp biến ngẫu nhiên có thể nhận giá trị rời rạc và bảng xác suất điều kiện được cho theo tổ hợp giá trị của các nút cha mẹ. Mỗi d ng trong bảng tương ứng với một điều kiện cụ thể, thực chất là một tổ hợp giá trị các nút cha. Ví dụ, trong mạng Bayes của ví dụ trên, d ng thứ nhất trong bảng xác suất của nút D ứng với điều kiện trong đó O = True và B = True. Nếu nút không có cha mẹ thì bảng xác suất chỉ gồm một d ng duy nhất như trường hợp với nút O và nút B.

### **2\. Tính độc lập xác suất trong mạng Bayes**

Mạng Bayes thể hiện hai thông tin chính.

_Thứ nhất_ , đây là biểu diễn rút gọn của toàn bộ xác suất đồng thời. Trong ví dụ trên ta chỉ cần 10 xác suất thay vì 25-1 xác suất đồng thời. Tùy theo kích thước và đặc điểm cụ thể của bài toán, hiệu quả của việc rút gọn số lượng xác suất có thể lớn hơn rất nhiều. Chẳng hạn, với mạng gồm 30 nút nhị phân, mỗi nút có 5 nút cha, ta cần tất cả 960 xác suất điều kiện cho mạng Bayes, trong khi bảng xác suất đồng thời cho 30 biến như vậy phải có 230-1, tức là hơn một tỷ dòng.

_Thứ hai_ , mạng Bayes cho thấy sự phụ thuộc hoặc độc lập xác suất có điều kiện giữa các biến. Về thực chất, chính việc độc lập về xác suất dẫn tới khả năng biểu diễn rút gọn các xác suất đồng thời.

Tính độc lập xác suất trong mạng Bayes thể hiện qua tính chất sau.

**_Tính chất:_**

\- Mỗi nút trên mạng Bayes độc lập có điều kiện với tất cả các nút không phải là hậu duệ của nút đó nếu biết giá trị các nút cha.

\- Mỗi nút độc lập có điều kiện với tất cả các nút khác trên mạng nếu biết giá trị tất cả nút cha, nút con và nút cha của các nút con.

Ví dụ: Theo mạng Bayes trong ví dụ trên H độc lập với O, L, B nếu biết giá trị của D.

**Tính các xác suất đồng thời**

Sử dụng tính độc lập xác suất vừa phát biểu ở trên, có thể tính xác suất đồng thời của tất cả các biến. Xét ví dụ sau

_**Ví dụ:**_ cần tính _P(H, D, L, ¬O, B)_

Theo công thức chuỗi:

_P(H, D, L,¬ O, B) = P(H| D, L, ¬O, B) * P(D| L,¬ O, B) * P(L|¬ O, B) * P(¬O|B) * P(B)_ Do tính độc lập xác suất (có điều kiện):

_P (H| B, D, ¬O, L) = P(H|D)_

_P(D| L, ¬O, B) = P(D|¬ O, B)_

_P(L| ¬O, B) = P(L|¬O)_

_P(¬O|B)=P(O)_

do vậy,

_P(H, D, L,¬ O, B) = P(H| D, L, ¬O, B) * P(D| L,¬ O, B) * P(L|¬ O, B) * P(¬O|B) * P(B) = P(H|¬O) * P(D|¬ O, B) * P(L|¬O) * P(¬O) * P(B)_

Một cách tổng quát, giả sử mạng có n nút tương ứng với n biến ngẫu nhiên _X_ 1, …, _X n_ của bài toán đang xét. Từ thông tin của mạng, có thể tính mọi xác suất đồng thời của n biến, trong đó mỗi xác suất đồng thời có dạng _P_ ( _X_ 1 = _x_ 1 ∧ _X_ 2 = _x_ 2 ∧…∧ _X n_ = _x n_) hay viết gọn là _P_ ( _x_ 1, …, _x n_). Xác suất đồng thời được tính theo công thức tổng quát sau:

_n_
_P_ ( _X_ 1 = _x_ 1,..., _X n _= _x n _) = ∏ _P_ ( _X i _= _x i _| _cha_ _ _me_ ( _X i _))
_i_ =1
hay viết gọn là
_n_
_P_ ( _x_ 1,..., _x n _) = ∏ _P_ ( _x i _| _cha_ _ _me_ ( _X i _))
_i_ =1
trong đó _cha_me_ ( _X i_) là giá trị cụ thể các nút cha mẹ của nút _X i_.

Để minh họa cho công thức trên, ta sẽ tính xác suất xẩy ra tình huống ở nhà có người, chó bị ốm và được buộc ngoài sân, đồng thời đèn không sáng và nghe tiếng chó sủa. Xác suất tình huống này chính là _P(B, ¬O, D, ¬L, H)_ và được tính như sau:

_P(B, ¬O, D, ¬L, H) = P(B) * P(¬O) * P(D|¬O, B) * P(H|D) * P(¬L|˥O)_

_=_ 0,3 * 0,4 * 0,05 * 0,7 * 0,3

_=_ 0,00126

Trong một phần trên ta đã thấy rằng nếu có mọi xác suất đồng thời thì có thể thực hiện suy diễn xác suất cho mọi dạng câu truy vấn. Như vậy, với mạng Bayes ta có thể suy diễn bằng cách trước tiên tính ra mọi xác suất đồng thời cần thiết. Tuy nhiên, cách này đòi hỏi tính toán nhiều và vì vậy trên thực tế thường sử dụng một số phương pháp suy diễn khác hiệu quả hơn. Vấn đề này sẽ được nhắc tới trong một phần sau.

### **3\. Cách xây dựng mạng Bayes**

Để có thể sử dụng, trước tiên cần xây dựng ra mạng Bayes. Quá trình xây dựng mạng Bayes bao gồm việc xác định tất cả các biến ngẫu nhiên liên quan, xác định cấu trúc đồ thị của mạng, và cuối cùng là xác định giá trị cho các bảng xác suất điều kiện. Trong phần này, ta sẽ coi như đã có biến ngẫu nhiên, việc xây dựng mạng chỉ bao gồm xác định cấu trúc và bảng xác suất điều kiện.

Có hai cách tiếp cận chính để xây dựng mạng Bayes.

• Cách thứ nhất do con người (chuyên gia) thực hiện dựa trên hiểu biết của mình về bài toán đang xét. Việc xây dựng mạng được chia thành hai bước: xác định cấu trúc đồ thị và điền giá trị cho bảng xác suất điều kiện.

• Cách thứ hai là tự động xác định cấu trúc và xác suất điều kiện từ dữ liệu. Ở đây, dữ liệu có dạng giá trị các biến ghi nhận được trong quá khứ, ví dụ ta có thể ghi lại tổ hợp cá giá trị của năm biến trong ví dụ trên trong thời gian vài năm. Quá trình xây dựng mạng khi đó bao gồm xác định cấu trúc của đồ thị và bảng xác suất điều kiện sao cho phân bố xác suất do mạng thể hiện phù hợp nhất với tần suất xuất hiện các giá trị trong tập dữ liệu.

Phần này chỉ xem xét cách xây dựng mạng do con người thực hiện và mô tả một quy trình cụ thể cho việc xây dựng mạng.

Các bước xây dựng mạng được thực hiện như trên hình 4.2. Sau khi đã có cấu trúc mạng, chuyên gia sẽ xác định giá trị cho các bảng xác suất điều kiện. Thông thường, việc xác định giá trị xác suất điều kiện khó hơn nhiều so với việc xác định cấu trúc mạng, tức là xác định quan hệ giữa các nút.


| B1:Xác định các biến ngẫu nhiên cho phép mô tả
miền của bài toán.B2:Sắp xếp các biến theo một thứ tự nào đó. Ví dụ
theo thứ tự sau: X1, X2… Xn.B3:For i = 1 to n doa.Thêm một nút mới Xivào mạngb.Xác định tập Cha_Mẹ(Xi) là tập nhỏ nhất
các nút đã có trước đó sao cho Xiđộc lập có điều kiện với
tất cả nút còn lại khi biết bố mẹ của Xi.c.Với mỗi nút thuộc tập Cha_Mẹ(Xi). Ta thêm
một cạnh có hướng từ nút đó tới Xi.d.Xác định bảng xác suất điều kiện cho Xithe các giá trị của bố mẹ hoặc bằng xác suất tiền nghiệm nếu
Xikhông có bố mẹ. |
| --- |

 

Hình 3.1 **:** Phương pháp xây dựng mạng Bayes

Để minh họa, xét ví dụ sau. Một người vừa lắp hệ thống báo động chống trộm ở nhà. Hệ thống sẽ phát tiếng động khi có trộm. Tuy nhiên, hệ thống có thể báo động (sai) nếu có chấn động do động đất. Trong trường hợp nghe thấy hệ thống báo động, hai người hàng xóm tên làm Nam và Việt sẽ gọi điện cho chủ nhà. Do nhiều nguyên nhân khác nhau, Nam và Việt có thể thông báo sai, chẳng hạn do ồn nên không nghe thấy chuông báo động hoặc ngược lại, nhầm âm thanh khác là tiếng chuông.

Theo phương pháp trên, các bước xây dựng mạng được thực hiện như sau.

  * B1: lựa chọn biến: sử dụng 5 biến sau


T (có trộm), Đ (động đất), B (chuông báo động), N (Nam gọi điện), V (Việt gọi điện)

  * B2: các biến được sắp xếp theo thứ tự T, Đ, B, N, V

  * B3: thực hiện như các bước ở hình vẽ, ta xây dựng được mạng thể hiện trên hình sau (để đơn giản, trên hình vẽ chỉ thể hiện cấu trúc và không có bảng xác suất điều kiện).


![](images/image2.png)

Hình 3.2.: Kết quả xây dựng mạng Bayes cho ví dụ chuông báo trộm

**Ảnh hướng của việc sắp xếp các nút tới kết quả xây dựng mạng**.

Trên thực tế, việc xây dựng mạng Bayes không đơn giản, đặc biệt trong việc chọn thứ tự các nút đúng để từ đây chọn được tập nút cha có kích thước nhỏ. Để làm rõ điểm này, ta giả sử trong ví dụ trên, các biến được xếp theo thứ tự khác: N, V, C, T, Đ.

Các bước thêm nút sẽ thực hiện như sau:

\- Thêm nút N: không có nút cha

\- Thêm nút V: nếu Nam gọi điện, xác suất Việt gọi điện sẽ tăng lên do sự kiện Nam gọi điện nhiều khả năng do có báo động và do vậy xác suất Việt nghe thấy chuông và gọi điện tăng theo. Do vậy N có ảnh hướng tới V và được thêm vào tập cha của V.

\- Thêm C: Nếu Nam và Việt cùng gọi thì khả năng có chuông cao hơn, do vậy cần thêm cả N và V vào tập cha của C.

\- Thêm T: Nếu đã biết trạng thái của chuông thì không cần quan tâm tới Nam và Việt nữa, do vậy chỉ có C là cha của T.

\- Thêm Đ: nếu có chuông, khả năng động đất tăng lên. Tuy nhiên, nếu đồng thời ta biết có trộm thì việc có trộm giải thích phần nào nguyên nhân chuông kêu. Như vậy, cả chuông và có trộm ảnh hướng tới xác suất động đất, tức là C và T đều là cha của Đ.

Kết quả của mạng Bayes xây dựng theo thứ tự mới được thể hiện trên hình dưới. So sánh với kết quả ở trên, mạng Bayes mới phức tạp hơn, theo nghĩa có nhiều cung hơn hay trung bình các nút có nhiều nút cha hơn. Ngoài ra, ý nghĩa một số quan hệ trên mạng rất không trực quan và khó giải thích, chẳng hạn việc xác suất động đất phục thuộc vào chuông báo động và có trộm. Như vậy, mặc dù cả hai mạng Bayes xây dựng ở trên đều đúng theo nghĩa đảm bảo các ràng buộc về xác suất và đều cho phép tính ra các xác suất đồng thời, việc lựa chọn không đúng thứ tự nút sẽ làm mạng khó hiểu và phức tạp hơn.

![](images/image3.png)

Hình 3.3: Kết quả xây dựng mạng Bayes khi sử dụng thứ tự các nút khác

Từ ví dụ trên ta có thể đưa ra một số nhận xét về kết quả xây dựng mạng Bayes.

_**_Nhận xét:_**_

\- Cùng một tập hợp biến có thể xây dựng nhiều mạng Bayes khác nhau.
\- Thứ tự sắp xếp có ảnh hưởng tới mạng Bayes. Nên sắp xếp sao cho các nút đóng vai tr nguyên nhân đứng trước nút hệ quả.
\- Tất cả các mạng được xây dựng như trên đều hợp lệ, theo nghĩa không vi phạm các ràng buộc về xác suất và đều cho phép thực hiện suy diễn.

### **4\. Tính độc lập xác suất tổng quát: khái niệm _d_ -phân cách**

Trong phần trước, ta đã xem xét khả năng biểu diễn tính độc lập xác suất của mạng Bayes, ví dụ, mỗi _x_ nút độc lập với các nút không phải hậu duệ nếu biết giá trị tất cả nút cha của _x_. Tuy nhiên, đây mới là các trường hợp riêng, trong trường hợp tổng quát cần có khả năng xác định liệu một tập hợp các nút _X_ có độc lập với tập hợp các nút _Y_ khi biết các nút _E_ không. Các tính chất độc lập xác suất đã trình bầy trong phần trước không cho phép trả lời tất cả các câu hỏi tổng quát dạng này. Chẳng hạn, trong ví dụ mạng Bayes trên hình 4.1 dưới đây, nếu không biết giá trị của nút C thì theo tính chất của mạng Bayes, N và V độc lập (không điều kiện) với nhau do V không phải hậu duệ của N và N không có cha. Tuy nhiên, nếu đã biết giá trị của C thì N và V còn độc lập với nhau không? Hai tính chất trình bày trong phần trước không cho phép trả lời câu hỏi này.

![](images/image4.png)

Hình 4.1. Ví dụ mạng Bayes

Trong phần này, ta sẽ xem xét cách trả lời câu hỏi về tính độc lập của tập các nút X với tập nút Y khi biết tập nút E trên một mạng Bayes bằng cách sử dụng khái niệm _d_ - _phân cách_ ( _d_ -separation).

Nguyên lý chung của _d_ -phân cách là gắn khái niệm phụ thuộc xác suất với tính kết nối (tức là có đường đi giữa các nút), và khái niệm độc lập xác suất với tính không kết nối, hay chia cắt, trên đồ thị có hướng khi ta biết giá trị một số nút _E_. Chữ “ _d_ ” ở đây là viết tắt của từ “directional” tức là “có hướng”. Theo đó, các nút _X_ và các nút _Y_ là _d_ -kết nối với nhau nếu chúng không bị _d_ -phân cách. _Nếu các nút X và các nút Y bị d-phân cách bởi các nút E thì X và Y là độc lập xác suất với nhau khi biết E_.

Để xác định tính _d_ -phân cách của tập X và Y, trước tiên ta cần xác định tính _d_ -phân cách giữa hai nút đơn _x_ thuộc _X_ và _y_ thuộc _Y_. Từ đây, hai tập nút sẽ độc lập với nhau nếu mỗi nút trong tập này độc lập với tất cả các nút trong tập kia. Sau đây là các quy tắc cho phép xác định tính _d_ -phân cách hay tính độc lập xác suất của hai biến _x_ và _y_.

**Quy tắc 1** : nút _x_ và _y_ được gọi là _d_ -kết nối nếu tồn tại đường đi không bị phong tỏa giữa hai nút. Ngược lại, nếu không tồn tại đường đi như vậy thì _x_ và _y_ là _d_ -phân cách.

Trong quy tắc này, đường đi là một chuỗi các cung nằm liền nhau, không tính tới hướng của các cung đó. Đường đi không bị phong tỏa là đường đi mà trên đó không có hai cung liền kề hướng vào nhau. Trong trường hợp tồn tại hai cung như vậy thì thông tin sẽ không thể đi qua được và do vậy các nút không thể kết nối với nhau. Nút có hai cung hướng vào như vậy gọi là _nút xung đột_.

Ví dụ, trong trường hợp sau:
![](images/image5.png)

giữa _x_ và _y_ tồn tại đường đi _x_ \- _r_ \- _s_ \- _t_ \- _u_ \- _v_ \- _y_ , tuy nhiên _t_ là nút xung đột do hai cung _st_ và _ut_ hướng vào nhau. Đường đi _x_ \- _r_ \- _s_ \- _t_ và _t_ \- _u_ \- _v_ \- _y_ là các đường đi không bị phong tỏa, do vậy _x_ và _t_ là d-kết nối, _t_ và _y_ cũng vậy. Tuy vậy, _x_ và _y_ không phải là _d_ -kết nối do không tồn tại đường đi nào không qua nút xung đột _t_. Như vậy, _x_ và _y_ là _d_ -phân cách trên mạng này và do vậy độc lập xác suất (không điều kiện) với nhau.

Tính kết nối và phân cách xác định theo quy tắc 1 là không điều kiện và do vậy tính độc lập xác suất được xác định theo quy tắc 1 là _độc lập không điều kiện_.

**Quy tắc 2** : nút _x_ và _y_ là _d_ -kết nối có điều kiện khi biết tập nút _E_ nếu tồn tại đường đi không bị phong tỏa (không chứa nút xung đột) và không đi qua bất cứ nút nào thuộc _E_. Ngược lại, nếu không tồn tại đường đi như vậy thì ta nói rằng _x_ và _y_ là _d_ -phân cách bởi _E_. Nói cách khác, mọi đường đi giữa _x_ và _y_ (nếu có) đều bị _E_ phong tỏa.

Quy tắc 2 là cần thiết do khi ta biết giá trị một số nút (tập nút _E_ ), tính chất độc lập hay phụ thuộc giữa các nút c n lại có thể thay đổi: một số nút độc lập trở nên phụ thuộc, và ngược lại, một ss nút phụ thuộc trở thành độc lập. Tính độc lập hay phụ thuộc trong trường hợp này được gọi là _d_ -phân cách có điều kiện theo tập biến _E_.

Ví dụ: trên hình sau, giả sử tập _E_ gồm hai nút _r_ và _v_ được khoanh tr n. Theo quy tắc 2, không tồn tại đường đi không bị phong tỏa nào giữa _x_ và _y_ mà không đi qua _E_ , do đó _x_ và _y_ là _d_ -phân cách khi biết _E_. Tương tự như vậy: _x_ và _s_ , _u_ và _y_ , _s_ và _u_ là _d_ -phân cách khi biết _E_ do đường đi _s_ – _r_ – _t_ đi qua nút _r_ thuộc _E_ , đường đi _y_ – _v_ – _s_ đi qua nút _v_ thuộc _E_ , c n đường đi _s_ – _t_ – _u_ là đường đi bị phong tỏa tại nút xung đột _t_ theo quy tắc 1. Chỉ có các cặp nút _s_ và _t_ , _t_ và _u_ là không bị phong tỏa bởi _E_.

![](images/image6.png)

**Quy tắc 3** : nếu một nút xung đột là thành viên của tập _E_ , hoặc có hậu duệ thuộc tập _E_ , thì nút đó không c n phong tỏa các đường đi qua nó nữa.

Quy tắc này được sử dụng cho trường hợp ta biết một sự kiện được gây ra bởi hai hay nhiều nguyên nhân. Khi ta đã biết một nguyên nhân là đúng thì xác suất những nguyên nhân c n lại giảm đi, và ngược lại nếu ta biết một nguyên nhân là sai thì xác suất những nguyên nhân c n lại tăng lên. Chẳng hạn, xẩy ra tai nạn máy bay với hai nguyên nhân là trục trặc kỹ thuật hoặc lỗi của con người. Nếu ta đã xác định được xẩy ra trục trặc kỹ thuật thì xác suất lỗi con người sẽ bị giảm đi (mặc dù không loại trừ hoàn toàn).

_Ví dụ_ : trên ví dụ ở hình sau, giả sử tập E gồm các nút r và p được đánh dấu bằng cách khoanh tr n. Theo quy tắc 3, nút s và y là d-kết nối do nút xung đột t có hậu duệ là nút p thuộc E, do vậy đã giải tỏa đường đi s – t – u – v – y. Trong khi đó x và u vẫn là d-phân cách do mặc dù t đã được giải tỏa nhưng nút r vẫn bị phong tỏa theo quy tắc 2.

![](images/image7.png)

# Public_112

## **PHÂN LOẠI BAYES ĐƠN GIẢN**

Phần này sẽ đề cập tới phân loại Bayes đơn giản (Naïve Bayes), một phương pháp phân loại đơn giản nhưng có nhiều ứng dụng trong thực tế như phân loại văn bản, dự đoán sắc thái văn bản, lọc thư rác, chẩn đoán y tế. Phân loại Bayes đơn giản là trường hợp riêng của kỹ thuật học máy Bayes, trong đó các giả thiết về độc lập xác suất được sử dụng để đơn giản hóa việc tính xác suất.

### **1\. Phương pháp phân loại Bayes đơn giản**

Tương tự như học cây quyết định ở trên, phân loại Bayes đơn giản sử dụng trong trường hợp mỗi ví dụ được cho bằng tập các thuộc tính < _x_ 1, _x_ 2, …, _x n_> và cần xác định nhãn phân loại y, y có thể nhận giá trị từ một tập nhãn hữu hạn _C_.

Trong giai đoạn huấn luyện, dữ liệu huấn luyện được cung cấp dưới dạng các mẫu < **x _i_** , _y i_>. Sau khi huấn luyện xong, bộ phân loại cần dự đoán nhãn cho mẫu mới **x**.

Theo lý thuyết học Bayes, nhãn phân loại được xác định bằng cách tính xác suất điều kiện của nhãn khi quan sát thấy tổ hợp giá trị thuộc tính < _x_ 1, _x_ 2, …, _x n_>. Thuộc tính được chọn, ký hiệu _c MAP_ là thuộc tính có xác suất điều kiện cao nhất (MAP là viết tắt của maximum a posterior), tức là:

![](images/image1.png)

Sử dụng quy tắc Bayes, biểu thức trên được viết lại như sau

![](images/image2.png)

Trong vế phải của biểu thức này, mẫu số không phụ thuộc vào _c j_ và vì vậy không ảnh hưởng tới giá trị của _C MAP_. Do đó, ta có thể bỏ mẫu số và viết lại như sau:

![](images/image3.png)

Hai thành phần trong biểu thức trên được tính từ dữ liệu huấn luyện. Giá trị _P_ ( _c j_) được tính bằng tần suất quan sát thấy nhãn _c j_ trên tập huấn luyện, tức là bằng số mẫu có nhãn là _c j_ chia cho tổng số mẫu. Việc tính _P_ ( _x_ 1, _x_ 2,..., _x n _| _c j_) khó khăn hơn nhiều. Vấn đề là số tổ hợp giá trị của _n_ thuộc tính cùng với nhãn phân loại là rất lớn khi _n_ lớn. Để tính xác suất này được chính xác, mỗi tổ hợp giá trị thuộc tính phải xuất hiện cùng nhãn phân loại đủ nhiều, trong khi số mẫu huấn luyện thường không đủ lớn.

Để giải quyết vấn đề trên, ta giả sử các thuộc tính là độc lập về xác suất với nhau khi biết nhãn phân loại _c j_. Trên thực tế, các thuộc tính thường không độc lập với nhau như vậy, chẳng hạn đối với ví dụ chơi tennis, khi trời nắng thì xác suất nhiệt độ cao cũng lớn hơn. Chính vì dựa trên giả thiết độc lập xác suất đơn giản như vậy nên phương pháp có tên gọi “Bayes đơn giản”. Tuy nhiên, như ta thấy sau đây, giả thiết như vậy cho phép tính xác suất điều kiện đơn giản hơn nhiều và trên thực tế phân loại Bayes có độ chính xác tốt trong rất nhiều ứng dụng.

Với giả thiết về tính độc lập xác suất có điều kiện, có thể viết:
_P_ ( _x_ 1, _x_ 2,..., _x n _| _c j_) = _P_ ( _x_ 1 | _c j_) _P_ ( _x_ 2 | _c j_) … _P_ ( _x n _| _c j_)

tức là xác suất đồng thời quan sát thấy các thuộc tính bằng tích xác suất điều kiện của tứng thuộc tính riêng lẻ. Thay vào biểu thức ở trên, ta được **bộ phân loại Bayes đơn giản** (có đầu ra ký hiệu là _c NB_) như sau.

_c NB _= argmax _P_ ( _c j_) ∏ _P_ ( _x i _| _c j_)

_c j_∈ _C i_

trong đó, _P_ ( _x i _| _c j_) được tính từ dữ liệu huấn luyện bằng số lần _x i_ xuất hiện cùng với _c j_ chia cho số lần _c j_ xuất hiện. Việc tính xác suất này đòi hỏi ít dữ liệu hơn nhiều so với tính _P_ ( _x_ 1, _x_ 2,..., _x n _| _c j_).

Trên hình 1 là biểu diễn mô hình phân loại Bayes đơn giản dưới dạng mạng Bayes. Các thuộc tính không được nối với nhau bởi các cạnh và do vậy các thuộc tính độc lập xác suất với nhau nếu biết giá trị của nhãn phân loại.

![](images/image4.png)

Hình 1: Mô hình Bayes đơn giản: các thuộc tính Xi độc lập xác suất với nhau nếu biết giá trị nhãn phân loại Y.

**Huấn luyện**.

Quá trình huấn luyện hay học Bayes đơn giản là quá trình tính các xác suất _P_ ( _c j_) và các xác suất điều kiện _P_ ( _x i _| _c j_) bằng cách đếm trên tập dữ liệu huấn luyện. Như vậy, khác với học cây quyết định, Học Bayes đơn giản không đòi hỏi tìm kiếm trong không gian các bộ phân loại. Các xác suất _P_ ( _c j_) và các xác suất điều kiện _P_ ( _x i _| _c j_) được tính trên tập dữ liệu huấn luyện theo công thức sau:

![](images/image5.png)

![](images/image6.png)

**Ví dụ**.

Để minh họa cho kỹ thuật học Bayes đơn giản, ta sử dụng lại bài toán phân chia ngày thành phù hợp hay không phù hợp cho việc chơi tennis theo điều kiện thời tiết đã được sử dụng trong phần học cây quyết định với dữ liệu huấn luyện cho trong bảng 4.1. Giả sử phải xác định nhãn phân loại cho ví dụ sau:

< Trời = nắng, Nhiệt độ = trung bình, Độ ẩm = cao, Gió = mạnh >

Thay số liệu của bài toán vào công thức Bayes đơn giản, ta có:

_c NB _= argmax _P_ ( _c j _) ∏ _P_ ( _x i _| _c j _)

_cj_ ∈ _C_ _i_

= argmax

_cj_ ∈{ _co_ , _khong_ }

_P_ (Trời=nắng| _c j_) _P_ (Nh. độ=t. bình| _c j_) _P_ (Độ ẩm=cao| _c j_) _P_ (Gió=mạnh | _c j_) _P_ ( _c j_)

Do _c j_ có thể nhận hai giá trị, ta cần tính 10 xác suất. Các xác suất _P_ (có) và _P_ (không) được tính bằng tất suất “có” và “không” trên dữ liệu huấn luyện.

_P_ (có) = 9/14 = 0,64  
_P_ (không) = 5/14 = 0,36

Các xác suất điều kiện cũng được tính từ dữ liệu huấn luyện, ví dụ ta có:

_P_ (Độ ẩm = cao | có) = 3/9 = 0,33  
_P_ (Độ ẩm = cao | không) = 4/5 = 0,8

Thay các xác suất thành phần vào công thức Bayes đơn giản, ta được:

_P_ (có) _P_ (nắng|có) _P_ (trung bình|có) _P_ (cao|có) _P_ (mạnh|có) = 0.0053

_P_ (không) _P_ (nắng|không) _P_ (trung bình|không) _P_ (cao|không) _P_ (mạnh|không) = 0.0206

Như vậy, theo phân loại Bayes đơn giản, ví dụ đang xét sẽ được phân loại là “không”. Cần chú ý rằng, 0.0053 và 0.0206 không phải là xác suất thực của nhãn “có” và “không”. Để tính xác suất thực, ta cần chuẩn hóa để tổng hai xác suất bằng 1. Việc chuẩn hoá được thực hiện bằng cách chia mỗi số cho tổng của hai số. Chẳng hạn xác suất có chơi sẽ bằng 0.0053/(0.0053+0.0206) = 0.205.

### **2\. Vấn đề tính xác suất trên thực tế**

Phân loại Bayes đơn giản đòi hỏi tính các xác suất điều kiện thành phần _P_ ( _x i _| _c j_). Xác suất này được tính bằng _n c _/ _n_ , trong đó _n c_ số lần _x i_ và _c j_ xuất hiện đồng thời trong tập huấn luyện và _n_ là số lần _c j_ xuất hiện.

Trong nhiều trường hợp, giá trị _n c_ có thể rất nhỏ, thậm chí bằng không, và do vậy ảnh hưởng tới độ chính xác khi tính xác suất điều kiện. Nếu _n c_ = 0, xác suất điều kiện cuối cùng sẽ bằng không, bất kể các xác suất thành phần khác có giá trị thế nào.

Để khắc phục vấn đề này, một kỹ thuật được gọi là _làm trơn_ thường được sử dụng. Kỹ thuật làm trơn đơn giản nhất sử dụng công thức tính _P_ ( _x i _| _c j_) như sau:

_P_ ( _x i _| _c j_) = ( _n c _\+ 1) / ( _n_ \+ 1)
Như vậy, kể cả khi _n c_ = 0, xác suất vẫn nhận giá trị khác 0.
Trong trường hợp chung, có thể sử dụng công thức được làm trơn sau:

![](images/image7.png)

trong đó _p_ là xác suất tiền nghiệm của _x i_ và _m_ là tham số cho phép xác định ảnh hưởng của _p_ tới công thức. Nếu không có thêm thông tin gì khác thì xác suất tiền nghiệm thường được tính _p_ = 1 / _k_ , trong đó _k_ là số thuộc tính của thuộc tính _X i_. Ví dụ, nếu không có thêm thông tin gì thêm thì xác suất quan sát thấy Gió = mạnh sẽ là 1/2 do thuộc tính Gió có hai giá trị. Nếu _m_ = 0, ta được công thức không làm trơn ban đầu. Ngược lại, khi m → ∞, xác suất hậu nghiệm sẽ bằng _p_ , bất kể _n c_ thế nào. Trong những trường hợp c n lại, cả _n c _/ _n_ và p cùng đóng góp vào công thức.

### **3\. Ứng dụng trong phân loại văn bản tự động**

Phân loại văn bản tự động là bài toán có nhiều ứng dụng thực tế. Trước tiên, cho một tập huấn luyện bao gồm các văn bản. Mỗi văn bản có thể thuộc vào một trong C loại khác nhau (ở đây ta không xét trường hợp mỗi văn bản có thể thuộc vào nhiều loại khác nhau). Sau khi huấn luyện xong, thuật toán phân loại nhận được văn bản mới và cần xác định phân loại cho văn bản này. Ví dụ, với các văn bản là nội dung thư điện tử, thuật toán có thể phân loại thư thành “thư rác” và “thư bình thường”. Khi huấn luyện, thuật toán học được cung cấp một tập thư rác và một tập thư thường. Sau đó, dựa trên nội dung thư mới nhận, bộ phân loại sẽ tự xác định đó có phải thư rác không. Một ứng dụng khác là tự động phân chia bản tin thành các thể loại khác nhau, ví dụ “chính trị”, “xã hội”, “thể thao”.v.v. như trên báo điện tử.

Phân loại văn bản tự động là dạng ứng dụng trong đó phân loại Bayes đơn giản và các phương pháp xác suất khác được sử dụng rất thành công. Chương trình lọc thư rác mã nguồn mở SpamAssassin (http://spamassassin.apache.org) là một chương trình lọc thư rác được sử dụng rộng rãi với nhiều cơ chế lọc khác nhau, trong đó lọc Bayes đơn giản là cơ chế lọc chính được gán trọng số cao nhất.

Sau đây ta sẽ xem xét cách sử dụng phân loại Bayes đơn giản cho bài toán phân loại văn bản. Để đơn giản, ta sẽ xét trường hợp văn bản có thể nhận một trong hai nhãn: “rác” và “không”.

Để sử dụng phân loại Bayes đơn giản, cần giải quyết hai vấn đề chủ yếu: thứ nhất, biểu diễn văn bản thế nào cho phù hợp; thứ hai: lựa chọn công thức cụ thể cho bộ phân loại Bayes.

Cách thông dụng và đơn giản nhất để biểu diễn văn bản là cách biểu diễn bằng “túi từ” (bag-of-word). Theo cách này, mỗi văn bản được biểu diễn bằng một tập hợp, trong đó mỗi phần tử của tập hợp tương ứng với một từ khác nhau của văn bản. Để đơn giản, ở đây ta coi mỗi từ là một đơn vị ngôn ngữ được ngăn với nhau bởi dấu cách. Lưu ý rằng đây là cách đơn giản nhất, ta cũng có thể thêm số lần xuất hiện thực tế của từ trong văn bản. Cách biểu diễn này không quan tâm tới vị trí xuất hiện của từ trong văn bản cũng như quan hệ với các từ xung quanh, do vậy có tên gọi là túi từ. Ví dụ, một văn bản có nội dung “Chia thư thành thư rác và thư thường” sẽ được biểu diễn bởi tập từ {“chia”, “thư”, “thành”, “rác”, “và”, “thường”} với sáu phần tử.

Giả thiết các từ biểu diễn cho thư xuất hiện độc lập với nhau khi biết nhãn phân loại, công thức Bayes đơn giản cho phép ta viết:

_c NB _= argmax _P_ ( _c j _) ∏ _P_ ( _x i _| _c j _)

_cj_ ∈{ _rac_ , _khong_ } _i_

= argmax

_cj_ ∈{ _rac_ , _khong_ }

_P_ ( _c j_) _P_ (“chia”| _c j_) _P_ (“thư ”| _c j_) _P_ (“thành”| _c j_) _P_ (“rác”| _c j_) _P_ (“và”| _c j_) _P_ (“thường ”| _c j_)

Các xác suất _P_ (“rác”| _c j_) được tính từ tập huấn luyện như mô tả ở trên. Những từ chưa xuất hiện trong tập huấn luyện sẽ bị bỏ qua, không tham gia vào công thức.

Cần lưu ý rằng cách biểu diễn và áp dụng phân loại Bayes đơn giản cho phân loại văn bản vừa trình bày là những phương án đơn giản. Trên thực tế có rất nhiều biến thể khác nhau cả trong việc chọn từ, biểu diễn văn bản bằng các từ, cũng như công thức tính xác suất điều kiện của văn bản.

Mặc dù đơn giản, nhiều thử nghiệm cho thấy, phân loại văn bản tự động bằng Bayes đơn giản có độ chính xác khá cao. Trên nhiều tập dữ liệu thư điện tử, tỷ lệ phân loại chính xác thư rác có thể đạt trên 98%. Kết quả này cho thấy, mặc dù giả thiết các từ độc lập với nhau là không thực tế, độ chính xác phân loại của Bayes đơn giản không bị ảnh hưởng đáng kể.

# Public_113

**1\. Định nghĩa:**

Attention là một kĩ thuật được sử dụng trong các mạng neural, kỹ thuật này được sử dụng trong các mô hình thực hiện các task như dịch máy hay ngôn ngữ tự nhiên. BERT và GPT là 2 mô hình điển hình có sử dụng Attention. Attention là thành phần chính tạo nên sự đình đám của mô hình Transformer, mô hình này chính là sự đột phá trong các bài toán xử lý của NLP so với các mạng neural hồi quy. Vậy Attention là gì mà tại sao nó lại là sự khác biệt đến vậy, hãy cũng tôi đi tìm hiểu trong bài viêt ngày hôm nay với tiêu đề “Attention và sự hình thành của mô hình Transformer”

## **2\. Động lực cho sự phát triển của Attention**

### **2.1. Recurrent Neural Network (RNN) và sự hạn chế đáng kể**

#### **2.1.1. Ý tưởng cốt lõi của RNN**

Con người chúng ta không thể bắt đầu suy nghĩ của mình tại tất cả các thời điểm, cũng giống như việc bạn đang đọc bài viết này, bạn hiểu mỗi chữ ở đây dựa vào các chữ mà bạn đã đọc và hiểu trước đó, chứ không phải đọc xong là quên chữ đó đi rồi đến lúc gặp thì lại phải đọc và tiếp thu lại. Giống như trong bài toán của chúng ta. Các mô hình mạng nơ-ron truyền thống lại không thể làm được việc trên. Vì vậy mạng nơ-ron hồi quy (RNN) được sinh ra để giải quyết việc đó. Mạng này chứa các vòng lặp bên trong cho phép nó lưu lại các thông tin đã nhận được. RNN là một thuật toán quan trọng trong xử lý thông tin dạng chuỗi hay nói cách khác là dạng xử lý tuần tự.

![](images/image1.png)

Vậy như nào là xử lý tuần tự - Xử lý tuần tự là mỗi block sẽ lấy thông tin của block trước và input hiện tại làm đầu vào

![](images/image2.png)

![](images/image3.png)

#### **2.1.2. Ưu điểm và nhược điểm của RNN**


| Ưu điểm | Nhược điểm |
| --- | --- |
| Khả năng xử lý các chuỗi đầu vào có độ dài khác
nhau | Tính toán khá chậm |
| Kích cỡ mô hình không bị tăng lên theo kích thước đầu
vào | Khó truy cập lại thông tin đã đi qua ở một khoảng thời gian
dài trước đó - hay còn gọi là bị quên thông tin khi gặp nhiều thông tin
mới |
| Quá trình tính toán có sử dụng thông tin trước đo | Phải thực hiện tuần tự nên không tận dụng triệt để được khả
năng tính toán song song của GPU |
| Trọng số được chia sẻ trong suốt qua trình học | Vanishing gradient |

 

### **2.2. Vấn đề gặp phải của Long Short Term Memory (LSTM)**

#### **2.2.1 Ý tưởng cốt lõi của LSTM (Long short term memory)**

LSTM là một dạng đặc biệt của RNN, nó có khả năng học các thông tin ở xa. Về cơ bản thì LSTM và RNN không khác nhau là mấy nhưng LSTM có cải tiển một số phép tính trong 1 hidden state và nó đã hiểu quả. Hiệu quả như nào thì chúng ta hãy cũng đọc tiếp nhé!

Cấu trúc của LSTM không khác gì RNN, nhưng sự cải tiến ở đây năm ở phần tính toán trong từng hidden state như sau: Thay vì chỉ có một tầng mạng nơ-ron, LSTM thiết kế với 4 tầng mạng nơ-ron tương tác với nhau một các rất đặc biệt.

Dưới đây là 2 hình ảnh biểu diễn sự khác nhau giữa RNN và LSTM

![](images/image4.png)

![](images/image5.png)

Chìa khóa để giúp LSTM có thể truyền tải thông tin giữa các hidden state một các xuyên suốt chính là cell state (hình dưới):

![](images/image6.png)

![](images/image7.png)

Đầu ra là hàm sigmoid chứa các giá trị từ 0 đến 1.

Nếu forget gate có giá trị bằng 0, LSTM sẽ "quên" trạng thái được lưu trữ trong đơn vị tương ứng của trạng thái cell trước đó.

Nếu cổng quên có giá trị bằng 1, LSTM sẽ chủ yếu ghi nhớ giá trị tương ứng ở trạng thái được lưu trữ.

![](images/image8.png)

![](images/image9.png)

Chứa thông tin có thể được lưu trữ từ time step hiện tại.

![](images/image10.png)

![](images/image11.png)

![](images/image12.png)

![](images/image13.png)

Là bộ nhớ trong của LSTM. Cell state như 1 băng tải truyền các thông tin cần thiết xuyết suất cả quá trình, qua các nút mạng và chỉ tương tác tuyển tính 1 chút. Vì vậy thông tin có thể tuyền đi thông suốt mà không bị thay đổi.

![](images/image14.png)

![](images/image15.png)

# Public_114

### Giới thiệu

Mặc dù công nghệ xử lý hình ảnh đã có nhiều tiến bộ, các hình ảnh thu được vẫn thường không thể hiện đầy đủ chi tiết cảnh hoặc có độ tương phản thấp do giới hạn dải động. Các phương pháp tăng cường tương phản (Contrast Enhancement - CE) đã được phát triển nhằm khắc phục vấn đề này. Tuy nhiên, các phương pháp truyền thống như Histogram Equalization \- HE thường tập trung vào phân phối mức xám tuyệt đối, dẫn đến hạn chế trong việc xử lý tương phản cục bộ và dễ gây hiện tượng quá làm nổi bật ở một số vùng ảnh.

Phương pháp được đề xuất là một thuật toán tăng cường tương phản toàn cục mới, dựa trên khung lý thuyết Layered Difference Representation - LDR. Điểm khác biệt chính của phương pháp này so với các thuật toán truyền thống là việc sử dụng lược đồ 2D để biểu diễn mối quan hệ mức xám giữa các điểm ảnh liền kề, thay vì chỉ xét đến phân phối mức xám đơn lẻ. Điều này cho phép phương pháp tận dụng sự nhạy cảm tự nhiên của hệ thống thị giác con người (Human Visual System - HVS) đối với sự khác biệt mức xám, mang lại kết quả cải thiện tương phản phù hợp hơn với nhận thức thị giác.

Phương pháp LDR kế thừa từ các nghiên cứu sử dụng lược đồ 2D trước đó, chẳng hạn như thuật toán Contextual Visual Contrast (CVC). Tuy nhiên, thay vì chỉ khai thác thông tin biên và cạnh vật thể, phương pháp LDR thiết lập mối quan hệ chặt chẽ giữa lược đồ 2D của ảnh đầu vào và sự khác biệt mức xám trong ảnh đầu ra. Phương pháp này nhấn mạnh các sự khác biệt xuất hiện thường xuyên, qua đó cải thiện tương phản cục bộ và tận dụng tối đa dải động. Điều này giúp LDR vượt qua các hạn chế của HE và CVC, mang lại hình ảnh đầu ra có độ tương phản cao hơn và chất lượng thị giác tốt hơn.

### Mô tả thuật toán

Thuật toán tăng cường tương phản toàn cục được đề xuất dựa trên Layered Difference Representation – LDR. Thuật toán gồm hai thành phần chính: intra-layer optimization và inter-layer aggregation. Các bước chính được mô tả lần lượt dưới đây.

![](images/image1.png)

_Hình minh họa quy trình, thể hiện các bước từ việc trích xuất lược đồ 2D, tối ưu hóa trong lớp, tổng hợp giữa các lớp, đến tái cấu trúc ảnh đầu ra_.

**1\. Trích Xuất Lược Đồ 2D**

  * Bước đầu tiên là xây dựng lược đồ 2D h(k, k+l) từ ảnh đầu vào. Lược đồ này đếm số lượng các cặp điểm ảnh liền kề với mức xám k và k+l, biểu diễn sự khác biệt mức xám giữa các điểm ảnh trong không gian ảnh.

$$
h(k,k+l)=tầnsốcáccặpđiểmảnhcómứcxám(k,k+l)h(k, k + l) =  tần số các cặp điểm ảnh có mức xám (k, k + l)
$$

  * Lược đồ 2D cung cấp thông tin phong phú về sự thay đổi mức xám, giúp phát hiện các đặc điểm cục bộ quan trọng để cải thiện tương phản.


**2\. Intra-Layer Optimization**

  * Lược đồ h(k, k+l) được phân tách thành các lớp (layers), mỗi lớp đại diện cho một khoảng chênh lệch mức xám cụ thể l.

  * Với mỗi lớp l, một vector lược đồ hl được tính toán. Vector này được sử dụng để thiết lập một hệ phương trình tuyến tính, từ đó giải ra vector sự khác biệt dl cho lớp l.


$D•dl=sl,D bullet d_{l} = s_{l},$

với D là ma trận chênh lệch, sl là tổng của hl .

  * Quá trình tối ưu này đảm bảo rằng các sự khác biệt mức xám xuất hiện thường xuyên sẽ được làm nổi bật trong ảnh đầu ra.


**3\. Inter-Layer Aggregation**

  * Các vector khác biệt dl từ tất cả các lớp được tổng hợp lại thành một vector sự khác biệt hợp nhất d, sử dụng một vector trọng số w để xác định mức độ đóng góp của mỗi lớp.


$$
d=∑l=1255wl•dld = sum_{l = 1}^{255}w_{l} bullet d_{l}
$$

  * Quá trình tổng hợp này giúp kết hợp thông tin từ tất cả các lớp, tạo ra một biểu diễn toàn diện cho toàn bộ ảnh.


**4\. Tái Cấu Trúc Hàm Biến Đổi**

  * Vector d được sử dụng để tái cấu trúc hàm biến đổi x, ánh xạ mức xám đầu vào thành mức xám đầu ra.


$$
xk=xk−1+dk−1,∀k∈[1,255]x_{k} = x_{k - 1} + d_{k - 1}, forall k in lbrack 1,255rbrack
$$

  * Hàm biến đổi này được áp dụng để biến đổi ảnh đầu vào, tạo ra ảnh đầu ra với độ tương phản được cải thiện.


**5\. Kết Quả**

  * Hàm biến đổi x được áp dụng lên ảnh đầu vào:

$out=x[img]out =  xlbrack imgrbrack$

  * Phương pháp tập trung vào việc tăng cường các sự khác biệt mức xám thường xuất hiện trong ảnh đầu vào. Điều này giúp cải thiện đáng kể độ tương phản so với các phương pháp truyền thống, đồng thời tận dụng toàn bộ dải động của ảnh.

# Public_115

### Giới thiệu

Trong các điều kiện ánh sáng yếu, ảnh chụp thường bị suy giảm đáng kể về chất lượng, xuất hiện noise và màu sắc không chính xác, gây khó khăn cho các ứng dụng như giám sát an ninh, xử lý y tế, và thị giác máy tính. Nhiệm vụ cải thiện ảnh ánh sáng yếu (Low-Light Image Enhancement - LLIE) nhằm phục hồi chi tiết, cân bằng độ sáng và giảm thiểu nhiễu từ các ảnh bị suy giảm chất lượng. Các phương pháp hiện tại chủ yếu dựa vào mạng nơ-ron học sâu để học hàm ánh xạ từ ảnh ánh sáng yếu sang ảnh sáng chuẩn trên không gian màu sRGB hoặc HSV. Tuy nhiên, các không gian màu này thường không ổn định do mối liên hệ phức tạp giữa độ sáng và màu sắc, dẫn đến sự phụ thuộc mạnh giữa các kênh RGB hoặc sự bất liên tục trên trục màu Hue trong không gian HSV.

Để giải quyết những hạn chế này, phương pháp tiếp cận mới được đề xuất nhằm định nghĩa một không gian màu có khả năng học được, có tên là Horizontal/Vertical-Intensity (HVI). Không gian HVI được thiết kế đặc biệt để tách biệt rõ ràng độ sáng và màu sắc, đồng thời thích ứng với các điều kiện chiếu sáng khác nhau thông qua các tham số học được. Điều này cho phép cải thiện sự ổn định trong việc xử lý ảnh, giảm thiểu hiệu ứng giả màu và lỗi về độ sáng thường gặp trong các không gian màu truyền thống. Bên cạnh đó, không gian HVI cung cấp nền tảng hiệu quả để xây dựng các kiến trúc mạng nơ-ron tối ưu hóa, phù hợp với các thiết bị tài nguyên hạn chế.

Để tận dụng tối đa không gian màu HVI, một mạng học sâu có tên Color and Intensity Decoupling Network (CIDNet) được đề xuất, kết hợp hai nhánh xử lý song song cho độ sáng và màu sắc. CIDNet được trang bị cơ chế Lighten Cross-Attention (LCA), giúp tối ưu hóa tương tác giữa các đặc trưng của nhánh độ sáng và nhánh màu sắc, đảm bảo tính bổ sung thông tin giữa hai thành phần. Kết quả thực nghiệm trên nhiều bộ dữ liệu đã chứng minh rằng CIDNet, dựa trên không gian HVI, không chỉ đạt hiệu suất vượt trội so với các phương pháp hiện đại mà còn giảm thiểu đáng kể độ phức tạp tính toán, đáp ứng yêu cầu triển khai trên các thiết bị biên.

### Mô tả phương pháp

#### Không gian màu HVI

Không gian màu Horizontal/Vertical-Intensity (HVI) được thiết kế để tách biệt hoàn toàn độ sáng và màu sắc, đồng thời bổ sung các tham số học được, cho phép hệ thống thích nghi tốt hơn với các điều kiện chiếu sáng khác nhau.

  1. **Cấu trúc của HVI**


Không gian màu HVI bao gồm ba thành phần chính, được thiết kế để cải thiện khả năng biểu diễn và xử lý ảnh:

  1. Intensity Map (Bản đồ độ sáng):


Bản đồ độ sáng được tính toán dựa trên giá trị lớn nhất trong ba kênh RGB tại mỗi điểm ảnh, giúp biểu diễn trực tiếp cường độ ánh sáng của cảnh. Công thức được định nghĩa như sau:

$$
Imax=maxcϵ{R,G,B}(IC)I_{max} = max_{cepsilon{ R,G,B}}{(I_{C})}
$$

Bản đồ này đóng vai trò làm tham chiếu để phân tách độ sáng và màu sắc.

  2. HV Transformation (Chuyển đổi màu sắc theo trục ngang/dọc):


Chuyển đổi HV được thiết kế để khắc phục tính không liên tục của trục Hue trong không gian HSV. Nó sử dụng các tham số học được và ánh xạ từng điểm ảnh sang mặt phẳng màu ngang/dọc, tạo thành một hệ tọa độ trực giao cho màu sắc.

Công thức tổng quát:

$$
Ĥ=Ck•S•DT•cos(2πPγ)widehat{H} = C_{k} bullet S bullet D_{T} bullet cos(2pi P_{gamma})
$$

$$
V̂=Ck•S•DT•sin(2πPγ)widehat{V} = C_{k} bullet S bullet D_{T} bullet sin(2pi P_{gamma})
$$

Trong đó, Ck​ đại diện cho mật độ màu, DT​ là hàm điều chỉnh độ bão hòa, và Pγ​ là ánh xạ tuyến tính điều chỉnh màu sắc

  3. Perceptual-Invert HVI Transformation (Chuyển đổi ngược):


Không gian HVI tích hợp các tham số học được để cải thiện khả năng xử lý linh hoạt:

  1. Color-Density-k (Mật độ màu):


Tham số k điều chỉnh mật độ màu trên mặt phẳng màu ở các vùng có độ sáng thấp, giảm thiểu mất mát thông tin trong vùng tối. Công thức được định nghĩa như sau:

$$
Ck=ksin(πImax2)+ϵC_{k} = ksqrt{sinleft( frac{pi I_{max}}{2} right) + epsilon}
$$

  2. Hue Bias Parameters (𝛾𝐺, 𝛾𝐵):


Các tham số này điều chỉnh độ nhạy màu sắc theo các kênh RGB để phù hợp với các đặc tính của cảm biến máy ảnh, giảm thiểu hiện tượng lệch màu, đặc biệt ở các vùng ánh sáng yếu.

  3. Chức năng điều chỉnh độ bão hòa (DT​)


Một hàm học được để tối ưu hóa độ bão hòa màu sắc dựa trên ánh xạ tuyến tính của tham số Pγ​, đảm bảo tính linh hoạt trong việc điều chỉnh cường độ màu.

  2. **Chuyển đổi hai chiều giữa HVI và sRGB**


Quá trình chuyển đổi giữa HVI và sRGB được thiết kế để đảm bảo tính thuận nghịch, với hai bước chính:

  1. Từ sRGB sang HVI:


Sử dụng bản đồ độ sáng (𝐼max ) để tính toán các thành phần HVI, bao gồm các mặt phẳng ngang và dọc (Ĥ, V̂). Phương pháp này đảm bảo rằng màu sắc và độ sáng được tách biệt hoàn toàn.

  2. Từ HVI về sRGB:


Chuyển đổi ngược được thực hiện bằng cách tái hợp nhất các thành phần HVI và ánh xạ về không gian sRGB. Các công thức sau đây được sử dụng:

$$
R=f(Ĥ,V̂,Imax)R = f(widehat{H},widehat{V},I_{max})
$$

$$
G,B=TuơngtựdựatrênánhxạcủaĤ,V̂G,B = Tuơng tự dựa trên ánh xạ của widehat{H},widehat{V}
$$

Quá trình này không chỉ phục hồi màu sắc chính xác mà còn duy trì độ sáng tự nhiên của ảnh.

#### CIDNet

  3. **Kiến trúc tổng thể**


![](images/image1.png)

_Tổng quan về mô hình CIDNet được đề xuất. (a) Chuyển đổi màu HVI (HVIT) nhận một ảnh sRGB làm đầu vào và tạo ra bản đồ màu HV cùng bản đồ cường độ sáng làm đầu ra. (b) Mạng tăng cường thực hiện quá trình xử lý chính, sử dụng kiến trúc UNet hai nhánh, bao gồm sáu khối Lighten Cross-Attention (LCA). Cuối cùng, áp dụng Perceptual-inverse HVI Transform (PHVIT) để nhận bản đồ HVI đã được làm sáng làm đầu vào và chuyển đổi nó thành ảnh sRGB đã được cải thiện._

Mô hình CIDNet (Color and Intensity Decoupling Network) được thiết kế dựa trên không gian màu HVI để tách biệt và xử lý độ sáng (Intensity) và màu sắc (HV-plain) trong ảnh ánh sáng yếu. Kiến trúc CIDNet bao gồm ba thành phần chính:

  1. HVI Transformation (HVIT):


Thành phần này chuyển đổi ảnh từ không gian sRGB sang không gian HVI, tách biệt hai đặc trưng:

  * Intensity Map (Bản đồ độ sáng): Đại diện cho độ sáng tổng thể của cảnh, được tính toán từ giá trị lớn nhất trong các kênh RGB tại mỗi điểm ảnh.

  * HV Color Map (Bản đồ màu HV): Chứa thông tin màu sắc và cấu trúc của ảnh, được điều chỉnh bởi các tham số học được như Color-Density-k và Hue Bias Parameters (γG,γB​).


Quá trình này đảm bảo tách biệt hoàn toàn giữa độ sáng và màu sắc, giúp giảm độ phức tạp của mô hình trong các bước xử lý sau.

  1. Mạng Tăng cường (Enhancement Network):


Đây là thành phần chính trong CIDNet, được thiết kế dựa trên kiến trúc UNet hai nhánh:

  * HV-branch: Xử lý các đặc trưng màu sắc từ HV Color Map để loại bỏ nhiễu và đảm bảo màu sắc chính xác.

  * Intensity-branch: Xử lý thông tin độ sáng từ Intensity Map, cải thiện độ sáng tổng thể của ảnh.


Mạng sử dụng cơ chế Lighten Cross-Attention (LCA) để trao đổi thông tin giữa hai nhánh, đảm bảo sự phối hợp và bổ sung thông tin giữa màu sắc và độ sáng.

  1. Perceptual-Inverse HVI Transformation (PHVIT):


Thành phần này chuyển đổi ảnh đã được cải thiện trong không gian HVI trở lại không gian sRGB, tái hợp nhất thông tin màu sắc và độ sáng để tạo ra ảnh đầu ra tự nhiên và chính xác.

  1. **Lighten Cross-Attention (LCA) Module**


CIDNet là một mạng học sâu không gian màu HVI và cơ chế LCA để tối ưu hóa khả năng xử lý ảnh ánh sáng yếu. Với kiến trúc UNet hai nhánh và các thành phần được thiết kế chuyên biệt, CIDNet không chỉ cải thiện chất lượng độ sáng và màu sắc của ảnh mà còn giảm thiểu độ phức tạp tính toán, phù hợp với các thiết bị tài nguyên hạn chế.


| ![](images/image2.png) | Khối Lighten Cross-Attention (LCA) hai nhánh (tức là nhánh I và
nhánh HV). LCA bao gồm một khối Chú ý Chéo (CAB), một Lớp Tăng cường
Cường độ (IEL), và một Lớp Giảm nhiễu Màu sắc (CDL). Các lớp tích chập
nhúng đặc trưng bao gồm một lớp tích chập theo chiều sâu 1×1 và một lớp
tích chập theo nhóm 3×3. |
| --- | --- |

 

LCA là thành phần quan trọng trong CIDNet, được thiết kế để tăng cường sự phối hợp giữa hai nhánh HV-branch và Intensity-branch bằng cách học các thông tin bổ sung giữa chúng. LCA bao gồm ba thành phần chính:

  1. Cross Attention Block (CAB)


  * CAB thực hiện cơ chế chú ý chéo (cross-attention), trong đó một nhánh hoạt động như "query" và nhánh còn lại là "key" và "value".

  * Cơ chế này giúp mỗi nhánh học được thông tin bổ sung từ nhánh đối diện, cải thiện hiệu quả xử lý. Công thức được định nghĩa như sau:

$$
YI=W(V⨀Softmax(K/αH))+YIY_{I} = W(V bigodot Softmax(K/alpha_{H})) +  Y_{I}
$$

* Q, K, V: Các ma trận chú ý được tính từ các nhành

* W: Lớp tích chập nhúng đặc trưng (Feature Embedding Convolution)

* $αHalpha_{H}$: Tham số điều chỉnh.

  1. Intensity Enhance Layer (IEL)

  * Lớp IEL được thiết kế để cải thiện độ sáng tổng thể, sử dụng phép nhân theo phần tử (element-wise multiplication) giữa các tensor đầu vào, giúp tăng cường các vùng sáng mà không gây bão hòa. Công thức IEL:

$$
YI=Tanh(WI•YI)⨀Tanh(WR•YR)Y_{I} =  Tanhleft( W_{I} bullet Y_{I} right) bigodot  Tanhleft( W_{R} bullet Y_{R} right)
$$

* WI , WR : Lớp tích chập chiều sâu (depth-wise convolution)

  1. Color Denoise Layer (CDL)

  * CDL giảm nhiễu trong các vùng tối của ảnh, đảm bảo màu sắc chính xác. Cơ chế này giúp duy trì tính tự nhiên của ảnh và giảm thiểu lỗi giả màu.

1. **Hàm mất mát (Loss Function)**


Hàm mất mát của CIDNet được thiết kế để khai thác ưu điểm của cả không gian màu HVI và không gian sRGB, giúp tối ưu hóa chất lượng ảnh đầu ra. Cụ thể, hàm mất mát bao gồm:

  1. Hàm Mất Mát trong Không gian HVI


Trong không gian HVI, hàm mất mát được cấu thành bởi ba thành phần chính:

  1. L1 Loss (L1):


  * Đo lường sự khác biệt trung bình tuyệt đối giữa ảnh dự đoán ($X̂HVI{widehat{X}}_{HVI}$) và ảnh gốc ($XHVIX_{HVI}$).

  * Đảm bảo rằng ảnh dự đoán gần với ảnh gốc về mặt giá trị điểm ảnh.


  2. Edge Loss (Le):


  * Bảo tồn các cạnh và cấu trúc trong ảnh bằng cách tối thiểu hóa sự khác biệt giữa các gradient của ảnh dự đoán và ảnh gốc.


  3. Perceptual Loss (Lp):


  * Đảm bảo chất lượng nhận thức của ảnh dự đoán, bằng cách sử dụng các đặc trưng được trích xuất từ mạng đã huấn luyện trước (chẳng hạn VGG19).


Hàm mất mát tổng hợp trong không gian HVI được biểu diễn như sau:

$$
l(X̂HVI,XHVI)=λ1•L1(X̂HVI,XHVI)+λe•Le(X̂HVI,XHVI)+λp•Lp(X̂HVI,XHVI)lleft( {widehat{X}}_{HVI}, X_{HVI} right) =  lambda_{1} bullet L_{1}left( {widehat{X}}_{HVI}, X_{HVI} right) + lambda_{e} bullet L_{e}left( {widehat{X}}_{HVI}, X_{HVI} right) + lambda_{p} bullet L_{p}left( {widehat{X}}_{HVI}, X_{HVI} right)
$$

  1. Hàm Mất Mát trong Không gian sRGB


Trong không gian sRGB, hàm mất mát cũng sử dụng các thành phần L1, Le và Lp, tương tự như trong không gian HVI, để đảm bảo chất lượng ảnh đầu ra ở không gian màu chuẩn.

  2. Hàm Mất Mát Tổng quát


Hàm mất mát tổng quát kết hợp cả hai không gian HVI và sRGB:

$$
L=λc•l(X̂HVI,XHVI)+l(Î,I)L =  lambda_{c} bullet lleft( {widehat{X}}_{HVI}, X_{HVI} right) + l(widehat{I}, I)
$$

Trong đó:

  * $$
l(X̂HVI,XHVI)lleft( {widehat{X}}_{HVI}, X_{HVI} right)
$$: Hàm mất mát trong không gian HVI.

  * $l(Î,I)l(widehat{I}, I)$: Hàm mất mát trong không gian sRGB.

  * $λclambda_{c}$: Trọng số để cân bằng giữa hai không gian.

# Public_116

# Mở đầu

Để huấn luyện một mô hình mạng nơ-ron, chúng ta cần dựa trên giá trị hàm mất mát để biết được sự khác biệt giữa các dự đoán của mô hình đưa ra và nhãn mà chúng ta muốn dự đoán. Giá trị hàm mất mát càng bé có nghĩa là mô hình học đưa ra càng chính xác. Với mục tiêu hạ thấp giá trị của hàm mất mát, việc sử dụng các thuật toán tối ưu tập hợp các tham số và siêu tham số (parameter và hyper parameter) là một thành phần cốt lõi giúp cải thiện kết quả nhận dạng.

Trong bài báo này, chúng tôi thực hiện khảo sát các thuật toán tối ưu hiện đang nhận được nhiều sự quan tâm như SGD, RMS Prop, AdaGrad, AdaDelta và Adam. Mỗi thuật toán sẽ có những đặc điểm kĩ thuật riêng, và sẽ được đánh giá khảo sát dựa trên nhiệm vụ nhận dạng/phân loại hình ảnh. Tập dữ liệu được sử dụng trong nghiên cứu này là MNIST và CIFAR-10, hai tập cơ sở dữ liệu được sử dụng phổ biến cho nhiều nghiên cứu khác trên thế giới.

# Mạng nơ-ron tích chập và thuật toán tối ưu

Để đọc giả có thể tiếp cận được vấn đề một cách tổng quan và dễ dàng, trong nội dung phần này chúng tôi chọn trình bày những nội dung cơ bản nhất về mạng nơ-ron tích chập cũng như sơ lược về thuật toán tối ưu. Đây là những nội dung cốt lõi của nghiên cứu này.

## Mạng nơ-ron tích chập

Đối với mạng đa lớp Perceptron (Multi-layer Perceptron – MLP) truyền thống, mỗi nơ-ron trong lớp phía trước sẽ kết nối đến tất cả các nơ-ron ở lớp phía sau, khi tăng độ sâu của mô hình sẽ khiến khối lượng tính toán trong mạng tăng mạnh.

Sự ra đời của mạng CNN đã giúp giải quyết vấn đề trên dựa trên 3 ý tưởng cơ bản: vùng tiếp nhận cục bộ, tập trọng số chia sẻ và phương pháp lấy mẫu xuống. Nhìn chung, cấu trúc của CNN gồm một số lớp cơ bản sau:

![](images/image1.png)

_Hình 2.1. Mô hình một mạng CNN đơn giản._

## Lớp tích chập (Convolutional layer)

Lớp tích chập là một thành phần cốt lõi của mạng nơ-ron tích chập (CNN), sử dụng để trích xuất các thông tin đặc tính của hình ảnh (feature map). Kết quả đầu ra nhận được là các đặc tính của ảnh, tương ứng với bộ lọc đã sử dụng, với càng nhiều bộ lọc được sử dụng, sẽ thu được càng nhiều thông tin của ảnh tương ứng. Bên cạnh đó, việc sử dụng lớp tích chập sẽ có nhiều ưu điểm so với mạng nơ-ron truyền thống MLP, đặc biệt khi dữ liệu là hình ảnh. Một số ưu điểm có thể nổi trội so với mô hình trước đây có thể kể đến: Trích xuất thông tin theo phân vùng không gian hay hạn chế số lượng tham số và khối lượng tính toán khi tăng chiều sâu cho mô hình.

## Lớp lấy mẫu xuống (Pooling/Subsampling layer)

Lớp lấy mẫu xuống có tác dụng giảm kích thước của dữ liệu hình ảnh từ đó giúp cho mạng có thể học được các thông tin có tính chất khái quát hơn, đây cũng chính là phương pháp mà trung khu thần kinh thị giác của con người hoạt động. Đồng thời quá trình này giảm số lượng các thông số trong mạng. Các phương pháp lấy mẫu xuống thường được sử dụng là Max Pooling và Average Pooling.

## Lớp kết nối đầy đủ (Fully-connected layer - FC)

Đầu vào của lớp kết nối đầy đủ là đầu ra từ lớp lấy mẫu xuống hoặc lớp tích chập cuối cùng, nó được làm phẳng và sau đó được đưa vào lớp kết nối đầy đủ để chuyển tiếp. Lớp FC có nhiệm vụ tổng hợp thông tin đưa ra lớp quyết định (output) cho ra kết quả đánh giá.

# Thuật toán tối ưu

Về cơ bản, trong việc tối ưu hóa thiết kế, mục tiêu thiết kế hướng tới có thể chỉ là giảm thiểu chi phí sử dụng hoặc tối đa hóa hiệu quả nhận được. Để thực hiện điều này, thuật toán tối ưu hóa là một khâu không thể thiếu, đây một quy trình được thực hiện lặp đi lặp lại bằng cách so sánh các giải pháp khác nhau cho đến khi tìm thấy một giải pháp tối ưu hoặc thỏa đáng.

Đối với kỹ thuật học sâu nói riêng, thuật toán tối ưu là các kỹ thuật giúp xây dựng các mô hình mạng nơ-ron để tối ưu hóa độ chính xác của mô hình mạng [1]. Với mục tiêu là “học” được các đặc tính từ dữ liệu đầu vào, từ đó có thể tìm một tập các trọng số (weights - _w_ ) và ngưỡng (bias - _b_ ) phù hợp hơn.

## Vai trò của thuật toán tối ưu 

Trong thuật toán học máy nói chung và kĩ thuật học sâu nói riêng, thuật toán tối ưu hóa là một khâu quan trọng không thể thiếu. Quá trình tối ưu hóa thực hiện xác định hàm mất mát (loss function) và sau đó tối thiểu hóa hàm trên bằng cách sử dụng hàm tối ưu. Cụ thể, thông qua việc cập nhật các tham số của mô hình ( _w, b_ ) và đánh giá lại hàm mất mát với một tỉ lệ học (learning rate) xác định, quá trình tối ưu giúp mô hình tương thích tốt hơn với tập dữ liệu được đào tạo.

## Hàm mất mát (Loss function)

Hàm mất mát là một phương pháp đánh giá độ hiệu quả của thuật toán “học” cho mô hình trên tập dữ liệu được sử dụng. Hàm mất mát trả về một số thực không âm thể hiện sự chênh lệch giữa hai đại lượng: a, nhãn được dự đoán và y, nhãn đúng. Hàm mất mát, bản thân chính là một cơ chế thưởng-phạt, mô hình sẽ phải đóng phạt mỗi lần dự đoán sai và mức phạt tỉ lệ thuận với độ lớn sai sót. Trong mọi bài toán học có giám sát, mục tiêu luôn bao gồm giảm tổng mức phạt phải đóng. Trong trường hợp lý tưởng a = y, loss function sẽ trả về giá trị cực tiểu bằng 0 [2]. Hai hàm mất mát thường xuyên được sử dụng trong mạng nơ-ron: MSE (Mean Squared Error) và Cross Entropy.

## Tỉ lệ học (Learning rate)

Learning rate hay tỉ lệ học là một thông số quan trọng trong việc quyết định tốc độ học của mạng nơ-ron. Tốc độ học được thể hiện bằng sự thay đổi giá trị cập nhật trọng số ( _w_ ) trong các chu kỳ học. Tùy theo mục đích của mô hình mà tăng/giảm tỉ lệ học. Tỉ lệ học càng cao thì giúp mô hình học khá nhanh và tiết kiệm được thời gian huấn luyện, tuy nhiên việc tỉ lệ học lớn đồng nghĩa với việc sự thay đổi trọng số ( _w_ ) và tham số ngưỡng - bias ( _b_ ) càng lớn, mô hình không ổn định, một số chu kỳ học có sự dao động mạnh ở tỉ lệ nhận dạng đúng hay nói cách khác là thuật toán không được tối ưu và ngược lại đối với tỉ lệ học nhỏ.

# Một số thuật toán tối ưu

Trong phạm vi bài báo một số thuật toán tối ưu hóa sẽ được đánh giá khảo sát gồm: Gradient Descent [3], SGD với động lượng [4], RMSProp [5], Adagrad [6], Adadelta [7], Adam [6]. Việc đánh giá được thực hiện dựa trên tiêu chí giá trị hàm mất mát và tỉ lệ nhận dạng đúng hình ảnh dựa trên hai tập Train và Test data. Dựa trên các kết quả đó có thể đánh giá tác động của thuật toán tối ưu đến mô hình mạng ứng dụng vào bài toán nhận dạng hình ảnh.

## Gradient Descent

Gradient Descent (GD) là thuật toán tìm tối ưu chung cho các hàm số. Ý tưởng chung của GD là điều chỉnh các tham số để lặp đi lặp lại thông qua mỗi dữ liệu huấn luyện để giảm thiểu hàm chi phí.


| w(k+1)=w(k)−η∇wJ(w(k))w^{(k + 1)} = \ w^{(k)} - \ \eta{\ \nabla}_{w\ }J(w^{(k)}) | (3.1) |
| --- | --- |

 

Với $w(k)w^{(k)}$ là tham số tại bước cập nhật tại lớp k, η là tỉ lệ học, $J(w)J(w)$ là hàm lỗi,$∇wJ(w(k)){ nabla}_{w }J(w^{(k)})$: đạo hàm của hàm lỗi tại điểm $w(k)w^{(k)}$.

## SGD với động lượng (SGD with momentum)

SGD với momentum là phương pháp giúp tăng tốc các vectơ độ dốc theo đúng hướng, và giúp hệ thống hội tụ nhanh hơn. Đây là một trong những thuật toán tối ưu hóa phổ biến nhất và nhiều mô hình hiện đại sử dụng nó để đào tạo. Mô tả như sau:


| vj←α*vj−η*∇W∑1mLm(w)v_{j} \leftarrow \ \alpha*v_{j} - \eta*\nabla_{W}\sum_{1}^{m}{L_{m}(w)} | (3.2) |
| --- | --- |

 

Phương trình (3.2) có hai phần. Thuật ngữ đầu tiên là độ dốc $vjv_{j}$ được giữ lại từ các lần lặp trước. Hệ số động lượng $αalpha$ là tỉ lệ phần trăm của độ dốc được giữ lại mỗi lần lặp. L là hàm mất mát, $ηeta$là tỉ lệ học.

## RMSProp (Root Mean Square Propogation)

RMSProp sử dụng trung bình bình phương của gradient để chuẩn hóa gradient. Có tác dụng cân bằng kích thước bước - giảm bước cho độ dốc lớn để tránh hiện tượng phát nổ độ dốc (Exploding Gradient), và tăng bước cho độ dốc nhỏ để tránh biến mất độ dốc (Vanishing Gradient). RMSProp tự động điều chỉnh tốc độ học tập, và chọn một tỉ lệ học tập khác nhau cho mỗi tham số. Phương pháp cập nhật các trọng số được thực hiện như mô tả:


| st=ρst−1+(1−ρ)*gt2s_{t} = \rho s_{t - 1} + (1 - \rho)*g_{t}^{2}Δxt=−ηst+ϵ*gt\Delta x_{t} = - \frac{\eta}{\sqrt{s_{t} + \epsilon}}*g_{t}xt+1=xt+Δxtx_{t + 1} = x_{t} + \ \Delta x_{t} |  |
| --- | --- |

 

Với $sts_{t}$: tích luỹ phương sai của các gradient trong quá khứ, $ρrho$: tham số suy giảm, $ΔxtDelta x_{t}$: sự thay đổi các tham số trong mô hình, $gtg_{t}$: gradient của các tham số tại vòng lặp t, ϵ: tham số đảm bảo kết quả xấp xỉ có ý nghĩa.

## Adagrad

Adagrad là một kỹ thuật học máy tiên tiến, thực hiện giảm dần độ dốc bằng cách thay đổi tốc độ học tập. Adagrad được cải thiện hơn bằng cách cho trọng số học tập chính xác dựa vào đầu vào trước nó để tự điều chỉnh tỉ lệ học theo hướng tối ưu nhất thay vì với một tỉ lệ học duy nhất cho tất cả các nút.


| wt+1=wt−ηGt+ϵ.gtw_{t + 1} = w_{t} - \frac{\eta}{\sqrt{G_{t} + \epsilon}}.\ g_{t} | (3.4) |
| --- | --- |

 

Trong công thức (3.4), $GtG_{t}$ là ma trận đường chéo chứa bình phương của đạo hàm vecto tham số tại vòng lặp t; $gtg_{t}$là vectơ của độ dốc cho vị trí hiện tại và η là tỉ lệ học.

## Adadelta

Adadelta là một biến thể khác của AdaGrad. Adadelta không có tham số tỉ lệ học. Thay vào đó, nó sử dụng tốc độ thay đổi của chính các tham số để điều chỉnh tỉ lệ học nghĩa là bằng cách **giới hạn cửa sổ của gradient tích lũy trong quá khứ ở một số kích thước cố định của trọng số w.**


| gt′=Δxt−1+ϵst+ϵ.gtg_{t}^{'} = \sqrt{\frac{\Delta x_{t - 1} + \epsilon}{s_{t} + \epsilon}}.\ g_{t}xt=xt−1−gt′x_{t} = x_{t - 1} - g_{t}^{'}Δxt=ρΔxt−1+(1−ρ)xt2\Delta x_{t} = \rho\Delta x_{t - 1} + (1 - \rho)x_{t}^{2} | (3.5) |
| --- | --- |

 

Từ công thức (3.5), Adadelta sử dụng 2 biến trạng thái: $sts_{t}$ để lưu trữ trung bình của khoảng thời gian thứ hai của gradient và $ΔxtDelta x_{t}$ để lưu trữ trung bình của khoảng thời gian thứ 2 của sự thay đổi các tham số trong mô hình. $gt′g_{t}^{'}$: căn bậc hai thương của trung bình tốc độ thay đổi bình phương và trung bình mô-men bậc hai của gradient.

**3.6. Adam**

Adam được xem như là sự kết hợp của RMSprop và Stochastic Gradient Descent với động lượng. Adam là một phương pháp tỉ lệ học thích ứng, nó tính toán tỉ lệ học tập cá nhân cho các tham số khác nhau. Adam sử dụng ước tính của khoảng thời gian thứ nhất và thứ hai của độ dốc để điều chỉnh tỉ lệ học cho từng trọng số của mạng nơ-ron. Tuy nhiên, qua nghiên cứu thực nghiệm, trong một số trường hợp, Adam vẫn còn gặp phải nhiều thiếu sót so với thuật toán SGD. Thuật toán Adam được mô tả:


| mt=β1mt−1+(1−β1)gtm_{t} = \beta_{1}m_{t - 1} + (1 - \beta_{1})g_{t}vt=β2vt−1+(1−β2)gt2v_{t} = \beta_{2}v_{t - 1} + (1 - \beta_{2})g_{t}^{2} | (3.6) |
| --- | --- |

 

Trong công thức (3.6), $vtv_{t}$ là trung bình động của bình phương và $mtm_{t}$là trung bình động của gradient; $β1beta_{1}$và $β2beta_{2}$ là tốc độ của di chuyển.

# Đánh giá kết quả với các thuật toán tối ưu

## Cơ sở dữ liệu

Để thực hiện khảo sát và đánh giá các thuật toán tối ưu với bài toán phân loại hình ảnh, nhóm nghiên cứu đề xuất hai tập cơ sở dữ liệu phổ biến cho mục đích nghiên cứu là MNIST và CIFAR-10 để thực hiện quá trình đào tạo và thực nghiệm.

### MNIST

Bộ dữ liệu MNIST là bộ dữ liệu gồm các hình ảnh xám (grayscale picture) các chữ số viết tay được chia sẻ bởi Yann Lecun bao gồm 70000 ảnh chữ số viết tay được chia thành 2 tập: tập huấn luyện gồm 60000 ảnh và tập kiểm tra 10000 ảnh. Các chữ số viết tay ở tập MNIST được chia thành 10 nhóm tương ứng với các chữ số từ 0 đến 9. Tất cả hình ảnh trong tập MNIST đều được chuẩn hóa với kích thước 28 x 28 điểm ảnh. Dưới đây là một số hình ảnh được trích xuất từ bộ dữ liệu.

![MNIST](images/image2.png)

_**Hình 4.1.** Hình ảnh chữ số viết tay từ tập MNIST [8]._

### CIFAR-10

Bộ cơ sở dữ liệu CIFAR10 là bộ dữ liệu chứa các ảnh màu có kích thước 32 x 32 x 3 (3 lớp màu RGB) trong 10 nhóm khác nhau, gồm: máy bay, ô tô, chim, mèo, hươu, chó, ếch, ngựa, tàu và xe tải. Mỗi nhóm gồm 6000 hình ảnh, cùng với sự đa dạng về các thành phần như độ sáng, vị trí, hướng của các đối tượng. Nó là một trong những bộ dữ liệu được sử dụng rộng rãi nhất cho nghiên cứu máy học bao gồm 60000 ảnh được chia thành 2 tập: tập huấn luyện gồm 50000 ảnh và tập kiểm tra 10000 ảnh.

## Mô hình và phương pháp đánh giá

Ở đây, nhóm nghiên cứu đề xuất sử dụng mô hình CNN với cấu trúc:

Input Convolution2D Maxpooling Dropout Convolution2D Maxpooling Dropout Flatten Dense Output.

Quá trình huấn luyện và đánh giá với chu kì học là 50 và tỉ lệ học của từng thuật toán được sử dụng theo khuyến nghị của Google Colab, cụ thể tỉ lệ học ứng với các thuật toán SGD với động lượng, RMSProp, Adagrad, Adadelta, Adam lần lượt là 0.01, 0.001, 0.01, 1.0, 0.001. Phương pháp thực hiện đánh giá kết quả sử dụng trong bài là loss function và tỉ lệ nhận dạng đúng trên các tập dữ liệu được xét.

![](images/image3.png)

_**Hình 5.2. Một số** hình ảnh từ bộ cơ sở dữ liệu CIFAR-10 [9]._

## Kết quả với bộ cơ sở dữ liệu MNIST

![mnistopti](images/image4.png)

Hình 5.3 Tỉ lệ mất mát của các thuật toán tối ưu trên tập dữ liệu MNIST.

Hình 5.3 mô tả kết quả của loss function của các thuật toán, xét trên tập dữ liệu MNIST. Ở đây, sau 50 chu kì học kết quả gần như không thay đổi nên chúng tôi chỉ xét ở 30 chu kì học đầu để có cách nhìn cụ thể hơn về sự biến thiên của hàm mất mát.

Từ đồ thị, có thể nhận thấy rằng, Adam và RMSProp là 2 thuật toán có biên độ dao động thấp nhất, gần như không thay đổi quá nhiều quanh giá trị 0.5. Trong khi đó, AdaDelta và AdaGrad là hai thuật toán có sự biến động lớn nhất trong suốt các chu kì học. Bên cạnh đó, nhận thấy rằng thuật toán SGD với động lượng là thuật toán có kết quả hội tụ nhanh nhất và tốt nhất là với tỉ lệ mất mát rơi vào khoảng 0.023. Các thuật toán Adam, RMSProp và Adagrad cũng có kết quả rất tốt lần lượt là 0.06, 0.067, 0.059, thuật toán Adelta có kết quả cao nhất trong các thuật toán đang xét với tỉ lệ mất mát 0.229.

Để có cách nhìn tổng thể hơn, tỉ lệ nhận dạng đúng của mô hình với các thuật toán khác nhau cũng được mô tả ở mô hình 5.4.

Hình 4.4 Tỉ lệ nhận dạng đúng của các thuật toán trên tập huấn luyện và tập đánh giá.

Từ hình 5.4, có thể thấy rằng tỉ lệ nhận dạng đúng của mô hình chịu sự ảnh hưởng từ các thuật toán tối ưu. Cụ thể, đối với thuật toán cho tỉ lệ mất mát cao như Adadelta hay Adagrad, tỉ lệ nhận dạng đúng khá thấp, rơi vào khoảng 93.4% trên tập đánh giá (Adadelta). Trong khi đó, các thuật toán cho tỉ lệ mất mát thấp như SGD with momentum, RMSProp và Adam cho tỉ lệ nhận dạng đúng khả quan hơn, đạt khoảng 99.2%, khi sử dụng trên cùng một mô hình kiến trúc mạng đề ra.

## Kết quả với bộ cơ sở dữ liệu CIFAR10

Để có thể đánh giá chính xác hơn về vai trò của các thuật toán, nhóm thực hiện khảo sát trên tập dữ liệu CIFAR-10, có độ phức tạp cao hơn so với MNIST. Tương tự với bộ cơ sở dữ liệu MNIST, hình 4.6 đưa ra kết quả khảo sát từng thuật toán riêng biệt trên cùng một mô hình mạng và tập dữ liệu xét sau 50 chu kì học.

Từ đồ thị hình 5.4, nhận thấy rằng, xu hướng hội tụ của thuật toán Adadelta và Adagrad khá tốt, tuy nhiên, tỉ lệ mất mát lại khá cao, xấp xỉ 1.2 với Adagrad và 1.6 với Adadelta sau khoảng chu kì học được xét. SGD with momentum là thuật toán có kết quả khả quan hơn cả, độ hội tụ khá ổn định, giá trị thấp, đạt đỉnh 0.8 tại chu kì học 20. Tiếp đến là thuật toán Adam, tuy nhiên, nhận thấy rằng thuật toán Adam có xu hướng tăng tỉ lệ mất mát khi qua khỏi 10 chu kì học. RMSProp là thuật toán có sự dao động lớn nhất về tỉ lệ mất mát qua các chu kì học trong các thuật toán được khảo sát.

![cifaropti](images/image5.png)

Hình 5.4 Tỉ lệ mất mát của các thuật toán tối ưu trên tập dữ liệu CIFAR-10.

Hình 5.5 cho thấy, tỉ lệ nhận dạng đúng của 2 thuật toán Adagrad và Adadelta không cao so với các thuật toán còn lại. Tuy nhiên ưu điểm là giảm được hiện tượng overfitting - hiện tượng kết quả trên tập dữ liệu huấn luyện rất cao trong khi thử nghiệm mô hình trên tập dữ liệu kiểm tra cho kết quả thấp.

Hình 5.5 Tỉ lệ nhận dạng đúng của các thuật toán trên tập huấn luyện và tập đánh giá.

Tổng quát ta cũng có thể thấy rằng với thuật toán cho tỉ lệ mất mát cao và các thuật toán cho tỉ lệ mất mát thấp sẽ ảnh hưởng đến tỉ lệ nhận dạng đúng của mô hình, SGD with momentum và Adam là hai thuật toán có kết quả khá hứa hẹn. Cụ thể tỉ lệ nhận dạng đúng khi sử dụng các thuật toán tối ưu SGD với động lượng, RMSProp, Adagrad, Adadelta, Adam lần lượt là 73.9%, 57.3%, 58.9%, 44.5%, 72.9%.

# Kết luận

Tổng quát, kết quả từ nghiên cứu trên đã đánh giá được sự tác động của thuật toán tối ưu đến việc phân loại đúng kết quả trong bài toán nhận dạng hình ảnh. Nghiên cứu cũng cung cấp thêm hiểu biết về thuật toán tối ưu, thông qua các kết quả từ thực nghiệm đánh giá, từ đó giúp chúng ta có sự lựa chọn các thuật toán thật hợp lí trong việc xây dựng và huấn luyện, đánh giá mô hình mạng. Trong phạm vi bài báo, chúng tôi chỉ so sánh các thuật toán phổ biến và trong thực tế còn rất nhiều các thuật toán tối ưu khác. Kết quả trên chỉ so sánh và xác định ra thuật toán tối ưu nhất trong phạm vi các thuật toán được xét, đối với bộ cơ sở dữ liệu CIFAR-10 và MNIST. Một số thành phần khác như kiến trúc, các tham số, siêu tham số và các tập dữ liệu khác chúng tôi sẽ thực hiện phân tích và đánh giá ở các nghiên cứu sau.

**TÀI LIỆU THAM KHẢO**

[1]. Léon Bottou, Frank E. Curtis, Jorge Nocedal (2016). Optimization Methods for Large-Scale Machine Learning, arXiv:1606.04838

[2]. Jonathan T. Barron (2017). A General and Adaptive Robust Loss Function, arXiv:1701.03077, _Cornell University_

[3]. Qian, N. (1999). On the momentum term in gradient descent learning algorithms. Neural Networks: The Official Journal of the International Neural Network Society, 12(1), 145–151. http://doi.org/10.1016/S0893-6080(98)00116-6

[4]. Sutskever, I., Martens, J., Dahl, G.E. and Hinton, G.E. (2013). On the importance of initialization and momentum in deep learning. ICML (3), Vol 28, pp. 1139—1147

[5]. Christian Igel and Michael H ̈usken (2000). Improving the RMSprop Learning Algorithm. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.1332

[6]. Alexandre Défossez, Léon Bottou, Francis Bach, Nicolas Usunier (2020). On the Convergence of Adam and Adagrad, arXiv:2003.02395

[7]. Matthew D. Zeiler (2012), Adadelta: An Adaptive Learning Rate Method, arXiv:1212.5701v1 [cs.LG] 22 Dec 2012

[8]. Yann LeCun, Courant Institute (1989). The MNIST Database of Handwritten Digits.

[9]. Alex Krizhevsky, Vinod Nair and Geoffrey Hinton (2009). The CIFAR-10 dataset

# Public_117

# Random variables

Một biến ngẫu nhiên (random variable) x là một đại lượng dùng để đo những đại lượng không xác định. Biến này có thể ký hiệu kết quả/đầu ra (outcome) của một thí nghiệm (ví dụ như tung đồng xu) hoặc một đại lượng biến đổi trong tự nhiên (ví dụ như nhiệt độ trong ngày). Nếu chúng ta quan sát rất nhiều đầu ra {x_i}_{i=1}^I của các thí nghiệm này, ta có thể nhận được những giá trị khác nhau ở mỗi thí nghiệm. Tuy nhiên, sẽ có những giá trị xảy ra nhiều lần hơn những giá trị khác. Thông tin về đầu ra được đo bởi phân phối xác suất (probability distribution) p(x) của biến ngẫu nhiên.  
  
Một biến ngẫu nhiên có thể là rời rạc (discrete) hoặc liên tục (continuous). Một biến ngẫu nhiên rời rạc sẽ lấy giá trị trong một tập hợp cho trước. Ví dụ tung đồng xu thì có hai khả năng là head và tail (tên gọi này bắt nguồn từ đồng xu Mỹ, một mặt có hình mặt người, được gọi là head, trái ngược với mặt này được gọi là mặt tail, cách gọi này hay hơn cách gọi xấp ngửa vì ta không có quy định rõ ràng thế nào là xấp ngay ngửa). Tập các giá trị này có thể là có thứ tự (khi tung xúc xắc) hoặc không có thứ tự (unordered), ví dụ khi đầu ra là các giá trị nắng, mưa, bão, etc. Mỗi đầu ra có một giá trị xác suất tương ứng với nó. Các giá trị xác suất này không âm và có tổng bằng một:

_if x is discrete:_

∑_x p(x) = 1 (1)

Biến ngẫu nhiên liên tục lấy các giá trị là tập con của các số thực. Những giá trị này có thể là hữu hạn, ví dụ thời gian làm bài của mỗi thí sinh trong một bài thi 180 phút, hoặc vô hạn, ví dụ thời gian để chiếc xe bus tiếp theo tới. Không như biến ngẫu nhiên rời rạc, xác suất để đầu ra bằng chính xác một giá trị nào đó, theo lý thuyết, là bằng 0. Thay vào đó, ta có thể hình dung xác suất để đầu ra nằm trong một khoảng giá trị nào đó; và việc này được mô tả bởi hàm mật độ xác suất (probability density function - pdf). Hàm mật độ xác suất luôn cho giá trị dương, và tích phân của nó trên toàn miền possible outcome phải bằng 1.

_if x is continuous:_

∫ p(x) dx = 1 (2)

Để giảm thiểu ký hiệu, hàm mật độ xác suất của một biến ngẫu nhiên liên tục x cũng được ký hiệu là p(x).  
  
Chú ý: Nếu x là biến ngẫu nhiên rời rạc, p(x) luôn luôn nhỏ hơn hoặc bằng 1. Trong khi đó, nếu x là biến ngẫu nhiên liên tục, p(x) có thể nhận giá trị dương bất kỳ, điều này vẫn đảm bảo là tích phân của hàm mật độ xác suất theo toàn bộ giá trị có thể có của x bằng 1. Với biến ngẫu nhiên rời rạc, p(x) được hiểu là mật độ xác suất tại x.

# Joint probability

Xét hai biến ngẫu nhiên x và y. Nếu ta quan sát rất nhiều cặp đầu ra của x và y, thì có những tổ hợp hai đầu ra xảy ra thường xuyên hơn những tổ hợp khác. Thông tin này được biểu diễn bằng một phân phối được gọi là joint probability của x và y, và được viết là p(x, y). Dấu phẩy trong p(x, y) có thể đọc là và, vậy p(x, y) là xác suất của x và y. x và y có thể là hai biến ngẫu nhiên rời rạc, liên tục, hoặc một rời rạc, một liên tục. Luôn nhớ rằng tổng các xác suất trên mọi cặp giá trị có thể xảy ra (x, y) bằng 1.

both are discrete: ∑_{x,y} p(x, y) = 1

both are continuous: ∫∫ p(x, y) dx dy = 1

x is discrete, y is continuous: ∑_x ∫ p(x, y) dy = ∫ (∑_x p(x, y)) dy = 1

Thông thường, chúng ta sẽ làm việc với các bài toán ở đó joint probability xác định trên nhiều hơn 2 biến ngẫu nhiên. Chẳng hạn, p(x, y, z) thể hiện joint probability của 3 biến ngẫu nhiên x, y và z. Khi có nhiều biến ngẫu nhiên, ta có thể viết chúng dưới dạng vector. Ta có thể viết p(x) để thể hiện joint probability của biến ngẫu nhiên nhiều chiều x = [x1, x2, …, xn]^T. Khi có nhiều tập các biến ngẫu nhiên, ví dụ x và y, ta có thể viết p(x, y) để thể hiện joint probability của tất cả các thành phần trong hai biến ngẫu nhiên nhiều chiều này.

# Marginalization

Nếu biết joint probability của nhiều biến ngẫu nhiên, ta cũng có thể xác định được phân bố xác suất của từng biến bằng cách lấy tổng (rời rạc) hoặc tích phân (liên tục) theo tất cả các biến còn lại:

p(x) = ∑_y p(x, y) (3)

p(y) = ∑_x p(x, y) (4)

Và với biến liên tục:

p(x) = ∫ p(x, y) dy (5)

p(y) = ∫ p(x, y) dx (6)

Với nhiều biến hơn, chẳng hạn 4 biến rời rạc x, y, z, w:

p(x) = ∑_{y,z,w} p(x, y, z, w) (7)

p(x, y) = ∑_{z,w} p(x, y, z, w) (8)

Từ đây trở đi, nếu không nói gì thêm, tôi sẽ dùng ký hiệu ∑ để chỉ chung cho cả hai loại biến. Nếu biến ngẫu nhiên là liên tục, bạn đọc ngầm hiểu rằng dấu ∑ cần được thay bằng dấu tích phân ∫, biến lấy vi phân chính là biến được viết dưới dấu ∑.

# Conditional probability

Xác suất có điều kiện (conditional probability) của một biến ngẫu nhiên x biết rằng biến ngẫu nhiên y có giá trị y* được ký hiệu là p(x | y = y*). Conditional probability p(x | y = y*) có thể được tính dựa trên joint probability p(x, y).

p(x | y = y*) = p(x, y = y*) / ∑_x p(x, y = y*) = p(x, y = y*) / p(y = y*) (9)

Thông thường, viết gọn: p(x | y) = p(x, y) / p(y) (10)

Tương tự: p(y | x) = p(y, x) / p(x)

Quan hệ: p(x, y) = p(x | y) p(y) = p(y | x) p(x) (11)

Khi có nhiều hơn hai biến:

p(x, y, z, w) = p(x, y, z | w) p(w) (12)

= p(x, y | z, w) p(z, w) = p(x, y | z, w) p(z | w) p(w) (13)

= p(x | y, z, w) p(y | z, w) p(z | w) p(w) (14)

# Quy tắc Bayes

Từ (11): p(y | x) p(x) = p(x | y) p(y) ⇒ p(y | x) = p(x | y) p(y) / p(x) (15)

= p(x | y) p(y) / ∑_y p(x, y) (16)

= p(x | y) p(y) / ∑_y p(x | y) p(y) (17)

Ba công thức (15)–(17) thường được gọi là Quy tắc Bayes (Bayes’ rule).

# Independence

Nếu x và y độc lập: p(x | y) = p(x) (18), p(y | x) = p(y) (19)

Khi đó: p(x, y) = p(x) p(y) (20)

# Kỳ vọng

Kỳ vọng (expectation) của một biến ngẫu nhiên:

E[x] = ∑_x x p(x) nếu x rời rạc (21)

E[x] = ∫ x p(x) dx nếu x liên tục (22)

Với hàm f(.): E[f(x)] = ∑_x f(x) p(x) (23)

Với joint probability: E[f(x, y)] = ∑_{x,y} f(x, y) p(x, y) (24)

Ba quy tắc:

E[α] = α (25)

E[αx] = α E[x] (26); E[f(x) + g(x)] = E[f(x)] + E[g(x)] (27)

Nếu x, y độc lập: E[f(x) g(y)] = E[f(x)] E[g(y)] (28)

# Một vài phân phối thường gặp

## Bernoulli distribution

Bernoulli distribution: x ∈ {0,1}, tham số λ ∈ [0,1] là xác suất để x=1.

p(x=1) = λ, p(x=0) = 1 − λ

Viết gọn: p(x) = λ^x (1 − λ)^{1 − x} (29)

Ký hiệu: p(x) = Bern_x[λ] (30)

## Categorical distribution

Categorical distribution với K lớp, tham số λ = [λ1, …, λK], ∑_k λk = 1.

p(x = k) = λ_k; viết gọn: p(x) = Cat_x[λ]

Biểu diễn one-hot: x ∈ {e1, …, eK}

p(x = e_k) = ∏_{j=1}^K λ_j^{x_j} = λ_k (31)

## Univariate normal distribution

p(x) = 1 / √(2πσ^2) · exp(− (x − μ)^2 / (2σ^2)) (32)

Ký hiệu: p(x) = Norm_x[μ, σ^2]

## Multivariate normal distribution

p(x) = 1 / ((2π)^{D/2} |Σ|^{1/2}) · exp(−1/2 (x−μ)^T Σ^{−1} (x−μ)) (33)

Ký hiệu: p(x) = Norm_x[μ, Σ]

## Beta distribution

p(λ) = Γ(α+β) / (Γ(α) Γ(β)) · λ^{α−1} (1−λ)^{β−1} (34)

Trong đó Γ(z) = ∫_0^∞ t^{z−1} exp(−t) dt, và Γ[z] = (z−1)! nếu z là số tự nhiên.

Ký hiệu: p(λ) = Beta_λ[α, β]

## Dirichlet distribution

p(λ1, …, λK) = Γ(∑_{k=1}^K α_k) / ∏_{k=1}^K Γ(α_k) · ∏_{k=1}^K λ_k^{α_k−1} (35)

Ký hiệu: p(λ1, …, λK) = Dir_{λ1,…,λK}[α1, …, αK]

# Thảo luận

Về Xác suất thống kê, còn rất nhiều điều cần lưu ý. Tạm thời, phần này ôn tập lại các kiến thức xác suất cơ bản để phục vụ cho các bài viết tiếp theo. Khi nào có phần nào cần nhắc lại, sẽ tiếp tục ôn tập bổ sung.

# Public_118

# Giới thiệu

Dimensionality Reduction (giảm chiều dữ liệu) là một kỹ thuật quan trọng trong Machine Learning.  
Dữ liệu thực tế có thể có số chiều rất lớn (hàng nghìn). Việc giảm chiều giúp tiết kiệm lưu trữ, tăng tốc tính toán và có thể coi như nén dữ liệu.  
Một phương pháp tuyến tính cơ bản là Principal Component Analysis (PCA).

# Một chút toán

## Norm 2 của ma trận

||A||_2 = max_x ||Ax||_2 / ||x||_2 (1)

||A||_2 = max_{||x||_2=1} ||Ax||_2 (2)

Giải bằng nhân tử Lagrange cho thấy norm 2 của ma trận chính là singular value lớn nhất của A.  
Vector tương ứng là right-singular vector của A.

## Biểu diễn vector trong các hệ cơ sở khác nhau

x = Uy, y = U^{-1}x (7)

Nếu U trực giao: U^{-1}=U^T, do đó y = U^T x.

## Trace

Một số tính chất:  
\- trace(A) = trace(A^T)  
\- trace(kA) = k trace(A)  
\- trace(AB) = trace(BA)  
\- ||A||_F^2 = trace(A^T A)  
\- trace(A) = tổng các trị riêng của A

## Kỳ vọng và ma trận hiệp phương sai

Một chiều: x̄ = (1/N) Σ x_n, σ^2 = (1/N) Σ (x_n − x̄)^2

Đa chiều: x̄ = (1/N) Σ x_n, S = (1/N) (X − x̄1^T)(X − x̄1^T)^T

# Principal Component Analysis (PCA)

Mục tiêu: Tìm hệ cơ sở trực chuẩn sao cho phương sai dữ liệu tập trung ở K thành phần đầu.  
Dữ liệu chuẩn hoá: Ẋ = X − x̄1^T  
Ma trận hiệp phương sai: S = (1/N)ẊẊ^T  
  
Hàm mất mát: J = Σ_{i=K+1}^D u_i^T S u_i  
Tối ưu tương đương chọn K vector riêng ứng với K trị riêng lớn nhất của S.

# Các bước PCA

  * Tính kỳ vọng x̄

  * Chuẩn hoá dữ liệu: Ẋ = X − x̄1^T

  * Tính ma trận hiệp phương sai S

  * Tính trị riêng & vector riêng, sắp xếp λ giảm dần

  * Chọn K vector riêng lớn nhất → U_K

  * Tính toạ độ mới: Z = U_K^T Ẋ

  * Xấp xỉ khôi phục: x ≈ U_K z + x̄

# Public_119

# Giới thiệu

Trong hai bài viết trước, PCA (unsupervised) giữ lại tổng phương sai lớn nhất nhưng không dùng nhãn. Trong phân lớp (supervised), tận dụng nhãn thường cho kết quả tốt hơn. Ví dụ chiếu lên các hướng d1 (gần PC1) và d2 (gần thành phần phụ): d1 có thể làm hai lớp chồng lấn, trong khi d2 tách tốt hơn cho classification. Điều này cho thấy giữ lại nhiều phương sai nhất không phải lúc nào cũng tốt cho phân lớp. LDA ra đời để tìm phép chiếu tuyến tính (projection matrix) tối đa hóa khả năng phân biệt (discriminant). Với C lớp, số chiều mới không vượt quá C−1.

# LDA cho bài toán với 2 classes

## Ý tưởng cơ bản

Discriminant tốt khi: (i) mỗi lớp tập trung (within-class variance nhỏ), (ii) các lớp cách xa nhau (between-class variance lớn).

## Xây dựng hàm mục tiêu

_Ký hiệu: dữ liệu x_n, phép chiếu y_n = w^T x_n._

Kỳ vọng mỗi lớp: m_k = (1/N_k) ∑_{n∈C_k} x_n, k=1,2. (1)

Hiệu kỳ vọng sau chiếu: m_1 − m_2 ⇒ w^T(m_1−m_2). (2)

Within-class variances (không lấy trung bình): s_k^2 = ∑_{n∈C_k} (y_n − m_k)^2. (3)

Ma trận between-class: S_B = (m_1−m_2)(m_1−m_2)^T. (5)

Ma trận within-class: S_W = ∑_{k=1}^2 ∑_{n∈C_k} (x_n−m_k)(x_n−m_k)^T. (6)

**Hàm mục tiêu Fisher (2 lớp):**

J(w) = (w^T S_B w) / (w^T S_W w). (4,7)

## Nghiệm tối ưu (Fisher’s linear discriminant)

_Đạo hàm và sắp xếp lại:_

S_W^{-1} S_B w = J(w) w. (10)

**Chọn nghiệm tỷ lệ:**

w = α S_W^{-1}(m_1 − m_2), α≠0. (11)

# LDA cho multi-class classification

Phép chiếu tuyến tính: y = W^T x, W ∈ R^{D×D′}. Không dùng bias.

**Within-class tổng quát:**

s_W = trace(W^T S_W W), với S_W = ∑_{k=1}^C ∑_{n∈C_k} (x_n − m_k)(x_n − m_k)^T. (17–19)

**Between-class tổng quát:**

s_B = trace(W^T S_B W), với S_B = ∑_{k=1}^C N_k (m_k − m)(m_k − m)^T. (21–22)

**Hàm mục tiêu multi-class:**

J(W) = trace(W^T S_B W) / trace(W^T S_W W).

_Điều kiện tối ưu bậc nhất:_

S_W^{-1} S_B W = J W. (24)

_Các cột của W là các eigenvectors ứng với các trị riêng lớn nhất của S_W^{-1} S_B._

_Bổ đề: rank(S_B) ≤ C − 1 ⇒ số chiều tối đa sau LDA ≤ C − 1._

# Ví dụ nhanh (Python, phác thảo)

_• Tạo dữ liệu 2 lớp: X0, X1 ∈ R^{N×D}; tính m0, m1._

_• S_B = (m0 − m1)(m0 − m1)^T; S_W = ∑ (x − m_k)(x − m_k)^T._

_• W từ eigenvectors của inv(S_W) @ S_B; so sánh sklearn.discriminant_analysis.LDA._

# Thảo luận

LDA là phương pháp supervised giảm chiều và/hoặc phân lớp: tối ưu small within-class & large between-class. Số chiều tối đa sau LDA là ≤ C−1. Giả định thường gặp: phân phối gần Gaussian, các ma trận hiệp phương sai giữa các lớp gần nhau. LDA tốt khi các lớp gần linearly separable; kém hiệu quả nếu không tách tuyến tính.

# Public_120

# Binary relevance (BR)

Phương pháp chuyển đổi đơn giản nhất là phương pháp chuyển đổi nhị phân (BR), tức là với mỗi nhãn khác nhau sẽ xây dựng một bộ phân lớp khác nhau. Phương pháp này xây dựng |L| bộ phân lớp nhị phân: Hl: X→ {l; -l} cho mỗi nhãn l khác nhau trong L. Thuật toán chuyển đổi dữ liệu ban đầu trong tập L nhãn. Nhãn là l nếu các nhãn của ví dụ ban đầu gồm l, nhãn là ⌐l trong trường hợp ngược lại. Theo [12], phương pháp này đã được sử dụng bởi Boutell (2004), Goncalves và Quaresma (2003), Lauser và Hotho (2003), Li và Ogihara (2003). Sau đây là ví dụ biểu diễn dữ liệu theo phương pháp này:

_Biểu diễn dữ liệu theo phương pháp nhị phân_


| Example | Label 0 | Label 1 (⌐ label 0) | … (⌐ label 0) | Label 99 (⌐ label 0) |
| --- | --- | --- | --- | --- |
| 1 | X |  |  |  |

 
| Example | Label 0(⌐label 1) | Label 1 | … (⌐label 1) | Label 99 (⌐ label 1) |
| --- | --- | --- | --- | --- |
| 2 |  | X |  |  |

 

#  Multi - label k-Nearest Neighbors (MLkNN)

Thuật toán kNN [14] (k-Nearest Neighbors) là phương pháp học máy được sử dụng rộng rãi, thuật toán tìm hàng xóm gần nhất của một đối tượng thử nghiệm trong không gian đặc trưng.

Bộ phân lớp dựa trên thuật toán K người láng giềng gần nhất là một bộ phân lớp dựa trên bộ nhớ, đơn giản vì nó được xây dựng bằng cách lưu trữ tất cả các đối tượng trong tập huấn luyện. Để phân lớp cho một điểm dữ liệu mới x’, trước hết bộ phân lớp sẽ tính khoảng cách từ điểm dữ liệu mới tới các điểm dữ liệu trong tập huấn luyện. Qua đó tìm được tập N (x’, D, k) gồm k điểm dữ liệu mẫu có khoảng cách đến x’ gần nhất. Ví dụ nếu các dữ liệu mẫu được biểu diễn bởi không gian vector thì chúng ta có thể sử dụng khoảng cách Euclidean để tính khoảng cách giữa các điểm dữ liệu với nhau. Sau khi xác định được tập N (x’, D, k), bộ phân lớp sẽ gán nhãn cho điểm dữ liệu x’ bằng lớp chiếm đại đa số trong tập N (x’, D, k).

Công thức tính Euclidean để tính khoảng cách giữa các điểm dữ liệu: Giả sử có hai phần tử dữ liệu X1=(x11, x12 … x1n) và X2=(x21, x22 ... x2n), độ đo khoảng cách Euclide được tính bằng công thức:

![A mathematical equation with a square and square AI-generated content may be incorrect.](images/image1.png)

Mô tả thuật toán:

\- Đầu vào: tập dữ liệu học D đã có nhãn và đối tượng kiểm tra z.
\- Tiến trình:
\- Tính d (x, x’) khoảng cách giữa đối tượng kiểm tra và mọi đối tượng (x, y) ϵ D.
\- Lựa chọn tập Dz gồm k đối tượng ϵ
\- Đầu ra: nhãn của đối tượng kiểm tra được xác định là
𝑦′ = arg max ∑ 𝐼(𝑣 = 𝑦𝑖)
(𝑥𝑖,𝑦𝑖)
Trong đó:
\- v là một nhãn trong tập nhãn
\- I () là một hàm số trả lại giá trị 1 khi v có nhãn yi, 0 nếu trong trường hợp ngược lại.
\- X là đối tượng xét, y là nhãn của nó.

Nhược điểm của thuật toán k-NN: Đòi hỏi không gian lưu trữ lớn.

Thuật toán MLkNN [13] là thuật toán k-NN áp dụng cho bài toán gán đa nhãn.

![A black text on a white background AI-generated content may be incorrect.](images/image2.png)

![A math equation with black text AI-generated content may be incorrect.](images/image3.png)
Trong mỗi trường hợp kiểm tra t, ML-KNN có k hàng xóm N (t) trong mỗi tập huấn luyện. Kí hiệu Hl1 là trường hợp t có nhãn l, Hl0 là trường hợp t không có nhãn l, Elj (jÎ{0, 1 … K}) biểu thị cho các trường hợp đó, giữa K láng giềng của t, chính xác j thể hiện có l nhãn. Do đó, nền tảng trên vector _C_ t, phân loại vector _y_ t sử dụng theo nguyên tắc:
![A black text on a white background AI-generated content may be incorrect.](images/image4.png)
Sử dụng luận Bayesian, có thể viết lại:
![A math equations on a white background AI-generated content may be incorrect.](images/image5.png)
Mã giả thuật toán MLkNN được trình bày như sau:

![A paper with mathematical equations AI-generated content may be incorrect.](images/image6.png)

_Hình 2.1 Mã giả thuật toán ML-kNN_

#  Random k-labelsets (RAKEL)

Phương pháp Label Powerset (LP) là một phương pháp chuyển đổi của phân lớp dữ liệu đa nhãn mà có xem xét đến sự phụ thuộc của các nhãn lớp. Ý tưởng của phương pháp này là coi một tập con các nhãn như là một nhãn và tiến hành phân lớp như việc phân lớp dữ liệu đơn nhãn. Theo phương pháp này thì số lượng các tập con nhãn được tạo ra là rất lớn, Grigorios và đồng nghiệp [11] đã đề xuất phương pháp RAKEL với mục đích tính đến độ tương quan giữa các nhãn, đồng thời tránh những vấn đề nói trên của LP.
Định nghĩa tập K nhãn, cho tập nhãn L của phân lớp đa nhãn, L= {λi}, với i = 1…|L|. Một tập Y![](images/image7.png) L với K = |L| gọi là tập K nhãn. Ta sử dụng giới hạn LK là tập của tất cả tập nhãn K khác nhau trên L. Kích thước LK cho bởi công thức: |LK| = (|L| K).
Thuật toán RAKEL là cấu trúc toàn bộ của m phân loại LP, với i = 1 …m, chọn ngẫu nhiên một tập K nhãn, Yi, từ Lk. Sau đó, học phân loại LP ℎ𝑖: 𝑋 → 𝑃(𝑌𝑖). Thủ tục của RAKEL:
![A white text with black text AI-generated content may be incorrect.](images/image8.png)

_Hình 2.2 Mã giả thuật toán RAKEL_

Số của sự lặp lại (m) là một tham số cụ thể cùng dãy giá trị có thể chấp nhận được từ 1 tới |LK|. Kích cỡ của tập K nhãn là một tham số cụ thể cùng dãy giá trị từ 2 tới |L| - 1. Cho K = 1 và m = |L| ta phân loại toàn bộ nhị phân của phương pháp Binary Relevance, khi K = |L| (m = 1). Giả thiết việc sử dụng tập nhãn có kích thước nhỏ, số lặp vừa đủ, khi đó RAKEL sẽ quản lý để mô hình nhãn tương quan hiệu quả.

# ClassifierChain (CC)

Thuật toán này bao gồm chuyển đổi nhị phân L như BR. Thuật toán này khác với thuật toán BR trong không gian thuộc tính cho mỗi mô hình nhị phân, nó được mở rộng cùng nhãn 0/1 cho tất cả phân lớp trước đó [8]. Ví dụ, chuyển đổi giữa BR và CC cho (x, y) với y = [1, 0, 0, 1, 0] và x = [0, 1, 0, 1, 0, 0, 1, 1, 0] (giả sử, cho đơn giản, không gian nhị phân). Mỗi phân loại hj được huấn luyện dự đoán yj ϵ {0, 1}.
_Chuyển đổi nhị phân giữa BR và CC [8]  
_


| Chuyển đổi của BR | Chuyển đổi của CC |
| --- | --- |
| h: x→ y | h: x’→ y |
| h1: [0, 1, 0, 1, 0, 0, 1, 1, 0] 1h2: [0, 1, 0, 1, 0, 0, 1, 1, 0] 0h3: [0, 1, 0, 1, 0, 0, 1, 1, 0] 0h4: [0, 1, 0, 1, 0, 0, 1, 1, 0] 1h5: [0, 1, 0, 1, 0, 0, 1, 1, 0] 0 | h1: [0, 1, 0, 1, 0, 0, 1, 1, 0] 1h2: [0, 1, 0, 1, 0, 0, 1, 1, 0,1] 0h3: [0, 1, 0, 1, 0, 0, 1, 1, 0,1, 0] 0h4: [0, 1, 0, 1, 0, 0, 1, 1, 0,1, 0, 0] 1h5: [0, 1, 0, 1, 0, 0, 1, 1, 0,1, 0, 0, 1] 0 |

# Public_121

# Phương pháp đánh giá các mô hình phân lớp đa nhãn

Để đánh giá các mô hình phân lớp đa nhãn MLL, khóa luận đã sử dụng phương pháp k-fold cross validation tập dữ liệu ban đầu được chia ngẫu nhiên thành k tập con (fold) có kích thước xấp xỉ nhau S1, S2 … Sk. Quá trình học và kiểm tra được thực hiện tại k lần. Tại lần lặp thứ i, Si là tập dữ liệu kiểm tra, các tập còn lại hợp thành dữ liệu huấn luyện. Có nghĩa là, đầu tiên chạy được thực hiện trên tập S2, S3 … Sk, sau đó test trên tập S1; tiếp tục quá trình dạy được thực hiện trên tập S1, S3, S4 … Sk, sau đó test trên tập S2; và cứ tiếp tục như thế.

Ví dụ, k = 10, thì phương pháp k-fold cross validation được minh họa như hình dưới:

_Bảng minh họa phương pháp k-fold cross validation  
_


| K=1 |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| K=2 |  |  |  |  |  |  |  |  |  |  |
| … |  |  |  |  |  |  |  |  |  |  |
| K=10 |  |  |  |  |  |  |  |  |  |  |

 

Trong đó: Là dữ liệu kiểm tra

Là dữ liệu học

##   


# Một số độ đo để đánh giá mô hình phân lớp đa nhãn

Đánh giá kết quả phương pháp phân lớp đa nhãn có sự khác biệt với đơn nhãn. Khóa luận đánh giá các phương pháp phân lớp đa nhãn dựa trên một số độ đo sau: Hamming Loss [15], One-error [15], Coverage [15], Ranking Loss [15], Average Precision, Mean Average Precision.

Cho một tập S = {(x1, Y1) … (xn, Yn)} của n ví dụ kiểm tra. Cho Y*i = h (xi) là tập hợp nhãn dự đoán cho kiểm tra xi, khi Yi là tập nhãn cho xi.

**Hamming Loss** : độ mất mát dữ liệu, được tính như sau:

![](images/image1.png)

Trong đó, 𝛿 là một hàm mà đầu ra là 1 nếu một nội dung đúng và 0 trong trường hợp ngược lại. Nhỏ hơn giá trị của hloss (h), thực thi tốt hơn. Trong trường hợp lí tưởng, hloss (h) = 0.

**One** - **error** : đánh giá lỗi cho nhãn xếp hạng đầu:

![A black and white math symbol AI-generated content may be incorrect.](images/image2.png)

Giá trị nhỏ hơn one_err (f), thực thi tốt hơn. Chú ý, vấn đề phân loại cho đơn nhãn, một lỗi chính là phân loại lỗi thường.

**Coverage** : Để đánh giá hiệu suất của một hệ thống cho tất cả các nhãn của một mẫu (đếm số lượng tất cả các nhãn). Coverage được định nghĩa như khoảng cách trung bình cho tất cả các nhãn thích hợp được gán cho một ví dụ thử nghiệm:

![A black and white math symbol AI-generated content may be incorrect.](images/image3.png)

**Ranking Loss** : Tính phân bố trung bình của các cặp nhãn:

![](images/image4.png)

Với 𝑌̅𝜄 là phần bù của tập nhãn Yi. Giá trị của rloss (f) càng nhỏ thì càng tốt.

**Average Precision** : độ chính xác trung bình của P@K tại các mức K có đối tượng đúng. Gọi I (K) là hàm xác định đối tượng ở vị trí hạng K nếu đúng I(K) = 1 và ngược lại I(K) = 0, khi đó:

![A black text on a white background AI-generated content may be incorrect.](images/image5.png)

Với n là số đối tượng được xét, P@K là độ chính xác của K đối tượng đầu bảng xếp hạng. Xác định số đối tượng đúng ở K vị trí đầu tiên của xếp hạng và gọi là Match@K và ta có

![A black text on a white background AI-generated content may be incorrect.](images/image6.png)

**Mean Average Precision** : Độ chính xác trung bình trên N xếp hạng. (N truy vấn, mỗi truy vấn có một thứ tự xếp hạng kết quả tương ứng).

![A black and white math equation AI-generated content may be incorrect.](images/image7.png)

Xét ví dụ:

Giả sử có có 5 đối tượng được xếp hạng tương ứng là: c, a, e, b, d

Một xếp hạng của đối tượng cần đánh giá là: **c, a, e** , d, b

Khi đó, P@1 = 1/1, P@2 = 2/2, P@3 = 3/3, P@4 = 3/4, P@5 = 3/5.

![A math equations with numbers and symbols AI-generated content may be incorrect.](images/image8.png)

# Public_122

# Giới thiệu

Động lực của nghiên cứu xuất phát từ những hạn chế của các phương pháp hiện tại trong việc xử lý các điều kiện ánh sáng phức tạp trong thực tế. Hình ảnh được chụp trong các bối cảnh đa dạng thường gặp phải tình trạng phơi sáng không đồng đều do sự thay đổi của ánh sáng, sự hiện diện của nhiều nguồn sáng, hoặc độ tương phản mạnh giữa các vùng sáng và tối. Các phương pháp truyền thống, như histogram equalization và tone mapping thường dựa trên các mô hình chiếu sáng toàn cục hoặc đơn giản, dẫn đến việc không khôi phục được các chi tiết quan trọng ở cả vùng thừa sáng và thiếu sáng, đặc biệt là trong các cảnh có điều kiện ánh sáng phức tạp.

Các phương pháp deep learning gần đây đã cải thiện đáng kể hiệu năng hiệu chỉnh độ phơi sáng so với các phương pháp truyền thống. Tuy nhiên, hầu hết các mô hình này giả định ánh sáng đồng nhất và không xử lý được sự tương tác giữa nhiều nguồn sáng, điều rất phổ biến trong các cảnh tự nhiên. Tương tự, các mô hình chiếu sáng dựa trên vật lý chủ yếu tập trung vào một nguồn sáng duy nhất, khiến chúng khó áp dụng hiệu quả trong thực tế khi có nhiều nguồn chiếu sáng.

Nghiên cứu này nhằm giải quyết các hạn chế trên bằng cách đề xuất Dual Illumination Estimation. Ý tưởng cốt lõi là mô hình hóa và ước lượng đồng thời hai nguồn sáng chính và phụ, cho phép hiệu chỉnh độ phơi sáng một cách thích ứng và chi tiết trong các điều kiện ánh sáng đa dạng. Phương pháp này không chỉ nâng cao chất lượng hình ảnh được hiệu chỉnh mà còn cung cấp một giải pháp tiền xử lý mạnh mẽ cho các ứng dụng trong nhiếp ảnh, thị giác máy tính, và xử lý ảnh tự động. Bằng cách giải quyết khoảng trống trong các phương pháp hiện có, nghiên cứu kỳ vọng sẽ thiết lập một tiêu chuẩn mới trong hiệu chỉnh độ phơi sáng cho các môi trường phức tạp trong thực tế.

# Mô tả thuật toán

Với một hình ảnh đầu vào, trước tiên quá trình ước lượng chiếu sáng kép (dual illumination estimation) được thực hiện để thu được các ánh sáng tiến (forward illumination) và ngược (reverse illumination). Từ đó, hình ảnh được hiệu chỉnh độ phơi sáng trung gian cho các trường hợp thiếu sáng (underexposure) và thừa sáng (overexposure) sẽ được khôi phục. Tiếp theo, một phương pháp hòa trộn hình ảnh hiệu chỉnh đa phơi sáng (multi-exposure image fusion) hiệu quả sẽ được áp dụng để kết hợp liền mạch các phần được phơi sáng tốt nhất từ hai hình ảnh hiệu chỉnh phơi sáng trung gian, cũng như hình ảnh đầu vào, thành một hình ảnh cuối cùng được phơi sáng đồng đều trên toàn cầu.

![A diagram of a person AI-generated content may be incorrect.](images/image1.png)

_**Tổng quan về thuật toán hiệu chỉnh độ phơi sáng được đề xuất.**_

## Ước lượng chiếu sáng kép (Dual Illumination Estimation)

Phần này mô tả chi tiết kỹ thuật ước lượng chiếu sáng kép. Mục tiêu là ước lượng hai bản đồ chiếu sáng bổ sung: ánh sáng tiến Lf​ và ánh sáng ngược Lr​. Các bản đồ này cho phép hiệu chỉnh các vùng thiếu sáng và thừa sáng của ảnh đầu vào một cách hiệu quả.

Cho ảnh đầu vào I được biểu diễn trong không gian màu RGB với các giá trị cường độ pixel được chuẩn hóa trong khoảng [0,1]. Phương pháp ước lượng chiếu sáng kép dựa trên quan sát rằng có thể tạo ra các ánh sáng bổ sung để cải thiện các vùng phơi sáng khác nhau của ảnh:

  1. Chiếu sáng tiến Lf​: Làm nổi bật và cải thiện các vùng tối hoặc thiếu sáng.

  2. Chiếu sáng ngược Lr​: Tập trung làm giảm các vùng bị thừa sáng.


Quá trình ước lượng Lf​ và Lr​ được thực hiện qua các bước sau:

**Bước 1: Ảnh đảo ngược**

Để tạo ra ánh sáng ngược, ảnh đầu vào III được đảo ngược:

$Iinv=1−II_{inv} = 1 - I$

Phép đảo ngược này thực chất lật các mức cường độ sáng, làm cho các vùng bị thừa sáng trở nên giống như thiếu sáng.

**Bước 2: Mô hình chiếu sáng**

Các bản đồ chiếu sáng được ước lượng bằng cách giải các bài toán tối ưu hóa cho cả Lf​ và Lr​. Các bản đồ này dựa trên mô hình Retinex, tách ảnh thành thành phần phản xạ và chiếu sáng:

$I=R⊙LI = R  odot  L$

Trong đó R là phần phản xạ và L là phần chiếu sáng. Framework dual illumination tính toán Lf​ và Lr​ bằng cách áp dụng các ràng buộc về độ mượt (smoothness) và tính trung thực (fidelity).

**Chiếu sáng tiến L f​:**

$$
Lr=argminL∥I−L⊙R∥2+λΦ(L)L_{r} = argmin_{L}{left| I -  L odot  R right|^{2} + lambda Phi(L)}
$$

trong đó:

  1. $Φ(L)Phi(L)$ là độ mượt (v.d. Total Variation)

  2. $λlambda$ là tham số điều chỉnh mức độ của ràng buộc độ mượt.


**Chiếu sáng ngược L r:​**

Ánh sáng ngược được tính toán tương tự từ ảnh đảo ngược Iinv:

$$
Lr=argminL∥Iinv−L⊙R∥2+λΦ(L)L_{r} = argmin_{L}{left| I_{inv} -  L odot  R right|^{2} + lambda Phi (L)}
$$

**Bước 3: Ước lượng số học**

Các bài toán tối ưu hóa trên được giải theo phương pháp gradient-based, đảm bảo rằng các bản đồ ánh sáng thu được mượt mà đồng thời nắm bắt chính xác điều kiện ánh sáng của ảnh đầu vào.

**Bước 4: Lọc mịn**

Để đảm bảo tính nhất quán giữa Lf​ và Lr​, kỹ thuật lọc song phương (bilateral filtering) được áp dụng. Phương pháp này làm mịn các bản đồ chiếu sáng trong khi vẫn bảo toàn các chi tiết tại biên. Cuối cùng, các bản đồ ánh sáng được chuẩn hóa để đảm bảo tương thích với các bước tiếp theo trong pipeline.

**Mã giả:**

Input: Image I

Output: Forward Illumination L_f, Reverse Illumination L_r

1\. Compute inverted image: I_inv = 1 - I

2\. Initialize L_f, L_r (e.g., with uniform values)

3\. While not converged:

a. Update L_f:

L_f = argmin || I - L_f * R ||^2 + λ * Smoothness(L_f)

b. Update L_r:

L_r = argmin || I_inv - L_r * R ||^2 + λ * Smoothness(L_r)

c. Apply bilateral filter to L_f, L_r

4\. Normalize L_f, L_r

## Trộn đa hình ảnh phơi sáng (Multi-Exposure Image Fusion)

Phần này mô tả chi tiết kỹ thuật hòa trộn hình ảnh đa phơi sáng. Mục tiêu của bước này là kết hợp liền mạch các phần được phơi sáng tốt nhất từ các hình ảnh đã hiệu chỉnh (underexposure-corrected và overexposure-corrected) và ảnh đầu vào để tạo ra một hình ảnh cuối cùng có độ phơi sáng đồng đều trên toàn cầu.

Cho các hình ảnh đầu vào:

Iu​: Hình ảnh đã được hiệu chỉnh vùng thiếu sáng (underexposure-corrected).

Io​: Hình ảnh đã được hiệu chỉnh vùng thừa sáng (overexposure-corrected).

I: Ảnh gốc.

Nhiệm vụ là hợp nhất Iu​, Io​, và I sao cho các vùng được chọn từ mỗi ảnh có độ phơi sáng tối ưu nhất. Quá trình này được thực hiện dựa trên các bản đồ trọng số cục bộ (weight maps) để chỉ định vùng nào sẽ được lấy từ mỗi hình ảnh.

**Bước 1: Tạo bản đồ trọng số cục bộ**

Bản đồ trọng số W được tính toán cho từng hình ảnh Iu​, Io​, và I. Các trọng số này được thiết kế để phản ánh chất lượng phơi sáng cục bộ của từng vùng. Công thức tính trọng số thường dựa trên các đặc trưng như độ tương phản, độ sắc nét và độ sáng cục bộ:

$$
Wx(p)=Contrast(p)•Sharpness(p)⋅Saturation(p)W_{x}(p) = Contrast(p) bullet Sharpness(p) cdot Saturation(p)
$$

Trong đó:

  3. Contrast(p): Đo lường độ tương phản tại điểm ảnh p.

  4. Sharpness(p): Đánh giá độ sắc nét bằng cách sử dụng các bộ lọc gradient.

  5. Saturation(p): Đo mức độ bão hòa màu tại p.


Các bản đồ trọng số được chuẩn hóa để đảm bảo tổng trọng số tại mỗi điểm ảnh bằng 1:

$$
If(p)=∑xŴx(p)⋅Ix(p),x∈{Iu,Io,I}I_{f}(p) = sum_{x}^{}{{widehat{W}}_{x}(p) cdot I_{x}}(p), x in { I_{u},I_{o},I}
$$

Quá trình này đảm bảo rằng mỗi điểm ảnh trong hình ảnh cuối cùng được lấy từ nguồn có chất lượng phơi sáng tốt nhất.

**Bước 3: Tăng độ mượt**

Để đảm bảo tính liên tục và không gây ra hiện tượng đường biên giữa các vùng được chọn từ các hình ảnh khác nhau, các bản đồ trọng số được làm mượt bằng bộ lọc Gaussian hoặc bộ lọc song phương trước khi sử dụng trong bước hòa trộn.

**Mã giả:**

Input: I_u (underexposure-corrected image),

I_o (overexposure-corrected image),

I (original image)

Output: Final globally well-exposed image I_f

1\. Compute local weight maps:

W_u = Contrast(I_u) * Sharpness(I_u) * Saturation(I_u)

W_o = Contrast(I_o) * Sharpness(I_o) * Saturation(I_o)

W_orig = Contrast(I) * Sharpness(I) * Saturation(I)

2\. Normalize weights:

W_u = W_u / (W_u + W_o + W_orig)

W_o = W_o / (W_u + W_o + W_orig)

W_orig = W_orig / (W_u + W_o + W_orig)

3\. Smooth weight maps using Gaussian filter:

W_u = GaussianFilter(W_u)

W_o = GaussianFilter(W_o)

W_orig = GaussianFilter(W_orig)

4\. Fuse images:

I_f = W_u * I_u + W_o * I_o + W_orig * I

# Public_123

# Giới thiệu tích chập

Tích chập là một khái niệm trong xử lý tín hiệu số nhằm biến đổi thông tin đầu vào thông qua một phép tích chập với bộ lọc để trả về đầu ra là một tín hiệu mới. Tín hiệu này sẽ làm giảm những đặc trưng mà bộ lọc không quan tâm và chỉ giữ những đặc trưng chính.

Tích chập thông dụng nhất là tích chập 2 chiều được áp dụng trên ma trận đầu vào và ma trận bộ lọc 2 chiều. Phép tích chập của một ma trận ![](images/image1.png)với một _bộ lọc_ (receptive field) ![](images/image2.png)là một ma trận ![](images/image3.png).

Trong một mạng nơ ron tích chập, các tầng ( _layer_ ) liền sau lấy đầu vào từ tầng liền trước nó. Do đó để hạn chế lỗi trong thiết kế mạng nơ ron chúng ta cần xác định kích thước đầu ra ở mỗi tầng. Điều đó có nghĩa là dựa vào kích thước ma trận đầu vào (W1, H1), kích thước bộ lọc (F,F) và bước nhảy S để xác định kích thước ma trận đầu ra (W2, H2)

Xét quá trình trượt trên chiều W1 của ma trận đầu vào.

![A screenshot of a computer AI-generated content may be incorrect.](images/image4.png)

**Hình 1:** Quá trình trượt theo chiều rộng w1. Mỗi dòng tương ứng với một bước. Mỗi bước chúng ta dịch sang phải một khoảng s đơn vị cho tới khi đi hết w1 ô. Nếu bước cuối cùng bị dư thì chúng ta sẽ lát ( _padding_ ) thêm để mở rộng ma trận sao cho quá trình tích chập không bị dư ô.

Giả sử quá trình này sẽ dừng sau w2 bước. Tại bước đầu tiên ta đi được đến vị trí thứ F . Sau mỗi bước liền sau sẽ tăng so với vị trí liền trước là S. Như vậy đến bước thứ i quá trình trượt sẽ đi đến vị trí F + (i-1)S. Suy ra tại bước cuối cùng w2 ma trận sẽ đi đến vị trí F + (W2-1)S. Đây là vị trí lớn nhất gần với vị trí cuối cùng là w1 . Trong trường hợp lý tưởng thì F + (W2 - 1)S. Từ đó ta suy ra:

![A black and white math equation AI-generated content may be incorrect.](images/image5.png)

Khi vị trí cuối cùng không trùng với w1 thì số bước w2 sẽ được lấy phần nguyên:

![A black and red text AI-generated content may be incorrect.](images/image6.png)

Chúng ta luôn có thể tạo ra đẳng thức (1) nhờ thêm phần _đường viền_ (padding) tại các cạnh của ảnh với độ rộng viền là P sao cho phép chia cho S là chia hết. Khi đó:

![A white rectangular object with black text AI-generated content may be incorrect.](images/image7.png)

**Hình 2:** Thêm padding kích thước P vào 2 lề chiều rộng (W1)

Hoàn toàn tương tự ta cũng có công thức ứng với chiều cao:

![A black and white math equation AI-generated content may be incorrect.](images/image8.png)

# Mạng nơ ron tích chập (mạng CNN)

## Các Thuật ngữ

Do bài này khá nhiều thuật ngữ chuyên biệt trong mạng CNN nên để dễ hiểu hơn cho bạn đọc tôi sẽ diễn giải trước khái niệm.

**\- Đơn vị (Unit)** : Là giá trị của một điểm nằm trên ma trận khối ở mỗi tầng của mạng CNN.

**\- Vùng nhận thức (Receptive Field)** : Là một vùng ảnh trên khối ma trận đầu vào mà bộ lọc sẽ nhân tích chập để ánh xạ tới một đơn vị trên layer tiếp theo.

**\- Vùng địa phương (Local region)** : Theo một nghĩa nào đó sẽ bao hàm cả vùng nhận thức. Là một vùng ảnh cụ thể nằm trên khối ma trận ở các tầng ( _layer_ ) của mạng CNN.

**\- Bản đồ đặc trưng (Feature Map)** : Là ma trận đầu ra khi áp dụng phép tích chập giữa bộ lọc với các vùng nhận thức theo phương di chuyển từ trái qua phải và từ trên xuống dưới.

**Bản đồ kích hoạt (Activation Map)** : Là output của _bản đồ đặc trưng_ CNN khi áp dụng thêm hàm activation để tạo tính phi tuyến.

## Kiến trúc chung của mạng neural tích chập

Tích chập được ứng dụng phổ biến trong lĩnh vực thị giác máy tính. Thông qua các phép tích chập, các đặc trưng chính từ ảnh được trích xuất và truyền vào các tầng _tích chập_ (layer convolution). Mỗi một tầng tích chập sẽ bao gồm nhiều đơn vị mà kết quả ở mỗi đơn vị là một phép biến đổi tích chập từ layer trước đó thông qua phép nhân tích chập với bộ lọc.

Về cơ bản thiết kế của một mạng nơ ron tích chập 2 chiều có dạng như sau:

INPUT -> [[CONV -> RELU]*N -> POOL?]*M -> [FC -> RELU]*K -> FC

Trong đó:

  * INPUT: Tầng đầu vào

  * CONV: Tầng tích chập

  * RELU: Tầng kích hoạt. Thông qua hàm kích hoạt ( _activation function_ ), thường là ReLU hoặc LeakyReLU để kích hoạt phi tuyến

  * POOL: Tầng tổng hợp, thông thường là Max pooling hoặc có thể là Average pooling dùng để giảm chiều của ma trận đầu vào.

  * FC: Tầng kết nối hoàn toàn. Thông thường tầng này nằm ở sau cùng và kết nối với các đơn vị đại diện cho nhóm phân loại.


Các kí hiệu [] _N, []_ M hoặc []*K ám chỉ các khối bên trong [] có thể lặp lại nhiều lần liên tiếp nhau. M, K là số lần lặp lại. Kí hiệu -> đại diện cho các tầng liền kề nhau mà tầng đứng trước sẽ làm đầu vào cho tầng đứng sau. Dấu ? sau POOL để thể hiện tầng POOL có thể có hoặc không sau các khối tích chập.

Như vậy ta có thể thấy một mạng nơ ron tích chập về cơ bản có 3 quá trình khác nhau:

  * Quá trình tích chập (convolution): Thông qua các tích chập giữa ma trận đầu vào với bộ lọc để tạo thành các đơn vị trong một tầng mới. Quá trình này có thể diễn ra liên tục ở phần đầu của mạng và thường sử dụng kèm với hàm kích hoạt ReLU. Mục tiêu của tầng này là trích suất đặc trưng hai chiều.

  * Quá trình tổng hợp (max pooling): Các tầng càng về sau khi trích xuất đặc trưng sẽ cần số lượng tham số lớn do chiều sâu được qui định bởi số lượng các kênh ở các tầng sau thường tăng tiến theo cấp số nhân. Điều đó làm tăng số lượng tham số và khối lượng tính toán trong mạng nơ ron. Do đó để giảm tải tính toán chúng ta sẽ cần giảm kích thước các chiều của khối ma trận đầu vào hoặc giảm số đơn vị của tầng. Vì mỗi một đơn vị sẽ là kết quả đại diện của việc áp dụng 1 bộ lọc để tìm ra một đặc trưng cụ thể nên việc giảm số đơn vị sẽ không khả thi. Giảm kích thước khối ma trận đầu vào thông qua việc tìm ra 1 giá trị đại diện cho mỗi một vùng không gian mà bộ lọc đi qua sẽ không làm thay đổi các đường nét chính của bức ảnh nhưng lại giảm được kích thước của ảnh. Do đó quá trình giảm chiều ma trận được áp dụng. Quá trình này gọi là tổng hợp nhằm mục đích giảm kích thước dài, rộng.

  * Quá trình kết nối hoàn toàn (fully connected): Sau khi đã giảm kích thước đến một mức độ hợp lý, ma trận cần được trải phẳng (flatten) thành một vector và sử dụng các kết nối hoàn toàn giữa các tầng. Quá trình này sẽ diễn ra cuối mạng CNN và sử dụng hàm kích hoạt là ReLU. Tầng kết nối hoàn toàn cuối cùng (fully connected layer) sẽ có số lượng đơn vị bằng với số classes và áp dụng hàm kích hoạt là softmax nhằm mục đích tính phân phối xác xuất.


# Tính chất của mạng nơ ron tích chập

**Tính kết nối trượt:** Khác với các mạng nơ ron thông thường, mạng nơ ron tích chập không kết nối tới toàn bộ hình ảnh mà chỉ kết nối tới từng _vùng địa phương_ (local region) hoặc _vùng nhận thức_ (receptive field) có kích thước bằng kích thước bộ lọc của hình ảnh đó. Các bộ lọc sẽ trượt theo chiều của ảnh từ trái qua phải và từ trên xuống dưới đồng thời tính toán các giá trị tích chập và điền vào _bản đồ kích hoạt_ (activation map) hoặc _bản đồ đặc trưng_ (feature map).

![A blue and green grid AI-generated content may be incorrect.](images/image9.png)

**Các khối nơ ron 3D:** Không giống như những mạng nơ ron thông thường khi cấu trúc ở mỗi tầng là một ma trận 2D (batch size x số đơn vị ở mỗi tầng). Các kết quả ở mỗi tầng của một mạng nơ ron là một khối 3D được sắp xếp một cách hợp lý theo 3 chiều rộng (width), cao (height), sâu (depth). Trong đó các chiều rộng và cao được tính toán theo công thức tích chập mục 1.1. Giá trị chiều rộng và cao của một tầng phụ thuộc vào kích thước của bộ lọc, kích thước của tầng trước, kích thước mở rộng ( _padding_ ) và bước trượt bộ lọc (stride). Tuy nhiên chiều sâu lại hoàn toàn không phụ thuộc vào những tham số này mà nó bằng với số bộ lọc trong tầng đó. Quá trình tính bản đồ kích hoạt dựa trên một bộ lọc sẽ tạo ra một ma trận 2D. Như vậy khi áp dụng cho d bộ lọc khác nhau, mỗi bộ lọc có tác dụng trích suất một dạng đặc trưng trên mạng nơ ron, ta sẽ thu được d ma trận 2D có cùng kích thước mà mỗi ma trận là một bản đồ đặc trưng. Khi sắp xếp chồng chất các ma trận này theo chiều sâu kết quả đầu ra là một khối nơ ron 3D. Thông thường đối với xử lý ảnh thì tầng đầu vào có depth = 3 (số kênh) nếu các bức ảnh đang để ở dạng màu gồm 3 kênh RBG. Bên dưới là một cấu trúc mạng nơ ron điển hình có dạng khối.

![A diagram of a diagram of a variety of squares AI-generated content may be incorrect.](images/image10.png)

**Tính chia sẻ kết nối và kết nối cục bộ:** Chúng ta đã biết quá trình biến đổi trong mạng tích chập sẽ kết nối các khối nơ ron 3D. Tuy nhiên các đơn vị sẽ không kết nối tới toàn bộ khối 3D trước đó theo chiều rộng và cao mà chúng sẽ chọn ra các _vùng địa phương_ (hoặc vùng nhận thức) có kích thước bằng với bộ lọc. Các vùng địa phương sẽ được chia sẻ chung một bộ siêu tham số có tác dụng nhận thức đặc trưng của bộ lọc. Các kết nối cục bộ không chỉ diễn ra theo chiều rộng và cao mà kết nối sẽ mở rộng hoàn toàn theo chiều sâu. Như vậy số tham số trong một tầng sẽ là FxFxD ( F, D lần lượt là kích thước bộ lọc và chiều depth).

Mỗi bộ lọc sẽ có khả năng trích xuất một đặc trưng nào đó như đã giải thích ở mục 1. Do đó khi đi qua toàn bộ các vùng địa phương của khối nơ ron 3D, các đặc trưng được trích xuất sẽ hiển thị trên tầng mới.

![A diagram of a block with numbers and a few circles AI-generated content may be incorrect.](images/image11.png)

**Tính tổng hợp:** Ở các tầng tích chập gần cuối số tham số sẽ cực kì lớn do sự gia tăng của chiều sâu và thông thường sẽ theo cấp số nhân. Như vậy nếu không có một cơ chế kiểm soát sự gia tăng tham số, chi phí tính toán sẽ cực kì lớn và vượt quá khả năng của một số máy tính cấu hình yếu. Một cách tự nhiên là chúng ta sẽ giảm kích thước các chiều rộng và cao bằng kỹ thuật giảm mẫu ( _down sampling_ ) mà vẫn giữ nguyên được các đặc trưng của khối. Theo đó những bộ lọc được di chuyển trên bản đồ đặc trưng và tính trung bình (average pooling) hoặc giá trị lớn nhất (max pooling) của các phần tử trong vùng nhận thức. Trước đây các tính trung bình được áp dụng nhiều nhưng các mô hình hiện đại đã thay thế bằng giá trị lơn nhất do tốc độ tính max nhanh hơn so với trung bình.

![A diagram of a diagram of a pool AI-generated content may be incorrect.](images/image12.png)

**Độ phức tạp phát hiện hình ảnh tăng dần:** Ở tầng đầu tiên, hình ảnh mà chúng ta có chỉ là những giá trị pixels. Sau khi đi qua tầng thứ 2 máy tính sẽ nhận diện được các hình dạng cạnh, rìa và các đường nét đơn giản được gọi là đặc trưng bậc thấp (low level). Càng ở những tầng tích chập về sau càng có khả năng phát hiện các đường nét phức tạp, đã rõ ràng hình thù và thậm chí là cấu thành vật thể, đây được gọi là những đặc trưng bậc cao (high level). Máy tính sẽ học từ tầng cuối cùng để nhận diện nhãn của hình ảnh.

# Public_124

# GIỚI THIỆU 

Xử lý ngôn ngữ tự nhiên là một lĩnh vực nghiên cứu của trí tuệ nhân tạo nhằm xây dựng một hệ thống xử lý cho máy tính, làm cho máy tính có thể hiểu được ngôn ngữ của con người gồm cả ngôn ngữ nói và viết. Không chỉ với một ngôn ngữ của một dân tộc, của một quốc gia mà máy tính có thể hiểu được ngôn ngữ của tất cả các dân tộc, các quốc gia trên thế giới. Nhờ đó, mọi người trên thế giới dựa vào máy tính cũng có thể hiểu và giao tiếp được với nhau mà không cần học, hiểu ngôn ngữ của nhau,... Và hơn thế nữa, máy tính có thể phân tích, tổng hợp ngôn ngữ để đưa ra tri thức cho con người một cách nhanh chóng và chính xác. Nhất là khi các dữ liệu liên quan đến ngôn ngữ đang dần trở nên là kiểu dữ liệu chính của con người.

Xử lý ngôn ngữ tự nhiên nhằm mục đích: Phân tích, nhận biết, tổng hợp ngôn ngữ tự nhiên. Là cơ sở chính để hiểu ngôn ngữ, dịch ngôn ngữ, xử lý tiếng nói, xử lý văn bản,... Để xử lý ngôn ngữ tự nhiên bằng máy tính, trên thế giới người ta đã cho ra đời một ngành học mới được kết hợp giữa hai ngành máy tính và ngôn ngữ học, được gọi là ngôn ngữ học máy tính. Trong tương lai máy tính sử dụng ngôn ngữ tự nhiên để giao tiếp giữa người và máy, máy có khả năng hiểu được ngôn ngữ tự nhiên của con người và trả lời các câu hỏi của con người. Thậm chí máy sẽ dịch được các ngôn ngữ tự nhiên từ một ngôn ngữ này sang một một ngôn ngữ khác một cách nhanh chóng và chính xác.

Với một hệ thống xử lý ngôn ngữ tự nhiên, đầu vào của một hệ thống có thể là một hoặc nhiều câu dưới dạng tiếng nói hay văn bản. Các dữ liệu liên quan đến ngôn ngữ viết (văn bản) và nói (tiếng nói) đang dần trở nên kiểu dữ liệu chính con người có và lưu trữ dưới dạng điện tử. Đặc điểm chính của các kiểu dữ liệu này là không có cấu trúc hoặc nửa cấu trúc và chúng không thể lưu trữ trong các khuôn dạng cố định như các bảng biểu. Theo đánh giá của công ty Oracle, hiện có đến 80% dữ liệu không cấu trúc trong lượng dữ liệu của loài người đang có [Oracle Text]. Với sự ra đời và phổ biến của Internet, của sách báo điện tử, của máy tính cá nhân, của viễn thông, của thiết bị âm thanh, … người người ai cũng có thể tạo ra dữ liệu văn bản hay tiếng nói. Vấn đề là làm sao ta có thể xử lý chúng, tức chuyển chúng từ các dạng ta chưa hiểu được thành các dạng ta có thể hiểu và giải thích được, tức là ta có thể tìm ra thông tin, tri thức hữu ích cho mình [1].

# CÁC BƯỚC XỬ LÝ VĂN BẢN

Quá trình xử lý văn bản hay quá trình phân tích và kiểm tra tính chính xác của một văn bản là một vấn đề khá phức tạp, trải qua nhiều bước khác nhau. Ở mỗi bước xử lý đòi hỏi người nghiên cứu phải có một nền tảng kiến thức vững vàng về ngôn ngữ cũng như nhiều kiến thức bổ trợ khác mới có thể xử lý tốt được. Quá trình này có thể được chia thành các bước sau.

  * Tiền xử lý văn bản: Sẽ xử lý sơ bộ văn bản đầu vào (làm sạch văn bản) bằng cách xóa bỏ những ký tự, những mã điều khiển, những vùng không cần thiết cho việc xử lý và phân rã nó ra thành các câu là đơn vị cơ sở của một văn bản.

  * Phân tích hình thái: phân tích câu thành một bảng các từ (hay cụm từ) riêng biệt, đồng thời kèm theo tất cả các thông tin về từ đó, như là: Từ loại, phạm trù ngữ pháp, các biến cách của từ, tiền tố, hậu tố của từ (nếu có). Trong trường hợp gặp từ mới, hệ thống sẽ để nguyên và đánh dấu một từ loại đặc biệt để chuyển sang phần xử lý tên riêng hay từ mới.

  * Phân tích cứu pháp: Phân tích một câu thành những thành phần văn phạm có liên quan với nhau và được thể hiện thành cây cú pháp. Khi nhập câu, ta phải phân thành các thành phần như chủ ngữ, vị ngữ; gán vai trò chủ từ, đối từ của động từ chính, bổ nghĩa,..

  * Phân tích ngữ nghĩa: là kiểm tra ý nghĩa của câu có mâu thuẫn với ý nghĩa của đoạn hay không. Dựa trên mối liên hệ logic về nghĩa giữa các cụm từ trong câu và mối liên hệ giữa các câu trong đoạn, hệ thống sẽ xác định được một phần ý nghĩa của câu trong ngữ cảnh của đoạn.

  * Tích hợp văn bản: Ngữ nghĩa của một câu riêng biệt có thể phụ thuộc vào những câu đứng trước, đồng thời nó cũng có thể ảnh hưởng đến các câu phía sau.

  * Phân tích thực nghĩa: phân tích nhằm xác định ý nghĩa câu dựa trên mối liên hệ của câu với hiện thực. Ý nghĩa thực tế của câu phụ thuộc rất nhiều vào ý tứ của người nói và ngữ cảnh diễn ra lời nói.


# HƯỚNG TIẾP CẬN VỚI BÀI TOÁN TÁCH TỪ

Các nhà nghiên cứu đã đề xuất một số hướng tiếp cận để giải quyết bài toán tách từ. Nhìn chung, các hướng tiếp cận đó được chia thành 2 hướng: tiếp cận dựa trên từ và tiếp cận dựa trên ký tự từ[2].

Hướng tiếp cận dựa trên từ với mục tiêu tách được các từ hoàn chỉnh trong câu. Hướng tiếp cận này được chia thành 3 nhóm: dựa trên thống kê (statistics-based), dựa trên từ điển (dictionary-based) và kết hợp nhiều phương pháp (hydrid-based).

Hướng tiếp cận dựa vào thống kê cần phải dựa vào thông tin thống kê như từ hay tần số ký tự, hay xác suất cùng xuất hiện trong một tệp dữ liệu cơ sở. Do đó, tính hiệu quả của các giải pháp này chủ yếu dựa vào dữ liệu huấn luyện cụ thể được sử dụng. Tác giả Đinh Điền [7] đã xây dựng ngữ liệu huấn luyện riêng (khoảng 10Mb) dựa vào các tài nguyên, tin tức và sách điện tử trên Internet, bộ dữ liệu này khá nhỏ và không toàn diện tức là không bao quát nhiều lĩnh vực, nhiều chủ đề.

Hướng tiếp cận dựa trên từ điển: Ý tưởng của hướng tiếp cận này là những cụm từ được tách ra từ văn bản phải được so khớp với các từ trong từ điển. Từ điển sử dụng để so khớp thì lại có 2 loại: từ điển hoàn chỉnh (full word/pharse) và từ điển thành phần (component). Trong từ điển hoàn chỉnh thì chia thành 3 loại: so khớp dài nhất (longest match), so khớp ngắn nhất (shortest match) và so khớp kết hợp (overlap). Hướng tiếp cận này có đặc điểm là đơn giản, dễ hiểu tuy nhiên hiệu quả mang lại chưa được cao. Lý do là bởi nó chưa xử lý được nhiều trường hợp nhập nhằng cũng như khả năng phát hiện từ mới trong văn bản chưa cao. Hiện nay, hướng tiếp cận so khớp cực đại được xem là phương pháp quan trọng và có hiệu quả nhất trong hướng tiếp cận từ điển.

Hướng tiếp cận nhiều phương pháp với mục đích kết hợp các phương pháp tiếp cận khác nhau để thừa hưởng các ưu điểm của nhiều kỹ thuật và hướng tiếp cận khác nhau nhằm nâng cao hiệu quả. Hướng tiếp cận này thường kết hợp giữa hướng tiếp cận thống kê và dựa trên từ điển nhằm tận dụng những mặt mạnh của các phương pháp này. Tuy nhiên, hướng tiếp cận này lại mất nhiều thời gian xử lý, không gian đĩa và chi phí cao.

Hướng tiếp cận dựa trên ký tự từ: Hướng tiếp cận này đơn thuần là rút trích ra một số lượng nhất định các tiếng trong văn bản như rút trích 1 ký tự (unigram) hay nhiều ký tự (n-gram). Phương pháp này tuy đơn giản nhưng mang lại kết quả quan trọng được chứng minh qua một số công trình nghiên cứu đã được công bố, như của tác giả Lê An Hà [3].

Trong bài báo gần đây của H.Nguyễn et al, đề xuất năm 2005. Đây là phương pháp tách từ dựa trên thống kê từ Internet và giải thuật di truyền thay vì sử dụng dữ liệu thô, để tìm ra những cách phân cách đoạn văn bản tối ưu nhất cùng một văn bản. Khi so sánh kết quả của tác giả Lê An Hà và H.Nguyễn thì thấy công trình nghiên cứu của H.Nguyễn cho được kết quả tốt hơn khi tiến hành tách từ, tuy nhiên thời gian xử lý lâu hơn. Ưu điểm của hướng tiếp cận dựa trên nhiều ký tự là tính đơn giản, dễ ứng dụng, chi phí thấp. Qua nhiều công trình nghiên cứu của các tác giả đã được công bố, hướng tiếp cận dựa trên ký tự từ được cho là sự lựa chọn thích hợp.

# MỘT SỐ PHƯƠNG PHÁP TÁCH TỪ

## Phương pháp so khớp cực đại (Maximum Matching)

Phương pháp này đã được ChihHao Tsai [4] giới thiệu năm 1996. Ý tưởng chính của phương pháp này là duyệt một câu từ trái qua phải và chọn từ có nhiều tiếng nhất có mặt trong từ điển tiếng Việt, rồi cứ thế tiếp tục cho từ kế tiếp cho đến hết câu.

Phương pháp so khớp cực đại dạng đơn giản: Giả sử chúng ta có một câu S={c1, c2, c3,...,cn} với c1, c2, c3,... cn là các tiếng được tách bởi khoảng trắng trong câu. Chúng ta bắt đầu duyệt từ đầu chuỗi, xác định đâu là từ. Trước tiên, chúng ta sẽ kiểm tra xem c1 có phải là từ có trong từ điển hay không, sau đó kiểm tra c1c2 có trong từ điển hay không. Tiếp tục như vậy c1c2c3, c1c2c3c4,..., c1c2c3... cn, với n là số tiếng lớn nhất của một từ có thể có nghĩa (nghĩa là có trong từ điển tiếng Việt). Sau đó, chúng ta chọn từ có nhiều tiếng nhất có mặt trong từ điển và đánh dấu từ đó. Tiếp tục quá trình trên với tất cả các từ còn lại trong câu và trong toàn bộ văn bản.

Phương pháp so khớp cực đại dạng phức tạp: Phương pháp này về cơ bản cũng giống như so khơp cực đại dạng đơn giản. Tuy nhiên, dạng này có thể tránh được một số nhập nhằng gặp phải trong dạng đơn giản. Độ chính xác cao lên đến 99.69% và 93.21 nhập nhằng được giải quyết. Đầu tiên, chúng ta sẽ kiểm tra xem c1 có phải từ có trong từ điển hay không, sau đó kiểm tra tiếp c1c2 có nằm trong từ điển hay không. Giả sử có 1 trường hợp xảy ra như sau: ta có c1 và c1c2 đều có trong từ điển thì thuật toán thực hiện chiến thực 3 từ tốt nhất được Chen & Liu (1992) đưa ra như sau:

Độ dài trung bình của từ lớn nhất: ở cuối mỗi chuỗi thường gặp những bộ chỉ có một hoặc hai từ. Luật này chỉ có lợi khi thiếu một hoặc một vài vị trí trong bộ. Khi bộ là bộ ba thì luật này không được hiệu quả lắm. Vì bộ ba từ có cùng tổng độ dài, đương nhiên nó sẽ có cùng độ dài chung bình. Nên giải pháp này không đạt hiệu quả cao vì thế chúng ta cần một giải pháp khác.

Sự chênh lệch độ dài của 3 từ là ít nhất: là độ biến đổi nhỏ nhất chiều dài từ. Luật này cho phép lấy bộ đầu tiên với độ biến đổi chiều dài từ nhỏ nhất. Trong ví dụ trên, ta lấy từ C1C2 từ bộ đầu tiên. Giả thiết của luật này là những từ có chiều dài đều bằng nhau.

Đánh giá phương pháp: Phương pháp so khớp cực đại là cách tách từ đơn giản, dễ hiểu và chạy nhanh. Hơn chúng ta chỉ cần một tập từ điển đầy đủ là có thể tiến hành tách các văn bản. Tuy nhiên, phương pháp này không giải quyết 2 vấn đề quan trọng của bài toán tách từ tiếng Việt là thuật toán gặp phải nhiều nhập nhằng; độ chính xác của phương pháp này phụ thuộc vào tính đầy đủ và tính chính xác của từ điển.

## Phương pháp chuyển dịch trạng thái hữu hạng có trọng số

Chuyển dịch trạng thái hữu hạn có trọng số (Weighted Finite-State Transducer – WFST) [5]. Mô hình chuyển dịch trạng thái hữu hạn có trọng số WFST đã được đề xuất năm 1996. Ý tưởng chính của phương pháp này áp dụng cho tách từ tiếng Việt là các từ sẽ được gán trọng số bằng xác suất xuất hiện của từ đó trong dữ liệu. Sau đó duyệt qua các câu, cách duyệt có trọng số lớn nhất sẽ là cách dùng để tách từ. Trong phương pháp này, tầng tiền xử lý có nhiệm vụ xử lý định dạng văn bản: Tiêu đề, đoạn, câu; chuẩn hoá về chính tả tiếng Việt (cách bỏ dấu, cách viết các ký tự y, i,... trong tiếng Việt). Ví dụ: Vật lý = vật lí, thời kỳ = thời kì).

Sau đó câu được chuyển sang tầng WFST. Trong tầng này tác giả xử lý thêm các vấn đề liên quan đến đặc thù của tiếng Việt, như: Từ láy, tên riêng, ...và tầng mạng Neural dùng để khử nhập nhằng về ngữ nghĩa sau khi đã tách từ (nếu có).

Sơ đồ các bước xử lý của WFST

Xét tầng WFST:

Hoạt động của WFST có thể chia thành ba bước sau:

\- Bước 1: Xây dựng từ điển trọng số, trong mô hình WFST, thì việc phân đoạn từ có thể được xem như là một sự chuyển dịch trạng thái có xác xuất. Chúng ta miêu tả từ điển D là một đồ thị biến đổi trạng thái hữu hạn có trọng số.

\- Bước 2: Xây dựng khả năng tách từ, bước này thống kê tất cả các khả năng tách từ của một câu. Vấn đề ở đây là để giảm sự bùng nổ các cách tách từ, thuật toán sẽ loại bỏ ngay những nhánh tách từ nào đó không phù hợp mà chứa từ không xuất hiện trong từ điển, không phải là từ láy, không phải là danh từ riêng thì loại bỏ các nhánh xuất phát từ cách tách từ đó. Thật vậy, giả sử một câu gồm n âm tiết, mà trong tiếng Việt thì một từ có tối đa 4 âm tiết tức là ta sẽ có tối đa 2n-1 cách tách từ khác nhau. Một câu tiếng Việt trung bình có 24 âm tiết thì lúc đó ta phải giải quyết 8.000.000 trường hợp tách từ có thể trong một câu.

\- Bước 3: Lựa chọn khả năng tối ưu: Sau khi liệt kê tất cả các khả năng tách từ, thuật toán sẽ chọn cách tách tốt nhất, đó là tách đoạn có trọng số bé nhất.

Xét ví dụ sau: Đầu vào là câu: “Tốc độ truyền thông tin sẽ tăng cao”:

Trọng số theo mỗi cách tách từ được tính là:

Id(I).D* = “Tốc độ # truyền thông # tin # sẽ # tăng # cao” (1)

= 8.68 +12.31+7.33+6.09+7.43+6.95=48.79

ID(I).D* = “TỐC ĐỘ # TRUYỀN # THÔNG TIN # SẼ # TĂNG # CAO” (2)

= 8.68 +12.31+7.24+6.09+7.43+6.95=48.70

Khi đó ta có được cách tối ưu là tách đoạn (2) “Tốc độ # truyền # thông tin # sẽ # tăng # cao”.

Xét tầng Neural:

Sau khi cho câu được tách từ qua mô hình WFST. Để xác định kết quả tách từ trên có thực sự hợp lệ hay không, tác giả định nghĩa một ngưỡng giá trị t0 với ý nghĩa như sau: nếu sự chênh lệch về trọng số (giữa các cách tách từ khác nhau với cách tách từ có trọng số nhỏ nhất) lớn hơn t0 thì đó là kết quả tách từ có trọng số nhỏ nhất đó đúng của câu và được chấp nhận. Còn nếu sự chênh lệch đó không lớn hơn t0, thì cách tách từ có trọng số nhỏ nhất đó chưa được xem là kết quả tách từ đúng của câu. Lúc này, ta sẽ đưa những cách tách từ của câu này qua mô hình mạng Neural để xử lý tiếp.

Tầng nhập của mạng được kết nối hoàn toàn với một tầng ẩn gồm 10 nút với một hàm truyền. Những nút ẩn này lại được kết nối hoàn toàn với một tầng xuất chỉ gồm 1 nút. Nút xuất là một giá trị thực nằm giữa 0..1. Biểu thị cho khả năng hợp lệ của một dãy các từ loại đứng liền nhau trong một cửa sổ trượt. Khi cửa sổ trượt từ đầu câu đến cuối câu, cộng dồn các kết quả lại với nhau và gán giá trị này vào thành trọng số của câu. Câu có trọng số lớn nhất sẽ được chọn.

Hàm truyền được chọn là hàm sigmoid:

Đánh giá phương pháp: phương pháp này là sẽ cho độ chính xác cao nếu ta xây dựng được một dữ liệu học đầy đủ và chính xác. Nó còn có thể kết hợp với các phương pháp khử nhập nhằng để cho kết quả tách rất cao (có thể chính xác đến 97%, tỉ lệ này tuỳ thuộc vào loại văn bản). Tuy nhiên, việc đánh trọng số dựa trên tần số xuất hiện của từ, nên khi tiến hành tách thì không tránh khỏi các nhập nhằng trong tiếng Việt. Hơn nữa với những văn bản dài thì phương pháp này còn gặp phải sự bùng nổ các khả năng phân đoạn của từng câu.

## Phương pháp mô hình Markov ẩn

Mô hình Markov (Hidden Markov Model - HMM) được giới thiệu vào cuối những năm 1960 [6]. Cho đến hiện nay phương pháp này có một ứng dụng khá rộng như trong nhận dạng giọng nói, tính toán sinh học và xử lý ngôn ngữ tự nhiên. Mô hình Markov là mô hình trạng thái hữu hạn với các tham số biểu diễn xác suất chuyển trạng thái và xác suất sinh dữ liệu quan sát tại mỗi trạng thái.

Mô hình Markov ẩn là mô hình thống kê trong đó hệ thống được mô hình hóa được cho là một quá trình Markov với các tham số không biết trước và nhiệm vụ là xác định các tham số ẩn từ các tham số quan sát được, dựa trên sự thừa nhận này. Các tham số của mô hình được rút ra sau đó có thể sử dụng để thực hiện các phân tích kế tiếp.

Trong một mô hình Markov điển hình, trạng thái được quan sát trực tiếp bởi người quan sát, vì vậy các xác suất chuyển tiếp trạng thái là các tham số duy nhất. Mô hình Markov ẩn thêm vào các đầu ra, mỗi trạng thái có xác suất phân bổ trên các biểu hiện đầu ra có thể. Vì vậy, nhìn vào dãy của các biểu hiện được sinh ra bởi HMM không trực tiếp chỉ ra dãy các trạng thái.

Các thông số trong mô hình: xi: các trạng thái trong mô hình Markov, aij: Các xác suất chuyển tiếp, bij: các xác suất đầu ra, yi: Các dữ liệu quan sát.

Mô hình Markov ẩn thêm vào các đầu ra, mỗi trạng thái có xác suất phân bố trên các biểu hiện đầu ra có thể. Vì vậy, nhìn vào dãy của các biểu hiện được sinh ra bởi HMM không trực tiếp chỉ ra dãy các trạng thái. Ta có thể tìm ra được chuỗi các trạng thái mô tả tốt nhất cho mỗi dữ liệu quan sát đước bằng cách tính: P(Y | X) = P(Y | X) / P(X).

Trong khi đó Yn là trạng thái thời điểm thứ t = n trong chuỗi trạng thái Y, Xn là dữ liệu quan sát được tại thời điểm thứ t = n trong chuỗi X. Do trạng thái hiện tại chỉ phụ thuộc vào trạng thái ngay trước đó với giả thiết rằng dữ liệu quan sát được tại thời điểm t chỉ phụ thuộc vào trạng thái t. Ta có thể tính P(Y, X) theo công thức:

Đánh giá phương pháp: mô hình Markov để tính được xác suất P(Y,X) thông thường ta phải liệt kê hết các trường hợp có thể của chuỗi Y và chuỗi X. Thực tế thì chuỗi Y là hữu hạn có thể liệt kê được, còn X (các dữ liệu quan sát) là rất phong phú. Để giải quyết các vấn đề này HMM đưa ra giả thiết về sự độc lập giữa các dữ liệu quan sát. Dữ liệu quan sát được tại thời điểm t chỉ phụ thuộc vào trạng thái tại thời điểm đó. Hạn chế thứ hai gặp phải là việc sử dụng xác suất đồng thời P (Y, X) đôi khi không chính xác vì với một số bài toán thì việc sử dụng xác suất điều kiện P(Y|X) cho kết quả tốt hơn rất nhiều.

## Phương pháp so khớp từ dài nhất (Longest Matching):

Phương pháp so khớp từ dài nhất [7] dựa trên tư tưởng tham lam. Với mỗi câu, duyệt từ trái qua phải các âm tiết trong câu, kiểm tra xem có nhóm các âm tiết có tồn tại trong từ điển hay không. Chuỗi dài nhất các âm tiết được xác định là từ sẽ được chọn ra. Tiếp tục thực hiện việc so khớp cho đến hết câu. Thuật toán chỉ đúng khi không có sự nhập nhằng những tiếng đầu của từ sau có thể ghép với từ trước tạo thành một từ có trong từ điển.

Giải thuật

Input: Chuỗi ký tự;

Output: Chuỗi từ, cụm từ (từ có chiều dài dài nhất);

V là danh sách các tiếng chưa xét;

T là bộ từ điển.

While V ≠ ∅ do

Begin

Wmax= từ đầu danh sách V;

Foreach (v thuộc từ gồm các tiếng bắt đầu trong V)

If(length(v) > length(Wmax) and (v thuộc T))

Then Wmax=v;

Loại bỏ đi các từ Wmax ở đầu danh sách V;

End.

Xét ví dụ: “Tôi là sinh viên trường Đại học Kiên Giang”:

Đánh giá phương pháp: phương pháp so khớp từ dài nhất là phương pháp tách từ đơn giản chỉ cần dựa vào từ điển với đội chính xác tương đối cao. Phương pháp này sẽ không tốt nếu có hiện tượng nhập nhằng xảy ra. Độ chính xác phụ thuộc hoàn toàn vào tính đầy đủ và chính xác của từ điển.

# THỰC NGHIỆM – KẾT QUẢ

## Thực nghiệm

Mục tiêu nghiên cứu là đánh giá tính khả thi của thuật toán tách từ dựa vào phương pháp so khớp cực đại (Maximum Matching) để tách toàn bộ văn bản, với dữ liệu sử dụng là bảng âm tiết tiếng Việt và từ điển từ vựng tiếng Việt. Phần mềm Vntokenizer là phần mềm tách từ biểu diễn cho phương pháp so khớp cực đại.

Quy trình thực hiện tách từ theo phương pháp so khớp cực đại (Vntokenizer).

Input: của phần mềm Vntokenizer là một câu, một văn bản được lưu dưới dạng tệp (.txt).

Output: là một chuỗi các từ đã được tách ở dạng file (.txt).

Thuật toán sẽ duyệt từ đầu chuỗi xác định đâu là từ. Đầu tiên, ta kiểm tra xem nó có trong từ điển hay không, sau đó kiểm tra tiếp chữ kế có trong từ điển hay không, nếu chữ đầu tiên và chữ kế tiếp có trong kho dữ liệu thì chương trình sẽ đọc chữ tiếp theo, quá trình đó sẽ lập lại cho đến khi đọc chữ tiếp theo mà dãy chữ đó không có trong từ điển thì sẽ dừng lại và lấy từ. Tức là chương trình sẽ duyệt một câu từ trái sang phải và chọn từ có nhiều âm tiết nhất có mặt trong từ điển và đánh dấu từ đó. Sau đó, tiếp tục quá trình trên với tất cả các từ kế tiếp cho đến hết câu.

Các đơn vị từ bao gồm các từ trong từ điển cũng như các chuỗi số, chuỗi ký tự từ nước ngoài, các dấu câu và các chuỗi kí tự hỗn tạp khác trong văn bản. Các đơn vị từ không chỉ bao gồm các từ có trong từ điển mà còn có thể là các từ mới hoặc các từ được sinh tự do theo một quy tắc nào đó (như phương thức thêm hậu tố hay phương thức láy) hoặc các chuỗi kí hiệu không được liệt kê trong từ điển.

## Kết quả

Kết quả phân tích sau khi áp dựng phương pháp so khớp cực đại, bằng cách chạy phần mềm Vntokenizer như sau: với file dữ liệu tên là 1.txt.

Giao diện màn hình khi chạy chương trình

Kết quả sau khi tách từ

Tính số lần xuất hiện của các từ

# KẾT LUẬN

Trong bài báo này chúng tôi giới thiệu các thuật toán tách từ trong xử lý ngôn ngữ tự nhiên dựa vào phương pháp so khớp cực đại, phương pháp mô hình MarKov ẩn, phương pháp chuyển dịch trạng thái hữu hạn có trọng số, phương pháp so khớp từ dài nhất. Kết quả mà chúng tôi thu được từ nghiên cứu này là hết sức khả quan và thiết nghĩ là hoàn toàn khả thi khi ứng dụng vào thực tế.

Trên cơ sở các phương pháp tách từ đó, bài báo này sử dụng phương pháp so khớp cực đại để minh họa cho các phương pháp tách từ trên. Phần mềm vntokenizer là phần mềm tách từ để biểu diễn cho thuật toán trên. Sau khi tách từ xong, tính tầng số xuất hiện các từ được tách trong tệp dữ liệu ban đầu. Đề xuất mô hình phân loại văn bản ứng dụng vào phân loại văn bản ở phòng ban, và thư viện trường Đại học Kiên Giang. Mặc dù kết quả nghiên cứu bước đầu đã khẳng định thuật toán tách từ dựa vào phương pháp so khớp cực đại là hoàn toàn khả thi và hoàn toàn có thể áp dụng vào thực tế, tuy nhiên Bài báo chỉ mới tách được các từ trong văn bản và tính được số lần xuất hiện của từ trong đoạn văn nhằm xây dựng vector đặc trưng từ đó hình thành ma trận để so sánh với từ khóa cho trước như: công nghệ thông tin, nông nghiệp,... từ đó làm cơ sở cho bài toán phân loại văn bản.

TÀI LIỆU THAM KHẢO

[1] Hồ Tú Bảo, Lương Chi Mai (2008), Về xử lý tiếng Việt trong công nghệ thông tin, Viện Công nghệ Thông tin, Viện Khoa học và Công nghệ tiên tiến Nhật Bản.

[2] Trần Thị Oanh, Mô hình tách từ, gán nhãn từ loại và hướng tiếp cận tích hợp cho tiếng Việt, Luận văn thạc sĩ trường Đại học Công nghệ, Đại học Quốc gia Hà Nội.

[3] Le An Ha (2003), A method for word segmentation in Vietnamese. In Proceedings of Curpus Linguistics. Lancaster, UK.

[4] Chih-Hao Tsai (2000). MMSEG: A word identification system for Mandarin Chinese text Based on two variants of the Maximum Matching Algorithm.

[5] Dinh Dien, Hoang Kiem, Nguyen Van Toan (2001), Vietnamese Word Segmentation, the sexth 6th Natural Language Processing Pacific Rim Symposium Tokyo, Japan, pp.749 – 756.

[6] Phil Blunsom (2004), Hidden Markov Medels, pp. 1-7

[7] Chen,K.J.,&Liu, S. H. (1992), Word identification for Mandarin Chinese sentences. Proceedings of the fifteenth inrernational Conference on computational Linguistics, Nantes.

# Public_125

Loài kiến là loài sâu bọ có tính chất xã hội, chúng sống thành từng đàn, bởi vậy có sự tác động lẫn nhau, chúng thạo tìm kiếm thức ăn và hoàn thành những nhiệm vụ từ kiến chỉ huy. Một điều thú vị trong tìm kiếm thức ăn của vài con kiến đặc biệt là khả năng của chúng để tìm kiếm đường đi ngắn nhất giữa tổ kiến và nguồn thức ăn. Trên thực tế, điều dễ nhận thấy có trong suy nghĩ nhưng nhiều con kiến hầu hết không nhận ra vì chúng không dùng thị giác để tìm kiếm những đầu mối thức ăn.

Tất cả mọi con kiến hầu như là mù, chúng chỉ có thể tương tác với nhau và với môi trường bằng cách sử dụng pheromone: đi đến đâu chúng xịt pheromone ra đến đấy. Mỗi một con kiến tại mỗi vị trí quyết định hướng đi tiếp theo dựa vào nồng độ pheromone của các hướng. Tại vị trí mà nồng độ pheromone xung quanh đều bằng nhau hoặc không có pheromone thì chúng sẽ quyết định hướng đi một cách ngẫu nhiên. Cứ như vậy thì các con kiến cứ đi theo bước chân của nhau và tạo thành một đường đi (path). Ta xét trường hợp tổ kiến ở vị trí 1 và nguồn thức ăn ở vị trí 2 như hình vẽ

![A diagram of a diamond AI-generated content may be incorrect.](images/image1.png)

Giả sử tại thời điểm ban đầu có 2 con kiến ra đi tìm thức ăn. Vì ban đầu chưa có pheromone nên chúng chọn 2 hướng đi khác nhau một cách ngẫu nhiên. Một hướng có đường đi đến nguồn thức ăn dài hơn hướng kia. Trong giai đoạn đầu các con kiến đi sau sẽ cảm nhận thấy nồng độ pheromone của cả 2 hướng là như nhau nên cũng chọn đi theo một trong 2 hướng một cách ngẫu nhiên. Tuy nhiên đường đi ngắn hơn làm cho khoảng thời gian di chuyển từ tổ đến nguồn thức ăn rồi quay trở lại của mỗi con kiến theo con đường đó cũng ngắn hơn và do đó mật độ di chuyển qua lại của đàn kiến tại mỗi vị trí của con đường ngắn sẽ cao hơn con đường dài. Do mật độ qua lại lớn hơn dẫn đến kết quả là nồng độ pheromone trên con đường ngắn càng ngày càng cao hơn con đường dài. Kết quả cuối cùng là đàn kiến ngày càng từ bỏ con đường dài và đi theo con dường ngắn. Đến một lúc nào đó sẽ không còn con kiến nào đi theo con đường dài nữa mà tất cả đều đi theo con đường ngắn.

![A group of hexagons with dots AI-generated content may be incorrect.](images/image2.png)

Thuật toán dựa trên hoạt động của đàn kiến có một số biến thể. Dạng đơn giản nhất gọi là AS (Ant System). Thuật toán này chỉ dùng để giải quyết bài toán tìm đường. Ở mức cao hơn là thuật toán ACO (Ant Colony Optimization).

# Từ những con kiến trong tự nhiên tới thuật toán ACO.

Thuật toán ACO lấy ý tưởng từ việc kiếm thức ăn của đàn kiến ngoài thực tế để giải quyết các bài toán tối ưu tổ hợp. Chúng dựa trên cơ sở một đàn kiến nhân tạo, chúng được tính toán tìm kiếm thức ăn nhờ mùi lạ nhân tạo.

Cấu trúc cơ bản của thuật toán ACO: trong mỗi thuật toán, tất cả kiến đi xây dựng cách giải quyết bài toán bằng cách xây dựng một đồ thị. Mỗi cạnh của đồ thị miêu tả các bước kiến có thể đi được kết hợp từ hai loại thông tin hướng dẫn kiến di chuyển:

Thông tin kinh nghiệm (heuristic information): giới hạn kinh nghiệm ưu tiên di chuyển từ nút r tới s…của cạnh ars. Nó được đánh dấu bởi rs. Thông tin này không được thay đổi bởi kiến trong suốt quá trình chạy thuật toán.

Thông tin mùi lạ nhân tạo (artificial pheromone trail information), nó giới hạn “nghiên cứu sự thèm muốn” của chuyển động là kiến nhân tạo và bắt chước mùi lạ thực tế của đàn kiến tự nhiên. Thông tin này bị thay đổi trong suốt quá trình thuật toán chạy phụ thuộc vào cách giải quyết được tìm thấy bởi những con kiến. Nó được đánh dấu bởi rs.

Giới thiệu các bước ảnh hưởng từ những con kiến thật vào ACO. Có hai vấn đề cần chú ý:

  * Chúng trừu tượng hoá vài mô hình thức ăn của kiến ngoài thực tế để tìm ra đường đi tìm kiếm thức ăn ngắn nhất.

  * Chúng bao gồm vài đặc điểm không giống với tự nhiên nhưng lại cho phép thuật toán phát triển chứa đựng cách giải quyết tốt tới bài toán bị cản (ví dụ: sử dụng thông tin kinh nghiệm để hướng dẫn chuyển động của kiến).


Cách thức hoạt động cơ bản của một thuật toán ACO như sau: m kiến nhân tạo di chuyến, đồng thời và không đồng bộ, qua các trạng thái liền kề của bài toán. Sự di chuyển này theo một tập quy tắc làm cơ sở từ những vùng thông tin có sẵn ở các thành phần (các nút). Vùng thông tin này bao gồm thông tin kinh nghiệm và thông tin mùi lạ để hướng dẫn tìm kiếm. Qua sự di chuyển trên đồ thị kiến xây dựng được cách giải quyết. Những con kiến sẽ giải phóng mùi lạ ở mỗi lần chúng đi qua một cạnh (kết nối) trong khi xây dựng cách giải quyết (cập nhật từng bước mùi lạ trực tuyến). Mỗi lần những con kiến sinh ra cách giải quyết, nó được đánh giá và nó có thể tạo luồng mùi lạ là hoạt động của chất lượng của cách giải quyết của kiến (cập nhật lại mùi lạ trực tuyến). Thông tin này sẽ hướng dẫn tìm kiếm cho những con kiến đi sau.

Hơn thế nữa, cách thức sinh hoạt động của thuật toán ACO bao gồm thêm hai thủ tục, sự bay hơi mùi lạ ( _pheromone trail evaporation_ ) và hoạt động lạ ( _daemon actions_ ). Sự bay hơi của mùi lạ được khởi sự từ môi trường và nó được sử dụng như là một kĩ thuật để tránh tìm kiếm bị dừng lại và cho phép kiến khảo sát vùng không gian mới. Daemon actions là những hoạt động tối ưu như một bản sao tự nhiên để thực hiện những nhiệm vụ từ một mục tiêu xa tới vùng của kiến.

# Giới thiệu về thuật toán 

Các thuật toán kiến là các thuật toán dựa vào sự quan sát các bầy kiến thực. Kiến là loại cá thể sống bầy đàn. Chúng giao tiếp với nhau thông qua mùi mà chúng để lại trên hành trình mà chúng đi qua. Mỗi kiến khi đi qua một đoạn đường sẽ để lại trên đoạn đó một chất mà chúng ta gọi là mùi. Số lượng mùi sẽ tăng lên khi có nhiều kiến cùng đi qua. Các con kiến khác sẽ tìm đường dựa vào mật độ mùi trên đường, mật độ mùi càng lớn thì chúng càng có xu hướng chọn. Dựa vào hành vi tìm kiếm này mà đàn kíên tìm được đường đi ngắn nhất từ tổ đến nguồn thức ăn và sau đó quay trở tổ của mình.

Sau đây là ví dụ về luồng đi của đàn kiến thực tế.

![A diagram of a obstacle course AI-generated content may be incorrect.](images/image3.png)

**Hình 1**

  1. Kiến đi theo đường thẳng giữa A và E

  2. Khi có chướng ngại vật kiến sẽ chọn hướng đi, có hai hướng với khả năng kiến sẽ chọn là như nhau.

  3. Trên đường ngắn hơn thì nhiều mùi (pheromone) hơn


![A diagram of a hexagon with numbers and arrows AI-generated content may be incorrect.](images/image4.png)

**Hình 2**

Xem hình 2a là giải thích rõ tình huống trong hình 1b.

Giả sử khoảng cách DH=BH=DB qua C và =1, C là điểm nằm giữa B và D (hình 2a). Bây giờ chúng ta xem xét điều gì xảy ra tại những khoảng thời gian rời rạc: t=0, 1, 2… Giả định rằng 30 con kiến mới đi từ A đến B, 30 con từ E đến D, mỗi kiến di chuyển với tốc độ một đơn vị thời gian và khi di chuyển kiến để tại thời điểm t một vệt pheromone với nồng độ là 1\. Để đơn giản chúng ta xét lượng pheromone bay hơi hoàn toàn và liên tục trong khoảng thời gian (t+1, t+2).

Tại thời điểm t=0, thì không có vệt mùi nào trên cạnh và có 30 kiến ở B, 30 ở D. Việc lựa chọn đường đi của chúng ta ngẫu nhiên do đó, trung bình từ mỗi nút có 15 con kiến sẽ đi đến H và 15 con sẽ đi đến C (hình 2b)

Tại thời điểm t=1, 30 con kiến mới đi từ A đến B, lúc này nó sẽ chọn hướng đến C hoặc hướng đến H. Tại hướng đến H có vệt mùi 15 do 15 con kiến đi từ B đến H, tại hướng đến C có vệt mùi 30 do 15 kiến đi từ B đến D và 15 con đi từ D đến B thông qua C (hình 2c). Do đó khả năng kiến hướng đến chọn đường đến C, do đó số kiến mong muốn đi đến C sẽ gấp đôi số kiến đi đến H (20 con đến C và 10 con đến H). Tương tự như vậy cho 30 con kiến mới đi từ D đến B.

Quá trình sẽ liên tục cho đến khi tất cả kiến sẽ chọn đường đi ngắn nhất.

Trên đây chúng ta mô tả hành vi tìm kiếm của bầy kiến thực.Sau đây , chúng ta sẽ tìm hiểu sâu hơn về các thuật toán kiến.

Thuật toán tối ưu bầy kiến (ACO) nghiên cứu các hệ thống nhân tạo dựa vào hành vi tìm kiếm của bầy kiến thực và được sử dụng để giải quyết các vấn đề về tối ưu rời rạc.Thuật toán bầy kiến siêu tìm kiếm(ACO meta_heuristic) lần đầu tiên được Dorigo, Di Caro và Gambardella đề xuất vào năm 1999.

Metaheuristic là một tập các khái niệm về thuật toán được sử dụng để xác định các phương thức tìm kiếm thích hợp cho một tập các vấn đề khác nhau. Hay nói cách khác, một siêu tìm kiếm ( meta-heuristic) có thể coi là một phương thức tìm kiếm đa năng.

ACO là một meta-heuristic, trong đó một tập các con kiến nhân tạo phối hợp tìm kiếm các giải pháp tốt cho các vấn đề về tối ưu rời rạc. Sự phối hợp là yếu tố cối lõi của các thuật toán ACO. Các con kiến nhân tạo liên lạc với nhau thông qua trung gian mà ta thường gọi là mùi.

Các thuật toán ACO được sử dụng để giải quyết các vấn đề về tối ưu tổ hợp tĩnh và động. Các vấn đề tĩnh là các vấn đề mà ở đó các đặc tính của vấn đề là không thay đổi trong suốt quá trình giải quyết vấn đề. Còn các vấn đề động thì ngược lại là một hàm các tham số mà giá trị của nó là động hay thay đổi trong quá trình giải quyết vấn đề, ví dụ bài toán người đưa thư là một vấn đề dynamic problem

Hệ thống ACO lần đầu tiên được Marco Dorigo giới thiệu trong luận văn của mình vào năm 1992, và được gọi là Hệ thống kiến (Ant System, hay AS). AS là kết quả của việc nghiên cứu trên hướng tiếp cận trí tuệ máy tính nhằm tối ưu tổ hợp mà Dorigo được hướng dẫn ở Politecnico di milano với sự hợp tác của Alberto Colorni và Vittorio Maniezzo. AS ban đầu được áp dụng cho bài toán người du lịch (TSP) và QAP

Cũng vào năm 1992, tại hội nghị sự sống nhân tạo lần đầu tiên ở châu Âu, Dorigo và các cộng sự đã công bố bài: sự tối ưu được phân bố bởi đàn kiến.

Tiếp theo tại hội nghị quốc tế thứ hai về giải quyết các vấn đề song song trong tự nhiên ở Hà Lan (1992), ông và các cộng sự đã công bố bài: nghiên cứu về các đặc tính của một giải thuật kiến.

Kể từ năm 1995 Dorigo, Gambardella và Stützle đã phát triển các sơ đồ AS khác nhau. Dorigo và Gambardella đã đề xuất Hệ thống bầy kiến (Ant Colony System, hay ACS) trong khi Stützle and Hoos đề xuất MAX-MIN Ant System (MMAS). Tất cả đều áp dụng cho bài toán người du lịch đối xứng hay không đối xứng và cho kết quả mỹ mãn. Dorigo, Gambardella and Stützle cũng đề xuất những phiên bản lai của ACO với tìm kiếm địa phưong.

Vào năm 1995, L.M. Gambardella và M. Dorigo đã đề xuất hệ thống Ant-Q, là một cách tiếp cận học tăng cường cho cho bài toán TSP.Và nó được áp dụng trong Học Máy.

Tiếp đó, vào năm 1996, trong bài báo công nghệ của mình tại Bruxelles M. Dorigo và L.M. Gambardella đã công bố hệ thống Ant Conoly System. Đây là hệ thống đề cập đến cách học phối hợp áp dụng cho bài toán TSP.

Cũng trong năm 1996 này, T. Stützle và H. H. Hoos đã đề xuất hệt thống Max-Min Ant System **.** Đây là một hệ thống cải tiến hệ thống AntSystem ban đầu và được đánh giá là hệ thống tính toán trong tương lai.

Sau đó, vào năm 1997, G. Di Caro và M. Dorigo đã đề xuất hệ thống AntNet. Đây là cách tiếp cận về định hướng sự thích nghi. Và phiên bản cuối cùng của hệ thống AntNet về điều khiển mạng truyền thông đã được công bố vào năm 1998.

Cũng trong năm 1997, hệ thống Rank-based Ant System, một hệ thống cải tiến hệ thống kiến ban đầu về nghiên cứu hệ thống tính toán đã được đề xuất bởi B. Bullnheimer, R. F. Hartl và C. Strauss. Phiên bản cuối cùng của hệ thống này được công bố vào năm 1999.

Vào năm 2001, C. Blum, A. Roli, và M. Dorigo đã cho công bố về hệ thống kiến mới là Hyper Cube – ACO. Phiên bản mở rộng tiếp đó đã được công bố vào năm 2004.

Hầu hết các nghiên cứu gần đây về ACO tập trung vào việc phát triển các thuật toán biến thể để làm tăng hiệu năng tính toán của thuật toán Ant System ban đầu.

Trên đây là sơ lược chung về các thuật toán kiến, mục tiếp theo sẽ mô tả về sơ đồ chung của thuật toán kiến.

# Sơ đồ chung thuật toán đàn kiến

**Procedure** ACO

**Initial();**

**While** (!ĐK dừng) do

ConstructSolutions();

LocalSearch(); **/*** Tuỳ ý, có thể có hoặc không

UpdateTrails();

**End** ;

**End** ;

trong đó:

ĐK dừng (tức là điều kiện dừng) là điều kiện đạt được khi thuật toán ở trạng thái kết thúc. Với bài toán người đưa thư thì ĐK dừng là điều kiện đạt được khi số vòng lặp của thuật toán = số vòng lặp lớn nhất do người dùng tự định nghĩa hoặc là tất cả đàn kiến đều đi theo một đường (tức là đường đi ngắn nhất).

ConstrucSolutions() là hàm xây dựng một giải pháp có thể theo phương pháp siêu tìm kiếm(meta-heuristic), với bài toán người đưa thư thì đó là hàm xây dựng chu trình cho mỗi kiến .

UpdateTrails() là hàm cập nhật mùi cho hành trình mà kiến đã đi qua.

LocalSearch() là hàm tìm kiếm địa phương, giúp tìm ra tối ưu cục bộ.

![A diagram of a flowchart AI-generated content may be incorrect.](images/image5.png)

**Hình 3**. Sơ đồ chung của thuật toán bầy kiến

# Các bước giải quyết bài toán đàn kiến

Từ thuật toán trên ta có thể rút ra các bước giải quyết một bài toán ứng dụng với thuật toán đàn kiến:

Bước 1: Thể hiện bài toán trong khung của tập các thành phần và sự chuyển đổi hoặc bởi một đồ thị được đánh dấu bởi kiến đề xây dựng cách giải quyết.

Bước 2: Định nghĩa thích hợp cho mùi lạ rs là một xu hướng quyết định. Đó là một bước chủ yếu trong việc hình thanhg thuật toán ACO và xác định rõ mùi lạ không là một nhiệm vụ tầm thường và nó tính toán yêu cầu bên trong của bài toán sau đáp án.

Bước 3: Định nghĩa thích hợp kinh nghiệm cho mỗi quyết định để một con kiến có thể xây dựng cách giải quyết, ví dụ: định nghĩa thông tin kinh nghiệm rs kết hợp mỗi thành phần hoặc trạng thái chuyển đổi. Thông tin kinh nghiệm chủ yếu cho việc tìm kiếm tốt nếu thuật toán tìm kiếm vùng không có sẵn hoặc không thể ứng dụng.

Bước 4: Nếu thực hiện được, tạo ra một vùng thuật toán tìm kiếm hiệu quả cho bài toán sau đáp án bởi vì kết quả của nhiều ứng dụng ACO cho bài toán tổ hợp tối ưu NP-hard thể hiện qua sự tìm kiếm tốt nhất đạt được khi ACO có vùng lạc quan.

Bước 5: Lựa chọn một thuật toán ACO và ứng dụng nó vào những bài toán cần giải quyết.

Bước 6: Các tham số phù hợp của thuật toán ACO. Một điểm bắt đầu tốt cho tham số phù hợp là sử dụng cài đặt tham số để tìm kiếm tốt khi ứng dụng thuật toán ACO vào bài toán đơn giản hoặc các bài toán khác nhau. Một vấn đề khác chi phối thời gian trong nhiệm phù hợp là để sử dụng thủ tục động cho tham số phù hợp.

Nó nên xoá các bước tiếp có thể chỉ đưa ra một hướng dẫn sử dụng thuật toán ACO. Thêm nữa, việc sử dụng là sự kết hợp các quá trình ở đó với vài bài toán sâu hơn và hoạt động của thuật toán, vài lựa chọn ban đầu cần phải sửa lại. Cuối cùng, chúng ta muốn trên thực tế, điều quan trọng nhất của các bước là đầu tiên phải khớp bởi vì lựa chọn tồi ở trạng thái này tính không thể tính với một tham số gốc phù hợp tốt.

# Các sơ đồ thuật toán khác phát triển trên mô hình ACO

Nhiều thuật toán đã được đưa ra dựa trên mô hình thuật toán **metaheuristic ACO**. Trong các mô hình đưa ra để giải quyết các bài toán tổ hợp tối ưu **NP-khó** sau đây xin trình bày chi tiết về 5 mô hình. Các mô hình này là phát triển dựa trên mô hình thuật toán ACO cụ thể trình bày ở phần trên. Theo các nghiên cứu cho thấy khi sử dụng thuật toán bầy kiến nói chung các thông tin pheromone và heuristic có thể áp dụng cho các nút hoặc cạnh nối. Trong các thuật toán đưa ra sau đây thì thông tin pheromone và heuristic chỉ gắn với các cạnh mà thôi.

## Thuật toán Ant System (AS)

Được phát triển bởi Dorigo, Maniezzo và Colorni năm 1991, là thuật toán ACO đầu tiên. Ban đầu có 3 biến thể khác nhau là: AS-Density, AS-Quantity và AS-Cycle khác nhau bởi cách thức cập nhật thông tin Pheromone.

Trong đó:

  * AS-Density: Thì đàn kiến sẽ đặt thêm pheromone trong quá trình xây dựng lời giải (online step-by-step pheromone update), lượng pheromone để cập nhật là một hằng số.

  * AS-Quantity: Thì đàn kiến sẽ đặt thêm pheromone trong quá trình xây dựng lời giải (online step-by-step pheromone update), lượng pheromone để cập nhật là phụ thuộc vào độ mong muốn (thông tin heuristic) với đoạn đường đi qua ηij.

  * AS-Cycle: Thông tin pheromone sẽ được cập nhật khi lời giải đã hoàn thành (online delayed pheromone update). Đây là mô hình cho kết quả tốt nhất và được coi như là thuật toán AS.


❖ _**Quy tắc di chuyển của kiến**_

Trong thuật toán AS, kiến xây dựng một đường đi bắt đầu tại một đỉnh được chọn ngẫu nhiên.

Tại đỉnh i, một con kiến k sẽ chọn đỉnh j chưa được đi qua trong tập láng giềng của i theo công thức sau:

![A mathematical equation with a square root AI-generated content may be incorrect.](images/image6.png)

Trong đó:

![A white background with black text AI-generated content may be incorrect.](images/image7.png)

Sự lựa chọn của con khi quyết định đi từ đỉnh i qua đỉnh j và được tính theo công thức:

![A white background with black text AI-generated content may be incorrect.](images/image8.png)

❖ _**Quy tắc cập nhật thông tin mùi**_

Trong quá trình di chuyển tìm đường đi của đàn kiến, chúng thực hiện cập nhật thông tin mùi trên những đoạn đường mà chúng đã đi qua. Gắn với mỗi cạnh (i,j) nồng độ vết mùi ij và thông số heuristic ij trên cạnh đó.

Ban đầu nồng độ mùi trên mỗi cạnh (i,j) được khởi tạo một hằng số c, hoặc được xác định theo công thức:

![A math equations on a white background AI-generated content may be incorrect.](images/image9.png)

Việc cập nhập pherpmone được tiến hành như sau:

  * Đầu tiên tất cả pheromone trên các cung sẽ được giảm đi bởi một lượng:


![](images/image10.png)

Với _p_ trong khoảng (0,1) là tốc độ bay hơi của pheromone.

  * Tiếp theo mỗi con kiến trong đàn sẽ đặt thêm một lượng thông tin pheromone trên những cung mà chúng đã đi qua trong hành trình của chúng.


![A group of black letters AI-generated content may be incorrect.](images/image11.png)

Trong đó: deta ij là lượng pheromone mà con kiến k đặt lên cạnh mà nó đã đi qua và được tính như sau:

![A close up of black text AI-generated content may be incorrect.](images/image12.png)

Với: Ck là độ dài đường đi của con kiến thứ k sau khi hoàn thành đường đi, tức là bằng tổng các cung thuộc đường đi mà kiến đã đi qua.

## Thuật toán Ant Colony System (ACS)

Phát triển từ thuật toán AS

_**❖ Quy tắc di chuyển của kiến**_

Trong thuật toán ACS, con kiến k đang ở đỉnh i, việc kiến chọn đỉnh j để di chuyển đến được xác định bằng quy luật như sau:

  * Cho qo là một hằng số cho trước (0<q0<1)

  * Chọn ngẫu nhiên một giá trị q trong khoảng [0,1]

  * Nếu q<q0 kiến k chọn điểm j di chuyển tiếp theo dựa trên giá trị lớn nhất của thông tin mùi và thông tin heuristic có trên cạnh tương ứng với công thức:


![](images/image13.png)

  * Nếu q>q0 kiến k sẽ chọn đỉnh j chưa được đi qua trong tập láng giềng của I theo một quy luật phân bổ xác xuất được xác định theo công thức sau:


![A black math equation AI-generated content may be incorrect.](images/image14.png)

_**❖ Quy tắc cập nhật thông tin mùi**_

Cập nhật thông tin mùi toàn cục:

Một con kiến có đường đi tốt nhất sau mỗi lần lặp thì được phép cập nhật thông tin pheromone. Việc cập nhật được thực hiện theo công thức sau:

![](images/image15.png)

Cập nhật thông tin mùi cục bộ:

Công thức sau:

![A black text on a white background AI-generated content may be incorrect.](images/image16.png)

Với _p_ : là tham số bay hơi năm trong khoảng (0,1)

0 =1/(nCnm)

n: là số dỉnh hay là số thành phố

Cnm: chiều dài hành trình cho bởi phương pháp tìm kiếm gần nhát

## Thuật toán Max–Min Ant System (MMAS)

Được phát triển bởi Stutzle và Hooss vào năm 1996, được mở rộng lên từ hệ thống AS. Luật di chuyển của kiến được thực hiện tương tự như trong thuật toán ACS

_**❖ Quy tắc cập nhật thông tin mùi**_

Thuật toán MMAS thực hiện việc cập nhật thông tin mùi khi toàn bộ kiến trong đàn hoàn thành lời giải và lượng thông tin mùi chỉ cập nhật trên các cạnh thuộc lời giải tối ưu nhất. Ban đầu cũng thực hiện bay hơi thông tin mùi trên các cạnh thuộc lơi giải tối ưu với một lượng được xác định tại công thức (2.4).

Lượng pheromone trên một cạnh được xác định như sau:

![A group of black letters AI-generated content may be incorrect.](images/image17.png)

Cbest là độ dài đường đi ngắn nhất của con kiến thứ k sau khi cả đàn hoàn thành đường đi.

_**❖ Khởi tạo và khởi tạo lại thông tin mùi**_

Thuật toán MMAS đã thêm vào giá trị cận trên và giá trị cận dưới cho thông tin pheromone gọi là _τ_ min và _τ_ max

Sau mỗi lần cập nhật giá trị thông tin mùi _τ_ ij nếu _τ_ ij < _τ_ min thì sẽ gán _τ_ ij = _τ_ min và nếu _τ_ ij > _τ_ max thì gán _τ_ ij = _τ_ max

Giá trị cận trên _τ_ max thường được thiết lập với công thức sau:

_τ max_ = $1ρCbestfrac{1}{rho C_{best}}$

Giá trị cận dưới _τ_ min được xác định bằng công thức:

_τ_ min = _τ_ max /2n.

## Thuật toán Rank-Based Ant System (RBAS)

Đây cũng là một thuật toán được mở rộng phát triển từ hệ thống AS đưa ra bởi Bullnheimer, Hartl và Strauss vào năm 1997. Thuật toán này đưa vào ý tưởng xếp hạng cho các lời giải khi thực hiện cập nhật pheromone. Cụ thể như sau:

  * Đầu tiên, m con kiến được xếp hạng theo thứ tự giảm dần dựa theo chất lượng lời giải mà nó thu được. Ví dụ: (S1, S2, … Sm-1, Sm) trong đó S1 là phương án tốt nhất.

  * Pheromone chỉ được đặt thêm trên các cung của б -1 con kiến có lời giải tốt nhất. Lượng pheromone cũng phụ thuộc trực tiếp vào thứ hạng sắp xếp của con kiến.

  * Các đoạn đường đi của lời giải tốt nhất được nhận thêm một lượng pheromone phụ thuộc vào chất lượng lời giải.


Các công thức như sau:

![](images/image18.wmf)

Trong đó ![](images/image19.wmf)

Và

![](images/image20.wmf)

Tóm tắt thủ tục cập nhật pheromone của thuật toán này:

1 **Procedure** daemon_actions

2 **for each** ![](images/image21.wmf) **do** local_search (![](images/image21.wmf)) {optional}

3 rank ![](images/image22.wmf) in decreasing order of solution

quality into ![](images/image23.wmf)

4 **if** (best (![](images/image24.wmf),![](images/image25.wmf)))

5 ![](images/image25.wmf) = ![](images/image24.wmf)

6 **end if**

7 **for** ![](images/image26.wmf) to ![](images/image27.wmf) **do**

8 **for** each edge ![](images/image28.wmf)![](images/image29.wmf) ![](images/image30.wmf) **do**

9 ![](images/image31.wmf)

10 **end for**

11 **end for**

12 **for** each edge ![](images/image32.wmf) ![](images/image33.wmf) ![](images/image25.wmf) **do**

13 ![](images/image34.wmf)

14 **end for**

15 **end Procedure**

## Thuật toán Best-Worst Ant System(BWAS)

Thuật toán được đưa ra bởi Cordon vào năm 1999. Thuật toán này bao gồm một thuật toán mở rộng khác của AS là MMAS (về luật di chuyển và việc bay hơi của pheromone). Bên cạnh đó trong thuật toán này còn quan tâm tới của việc tối ưu cục bộ một cách hệ thống để nâng cao chất lượng lời giải của con kiến. Trong thuật toán BWAS có 3 **daemon action** thêm vào gồm có:

  * Đầu tiên, áp dụng luật có tên _best-worst pheromone update_ để tăng cường pheromone trên các đoạn đường đi qua bởi lời giải tốt nhất toàn cục (global best solution). Thêm vào đó luật này sẽ phạt những cạnh của lời giải tồi nhất trong lần lặp Scurrent-worst.

  * Áp dụng _Pheromone trail mutation_ để đi theo các hướng khác nhau trong quá trình tìm kiếm.

  * BWAS có cơ chế khởi tạo lại thông tin pheromone khi thuật toán bị đình trệ, bằng cách thiết lập pheromone trail cho tất cả các thành phần bằng ![](images/image35.png).


Mô hình thủ tục **Daemon action** của thuật toán BWAS như sau:

1 **Procedure** daemon_actions

2 **for each** ![](images/image21.wmf) **do** local_search (![](images/image21.wmf))

3 ![](images/image36.wmf)best_solution (![](images/image21.wmf))

4 **if** (best (![](images/image37.wmf),![](images/image25.wmf)))

5 ![](images/image25.wmf) =![](images/image37.wmf)

6 **end if**

7 **for** each edge ![](images/image38.wmf)![](images/image29.wmf) ![](images/image25.wmf) **do**

8 ![](images/image39.wmf)

9 ![](images/image40.wmf)

10 **end for**

11 ![](images/image41.wmf)

12 ![](images/image42.wmf)

13 **for** each edge ![](images/image43.wmf) ![](images/image44.wmf)and ![](images/image45.wmf) ![](images/image46.wmf) **do**

14 ![](images/image47.wmf)

15 **end for**

16 ![](images/image48.wmf)

17 **for** each nút / component ![](images/image49.wmf) **do**

18 z = generate_random_value_in_[0,1]

19 **if** (![](images/image50.wmf))

20 s = generate_random_value_in_[1,…, 1]

21 a = generate_random_value_in_[0,1]

22 if ![](images/image51.wmf)

23 else ![](images/image52.wmf)

24 **end if**

25 **end for**

26 **if** (stagnation_condition)

27 **for** each ![](images/image53.wmf) **do** ![](images/image54.wmf)

28 **end if**

29 **end Procedure**

Mục này chỉ đưa ra 5 mô hình thuật toán ACO phát triển từ hệ thống Ant System. Nhưng đó chỉ là một số các dạng tiêu biểu của thuật toán ACO, còn tồn tại rất nhiều các biến thể khác. Và trong đồ án sẽ áp dụng thuật toán theo mô hình hệ thống MMAS để giải bài toán CPMP. Mô hình thuật toán MMAS là một trong các thuật toán hiệu quả nhất của các thuật toán bầy kiến.

# Thuật toán đàn kiến song song

Từ sơ đồ giải thuật ta nhận thấy các cá thể kiến trong giải thuật là rất độc lập với nhau và vì vậy ý tưởng song song đơn giản và hiệu quả nhất là phân chia kiến ra các bộ xử lý khác nhau , các bộ xử lý mạnh có thể nhận nhiều kiến, các bộ xử lý yếu hơn sẽ nhận ít kiến hơn. Việc phân chia như vậy sẽ làm tăng hiệu suất của giải thuật,tuy nhiên khi tới bước cập nhập ma trận mùi các bộ xử lý cần phải trao đổi dữ liệu với nhau, tùy vào thông tin được trao đổi và mô hình các bộ xử lý mà ta có các kiểu thuật toán song song khác nhau và các tham số khác nhau cho giải thuật.

**All-to-all topology** :Các cụm kiến gửi thông tin tới tất cả các cụm kiến khác

**(Directed or undirected) ring topology** : trong mô hình directed ring colony cụm kiến (z +1 mod _**p )**_ \+ 1 là hàng xóm của cụm _**i**_ cho tất cả các cụm kiến và trong mô hình undirected ring colony cụm kiến _**(i**_ \- 1 mod _**p )**_ \+ 1 là hàng xóm của cụm kiến

_**i**_ cho tất cả các cụm kiến.

**Hypercube topology** : Mô hình này yêu cầu có _**p**_ = _**2^k**_ cụm kiến và mỗi cụm kiến I là hàng xóm với cụm kiến j nếu và chỉ nếu kiểu biểu diễn nhị phân của i và j chỉ khác nhau 1 bit. Vì vậy mỗi cụm kiến chỉ có k hàng xóm.

**Random topology** :Trong mô hình này các hàng xóm của mỗi cụm kiến được đinh nghĩa một cách ngẫu nhiên trong mỗi bước trao đổi thông tin .Có nhiều phương thức xác định hàng xóm ngẫu nhiên trong trường hợp này

Cũng có thể phân biệt các giải thuật với nhau bằng loại thông tin gửi nhận qua mỗi bước lặp.

**Lời giải** : Trong chiến thuật này các lời giải tố đã tìm ra sẽ được gửi đi tới các cụm kiến khác .có nhiều kiểu lời giải có thể được gửi đi

**Kiến** : Lời giải của một con kiến từ lần lặp này được gửi tới cụm kiến khác, thông thường đây là lời giải của con kiến tốt nhất

**Lời giải toàn cục tốt nhất**. Lời giải tốt nhất của các cụm kiến được gửi đi cho tất cả các cụm kiến

**Lời giải của hàng xóm tốt nhất** . Lời giải tốt nhất của các cụm kiến được gửi tới các hàng xóm

**Lời giải cục bộ tốt nhất**. Lời giải cục bộ tốt nhất được gửi đi tới các hàng xóm

**Vector mùi** . Thay vì gửi lời giải thì vector mùi sẽ được gửi sau mỗi buớc lặp.

# Public_126

Cũng như các khoa học khác, vật lý là khoa học dựa trên các quan sát thực nghiệm và các phép đo định lượng. Mục tiêu chính của vật lý là xác định số lượng có hạn các định luật cơ bản chi phối các hiện tượng trong tự nhiên và sử dụng chúng để phát triển các lý thuyết có thể dự đoán được kết quả của các thí nghiệm trong tương lai.

Các định luật cơ bản này được diễn đạt bằng ngôn ngữ toán học, một công cụ để để gắn kết lý thuyết với thực nghiệm.

Mỗi khi có sự không nhất quán giữa tiên đoán của lý thuyết và kết quả thực nghiệm thì cần phải đưa ra một lý thuyết mới hoặc chỉnh sửa lý thuyết đã có để loại bỏ sự không nhất quán đó. Nếu một lý thuyết chỉ được thỏa mãn trong những điều kiện nhất định thì một lý thuyết tổng quát hơn sẽ có thể thỏa mãn được mà không cần các điều kiện này. Ví dụ như các định luật chuyển động được Newton (1642-1727) khám phá mô tả chính xác chuyển động của các vật có tốc độ bình thường nhưng lại không áp dụng được cho các vật chuyển động với tốc độ tương đương với tốc độ ánh sáng. Ngược lại, thuyết tương đối hẹp của Einstein (1879-1955) cho các kết quả giống với các định luật Newton đối với tốc độ nhỏ nhưng cũng mô tả chính xác chuyển động của các vật có tốc độ gần bằng tốc độ ánh sáng. Do đó, thuyết tương đối hẹp của Einstein là một thuyết về chuyển động tổng quát hơn so với thuyết được xây dựng từ các định luật Newton.

Vật lý học cổ điển bao gồm các nguyên lý của _**cơ học cổ điển**_ , _**nhiệt động lực học**_ , _**quang học**_ và _**điện từ học**_ đã được phát triển trước năm 1900. Newton là người đã có những đóng góp quan trọng cho vật lý học cổ điển, ông cũng là một trong những người khai sinh ra phép tính vi tích phân như là một công cụ toán học. Các phát triển chủ yếu của cơ học được tiếp diễn trong thế kỷ 18, nhưng ngành nhiệt động lực học và điện từ thì phải đến nửa sau của thế kỷ 19 mới được phát triển. Nguyên nhân chủ yếu là do các thiết bị thí nghiệm thời đó quá thô sơ hoặc thiếu thốn.

Cuộc cách mạng lớn của vật lý, có liên quan với vật lý hiện đại, bắt đầu vào gần cuối thế kỷ 19. Vật lý hiện đại được phát triển là do vật lý cổ điển không thể giải thích được nhiều hiện tượng vật lý. Hai sự phát triển quan trọng nhất trong kỷ nguyên hiện đại là _**thuyết tương đối**_ và _**cơ học lượng tử**_. Thuyết tương đối hẹp của Einstein không những chỉ mô tả chính xác chuyển động của các vật có tốc độ tươndg đương với tốc độ ánh sáng mà còn hiệu chỉnh một cách trọn vẹn các khái niệm truyền thống về không gian, thời gian và năng lượng. Lý thuyết này còn chỉ ra rằng tốc độ ánh sáng là giới hạn trên của tốc độ của một vật và khối lượng và năng lượng có liên hệ với nhau. Cơ học lượng tử được hình thành bởi nhiều nhà khoa học khác nhau, mô tả các hiện tượng vật lý ở cấp độ nguyên tử. Nhiều thiết bị thực tiễn đã được chế tạo dựa vào các nguyên lý của cơ học lượng tử.

Các nhà khoa học làm việc không ngừng để cải thiện hiểu biết của chúng ta về các định luật cơ bản. Nhiều tiến bộ về công nghệ trong hiện tại như tàu vũ trụ không người lái, hàng loạt ứng dụng tiềm năng trong công nghệ na nô, vi mạch và máy tính siêu tốc, kỹ thuật chụp

ảnh tinh xảo dùng trong nghiên cứu khoa học và y khoa cũng như nhiều kết quả đáng kể trong kỹ thuật gien là kết quả của những nỗ lực của nhiều nhà khoa học, kỹ sư, nhà kỹ thuật. Ảnh hưởng của những phát triển và khám phá này đến xã hội của chúng ta quả thực là to lớn và chắc chắn là các khám phá và phát triển trong tương lai cũng sẽ đầy hứng thú, thách thức và mang lại nhiều lợi ích cho nhân loại.

## ![](images/image2.png) Các chuẩn độ dài, khối lượng và thời gian

Để mô tả các hiện tượng vật lý, ta cần phải đo lường nhiều khía cạnh khác nhau của tự nhiên. Mỗi phép đo tương ứng với một đại lượng vật lý, ví dụ như chiều dài của một vật. Các định luật vật lý được diễn đạt như là các mối quan hệ toán học giữa các đại lượng vật lý.

Trong cơ học, ba đại lượng cơ bản nhất là chiều dài, khối lượng và thời gian. Mọi đại lượng khác trong cơ học có thể được biểu diễn thông qua ba đại lượng này.

Do các quốc gia khác nhau sử dụng các chuẩn khác nhau nên cần phải có chuẩn chung cho các đại lượng. Cái được chọn làm chuẩn phải:

  * có sẵn;

  * có một vài thuộc tính có thể đo lường được một cách tin cậy;

  * phải cho cùng một kết quả khi đo bởi bất kỳ ai và bất kỳ nơi nào;

  * không thay đổi theo thời gian.


Vào năm 1960, một ủy ban quốc tế đã đưa ra một bộ các chuẩn cho các đại lượng cơ bản của khoa học. Nó được gọi là SI (Système International d’unités – Hệ đơn vị quốc tế). Bảng dưới đây là các đại lượng cơ bản nhất và đơn vị tương ứng.


| Đại lượng | Đơn vị trong SI |
| --- | --- |
| độ dài | mét (m), |
| khối lượng | ki-lô-gam (kg) |
| thời gian | giây (s). |
| nhiệt độ | Kelvin (K) |
| cường độ dòng điện | Ampère (A) |
| cường độ sáng | Candela – Cd |
| lượng chất | mole (mol) |

 

Các đại lượng cơ bản dùng trong cơ học là chiều dài, khối lượng và thời gian. Các đại lượng còn lại được biểu diễn qua các đại lượng này.

### Chiều dài

Chiều dài được xác định bằng khoảng cách giữa hai điểm trong không gian.

Năm 1799, khi mét được chọn làm đơn vị đo hợp pháp của chiều dài tại Pháp, thì mét được định nghĩa bằng 1/10.000.000 chiều dài của đoạn kinh tuyến đi qua Paris, tính từ xích đạo lên cực bắc của Trái đất. Cần lưu ý rằng giá trị này không thỏa mãn yêu cầu là có thể sử dụng trong toàn vũ trụ.

Năm 1960, mét được định nghĩa là khoảng cách giữa hai vạch trên một thanh platinum– iridium đặc biệt được lưu trữ tại Pháp trong điều kiện kiểm soát được.

Trong những năm 1960 và 1970, mét được định nghĩa bằng 1.650.763,73 lần bước sóng

λ của ánh sáng đỏ - cam phát ra từ đèn khí kripton-86.

Năm 1983, _**mét được định nghĩa là quãng đường mà ánh sáng đi được trong chân không trong khoảng thời gian 1/299.792.458 s**_. Trong thực tế, định nghĩa này thiết lập tốc độ ánh sáng trong chân không chính xác bằng 299.792.458 m/s. Định nghĩa này là hợp lệ trong toàn vũ trụ và dựa trên giả thiết rằng ánh sáng là như nhau ở khắp mọi nơi. Bảng

1.1Bảng liệt kê các giá trị ước lượng của một số chiều dài đã đo đạc được.

_Bảng 1.1: Ước lượng giá trị số đo của một vài độ dài (m)_


|  | Độ dài (m) |
| --- | --- |
| Khoảng cách từ Trái đất đến chuẩn tinh xa nhất được biết đến | 1,4× 1026 |
| Khoảng cách từ Trái đất đến thiên hà xa nhất | 9 × 1025 |
| Khoảng cách từ Trái đất đến thiên hà lớn gần nhất (Andromeda) | 2 × 1022 |
| Khoảng cách từ Mặt trời đến ngôi sao gần nhất (Proxima Centauri) | 4 × 1016 |
| Một năm ánh sáng | 9,46 × 1015 |
| Bán kính quĩ đạo trung bình của Trái đất quanh Mặt trời | 1,50 × 1011 |
| Khoảng cách trung bình từ Trái đất đến Mặt trăng | 3,84 × 108 |
| Khoảng cách từ xích đạo đến Bắc cực | 1,00 × 107 |
| Bán kính trung bình của Trái đất | 6,37 × 106 |
| Độ cao điển hình (tính từ bề mặt) của vệ tinh bay quanh Trái đất | 2 × 105 |
| Chiều dài của một sân bóng đá | 9,1 × 101 |
| Chiều dài của một con ruồi nhà | 5 × 10−3 |
| Kích thước của các hạt bụi nhỏ nhất | ~ 10−4 |
| Kích thước của tế bào trong hầu hết các cơ quan sống | ~ 10−5 |
| Đường kính của nguyên tử hidro | ~ 10−10 |
| Đường kính của hạt nhân nguyên tử | ~ 10−14 |
| Đường kính của một proton | ~ 10−15 |

 

### Khối lượng

Đơn vị của khối lượng trong SI là ki-lô-gram (kg), được định nghĩa là khối lượng của một khối platinum–iridium hình trụ đặc biệt lưu trữ tại văn phòng quốc tế về khối lượng và

đo lường tại Sèvres, Pháp. Chuẩn khối lượng được đưa ra vào năm 1887 và từ đó đến nay chưa thay đổi, do platinum-iridium là hợp kim đặc biệt bền. Một bản sao của khối trụ này được giữ tại Viện quốc tế về tiêu chuẩn và công nghệ (NIST) tại Gaithersburd, Maryland. Bảng 1.2 liệt kê các giá trị gần đúng của khối lượng các vật thể khác nhau.

_Bảng 1.2: Ước lượng khối lượng của các vật thể khác nhau_


|  | Khối lượng (kg) |
| --- | --- |
| Phần vũ trụ quan sát được | 1052 |
| Dải Ngân hà | 1042 |
| Mặt trời | 1,99 × 1030 |
| Trái đất | 5,98 × 1024 |
| Mặt trăng | 7,36 × 1022 |
| Cá mập | ~ 103 |
| Con người | ~ 102 |
| Con ếch | ~ 10−1 |
| Con muỗi | ~ 10−5 |
| Vi khuẩn | ~ 10−15 |
| Nguyên tử hidro | 1,67 × 10−27 |
| Điện tử | 9,11 × 10−31 |

 

### Thời gian

Trước năm 1967, chuẩn về thời gian được định nghĩa theo _ngày mặt trời trung bình_ (là khoảng thời gian giữa hai lần mặt trời đứng bóng liên tiếp). Đơn vị _giây_ (second – s) được

định nghĩa là 

1 
1  1 

của ngày mặt trời trung bình. Định nghĩa này dựa trên sự quay

   
   

của một hành tinh là Trái đất nên không thể xem là chuẩn thời gian của vũ trụ.

Vào năm 1967, _giây_ được định nghĩa lại khi xuất hiện dụng cụ đo thời gian với độ chính xác cao – _đồng hồ nguyên tử_ (hình 1.1b), đồng hồ này đo các dao động của nguyên tử Cesium (Cs). Theo đó, _**1 giây là 9.192.631.770 chu kỳ dao động của nguyên tử Cs133**_. Bảng 1.3 trình bày một số giá trị gần đúng của thời gian.
_Bảng 1.3: Ước lượng giá trị của một số khoảng thời gian_


| Khoảng thời gian (s) |
| --- |

 

Ngoài các đơn vị cơ bản mét, kg và s nói trên, ta có thể dùng các đơn vị khác như là mm (mili-mét), ns (nano giây), với mili và nano là các tiếp đầu ngữ chỉ các bội số của 10.

_**Các tiếp đầu ngữ:**_ Các tiếp đầu ngữ (tiền tố) được ghép vào trước một đơn vị đo để biểu diễn một bội số của 10. Mỗi tiếp đầu ngữ có một tên và cách viết tắt riêng. Có thể ghép tiếp đầu ngữ với bất kỳ đơn vị cơ bản nào. Nó chính là hệ số nhân thêm vào đơn vị cơ bản.

Ví dụ: 1mm = 10−3 m ;1mg = 10−3g .
_**Đại lượng cơ bản và đại lượng phái sinh**_ : Độ dài, khối lượng và thời gian là ví dụ cho các _đại lượng cơ bản._ Hầu hết các đại lượng còn lại là đại lượng phái sinh, tức là có thể được biểu diễn dưới dạng các tổ hợp toán học của các đại lượng cơ bản. Ví dụ thường gặp là _diện tích_ (tích của hai chiều dài) và _tốc độ_ (tỉ số giữa độ dài và khoảng thời gian). Hoặc _khối lượng riêng,_ được định nghĩa là _khối lượng của một đơn vị thể tích_
ρ ≡ _m_
_V_

_**Tính hợp lý của các kết quả**_ : Khi giải bài tập, bạn cần phải kiểm tra câu trả lời của mình xem chúng có hợp lý không. Việc xem lại các bảng giá trị gần đúng của độ dài, khối lượng và thời gian có thể giúp bạn kiểm tra tính hợp lý này.

_Bảng 1.4: Các tiếp đầu ngữ cho bội/ước số của 10_


| Lũy thừa 10 | Tiếp đầu ngữ | Viết tắt | Lũy thừa 10 | Tiếp đầu ngữ | Viết tắt |
| --- | --- | --- | --- | --- | --- |
| 10−22 | yocto | y | 103 | kilo | k |
| 10−21 | zepto | z | 106 | mega | M |
| 10−18 | atto | a | 109 | giga | G |
| 10−15 | femto | f | 1012 | tera | T |
| 10−12 | pico | p | 1015 | peta | P |
| 10−9 | nano | n | 1018 | exa | E |
| 10−6 | micro | μ | 1021 | zetta | Z |
| 10−3 | milli | m | 1024 | yotta | Y |
| 10−2 | centi | c |  |  |  |
| 10−1 | deci | d |  |  |  |

 

_**Câu hỏi 1.1:**_ Trong một xưởng cơ khí, người ta chế tạo hai bánh cam, một bằng nhôm và một bằng sắt. Hai bánh cam này có cùng khối lượng. Bánh cam nào lớn hơn?

(a) bánh bằng nhôm (b) bánh bằng sắt (c) hai bánh có cùng kích cỡ

## ![](images/image3.png) Vật chất và xây dựng mô hình

Nếu nhà vật lý _**không thể tương tác trực tiếp với một số hiện tượng**_ , họ thường hình dung ra một _**mô hình**_ cho hệ vật lý có liên quan đến các hiện tượng này. Ví dụ, ta không thể tương tác trực tiếp với các nguyên tử vì chúng quá nhỏ. Do đó, ta xây dựng một mô hình tưởng tượng về nguyên tử như một hệ gồm một hạt nhân và một hoặc nhiều electron nằm bên ngoài hạt nhân. Khi đã xác định được _**các thành phần vật lý của mô hình**_ thì ta _**đưa ra các tiên đoán**_ về _**hành vi**_ của chúng _**trên cơ sở các tương tác giữa các thành phần của hệ hoặc tương tác giữa hệ với môi trường bên ngoài hệ**_.

Hãy xem xét hành vi của vật chất để làm ví dụ. Hình đầu tiên của hình 1.1 cho thấy một miếng vàng đặc. Có phải miếng vàng này toàn là vàng, không có chỗ trống nào? Nếu cắt đôi miếng vàng này, hai miếng vàng thu được vẫn giữ nguyên đặc tính hóa học như miếng vàng nguyên. Chuyện gì sẽ xảy ra nếu ta cứ chia đôi các miếng này liên tục, vô hạn lần? Các miếng ngày càng nhỏ dần này có luôn là vàng hay không? Những câu hỏi như vậy đã được đặt ra từ rất lâu bởi _**các nhà triết học Hi Lạp**_. Hai trong số họ, Leucippus và học trò của ông là Democritus, không chấp nhận ý tưởng rằng sự chia cắt như vậy có thể diễn ra mãi mãi. Họ _**xây dựng một mô**_

![](images/image4.jpeg)

_Hình 1.1_

_**hình một mô hình vật chất**_ với suy đoán rằng quá trình nói trên cuối cùng cũng phải kết thúc khi nó tạo ra _**một hạt không thể bị chia cắt được nữa**_. Trong tiếng Hi lạp, “atomos” có nghĩa là “không chia cắt được”. Từ tiếng Anh “atom” (nguyên tử) bắt nguồn từ cách gọi này trong tiếng Hi lạp.

Mô hình Hi lạp về cấu trúc vật chất cho rằng mọi vật chất bình thường đều có các nguyên tử (xem hình giữa của hình 1.1). Ngoài ra, không có thêm cấu trúc nào khác được xác định trong mô hình này; các nguyên tử hoạt động như các hạt nhỏ có tương tác với nhau, nhưng mô hình này không đề cập đến cấu trúc bên trong nguyên tử.

_**Vào năm 1897, J. J. Thomson đã xác định electron là một hạt tích điện và là một thành phần của nguyên tử**_. Điều này dẫn đến mô hình nguyên tử đầu tiên có cấu trúc bên trong. Mô hình này sẽ được thảo luận trong chương 42.

Sau sự phát hiện các hạt nhân vào năm 1911, người ta đã đưa ra một mô hình nguyên tử trong đó nguyên tử được tạo thành từ các electron bao quanh một hạt nhân ở giữa. Tuy vậy, mô hình này dẫn đến một câu hỏi mới: Hạt nhân có cấu trúc hay không? Nghĩa là, phải chăng hạt nhân là một hạt đơn lẻ hay là một tập hợp các hạt? Vào đầu những năm 1930, người ta đưa ra một mô hình mô tả hai thành phần cơ bản trong hạt nhân: proton và neutron. Proton mang điện tích dương và một nguyên tố hóa học được xác định bằng số lượng proton trong

hạt nhân của nó. Con số này được gọi là nguyên tử số (atomic number) của nguyên tố. Bên cạnh nguyên tử số, một số khác, khối số (mass number), được định nghĩa bằng tổng của số proton và số neutron tạo nên hạt nhân. Nguyên tử số của một nguyên tố không bao giờ thay đổi, còn khối số có thể thay đổi.

Tuy nhiên, có phải sự phân chia vật chất đã kết thúc? Hiện nay, người ta đã biết rằng _**các proton, neutron và một số đông đảo các hạt ngoại lai**_ được tạo nên từ _**6 hạt khác gọi là quark**_ , các hạt này được đặt tên là _up_ , _down_ , _strange_ , _charmed_ , _bottom_ và _top_. Các hạt quark _up_ , _charmed_ và _top_ có điện tích +2/3 điện tích của proton trong khi 3 hạt còn lại có điện tích –1/3 điện tích của proton. Proton được tạo thành từ 2 hạt _up_ và 1 hạt _down_ (ký hiệu lần lượt là u và d trong hình 1.2). Tương tự, neutron được tạo thành từ 2 hạt _down_ và 1 hạt _up_.
_**Khi học vật lý, bạn phải phát triển một tiến trình xây dựng các mô hình.**_ Bạn sẽ được thử thách với việc giải quyết nhiều vấn đề toán học. Một kỹ thuật giải quyết bài toán quan trọng nhất là _**xây dựng mô hình cho vấn đề cần giải quyết**_ :

  * Xác định một hệ các thành phần vật lý cho bài toán và

  * Đưa ra dự đoán về hành vi của hệ thống trên cơ sở các tương tác giữa các thành phần của hệ hoặc tương tác của hệ này với môi trường xung quanh.


## ![](images/image5.png) Phân tích thứ nguyên

Trong vật lý, từ “ _thứ nguyên_ ” được dùng để bản chất vật lý của một đại lượng. Ví dụ, khoảng cách giữa hai điểm có thể được đo bằng feet1, mét hay fulong2, tất cả đều là các cách khác nhau để biểu thị thứ nguyên độ dài.

Trong sách này, chúng tôi dùng các ký hiệu cho thứ nguyên độ dài, khối lượng và thời gian tương ứng là L, M và T 3. Chúng tôi cũng thường dùng cặp dấu ngoặc [ ] để biểu thị các thứ nguyên của các đại lượng. Ví dụ, _v_ được dùng để chỉ tốc độ, thứ nguyên của tốc độ sẽ được biểu thị là [ _v_ ]=L/T. Với diện tích (ký hiệu là _A_ ) thì ta có [ _A_ ]=L2. Bảng 1.5 **Error! Reference source not found.** giới thiệu thứ nguyên của một số đại lượng.

_Bảng 1.5: Các thứ nguyên và đơn vị của 4 đại lượng đã biết_


| Đại lượng | Diện tích (A) | Thể tích (V) | Tốc độ (v) | Gia tốc (a) |
| --- | --- | --- | --- | --- |
| Thứ nguyên | L2 | L3 | L / T | L / T2 |
| Đơn vị SI | m2 | m3 | m / s | m / s2 |
| Đơn vị trong hệ đo lường của Mỹ | ft2 | ft3 | ft / s | ft / s2 |

 

Trong nhiều trường hợp, có thể bạn phải kiểm tra một phương trình cụ thể để xem nó có phù hợp với dự tính của bạn hay không. Để làm điều đó, bạn có thể sử dụng một thủ thuật

1 Feet: đơn vị đo chiều dài của Anh, bằng 0,3048m
2 Fulong: đơn vị đo chiều dài, bằng 1/8 dặm Anh, tức khoảng 201m
3 Thứ nguyên của một đại lượng được viết bằng chữ viết hoa, thẳng; còn ký hiệu đại số cho đại lượng được ký hiệu bằng chữ in nghiêng: _L_ cho độ dài và _t_ cho thời gian.

hữu ích, _phân tích thứ nguyên_ , vì các thứ nguyên có thể được xem như là các đại lượng đại số. Cần lưu ý:

  * Chỉ có thể cộng hoặc trừ các đại lượng với nhau nếu chúng có cùng thứ nguyên.

  * Vế trái và vế phải của một đẳng thức (bất đẳng thức) cần phải có cùng thứ nguyên.


Tuân theo quy tắc cơ bản này, ta có thể sử dụng phép _phân tích thứ nguyên_ để kiểm tra tính đúng đắn của một biểu thức. Một quan hệ bất kỳ chỉ có thể đúng nếu thứ nguyên của hai vế phương trình là giống nhau.

Để minh họa cho thủ thuật này, giả thiết rằng bạn quan tâm đến một phương trình về vị trí _x_ của một chiếc xe và thời gian _t_ nếu xe khởi hành từ trạng thái đứng yên tại vị trí _x_ =0 và chuyển động với gia tốc không đổi _a_. Biểu thức đúng cho trường hợp này là _x_ = ½ _at_ 2 (xem chương 2). Đại lượng _x_ ở vế trái có thứ nguyên là L. Để cho phương trình này đúng về thứ nguyên thì vế bên phải của phương trình cũng phải có thứ nguyên là L. Ta có thể tiến hành kiểm tra thứ nguyên bằng cách thay thế thứ nguyên cho gia tốc là L/T2, và thời gian là T vào phương trình. Ta được:

L=

2 = L

Các thứ nguyên thời gian được khử đi như trên nên chỉ còn lại thứ nguyên độ dài. Hai vế trái và phải khớp với nhau.

Một thủ thuật tổng quát hơn khi sử dụng phép phân tích thứ nguyên là lập một biểu thức
có dạng: _x_ ∝ _a ntm_

Với _m_ , _n_ là các số cần tìm và ∝ là dấu tỉ lệ. Quan hệ này chỉ đúng nếu thứ nguyên của hai vế là như nhau. Vì thứ nguyên của vế bên trái là chiều dài nên thứ nguyên của phần bên phải cũng là chiều dài. Nghĩa là:

Do gia tốc a có thứ nguyên là L _/_ T2 (xem chương 2) nên ta có:
(L / T2 ) _n_ T _m_ = L1T0 → L / T _m_ −2 _n_ = L1 T0
Từ phương trình trên, ta dễ thấy là _n_ =1 và _m_ =2. Tức là: _x_ ∝ _at_ 2

Phép phân tích thứ nguyên chỉ có một hạn chế là không kiểm tra được các hệ số bằng số trong công thức.

Các ký hiệu dùng trong công thức không nhất thiết phải là ký hiệu dùng cho thứ nguyên của đại lượng vật lý. Một số ký hiệu được dùng thường xuyên (ví dụ như _t_ ). Một đại lượng có thể được biểu diễn bởi nhiều ký hiệu (ví dụ như tọa độ, có thể dùng _x_ , _y_ hoặc _z_ ), tùy theo trường hợp sử dụng.

_**Câu hỏi 1.2**_ : Nói rằng “Phép phân tích đơn vị có thể cho ra giá trị bằng số của các hằng số của các tỉ lệ có thể xuất hiện trong các biểu thức đại số” là đúng hay sai?

### Bài tập mẫu 1.1:

### 

Hãy chứng tỏ rằng biểu thức gian) là đúng về thứ nguyên.

_v_ = _at_ (với v là tốc độ, a là gia tốc và t là khoảng thời

### Bài tập mẫu 1.2:

Giả sử người ta bảo rằng gia tốc của một hạt chuyển động với tốc độ không đổi _v_ theo một đường tròn bán kính _r_ tỉ lệ với _r n_ và với _v m_. Hãy tìm giá trị của _m_ và n và viết biểu thức tối giản của gia tốc.

### Giải:

Ta có thể viết biểu thức ban đầu của gia tốc với _k_ là hệ số tỉ lệ, không có thứ nguyên:
_a_ = _kr nv_m
Thay các thứ nguyên của gia tốc, tốc độ và bán kính vào, ta được:
![](images/image6.png)L  L  _m_
T2  T 
Cân bằng các số mũ của L và T ta được
_n_ \+ _m_ = 1;
Từ đó:
_n_ = −1
_m_ = 2
Biểu thức của gia tốc sẽ là
_a_ = _kr_ −1 _v_ 2 _k v_
_r_
Trong phần 4.4 về sau, ta sẽ thấy rằng _k=_ 1 với hệ đơn vị được chọn phù hợp. Nếu dùng hệ đơn vị khác thì _k_ sẽ khác 1. Ví dụ nếu đơn vị vận tốc là km/h và ta muốn có gia tốc tính bằng m/s2.

## ![](images/image7.png) Phép đổi đơn vị

Trong các bài toán, đôi khi ta phải đổi đơn vị từ một hệ đơn vị này sang một hệ đơn vị khác (ví dụ từ inch sang cm) hoặc đổi đơn vị trong cùng một hệ (ví dụ từ km sang m). Xem phụ lục A về danh sách các hệ số qui đổi.

Cũng như với thứ nguyên, có thể xem đơn vị là các đại lượng đại số và có thể ước lược lẫn nhau trong một công thức.

Cần lưu ý là phải luôn ghi kèm đơn vị cho mỗi đại lượng, nếu cần thì ghi đơn vị trong suốt quá trình tính toán. Làm như vậy thì có thể phát hiện được các sai sót trong tính toán.

## ![](images/image8.png) Ước lượng và phép tính bậc độ lớn

Trong nhiều trường hợp, ta không cần phải có một con số chính xác cho đại lượng vật lý mà chỉ cần một giá trị gần đúng, biểu diễn dưới dạng số dùng trong khoa học. Giá trị ước lượng này có thể thiếu chính xác hơn nữa (more approximate) nếu được biểu diễn theo bậc độ lớn (order of magnitute). Cách tính theo bậc độ lớn như sau:

  * Biểu diễn số dưới dạng khoa học: là tích của một số _x_ (có giá trị từ 1 đến 10) với một lũy thừa của 10 kèm theo một đơn vị đo. (ví dụ 1,23×10–2 m)

  * ![](images/image9.png)Nếu _x_ nhỏ hơn 3,162 ( 10 ) thì bậc của độ lớn là số mũ của 10 khi biểu diễn số đã cho dưới dạng khoa học.

  * Nếu _x_ lớn hơn 3,162 thì bậc của độ lớn bằng số mũ của 10 cộng thêm 1.


Ta dùng dấu ∼ để chỉ “cùng bậc với”. Sử dụng qui ước này để xem xét một số giá trị về độ dài, ta được kết quả như sau:

0,002 1 m = 2,1×10–3 m ∼ 10–3 m; (bậc độ lớn bằng số mũ của 10, trong trường hợp này là –3)

0,008 6 m = 8.6×10–3 m ∼ 10–2 m; (bậc độ lớn bằng số mũ của 10 cộng thêm 1) 720 m = 7,2×102 m ∼ 103 m; (bậc độ lớn bằng số mũ của 10 cộng thêm 1)

Khi sử dụng ước lượng theo bậc độ lớn thì các kết quả chỉ tin cậy được trong phạm vi một bội số của 10. Nếu một đại lượng tăng 3 bậc độ lớn thì giá trị của nó được nhân với một hệ số là 103 = 1, 000.

## ![](images/image10.png) Các chữ số có nghĩa

Khi đo một đại lượng nào đó, các giá trị đo được chỉ được biết đến trong giới hạn của sai số thực nghiệm. Giá trị của sai số này phụ thuộc vào nhiều yếu tố khác nhau.

  * Các sai số này có thể là do dụng cụ đo, kỹ năng của người làm thí nghiệm và/hoặc số lượng phép đo được thực hiện.

  * Ta cần có một kỹ thuật để tính đến các sai số này.


Ta sẽ dụng các qui tắc về chữ số có nghĩa để ước lượng sai số trong kết quả của các phép tính.

Số chữ số có nghĩa trong một phép đo có thể mô tả được ít nhiều về sai số. Nó có liên quan với số chữ số được ghi trong kết quả của phép đo.

Ví dụ ta cần đo bán kính của một cái đĩa CD bằng thước mét. Giả sử rằng độ chính xác mà ta có thể đạt được là ± 0,1 cm. Nếu ta đo được 6,0 cm thì ta chỉ có thể nói được rằng bán

kính của đĩa nằm đâu đó trong khoảng 5,9 cm đến 6,1 cm. Trong trường hợp này, giá trị đo 6,0 cm có 2 chữ số có nghĩa. Lưu ý rằng chữ số được ước lượng đầu tiên cũng được tính là chữ số có nghĩa. Vì vậy ta có thể viết giá trị bán kính của đĩa là (6,0 ± 0,1) cm.

Chữ số có nghĩa là chữ số đáng tin. Số không (0) có thể có nghĩa hoặc không có nghĩa.

  * Số 0 dùng để xác định vị trí của dấu thập phân thì _**không có nghĩa**_. Ví dụ như các số 0 trong các số 0,03 và 0,007 5 là không có nghĩa. Số chữ số có nghĩa của hai giá trị này lần lượt là 1 và 2. Tuy nhiên, số 10,0 lại có 3 chữ số có nghĩa.

  * Nếu số 0 nằm sau các chữ số khác thì có thể bị nhầm lẫn. Ví dụ như khối lượng của một vật được ghi là 1 500 g thì các chữ số 0 có phải là số có nghĩa hay không. Để đỡ nhầm lẫn thì phải dùng dạng số khoa học. Trong trường hợp này, nếu ghi là 1,5 × 103 thì có 2 chữ số có nghĩa. Nếu ghi là 1,50 × 103 thì có 3 chữ số có nghĩa và nếu ghi 1,500 × 103 thì có 4 chữ số có nghĩa. Các giá trị nhỏ hơn 1 cũng được xem xét với qui tắc tương tự: 2,3 × 10–4 (hoặc 0,000 23) thì có 2 chữ số có nghĩa, trong khi 2,30 × 10–


4 (hoặc 0,000 230) thì có 3 chữ số có nghĩa.

Khi giải bài tập, ta thường kết hợp các đại lượng với nhau bằng các phép toán nhân, chia, cộng, trừ… Khi làm như vậy thì cần phải bảo đảm rằng kết quả có một số chữ số có nghĩa thích hợp.

  * Khi nhân hoặc chia các đại lượng, số chữ số có nghĩa ở kết quả là _**số chữ số có nghĩa nhỏ nhất**_ trong các giá trị tham gia vào phép tính.


Tính diện tích của một hình chữ nhật có 2 cạnh là 25,57 m và 2,45 m, ta có:
25,57 m × 2,45 m = 62,6 m2

do số chữ số có nghĩa của hai thừa số lần lượt là 4 và 3 nên lấy 3 là số chữ số có nghĩa cho kết quả phép nhân.

Tính diện tích của một hình tròn bán kính 6,0 cm:
_A=_ π _r 2_ = π ( _6,0_ cm) _2 =_ 1,1×102 cm2

Nếu dùng máy tính thì bạn có thể thu được kết quả là 113,097 335 5. Tất nhiên là không thể ghi hết các chữ số như vậy nên có thể là bạn sẽ ghi kết quả là 113 cm2. Kết quả này không đúng vì nó có đến 3 chữ số có nghĩa trong khi bán kính của hình tròn chỉ có 2 chữ số có nghĩa. Vì vậy, kết quả phải được ghi là 1,1×102 cm2 (chứ không phải là 110 cm2)

  * Nếu cộng và trừ các số thì kết quả sẽ lấy _**số chữ số thập phân nhỏ nhất**_ trong các số hạng của phép tính.


_**Ví dụ**_ : Tổng của 135 cm và 3,25 cm sẽ là:
135 cm + 3,25 cm = 138 cm (do số 135 cm không có số thập phân nào).

Tương tự như vậy, ta có: 23,2 + 5,174 = 28,4 (Lưu ý là không thể ghi kết quả là 28,374 vì số 23,2 chỉ có 1 chữ số thập phân).

Qui tắc về cộng hoặc trừ có thể dẫn đến trường hợp mà số chữ số có nghĩa của kết quả không giống với số chữ số có nghĩa của các số hạng trong phép tính. Xét các phép tính dưới đây:

1,000 1 + 0,000 3 = 1,000 4
1,002 – 0,998 = 0,004

Ở phép tính thứ nhất, số chữ số có nghĩa của kết quả là 5, trong khi số chữ số có nghĩa của các số hạng lần lượt là 5 và 1. Ở phép tính thứ 2, số chữ số có nghĩa của kết quả là 1, trong khi số chữ số có nghĩa của các số hạng lần lượt là 4 và 3.

_**Lưu ý:**_ Trong sách này, các ví dụ về số cũng như các bài toán ở cuối chương sẽ dùng các số với 3 chữ số có nghĩa.

Qui tắc về làm tròn số:

  * Chữ số cuối cùng được giữ lại sẽ tăng lên 1 đơn vị nếu chữ số cuối cùng bị bỏ đi lớn hơn 5. (Ví dụ, 1,346 được làm tròn thành 1,35)

  * Giữ nguyên chữ số cuối cùng được giữ lại nếu chữ số cuối cùng bị bỏ đi nhỏ hơn 5. (Ví dụ, 1,342 được làm tròn thành 1,34)

  * Nếu chữ số cuối cùng được bỏ đi là 5 thì chữ số được giữ lại được làm tròn thành _**số chẵn gần nhất**_.4 (Qui tắc này được đưa ra để tránh sai số tích lũy trong một loạt phép tính số học liên tiếp).

  * Khi làm toán, nếu có nhiều phép tính trung gian thì để tránh cộng dồn sai số, ta _**chỉ làm tròn ở phép tính cuối cùng**_.


### Bài tập mẫu 1.5:

Người ta trải một tấm thảm trong phòng hình chữ nhật có các số đo chiều dài là 12,71 m và chiều rộng là 3,56 m. Hãy tìm diện tích của căn phòng.

### Giải:

Nếu nhân 12,71 m với 3,46 m bằng máy tính bỏ túi thì ta sẽ được kết quả là 43,9766 m2. Ta sẽ chấp nhận bao nhiêu chữ số trong kết quả này. Áp dụng qui tắc về số chữ số có nghĩa thì con số có ít chữ số có nghĩa nhất là 3,46 m. Vì vậy ta phải biểu diễn kết quả là 44,0 m2.
4 Qui tắc này dựa trên lập luận là trong quá trình tính toán thì 50% các số đã được làm tròn lên và 50% còn lại được làm tròn xuống. Theo qui tắc này, khi bỏ đi chữ số 5 cuối cùng thì 2,315 và 2,325 đều được làm tròn thành 2,32.

# Tóm tắt chương 1

**Định nghĩa:**
**Khái niệm và nguyên lý:**

  1. Một lốp ô tô được dùng cho 50 000 miles (dặm). Nó quay được bao nhiêu vòng trong cuộc đời của nó? Giả sử lốp xe có đường kính là 2,5 ft, chu vi khoảng 8 ft. 1 mile = 5280 ft


ĐS: 107 vòng

  2. Năm dương lịch, khoảng thời gian từ một Xuân phân này đến một Xuân phân tiếp theo, là cơ sở cho lịch chúng ta. Nó có 365,242 199 ngày. Tìm số giây trong một năm dương lịch.


ĐS: 31556926,0 s

  3. Trong bãi đỗ xe của trường đại học cộng đồng, số xe bình thường lớn hơn số xe thể thao tiện ích (SUV) là 94,7 %. Hiệu của chúng là 18. Tìm số lượng SUV trong bãi đỗ xe .


ĐS: 19

  4. Bán kính của một quả cầu rắn đồng chất được đo là (6,50 ± 0,20) cm, và khối lượng của nó được đo là (1,85 ± 0,02) kg. Xác định khối lượng riêng của quả cầu tính bằng kilôgam trên mét khối và sai số của nó.


ĐS: 1,6 ± 0,2 ×103 kg

  5. Khoảng cách từ Mặt trời đến ngôi sao gần nhất là khoảng 4 ×1016 m. Có thể xem dải Ngân hà là một đĩa hình trụ đường kính ~1021 m và độ dày ~1019 m. Hãy tìm số ngôi sao trong dải Ngân hà theo bậc của độ lớn. Xem khoảng cách giữa Mặt trời và ngôi sao gần nhất là khoảng cách điển hình.


ĐS: 1011 ngôi sao.

# Public_127

Trong vật lý, ta thường làm việc với các đại lượng có cả thuộc tính về số và về hướng đó là các đại lượng vec-tơ. Đại lượng vec-tơ được dùng nhiều trong sách này nên bạn cần phải nắm vững những kỹ thuật được trình bày trong chương này.

## ![](images/image2.png) Các hệ tọa độ

Các hệ tọa độ được sử dụng để mô tả vị trí của một điểm trong không gian. Phần này sẽ trình bày về hệ tọa độ Descartes và hệ tọa độ cực.

### Hệ tọa độ Descartes:

Hệ tọa độ Descartes còn được gọi là hệ tọa độ vuông góc. Trong đó có hai trục tọa độ _x_ và _y_ vuông góc với nhau và giao nhau tại gốc tọa độ (hình 3.1).

### Hệ tọa độ cực

Hệ tọa độ cực bao gồm một gốc tọa độ và một đường thẳng qui chiếu. Một điểm cách gốc tọa độ một khoảng _r_ theo hướng θ tính từ đường thẳng qui chiếu (hình 3.2 a). Thường thì ta chọn trục _Ox_ làm đường thẳng qui chiếu.

![0301](images/image3.jpeg)

_Hình 3.1 Trong hệ tọa độ Descartes, một điểm trong mặt phẳng được gán nhãn (x, y)_
![](images/image4.jpeg)
_Hình 3.2 (a) Hệ tọa độ cực, các điểm được gán nhãn (r, θ); (b) liên hệ giữa (x, y) và (r, θ)_
Trong nhiều trường hợp, sử dụng hệ tọa độ cực sẽ dẫn đến các phép tính đơn giản hơn so với hệ tọa độ Descartes.

### Chuyển đổi từ tọa độ cực sang tọa độ Descartes:

### 

Dựa trên tam giác vuông dựng từ _r_ và θ ta có:
_x_ = _r_ cosθ
(3.1);
_y_ = _r_ sinθ
(3.2)
Nếu biết trước các tọa độ _x_ và _y_ thì tanθ = _y_

_x_

(3.4) và
_r =_
(3.5)

### Bài tập mẫu 3.1:

![0303](images/image5.jpeg)Các tọa độ Descartes của một điểm trong mặt phẳng xy là (x, y) = (–3.50; –2.50) m như hình 3.3. Hãy tìm các tọa độ cực của điểm này.

### Giải:

Từ phương trình (3.4) ta có:

_r_ =

=

= 4,30 m
Từ phương trình (3.3) suy ra:
tanθ = _y_

_x_

= −2,50 m = 0,714 ⇔ θ = 216°
−3,50 m
_Hình 3.3 Tìm các tọa độ cực._

## ![](images/image6.png) Đại lượng vec-tơ và đại lượng vô hướng

### Đại lượng vô hướng

Đại lượng vô hướng được xác định một cách trọn vẹn bằng một giá trị với một đơn vị đo tương ứng và không có hướng.

  * Nhiều đại lượng là số luôn dương.

  * Một vài đại lượng có thể âm hoặc dương.

  * Có thể dùng các qui tắc số học để làm việc với các đại lượng vô hướng.


### ![0304](images/image7.jpeg)Đại lượng vec-tơ

Đại lượng vec-tơ chỉ được xác định một cách trọn vẹn bởi một con số kèm theo đơn vị đo và một hướng nhất định.
_**Ví dụ về vec-tơ:**_ Một hạt chuyển động từ A đến B dọc theo một đường cong (nét đứt) như hình vẽ.

  * Quãng đường mà hạt đi được là một đại lượng vô hướng (chính là độ dài của đường cong).

  * Độ dời của chất điểm là đường thẳng liền nét từ A đến B, nó không phụ thuộc vào dạng của đường cong giữa 2 điểm A và B. Vì vậy độ dời là một vec-tơ.


_Hình 3.4 Một chất điểm chuyển động từ A đến B theo đường nét đứt._
![](images/image8.png)![](images/image9.png) _ **Cách trình bày vec-tơ**_ : Trong tài liệu này, vec-tơ được thể hiện bằng một chữ cái in đậm và một dấu mũi tên trên đầu hoặc có thể không có mũi tên: **A, A** . Khi nói về độ lớn của vec- tơ, ta dùng chữ in nghiêng _A_ hoặc ghi rõ **| A |** .
Độ lớn của vec-tơ sẽ có một đơn vị vật lý và luôn là một số dương. Nếu viết tay thì phải dùng thêm dấu mũi tên.
_**Câu hỏi 3.1:**_ Điều nào sau đây là đại lượng vec-tơ và điều nào là đại lượng vô hướng?
(a) Tuổi của bạn, (b) gia tốc, (c) vận tốc, (d) tốc độ, (e) khối lượng.
![](images/image10.jpeg)![](images/image11.png)

### Phép cộng vec-tơ:

Phép cộng vec-tơ rất khác với cộng các đại lượng vô hướng.
Khi cộng các vec-tơ, phải lưu ý đến hướng của chúng. Đơn vị của các vec-tơ phải giống nhau (nghĩa là chúng phải là các vec-tơ cùng loại). Không thể lấy vec-tơ độ dời cộng với vec-tơ vận tốc.
_Hình 3.5 Bốn vec-tơ bằng nhau._
Có hai cách cộng vec-tơ: bằng hình học và bằng đại số. Cách cộng đại số là thuận tiện hơn so với cách cộng hình học (phải vẽ các vec-tơ theo tỉ lệ).
_**Cộng vec-tơ theo kiểu hình học:**_
![](images/image13.jpeg)Khi thực hiện phép cộng vec-tơ theo kiểu hình học thì phải chọn một tỉ lệ xích. Vẽ vec- tơ thứ nhất với độ dài phù hợp theo hướng xác định (theo một hệ tọa độ). Vẽ vec-tơ tiếp theo sao cho gốc tọa độ của vec-tơ này trùng với ngọn của vec-tơ trước và các trục của hệ tọa độ của vec-tơ sau song song với các trục tọa độ của vec-tơ trước (kiểu vẽ gốc nối ngọn). Vec-tơ tổng được vẽ từ gốc
của vec-tơ đầu tiên đến ngọn của vec-tơ cuối cùng. Sau khi vẽ xong, đo độ dài của vec-tơ tổng và hướng (theo góc hợp với các trục tọa
độ) của nó (xem hình 3.6).
_Hình 3.6 Một số ví dụ về cộng vec-tơ_
Do phép cộng vec-tơ có _**tính giao hoán**_ nên thứ tự vẽ các vec-tơ là không quan trọng. Đồng thời, do phép cộng vec- tơ có _**tính kết hợp**_ nên khi tìm tổng của nhiều vec-tơ thì có thể gộp các vec-tơ thành nhóm một cách tùy ý. Kết quả của phép cộng không thay đổi. Ví dụ với tổng sau:
![0309](images/image14.jpeg)
_Hình 3. 7 Cộng vec-tơ kiểu hình học_
![](images/image15.png)![](images/image16.png)
Có thể tìm tổng **B** và **C** trước rồi tìm tổng của **A** với **B** + **C**. Nhưng cũng có thể tìm tổng của **A** và **B** trước rồi sau đó tìm tổng của **A** + **B** với **C**

### Phép trừ vec-tơ:

![](images/image19.png) _ **Vec-tơ trái dấu:**_ Vec-tơ trái dấu của một vec-tơ là một vec-tơ mà tổng của nó với vec-tơ ban đầu là một vec-tơ không. Vec-tơ trái dấu có độ lớn bằng với độ lớn vec-tơ gốc nhưng ngược chiều. Vec-tơ trái dấu của **A** là – **A** nên **A+(** – **A)** = **0**
![](images/image20.jpeg) _ **Phép trừ vec-tơ:**_ là trường hợp đặc biệt của phép cộng vec-tơ: Hai cách thực hiện phép trừ vec-
tơ (hình 3.8):

  * Cách 1: tìm vec-tơ trừ của vec- tơ **B** rồi tiếp tục thực hiện phép cộng với vec-tơ trừ này.

  * Cách 2: Tìm một vec-tơ mà khi cộng vec-tơ này với vec-tơ thứ hai (nằm sau dấu trừ) thì được vec-tơ thứ nhất (nằm trước dấu


**A** − **B** = **A** \+ (− **B** )

trừ).

![](images/image21.png)![](images/image22.png)(3.7)

_Hình 3.8 Phép trừ vec-tơ (a) cách 1; (b)_

_cách 2_

### Phép nhân (chia) vec-tơ với một số vô hướng:

Khi nhân/chia một vec-tơ với một số vô hướng thì ta được một vec-tơ có độ lớn bằng độ lớn của vec-tơ được nhân (hoặc chia) với số vô hướng đó.
![](images/image25.png)Nếu số vô hướng là số dương thì vec-tơ kết quả cùng hướng với vec-tơ ban đầu. Nếu số vô hướng là số âm thì vec-tơ kết quả ngược hướng với vec-tơ ban đầu.

![](images/image26.png)![](images/image27.png)

có giá trị lớn nhất và nhỏ nhất có thể là độ lớn của vec-tơ **R = A +B** ? (a) 14.4 đơn vị và 4 đơn vị, (b) 12 đơn vị và 8 đơn vị, (c) 20 đơn vị và 4 đơn vị, (d) không phải 3 cặp trên.

![](images/image27.png)![](images/image26.png)![](images/image26.png)![](images/image27.png)

song và cùng chiều, (b) **A** và **B** song song và ngược chiều, (c) **A** và **B** có cùng độ lớn, (d) **A**
![](images/image26.png)![](images/image27.png)![](images/image26.png)![](images/image27.png)![](images/image26.png)![](images/image27.png)và **B** trực giao.

### Bài tập mẫu 3.2:

Một ô tô đi theo hướng bắc được 20km, sau đó quẹo sang hướng tây theo phương hợp với phương bắc 1 góc 60o, xe đi được 35km trên đoạn đường này (hình 3.9). Xác định độ lớn, phương và chiều của vec-tơ độ dời của xe sau 2 đoạn đường trên.

### Giải:

![](images/image26.png)![](images/image27.png)Gọi **A** và **B** là 2 vec-tơ độ dời của xe lần lượt trong 2 đoạn đường 20km và
![](images/image28.jpeg)
_Hình 3.9 Ví dụ 3.2_
![](images/image26.png)![](images/image27.png)35km. Góc hợp bởi **A** và **B** là θ, θ = 180o – 120o = 60o.
Vec-tơ độ dời của 2 xe sau 2 đoạn đường trên là
![](images/image30.png)

. Ta có **R = A +B** với độ lớn của

![](images/image30.png)![](images/image25.png)là:

**R =**
Phương của

=

![](images/image30.png)tạo với phương bắc 1 góc β. Ta có:
_sin β_
= _sinθ_
= 48.2 _km_
⇒ sin β = _B_
_sinθ_
_R_
_B R_
_o_
35 × = 38.9
48.2
Vậy: vec-tơ độ dời của xe sau 2 đoạn đường trên có độ lớn 48.2 km, chiều hướng về phía tây, phương hợp với phương bắc 1 góc 38.9o.

## ![](images/image31.png) Các thành phần của vec-tơ và vec-tơ đơn vị

Khi cộng các vec-tơ thì phương pháp hình học không được khuyến khích dùng trong trường hợp cần phải có độ chính xác cao hoặc trong các bài toán có không gian 3 chiều. Lúc này, ta sử dụng phương pháp thành phần. Phương pháp thành phần sử dụng các hình chiếu của vec-tơ lên các trục tọa độ.

### ![](images/image32.jpeg)Các thành phần của vec-tơ:

Thành phần của vec-tơ là hình chiếu của vec-tơ này lên một trục tọa độ. Có thể biểu diễn một cách đầy đủ mọi vec-tơ theo các thành phần của nó.
Để tiện lợi thì ta sử dụng các thành phần vuông góc của vec-tơ: đó là hình
chiếu của vec-tơ lên các trục tọa độ x và y.
_Hình 3.10 Phân tích vec-tơ **A** thành 2 thành phần **Ax** và **Ay**_
![](images/image33.png)![](images/image26.png)Trên hình 3.10, các vec-tơ **A** _x_ , **A** _y_ là các vec-tơ thành phần của **A** . Các vec-tơ thành phần cũng là các vec-tơ nên chúng tuân theo các qui tắc về vec-tơ.
![](images/image26.png) _Ax_ và _Ax_ là các số vô hướng, được gọi là các thành phần của vec-tơ **A** . Trên hình vẽ bên cạnh, dễ thấy:

![](images/image34.png)

3 vec-tơ này lập thành một tam giác vuông. Các thành phần của vec-tơ **A** lần lượt là:


| Ax=Acosθ | (3.8) |
| --- | --- |
| Ay=Asinθ | (3.9) |

 

![](images/image26.png)Góc θ được xác định từ trục Ox.
Các thành phần của vec-tơ là hai cạnh góc vuông của tam giác vuông có cạnh huyền là độ dài của vec-tơ. Dễ thấy:


| A=A2+A2x y | (3.10) |
| --- | --- |
| θ = tan−1AyAx | (3.11) |

 

![0313](images/image35.jpeg)Trong một bài toán, một vec-tơ có thể được xác định bởi các thành phần hoặc độ dài và hướng của nó.
Các thành phần của vec-tơ có thể dương hoặc âm nhưng có cùng đơn vị với vec-tơ. Dấu của thành phần phụ thuộc vào góc (hợp bởi vec-tơ và các trục tọa độ). Hình 3.11 minh họa các trường hợp mà các thành phần vec-tơ có dấu dương, âm.
![](images/image36.jpeg) _ **Câu hỏi 3.4:**_ Hãy chọn từ nào phù hợp với dấu … trong câu sau: “Một thành phần của một vec-tơ … lớn hơn độ lớn của vec-tơ đó”? (a) luôn luôn, (b) không bao giờ, (c) thỉnh thoảng.

### Vec-tơ đơn vị

Các đại lượng vec-tơ thường được biểu diễn thông qua vec-tơ đơn vị.
Vec-tơ đơn vị là vec-tơ không có thứ nguyên và có độ lớn đúng bằng 1. Các vec-tơ đơn vị được dùng để mô tả hướng trong không gian và không có ý nghĩa vật lý nào khác.
_Hình 3.11 Dấu của các thành phần của vec-tơ **A**_
Trong không gian 3 chiều, các vec-tơ đơn vị được ký hiệu là ˆ **i** , ˆ **j** , **k** ˆ .Các vec-tơ này vuông góc với nhau từng đôi trong một tam diện thuận. Độ lớn của mỗi vec-tơ này là 1:
_Hình 3.12 Các vec-tơ đơn vị trong hệ tọa độ Descartes._
![](images/image38.png)![](images/image39.png)![](images/image40.png)Xét một vec-tơ A trong mặt phẳng Xy, **A** _x_ = _Ax_ ˆ **i** và **A** _y_ = _Ay_ ˆ **j** nên **A** = _Ax_ ˆ **i** \+ _Ay_ ˆ **j** (3.12)

### ![0316](images/image41.jpeg)Vec-tơ vị trí

Một điểm có tọa độ (x, y) trong mặt phẳng Xy của hệ tọa độ Descartes có thể được biểu diễn bởi một vec-tơ vị trí:

![](images/image42.png)

Trong cách viết này, x và y là các thành phần của vec-tơ **r**

### ![](images/image43.png)Phép cộng vec-tơ khi dùng vec-tơ đơn vị:

Khi dùng vec-tơ đơn vị, các phép tính vec-tơ sẽ đơn giản
![](images/image44.png)![](images/image46.png)hơn. Trong mặt phẳng Xy, tổng của hai vec-tơ: **R** = **A** \+ **B** với _Hình 3.13 Cộng 2 vec-tơ_
các thành phần của vec-tơ **R** là _R x = Ax \+ Bx và Ry = Ay \+ By dùng vec-tơ đơn vị theo_
![](images/image47.png)![](images/image48.png) **R** = ( _Ax_ ˆ **i** \+ _Ay_ ˆ **j** ) + ( _Bx_ ˆ **i** \+ _By_ ˆ **j** )
**R** = ( _Ax_ \+ _Bx_ ) ˆ **i** \+ ( _Ay_ \+ _By_ )ˆ **j**
![](images/image46.png)Suy ra độ lớn của vec-tơ **R** : _R_ =
(3.14)
(3.15)

=

_hình học_
(3.16)
Góc hợp bởi vec-tơ tổng với trục Ox cho bởi:


| tanθ =Ry=Ay+ByRx Ax+Bx | (3.17) |
| --- | --- |

 

Nếu xét trong không gian 3 chiều thì chỉ cần thêm thành phần thứ 3 của các vec-tơ.


| ![](images/image49.png)A=Axˆi+Ayˆj+Azkˆ | (3.18) |
| --- | --- |
| ![](images/image50.png)B=Bxˆi+Byˆj+Bzkˆ | (3.19 |

 

Tổng của 2 vec-tơ này là:
![](images/image51.png) **R** = ( _Ax_ \+ _Bx_ ) ˆ **i** \+ ( _Ay_ \+ _By_ )ˆ **j** \+ ( _Az_ \+ _Bz_ ) **k** ˆ = _Rx_ ˆ **i** \+ _Ry_ ˆ **j** \+ _Rz_ **k** ˆ (3.20)
Độ lớn của vec-tơ tổng: _R_ = .
![](images/image53.png)![](images/image55.png)Nếu tính tổng của 3 vec-tơ trở lên thì ta vẫn dùng phương pháp như trên cho từng vec-tơ trong tổng. Ví dụ, với **R** = **A** \+ **B** \+ **C** thì:
![](images/image51.png) **R** = ( _Ax_ \+ _Bx_ \+ _Cx_ ) ˆ **i** \+ ( _Ay_ \+ _By_ \+ _Cy_ )ˆ **j** \+ ( _Az_ \+ _Bz_ \+ _Cz_ ) **k** ˆ
_**Câu hỏi 3.5**_ : Độ lớn của vec-tơ nào sau đây bằng 1 trong những thành phần của vec-tơ khác?
![](images/image56.png)![](images/image57.png)![](images/image60.png)(a) **A** = 2 **i** ˆ + 5ˆ **j** , (b) _B_ = −3ˆ **j** , (c) _**C**_ = 5 _ **k**_

# Public_128

Hiểu biết về các cơ sở của chuyển động trong không gian 2 chiều (từ đây gọi tắt là chuyển động hai chiều) sẽ cho chúng ta (trong các chương sau) khảo sát các tình huống khác nhau, từ chuyển động của các vệ tinh trên quỹ đạo đến chuyển động của các electron trong điện trường đều. Chúng ta sẽ bắt đầu nghiên cứu chi tiết hơn về

bản chất vec-tơ của vị trí, vận tốc và gia tốc. Sau đó sẽ xử lý chuyển động ném nghiêng và chuyển động tròn đều như là các trường hợp đặc biệt của chuyển động hai chiều. Chúng ta cũng sẽ thảo luận về khái niệm chuyển đông tương đối.

## ![](images/image1.png) Các vec-tơ vị trí, vận tốc và gia tốc

### Vec-tơ độ dời

![0401](images/image2.jpeg)Trong chương 2, ta đã thấy rằng chuyển động của một chất điểm theo một đường thẳng sẽ được xác định hoàn toàn nếu vị trí của nó được biết đến như là một hàm của thời gian. Bây giờ ta sẽ mở rộng ý tưởng này sang chuyển động 2 chiều của
![](images/image3.png)một chất điểm trong mặt phẳng xy. Ta bắt đầu bằng việc mô tả vị trí của một chất điểm bằng vec-tơ vị trí **r** , vẽ từ gốc của một hệ tọa độ đến vị trí của hạt trong mặt phẳng xy (hình 4.1).
Tại thời điểm ti, vị trí của chất điểm là ở A, được mô tả bởi
![](images/image4.png)vec-tơ **r** i , tại thời điểm tf, vị trí của chất điểm là B, được mô tả
![](images/image5.png)bởi vec-tơ **r** f . Quỹ đạo của chất điểm là đoạn cong AB.
**Vec-tơ độ dời** của chất điểm được định nghĩa là **hiệu của vec-tơ vị trí ở thời điểm cuối và vec-tơ vị trí ở thời điểm đầu của chất điểm**.

![](images/image7.png)

Như vậy động học chuyển động hai chiều (2 chiều hoặc 3

_Hình 4.1_

chiều), mọi thứ đều tương tự như trong chuyển động một chiều ngoại trừ việc ta phải sử dụng trọn vẹn cách biểu diễn vec-tơ.

### ![0402](images/image8.jpeg)Vận tốc trung bình:

Vận tốc trung bình bằng vec-tơ độ dời chia cho khoảng thời gian thực hiện độ dời đó. Hướng của vận tốc trung bình là hướng của vec-tơ độ dời.
![](images/image9.png)![](images/image10.png) _avg_ ∆ _t_

### Vận tốc tức thời:

Vận tốc tức thời là giới hạn của vận tốc trung bình khi Δ _t_ tiến tới không (tức là bằng đạo hàm của vec-tơ độ dời theo thời gian).

![](images/image11.png)![](images/image14.png)

Vận tốc tức thời tại mỗi điểm trên quỹ đạo của chất
_Hình 4.2 Vận tốc tức thời tại điểm A có phương là đường tiếp tuyến với quỹ đạo tại điểm A._
điểm có phương là phương tiếp tuyến với quỹ đạo và có chiều là chiều chuyển động. Độ lớn của vận tốc tức thời được gọi là tốc độ. Tốc độ là một đại lượng vô hướng.

### Gia tốc trung bình

Gia tốc trung bình của một chất điểm chuyển động được định nghĩa bằng độ biến thiên của vận tốc tức thời chia cho khoảng thời gian diễn ra sự biến thiên đó.


| ![](images/image15.png)![](images/image18.png)![](images/image19.png)a≡∆v=vf −viavg∆t t−tf i | (4.4) |
| --- | --- |

 

![](images/image20.png)Gia tốc trung bình là một đại lượng vec-tơ cùng hướng với ∆ **v** .

### Gia tốc tức thời:

Gia tốc tức thời là giới hạn khi Δ _t_ tiến đến không của ∆𝑣ሬԦ
∆𝑡


| ![](images/image24.png)![](images/image25.png)a≡ lim∆v=dv∆t→0∆t dt | (4.5) |
| --- | --- |

 

Gia tốc tức thời bằng đạo hàm theo thời gian của vec-tơ vận tốc.
_**Câu hỏi 4.1:**_ Xét các vật điều khiển trong 1 ô tô gồm: bàn đạp ga, phanh, tay lái. Trong 3 vật này, vật nào gây ra gia tốc cho xe? (a) Cả 3 vật, (b) bàn đạp ga và phanh, (c) phanh, (d) bàn đạp ga, và (e) tay lái.

## ![](images/image26.png) Chuyển động hai chiều với gia tốc không đổi

### Các phương trình động học trong chuyển động hai chiều:

Nếu một chuyển động hai chiều có gia tốc không đổi, ta có thể tìm được một hệ phương trình để mô tả chuyển động đó. Các phương trình này tương tự như các phương trình động học trong chuyển động thẳng.
Có thể mô hình hóa chuyển động trong không gian 2 chiều như là hai chuyển động _độc lập_ trong từng hướng gắn với các trục x và y. _Lưu ý:_ tác động lên chuyển động theo trục y không ảnh hưởng đến chuyển động theo trục x.

### Các phương trình động học:

Vec-tơ vị trí của một chất điểm chuyển động trong mặt phẳng xy là


| ![](images/image29.png)r=xˆi+yˆj | (4.6) |
| --- | --- |

 

Vec-tơ vận tốc của chất điểm được xác định bởi:


| ![](images/image9.png)![](images/image10.png)v=dr=dxˆi+dyˆj=vˆi+vˆjdt dt dtxy | (4.7) |
| --- | --- |

 

Vì gia tốc của chất điểm là hằng số nên ta tìm được biểu thức của vận tốc như là hàm của thời gian:


| ![](images/image30.png)![](images/image32.png)vf=vi+at | (4.8) |
| --- | --- |

 

Vị trí của chất điểm cũng được biểu diễn như là hàm của thời gian:


| ![](images/image33.png)![](images/image36.png)r=r+vt+ 1at2f i i2 | (4.9) |
| --- | --- |

 

![](images/image37.jpeg)

_Hình 4.3 Biểu diễn các thành phần của vec-tơ (a) vị trí, (b) vận tốc trong chuyển động hai chiều có gia tốc không đổi_

## ![](images/image40.png) Chuyển động ném nghiêng

Một vật có thể đồng thời chuyển động theo hai trục x và y. Trong phần này, ta xem xét chuyển động ném nghiêng. Phân tích chuyển động ném nghiêng của một vật sẽ đơn giản nếu chấp nhận 2 giả định:

  * Gia tốc rơi tự do là hằng số trong phạm vi chuyển động và hướng xuống dưới (giống như là quả đất là phẳng trong phạm vi khảo sát, điều này là hợp lý nếu phạm vi này là bé so với bán kính của Quả đất).

  * Bỏ qua sức cản của không khí.


![0407](images/image41.jpeg) **Phân tích chuyển động ném nghiêng:** Xét một chất điểm được ném nghiêng từ gốc tọa độ với vận tốc ban đầu
𝑣ሬ Ԧ𝜄 có phương hợp với phương ngang một góc θi. Với 2 giả định nêu trên, quỹ đạo của chất điểm luôn là một parabol như trong hình 4.4. Ở điểm cao nhất của quỹ đạo, vận tốc theo phương thẳng đứng bằng 0. Gia tốc luôn bằng g tại mọi điểm trên quỹ đạo.
Cụ thể, chúng ta sẽ đi **thiết lập phương trình chuyển động** của chất điểm trên theo 2 phương x và y. Chuyển
_Hình 4.4 Quỹ đạo parabol của chất điểm được ném nghiêng 1 góc θi từ gốc tọa độ với vận tốc ban đầu vi_
động của chất điểm là tổng hợp của các chuyển động theo phương _x_ và _y_. Vị trí của chất điểm tại thời điểm bất kỳ cho bởi:

![](images/image42.png)![](images/image43.png)

Từ những phân tích trên ta viết được:

  * Theo phương _x_ : ax = 0 và vxi = const nên chất điểm chuyển động thẳng đều với vận tốc


𝑣𝑥𝑖 = 𝑣𝑖𝑐𝑜𝑠𝜃𝑖. Từ biểu thức (4.10), ta viết được phương trình chuyển động của chất điểm theo phương x ứng với hệ tọa độ đã chọn như hình 4.4 như sau:

  * 𝑥𝑓 = 𝑥𝑖 + 𝑣𝑥𝑖 . 𝑡 +


1
2 𝑎𝑥𝑡
= 0 + 𝑣𝑖𝑐𝑜𝑠𝜃𝑖. 𝑡 + 0 = 𝑣𝑖𝑐𝑜𝑠𝜃𝑖. 𝑡 (4.12)

  * Theo phương _y_ : 𝑎𝑦 = −𝑔 = 𝑐𝑜𝑛𝑠𝑡 nên theo phương y chất điểm chuyển động thẳng


biến đổi đều với vận tốc ban đầu 𝑣𝑦𝑖 = +𝑣𝑖𝑠𝑖𝑛𝜃𝑖. Từ biểu thức (4.10), ta viết được phương trình chuyển động của chất điểm theo phương y ứng với hệ tọa độ đã chọn như hình 4.4 như sau:
𝑦𝑓 = 𝑦𝑖 + 𝑣𝑦𝑖. 𝑡 +
1
2 𝑎𝑦𝑡
= 0 + 𝑣𝑖𝑠𝑖𝑛𝜃𝑖. 𝑡 +
1 (−𝑔
2

)𝑡2

= 𝑣𝑖𝑠𝑖𝑛𝜃𝑖. 𝑡 −
1 𝑔𝑡2
2
(4.13)
của những chất điểm chuyển động ném nghiêng vẫn là phương trình bậc 2 của y phụ thuộc x theo quỹ đạo parabol.
_**Câu hỏi 4.2:**_ (i) Giả sử một vật chuyển động ném nghiêng với quỹ đạo parabol như hình 4.4, tại điểm nào trên quỹ đạo của vật vec-tơ vận tốc và vec-tơ gia tốc vuông góc với nhau? (a) không có điểm nào, (b) điểm cao nhất, (c) điểm xuất phát. (ii) Với cùng lựa chọn như trên, hỏi điểm nào trên quỹ đạo của vật vec-tơ vận tốc và vec-tơ gia tốc song song với nhau?
_**Tầm xa và độ cao cực đại của vật ném nghiêng:**_
Khi phân tích chuyển động ném nghiêng ta thường quan tâm đến hai đặc trưng: **tầm xa _R_** (là khoảng cách xa nhất theo phương ngang so với vị trí ban đầu) và **độ cao cực đại _h_** (là khoảng cách xa nhất theo phương đứng so với vị trí ban đầu) mà vật đạt được (hình 4.5).

  * **Độ cao cực đại _h_ :** Khi chất điểm đi đến điểm A – vị trí đạt độ cao cực đại, vận tốc theo phương y của nó bằng 0. Từ phương trình (4.11), cho vy = 0, ta suy ra thời gian mà


![0409](images/image44.jpeg)
_Hình 4.5 Tại điểm A, chất điểm đạt độ cao cực đại. Tại_
chất điểm đi từ O đến A là: 𝑡𝐴
= 𝑣𝑖𝑠𝑖𝑛𝜃 _𝑖_. Thay tA vào
𝑔
_điểm B, chất điểm đạt vị trí xa nhất theo phương ngang._
phương trình chuyển động (4.13), ta thu được biểu thức
độ cao cực đại của chất điểm:

𝑣2𝑠𝑖𝑛2𝜃𝑖

ℎ = _𝑖_

2𝑔

(4.15)

  * **Tầm xa _R_ :** Khi chất điểm đến điểm B – vị trí đạt khoảng cách xa nhất theo phương ngang, tọa độ y của chất điểm bằng 0. Từ phương trình (4.14), cho y = 0 ta suy ra biểu thức tính thời gian chất điểm đi từ O đến B. Cách khác, đối với bài toán ta đang xét, ta thấy tB = 2tA. Thay tB vào phương trình (4.12) ta thu được biểu thức tính tầm xa:


𝑣𝑖𝑠𝑖𝑛𝜃𝑖

![0410](images/image45.jpeg)𝑅 = 𝑣𝑖𝑐𝑜𝑠𝜃𝑖. 𝑡𝐵 = 𝑣𝑖𝑐𝑜𝑠𝜃𝑖. 2. 𝑔
𝑣2𝑠𝑖𝑛2𝜃𝑖
→ 𝑅 = _𝑖_

𝑔

(4.16)
_Lưu ý: Các kết quả này (4.15) và (4.16) chỉ đúng trong trường hợp chuyển động là đối xứng. Trong trường hợp độ cao ban đầu và độ cao cuối cùng của vật khác nhau thì phải tính bằng các công thức khác._
Từ các kết quả trên, ta xét trường hợp các góc bắn θ phụ nhau. Cụ thể như hình 4.6, nó mô tả quỹ đạo của một vật ném nghiêng được bắn từ gốc tọa độ với cùng tốc độ ban đầu

# Public_129

## ![](images/image1.png) Khái niệm về lực

Có thể phân các loại lực thành hai nhóm: (1) Lực do có tiếp xúc (lực đàn hồi của lò xo, lực căng dây, lực đàn hồi ở các điểm tiếp xúc giữa các vật…) (2) Lực của một trường lực (lực hấp dẫn, lực tĩnh điện, lực từ)

![](images/image2.jpeg)

_Hình 5.1: a, b, c lực do có tiếp xúc; d, e, f lực của một trường_
Bản chất vectơ của lực: Lực là đại lượng vectơ nên khi tìm lực cần chú ý đến điểm đặt, phương, chiều và độ lớn của lực. Khi tổng hợp các lực, cần chú ý qui tắc cộng vectơ.
Hình 5.2 minh họa 2 lực tác dụng vào móc của lực kế theo 2 cách khác nhau: 2 lực cùng phương và 2 lực vuông góc với nhau. Khi tác dụng dọc theo trục lò xo, lực F1 và F2 lần lượt làm lò xo giãn ra 1cm và 2cm (hình 5.2 a,b). Nhưng hai lực này tác dụng vuông góc với nhau thì lò xo giãn ra 2,24cm (hình 5.2d).

![](images/image3.jpeg)

_Hình 5.2: Các lực tác dụng lên lực kế: a. lực F1; b. lực F2; c. 2 lực F1 và F2 cùng phương chiều; d. 2 lực F1 và F2 vuông góc với nhau._

## ![](images/image5.png) Định luật Newton thứ nhất và các hệ qui chiếu quán tính

### Định luật Newton thứ nhất:

_Nếu một vật không tương tác với các vật khác thì ta có thể xác định một hệ qui chiếu trong đó vật có gia tốc bằng 0._

![](images/image6.jpeg)

_Hình 5.3: Miếng nhựa đặt trên đệm khí._

### Hệ qui chiếu quán tính

Một hệ qui chiếu mà định luật Newton thứ nhất được thỏa mãn gọi là _**hệ qui chiếu quán tính**_.
Một dạng phát biểu khác của định luật Newton thứ nhất:
Khi không có ngoại lực tác dụng và được quan sát từ một hệ qui chiếu quán tính, một vật đứng yên sẽ vẫn đứng yên và một vật chuyển động sẽ tiếp tục chuyển động với vận tốc không đổi (tức là chuyển động với tốc độ không đổi theo một đường thẳng).
Ví dụ như khi xét một miếng nhựa tròn đặt trên bàn đệm khí, và bàn này đặt trên mặt đất thì miếng nhựa này không tương tác với vật nào khác theo phương ngang nên gia tốc của nó theo phương ngang bằng không. Nếu bàn đệm khí này được đặt trên một con tàu chuyển động thẳng đều thì ta cũng quan sát được hiện tượng tương tự. Tuy nhiên, nếu tàu chuyển động có gia tốc thì hệ qui chiếu gắn với tàu không còn là hệ qui chiếu quán tính nữa. Một người đứng trên tàu sẽ thấy miếng nhựa chuyển động có gia tốc. Hệ qui chiếu gắn với tàu là _**hệ qui chiếu phi quán tính.**_ Mặc dầu vậy, một người quan sát đứng yên trên mặt đất vẫn thấy miếng nhựa chuyển động thẳng đều.
Một hệ qui chiếu chuyển động với vận tốc không đổi đối với các ngôi sao ở rất xa là một xấp xỉ tốt nhất cho một hệ qui chiếu quán tính. Trong nhiều trường hợp, Trái Đất cũng có thể xem là một hệ qui chiếu quán tính.
Khoảng trước năm 1600 thì người ta cho rằng trạng thái tự nhiên của vật chất là trạng thái nghỉ (đứng yên). Galileo là người đầu tiên đưa ra cách nhìn nhận mới về chuyển động và trạng thái tự nhiên của vật chất. Theo ông thì “Vận tốc mà ta truyền cho một vật chuyển động sẽ được bảo toàn nếu các nguyên nhân bên ngoài làm chậm chuyển động bị loại bỏ”. Lúc đó vật không tìm về “trạng thái nghỉ bản chất” nữa.
_**Câu hỏi 5.1:**_ Hãy chọn phát biểu đúng trong các phát biểu sau:a) Một vật có thể chuyển động khi không có lực tác dụng lên vật đó. b) Một vật có thể không chuyển động khi có lực tác dụng lên vật đó. c) Cả (a) và (b) đều đúng. d) Cả (a) và (b) đều sai.

### Cách phát biểu khác của định luật Newton thứ nhất

Nếu không có ngoại lực tác dụng và được quan sát từ một hệ qui chiếu quán tính thì một vật đứng yên sẽ đứng yên và một vật chuyển động sẽ tiếp tục chuyển động với vận tốc không đổi (tức là chuyển động thẳng đều).
Nói cách khác, nếu không có lực tác dụng lên vật thì gia tốc của vật bằng không. Bất kỳ vật cô lập nào cũng đứng yên hoặc chuyển động thẳng đều. Khuynh hướng chống lại sự thay đổi vận tốc của một vật được gọi là _**quán tính**_.

### Định nghĩa lực

Lực là nguyên nhân làm thay đổi chuyển động của một vật

## ![](images/image7.png) Khối lượng

### Định nghĩa khối lượng

**Khối lượng** là một thuộc tính của vật xác định mức độ chống lại sự thay đổi vận tốc của nó. Đơn vị của khối lượng trong hệ đo lường quốc tế là kilôgram (kg). Các thí nghiệm đã cho thấy, dưới tác dụng của một lực cho trước thì vật có khối lượng càng lớn sẽ thu được gia tốc càng nhỏ. Giả sử cho cùng một lực tác dụng lên hai vật có khối lượng lần lượt là m1 và m2 và hai vật lần lượt thu được các gia 𝑎⃗1 𝑣à 𝑎⃗2. Tỷ số hai khối lượng của hai vật này được định nghĩa bằng nghịch đảo của tỷ số hai độ lớn của hai gia tốc tương ứng:


| m1 ≡a2m2a1 | (5.1) |
| --- | --- |

 

Các kết quả thí nghiệm cho thấy: Với một lực cho trước tác dụng lên vật, độ lớn gia tốc mà vật thu được tỷ lệ nghịch với khối lượng của vật.
Khối lượng là thuộc tính cố hữu của một vật, không phụ thuộc vào môi trường xung quanh vật và phương pháp được dùng để đo lường nó. Khối lượng là đại lượng vô hướng. Khối lượng tuân theo các phép tính số học thông thường.

#### Khối lượng và trọng lượng:

Khối lượng và trọng lượng (weight) là hai đại lượng khác nhau. Trọng lượng là độ lớn của lực hấp dẫn tác dụng lên vật. Trọng lượng có thể thay đổi tùy theo vị trí của vật.
Ví dụ:

  * wearth = 180 lb; wmoon ~ 30 lb

  * mearth = 2 kg; mmoon = 2 kg


## ![](images/image8.png) Định luật Newton thứ hai

Khi xem xét từ một hệ quy chiếu quán tính, gia tốc của một vật tỉ lệ thuận trực tiếp với lực tổng hợp tác dụng lên vật và tỉ lệ nghịch với khối lượng của nó.
Lực là nguyên nhân của _**các thay đổi**_ trong chuyển động, được đo thông qua gia tốc.
Cần lưu ý là một vật có thể chuyển động mà không cần có lực tác dụng. Không được diễn giải rằng lực là nguyên nhân của chuyển động.
Về mặt đại số thì:


| ![](images/image9.png)![](images/image10.png)![](images/image11.png)a∝
∑F→ ∑F=mam | (5.2) |
| --- | --- |

 

![](images/image15.png)ở đây, hệ số tỉ lệ được chọn bằng 1 và các tốc độ chuyển động của các vật phải nhỏ hơn nhiều so với tốc độ ánh sáng. Trong đó, ∑ **F** là lực tổng hợp, là tổng vectơ của tất cả các lực tác dụng lên vật (còn gọi là lực toàn phần).
Định luật Newton thứ 2 cũng có thể được biểu diễn theo các thành phần:
Σ _Fx_ = _max_
Σ _Fy_ = _may_
Σ _Fz_ = _maz_
![](images/image16.png)Lưu ý: _m_ **a** không phải là một lực.
Tổng tất cả các lực bằng tích của khối lượng của vật với gia tốc của nó.
_**Đơn vị của lực**_ : Trong SI, đơn vị của lực là **newton** (N)

  * 1 N = 1 kg·m / s2


Theo hệ đơn vị của Mỹ thì đơn vị của lực là **pound** (lb).

  * 1 lb = 1 slug·ft / s2


Quy đổi đơn vị: 1 N ~ ¼ lb
_**Câu hỏi 5.2:**_ Một vật chuyển động không gia tốc. Hãy chọn phát biểu **không đúng** trong các phát biểu sau:a) Chỉ có một lực tác dụng lên vật đó. b) Không có lực nào tác dụng lên vật. c) Nhiều lực tác dụng lên vật nhưng các lực này triệt tiêu lẫn nhau.
_**Câu hỏi 5.3:**_ Khi đẩy một vật từ trạng thái nghỉ trượt qua một mặt sàn không ma sát với lực không đổi trong khoảng thời gian Δt, kết quả vật thu được tốc độ v. Sau đó, lặp lại thí nghiệm trên với lực đẩy lớn hơn 2 lần. Hỏi để đạt được vận tốc cuối cùng như thí nghiệm trên thì thời gian đẩy vật là?a) 4Δt; b) 2 Δt; c) Δt; d) Δt.

## ![](images/image17.png) Lực hấp dẫn và khối lượng

![](images/image18.png)Lực hấp dẫn **F** _g_ là lực mà Trái đất tác dụng lên một vật. Lực này hướng về tâm của Trái đất, và độ lớn của nó được gọi là **trọng lượng** của vật.
Theo định luật Newton thứ 2 thì:


| ![](images/image19.png)![](images/image20.png)Fg=mg | (5.5) |
| --- | --- |

 

Do đó, trọng lượng của vật:


| Fg= mg | (5.6) |
| --- | --- |

 

#### Nói thêm về trọng lượng:

Do trọng lượng phụ thuộc vào gia tốc trọng trường (g) nên nó sẽ thay đổi theo vị trí.

  * Càng lên cao thì g và trọng lượng càng giảm.

  * Điều này cũng áp dụng được cho các hành tinh khác, nhưng g thay đổi theo hành tinh nên trọng lượng cũng thay đổi từ hành tinh này sang hành tinh khác.


Trọng lượng không phải là thuộc tính cố hữu của vật. Trọng lượng là thuộc tính của _một hệ_ các vật: vật và Trái đất. Về đơn vị thì kg không phải là đơn vị của trọng lượng. Công thức 1kg=2,2lb là công thức tương đương và chỉ đúng trên mặt đất.

#### Khối lượng hấp dẫn và khối lượng quán tính:

Trong các định luật của Newton, khối lượng là khối lượng **quán tính** và đo bằng sự cản trở đối với sự thay đổi chuyển động của vật. Còn trong công thức (5.6) khối lượng _m_ cho biết lực hấp dẫn giữa vật và Trái Đất. Các thí nghiệm cho thấy khối lượng quán tính và khối lượng hấp dẫn có cùng giá trị.
_**Câu hỏi 5.4:**_ Giả sử rằng bạn đang gọi một cuộc điện thoại liên hành tinh với bạn của bạn ở trên Mặt Trăng. Người bạn đó kể rằng anh ta mới thắng được 1 Newton vàng trong một cuộc thi. Anh ta khuyên bạn nên tham dự cuộc thi đó phiên bản Trái Đất và nếu chiến thắng cũng được 1 Newton vàng. Hỏi nếu điều đó xảy ra, ai sẽ giàu hơn?, a) Bạn sẽ giàu hơn; b) Bạn của bạn giàu hơn; c) Cả 2 giàu bằng nhau.

## ![](images/image21.png) Định luật Newton thứ 3

![](images/image22.png)![](images/image22.png)Nếu hai vật tương tác với nhau, lực **F** 12 do vật 1 tác dụng lên vật 2 bằng về độ lớn nhưng ngược chiều với lực **F** 21 do vật 2 tác dụng lên vật 1.


| ![](images/image25.png)F12 =
−F21 | (5.7) |
| --- | --- |

 

![](images/image26.png)Lưu ý về ký hiệu: **F** AB là lực do A tác dụng lên B. Một cách phát biểu khác của định luật:
![](images/image27.jpeg)Lực tác dụng và lực phản tác dụng (phản lực) bằng
nhau về độ lớn nhưng ngược chiều.

  * Một trong hai lực là lực tác dụng, lực kia là phản lực.

  * Lực và phản lực phải tác dụng lên hai vật khác nhau và cùng loại với nhau.


Ví dụ 1 về lực – phản lực: Ở hình 5.5, hai vật tác dụng vào nhau bởi các lực có độ lớn bằng nhau nhưng ngược chiều nhau.
![](images/image29.png)![](images/image30.png)![](images/image31.png)Ví dụ 2 về lực – phảnlực: Trong hình 5.6a ở trên, lực pháp tuyến1 (normal force) do mặt bàn tác dụng lên màn hình ( **n = F** tm ) là phản lực của lực tác dụng của màn hình lên mặt bàn (


| ![0506a](images/image32.jpeg)a | ![0506b](images/image33.jpeg)b | ![0506c](images/image34.jpeg)c |
| --- | --- | --- |

 

![](images/image35.png)![](images/image37.png)Lực tác dụng của Trái đất lên màn hình ( **F** g = **F** Em ) có độ lớn bằng với lực mà màn hình tác dụng lên Trái đất ( **F** mE ) nhưng ngược chiều.
Khi giải toán bằng cách vận dụng các định luật của Newton, ta có thể vẽ các lực tác dụng lên vật như trong hình b (còn gọi là sơ đồ lực). Một cách khác là ta có thể vẽ sơ đồ lực trong đó sử dụng mô hình chất điểm cho vật, ta được một sơ đồ như trong hình c (gọi là free-body diagram).
Khi vẽ các sơ đồ, cần lưu ý là chỉ vẽ những lực tác dụng lên vật đang xét (kể cả các lực do trường lực gây ra). Các lực tác dụng lên vật xem như là tác dụng lên chất điểm thay thế cho vật. Sơ đồ này giúp ta tách các lực tác dụng lên vật đang xét mà bỏ qua các lực khác khi phân tích.
_**Câu hỏi 5.5:**_ i) Nếu một con ruồi va chạm vào kính chắn gió của một chiếc xe buýt đang chạy rất nhanh, thì lực nào sau đây lớn hơn? a) của con ruồi tác dụng vào xe, b)của xe buýt tác dụng vào ruồi, c)2 vật tác dụng các lực bằng nhau.

  2. Vật nào có gia tốc lớn hơn? a) Con ruồi, b) Xe buýt, c) 2 vật có gia tốc bằng nhau.


1 Còn gọi là phản lực, lực đàn hồi vuông góc

## ![](images/image38.png) Các mô hình phân tích sử dụng định luật 2 Newton

Trong phần này, ta thảo luận về hai mô hình phân tích để giải toán trong đó vật cân bằng hoặc chịu tác dụng của các lực không đổi. Để giải các bài toán ta đơn giản hóa mô hình bằng các giả định sau:

  * Các vật có thể được mô hình hóa thành các chất điểm (particle).

  * Chỉ quan tâm đến các ngoại lực tác dụng lên vật (có thể bỏ qua phản lực – vì phản lực tác dụng lên vật khác).

  * Tạm thời bỏ qua ma sát ở các bề mặt.

  * Khối lượng của các sợi dây là không đáng kể: Lực của dây tác dụng lên vật hướng ra xa vật và song song với dây. Khi dây được buộc vào vật và kéo vật đi thì độ lớn của lực này là lực căng dây


### Mô hình phân tích: Hạt ở trạng thái cân bằng

![0507ab](images/image39.jpeg)Nếu gia tốc của một vật (xem là một chất điểm) bằng không, vật được gọi là ở trạng thái cân bằng. Mô hình này gọi là mô hình chất điểm ở trạng thái cân bằng. Về mặt toán học, lực tổng hợp tác dụng lên vật bằng không:

![](images/image40.png)

hay
∑ _Fx_ = 0
và ∑ _Fy_ = 0
Ví dụ về cân bằng: một cái đèn được treo bằng một dây xích nhẹ (hình 5.7). Các lực tác dụng lên đèn gồm:

  * Lực hấp dẫn hướng xuống dưới

  * Lực căng của dây xích hướng lên trên. Áp dụng điều kiện cân bằng, ta được


∑ _Fy_ = 0 → _T_ − _Fg_ = 0 → _T_ = _Fg_

### Mô hình phân tích: Hạt dưới tác dụng của một lực tổng hợp

_Hình 5.7: Một chiếc đèn được treo trên trần nhà nhờ sợi xích._
Nếu một vật được mô hình hóa như một chất điểm chịu một gia tốc, phải có lực tổng hợp khác không tác dụng lên nó. Mô hình dùng trong trường hợp này là mô hình chất điểm dưới tác dụng của một lực tổng hợp. Ta giải bài toán theo các bước sau:

  * Vẽ sơ đồ lực.

  * ![](images/image41.png)Viết định luật 2 Newton: ∑ _F_ = _m_. _a_

  * Xét theo các phương _x_ , _y_.


![](images/image42.png)![](images/image18.png)Một người kéo một cái thùng như hình 5.8 a. Các lực tác dụng lên thùng: lực căng dây **T**
![](images/image43.png), trọng lực **F** _g_ , và phản lực pháp tuyến **n** tác dụng bởi sàn nhà.
![](images/image44.jpeg)Áp dụng định luật 2 Newton theo các phương _x_ , _y_ :
∑ _Fx_ = _T_ = _max_
∑ _Fy_ = _n_ − _Fg_ = 0 → _n_ = _Fg_
Giải hệ phương trình theo các ẩn.
Nếu lực căng dây là không đổi thì gia tốc _a_ là hằng số, ta có thể áp dụng các phương trình động học để mô tả đầy đủ hơn về chuyển động của thùng.

#### ![](images/image43.png)Lưu ý về phản lực pháp tuyến n :

Lực pháp tuyến không phải là luôn bằng trọng lực tác dụng lên vật. Ví dụ như trong hình bên cạnh thì
∑ _Fy_ = _n_ − _Fg_ − _F_ = 0 nên: _n_ = _mg_ \+ _F_
Nó cũng có thể nhỏ hơn trọng lực.

### Gợi ý để giải toán: Áp dụng các định luật Newton Khái niệm hóa:

  * Vẽ một sơ đồ

  * Chọn hệ tọa độ thích hợp cho mỗi vật


### Phân loại:

  * ![](images/image40.png)![](images/image46.png)![](images/image47.png)Mô hình chất điểm cân bằng: ∑ **F** = 0

  * Mô hình chất điểm chịu tác dụng của lực tổng hợp:


### Phân tích:

  * Vẽ sơ đồ lực cho mỗi vật

  * Chỉ vẽ các lực tác dụng lên vật

  * Tìm các thành phần theo các trục tọa độ

  * Bảo đảm rằng các đơn vị là nhất quán


∑ **F** = _m_ **a**

  * Áp dụng các phương trình thích hợp dưới dạng thành phần

  * Giải phương trình để tìm các ẩn số


### Hoàn thành bài giải

  * Kiểm tra các kết quả xem có phù hợp với sơ đồ lực không

  * Kiểm tra các giá trị đặc biệt


### Bài tập mẫu 5.2: đèn giao thông

Một hộp đèn giao thông có trọng lượng 122 N được treo trên một sợi dây buộc vào hai sợi dây khác như hình 5.10a. Các sợi dây phía trên không chắc bằng dây thẳng đứng
nên sẽ bị dứt nếu lực căng lớn hơn 100 N. Hỏi hộp đèn có đứng yên được không hay là một trong các sợi dây sẽ bị đứt.

![0510a](images/image48.jpeg)![0510b](images/image49.jpeg)![0510c](images/image50.jpeg)

_Hình 5.10: Đèn giao thông được treo nhờ các sợi dây cáp_

### Giải

**Khái niệm hóa.** Hộp đèn giao thông Giả thiết là các sợi dây không bị đứt Không có cái gì chuyển động
**Phân loại.** Bài toán như là một bài toán về cân bằng Không có chuyển động, vậy gia tốc bằng không
Mô hình chất điểm cân bằng

### Phân tích.

Vẽ sơ đồ các lực tác dụng lên hộp đèn
Vẽ sơ đồ lực tác dụng lên nút buộc ở vị trí các dây nối với nhau: Nút buộc là điểm phù hợp để chọn vì mọi lực ta quan tâm tác dụng dọc theo các đường dây sẽ đi đến nút buộc.
Áp dụng các phương trình cân bằng cho nút buộc Với hộp đèn, ta có:
∑ _Fy_ = 0 → _T_ 3 − _Fg_ = 0 hay _T_ 3 = _F g_
Với nút buộc:
∑ _Fx_ = − _T_ 1 cosθ1 + _T_ 2 cosθ2 = 0
∑ _Fy_ = _T_ 1 sinθ1 + _T_ 2 sinθ2 − _Fg_ = 0
Giải các phương trình, ta được:

_T_ 1 =

122N
sin37,0° + cos37,0°tan53,0°
= 73,4N
_T_ = (73,4N) cos37,0°  = 97,4N
2  

### Bài tập mẫu 5.3: Mặt phẳng nghiêng

![0511](images/image51.jpeg)Một chiếc xe khối lượng m đỗ trên một đường dốc nghiêng có đóng băng như trong hình 5.11a.

  1. Tìm gia tốc của xe, giả thiết mặt đường không có ma sát


### Giải:

**Khái niệm hóa:** dùng hình 5.11a để khái niệm hóa tình huống của bài toán. Từ kinh nghiệm hằng ngày, ta biết rằng một chiếc xe trên dốc nghiêng sẽ chuyển động nhanh dần xuống dưới.
**Phân loại** : đây là chất điểm dưới tác dụng của lực tổng hợp do xe chuyển
động có gia tốc.
**Phân tích:** Các lực tác dụng vào vật:
Phản lực vuông góc với mặt nghiêng.
Trọng lực hướng thẳng đứng xuống dưới.
_Hình 5.11: Một chiếc xe hơi trên mặt phẳng nghiêng không ma sát_
Chọn hệ trục tọa độ với x dọc theo mặt nghiêng và y vuông góc với mặt nghiêng. Thay trọng lực bởi các thành phần của nó (theo x và y).
Áp dụng mô hình chất điểm chuyển động dưới tác dụng của lực tổng hợp theo phương x và chất điểm cân bằng theo phương y.
∑ _Fx_ = _mg_ sinθ = _max_
∑ _Fy_ = _n_ − _mg_ cosθ = 0
Giải phương trình thứ nhất, ta được _ax_ = _g_ sinθ

  2. Giả sử xe được thả từ trạng thái nghỉ từ đỉnh dốc và khoảng cách từ cản trước của xe đến chân dốc là _d_. Xe phải mất bao lâu để cản trước của nó chạm chân dốc và tốc độ của xe lúc đến chân dốc.


### Giải:

Đây là nội dung liên quan đến phần động học. Dùng gia tốc tìm được ở câu a để thay vào các phương trình động học. Từ đó tìm được:

_t_ =

và _vxf_ =

### Trường hợp có nhiều vật:

Khi có hai hay nhiều vật kết nối với nhau hoặc tiếp xúc nhau, có thể áp dụng các định luật Newton cho hệ như một vật tổng thể hay từng vật riêng rẽ. Ta có thể chọn một cách để giải bài toán và dùng cách khác để kiểm tra lại kết quả.

## ![](images/image52.jpeg)![](images/image54.png) Các lực ma sát

Khi một vật chuyển động trên bề mặt hoặc xuyên qua một môi trường nhớt thì sẽ xuất hiện sức cản chuyển động. Đó là do các tương tác giữa vật và môi trường quanh nó. Sức cản này được gọi là lực ma sát.

### Lực ma sát nghỉ (tĩnh)

Lực ma sát nghỉ giữ cho vật không chuyển động. Chừng nào vật chưa chuyển động thì lực ma sát nghỉ đúng bằng lực tác động từ bên ngoài ƒs = F
Nếu F tăng thì _f_ s tăng và ngược lại.
Gọi _µs_ là hệ số ma sát nghỉ thì _ƒs_ ≤ _µs n_

  * Lưu ý: dấu bằng xảy ra khi các mặt bắt đầu trượt lên nhau.


### Lực ma sát trượt (động)

Lực ma sát trượt tác dụng khi vật chuyển động.
Hệ số ma sát trượt _µk_ có thể thay đổi theo tốc độ của vật, tuy nhiên, ta bỏ qua sự thay đổi này.
_ƒk_ = _µk n_
Khảo sát lực ma sát: Để khảo sát, ta tăng dần độ lớn của ngoại lực F và ghi lại giá trị của lực ma sát. Chú ý thời điểm vật bắt đầu trượt. Đồ thị biểu diễn quan hệ giữa lực ma sát và ngoại lực cho trên hình 5.16c.

### Lưu ý:

  * Các phương trình này chỉ quan tâm đến độ lớn của các lực, chúng không phải là phương trình vec-tơ.

  * Với ma sát nghỉ ( _fs_ ), dấu bằng chỉ đúng khi vật sắp chuyển động, các bề mặt sắp trượt lên nhau. Nếu các bề mặt chưa trượt lên nhau thì dùng dấu nhỏ hơn

  * Hệ số ma sát phụ thuộc vào các mặt tiếp xúc.

  * Lực ma sát nghỉ (tĩnh) thường lớn hơn lực ma sát trượt (động).

  * Hướng của lực ma sát ngược với hướng của chuyển động và song song với các mặt tiếp xúc.

  * Hệ số ma sát hầu như không phụ thuộc vào diện tích mặt tiếp xúc.


### Ma sát trong các bài toán dùng các định luật Newton

Ma sát là một lực, do đó chỉ cần thêm nó vào trong các định luật Newton.
![](images/image55.jpeg)Các qui tắc về ma sát cho phép ta xác định hướng và độ lớn của lực ma sát.

### Bài tập mẫu 5.6: thí nghiệm xác định μs và μk

Một khối hộp đang nằm trên một mặt nghiêng như hình 5.15. Nâng dần góc nghiêng cho đến khi hộp bắt đầu trượt. Chứng tỏ rằng có thể tìm được hệ số ma sát nghỉ μs theo góc tới hạn θ.

### Giải:

**Khái niệm hóa:** Tưởng tượng rằng khối hộp có xu hướng trược xuống dưới do tác dụng của trọng lực. Hộp trượt xuống nên ma sát sẽ hướng lên phía trên.
**Phân loại:** Khối hộp chịu tác dụng của nhiều lực khác nhau, tuy nhiên, nó chưa trượt xuống dốc nên đây là bài toán _chất điểm cân bằng._
![](images/image56.png)![](images/image43.png)![](images/image57.png) **Phân tích:** Sơ đồ lực trên hình 5.15 cho thấy các lực tác dụng vào hộp gồm: trọng lực _m_ **g** , phản lực **n** và lực ma sát nghỉ **f** _s_ . Chọn trục _x_ dọc theo mặt nghiêng và _y_ vuông góc với mặt nghiêng.
∑ _Fx_ = _mg_ sinθ − _fs_ = 0

∑ _Fy_

= _n_ − _mg_ cosθ = 0
Giải hệ phương trình ta có _fs_ = _mg_ sinθ = _n_ tanθ
Với góc nghiêng tới hạn θc thì lực ma sát nghỉ bằng _f s_ = μ _sn_ nên
μ _s_ = tanθ _c_ .
**Hoàn tất:** Khi hộp bắt đầu trượt thì θ ≥θc. Hộp trượt có gia tốc xuống dưới thì lực ma sát trượt _fk_ = μ _kn_ . Tuy nhiên, nếu giảm góc q thì vật cũng có thể trượt xuống, nếu vật
trượt thẳng đều thì
μ _k_ = tanθ _c_ ′
với θ _c_ ′ < θ _c_
**Lưu ý:** Với bố trí thí nghiệm như trên thì ta có thể xác định hệ số ma sát bằng thực nghiệm: _µ_ = tan θ

  * Với _µs_ , sử dụng góc nghiêng khi khối hộp bắt đầu trượt.

  * Với _µk_ , sử dụng góc nghiêng khi mà khối hộp trượt xuống với tốc độ không đổi.


### Bài tập mẫu 5.7: Một quả bóng khúc côn cầu đang trượt

### 

Một quả bóng khúc côn cầu trượt trên mặt băng với tốc độ ban đầu là 20,0 m/s. Quả bóng trượt được 115 m trước khi dừng lại. Hãy xác định hệ số ma sát trượt giữa quả bóng và băng.

### ![0519](images/image58.jpeg)Giải:

**Khái niệm hóa:** Giả sử quả bóng chuyển động sang phải như hình 5.16. Lực ma sát trượt tác dụng về bên phải và làm quả bóng chuyển động chậm lại cho đến khi dừng hẳn.
**Phân loại:** Các lực tác dụng lên quả bóng như trong hình 5.16, nhưng bài toán lại cho các biến số về động học. Do đó, có thể phân loại bài toán bằng nhiều cách khác nhau. Theo phương thẳng đứng, đây là bài toán
chất điểm cân bằng (tổng lực tác dụng lên vật bằng 0). Theo phương ngang, là bài toán chất điểm có gia tốc không đổi.
_Hình 5.16: quả khúc con cầu trượt có ma sát trên mặt băng_
**Phân tích:** Vẽ sơ đồ lực tác dụng lên vật, lưu ý đến lực ma sát (ngược chiều chuyển động, song song với mặt tiếp xúc).
Áp dụng mô hình chất điểm chịu tác dụng của lực tổng hợp theo phương _x_ :
∑ _Fx_ = − _fk_ = _max_
Áp dụng mô hình chất điểm cân bằng theo phương _y_ :
∑ _Fy_ = _n_ − _mg_ = 0
Giải hệ phương trình, với định nghĩa lực ma sát trượt, ta được:
_ax_ = −μ _kg_
Sau khi tìm được gia tốc, áp dụng mô hình động học, ta tìm được
_v_ 2

μ _k_ = __xi__

2 _gxf_

thay số:
μ _k_ = 0,117
**Hoàn tất:** Lưu ý rằng μ _k_ không có thứ nguyên và có giá trị bé, không đổi với một vật trượt trên mặt băng.

### Bài tập mẫu 5.8: Gia tốc của hai vật nối với nhau khi có ma sát

Một khối hộp có khối lượng _m_ 2 nằm trên một mặt ngang, nhám được nối với một quả cầu khối lượng _m_ 1 bằng một sợi dây nhẹ vắt qua một ròng rọc nhẹ, không ma sát như trong hình 5.20a. Tác dụng vào khối hộp một lực có độ lớn _F_ hợp với phương ngang một góc θ và khối hộp chuyển động sang phải. Hệ số ma sát trượt giữa khối hộp và mặt ngang là μ _k_ Tìm độ lớn của gia tốc của hai vật.
![0520](images/image59.jpeg)
_Hình 5.17: hệ 2 vật nối nhau khi có ma sát._

### Giải:

![](images/image60.png) **Khái niệm hóa:** Hình dung xem chuyện gì xảy ra khi tác dụng lực **F** vào khối hộp. Giả sử lực đủ lớn hơn lực ma sát nghỉ nhưng không đủ lớn để nhất hộp lên, hộp sẽ trượt sang phải và quả cầu được kéo lên.
**Phân loại:** Bài toán này là bài toán hai _chất điểm dưới tác dụng của lực tổng hợp_. Vì khối hộp không bị nhấc lên nên theo phương thẳng đứng, khối hộp được xem là _chất điểm cân bằng_.
**Phân tích:** Vẽ sơ đồ lực cho từng vật (hình 5.17b và 5.17c).
Áp dụng mô hình chất điểm chịu tác dụng của lực tổng hợp cho khối hộp theo phương ngang:
∑ _Fx_ = _F_ cosθ − _fk_ − _T_ = _m_ 2 _ax_ = _m_ 2 _a_ (1)
Áp dụng mô hình chất điểm cân bằng cho khối hộp theo phương thẳng đứng
∑ _Fy_ = _n_ \+ _F_ sinθ − _m_ 2 _g_ = 0 (2)
Áp dụng mô hình chất điểm chịu tác dụng của lực tổng hợp cho quả cầu theo phương thẳng đứng:
∑ _Fy_ = _T_ − _m_ 1 _g_ = _m_ 1 _ay_ = _m_ 1 _a_ (3)
Giải hệ phương trình, ta tìm được:
_a_ = _F_ (cosθ + μ _k_ sinθ ) − ( _m_ 1 \+ μ _k m_2 ) _g_
_m_ 1 + _m_ 2
(4)
**Hoàn tất:** Gia tốc của khối hộp có thể hướng sang phải hoặc trái tùy theo dấu của tử số trong phương trình (4). Nếu vận tốc của khối hộp hướng sang trái thì phải đổi dấu của _fk_ trong (1). Trong trường hợp đó, chỉ cần đổi hai dấu cộng (+) trong tử số của (4) thành dấu trừ (–).ss

# Public_130

## ![](images/image1.jpeg)![](images/image2.png) Chuyển động tròn không đều

Ở chương 4, chúng ta đã khảo sát chuyển động trên một đoạn đường tròn với tốc độ thay đổi thì ngoài gia tốc hướng tâm sẽ có thêm thành phần gia tốc tiếp tuyến. Điều đó, có nghĩa là lực tác dụng lên chất điểm cũng có thể phân tích ra thành phần hướng tâm và thành phần tiếp tuyến.
![](images/image3.png)Bởi vì, gia tốc tổng cộng có dạng: _a_ = _ar_ \+ _at_ nên tổng hợp
![](images/image4.png)lực tác dụng lên chất điểm được biểu diễn là:
![](images/image7.png)Vectơ ∑
là lực hướng tâm, có chiều vào tâm của quỹ
đạo tròn là lực gây ra gia tốc hướng tâm, còn vectơ ∑
tiếp tuyến với đường tròn, là lực
![](images/image7.png)![](images/image9.jpeg)gây ra gia tốc tiếp tuyến làm thay đổi tốc độ của chất điểm theo thời gian.
_**Câu hỏi 6.1:**_ Một hạt gỗ đục lỗ trượt dọc theo sợi dây có dạng như hình 6.6: a) Hãy vẽ các vectơ lực tác dụng lên hạt gỗ tại các vị trí A, B và C . b) Giả sử rằng hạt gỗ được tăng tốc với gia tốc tiếp tuyến không đổi khi chuyển động hướng sang phải. Hãy vẽ các vectơ lực tác dụng lên hạt gỗ tại các điểm A, B và C.
_Hình 6.6: một hạt gỗ chuyển động dọc theo sợi dây_

### Bài tập mẫu 6.5: Chuyển động tròn không đều theo phương thẳng đứng

![0609](images/image10.jpeg)Một quả cầu nhỏ khối lượng m được gắn vào đầu một sợi dây có chiều dài R và đang quay theo phương thẳng đứng quanh điểm O cố định như hình vẽ. Hãy xác định gia tốc tiếp tuyến của quả cầu và lực căng dây khi vận tốc của quả cầu là v và sợi dây tạo một với phương thẳng đứng một góc θ.

### Giải:

**Khái niệm:** So sánh chuyển động của quả cầu ở hình 6.7 và những đứa trẻ ở hình 6.4 thì thấy rằng cả hai đều chuyển động theo quỹ đạo tròn, nhưng điều khác ở đây là quả cầu chuyển động không đều, do đó, ở tại hầu hết các điểm trên quỹ đạo chuyển động của quả cầu, thành phần gia tốc tiếp tuyến được đóng góp bởi lực hấp dẫn.
**Phân loại:** Bài toán này sẽ sử dụng mô hình _chất điểm chuyển động dưới tổng hợp lực,_ và chịu tác dụng của lực hấp dẫn trong toàn bộ quá trình chuyển động.
**Phân tích:** Từ hình 6.7, các lực tác dụng lên quả
![](images/image11.png)![](images/image13.png)cầu chỉ có 2 lực: lực hấp dẫn của Trái Đất tác _Hình 6.7: Một quả cầu được gắn vào_
![](images/image14.png)dụng lên quả cầu
và _T_ lực căng dây.
_một sợi dây và quay theo phương_
Trọng lực
sẽ được phân tích thành 2 thành
_thẳng đứng._
phần, theo phương tiếp tuyến là _mgsinθ_ và theo phương hướng tấm là _mgcosθ_. Áp dụng định luật 2 Newton theo phương tiếp tuyến:
∑ _Ft_ = _mg_ sinθ = _mat_ → _at_ = _g_ sinθ
Áp dụng định luật 2 Newton theo phương hướng tâm:

_mv_ 2

∑ _Fr_ = _T_ − _mg_ cosθ = _mar_ = _R_
Do đó, đối với chuyển động tròn không đều. Lực căng dây được tính theo công thức:
 _v_ 2 
_T_ = _mg_  + cosθ 
 
(6.6)
Xét điểm trên cùng và dưới cùng của đường tròn. Ta thấy: Lực căng tại điểm dưới cùng là lớn nhất:
=  _v_ 2 
_T mg_  __bot__ \+ 1
 _Rg_ 

![](images/image16.png)

![](images/image17.jpeg)Lực quán tính là kết quả khi chúng ta xét chuyển động trong một hệ quy chiếu không (phi) quán tính.
Lực quán tính xuất hiện và tác dụng lên vật giống như một lực thực, tuy nhiên chúng ta không thể phát hiện vật thứ hai nào gây ra lực quán tính đó. Nên nhớ rằng lực thực luôn gây ra bởi tương tác giữa hai vật nào đó.
Lực quán tính dễ thấy nhất khi các vật chuyển động thẳng có gia tốc.

### Lực ly tâm

Đối với hệ quy chiếu gắn với hành khách (trên hình 6.8b), một lực xuất hiện đẩy cô ta nghiêng khỏi ghế về phía bên phải.
Đối với hệ quy chiếu gắn với Trái Đất, chiếc xe hơi tác dụng một lực về bên trái vào hành khách (hình 6.8c).
Lực đẩy hành khách ra ngoài được gọi là lực ly tâm. Nó là lực quán tính do xuất hiện gia tốc hướng tâm khi xe chuyển hướng.
Còn trên thực tế, lực ma sát chính là lực giữ cho hành khách chuyển động cùng với chiếc xe. Do đó, nếu lực ma sát không đủ lớn, hành khách sẽ tiếp tục chuyển động thẳng theo phương ban đầu theo định luật 1 Newton.

### Lực Coriolis

Đây là lực xuất hiện bởi sự thay đổi bán kính quỹ đạo của một vật trong một hệ quy chiếu đang quay.
Trong hình vẽ 6.9, kết quả của chuyển động quay của vòng xoay là đường cong của quả bóng ném.
Đối với người bắt bóng, một lực theo phương ngang tác dụng vào làm quả bóng chuyển động cong.

![](images/image19.jpeg)![](images/image20.jpeg)

_Hình 6.8: a. Khi chiếc xe đi vào đoạn đường rẽ sang trái thì hành khách bị nghiêng sang phải, lực tác dụng: b. đối với hành khách. c. đối với Trái Đất_
![](images/image21.jpeg)
_Hình 6.9: Khi 2 người bạn đứng trên một vòng xoay lớn, bạn cố gắng ném bóng thẳng về phía bạn mình. a. đối với người quan sát đứng dưới mặt đất. b. đối với người quan sát đứng cùng trên vòng quay._

### Ví dụ về lực quán tính:

Mặc dù lực quán tính không phải lực thực, nhưng nó lại gây ra những tác động thực. Ví
dụ:

  * Những vật trên xe hơi thường bị trượt đi.

  * Bạn cảm giác như bị đẩy ra ngoài khi ngồi trên một bề mặt đang quay.

  * Lực Coriolis chịu trách nhiệm cho chuyển động quay trong hệ thống thời tiết, bao gồm cả bão, và các dòng hải lưu.


_**Câu hỏi 6.2:**_ Một hành khách ngồi trên xe đang rẽ trái như hình 6.8. Chọn phát biểu đúng về lực theo phương nằm ngang nếu hành khách ấy đặt tay lên cửa sổ: a) Hành khách ấy ở trạng thái cân bằng bởi lực thực tác dụng sang bên phải và lực thực tác dụng sang bên trái. b) Hành khách chịu tác dụng của lực chỉ tác dụng sang bên phải. c) Hành khách chỉ bị lực thực tác dụng sang bên trái. d) Không có phát biểu nào ở trên đúng.

### Lực quán tính trong chuyển động thẳng

Đối với quan sát viên ở ngoài xe (hình a), gia tốc của quả cầu do thành phần nằm ngang của lực căng dây gây ra. Còn vật ở trạng thái cân bằng theo phương thẳng đứng

∑ _Fx_ = _T_ sinθ = _ma_

∑ _Fy_ = _T_ cosθ − _mg_ = 0
Đối với quan sát viên trên xe (hình b), tổng hợp lực tác dụng lên quả cầu bằng 0 và vật ở trạng thái cân bằng theo cả hai phương


| ![](images/image22.jpeg) | ![](images/image23.jpeg) |
| --- | --- |

 

_Hình 6.10: Một quả cầu nhỏ được treo trên một sợi dây cột trên trần một toa tàu. Các lực tác dụng lên quả cầu đối với: ass. hệ quy chiếu quán tính. b. hệ quy chiếu phi quán tính_
∑ _F_ ' _x_ = _T_ sinθ − _Ffictitious_ = _ma_

∑ _F_ ' _y_ = _T_ cosθ − _mg_ = 0

Và hai phương trình ở hai hệ quy chiếu sẽ thỏa mãn khi:
_Ffictiitous = ma_ (6.7)

## ![](images/image24.png) Chuyển động với lực cản

Chuyển động của một vật có thể trong một môi trường nào đó như chất lỏng, hoặc chất
![](images/image25.png)khí. Và môi trường sẽ tác dụng lên vật một lực cản khi vật chuyển động trong nó.
![](images/image25.png)Độ lớn của lực cản phụ thuộc vào nhiều yếu tố như: bản chất môi trường, tốc độ của
vật, hình dạng và kích thước của vật.
![](images/image25.png)Hướng của lực cản luôn ngược với hướng chuyển động của vật so với môi trường.
![](images/image25.png)gần như luôn tăng cùng với sự tăng của tốc độ. Độ lớn của lực cản phức tạp vào tốc độ. Chúng ta chỉ khảo sát hai trường hợp:
phụ thuộc rất

  * ![](images/image25.png)![](images/image25.png) tỉ lệ với tốc độ ( _v_ ): _đối với_ các trường hợp vật chuyển động với tốc độ nhỏ và các vật có kích thước nhỏ (ví dụ như các hạt bụi chuyển động trong không khí).

  * tỉ lệ với bình phương tốc độ ( _v_ 2 ): trong trường hợp vật có kích thước lớn (ví dụ như người nhảy dù).


### Lực cản tỉ lệ với tốc độ

![](images/image27.jpeg)![](images/image28.jpeg)![](images/image29.png)Lực cản có thể cho bởi công thức:

![](images/image30.png)(6.8)

Với _b_ phụ thuộc vào tính chất của môi trường và hình dáng, kích thước của vật. 𝑣⃗ là vận tốc của vật đối với môi trường. Dấu trừ trong công thức thể hiện lực cản ngược hướng với chiều chuyển động.

### Bài tập mẫu 6.6:

Xét một quả cầu nhỏ có khối lượng m đang rơi trong chất lỏng từ trạng thái nghỉ.
Những lực tác dụng lên vật:

  * Lực cản

  * Lực hấp dẫn


Kết quả của chuyển động là:
_mg_ − _bv_ = _ma_ = _m dv_
_dt_
_a_ = _dv_
= _g_ − _b v_
_dt m_
Lực cản tỉ lệ với tốc độ:

  * Tại thời điểm ban đầu, _v_ = 0 và _dv_ / _dt_ = _g_

  * Theo thời gian, _lực cản R tăng, còn gia tốc giảm dần._


Gia tốc của vật bằng 0 khi _R_ = _mg_
Lúc này, tốc độ v đạt đến tốc độ tốc giới hạn và không thay đổi nữa.
Vận tốc giới hạn
Để tìm vận tốc giới hạn, ta có _a_ = 0
_v_ = _mg_
_T b_
Giải phương trình vi phân, ta được:
_v_ = _mg_ (1− _e_ − _bt_ ![](images/image32.png) _m_ ) = _v_
(1− _e_ − _t_ ![](images/image33.png)τ )
Với _τ_ là hằng số thời gian, có độ lớn: τ = __m__
_b_

### Lực cản tỉ lệ thuận với bình phương tốc độ

![0614](images/image34.jpeg)Những vật chuyển động với tốc độ lớn trong không khí, lực cản của không khí sẽ tỉ lệ với bình phương vận tốc:
_R = ½ D_ ρ _Av 2_ (6.9)
Với _D_ là một đại lượng không thứ nguyên được gọi là hệ số cản, ρ là mật độ của không khí, _A_ là diện tích tiết diện vuông góc với vận tốc của vật, _v_ là tốc độ của vật.
Khảo sát một vật rơi trong không khí khi tính đến lực cản của không khí:
∑ _F_ = _mg_ − _1_ _D_ ρ _Av_ 2 = _ma a_ = _g_ −  __D_ ρ _A__  _v_ 2
2  2 _m_ 

 

Vận tốc giới hạn sẽ đạt được khi gia tốc tiến tới 0.
_Hình 6.12: Chuyển động của một vật rơi trong chất lỏng._
Giải các phương trình trên ta sẽ được: _v T_ =
(6.10)
_Bảng 6.1: Một vài tốc độ giới hạn_


| Vật thể | Khối lượng (kg) | Diện tích mặt cắt (m2) | Vận tốc giới hạn (m/s) |
| --- | --- | --- | --- |
| Người nhảy dù | 75 | 0,7 | 60 |
| Quả bóng chày (bán kính 3,7 cm) | 0,145 | 4,2.10-3 | 43 |
| Quả golf (bán kính 2,1 cm) | 0,046 | 1,4.10-3 | 44 |
| Hạt mưa đá (bán kính 0,5 cm) | 4,8.10-4 | 7,9.10-5 | 14 |
| Giọt mưa (bán kính 0,2 cm) | 3,4.10-5 | 1,3.10-5 | 9 |

# Public_131

Nhiều bài toán có thể giải được nhờ các định luật Newton và các nguyên lý liên quan. Tuy nhiên, về mặt lý thuyết có nhiều bài toán có thể giải được bằng các định luật Newton nhưng thực tế thì rất phức tạp. Các bài toán đó lại có thể giải một cách dễ dàng bằng một cách khác.
Khái niệm về _năng lượng_ là một trong những chủ đề quan trọng nhất trong khoa học và kỹ thuật. Mỗi quá trình vật lý xảy ra trong vũ trụ đều liên quan đến việc chuyển hóa từ dạng năng lượng này sang dạng năng lượng khác. Trên cơ sở khái niệm năng lượng, người ta đã phát triển những phương pháp mới cho phép giải các bài toán vật lý một cách dễ dàng mà khi giải bằng các định luật Newton thì lại rất khó khăn. Chương này sẽ giới thiệu khái niệm _hệ_ và các cách _lưu trữ năng lượng_ trong một hệ.

## ![](images/image1.png) Hệ và môi trường

Một hệ là một phần nhỏ của cả vũ trụ. Một hệ có thể là một vật hoặc một chất điểm, một tập hợp nhiều vật hoặc nhiều chất điểm, hay một vùng không gian nào đó. Một hệ sẽ có ranh giới với bên ngoài. Bên ngoài biên giới của hệ là _môi trường_. Biên giới của một hệ có thể là một bề mặt thực hoặc một bề mặt tưởng tượng, không nhất thiết trùng với một bề mặt thực. Biên giới chia vũ trụ thành hệ và môi trường. Kích thước và hình dạng của một hệ có thể thay đổi theo thời gian.
Ví dụ một hệ: Khi có một lực tác dụng vào một vật trong không gian trống rỗng thì hệ là vật đó, bề mặt của vật là ranh giới của hệ.
Những điều cần chú ý khi giải toán:

  * Xác định hệ

  * Cũng xác định một ranh giới hệ

  * Lực ảnh hưởng lên hệ từ môi trường tác động xuyên qua ranh giới của hệ.


## ![](images/image2.png) Công thực hiện bởi một lực không đổi

_**Công**_ (ký hiệu là _W_ ) thực hiện bởi một tác nhân tác dụng một ngoại lực không đổi lên hệ là một đại lượng được xác định bằng tích của độ lớn lực F với độ dịch chuyển Δ _r_ của điểm đặt lực nhân với cos _θ,_ với _θ_ là góc tạo bởi vectơ lực và vectơ độ dich chuyển.
_W_ = _F_ Δ _r_ cos _θ_ (7.1)
Chú ý rằng độ dịch chuyển ở đây là độ dịch chuyển của điểm mà lực tác dụng vào.
Lực sẽ không thực hiện công trên một vật chuyển động nếu điểm đặt lực không chuyển động cùng với phương dịch chuyển. Công thực hiện bởi một lực làm cho vật dịch chuyển có độ lớn bằng 0 khi lực vuông góc với phương dịch chuyển.

### Độ dịch chuyển trong công thức tính công

Nếu lực tác dụng vào một vật rắn được xem như một chất điểm thì độ dịch chuyển giống như độ dịch chuyển của chất điểm. Đối với vật biến dạng thì độ dịch chuyển
![0702](images/image4.jpeg)
_Hình 7.1 Một vật dịch chuyển dưới tác dụng của một lực không đổi._
![0703](images/image5.jpeg)của vật không giống với độ dịch chuyển mà lực tác dụng vào. Do đó, để xác định độ dịch chuyển chúng ta chỉ xét đến điểm mà lực tác dụng vào.
![](images/image6.png)Phản lực pháp tuyến và lực hấp dẫn không sinh ra công trên vật vì cos _θ_ = cos 90° = 0. Chỉ có lực **F** thực hiện công trên vật.
Dấu của công phụ thuộc vào hướng của lực và hướng của độ dịch chuyển. Công dương khi lực và độ dịch chuyển có cùng hướng, công âm khi chúng ngược hướng.
Công là một đại lượng vô hướng. Đơn vị của công là joule
(J).

  * 1 joule = 1 newton. 1 meter = kg.m²/s²

  * J = N.m


### Công là một dạng năng lượng trao đổi

Nếu công thực hiện trên một hệ nhận giá trị dương thì năng
_Hình 7.2 Phản lực pháp tuyến và trọng lực không sinh công, chỉ có lực_ 𝐹⃗
lượng được truyền vào hệ; còn nếu công thực hiện trên một hệ
nhận giá trị âm thì năng lượng thoát ra khỏi hệ. Nếu một hệ tương tác với môi trường ngoài thì sự tương tác đó có thể xem như sự trao đổi năng lượng truyền qua biên giới của hệ. Điều này dẫn đến một sự thay đổi của năng lượng dự trữ trong hệ.
_**Câu hỏi 7.1:**_ Lực hấp dẫn Mặt trời tác dụng lên Trái đất giữ cho Trái đất chuyển động trên quỹ đạo quanh Mặt trời. Giả sử quỹ đạo là đường tròn. Hỏi công của lực hấp dẫn này thực hiện khi Trái đất di chuyển một quãng đường trong một khoảng thời gian ngắn trên quỹ đạo là: (a) bằng không? (b) dương? (c) âm? (d) không thể xác định được?
_sinh công._

![](images/image7.jpeg)

_Hình 7.3 Hình cho câu hỏi 7.2._
_**Câu hỏi 7.2:**_ Trên hình 7.3, các lực có độ lớn bằng nhau, quãng đường dịch chuyển của vật sang phải bằng nhau. Hãy sắp xếp theo thứ tự giá trị của công do lực thực hiện trên vật từ dương nhất đến âm nhất.

## ![](images/image8.png) Tích vô hướng 2 vectơ

![](images/image9.png)![](images/image10.png)![](images/image11.png)Tích vô hướng của hai vectơ **A** và **B** , được kí hiệu là **A** ⋅ **B** và có giá trị bằng:
![](images/image12.png)![0706](images/image13.jpeg) **A** ⋅ **B** ≡ _A B cos_ θ
![](images/image9.png)![](images/image10.png)Với _θ_ là góc giữa hai vectơ **A** và **B**
![](images/image14.png)![](images/image16.png)![](images/image17.png)Tích vô hướng có tính chất giao hoán: và tính chất kết hợp:
Áp dụng vào công thức tính công, ta được:
_Hình 7.4 Tích vô hướng 2 vectơ._
![](images/image20.png)![](images/image21.png) _W_ = _F_ ∆ _r_ cosθ = **F** ⋅ ∆ **r** (7.2)

## ![](images/image24.png) Công được thực hiện bởi lực có độ lớn thay đổi

Để sử dụng công thức W = FΔrcos θ lực phải không đổi, do đó công thức này không thể sử dụng cho việc tính công của một lực biến thiên. Giả sử rằng trong khoảng dịch chuyển rất nhỏ Δx, Fx là hằng số thì trong khoảng đó W = FxΔx. Vì vậy, trên cả quãng đường dịch chuyển từ vị trí đầu xi đến vị trí cuối xf thì:
_x_
_W_ ≈ ∑ _Fx_ ∆ _x_
_xi_


| ![](images/image25.jpeg) | ![](images/image26.jpeg) |
| --- | --- |

 

## ![](images/image27.png) Thế năng của một hệ

Bây giờ chúng ta hãy xem xét một hệ gồm nhiều hơn một vật mà các vật bên trong hệ tương tác lực với nhau. Ví dụ, một hệ gồm cuốn sách và Trái đất, hai vật này tương tác với nhau bằng lực hấp dẫn. Ta sẽ thực hiện một công trên cuốn sách bằng cách nâng quyển sách thật chậm theo phương thẳng đứng, cuốn sách đã có một dời chuyển

![](images/image28.png)

Công thực hiện trên hệ phải xuất hiện như là sự tăng năng lượng của hệ. Vì trước và sau khi thực hiện công, quyển sách đều ở trạng thái nghỉ nên động năng của hệ không có sự thay đổi. Như vậy, năng lượng cung cấp cho hệ từ bên ngoài phải tồn trữ ở một dạng khác động năng của hệ. Khi cuốn sách được thả rơi hệ có động năng; như vậy, trước khi cuốn sách được thả rơi hệ phải có một khả năng (potential) để thu được động năng. Ta gọi cơ chế tích trữ năng lượng trước khi cuốn sách được thả rơi là _**thế năng**_ (potential energy).

![](images/image29.jpeg)

_Hình 7.10 Tác nhân bên ngoài nâng từ từ cuốn sách ở độ cao hi lên độ cao hf._
_**Thế năng là dạng năng lượng được xác định bởi cấu hình của một hệ mà trong đó các thành phần của hệ tương tác với nhau bằng các lực.**_ Các lực này là nội lực của hệ, chỉ liên quan đến tương tác giữa các thành phần của hệ với nhau. Thế năng luôn gắn liền với một hệ của 2 hay nhiều vật tương tác lẫn nhau.

### Thế năng hấp dẫn

Xét hệ gồm Trái Đất và cuốn sách như hình vẽ. Cuốn sách có khối lượng m đang nằm tại độ cao yi so với bề mặt Trái đất. Một tác nhân bên ngoài hệ nâng cuốn sách lến độ cao yf một cách chậm chạp để dịch chuyển không có gia tốc và do đó lực nâng có độ lớn bằng lực hấp dẫn mà Trái đất tác dụng lên cuốn sách. Công mà lực ngoài thực hiện trên hệ Cuốn sách - Trái đất là:
_Wext_
_Wext Wext_
= ( **F** app )⋅ ∆ **r**
![](images/image30.png)![](images/image31.png)= ( _mg_ ˆ **j** ) ⋅ ( _y f_ − _y i_ ) ˆ **j** 
= _mgyf_ − _mgyi_

(7.13)

Phương trình trên cho thấy công của ngoại lực thực hiện trên hệ bằng hiệu số giữa hai giá trị cuối và đầu của một đại lượng. Công này đã truyền cho hệ một năng lượng và năng lượng đó tích trữ ở một dạng được gọi là thế năng. Đại lượng mgy được gọi là **thế năng hấp dẫn** _Ug_ của hệ vật khối lượng m và Trái đất.
_Ug_ = _mgy_ (7.14)
Thế năng là một đại lượng vô hướng. Đơn vị của thế năng là joules (J). Công có thể làm thay đổi thế năng hấp dẫn của hệ
_W_ ext = _ΔUg_ (7.15)
_**Thế năng hấp dẫn**_ là năng lượng liên kết với một vật, phụ thuộc vào độ cao của vật đó trên bề mặt của Trái Đất. Thế năng hấp dẫn chỉ phụ thuộc vào độ cao của vật so với bề mặt Trái Đất. Khi giải các bài toán, chúng ta cần phải chọn một mốc quy chiếu sao cho thế năng hấp dẫn tại đó bằng một giá trị tham chiếu nào đó, thường là bằng 0. Việc chọn lựa mốc thế năng là tùy ý. Thông thường một vật nằm trên bề mặt của Trái Đất được xem như có thế năng hấp dẫn bằng 0. Hoặc các bài toán sẽ đề xuất một mốc thế năng để sử dụng.
_**Câu hỏi 7.4:**_ Hãy chọn câu trả lời đúng: Thế năng hấp dẫn của một hệ (a) luôn luôn dương.
(b) luôn luôn âm. (c) có thể âm hoặc dương.

### Thế năng đàn hồi

Thế năng đàn hồi là một loại năng lượng mà một hệ có lò xo sẽ tích trữ. Khi đó lực tương tác giữa các thành phần bên trong hệ là lực đàn hồi của lò xo.
Xét hệ gồm có một vật và một lò xo như trên hình vẽ. Lực đàn hồi lò xo tác dụng lên cái hộp là
_Fs_ = - _kx_
Công thực hiện bởi ngoại lực Fapp tác dụng lên hệ lò xo - hộp là:
Wext = ½ _kxf_ 2 – ½ _kxi_ 2 (7.16)
Trong đó xi và xf là vị trí đầu và cuối của vật tính từ vị trí cân bằng x = 0. Công này bằng với độ chênh lệch giữa giá trị đầu và giá trị cuối của một đại lượng gắn với cấu hình của hệ. Do đó thế năng đàn hồi của hệ vật - lò xo có thể được xác định bởi hệ thức:
Lúc đó ta cũng có phương trình:
_Us_ = ½ _kx_ 2 (7.17)
_W_ ext = _ΔUs_ (7.18)
Thế năng đàn hồi có thể hiểu là năng lượng dự trữ trong một lò xo bị biến dạng. Năng lượng dự trữ này có thể chuyển hóa thành động năng. Quan sát sự biến dạng của lò xo, có thể nhận thấy: Thế năng đàn hồi dự trữ trong lò xo bằng 0 khi lò xo không biến dạng (Us = 0 khi x
= 0); năng lượng được dự trữ trong lò xo chỉ khi lò xo bị giãn hay nén; thế năng đàn hồi lớn nhất khi lò xo đạt đến độ nén hoặc độ giãn lớn nhất; thế năng đàn hồi luôn luôn dương bởi vì x2 luôn dương.

![0716](images/image32.jpeg)

_Hình 7.11 Sự biến đổi năng lượng giữa thế năng đàn hồi và động năng của hệ._
Trên hình 7.11 là một biểu diễn đồ thị quan trọng về năng lượng của một hệ, được gọi là _**biểu đồ thanh năng lượng**_. Biểu đồ thanh năng lượng là một đồ thị quan trọng để biểu diễn thông tin về năng lượng của hệ. Trên biểu đồ thanh năng lượng, trục tung biểu diễn giá trị năng lượng, trục hoành cho thấy các loại năng lượng có trong hệ.
Trong hình 7.11a, không có năng lượng nào cả, bởi vì lò xo đang thả lỏng còn hộp thì không chuyển động.
Trong hình 7.11b và c, tác nhân bên ngoài thực hiện công trên hệ. Do lò xo bị nén lại nên có thế năng đàn hồi trong hệ. Không có động năng trong hệ vì hộp vẫn đang được giữ
Trong hình 7.11d, hộp được thả ra cho chuyển động về phía bên phải trong khi vẫn tương tác với lò xo. Do đó, thế năng đàn hồi của hệ giảm trong khi động năng của hệ tăng.
Trong hình 7.11e, lò xo trở về chiều dài ban đầu và hệ chỉ còn động năng do sự chuyển động của cái hộp.
![](images/image33.jpeg) _ **Câu hỏi 7.5:**_ Một trái banh gắn với một lò xo nhẹ được treo thẳng đứng như hình
7.12. Khi kéo trái banh xuống dưới khỏi vị trí cân bằng rồi thả ra thì trái banh sẽ dao động lên xuống.

  1. Nếu _hệ gồm trái banh, lò xo và Trái đất_ thì có những dạng năng lượng nào trong quá trình chuyển động đó: (a)


![](images/image34.jpeg)
_Hình 7.12 Câu hỏi 7.5._
động năng và thế năng đàn hồi (b) động năng và thế năng hấp dẫn (c) động năng, thế năng đàn hồi và thế năng hấp dẫn (d) thế năng đàn hồi và thế năng hấp dẫn.

  2. Nếu _hệ gồm trái banh và lò xo_ thì có những dạng năng lượng nào trong quá trình chuyển động đó: (a) động năng và thế năng đàn hồi (b) động năng và thế năng hấp dẫn (c) động năng, thế năng đàn hồi và thế năng hấp dẫn (d) thế năng đàn hồi và thế năng hấp dẫn.


## ![](images/image35.png) Lực bảo toàn và lực không bảo toàn

Trong phần này ta sẽ tìm hiểu một loại năng lượng có thể tồn trữ trong một hệ. Loại năng lượng đó liên hệ với nhiệt độ của hệ, được gọi là _nội năng_ , _E_ int. Trong ví dụ trên hình 7.13, giả sử ta dùng tay tác dụng lực gia tốc cuốn sách trượt sang phải trên một bề mặt của một chiếc bàn nặng. Ở đây, bề mặt có ma sát nên sau khi thôi tác dụng lực thì cuốn sách sẽ chuyển động chậm lại rồi dừng hẳn. Xét _hệ chỉ là bề mặt_ mà cuốn sách trượt trên đó. Lực ma sát mà cuốn sách tác dụng lên bề mặt thực hiện công. Khi cuốn sách chuyển động sang bên phải, lực ma sát tác dụng lên bề mặt hướng sang phải và điểm đặt lực cũng dịch chuyển sang phải. Do đó công thực hiện trên bề mặt là dương nhưng bề mặt không dịch chuyển
sau khi cuốn sách ngừng trượt. Công thực hiện trên hệ là công dương song cả động năng và thế năng của hệ không thay đổi. Vậy năng lượng đó nằm ở đâu?
Từ kinh nghiệm hằng ngày, có thể nhận biết rằng khi cuốn sách trượt trên bề mặt thì sẽ làm bề mặt nóng lên. Như vậy, công thực hiện trên hệ đã làm nóng hệ lên mà không tăng tốc độ hay thay đổi cấu hình của hệ. Người ta gọi năng lượng liên hệ với nhiệt độ của hệ là _nội năng_ , ký hiệu là _E_ int. Trong trường hợp này, ma sát đã thực hiện công trên bề mặt, truyền cho hệ một năng lượng dưới dạng nội năng còn động năng và thế năng của hệ vẫn giữ nguyên không thay đổi.
Bây giờ, ta xét hệ gồm có cuốn sách và bề mặt. Ban đầu hệ có động năng vì cuốn sách đang di chuyển. Trong khi cuốn sách trượt trên bề mặt thì nội năng của hệ tăng lên vì cả cuốn sách và bề mặt đều ấm hơn trước đó. Khi cuốn sách dừng lại, động năng của hệ đã chuyển hóa hoàn toàn thành nội năng của hệ. Ở đây, lực ma sát – một lực không bảo toàn, tác dụng giữa các thành phần của hệ đã chuyển hóa động năng của hệ thành nội năng.

### Lực bảo toàn (lực thế)

Công thực hiện bởi một lực tác dụng lên một chất điểm làm chất điểm này chuyển động giữa hai điểm mà không phụ thuộc vào quỹ đạo chuyển động của chất điểm đó thì lực này được gọi là _**lực bảo toàn (lực thế).**_ Do đó, công thực hiện bởi lực bảo toàn tác dụng lên một chất điểm chuyển động trên một quỹ đạo kín bằng 0. Quỹ đạo kín là quỹ đạo mà điểm đầu trùng với điểm cuối.
Lực hấp dẫn và lực đàn hồi là những ví dụ điển hình của lực bảo toàn.
Thế năng của một hệ gắn liền với một lực bảo toàn nào đó tác dụng giữa các thành phần của hệ đó. Một cách tổng quát, công Wint được thực hiện bởi một lực bảo toàn do một thành phần của hệ tác dụng lên một thành phần khác của hệ khi cấu hình của hệ thay đổi sẽ bằng hiệu thế năng của hệ tại vị trí đầu và vị trí cuối.
_Wint_ = _Ui – Uf_ = - Δ _U_ (7.19)
![0719](images/image36.jpeg)Khi động năng và nội năng của hệ không thay đổi trong một quá trình thì công dương thực hiện bởi một tác nhân bên ngoài Wext trong trình đó sẽ làm tăng thế năng của hệ. Trong khi đó, công do một thành phần của hệ thực hiện Wint bởi lực bảo toàn bên trong một hệ cô lập là nguyên nhân làm giảm thế năng của hệ.

### Lực không bảo toàn (lực phi thế)

Các lực không thỏa mãn các điều kiện của lực bảo toàn được gọi là lực không bảo toàn. Công thực hiện bởi một lực không bảo toàn phụ thuộc vào quãng đường dịch chuyển.
Lực không bảo toàn tác dụng bên trong hệ sẽ làm biến đổi cơ năng Emech của hệ.

# Public_132

## ![](images/image1.png) Hệ không cô lập

_**Hệ không cô lập**_ về năng lượng là một hệ có trao đổi _n_ ăng lượng với môi trường qua biên giới của nó. Một hệ không cô lập sẽ tương tác với môi trường. Một vật bị tác dụng lực là một ví dụ của hệ không cô lập.
_**Hệ cô lập**_ là một hệ không trao đổi năng lượng với môi trường qua biên giới của hệ.
Đối với một hệ không cô lập, năng lượng được truyền qua biên giới của hệ trong thời gian hệ tương tác với môi trường bên ngoài. Sau đây là những phương thức truyền năng lượng vào hoặc ra khỏi một hệ.
_**Công**_ ( _Work_ ) là một hình thức truyền năng lượng bằng cách tác dụng lực lên hệ và điểm đặt của lực bị dịch chuyển (hình 8.1a).


| ![](images/image2.jpeg)a | ![](images/image3.jpeg)b | ![](images/image4.jpeg)c |
| --- | --- | --- |
| ![](images/image5.jpeg)d | ![](images/image6.jpeg)e | ![](images/image7.jpeg)f |

 

_**Sóng cơ**_ ( _Mechanical waves_ ) là hình thức truyền năng lượng thông qua sự lan truyền nhiễu loạn trong môi trường. Âm thanh rời khỏi chiếc loa radio ở hình 8.1b hay sóng địa chấn, sóng biển là sự truyền năng lượng bằng sóng cơ.
_**Nhiệt**_ ( _Heat_ ) là một cơ chế trao đổi năng lượng giữa hệ và môi trường do có sự khác nhau về nhiệt độ. Năng lượng truyền tới đuôi cái thìa trong hình 8.1c từ phần bị nhúng trong tách cà phê nóng là dưới dạng nhiệt.
_**Trao đổi chất** (Matter transfer)_ là hình thức truyền năng lượng xuyên qua biên giới của hệ dưới dạng vật chất mang theo năng lượng. Ví dụ đổ xăng cho xe như ở hình 8.1d hay đối lưu là sự truyền năng lượng dưới dạng trao đổi chất.
_**Truyền điện**_ ( _Electrical transmission_ ) là sự truyền năng lượng vào hoặc ra khỏi hệ bằng dòng điện. Năng lượng cung cấp cho máy sấy tóc là nhờ sự truyền điện (hình 8.1e).
_**Sóng điện từ**_ ( _Electromagnatic radiation_ ) là năng lượng được trao đổi bởi sóng điện từ.
Năng lượng truyền khỏi bóng đèn (hình 8.1f) là dưới dạng sóng điện từ.

### Định luật bảo toàn năng lượng

_**Năng lượng luôn được bảo toàn.**_
Điều này nghĩa là nếu năng lượng tổng cộng của một hệ thay đổi thì đã có một năng lượng truyền qua biên giới của hệ bằng một phương pháp trao đổi năng lượng nào đó. Dạng tổng quát của định luật bảo toàn năng lượng có thể được biểu diễn bằng _**phương trình bảo toàn năng lượng**_ như sau:
Δ _E_ system = Σ _T_
_ΔEsystem​=∑T_ (8.1)
_Trong đó, E_ system là tổng năng lượng của hệ, _T_ (Transfer) là năng lượng truyền qua biên giới của hệ.
Phương trình toán học của định luận bảo toàn năng lượng đối với một **hệ không cô lập**
thể hiện đầy đủ các loại năng lượng trao đổi có thể được biểu diễn dưới dạng:
_Δ K + Δ U + Δ Eint = W + Q + TMW + TMT + TET + TER_ (8.2)
Với K là động năng, U là thế năng và Eint là nội năng của hệ; năng lượng truyền qua biên giới của hệ dưới dạng công là _T_ work = _W_ , dưới dạng nhiệt là _T_ heat = _Q,_ TMW là năng lượng được truyền bởi sóng cơ, TMT là năng lượng trao đổi chất, TET là năng lượng do truyền điện và TER là năng lượng trao đổi bởi sóng điện từ.
Trong thực tế, phương trình của định luật bảo toàn năng lượng sẽ đơn giản hơn nhiều. Ví dụ, nếu có một lực tác dụng lên hệ và sinh công và giả sử chỉ có cơ chế truyền năng lượng này làm thay đổi tốc độ của hệ thì phương trình của định luật bảo toàn năng lượng sẽ rút về phương trình của định lý công-động năng:

_ΔK = W_

_**Câu hỏi 8.1:**_ Hãy cho biết cơ chế truyền năng lượng nào qua một hệ là: a- Một chiếc tivi, b- Một máy cắt cỏ chạy xăng, c- Một cái gọt bút chì bằng tay.
_**Câu hỏi 8.2:**_ Xét một cái hộp trượt có ma sát trên một bề mặt nằm ngang.

  1. Nếu hệ là chiếc hộp thì hệ là a- cô lập, b- không cô lập, c- không thể xác định được.

  2. Nếu hệ là bề mặt nằm ngang thì hệ là a- cô lập, b- không cô lập, c- không thể xác định được.

  3. Nếu hệ là cái hộp và bề mặt nằm ngang thì hệ là a- cô lập, b- không cô lập, c- không thể xác định được.


## ![](images/image9.png) Hệ cô lập

Đối với một hệ cô lập, không có bất kỳ hình thức trao đổi năng lượng nào với môi trường bên ngoài qua biên giới của hệ, thì tất cả các số hạng bên vế phải trong phương trình (8.2) đều bằng 0 do đó phương trình của định luật bảo toàn năng lượng có dạng:
ΔEsystem = 0 (8.3)
Esystem là tổng động năng, thế năng và nội năng của hệ.
Như vậy, **năng lượng của một hệ cô lập không đổi**.
Trên hình vẽ bên dưới mô tả các dạng năng lượng tồn trữ bên trong một hệ cô lập gồm có động năng, thế năng và nội năng. Các dạng năng lượng này biến đổi lẫn nhau nhưng tổng năng lượng của hệ bảo toàn.

![](images/image10.png)

_Hình 8.2 Các dạng năng lượng tồn trữ bên trong hệ._

## ![](images/image11.png) Công suất

**Định nghĩa:** Công suất tức thời là tốc độ truyền năng lượng theo thời gian và được tính theo công thức:

_P_ ≡ _dE_

_dt_

(8.18)

Nếu năng lượng trao đổi dưới dạng công được thực hiện bởi một lực và trong khoảng thời gian ∆t công do lực sinh ra là W thì công suất trung bình Pavg được xác định bởi công thức:

_Pavg_ = ∆ _t_

(8.19)

Công suất tức thời là giới hạn của công suất trung bình khi Δt tiến tới 0.

![](images/image12.png)![](images/image13.png)![](images/image14.png) _P_ = lim _W_ = _dW_ = **F** ⋅ _d_ **r** = **F** ⋅ **v**

∆ _t_ →0 ∆ _t dt dt_

### Đơn vị

Trong hệ đơn vị SI, đơn vị của công suất là watt (W). 1 watt = 1 joule/second = 1 kg.m2/s3
Một đơn vị công suất hay sử dụng nữa tại Mỹ là mã lực (horsepower – hp) 1 hp = 746 W
Một đơn vị của năng lượng thường bị nhầm lẫn với đơn vị công suất là kWh. Nhớ rằng kWh là đơn vị đo năng lượng, được xác định như sau:
1 kWh = 1kW.1h = (1000 W)(3600 s) = 3.6 x106 J

# Tóm tắt chương 8

# Public_133

Khi giải quyết một bài toán cơ học ta có thể sử dụng nhiều phương pháp khác nhau. Đối với một số bài toán nếu ta dùng phương pháp này thì sẽ phức tạp nhưng nếu ta dùng phương pháp khác thì lại trở nên dễ dàng hơn. Ví dụ trường hợp người đàn ông đứng trên băng bắn cung tên hoặc tình huống các viên bi-da va chạm với nhau.
Giả sử xét một tình huống đơn giản là cho biết vận tốc của mũi tên ngay sau khi được bắn ra và yêu cầu tính vận tốc của người bắn cung ngay khi đó. Ta không thể giải bài toán này với các mô hình động học (chương 2), động lực học (chương 5), hoặc năng lượng (chương 7). Tuy nhiên, ta có thể giải quyết bài toán này một cách dễ dàng dùng cách tiếp cận liên quan đến động lượng.
Chương này sẽ trình bày các khái niệm động lượng, xung lượng, các định lý liên quan đến động lượng, xung lượng, từ đó đưa ra phương pháp giải các bài toán cơ học liên quan đến động lượng, đặc biệt là các bài toán va chạm.

## ![](images/image1.jpeg)![](images/image2.png) Động lượng

Xét hệ cô lập gồm 2 chất điểm có khối lượng m1, m2, chuyển động với các vận tốc 𝑣⃗1 và 𝑣⃗2 (hình 9.1). Vì hệ cô lập nên lực tác dụng lên chất điểm này là do chất điểm kia gây ra. Nếu chất điểm 1
tác dụng lên chất điểm 2 một lực 𝐹⃗12 thì chất điểm 2 cũng tác dụng lên chất điểm 1 một lực 𝐹⃗21 bằng về độ lớn nhưng ngược chiều. Các lực này tạo thành một cặp lực-phản lực theo định luật 3 Newton,
𝐹⃗12 = −𝐹⃗21, nên ta có: 𝐹⃗12 + 𝐹⃗21 = 0.
Theo định luật 2 Newton: lực tác dụng lên mỗi chất điểm bằng
𝑚𝑎⃗ nên:
𝑚1𝑎⃗1 + 𝑚2𝑎⃗2 = 0
Thay các gia tốc bằng biểu thức định nghĩa của nó theo phương trình 4.5, ta có:
_Hình 9.1 Hai chất điểm tương tác với nhau_

𝑚1

𝑑𝑣⃗1
𝑑𝑡 + 𝑚2
𝑑𝑣⃗2
= 0
𝑑𝑡
Nếu các khối lượng m1, m2 không đổi, ta có thể đưa chúng vào trong dấu đạo hàm:
𝑑(𝑚1𝑣⃗1)
+
𝑑𝑡
𝑑(𝑚2𝑣⃗2)
= 0
𝑑𝑡

![](images/image4.png) _d_ ( _m_ 1 _v_ 1 \+ _m_ 2 _v_ 2 ) = 0

_dt_

(9.1)

![](images/image5.png)Vì đạo hàm của tổng 𝑚1𝑣⃗1 + 𝑚2𝑣⃗2 theo thời gian bằng không, nên tổng này là không đổi. Đại lượng _mv_ được gọi là động lượng của một chất điểm, và đối với hệ các chất điểm cô lập, tổng các đại lượng này được bảo toàn.

### Định nghĩa động lượng của chất điểm:

_Động lượng của một chất điểm có khối lượng m chuyển động với vận tốc_ 𝑣⃗ _được xác định bằng tích của khối lượng và vận tốc của nó:_

![](images/image6.png)(9.2)

Động lượng là một đại lượng vectơ, hướng dọc theo 𝑣⃗, thứ nguyên là ML/T, đơn vị trong hệ SI là kg.m/s.
Nếu chất điểm chuyển động theo hướng bất kỳ thì động lượng 𝑝⃗ có 3 thành phần, và phương trình (9.2) viết cho các thành phần là:

𝑝𝑥 = 𝑚𝑣𝑥 𝑝𝑦 = 𝑚𝑣𝑦 𝑝𝑧 = 𝑚𝑣𝑧

Khái niệm động lượng giúp ta phân biệt một cách định lượng giữa các vật nặng và vật nhẹ chuyển động với cùng vận tốc. Ví dụ động lượng của một quả bóng bowling thì lớn hơn nhiều so với động lượng của một quả bóng tennis chuyển động với cùng vận tốc. Newton đã gọi 𝑚𝑣⃗ là _khối lượng chuyển động_ ; thuật ngữ này có lẽ sinh động hơn thuật ngữ _động lượng_ ta dùng hiện nay.

### Phân biệt động năng và động lượng:

_Thứ nhất, động năng là đại lượng vô hướng còn động lượng là đại lượng vectơ_. Ví dụ xét hai chất điểm có khối lượng bằng nhau chuyển động về phía nhau theo một đường thẳng với cùng tốc độ. Động năng của hệ này khác không, động lượng của hệ này bằng không.
_Thứ hai là động năng có thể chuyển hóa thành các dạng năng lượng khác chẳng hạn như thế năng hoặc nội năng, còn động lượng không chuyển đổi được thành năng lượng._ Các khác biệt này đủ để tạo ra các mô hình phân tích dựa vào động lượng, tách biệt với các mô hình dựa vào năng lượng, cung cấp một công cụ độc lập để sử dụng trong việc giải quyết các bài toán.
Theo định luật 2 Newton, ta có:
𝑑𝑣⃗

∑ 𝐹⃗ = 𝑚𝑎⃗ = 𝑚

𝑑𝑡
Giả sử khối lượng m là không đổi, ta có thể đưa khối lượng m vào trong dấu đạo hàm, nên:

![](images/image8.png)![](images/image9.png)![](images/image10.png) _F_ = __d_ ( _mv_ )_ = __dp__

_dt dt_

(9.3)

_Phương trình (9.3) là dạng khác của định luật 2 Newton đối với chất điểm_. Phương trình này chỉ ra **rằng tốc độ biến thiên theo thời gian của động lượng của chất điểm thì bằng hợp lực tác dụng lên chất điểm**. Dạng này tổng quát hơn dạng đã giới thiệu ở chương 5, và có thể sử dụng để khảo sát các hiện tượng trong đó khối lượng thay đổi, ngoài các trường hợp
trong đó vận tốc thay đổi. Ví dụ trường hợp khối lượng của tên lửa thay đổi do nhiên liệu bị đốt và bị phóng ra khỏi tên lửa, ta không thể sử dụng phương trình ∑ 𝐹⃗ = 𝑚𝑎⃗ để phân tích mà phải dùng cách tiếp cận động lượng như sẽ trình bày trong mục 9.9.
_**Câu hỏi 9.1:**_ Hai vật có động năng bằng nhau. Độ lớn động lượng của chúng so với nhau thế nào? ( **a** ) p1 < p2 ( **b** ) p1 = p2 ( **c** ) p1 > p2 ( **d** ) không đủ thông tin để phát biểu.
_**Câu hỏi 9.2:**_ Giáo viên thể dục ném một quả bóng chày về phía bạn với một tốc độ nào đó và bạn bắt lấy nó. Tiếp theo giáo viên sẽ ném một quả bóng tập nặng gấp 10 lần quả bóng chày. Bạn có các lựa chọn sau: Bạn có thể bắt được quả bóng tập được ném với ( **a** ) cùng tốc độ với quả bóng chày, ( **b** ) cùng động lượng với quả bóng chày, hoặc ( **c** ) cùng động năng với quả bóng chày. Hãy sắp xếp các lựa chọn này từ dễ đến khó để bắt.

## ![](images/image14.png) Mô hình phân tích: Hệ cô lập (động lượng)

Sử dụng định nghĩa động lượng, biểu thức 9.1 có thể viết là:
𝑑
𝑑𝑡 (𝑝⃗1 + 𝑝⃗2) = 0
Vì đạo hàm của động lượng toàn phần 𝑝⃗𝑡𝑜𝑡 = 𝑝⃗1 + 𝑝⃗2 bằng không, nên động lượng toàn phần của hệ hai chất điểm cô lập trong hình 9.1 là không đổi:
Hay:
hoặc viết theo dạng khác là:
![](images/image15.png)

![](images/image17.png)

𝑝⃗1𝑖 + 𝑝⃗2𝑖 = 𝑝⃗1𝑓 + 𝑝⃗2𝑓

(9.4)

9.5)

với 𝑝⃗1𝑖, 𝑝⃗2𝑖 là các giá trị đầu và 𝑝⃗1𝑓, 𝑝⃗2𝑓 là các giá trị cuối của động lượng của hai chất điểm.
Phương trình (9.5) chứng tỏ động lượng toàn phần theo các hướng x, y, z đều được bảo toàn một cách độc lập:
_p_ 1 _ix_ \+ _p_ 2 _ix_ = _p_ 1 _fx_ \+ _p_ 2 _fx_
_p_ 1 _iy_ \+ _p_ 2 _iy_ = _p_ 1 _fy_ \+ _p_ 2 _fy_
_p_ 1 _iz_ \+ _p_ 2 _iz_ = _p_ 1 _fz_ \+ _p_ 2 _fz_
(9.6)
Phương trình (9.5) là dạng toán học của một mô hình phân tích mới, gọi là mô hình **hệ cô lập** ( **động lượng)**. Mô hình này có thể mở rộng cho hệ cô lập nhiều chất điểm bất kỳ như sẽ trình bày trong mục 9.7.
Từ phương trình (9.5) ta có thể phát biểu như sau: _Khi hai hay nhiều chất điểm của một hệ cô lập tương tác với nhau, động lượng toàn phần của hệ luôn không đổi._ Như vậy động lượng toàn phần của hệ cô lập tại các thời điểm bất kì đều bằng động lượng ban đầu của nó.
Mô hình phân tích hệ cô lập không cần xét đến ngoại lực tác dụng lên hệ, cũng như lực đó là lực bảo toàn hay không bảo toàn, lực biến thiên hay không biến thiên theo thời gian. Yêu cầu duy nhất là các lực phải là nội lực của hệ. Điều này cho thấy tầm quan trọng của mô hình mới này.

### Mô hình phân tích: Hệ cô lập (động lượng)

![](images/image19.png)![](images/image20.png)Giả sử ta đã xác định được hệ cần phân tích và biên của nó. Nếu không có ngoại lực nào tác dụng lên hệ thì hệ là cô lập. Khi đó động lượng toàn phần của hệ được bảo toàn:
∆ _ptot_ = 0
Ví dụ:
(9.5)

  * Viên bi da cái đánh vào các viên bi da khác trên bàn

  * Tàu vũ trụ bắn tên lửa ra và chuyển động nhanh hơn trong không gian

  * Các phân tử chất khí ở một nhiệt độ xác định chuyển động và va chạm với nhau


### Bài tập mẫu 9.1:

Một người bắn cung đứng trên mặt băng không ma sát bắn một mũi tên nặng 0.03 kg theo phương ngang với vận tốc đầu 85 m/s. (A) Hỏi vận tốc của người sau khi mũi tên được bắn ra. (B) Điều gì xảy ra nếu mũi tên được bắn theo hướng hợp với phương nằm ngang một góc θ? Điều này sẽ làm thay đổi vận tốc giật lùi của người bắn cung như thế nào?

### Giải:

![](images/image21.jpeg) **Phân tích bài toán:** Hãy tưởng tượng mũi tên bị bắn đi trên một đường thẳng và người bắn cung thủ chuyển động giật lùi theo hướng ngược lại. Ta không thể giải bài toán này với các mô hình dựa trên chuyển động, lực, hoặc năng lượng. Tuy nhiên, ta có thể giải quyết vấn đề này một cách dễ dàng với cách tiếp cận liên quan đến động lượng. Ta xét hệ gồm có người bắn cung (bao gồm cả cung) và mũi tên. Hệ không cô lập vì có lực hấp dẫn và phản lực pháp tuyến từ băng tác dụng lên hệ. Tuy nhiên, các lực này theo phương thẳng đứng và vuông góc với chiều
chuyển động của hệ. Không có ngoại lực tác dụng lên hệ theo phương ngang, và ta có thể áp dụng mô hình hệ cô lập (động lượng) đối với các thành phần động lượng theo hướng này.
_Hình 9.2 Bài tập mẫu 9.1 – Người bắn cung_

  1. Áp dụng mô hình hệ cô lập (động lượng) theo phương ngang, động lượng theo phương ngang của hệ trước và sau khi bắn đều bằng 0. Ta chọn hướng bắn mũi tên là hướng dương của trục x. Xem người bắn cung là chất điểm 1 và mũi tên là chất điểm 2, theo phương trình 9.5 ta được:


![](images/image19.png)![](images/image22.png)∆ _ptot_ = 0 →
![](images/image23.png)![](images/image25.png)Theo đề bài ta có m1 = 60 kg, m2 = 0,030 kg và _v_ 2 _f_
Giải phương trình này và thay số ta được:
= 85 _i_
m/s.

![](images/image26.png)![](images/image29.png)1 _f_

2 _f_
1
Dấu trừ chỉ ra rằng người bắn cung chuyển động về phía bên trái trên hình 9.2 sau khi bắn mũi tên, phù hợp với định luật 3 Newton. Gia tốc và vận tốc của người bắn cung nhỏ hơn nhiều so với gia tốc và vận tốc của mũi tên vì khối lượng của người bắn cung rất lớn so với mũi tên.

  2. Độ lớn của vận tốc giật lùi sẽ giảm vì chỉ một thành phần của vận tốc mũi tên là theo hướng x. Sự bảo toàn động lượng theo hướng x cho ta:


_m v_ \+ _m v_ cosθ = 0 dẫn tới _v_ =− _m_ 2 _v_ cosθ .

  1. 1 _f_

  2. 2 _f_


1 _f_ 2 _f_
1
Với các giá trị θ ≠ 0 thì _v_ 1 _f_ nhỏ hơn _v_ 1 _f_ khi θ = 0 vì cosθ < 1.

## ![](images/image30.png) Mô hình phân tích: Hệ không cô lập (động lượng)

Đối với các khảo sát động lượng, _hệ không cô lập_ nếu có lực tác dụng lên hệ. Ta có thể hình dung động lượng được chuyển từ môi trường đến hệ thông qua lực. Việc hiểu được lực là nguyên nhân gây ra sự biến thiên động lượng rất quan trọng khi giải quyết một số loại bài toán.
Giả sử có một hợp lực ∑ 𝐹⃗ tác dụng lên chất điểm và hợp lực này có thể biến thiên theo thời gian. Theo định luật 2 Newton:
hay
𝑑𝑝⃗

∑ 𝐹⃗ =

𝑑𝑡
𝑑𝑝⃗ = ∑ 𝐹⃗ 𝑑𝑡 (9.7)
Ta có thể lấy tích phân biểu thức (9.7) để tìm độ biến thiên động lượng của chất điểm khi
có lực tác dụng lên nó trong một khoảng thời gian nào đó. Nếu động lượng của chất điểm thay đổi từ 𝑝⃗𝑖 tại thời điểm 𝑡𝑖 tới 𝑝⃗𝑓 tại thời điểm 𝑡𝑓, lấy tích phân phương trình 9.7 ta được:
𝑡𝑓
∆𝑝⃗ = 𝑝⃗𝑓 − 𝑝⃗𝑖 = ∫ ∑ 𝐹⃗ 𝑑𝑡

𝑡𝑖

(9.8)

Để tính tích phân này, ta cần biết hợp lực tác dụng lên chất điểm biến thiên theo thời gian như thế nào. Đại lượng ở vế phải của phương trình (9.8) được gọi là **xung của hợp lực** ∑ 𝐹⃗ tác dụng lên chất điểm trong khoảng thời gian ∆𝑡 = 𝑡𝑓 − 𝑡𝑖, kí hiệu là 𝐼⃗:

𝐼⃗ =

∫𝑡𝑓 ∑ 𝐹⃗ 𝑑𝑡
𝑡𝑖
(9.9)
Giả sử lực biến thiên theo thời gian như trên hình 9.3a và khác không trong khoảng thời gian ∆𝑡 = 𝑡𝑓 − 𝑡𝑖. Vectơ xung lực 𝐼⃗ cùng hướng với vectơ độ biến
thiên động lượng ∆𝑝⃗. Xung lực có thứ nguyên của động lượng là ML/T. Xung lực không phải là một thuộc tính của chất điểm, mà là số đo mức độ ngoại lực làm thay đổi động lượng của chất điểm.
Do hợp lực truyền xung lực cho chất điểm thường thay đổi theo thời gian, nên để thuận tiện, người ta định nghĩa hợp lực trung bình theo thời gian:
![](images/image33.png)![](images/image34.png) _Hình 9.3 (a) Lực tác dụng lên chất điểm biến thiên theo thời gian. (b) Giá trị của lực không đổi (đường nét đứt nằm ngang) được lấy sao cho diện tích của hình chữ nhật bằng diện tích dưới đường cong ở_
𝑡𝑓

(∑ 𝐹⃗)

𝑎𝑣𝑔

1
=
∆𝑡
∫ ∑ 𝐹⃗ 𝑑𝑡
𝑡𝑖

(9.10)

trong đó ∆𝑡 = 𝑡𝑓 − 𝑡𝑖. (Phương trình 9.11 là một áp dụng của định lý giá trị trung bình trong giải tích.) Do đó có thể biểu diễn phương trình 9.9 như là:
𝐼⃗ = (∑ 𝐹⃗) ∆𝑡 (9.11)
𝑎𝑣𝑔
Lực trung bình này, như chỉ ra trên hình 9.3b, có thể xem là lực không đổi tác dụng lên chất điểm trong khoảng thời gian ∆𝑡, có cùng xung lực với xung lực của lực biến thiên theo thời gian tác dụng lên chất điểm trong khoảng thời gian đó.
Nếu ∑ 𝐹⃗ là một hàm của thời gian, có thể tính được xung lực từ phương trình 9.9. Việc tính toán trở nên rất đơn giản nếu như lực tác dụng lên chất điểm là không đổi. Trong trường
hợp này, (∑ 𝐹⃗) = ∑ 𝐹⃗, trong đó ∑ 𝐹⃗ là hợp lực không đổi tác dụng lên chất điểm, và
𝑎𝑣𝑔
phương trình (9.11) trở thành:
𝐼⃗ = ∑ 𝐹⃗ ∆𝑡 (9.12)
Kết hợp các phương trình (9.8) và (9.9) ta được **định lý xung lượng-động lượng** :
_Độ biến thiên động lượng của một chất điểm thì bằng xung lượng của hợp lực tác dụng lên chất điểm đó:_
∆𝑝⃗ = 𝐼⃗ (9.13)
Phát biểu này tương đương với định luật 2 Newton. Khi nói một xung lực được truyền cho chất điểm, ta muốn nói rằng động lượng được truyền từ một tác nhân bên ngoài tới chất điểm
đó. Phương trình (9.13) có dạng tương tự với các phương trình bảo toàn năng lượng (8.1) và (8.2).
Phương trình 9.13 là phát biểu tổng quát nhất của nguyên lý **bảo toàn động lượng** và được gọi là **phương trình bảo toàn động lượng**. Trong cách tiếp cận động lượng, hệ cô lập xuất hiện thường xuyên hơn hệ không cô lập, nên phương trình (9.13) có thể xem như trường hợp đặc biệt của phương trình (9.5). Vế trái của phương trình (9.13) là độ biến thiên động lượng của hệ. Vế phải là số đo động lượng đi qua biên của hệ khi có lực tác dụng lên hệ. Phương trình (9.13) là phát biểu toán học của một mô hình phân tích mới, gọi là **mô hình hệ không cô lập (động lượng)**. Phương trình này có dạng tương tự phương trình (8.1) nhưng có một số khác biệt khi áp dụng cho các bài toán. Trước tiên, phương trình (9.13) là phương trình vectơ, trong khi phương trình (8.1) là phương trình vô hướng. Do đó hướng là quan trọng đối với phương trình (9.13). Thứ hai, chỉ có một loại động lượng nên chỉ có một cách duy nhất để tích trữ động lượng trong hệ. Ngược lại, như thấy từ phương trình (8.2), có 3 cách để tích năng lượng cho hệ là động năng, thế năng và nội năng. Thứ ba, chỉ có một cách để truyền động lượng cho hệ là tác dụng lực lên hệ trong một khoảng thời gian. Phương trình (8.2) chỉ ra 6 cách mà ta đã biết để truyền năng lượng cho một hệ. Do đó, không có sự mở rộng phương trình (9.13) tương tự như phương trình (8.2).
Trong nhiều tình huống người ta dùng “xấp xỉ xung lực”, bằng cách giả sử một trong các lực tác dụng lên chất điểm tác dụng trong một khoảng thời gian ngắn nhưng lớn hơn nhiều so với các lực khác cùng có mặt. Khi đó, hợp lực ∑ 𝐹⃗ trong phương trình (9.9) được thay thế bằng một lực đơn 𝐹⃗ để tính xung lực tác dụng lên chất điểm. Sự xấp xỉ này rất hữu ích khi xét các bài toán va chạm trong đó khoảng thời gian va chạm rất ngắn. Khi sử dụng xấp xỉ này, lực đơn được xem là một xung lực. Ví dụ khi quả bóng chày bị đánh bằng cái gậy, thời
gian va chạm khoảng 0,01s và lực trung bình mà gậy tác dụng lên quả bóng là vài ngàn Newton. Vì lực này lớn hơn nhiều so với trọng lực tác dụng lên quả bóng và cái gậy, nên sự xấp xỉ xung lực cho thấy việc bỏ qua trọng lực là đúng đắn. Khi dùng xấp xỉ này, cần nhớ rằng 𝑝⃗𝑖 và 𝑝⃗𝑓 là các động lượng tức thời trước và sau khi va chạm. Do đó trường hợp phù hợp để dùng xấp xỉ xung là khi va chạm chất điểm di chuyển một đoạn rất ngắn.
_**Câu hỏi 9.3:**_ Hai vật nằm yên trên một bề mặt không có ma sát. Vật 1 có khối lượng lớn hơn vật 2. ( **i** ) Khi một lực không đổi tác dụng lên vật 1, nó gia tốc vật trên quãng đường d theo một đường thẳng. Ngừng cho lực tác dụng lên vật 1 mà cho nó tác dụng lên vật 2. Tại thời điểm vật 2 được gia tốc qua cùng quãng đường d, phát biểu nào đúng? (a) p1 < p2, (b) p1 = p2,
(c) p1 > p2, (d) K1 < K2, (e) K1 = K2, (f) K1 > K2. ( **ii** ) Khi một lực không đổi tác dụng lên vật 1, nó gia tốc vật trong một khoảng thời gian ∆ t. Ngừng cho lực tác dụng lên vật 1 mà cho nó tác dụng lên vật 2. Từ danh sách các lựa chọn như trên, phát biểu nào là đúng sau khi vật 2 được gia tốc trong cùng khoảng thời gian ∆ t?
_**Câu hỏi 9.4:**_ Hãy xếp hạng từ lớn nhất đến nhỏ nhất một bảng điều khiển ô tô, một dây an toàn và một túi khí, mỗi cái được sử dụng một mình trong các va chạm có cùng tốc độ, về (a) xung lực và (b) lực trung bình mà mỗi cái mang lại cho một hành khách ngồi phía trước.

### ![](images/image35.png)Mô hình phân tích: Hệ không cô lập (động lượng)

![](images/image36.png)![](images/image37.png)Giả sử ta đã xác định được hệ cần phân tích và biên của nó. Nếu có ngoại lực tác dụng lên hệ thì hệ là không cô lập. Khi đó độ biến thiên động lượng toàn phần của hệ bằng xung lực tác dụng lên hệ (định lý
xung lực - động lượng):
Ví dụ:
∆ _ptot_ = _I_
(9.13)

  * Cái gậy đánh vào quả bóng chày

  * Dùng sợi dây kéo một ống chỉ đặt trên bàn


### Bài tập mẫu 9.3: Cái đỡ va tốt như thế nào?

![](images/image38.png)![](images/image41.png)![](images/image42.jpeg)Trong một thử nghiệm va chạm, một xe hơi có khối lượng 1500 kg va chạm với một bức tường như trên hình 9.4. Vận tốc của xe trước
và sau khi va chạm lần lượt là
_vi_ = −15 _i_ m/s
![](images/image45.png)![](images/image46.png)và _vf_ = 2, 6 _i_ m/s. (A) Va chạm kéo dài trong
0.15 s, hãy tìm xung lực c ủa vụ va chạm và lực trung bình tác dụng lên xe. (B) Điều gì xảy ra nếu chiếc xe không bật ra khỏi bức tường? Giả sử tốc độ cuối cùng của xe bằng không và khoảng thời gian của va chạm vẫn
_Hình 9.4 Bài tập mẫu 9.3_
ở mức 0.15 s. Điều đó có thể hiện là lực lớn hơn hoặc nhỏ hơn tác dụng lên xe không?

### Giải:

  1. Sử dụng công thức 9.13 để tính xung lực tác dụng lên xe hơi:


![](images/image47.png)![](images/image50.png)![](images/image51.png)![](images/image52.png)![](images/image53.png) _I_ = ∆ _p_ = p _f_ − p _i_ = _mvf_ − _mvi_ = _m_ ( _vf_ − _vi_ ) = 26400 _i_ kg.m/s
![](images/image58.png)![](images/image59.png)Dùng công thức (9.11) để tính lực trung bình tác dụng lên xe: (∑ _F_ )
N

_avg_

= __I__ = 176000 i
![](images/image60.png)∆ _t_
Lực tính được ở trên là tổng hợp của phản lực vuông góc do tường tác dụng lên xe và lực ma sát giữa các lốp xe và mặt đất khi đầu xe bị biến dạng. Nếu các bánh xe quay tự do, lực ma sát này là tương đối nhỏ.

  2. Trong tình huống trên, khi mà chiếc xe bật ra khỏi tường, lực tác dụng lên xe thực hiện hai việc trong khoảng thời gian 0.15s: (1) nó dừng xe, và (2) nó làm cho xe chuyển động ra khỏi tường với tốc độ 2.60 m/s sau khi va chạm. Nếu chiếc xe không bật ra, lực chỉ thực hiện bước đầu tiên đó là dừng xe - đòi hỏi một lực nhỏ hơn. Trong trường hợp này, xung lực là:


![](images/image63.png)![](images/image64.png)![](images/image47.png)![](images/image50.png) _I_ = ∆ _p_ = p _f_ − p _i_ = 0 − _mvi_ = _m_ ( _vf_ − _vi_ ) = 22500 _i_ kg.m/s và lực trung bình tác dụng lên xe là:
![](images/image58.png)![](images/image59.png)(∑ _F_ )

_avg_

= __I__ = 150000 i N.
![](images/image60.png)∆ _t_

## ![](images/image65.png) Va chạm một chiều

Thuật ngữ va chạm biểu thị sự kiện hai chất điểm đi lại gần nhau và tương tác với nhau bằng các lực. Các lực tương tác được giả sử rất lớn so với các ngoại lực có mặt, nên có thể sử dụng xấp xỉ xung lực.
Va chạm không chỉ xảy ra khi có sự tiếp xúc trực tiếp giữa hai vật thể vĩ mô, như mô tả trên hình 9.5a, mà phải được hiểu tổng quát hơn. Ví dụ xét một va chạm ở tỉ lệ nguyên tử giữa proton và hạt alpha (hình 9.5b). Vì cả hai hạt đều mang điện dương, chúng đẩy nhau, va chạm với nhau thông qua trường điện từ.
Khi hai vật có khối lượng m1 và m2 va chạm như trên hình 9.5, các xung lực có thể thay đổi rất phức tạp, chẳng hạn như trên hình 9.3. Tuy nhiên, bất kể sự phức tạp của xung lực, lực luôn là nội lực của hệ hai vật. Do đó, hai vật tạo thành một hệ cô lập và động lượng của hệ được bảo toàn trong va chạm bất kỳ. Tuy nhiên, tổng động năng của hệ có thể bảo toàn hoặc không, tùy thuộc vào loại va chạm.
![](images/image66.jpeg)
_Hình 9.5 (a) Va chạm giữa hai vật như kết quả của sự tiếp xúc trực tiếp, (b) "Va chạm" giữa hai hạt tích điện._
**Phân loại va chạm:** _Va chạm được chia thành va chạm đàn hồi hoặc va chạm không đàn hồi tùy thuộc vào việc động năng của hệ có bảo toàn hay không_.
_Va chạm đàn hồi_ gữa _hai vật là va chạm mà tổng động năng và tổng động lượng của hệ trước và sau khi va chạm là như nhau_. Va chạm giữa các vật trong thế giới vĩ mô, chẳng hạn giữa các quả bóng bi a, chỉ là xấp xỉ đàn hồi vì có xảy ra sự biến dạng và mất động năng. Ví dụ ta có thể nghe thấy tiếng các quả bi a va chạm nhau, như vậy có một số năng lượng từ hệ đã bị truyền đi xa bởi âm thanh. Va chạm đàn hồi phải hoàn toàn yên lặng
_Va chạm không đàn hồi là va chạm mà tổng động năng của hệ trước và sau khi va chạm khác nhau (mặc dù động lượng của hệ được bảo toàn)._ Các va chạm không đàn hồi có hai loại. Khi các vật dính vào nhau sau khi va chạm được gọi là _va chạm hoàn toàn không đàn hồi_ , ví dụ khi một thiên thạch va chạm với Trái đất. Khi các vật va chạm nhưng không dính vào nhau, nhưng một phần năng lượng bị chuyển sang dạng năng lượng khác hoặc bị truyền ra xa, như trường hợp quả bóng cao su va chạm với một bề mặt cứng, thì va chạm được gọi là _không đàn hồi_. Khi quả bóng cao su va chạm với nền cứng, một phần động năng của quả bóng bị chuyển đổi (sang nhiệt) khi quả bóng bị biến dạng trong khi nó tiếp xúc với bề mặt cứng. Các va chạm không đàn hồi được mô tả bằng cách diễn giải động lượng của mô hình hệ cô lập.

### Va chạm hoàn toàn không đàn hồi

Xét 2 vật khối lượng m1 và m2, chuyển động với các vận tốc ban đầu 𝑣⃗1𝑖, 𝑣⃗2𝑖 dọc theo một đường thẳng như trên hình 9.6. Hai vật va chạm trực diện với nhau, dính vào nhau và sau va chạm chúng chuyển động với vận tốc chung 𝑣⃗𝑓. Do động lượng của một hệ cô lập được bảo toàn trong va chạm bất kì, ta có tổng động lượng trước khi va chạm bằng với động lượng của hệ
hợp lại sau khi va chạm:

![](images/image67.png)![](images/image68.png)

_Hình 9.6 Giản đồ biểu diễn va chạm xuyên tâm hoàn toàn không đàn hồi giữa hai chất điểm_
𝑚1𝑣⃗1𝑖 + 𝑚2𝑣⃗2𝑖 = (𝑚1 + 𝑚2)𝑣⃗𝑓 (9.14)
Giải phương trình này đối với ẩn số là vận tốc sau va chạm, ta được:
𝑚1𝑣⃗1𝑖 + 𝑚2𝑣⃗2𝑖

# Public_134

_Trong chương này ta sẽ phân tích kĩ chuyển động quay của một vật rắn, cụ thể là phân tích mô hình vật rắn quay với gia tốc góc không đổi, từ đó dẫn ra các phương trình động lực học của mô hình này_. Lưu ý, vật rắn là vật không bị biến dạng, tức là vị trí tương đối của các chất điểm cấu tạo nên hệ luôn không đổi. Mọi vật thể thực tế đều bị biến dạng ở mức độ nào đó; tuy nhiên, trong các phân tích dưới đây ta bỏ qua sự biến dạng của vật.

## ![](images/image1.png) Tọa độ góc, vận tốc góc và gia tốc góc

![](images/image2.png)![](images/image3.png)Hình 10.1 minh họa một đĩa CD đang quay quanh trục cố định vuông góc với mặt phẳng hình vẽ và đi qua tâm O của đĩa. Một yếu tố nhỏ của đĩa được mô hình hóa như một chất điểm tại P, cách gốc O một khoảng cố định r và quay quanh O theo một vòng tròn bán kính r.
Ta biểu diễn vị trí của P theo tọa độ cực (𝑟, 𝜃), với _r là khoảng cách từ gốc tọa độ tới P_ , 𝜃 _là góc quay_ ngược
chiều kim đồng hồ từ một đường cố định được chọn làm mốc (đường chuẩn) như trên hình 10.1. Góc 𝜃
_Hình 10.1 Một đĩa compact quay quanh trục cố định qua O và vuông góc với mặt phẳng hình vẽ_
thay đổi theo thời gian, còn r không thay đổi. Khi chất điểm chuyển động dọc theo đường tròn bắt đầu từ đường chuẩn (𝜃 = 0), nó chuyển động qua một cung có độ dài s như trên hình 10.1b. Ta có:
𝑠 = 𝑟𝜃 (10.1a)

𝑠

𝜃 =
𝑟

(10.1b)

Vì 𝜃 là tỉ số giữa độ dài của cung và bán kính của đường tròn nên nó là một số thuần túy (không có đơn vị). Tuy nhiên, ta thường cho đơn vị (giả) của 𝜃 là radian (rad).
_**Tọa độ góc θ:**_ Vì đĩa là một vật rắn nên khi chất điểm tại P chuyển động quét qua một góc 𝜃 tính từ đường chuẩn thì mỗi yếu tố khác của vật cũng quay và quét qua một góc 𝜃. Nên ta có thể liên kết góc 𝜃 với toàn bộ vật, cũng như liên kết với từng chất điểm riêng biệt, cho phép xác định tọa độ góc của vật rắn trong chuyển động quay. Chọn một đường chuẩn trên vật thì _tọa độ góc của vật rắn là góc_ 𝜃 _giữa đường chuẩn này và một đường chuẩn cố định_
_khác (thường là trục x)_. Tọa độ góc θ trong chuyển động quay đóng vai trò tương tự như vị trí x trong chuyển động tịnh tiến.
Khi chất điểm đang xét chuyển động từ vị trí A tới vị trí B trong khoảng thời gian ∆𝑡 như trên hình 10.2, đường chuẩn gắn với vật quét được một góc ∆𝜃 = 𝜃𝑓 − 𝜃𝑖. Đại lượng ∆𝜃 này được gọi là _**độ dời góc**_ của vật rắn:

∆𝜃 ≡ 𝜃𝑓 − 𝜃𝑖

![](images/image5.jpeg)Nếu vật rắn quay nhanh, độ dời này diễn ra trong một khoảng thời gian ngắn. Nếu vật rắn quay chậm, độ dời này diễn ra trong một khoảng thời gian dài hơn. Các tốc độ quay khác nhau được định lượng bởi khái niệm tốc độ góc trung bình 𝜔𝑎𝑣𝑔, là tỉ số giữa độ dời góc của vật rắn và khoảng thời gian ∆𝑡 diễn ra độ dời đó:

𝜔𝑎𝑣𝑔 =

𝜃𝑓 − 𝜃𝑖
𝑡𝑓 − 𝑡𝑖
∆𝜃
= (10.2)
∆𝑡
_**Tốc độ góc tức thời ω**_ được xác định bằng giới hạn của tốc độ góc trung bình khi ∆𝑡 → 0:
_Hình 10.2 Chất điểm trên vật rắn quay từ (A) tới (B) dọc theo_
𝜔 ≡ lim ∆𝜃 = 𝑑𝜃

∆𝑡→0 ∆𝑡 𝑑𝑡

(10.3)

_cung tròn. Trong khoảng_ ∆𝑡 =

𝑡𝑓 − 𝑡𝑖 _, r quét qua một góc_

Đơn vị tốc độ góc là rad/s, có thể viết là s-1 vì rad không có thứ nguyên. 𝜔 dương khi 𝜃 tăng (chuyển động cùng chiều kim đồng hồ), 𝜔 âm khi 𝜃 giảm (chuyển động ngược chiều kim đồng hồ)
_Tính mômen quán tính của các vật rắn có hình dạng đơn giản (có tính đối xứng cao)_ là tương đối dễ với điều kiện trục quay trùng với một trục đối xứng, như trình bày trong mục
10.6 tiếp theo.

![](images/image6.jpeg)

_Bảng 10.2: Mômen quán tính của các vật rắn đồng nhất có hình dạng khác nhau_
_**Câu hỏi 10.5:**_ Bạn tắt máy khoan điện và thấy rằng khoảng thời gian để cho mũi khoan dừng lại do mômen lực ma sát trong máy khoan là ∆ t. Bạn thay một mũi khoan lớn hơn có mômen quán tính gấp đôi. Khi mũi khoan lớn hơn này đang quay với tốc độ góc như cái nhỏ lúc đầu và khoan được ngắt điện, mômen lực ma sát vẫn giữ nguyên như trường hợp mũi khoan nhỏ.
Khoảng thời gian để mũi khoan lớn hơn dừng lại là (a) 4 ∆t (b) 2 ∆t

  2. ∆t

  3. 0.5 ∆t

  4. 0.25


∆t (f) không thể xác định được.

### Định lý các trục song song:

Việc tính mômen quán tính đối với một trục quay bất kì là khó khăn, ngay cả với vật có tính đối xứng cao. Ta có thể dùng **định lí các trục song song** để đơn giản hóa sự tính toán. Giả sử vật trên hình 10.14a quay quanh trục z. Mômen quán tính không phụ thuộc sự phân bố khối lượng dọc trục z. Tưởng tượng làm bẹp một vật thể 3 chiều thành một vật thể 2 chiều như trên hình 10.14b. Trong quá trình này tất cả khối lượng chuyển động song song với trục z cho đến khi nó nằm trong mặt phẳng xy. Các tọa độ khối tâm của vật lúc này là xCM, yCM, zCM=0. Xét phần tử khối lượng dm có các tọa độ (x, y, 0) như ở hình 10.14c khi nhìn từ trên
trục z xuống. Vì phần tử này cách trục z một khoảng 𝑟 = √𝑥2 \+ 𝑦2, nên mômen quán tính của vật đối với trục z là:

𝐼 = ∫ 𝑟2𝑑𝑚 = ∫(𝑥2 \+ 𝑦2) 𝑑𝑚

![](images/image7.jpeg)

## 

## 

Trong đó tốc độ góc thay đổi từ 𝜔𝑖 đến 𝜔𝑓. Phương trình (10.27) là định lý công-động năng đối với chuyển động quay. Định lý này phát biểu rằng công do ngoại lực thực hiện lên vật rắn đối xứng đang quay quanh trục cố định thì bằng độ biến thiên động năng quay của vật.
Định lý này là một dạng của mô hình hệ không cô lập (năng lượng) đã thảo luận trong chương 8. Công thực hiện lên hệ vật rắn biểu thị sự truyền năng lượng qua biên của hệ do sự tăng động năng quay của vật.
Tổng quát, có thể tổ hợp định lí này với định lí công-động năng trong chuyển động tịnh tiến ở chương 7. Cho nên công do ngoại lực thực hiện lên vật bằng độ biến thiên động năng toàn phần gồm động năng tịnh tiến và động năng quay của vật. Ví dụ khi một cầu thủ ném quả bóng thì công thực hiện bởi tay của cầu thủ lên quả bóng bằng động năng do quả bóng chuyển động trong không gian và động năng quay của quả bóng.
Ngoài định lí công-động năng, các nguyên lí năng lượng khác cũng áp dụng được cho chuyển động quay. Ví dụ vật đang quay và không có các lực không bảo toàn tác dụng lên hệ thì có thể dùng mô hình hệ cô lập và nguyên lí bảo toàn cơ năng để phân tích hệ. Độ biến thiên động năng trong phương trình bảo toàn năng lượng 8.2 sẽ gồm cả độ biến thiên động năng tịnh tiến và độ biến thiên động năng quay.
Trong một số trường hợp, nếu cách tiếp cận năng lượng không đủ thông tin để giải bài toán thì phải kết hợp với cách tiếp cận động lượng. Một trường hợp như vậy được minh họa trong ví dụ 10.14 trong mục 10.9.
Bảng 10.3 liệt kê các phương trình liên quan đến chuyển động quay cùng với các công thức tương ứng của chuyển động tịnh tiến. Lưu ý đến sự giống nhau về dạng toán học của các phương trình. Hai phương trình cuối cùng ở cột bên trái của bảng 10.3 liên quan đến mômen động lượng L sẽ được trình bày trong chương 11. Ở đây chúng được đưa vào với mục đích làm hoàn chỉnh bảng các công thức chuyển động quay và chuyển động tịnh tiến.

## ![](images/image8.png) Chuyển động lăn của vật rắn

Trong mục này ta xét chuyển động của vật rắn lăn trên mặt phẳng. Ví dụ, xét một khối trụ lăn trên một đường thẳng sao cho trục quay của nó luôn song song với hướng lúc đầu của nó. Như hình 10.18 cho thấy, một điểm trên vành của hình trụ chuyển động theo một đường phức tạp gọi là _cycloid_. Tuy nhiên ta đơn giản hóa vấn đề bằng cách chú ý đến khối tâm của vật hơn là điểm trên vành của vật đang lăn. Như thấy trên hình 10.18, khối tâm của vật chuyển động theo đường thẳng. Nếu một vật lăn không trượt trên mặt phẳng (gọi là _chuyển động lăn thuần túy_ ) thì tồn tại một mối liên hệ đơn giản giữa chuyển động tịnh tiến và chuyển động quay của nó.

![](images/image9.jpeg)

_Hình 10.18 Hai điểm trên một vật đang lăn có quỹ đạo khác nhau trong không gian_
Xét một khối trụ đồng nhất có bán kính R lăn không trượt trên một mặt phẳng nằm ngang (hình 10.19).
![](images/image10.jpeg)Khi trụ quay được một góc 𝜃 thì khối tâm của nó đi được một đoạn 𝑠 = 𝑅𝜃. Do đó, tốc độ chuyển động tịnh tiến của khối tâm là:
𝑑𝑠 𝑑𝜃
𝑣𝐶𝑀 = 𝑑𝑡 = 𝑅 𝑑𝑡 = 𝑅𝜔 (10.28)
trong đó 𝜔 là tốc độ góc của hình trụ. Phương trình 10.28 đúng khi khối trụ hoặc khối cầu lăn không trượt và là điều kiện đối với chuyển động lăn thuần túy.
Độ lớn gia tốc tịnh tiến của khối tâm là:
_Hình 10.19 Đối với chuyển_

𝑎𝐶𝑀

𝑑𝑣𝐶𝑀
= = 𝑅
𝑑𝑡
𝑑𝜔
𝑑𝑡
= 𝑅𝛼 (10.29)
_động lăn thuần túy, khi hình trụ quay được một góc_ 𝜃 _thì khối tâm của nó đi được một_
trong đó 𝛼 là gia tốc góc của khối trụ.
_đoạn thẳng_ 𝑠 = 𝑅𝜃
**Khái niệm và nguyên lý**
**Các mô hình phân tích**


| Vật rắn quay với gia tốc góc không đổiNếu một vật rắn quay quanh trục cố định với gia tốc góc không đổi, có
thể áp dụng các phương trình động học tương tự các phương trình động học
của chuyển động tịnh tiến với gia tốc không đổi:𝜔𝑓 = 𝜔𝑖 + 𝛼𝑡 (10.6)𝜃 = 𝜃 + 𝜔 𝑡 + 1 𝛼𝑡2(10.7)𝑓 𝑖 𝑖 2𝜔2= 𝜔2+ 2𝛼(𝜃𝑓 − 𝜃𝑖) (10.8)𝑓 𝑖1𝜃𝑓 = 𝜃𝑖 + 2 (𝜔𝑖 + 𝜔𝑓)𝑡 (10.9) | ![](images/image11.jpeg) |
| --- | --- |

 
| Vật rắn quay dưới tác dụng của mômen lực tổng
hợpNếu vật rắn quay tự do quanh trục cố định và có các mômen ngoại lực
tác dụng lên nó, thì vật có gia tốc góc 𝛼, trong đó:∑ 𝜏𝑒𝑥𝑡 = 𝐼𝛼 (10.18)Phương trình này trong chuyển động quay tương tự như định luật 2
Newton trong mô hình chất điểm chịu tác dụng của hợp lực. | ![](images/image12.jpeg) |
| --- | --- |

# Public_135

Chủ đề trung tâm của chương này là mômen động lượng, là đại lượng đóng vai trò quan trọng trong động lực học chuyển động quay. Tương tự như nguyên lý bảo toàn động lượng, ta cũng có nguyên lý bảo toàn mômen động lượng. Mômen động lượng của một hệ cô lập là không đổi. Đối với mômen động lượng, một hệ cô lập là một

hệ không có các mômen ngoại lực tác dụng lên hệ. Nếu có mômen ngoại lực tác dụng lên hệ thì hệ đó không cô lập. Giống như định luật bảo toàn động lượng, định luật bảo toàn mômen động lượng là một định luật cơ bản của vật lý, nó cũng có giá trị đối với các hệ tương đối và lượng tử.

## ![](images/image1.png) Tích vectơ và mômen lực

![](images/image2.png)Điều quan trọng khi xác định mômen động lượng là nhân 2 vectơ bằng toán tử tích có hướng.

Xét lực 𝐹⃗ tác dụng lên chất điểm tại vị trí vectơ 𝑟⃗ (hình 11.1). Như đã biết trong mục 10.6, độ lớn của mômen lực của lực này đối với một trục quay đi qua gốc là 𝑟𝐹 sin 𝜑, trong đó 𝜑 là góc giữa các vectơ 𝑟⃗ và 𝐹⃗. Trục mà lực 𝐹⃗ có

xu hướng tạo ra chuyển động quay quanh nó là trục vuông

góc với mặt phẳng tạo bởi các vectơ 𝑟⃗ và 𝐹⃗.

Vectơ mômen lực 𝜏⃗ được liên kết với các vectơ 𝑟⃗ và 𝐹⃗. Ta có thể thiết lập một mối liên hệ toán học giữa 𝜏⃗ , 𝑟⃗ và 𝐹⃗ bởi một toán tử được gọi là tích vectơ:


| 𝜏⃗ = 𝑟⃗ × 𝐹⃗ | (11.1) |
| --- | --- |

 

Bây giờ ta đưa ra một định nghĩa chính thức của tích vectơ. Cho trước hai vectơ 𝐴⃗ và 𝐵⃗⃗ bất kì, tích vectơ 𝐴⃗ × 𝐵⃗⃗ được định nghĩa như là vectơ thứ ba 𝐶⃗ có độ lớn bằng

𝐴𝐵 sin 𝜃, trong đó 𝜃 là góc giữa hai vectơ 𝐴⃗ và 𝐵⃗⃗. Tức là nếu 𝐶⃗ được cho bởi 𝐶⃗ = 𝐴⃗ × 𝐵⃗⃗ thì độ lớn của nó là 𝐶 =

𝐴𝐵 sin 𝜃.

_Hình 11.1: Vectơ mômen lực_ 𝜏⃗ _hướng vuông góc với mặt phẳng tạo bởi vectơ vị trí_ 𝑟⃗ _và vectơ lực tác dụng_ 𝐹⃗ _. Trên hình vẽ này,_ 𝑟⃗ _và_ 𝐹⃗ _nằm trong mặt phẳng xy, nên mômen lực_
_dọc theo trục z._

## ![](images/image4.png) Mô hình phân tích : Hệ không cô lập (mômen động lượng)

Hình dung một cái cột được dựng lên trên một hồ nước đóng băng (hình 11.3). Một người trượt băng trượt nhanh về phía cái cột, theo hướng hơi lệch sang bên để không va vào cái cột. Khi cô ta trượt ngang qua cái cột, cô ta chìa tay ra bên hông và túm lấy cái cột. Hành động này làm cho cô ta chuyển động tròn xung quanh cái cột. Giống như ý tưởng về động lượng giúp ta phân tích chuyển động tịnh tiến, một sự tương tự trong chuyển động quay, mômen

Bây giờ ta có thể viết (11.9) như sau:

![C:\Users\ACER\Desktop\Untitled.png](images/image5.png)

![](images/image6.png)![](images/image7.png)![](images/image8.png) _Hình 11.4: Mômen động lượng L của chất điểm là một véctơ cho bởi L_ = _r_ × _p_


 

**Mômen động lượng của hệ chất điểm**

Dùng các kỹ thuật như trong mục 9.7, ta có thể chỉ ra rằng định luật 2 Newton đối với hệ chất điểm là:

_F ext_ = __d Ptot__
_dt_

Phương trình này cho thấy tổng ngoại lực tác dụng lên hệ chất điểm thì bằng tốc độ biến thiên theo thời gian của động lượng toàn phần của hệ.

Ta hãy xem một phát biểu tương tự như vậy có thể được thực hiện đối với chuyển động quay hay không. Mômen động lượng toàn phần của hệ chất điểm đối với một trục quay nào đó được xác định bằng tổng véctơ mômen động lượng của từng chất điểm riêng biệt:

_Ltot_ = _L_ 1 + _L_ 2 + _L_ 3 + ... + _Ln_ = ∑ _Li_

trong đó tổng vectơ được lấy trên toàn bộ n chất điểm của hệ.

Lấy đạo hàm biểu thức này theo thời gian ta có:
_dLtot dt_
= _dLi_ = τ
_dt i_
_i i_

Ở đây ta đã dùng phương trình (11.11) để thay thế tốc độ biến thiên theo thời gian của mômen động lượng của mỗi chất điểm với mômen lực tác dụng lên mỗi chất điểm.

Phương trình này trong chuyển động quay tương tự với phương trình ∑ _Fext_
= _dPtot_
_dt_
đối

với hệ chất điểm. Phương trình 11.13 là biểu diễn toán học của sự diễn tả mô hình hệ không cô lập mômen động lượng. Nếu hệ không cô lập theo nghĩa có mômen lực tác dụng lên nó, thì mômen lực bằng tốc độ biến thiên theo thời gian của mômen động lượng.

Mặc dù ta không chứng minh ở đây, nhưng phát biểu này là đúng bất kể chuyển động của khối tâm. Nó có thể áp dụng ngay cả khi khối tâm đang gia tốc, miễn là mômen lực và mômen động lượng được đánh giá so với một trục quay đi qua khối tâm.

Sắp xếp lại phương trình 11.13 và lấy tích phân ta được
∫ _ext_ ) _dt_ = ∆ _L_
![](images/image9.jpeg)![](images/image6.png)![](images/image10.png)Phương trình này trong chuyển động quay tương tự với phương trình của định lí xung lực-động lượng của hệ chất điểm (9.40). Phương trình này biểu diễn _định lí xung lượng của mômen lực- mômen động lượng_.

## ![](images/image11.png) Mômen động lượng của vật rắn quay

Trong ví dụ 11.4, ta đã khảo sát mômen động lượng của một hệ có thể biến dạng. Bây giờ ta sẽ tập trung sự chú ý vào hệ không biến dạng, gọi là vật rắn. Xét vật rắn quay quanh một trục cố định trùng với trục z của hệ tọa độ như chỉ ra trên hình 11.7.

![](images/image14.png)![](images/image15.png)Ta hãy xác định mômen động lượng của vật này. Mỗi chất điểm của vật này quay trong một mặt phẳng xy quanh trục z với tần số góc ω . Độ lớn của mômen động lượng của

## ![](images/image16.png) Mô hình phân tích: hệ cô lập (mômen động lượng)

Trong chương 9 ta đã thấy rằng động lượng toàn phần của một hệ chất điểm là không đổi nếu hệ cô lập, tức là khi ngoại lực tác dụng lên hệ bằng không. Trong chuyển động quay, ta cũng có một định luật bảo toàn tương tự:

“Mômen động lượng toàn phần của một hệ không đổi cả độ lớn và hướng (bảo toàn) nếu tổng mômen ngoại lực tác dụng lên hệ bằng không, hoặc hệ cô lập“.

Phát biểu này thường được gọi là **nguyên lý bảo toàn mômen động lượng** và là cơ sở cho **cách diễn tả mômen động lượng của mô hình hệ cô lập**.

## ![](images/image17.png) Chuyển động hồi chuyển và các con cù

![C:\Users\ACER\Desktop\Untitled.png](images/image18.jpeg)Một kiểu chuyển động khác lạ và hấp dẫn có thể bạn đã biết là con cù quay quanh trục đối xứng của nó như trên hình 11.13a. Nếu con cù quay nhanh, trục đối xứng của nó quay quanh trục z, vẽ ra một hình nón, (Hình 11.13b). Chuyển động của trục đối xứng xung quanh trục thẳng đứng, được biết tới như là **chuyển động tiến động** , thường là chậm so với chuyển động quay của con cù.

_Hình 11.13. Chuyển động tiến động của con cù quay quanh trục đối xứng của nó. a) Các ngoại lực tác dụng lên con cù chỉ là phản lực_

![](images/image19.png)![](images/image22.png)![](images/image6.png)![](images/image23.png) _pháp tuyến n và trọng lực Mg . Hướng của mômen động lượng L_

_dọc theo trục đối xứng. b) Vì_
_Lf_ = ∆ _L_ \+ _Li_
_nên con cù tiến động quanh_

_trục z._

![](images/image24.png)![](images/image6.png)Câu hỏi nảy sinh một cách tự nhiên ở đây là tại sao con cù không bị đổ xuống. Vì khối tâm của nó không ở ngay trên điểm trụ O, nên có một mômen lực tác dụng lên con cù đối với trục quay đi qua O, mômen lực này gây bởi trọng lực _Mg_ . Con cù sẽ đổ xuống nếu như nó

không quay. Tuy nhiên vì nó quay, nên nó có một mômen động lượng _L_ hướng dọc theo trục đối xứng của nó. Ta sẽ chỉ ra rằng trục đối xứng này chuyển động xung quanh trục z (xảy ra chuyển động tiến động) vì mômen lực làm cho hướng của trục đối xứng thay đổi. Sự minh họa này là một ví dụ tuyệt vời về tầm quan trọng của bản chất véctơ của mômen động lượng.

∑τ _ext_

= _dLtot_
_dt_

![](images/image27.png)![](images/image19.png)![](images/image27.png)![](images/image6.png)Biểu thức này chỉ ra rằng trong khoảng thời gian vô cùng nhỏ dt, mômen lực gây ra một độ biến thiên mômen động lượng _dL_ , cùng hướng với τ . Do đó, giống như véctơ mômen

![](images/image28.png)lực, _dL_ cũng phải vuông góc với _L_ . Hình 11.14c minh họa chuyển động tiến động của trục đối xứng của con quay. Trong khoảng thời gian dt, độ biến thiên mômen động lượng là

![](images/image29.png)![](images/image30.png)![](images/image27.png)![](images/image6.png)![](images/image6.png) _dL_ = _Lf_ − _Li_ = τ _dt_ . Vì _dL_ vuông góc với _L_ , nên độ lớn của _L_ không thay đổi,
. Hơn

![](images/image6.png)![](images/image27.png)nữa, sự thay đổi chỉ là hướng của _L_ . Vì sự thay đổi mômen động lượng _dL_ là theo hướng của

![](images/image19.png)τ , nằm trong mặt phẳng xy, nên con quay hồi chuyển chịu chuyển động tiến động.

![C:\Users\ACER\Desktop\Untitled.png](images/image31.jpeg)

_Hình 11.14. a) Một con quay hồi chuyển được đặt trên một cái trụ ở đầu mút bên phải. b) Giản đồ đối với con quay chỉ ra các lực, mômen lực và mômen động lượng. c) Nhìn từ trên xuống (dọc theo trục z) các vectơ mômen động lượng của con quay tại thời điểm đầu và cuối của khoảng thời gian rất ngắn dt._

![](images/image32.png)![](images/image32.png)![](images/image10.png)Để đơn giản hóa sự mô tả hệ, giả sử mômen động lượng toàn phần của bánh xe tiến động là tổng của mômen động lượng _I_ ω do quay và mômen động lượng do chuyển động của khối tâm so với trục đứng. Trong cách xử lý này, ta bỏ qua phần đóng góp của chuyển động của khối tâm và lấy mômen động lượng toàn phần chỉ là _I_ ω . Trong thực hành, sự xấp xỉ này là tốt khi ω lớn.

Giản đồ véctơ trên hình 11.14c cho thấy rằng trong khoảng thời gian dt, véctơ mômen động lượng quay được một góc _d_ φ , cũng là góc mà con quay hồi chuyển quay được. Từ tam

Chia cả 2 vế cho dt và dùng công thức _L_ = _I_ ω

trục thẳng đứng là:

ta thấy rằng tốc độ trục xe quay đối với


| ω =dφ= MgrCMPdtIω | (11.20) |
| --- | --- |

 

Tần số góc ω _P_ gọi là **tần số tiến động**. Kết quả này chỉ đúng khi ω _P_ << ω . Nếu không,

sẽ liên quan đến một chuyển động phức tạp hơn nhiều. Như bạn có thể thấy từ phương trình

(11.20), điều kiện ω _P_ << ω thỏa mãn khi ω rất lớn, tức là khi bánh xe quay rất nhanh. Hơn

nữa, chú ý rằng tần số tiến động suy giảm khi ω tăng, tức là khi bánh xe quay càng nhanh quanh trục đối xứng của nó.

Một ví dụ về con quay hồi chuyển, giả sử bạn đang ở trên một con tàu vũ trụ trong không gian xa xôi, và bạn cần thay đổi quỹ đạo của tàu. Để lái động cơ chạy đúng hướng, bạn cần phải xoay tàu vũ trụ. Tuy nhiên, làm thế nào để bạn xoay con tàu vũ trụ trong không gian trống rỗng? Cách thứ nhất là phải có các động cơ tên lửa nhỏ bắn ra vuông góc với tàu, cung cấp một mômen lực đối với khối tâm của tàu. Một cơ cấu như vậy là đáng mong muốn, và nhiều tàu vũ trụ có các tên lửa như vậy.


| ![](images/image33.jpeg) | ![](images/image34.jpeg) |
| --- | --- |
| Hình 11.15. a) Tàu vũ trụ mang theomột con quay đang đứng yên chưa quay. | b) Con quay được điều khiển cho quay. |

 

Tuy nhiên, ta hãy khảo sát phương pháp khác liên quan tới mômen động lượng, và không đòi hỏi tiêu thụ nhiên liệu tên lửa. Giả sử tàu vũ trụ mang một con quay hồi chuyển không

quay như trên hình 11.15a. Trong trường hợp này, mômen động lượng của tàu vũ trụ đối với khối tâm của nó bằng không. Giả sử con quay được làm cho quay, cung cấp cho nó một mômen động lượng khác không. Không có mômen ngoại lực tác dụng lên hệ cô lập (tàu vũ trụ-con quay), cho nên mômen động lượng của hệ này phải bằng không theo mô hình hệ cô lập (mômen động lượng). Mômen động lượng của hệ bằng không nếu tàu vũ trụ quay theo chiều ngược với chiều quay của con quay sao cho véc tơ mômen động lượng của tàu và của con quay khử lẫn nhau. Kết quả của việc làm cho con quay quay như trên hình 11.15b là tàu quay vòng. Bằng cách bố trí ba con quay theo ba trục vuông góc với nhau, có thể thu được sự quay mong muốn trong không gian.

Hiệu ứng này tạo ra một tình huống không mong muốn đối với tàu Voyager 2 trong chuyến bay của nó. Tàu này đã mang một máy ghi âm (dùng băng) mà phần guồng (ống) của nó quay ở tốc độ rất cao. Mỗi lần máy thu băng được bật lên, guồng tác dụng như một con quay hồi chuyển và tàu bị quay theo hướng ngược lại. Sự quay này đã được Trung tâm điều khiển tàu (Mission Control) dùng các vòi phun bắn về một phía để dừng sự quay.

_**Câu hỏi 11.1:**_ Cho hai quả cầu đặc và rỗng cùng khối lượng và bán kính. Chúng chuyển động quay cùng tốc độ góc. Hỏi quả cầu nào có mômen động lượng lớn hơn:

  1. Quả cầu đặc.

  2. Quả cầu rỗng.

  3. Bằng nhau.

  4. Không thể xác định.


_**Câu hỏi 11.2:**_ Một người thợ lặn lao ra từ tàu xuống nước với cơ thể duỗi thẳng và quay chậm. Hỏi động năng quay của cô ấy sẽ như thế nào:

  1. Tăng lên.

  2. Giảm đi.

  3. Không đổi.

  4. Không thể xác định.


![](images/image6.png)![](images/image35.png)![](images/image36.png)

**Khái niệm và nguyên lý**
**Mô hình phân tích để giải bài toán**


| ![](images/image37.png) | ![](images/image38.png) |
| --- | --- |

 

  1. Cho hệ gồm: một thanh nhẹ, mảnh có chiều dài l = 1m, hai vật (xem như chất điểm) được gắn hai đầu thanh. Hạt một khối lượng 𝑚1 = 4 𝑘𝑔 và vật hai khối lượng 𝑚2 = 3 𝑘𝑔. Hệ quay quanh tâm, trong mặt phẳng xy (như hình). Tính momen động lượng của hệ so với gốc biết tốc độ của mỗi hạt là 5,00 m / s.


![](images/image39.jpeg)

  2. Một vật nặng có m = 2kg được gắn vào đầu của một sợi dây quấn quanh ròng rọc như hình vẽ. Ròng rọc là một vành tròn bán kính R


![](images/image40.jpeg)= 8cm và khối lượng M = 2 kg. Các nan hoa có khối lượng không đáng kể.

  1. Tính tổng mômen lực đối với trục ròng rọc.

  2. Khi vật chuyển động với tốc độ v thì ròng rọc quay với tốc độ góc = _v_. Xác định tổng mômen động lượng của hệ đối với trục


R

ròng rọc theo v.

  3. Sử dụng kết quả câu a và τ⃗⃗ = d⃗⃗⃗L⃗⃗⃗ để tính gia tốc của ròng rọc.


dt

  3. Một hạt 5.00kg bắt đầu chuyển động từ gốc tại t = 0. Vận tốc cho bởi phương trình:


𝑣⃗ = (6𝑡2𝚤⃗ + 2𝑡𝚥⃗)
Với 𝑣⃗ tính bằng m/s và t tính bằng s.

  1. Tìm vị trí của nó theo thời gian.

  2. Mô tả chuyển động của nó.

  3. Tính gia tốc theo thời gian

  4. Tính tổng ngoại lực tác động lên hạt theo thời gian,

  5. Tính tổng momen ngoại lực so với gốc tác động lên hạt theo thời gian,

  6. Tính mômen động lượng so với gốc theo thời gian

  7. Tính động năng của hạt theo thời gian,

  8. Tính công suất truyền cho hạt theo thời gian.


  4. Một đĩa khối lượng đồng nhất m = 3,00 kg và bán kính r = 0,200 m quay quanh một trục cố định vuông góc với đĩa với tần số góc 6,00 rad / s. Tính độ lớn mômen động lượng của đĩa khi trục quay

1. Đi qua khối tâm của đĩa

2. Đi qua một điểm giữa khối tâm và vành đĩa.

  5. Khoảng cách giữa tâm của hai bánh xe của một xe máy là 155 cm. Khối tâm của xe máy, kể cả người lái nằm trên mặt đất 88 cm và ở giữa 2 bánh xe. Giả sử khối lượng của mỗi bánh xe không đáng kể so với người lái và xe. Động cơ chỉ lái bánh sau. Hỏi giá trị gia tốc theo phương ngang nào của xe máy sẽ làm bánh xe trước văng lên khỏi mặt đất.

  6. Một bàn xoay bán kính R = 2,00 m có mômen quán tính I = 250 𝑘𝑔𝑚2 và quay không có ma sát ở tốc độ 10,0 vòng / phút theo một trục vuông góc với nó. Một đứa trẻ nặng 25,0 kg nhảy lên vòng xoay và ngồi xuống cạnh vòng xoay. Tìm tốc độ góc mới của vòng xoay?

  7. ![](images/image41.jpeg)Một học sinh ngồi trên một chiếc ghế xoay tự do cầm hai quả tạ, mỗi chiếc có khối lượng 3,00 kg (như hình). Khi dang tay ra theo chiều ngang (hình a), tạ cách trục quay là 1.00 m và học sinh quay với tốc độ góc là 0,750 rad / s. Tổng momen quán tính của ghế xoay và học sinh đối với trục quay là 3,00 kg.m2 và được xem như không đổi. Học sinh co tay lại theo chiều ngang tới vị trí quả tạ cách trục xoay 0,300 m (hình b).

1. Tìm tốc độ góc mới của học sinh.

2. Tìm động năng quay của hệ trước và sau khi học sinh co tay.

  8. ![](images/image42.jpeg)Một khối gỗ có khối lượng M đăt trên bề mặt bàn nằm ngang không ma sát được gắn vào một thanh cứng có chiều dài l và khối lượng không đáng kể (hình), thanh cứng này được gắn một đầu cố định vào bàn và có thể xoay quanh đầu này. Một viên đạn chuyển động trên bề mặt mặt bàn với vận tốc v có phương vuông góc với thanh cứng đến va chạm và cắm vào khối gỗ.

1. Tính mômen động lượng của hệ viên đạn – khối gỗ đối với trục quay thẳng đứng đi qua điểm cố định của thanh cứng.

2. Tính tỷ số phần năng lượng của viên đạn đươc chuyển hóa thành nội năng của hệ sau va chạm.

  9. ![](images/image43.jpeg)Một viên đạn nặng 0,005kg được bắn vào cánh cửa nặng 18kg theo phương ngang với tốc độ 103 m/s, viên đạn cắm vào cửa ở vị trí các mép dưới một đoạn 10 cm (như hình). Cánh cửa rộng 1 m và có thể xoay quanh bản lề, bỏ qua ma sát.

1. Trước khi viên đạn chạm vào cánh cửa nó có mômen động lượng so với trục quay của cánh cửa hay không?

2. Nếu có hãy tính giá trị của mômen động lượng này, nếu không hãy giải thích.

3. Cơ năng của hệ viên đạn – cánh cửa có bảo toàn trong suốt quá trình va chạm không?

4. Tốc độ góc của cánh cửa ngay sau khi va chạm là bao nhiêu?

5. Tính tổng năng lượng của hệ viên đạn – cánh cửa sau va chạm và xác định xem nó ít hơn hay bằng với động năng của viên đạn trước khi va chạm.

  10. ![](images/image44.jpeg)Ba vật có khối lượng bằng nhau được gắn với một thanh cứng không có khối lượng như hình. Thanh cứng đang nằm ngang, đứng yên thì bắt đầu xoay tự do trong mặt phẳng


thẳng đứng với trục quay đi qua điểm P. Giả sử m và d đã biết, hãy tìm

  1. Mômen quán tính của 3 vật này đối với trục quay qua P,

  2. Mômen xoắn tác động lên hệ tại t = 0,

  3. Gia tốc góc của hệ tại t = 0,

  4. Gia tốc tiếp tuyến của vật 3 tại t = 0,

  5. Động năng cực đại của hệ,

  6. Tốc độ góc tối đa thanh đạt được,

  7. Mômen động lượng cực đại của hệ và

  8. Tốc độ cực đại của vật hai.


  11. ![](images/image45.jpeg)Bắn một viên đạn có khối lượng m với tốc độ 𝑣𝑖 về phía phải (như hình a) và đâm vào đầu thanh sắt cố định có khối lượng M, chiều dài d, xoay quanh trục không ma sát vuông góc với mặt phẳng hình vẽ qua O (như hình). Chúng ta muốn xác định được tỷ số động năng thay đổi trong hệ do va chạm.

1. Mô hình phân tích nào thích hợp để mô tả chuyển động của viên đạn và thanh sắt?

2. Xác định mômen động lượng của hệ trước va chạm đối với trục quay qua O?

3. Mômen quán tính của hệ đối với trục qua O sau khi m cắm vào thanh.

4. Nếu tốc độ góc của hệ thống sau va chạm là ω, xác định mômen động lượng của hệ sau va chạm.

5. Tính tốc độ góc ω sau va chạm,

6. Tính động năng của cơ hệ trước khi va chạm và

7. Tính động năng của cơ hệ sau va chạm.

8. Tính tỷ số động năng trước và sau va chạm.

  12. ![](images/image46.jpeg)Hai phi hành gia (như hình), mỗi người có khối lượng 75kg, được nối với nhau bằng một sợi dây dài 10 m và có khối lượng không đáng kể. Xem như họ cô lập trong không gian và quay quanh khối tâm của họ với tốc độ 5 m/s. Xem như các phi hành gia là các chất điểm

1. Tính độ lớn của mômen động lượng của hệ hai phi hành gia và

2. Tính động năng quay của hệ.


Một phi hành gia kéo sợi dây thừng để rút ngắn khoảng cách giữa hai người còn 5 m.
Hãy tính

  3. Mômen động lượng mới của hệ,

  4. Tốc độ mới của phi hành gia và

  5. Động năng quay mới của hệ thống.

  6. Hóa năng dự trữ trong cơ thể của phi hành gia đã được chuyển đổi thành cơ năng của hệ khi anh ta rút ngắn sợi dây là bao nhiêu?


  13. Hiện tượng nóng lên của Trái đất đang rất được quan tâm bởi vì ngay cả những thay đổi nhỏ trong nhiệt độ Trái đất có thể có những hậu quả đáng kể. Ví dụ, nếu những tảng băng ở hai cực của Trái đất tan chảy hoàn toàn, thì nước trong các đại dương nhiều lên và làm tràn ngập nhiều vùng duyên hải.


Mô hình tảng băng ở 2 cực có khối lượng 2.3 × 1019kg và có dạng đĩa phẳng bán kính 6 × 105m . Giả sử các tảng băng sau khi tan chảy sẽ tạo thành lớp vỏ hình cầu là nước bao quanh Trái đất. Hỏi độ dài một ngày đêm thay đổi một lượng bao nhiêu so với hiện tại là 24 giờ/ngày? (tính theo giây và %). Cho khối lượng Trái đất là 5,972 × 1024kg và bán kính Trái đất là 6371 km.

# Public_136

Cân bằng tĩnh là trạng thái chuyển động đặc biệt của vật rắn. Khi đó, vật rắn có vận tốc chuyển động tịnh tiến và vận tốc chuyển động quay đều bằng 0 trong một hệ quy chiếu quán tính. Trạng thái cân bằng tĩnh này được ứng dụng rất nhiều trong kỹ thuật dân dụng, kiến trúc và cơ khí.

## ![](images/image1.png) Mô hình phân tích: Vật rắn ở trạng thái cân bằng

Cân bằng có nghĩa là một vật chuyển động với vận tốc dài và vận tốc góc không đổi so với một quan sát viên trong một hệ quy chiếu quán tính.

Ở đây ta quan tâm đến trường hợp đặc biệt mà cả hai loại vận tốc này bằng không

  * Trường hợp này được gọi là _cân bằng tĩnh._


Cân bằng tĩnh là một tình huống thường gặp trong kỹ thuật, đặc biệt là trong xây dựng, kiến trúc và cơ khí.

### Sự đàn hồi:

Chúng ta có thể thảo luận về việc các vật bị biến dạng như thế nào trong điều kiện chịu

tải.

Một vật đàn hồi sẽ trở lại hình dạng ban đầu khi không còn lực làm nó biến dạng. Người ta định nghĩa nhiều hằng số đàn hồi khác nhau, tương ứng với mỗi kiểu biến dạng

khác nhau.

Trong _mô hình hạt ở trạng thái cân bằng_ thì một hạt chuyển động với vận tốc không đổi do hợp lực tác dụng lên nó bằng không.

Với các vật thật (dạng mở rộng) thì tình huống sẽ phức tạp hơn nhiều.

  * Thường thì không thể xem các vật là các hạt.


Với một vật thật ở trạng thái cân bằng thì cần thỏa mãn một điều kiện thứ hai:

  * Điều kiện này liên quan đến chuyển động quay của vật.


Một vật khi ở trạng thái cân bằng tĩnh thì: tổng ngoại lực và tổng mômen ngoại lực tác dụng lên vật bằng 0.

Các điều kiện này mô tả **mô hình vật rắn ở trạng thái cân bằng**.

Các lưu ý về cân bằng:

Cân bằng tịnh tiến

Điều kiện thứ nhất về cân bằng là phát biểu về cân bằng tịnh tiến.

  * Gia tốc tịnh tiến của khối tâm của vật phải bằng không.

  * Điều này được áp dụng trong một hệ quy chiếu quán tính. Cân bằng quay

  * Điều kiện thứ hai về cân bằng là một phát biểu về cân bằng quay.

  * Gia tốc góc của vật bằng không.

  * Điều này phải đúng với mọi trục quay.


### Cân bằng động và cân bằng tĩnh

Trong chương này, ta tập trung vào cân bằng tĩnh.

  * Vật không chuyển động.

  * vCM = 0 và ω = 0


Mômen hợp lực bằng không không có nghĩa là vật không chuyển động quay. Cân bằng động cũng có thể xảy ra.

  * Vật có thể quay với vận tốc góc không đổi.

  * Vật có thể chuyển động với vận tốc khối tâm không đổi.


### Các phương trình trong cân bằng

Ta sẽ giới hạn các ứng dụng cho các tình huống mà các lực nằm trong mặt phẳng _xy_

  * Các lực này được gọi là đồng phẳng vì chúng cùng nằm trong một mặt phẳng

  * Giới hạn này dẫn đến 3 phương trình theo các trục. Các phương trình này là:

  * ΣFx = 0

  * ΣFy = 0

  * Στz = 0 (12.3)


Vị trí của trục của phương trình mômen quay được chọn bất kỳ.

## ![](images/image3.png) Ví dụ về vật rắn ở trạng thái cân bằng

### Chiến lược giải toán về cân bằng Khái niệm hóa

Tìm tất cả các lực tác dụng lên vật.

Hình dung ảnh hưởng của mỗi lực đến sự quay của vật như là chỉ có lực này tác dụng lên vật.

### Phân loại

### 

Khẳng định rằng vật là một vật rắn cân bằng.

Vật phải có gia tốc tịnh tiến và gia tốc góc bằng không.

### Phân tích

![](images/image4.png)Vẽ một sơ đồ.

Vẽ và đặt tên tất cả các ngoại lực tác dụng lên vật.

Mô hình hạt chịu tác dụng của hợp lực: có thể biểu diễn vật như là một điểm trong sơ đồ lực vì ta không quan tâm đến điểm tác động của lực lên vật.

Mô hình vật rắn cân bằng: Không thể biểu diễn vật bằng một điểm vì điểm tác động của các lực là quan trọng.

Lập một hệ tọa độ thuận tiện.

Tìm thành phần của các lực theo hai trục tọa độ.

Áp dụng điều kiện thứ nhất về cân bằng (ΣF=0). Cẩn thận với các dấu cộng, trừ.

_Hình 12.1: Hệ chai rượu và giá đỡ cân bằng_

Chọn một trục thuận tiện cho việc tính mômen quay tổng hợp đối với vật rắn: Nhớ rằng việc chọn trục là tùy ý.

Chọn một trục sao cho các phép tính là đơn giản nhất: Lực tác dụng dọc theo đường thẳng đi qua gốc có mômen quay bằng không

Áp dụng điều kiện thứ 2 của cân bằng.

Hai điều kiện cân bằng sẽ cho ta một hệ phương trình. Giải hệ phương trình.

### Hoàn tất

Bảo đảm rằng các kết quả là phù hợp với sơ đồ ban đầu.

Nếu lời giải cho thấy một lực âm thì lực đó ngược với chiều mà ta đã vẽ trong sơ đồ.

Kiểm tra các kết quả để bảo đảm rằng:

∑ _Fx_ = 0,∑ _Fy_ = 0, ∑ _Fz_ = 0 .

Sự cân bằng của hệ chai rượu và giá đỡ trong hình 12.1 là một ví dụ thú vị về trạng thái cân bằng tĩnh của vật rắn. Để chai rượu có thể đứng cân bằng trên giá đỡ thì cần hai điều kiện: tổng hợp lực và tổng mômen lực tác dụng lên hệ phải bằng không. Để điều kiện thứ hai được thỏa mãn thì trọng tâm của hệ gồm chai rượu và giá đỡ phải ở trên đường thẳng đứng đi qua điểm đặt của giá đỡ trên bàn.

### ![1208a](images/image5.jpeg)Bài tập mẫu 12.1: Người đứng trên xà ngang:

Một thanh xà đồng chất nằm ngang có chiều dài _l_ = 8.00 m và trọng lượng _Wb_ =200 N được gắn vào tường bởi một trục quay. Đầu còn lại của xà được móc vào cáp treo lập một góc

Φ=53° so với xà (hình 12.8a). Một người có trọng lượng Wp=5600 N đứng trên xà và cách tường một khoảng d=2.00 N. Tìm lực căng của cáp treo cũng như độ lớn và hướng của lực mà tường tác dụng lên xà.

### Giải:

**Khái niệm hóa**

Thanh xà là đồng chất.

![1208b](images/image6.jpeg)Trọng tâm của xà là ở tâm hình học của xà (trung điểm của xà).

Người đứng trên xà.

Lực căng của cáp và lực mà tường tác dụng lên xà là gì?

### Phân loại

Hệ đứng yên, phân loại bài toán như là một vật rắn nằm cân bằng.

### Phân tích

![1208c](images/image7.jpeg)Vẽ một sơ đồ lực (hình 12.8b).

Dùng trục quay cho trong bài toán (nằm trên tường) làm trục quay: Cách này là đơn giản nhất

Lưu ý là ở đây có 3 ẩn số (đại lượng cần tìm) là

_T_ , _R_ , θ.

Có thể phân tích các lực thành các thành phần.

Áp dụng 2 điều kiện cân bằng, ta thu được 3 phương trình.

Giải hệ phương trình để tìm các ẩn số.

### Hoàn tất

Giá trị của _θ_ cho thấy hướng của _R_ trong đồ thị là đúng.

### Bài tập mẫu 12.2: Thang dựng nghiêng

![1209a](images/image8.jpeg)Một cái thang đồng chất có chiều dài _l_ tựa vào một cái tường nhẵn, thẳng đứng (hình 12.9a). Khối lượng của thang là _m_ và hệ số ma sát giữa thang và sàn nhà là μ=0,40. Tìm góc nghiêng nhỏ nhất θmin để thang không bị trượt.

### Khái niệm hóa

Thang là đồng chất.

Trọng lượng của thang đặt ở tâm hình học của nó (cũng là trọng tâm).

Giữa thang và sàn nhà có ma sát nghỉ (ma sát tĩnh).

### Phân loại

Mô hình hóa vật như là một vật rắn nằm cân bằng: do ta không muốn thang trượt

### Phân tích

Vẽ một sơ đồ chỉ ra tất cả các lực tác động lên thang. Lực ma sát là ƒs = µs n.

Chọn O làm trục quay.

Áp dụng các phương trình của 2 điều kiện cân bằng. Giải các phương trình.

# Public_137

Trước năm 1687, số liệu về chuyển động của Mặt Trăng và các hành tinh đã được thu thập rất nhiều. Tuy nhiên, những chuyển động này là do loại lực nào gây ra thì vẫn là một bí ẩn. Ngay chính năm đó, Isaac Newton đã đưa ra chìa khóa cho vấn đề này.

Từ định luật I của mình, ông biết rằng có đang có một lực tổng hợp nào đó đang tác động lên Mặt Trăng vì nếu không có thì Mặt Trăng đã chuyển động với quỹ đạo thẳng chứ không phải tròn như hiện tại. Newton chỉ ra rằng chính trọng lực của Trái Đất đã tác động lên Mặt Trăng. Ông nhận ra rằng lực hút giữa Trái Đất và Mặt Trăng, giữa Mặt Trời và các hành tinh thực ra chính là trường hợp đặc biệt của lực hút giữa các vật. Nói một cách khác, lực hút làm Mặt Trăng quay quanh Trái Đất, cũng chính là lực làm làm quả táo rơi từ trên cây.

Trong chương này, chúng ta sẽ học về Định luật vạn vật hấp dẫn. Định luật này sẽ được kiểm chứng bởi các số liệu quan sát thiên văn học. Chúng ta cũng chỉ ra rằng các định luật về chuyển động của các hành tinh được trình bày bởi Johannes Kepler cũng suy ra được nhờ định luật vạn vật hấp dẫn và định luật bảo toàn moment động lượng.

## 

### Trọng lực

Trọng lực là trường hợp riêng của lực hấp dẫn do Trái Đất tác dụng lên một vật. Độ lớn của trọng lực là:

Với:

  * m: khối lượng của vật


𝑃 = 𝐺 _𝑀𝐸𝑚_

(𝑅𝐸+ℎ)2

(13.2)

  * P: là trọng lực của Trái Đất tác dụng lên vật có khối lượng m

  * ME: khối lượng Trái Đất

  * RE: bán kính của Trái Đất

  * G: hằng số hấp dẫn


### Gia tốc trọng trường

Theo định luật II Newton, trọng lực P do Trái đất tác dụng lên vật m sẽ làm vật m có gia tốc là g:

ra:

_P = mg_ (13.3)

Mặt khác theo công thức (13.2), ta có: 𝑃 = 𝐺 _𝑀𝐸𝑚_ . Từ công thức (13.2) và (13.3) suy

(𝑅𝐸+ℎ)2

g: được gọi là gia tốc trọng trường.

𝑔 = 𝐺 _𝑀𝐸_

(𝑅𝐸+ℎ)2

(13.4)

## ![](images/image2.png) Trường hấp dẫn – Trọng trường

Định luật vạn vật hấp dẫn xem như một thành công lớn nữa của Newton vì nó giúp giải thích quy luật chuyển động của các hành tinh. Đồng thời, phạm vi ứng dụng của các định luật khác của ông cũng được mở rộng ra áp dụng cho các vật thể có kích thước và khối lượng lớn như các hành tinh trong vũ trụ. Từ năm 1687, lý thuyết của Newton đã được ứng dụng vào giải thích chuyển động của sao chổi, thí nghiệm Cavendish, quỹ đạo của Sao đôi, và sự quay của các thiên hà. Tuy nhiên, cả Newton và những người cùng thời với ông đều không thể nào lý giải được tại sao hai vật ở xa mà có thể tương tác được với nhau. Mãi sau khi ông mất thì khái niệm về một trường hấp dẫn xung quanh các vật có

Riêng đối với Trái Đất, trường hấp dẫn của nó được gọi là trọng trường. Với giả thiết Trái đất là quả cầu đồng nhất thì vecto cường độ của trường hấp dẫn g⃗→ có công thức là:

𝑔→ = 𝐹𝑔 _→_ = − 𝐺𝑀 _𝐸_ 𝑟→ (13.6)
𝑚 𝑟2

  * 𝐹⃗⃗⃗𝑔→ là trọng lực tác dụng lên chất điểm có khối lượng m

  * G là hằng số hấp dẫn

  * ME là khối lượng của Trái Đất

  * r: là khoảng cách từ tâm Trái Đất đến điểm mà ta đang khảo sát

  * 𝑟→ là vectơ đơn vị hướng từ tâm Trái Đất đến điểm khảo sát.


Đối với các điểm ở gần mặt đất thì giá trị r ≈ RE, khi đó 𝒈⃗→ có độ lớn là g ≈ 9,8 m/s2.

## ![](images/image3.png) Các định luật Kepler và chuyển động của các hành tinh

Từ hàng ngàn năm trước, con người đã bắt đầu quan sát chuyển động của các hành tinh và các ngôi sao và cho rằng Trái Đất là trung tâm vũ trụ. Đây là lý thuyết xuất phát từ nhà bác học người Hy Lạp Claudius Ptolemy (100 - 170). Lý thuyết này được chấp nhận trong suốt 1400 năm sau. Mãi cho đến năm 1543, nhà bác học người Ba Lan Nicolaus Copernicus (1473 – 1543) mới đưa ra một nhận định là Trái Đất và các hành tinh khác quay quanh Mặt Trời. Sau đó, vì khao khát muốn tìm ra quy luật sắp xếp của bầu trời, nhà bác học người Đan Mạch Tycho Brahe (1546 – 1601) đã miệt mài quan sát sự chuyển động của các hành tinh và 777 ngôi sao mà mắt thường có thể nhìn thấy. Nhờ dữ liệu này mà người trợ lý của Brahe – Johannes Kepler đã bỏ ra 16 năm trời để tìm ra mô hình toán học giải thích chuyển động của các hành tinh. Tuy nhiên, vì các dữ liệu này là do quan sát chuyển động ở tại Trái Đất nên gây ra rất nhiều khó khăn cho Kepler trong việc tính toán. Cuối cùng, Kepler cũng đã đưa ra được mô hình chính xác nhờ vào dữ liệu của Brahe về chuyển động của Sao Hỏa xung quanh Mặt Trời. Lý thuyết của Kepler về chuyển động của các hành tinh được tóm tắt trong ba định luật:

  1. Tất cả các hành tinh chuyển động theo các quỹ đạo elip trong đó Mặt Trời là một tiêu điểm.

  2. Vecto bán kính kẻ từ Mặt Trời đến một hành tinh quét được những điện tích bằng nhau trong những khoảng thời gian bằng nhau.

  3. Bình phương chu kỳ quỹ đạo của một hành tinh tỷ lệ với lập phương bán trục lớn của quỹ đạo elip của hành tinh đó.


### Định luật I Kepler

“Tất cả các hành tinh chuyển động theo các quỹ đạo elip trong đó Mặt Trời là một tiêu điểm.”

Các mô hình về hệ mặt trời lúc bấy giờ đều cho rằng quỹ đạo của các thiên thể đều là tròn. Tuy nhiên, theo định luật I Kepler, quỹ đạo tròn chỉ là một trường hợp đặc biệt, quỹ đạo elip mới là trường hợp tổng quát. Khám phá này của Kepler đã gặp rất nhiều thách thức vì

phần lớn các nhà khoa học thời đó đều tin rằng quỹ đạo của các hành tinh có hình tròn hoàn hảo.

Như ta đã biết, một elip (hình 13.2) sẽ được đặc trưng bởi:

  * Bán kính trục lớn (a), kính trục nhỏ (b), bán tiêu cự (c), với:


𝑎2 = 𝑏2 \+ 𝑐2 (13.7)

  * Độ lệch tâm: 𝑒 = 𝑐⁄𝑎. Độ lệch tâm là tham số có giá trị từ 0 (đường tròn) đến nhỏ hơn 1 (khi độ lệch tâm tiến tới 1, elip tiến tới dạng parabol).


![](images/image4.jpeg)

_Hình 13.2: Dạng hình học quỹ đạo elip của các hành tinh_

Độ lệch tâm quỹ đạo mà Kepler tính được cho Trái Đất là 0,017 vì vậy quỹ đạo của nó gần như là hình tròn. Đối với hành tinh có độ lệch tâm lớn nhất là Sao Thủy thì độ lệch tâm quỹ đạo của nó cũng chỉ là 0,21. Với các giá trị độ lệch tâm của các hành tinh thì quỹ đạo elip của các hành tinh rất khó phân biệt so với hình tròn. Chính vì lý do này mà các nghiên cứu của Kepler được đánh giá rất cao. Kể cả quỹ đạo elip của sao chổi Haley cũng được tính toán dựa trên định luật Kepler với độ lệch tâm là 0,97. Với bán kính trục lớn rất dài so với bán

![C:\Users\ACER\Desktop\Untitled.png](images/image6.jpeg)

_Hình 13.3: Quỹ đạo của sao Thủy (hình a) và quỹ đạo của sao chổi Haley (hình b)_

kính trục nhỏ, sao chổi Haley phải mất đến 76 năm mới chuyển động hết một vòng xung quanh Mặt Trời.

Định luật I Kepler là kết quả trực tiếp của tính chất tỷ lệ nghịch với bình phương khoảng cách của lực hấp dẫn. Dưới tác dụng của lực hấp dẫn gây ra bởi Mặt trời, các thiên thể có thể chuyển động theo các quỹ đạo hình elip (các hành tinh, tiểu hành tinh, sao chổi) hoặc parabol hoặc hyperbol (thiên thạch).

### Định luật II Kepler

“Vecto bán kính kẻ từ Mặt Trời đến một hành tinh quét được những điện tích bằng nhau trong những khoảng thời gian bằng nhau.”

![](images/image7.jpeg)

_Hình 13.4: - hình a: tác dụng lực hút của Mặt Trời lên hành tinh_

_\- hình b: trong thời gian dt, hình bình hành được tạo nên bởi 2 vectơ bán kính_ 𝑟→ _(với gốc tọa độ đặt ở Mặt Trời) và_ 𝑑𝑟→ = 𝑣→𝑑𝑡 _(13.8)_

Moment của lực hấp dẫn mà Mặt Trời tác dụng lên hành tinh đối với trục qua Mặt trời bằng không nên moment động lượng của hành tinh đối với trục qua Mặt trời được bảo toàn:

𝑈 = − 𝐺𝑀𝐸 _𝑚_

𝑟

(13.21)

Công thức (13.21) trên chỉ đúng cho những vật nằm trên và bên ngoài bề mặt Trái Đất, tức r ≥ RE. Với gốc thế năng đã chọn (∞) thì thế năng trọng trường sẽ luôn có giá trị âm.

Ta có thể phát triển công thức (13.21) lên thành thế năng hấp dẫn tổng quát hơn của hệ hai chất điểm cách nhau một khoảng r và có khối lượng lần lượt là m1 và m2 như sau:

𝑈 = − _𝐺𝑚1𝑚2_
𝑟
Đối với hệ có ba chất điểm thì tổng thế năng hấp dẫn của cả hệ sẽ bằng:
(13.22)
𝑈 = 𝑈 + 𝑈 + 𝑈 = −𝐺( _𝑚1𝑚2_ \+ _𝑚1𝑚3_ \+ _𝑚2𝑚3_ ) (13.23)

𝑡𝑜𝑡𝑎𝑙

12 13 23

𝑟12

𝑟13

𝑟23

Thế năng này có giá trị đúng bằng công cần thiết để tách các chất điểm của hệ ra xa nhau vô cùng.

## ![](images/image9.png) Năng lượng của các hành tinh và các vệ tinh

Cho hệ gồm một vật có khối lượng m chuyển động với vật tốc ν trong trường hấp dẫn của vật có khối lượng M với M >> m. Hệ này có thể là mô hình cho một hành tinh chuyển động xung quanh Mặt Trời, một vệ tinh chuyển động xung quanh Trái Đất hoặc một sao chổi chuyển động ngang qua Mặt Trời. Nếu vật M được gắn cố định trong một hệ quy chiếu quán tính thì tổng cơ năng E của hệ 2 vật sẽ chỉ là cơ năng của vật m. Cơ năng này bao gồm động năng K và thế năng hấp dẫn U của vật m (hay thế năng của hệ hai vật):

𝐸 = 𝐾 + 𝑈 (13.24)

𝐸 =

1 𝑚𝜈2
2
− 𝐺
𝑀𝑚
𝑟

(13.25)

Công thức 13.25 cho thấy cơ năng E của vật có khả năng mang các giá trị dương, âm hoặc bằng không phụ thuộc vào độ lớn vận tốc ν. Đối với các hệ liên kết như Mặt Trời-Trái Đất, Mặt Trăng – Trái Đất hoặc vệ tinh của Trái Đất thì cơ năng của vật sẽ có giá trị âm. Ta có thể dễ dàng kiểm chứng điều này qua chuyển động của một hành tinh có quỹ đạo được xem như tròn bất kỳ:

𝐹𝑔 = 𝑚𝑎 →

𝐺𝑀𝑚
𝑟2 =

𝑚𝜈2

𝑟
Nếu chia hai vế của đẳng thức trên cho 2 ta sẽ được:

𝑚𝑣2 = 𝐺𝑀𝑚

(13.26)
2 2𝑟
Áp dụng công thức (13.26) vào công thức (13.25) ta được:

𝐸 =

𝐺𝑀𝑚 2𝑟
𝐺𝑀𝑚
−
𝑟
𝐸 = − 𝐺𝑀𝑚 (quỹ đạo tròn) (13.27)

2𝑟

Trong quỹ đạo tròn, động năng của một vật có giá trị dương sẽ bằng ½ độ lớn của thế năng hấp dẫn. Vì vậy, cơ năng của vật sẽ có giá trị âm. Đây chính là năng lượng liên kết của hệ, tức năng lượng tối thiểu cần để tách riêng hai vật ra khỏi nhau xa vô cùng.

Đối với quỹ đạo elip, công thức của cơ năng sẽ giống (13.27) nhưng ta chỉ cần thay bán kính r của quỹ đạo tròn bằng bán kính trục lớn a trong quỹ đạo elip, tức là:

𝐸 = − 𝐺𝑀𝑚 (quỹ đạo elip) (13.28)

2𝑎

Nếu hệ cô lập thì cơ năng này sẽ có giá trị không đổi. Vì vậy, khi vật m chuyển động từ vị trí 1 (r1) đến vị trí 2 (r2) thì cơ năng sẽ được bảo toàn:

𝐸 =

1 𝑚𝑣2
2
− 𝐺
𝑀𝑚
𝑟𝑖
= 1 𝑚𝑣2
2
− 𝐺
𝑀𝑚
𝑟𝑗

(13.29)

# Câu hỏi lý thuyết chương 13

  1. Sắp xếp các đại lượng năng lượng sau từ lớn nhất đến nhỏ nhất. Nếu có bằng nhau thì minh họa dấu bằng.

1. giá trị tuyệt đối của thế năng trung bình của hệ Mặt trời – Trái đất.

2. động năng trung bình của Trái Đất khi chuyển động quanh Mặt trời.

3. giá trị tuyệt đối của tổng năng lượng của hệ Mặt trời – Trái đất.

  2. Giả sử gia tốc hấp dẫn ở bề mặt của một mặt trăng A của sao Mộc là _2m/s 2_. Mặt trăng B có khối lượng gấp đôi và bán kính gấp đôi của mặt trăng A. Gia tốc hấp dẫn ở bề mặt của nó bằng bao nhiêu? Bỏ qua gia tốc hấp dẫn gây bởi sao Mộc.

1. (a) 8 m/s2

2. (b) 4 m/s2

3. (c) 2 m/s2

4. (d) 1 m/s2

5. (e) 0.5 m/s2

  3. Một vệ tinh ban đầu di chuyển theo quỹ đạo tròn với bán kính R quanh Trái đất. Giả sử nó được chuyển vào quỹ đạo tròn có bán kính 4R.


  1. Lực tác động lên vệ tinh như thế nào?

1. lớn gấp tám lần

2. lớn gấp bốn lần

3. lớn gấp 1/2 lần

4. lớn gấp 1/8 lần

5. lớn gấp 1/16 lần

  2. Điều gì xảy ra với tốc độ của vệ tinh? Chọn từ các khả năng tương tự (a) đến (e).

  3. Điều gì xảy ra với chu kỳ của nó? Chọn từ các khả năng tương tự (a) đến (e).


  4. Xếp hạng độ lớn của các lực hấp dẫn sau từ lớn nhất đến nhỏ nhất. Nếu hai lực bằng nhau, minh họa dấu bằng.

1. lực tác dụng bởi vật nặng 2 kg lên vật nặng 3 kg cách nhau 1 m.

2. lực tác động bởi vật nặng 2 kg lên vật thể 9 kg cách nhau 1 m.

3. lực tác dụng bởi vật nặng 2 kg lên vật thể 9 kg cách nhau 2 m.

4. lực tác dụng bởi vật thể 9 kg lên vật thể 2 kg cách nhau 2 m.

5. lực tác dụng bởi vật thể 4 kg lên vật thể 4 kg khác cách đó 2 m.

  5. Lực hấp dẫn tác dụng lên một phi hành gia tại bề mặt Trái Đất là 650 N. Khi cô ấy đang ở trong trạm không gian quay quanh Trái Đất thì lực hấp dẫn tác dụng lên cô ấy:

1. lớn hơn 650N,

2. chính xác bằng 650N,

3. nhỏ hơn 650N,

4. gần nhưng không chính xác bằng không, hoặc

5. chính xác bằng không?


# Bài tập chương 13

  1. ![](images/image10.jpeg)Ba quả cầu đồng nhất có khối lượng m1 = 2,00 kg, m2 = 4,00 kg và m3 = 6,00 kg được đặt ở các vị trí như trong hình. Tính lực hấp dẫn tác dụng lên quả cầu m2 do hai quả cầu còn lại gây ra.


![](images/image11.png)![](images/image12.png)![](images/image13.png)ĐS: _F_
10.0 _i_ ˆ
5.93 ˆ _j_
10 11 _N_

  2. Hai vật hút lẫn nhau với lực hấp dẫn có độ lớn 1 × 10−8N khi cách nhau 20,0 cm. Nếu tổng khối lượng của hai vật thể là 5.00 kg, tính khối lượng của mỗi vật?


![](images/image14.png)ĐS: _m_ 1

  3. Gia tốc rơi tự do trên bề mặt Mặt trăng là khoảng 1/6 gia tốc rơi tự do trên bề mặt Trái đất. Bán kính của Mặt trăng là khoảng 0,250 𝑅𝐸 (𝑅𝐸 = 6,37 × 106m, 𝑅𝐸: bán kính Trái Đất). Tìm tỷ số khối lượng riêng của chúng, 𝜌𝑀 _ặ_ 𝑡 𝑡𝑟 _ă_ 𝑛 _𝑔_.


𝜌𝑇𝑟á𝑖 đấ𝑡
![](images/image16.png)![](images/image17.png)![](images/image23.jpeg)ĐS:

  4. (a) Xác định vecto cường độ trường hấp dẫn 𝑔→ tại P do hai quả cầu gây ra như trong hình.

2. Chứng minh rằng, vecto cường độ trường hấp dẫn 𝑔→ tại P bằng 0 khi r→0.

3. Chứng minh rằng, vecto cường độ trường hấp dẫn 𝑔→ tại P bằng 2 _GM_ / _r_ 2 khi 𝑟 → ∞.


ĐS: (a) _g_
2 _MGr_

![](images/image24.png)![](images/image25.png)![](images/image26.png) _3_

về phía khối tâm.
![](images/image27.png) _r_ 2 _a_ 2 2

  5. Ba quả cầu giống nhau đặt tại 3 đỉnh của hình vuông cạnh _l_ như hình bên. Xác định vecto cường độ trường hấp dẫn 𝑔→ tại O.


ĐS: _g_
_Gm_ 2
![](images/image28.png)![](images/image29.png)![](images/image30.png)![](images/image34.png)![](images/image35.png)![](images/image30.png)![](images/image34.png)![](images/image30.png)![](images/image34.png)![](images/image36.png)![](images/image37.png) _I_ 2
1 về phía góc đối diện.
2

  6. Io, một vệ tinh của sao Mộc, có chu kỳ quỹ đạo 1,77 ngày, và


![](images/image38.png)bán kính quỹ đạo là 4,22 × 105 km. Từ những dữ liệu này, xác định khối lượng của sao Mộc.
ĐS:
_MJ_
(khoảng 316 lần khối lượng Trái Đất).

  7. ![](images/image40.png)Hệ sao đôi của Plaskett bao gồm hai ngôi sao quay trên một quỹ đạo tròn có tâm là trung điểm của đoạn nối hai ngôi sao, xem như khối lượng của hai sao là bằng nhau. Giả sử tốc độ quỹ đạo của mỗi ngôi sao là|𝑣→| = 220 𝑘𝑚/𝑠 và chu kỳ quỹ đạo là 14,4 ngày. Tìm khối lượng M của mỗi ngôi sao so với khối lượng của mặt trời. (Biết khối lượng Mặt trời: 1,99 × 1030 𝑘𝑔).


![](images/image42.jpeg)ĐS:
_M_
khối lượng mặt trời.

  8. Các ngôi sao neutron là những vật thể có khối lượng riêng cực kỳ lớn, hình thành từ những tàn dư của vụ nổ siêu tân tinh (supernova). Chúng quay rất nhanh. Giả sử khối lượng của một ngôi sao neutron hình cầu gấp đôi khối lượng Mặt trời, bán kính 10,0 km. Xác định tốc độ góc lớn nhất mà nó có thể có để cho vật chất tại bề mặt của sao trên đường xích đạo của nó chỉ được giữ trong quỹ đạo bởi lực hấp dẫn.


![](images/image49.png)ĐS: _w_

  9. Một vệ tinh trong quỹ đạo Trái Đất có khối lượng là 100 kg và ở độ cao 2 × 106 𝑚.


  1. Tính thế năng của hệ thống vệ tinh - Trái Đất?

  2. Tính độ lớn của lực hấp dẫn do Trái đất tác dụng lên vệ tinh?

  3. Có những lực nào do vệ tinh tác dụng lại trái đất?


![](images/image51.png)![](images/image53.png)ĐS: a) b) _F_

  10. Sau khi Mặt trời sử dụng hết nhiên liệu hạt nhân của nó và Mặt trời sẽ trở thành sao lùn trắng. Khối lượng của sao lùn trắng này bằng khoảng một nửa khối lượng của Mặt trời, vật chất của nó được nén trong một thể tích hình cầu tương đối khiêm tốn, cỡ chỉ bằng kích thước trái đất, do đó vật chất của nó cực kỳ đặc. Tính:


  1. Mật độ trung bình của sao lùn trắng,

  2. Gia tốc rơi tự do và thế năng của một vật có khối lượng 1.00 kg ở bề mặt của sao lùn trắng.


![](images/image55.png)![](images/image56.png)![](images/image59.png)ĐS: a) b) _g_

  11. Một vệ tinh 500 kg nằm trong quỹ đạo tròn ở độ cao 500 km so với bề mặt Trái đất. Do ma sát không khí, vệ tinh cuối cùng rơi xuống bề mặt Trái Đất và chạm đất với tốc độ 2,00 km/s. Tính phần năng lượng đã được chuyển thành nội năng do ma sát với không khí.


![](images/image61.png)ĐS:

  12. Một vệ tinh 1.000 kg quay quanh Trái đất ở độ cao không đổi 100 km.


  1. Tính năng lượng phải thêm vào hệ (vệ tinh – trái đất) để di chuyển vệ tinh này vào một quỹ đạo tròn với độ cao 200 km?

  2. ![](images/image63.png)Động năng và thế năng trong hệ thay đổi như thế nào? ĐS: (a)


  13. Một vệ tinh có khối lượng 200 kg ở độ cao 200 km so với bề mặtTrái Đất.


  1. Giả sử quỹ đạo là tròn, vệ tinh mất bao lâu để hoàn thành một vòng quỹ đạo?

  2. Tính tốc độ của vệ tinh?

  3. ![](images/image65.png)![](images/image67.png)Vệ tinh xuất phát từ bề mặt trái đất, tính năng lượng tối thiểu cần thiết cung cấp cho vệ tinh này ? Bỏ qua sức cản không khí nhưng tính đến sự quay của Trái Đất quanh trục của nó.


![](images/image69.png)ĐS: (a) _T_
(b) _v_
(c)
_E_ min

  14. Một vệ tinh nằm trong quỹ đạo tròn quanh Trái đất ở độ cao 2,80.106 m. Tìm:


  1. Chu kỳ quay.

  2. ![](images/image71.png)Tốc độ và gia tốc của vệ tinh.


![](images/image73.png)ĐS: (a) _T_
(b)
_v_
về phía trái đất.

# Public_138

Vật chất thông thường tồn tại ở ba trạng thái: rắn, lỏng, khí. Chúng ta biết rằng, ở trạng thái rắn vật chất sẽ có thể tích và hình dạng xác định, ở trạng thái lỏng thì chúng chỉ có thể tích xác định còn ở trạng thái khí thì ngay cả thể tích và hình dạng đều không xác định. Những mô tả trên chỉ cho chúng ta bức tranh cơ bản về các

trạng thái tồn tại của vật chất nhưng nó không hoàn toàn chính xác. Ví dụ như nhựa đường (asphalt) và chất dẽo (plastics) thường được xem là những chất rắn nhưng sau một khoảng thời gian nó lại có xu hướng chảy như chất lỏng. Ngoài ra, trạng thái rắn, lỏng, khí của một vật chất phụ thuộc rất nhiều vào nhiệt độ và áp suất. Nói tóm lại, theo thời gian một vật chất nào đó sẽ thay đổi trạng thái rắn, lỏng, khí của nó tùy thuộc vào điều kiện bên ngoài.

Chất lưu là một hệ, gồm các phân tử sắp xếp một cách ngẫu nhiên, tương tác với nhau bằng một lực liên kết yếu và định hình được nhờ vào lực tác dụng của thành bình. Cả chất lỏng và chất khí đều là chất lưu.

Trong cơ học chất lưu, chúng ta áp dụng các định luật đã biết để nghiên cứu chất lưu ở trạng thái tĩnh và trạng thái động của chúng.

## ![](images/image1.png) Áp suất

![](images/image2.jpeg)Chất lưu không tác dụng lực căng hay lực kéo lên một vật, ở trạng thái tĩnh nó chỉ có một xu hướng là nén lên mọi mặt của một vật bất kỳ đặt trong nó _. (Hình 14.1)_

Áp suất của chất lưu có thể được đo bằng một dụng cụ rất đơn giản. Dụng cụ đo áp suất được cấu tạo bằng một xi-lanh rỗng được hút chân không nối với một pittông nhẹ bằng một lò xo. Ta có thể thấy cấu tạo của nó ở _Hình 14.2_.

Khi nhúng dụng cụ đo áp suất này vào

chất lưu cần khảo sát thì chất lưu sẽ nén một lực F lên mặt bên ngoài của pittông. Lò xo bên dưới cũng sẽ bị nén theo cho đến khi lực nén

_Hình 14.1: Lực nén của chất lưu lên một_

_vật đặt trong nó_

F của chất lưu cân bằng với lực đàn hồi của lò xo. Đo độ lớn của lực đàn hồi thì ta sẽ biết giá trị của lực nén F. Áp suất P của chất lưu khi đó chính là tỉ số giữa lực nén F và diện tích A của pittông. Tổng quát, áp suất của chất lưu chính là lực nén của chất lưu đó lên một đơn vị diện tích của bề mặt vật khác đặt trong nó. Công thức tính áp suất khi đó là:

𝑃 = 𝐹

𝐴

(14.1)

![](images/image4.jpeg)Nếu áp suất thay đổi trên toàn bề mặt của vật bị nén thì khi đó áp suất tại vi trí của diện tích nhỏ dA sẽ là:

𝑃 = 𝑑𝐹

𝑑𝐴

↔︎ 𝑑𝐹 = 𝑃𝑑𝐴 (14.2)

Vì vậy, lực tác dụng của chất lưu lên toàn diện tích bề mặt A của vật là:

𝐹 = ∫ 𝑑𝐹 = ∫ 𝑃𝑑𝐴 (14.3)

Đơn vị đó áp suất trong hệ SI là (N/m2) hay pascal (Pa):

_Hình 14.2: Dụng cụ đo áp suất chất lưu_

1 Pa = 1N/m2

Mỗi bên của phương trình này là công của lực tác động lên piston tương ứng. Do đó, công của lực F1 trên piston đầu vào bằng công của lực F2 trên piston đầu ra, vì nó phải bảo tồn năng lượng.

Các ứng dụng khác của định luật Pascal: phanh thủy lực, nâng xe hơi, đòn bẩy thủy lực, xe nâng hàng.

## ![](images/image5.png) Phương pháp đo áp suất khí quyển

Áp suất khí quyển là một thông số quan trọng luôn được đề cập đến trong các chương trình dự báo thời tiết. Giá trị của áp suất khí quyển này thay đổi theo từng vùng, từng thời điểm chứ không phải là giá trị áp suất khí quyển chuẩn Pο không đổi mà ta đã đề cập ở _mục_

_14.2_. Vậy, áp suất khí quyển này được đo như nào?

### Khí áp kế Torricelli

![](images/image6.png)Một trong những khí áp kế phổ biến đã được chế tạo bởi nhà bác học Evangelista Torricelli (1608–1647). Áp kế này gồm một ống thủy tinh dài chứa đầy thủy ngân, được úp ngược vào một chậu cũng chứa thủy ngân ( _hình 14.5_ ). Khi đó, áp suất tại mặt trên của cột thủy ngân trong ống là P = 0.

Áp suất tại điểm B và điểm A trong thủy ngân là như nhau và bằng áp suất khí quyển. Nếu ta đặt áp kế này trong điều kiện chuẩn thì áp suất tại A và B chính là áp suất khí quyển Pο. Vì cột thủy ngân trong ống được cân bằng nên lực nén do áp suất thủy ngân và trọng lực của cột

thủy ngân tại điểm A sẽ cân bằng nhau, tức:

𝑃𝜊 = 𝜌𝐻𝑔𝑔ℎ (14.8)

_Hình 14.5: Áp kế khí thủy ngân_

  * ℎ = _𝑃𝑜_


𝜌𝐻𝑔𝑔

(14.9)

![](images/image7.jpeg)
_Hình 14.6: Áp kế khí chữ U_

Để đo áp suất khí P của khí trong bình ta đổ vào ống chữ U một chất lỏng và để hở trong không khí. Khi đó áp suất tại A và B là bằng nhau và bằng áp suất P của chất khí trong bình. Áp dụng công thức 14.6 ta có được: 𝑃 = 𝑃𝜊 + 𝜌𝑔ℎ

Khi đó:

  * _P_ là áp suất tuyệt đối của chất khí.

  * 𝑃 − 𝑃𝜊 = 𝜌𝑔ℎ: được gọi là áp suất tương đối của chất khí trong bình so với khí quyển.


Thông thường nếu không cần biết giá trị thực của áp suất thì người ta thường đo áp suất tương đối của chất khí đó bằng cách đo độ cao chênh lệch _h_ của chất lỏng. Ví dụ, áp suất khí ta đo được trong lốp xe chính là áp suất tương đối.

## ![](images/image8.png) Động lực học chất lưu

Ở các nội dung trước, ta đã khảo sát chất lưu ở trạng thái tĩnh. Trong đề mục này ta sẽ khảo sát chất lưu ở trạng thái chuyển động. Khi một chất lưu chuyển động thì chuyển động của nó sẽ thuộc một trong hai loại: chuyển động thành dòng (lớp) ( _hình 14.7_ ) hay chuyển động rối ( _hình 14.8_ ).

Trong chuyển động của chất lưu ta sẽ gặp khái niệm độ nhớt. Độ nhớt chính là đại lượng đặc trưng cho mức độ ma sát giữa các lớp chất lưu lên nhau khi chúng chuyển động. Vì

chuyển động thực tế của chất lưu rất phức tạp nên trước tiên chúng ta sẽ khảo sát chuyển động của chất lưu lý tưởng với các điều kiện như sau:


| ![](images/image9.jpeg)Hình 14.7: Chuyển động thành lớp của chất khí khi xe chuyển động
trong hầm | ![](images/image10.jpeg)Hình 14.8: Khói thuốc chuyển động trong sự chảy thành dòng ở phía
dưới và trongsự chảy rối ở phía trên. |
| --- | --- |

 

  1. Trong chất lưu lý tưởng thì ma sát giữa các lớp chất lưu khi chuyển động được bỏ qua.

  2. Chất lưu lý tưởng sẽ chuyển động thành dòng. Ở chế độ chuyển động này, mọi hạt chất lưu qua một điểm sẽ có cùng vận tốc.

  3. Mật độ khối lượng của chất lưu là không thay đổi, hay chất lưu là không chịu nén.

  4. Chất lưu không có chuyển động xoáy.


**Đường dòng** là đường cong sao cho tiếp tuyến với nó tại mỗi điểm trùng với vectơ của phân tử chất lưu tại điểm đó ( _hình 14.9_ ).

![](images/image11.png)

_Hình 14.9: Hình ảnh đường dòng của chất lưu_

Một tập hợp các đường dòng tạo thành một **ống dòng**. Các hạt chất lưu không đi vào hay đi ra một ống dòng.

Lưu lượng thể tích của chất lưu qua một tiết diện là đại lượng đo bằng thể tích chất lưu qua tiết diện đó trong một đơn vị thời gian. Với tiết diện có diện tích A và vuông góc với vận tốc 𝑣→ của chất lưu (giả định vận tốc 𝑣→ của chất lưu là như nhau tại mọi điểm thuộc tiết diện đang xét) thì lưu lượng qua tiết diện này bằng: _Aν_. Đơn vị của lưu lượng thể tích trong hệ SI là 𝑚3.

𝑠

Chất lưu lý tưởng khi chuyển động sẽ tuân theo phương trình liên tục: lưu lượng thể tích chất lưu qua mọi tiết diện vuông góc với ống dòng khác nhau trong cùng một ống dòng của chất lưu đều bằng nhau, tức là:

_A_ 1 _ν_ 1 = _A_ 2 _ν_ 2 = …= _A_ i _ν_ i = const

Với _A_ 1, _A_ 2,…, _A_ i lần lượt là diện tích của mặt cắt 1, 2, …, thứ i trong cùng một ống dòng, còn _ν_ 1, _ν_ 2, …, _ν_ i lần lượt là vận tốc của chất lưu tại mặt cắt 1, 2, …, thứ i trong cùng một ống dòng.

## ![](images/image12.png) Phương trình Bernoulli

![](images/image13.jpeg)Cho chất lưu lý tưởng chuyển động trong một ống dòng như _hình 14.10_.

Áp suất tại mỗi điểm của chất lưu lý tưởng sẽ tuân theo phương trình Bernoulli:

Với:
𝑃 +
1
![](images/image14.png) 𝜌𝜈2
2
\+ 𝜌𝑔𝑦 = 𝑐𝑜𝑛𝑠𝑡𝑎𝑛𝑡

  * P là áp suất chất lưu tại một điểm bất kỳ trong dòng chảy.

  * ρ là mật độ khối lượng của chất lưu

  * y là độ cao của tiết diện đó

  * ν là vận tốc dòng chảy tại tiết điện đó.


## ![](images/image15.png) Các ứng dụng của động lực học chất lưu

Lý thuyết động lực học chất lưu có thể giúp ta giải thích được các hiện tượng liên quan chuyển động của các vật thể trong chất lưu. Đầu tiên ta sẽ khảo sát dòng khí chuyển động qua cánh máy bay có hình ảnh các đường dòng như hình 14.11.

Giả sử dòng khí đang chuyển động theo phương ngang từ phải sang trái với vận tốc 𝑣→1. Khi gặp cánh máy bay, do độ nghiêng của cánh dòng chảy của chất khí bị bẻ cong lõm xuống với vận tốc 𝑣→2. Cánh máy bay đã tác dụng một lực lên dòng khí và theo định luật III Newton, dòng khí này cũng tác dụng ngược lại lên máy bay một lực 𝐹→ cùng độ lớn nhưng ngược chiều. Lực này được phân tích thành 2 thành phần là lực nâng và lực cản. Lực nâng tác dụng vào cánh máy bay sẽ phụ thuộc vào các yếu tố như: tốc độ của máy bay, diện tích của cánh, độ cong của cách máy bay và góc giữa cánh máy bay so với phương ngang. Độ cong của cánh máy bay phải được thiết kế sao nhằm làm cho áp suất khí ở phía trên cánh máy bay nhỏ hơn phía dưới tuân theo định luật Bernoulli. Chính sự chênh lệch áp suất này đã giúp nâng cánh máy bay lên. Khi góc chênh lệch giữa cánh máy bay và phương ngang tăng thì sẽ làm xuất hiện các dòng chảy xoáy làm giảm lực nâng.

![](images/image16.jpeg)

_Hình 14.11: Dòng chảy của khí qua cánh máy bay_

![1422](images/image17.jpeg)Một cách tổng quát, khi một vật thể chuyển động xuyên qua một chất lưu thì nó sẽ bẻ cong các dòng chảy làm sinh ra lực nâng tác dụng lên vật đó. Một vài yếu tố ảnh hưởng lên lực nâng này là: hình dạng của vật, sự định hướng của vật so với dòng chảy, chuyển động xoáy và kết cấu bề mặt của vật thể đó.

### Ví dụ về quả banh golf:

Quả banh được cung cấp một chuyển động quay lùi. Các chỗ trũng trên mặt banh làm tăng ma sát với không khí làm cho lực nâng tăng lên _._ Lực nâng do chuyển động xoáy của bóng tạo ra sẽ làm cho độ tăng tầm xa lớn hơn độ giảm tầm xa gây ra bởi lực ma sát trong chuyển động tịnh tiến của quả bóng.

### ![1423](images/image18.jpeg)Ví dụ về máy phun:

Một dòng khí chạy qua phía trên của một ống hở hai đầu. Đầu còn lại của ống được nhúng vào một chất lỏng. Dòng khí chuyển động làm giảm áp suất phía trên ống. Chất lỏng dâng lên đến dòng khí. Chất lỏng bị phân tán vào trong ống phun dưới dạng các hạt nhỏ.

# Câu hỏi lý thuyết chương 14

  1. Khi một vật được nhúng trong một chất lỏng, tại sao tổng hợp lực tác dụng lên vật theo phương ngang bằng không?

  2. Hai ly uống nước có bề dày mỏng và có diện tích đáy bằng nhau nhưng hình dạng khác nhau, với các mặt cắt ngang rất khác nhau ở mặt trên của hai ly, được đổ đầy với cùng một mực nước. Theo công thức 𝑃 = 𝑃𝜊 + 𝜌𝑔ℎ, áp suất là như nhau ở mặt dưới (hay đáy) của cả hai ly. Theo quan điểm này, tại sao khi người ta cân thì hai ly có trọng lượng khác nhau?

  3. Một con cá nằm yên ở đáy cùng của một xô nước, trong khi xô đang được đặt trên một cái cân. Khi cá bắt đầu bơi xung quanh, kim của cân có thay đổi không? Giải thích.

  4. Việc cấp nước cho một thành phố thường được cung cấp từ các hồ chứa được xây dựng ở nơi đất cao. Nước chảy từ hồ chứa, qua đường ống, và vào nhà của bạn. Tại sao khi bạn bật vòi nước ở tầng trệt của một tòa nhà thì nước chảy nhanh hơn so với khi bật vòi nước trong một căn hộ ở tầng cao hơn?

  5. Một con tàu đậu trong hồ nội địa sẽ nổi cao hơn hay thấp hơn khi con tàu đậu trong đại dương? Tại sao?


# Bài tập chương 14

  1. Một phụ nữ 50,0 kg mang giày cao gót được mời vào nhà trong đó nhà bếp lót bằng sàn vinyl. Đế gót có hình tròn và bán kính 0,500 cm.

1. Nếu người phụ nữ đứng cân bằng trên một gót chân, tính áp lực cô ấy gây ra trên sàn?

2. Chủ nhà có quan tâm không? Giải thích câu trả lời của bạn.


![](images/image19.png)ĐS: a) _P_ .

  2. (a) Máy hút bụi rất mạnh có ống hút với đường kính 2,86 cm. Đầu cuối của ống hút đặt vuông góc trên mặt phẳng của một viên gạch, trọng lượng lớn nhất của viên gạch bằng bao nhiêu để người lau dọn có thể nâng nó lên?


![](images/image20.png)![](images/image21.png)![](images/image22.jpeg)(b) Chuyện gì sẽ xảy ra nếu bạch tuộc sử dụng một con vòi có đường kính 2,86 cm trên mỗi hai vỏ sò để kéo vỏ ra ngoài. Tìm lực lớn nhất bạch tuộc có thể gây ra trên một vỏ sò trong nước muối sâu 32,3 m.
ĐS: a)
_F_
b) _F_

  3. ![](images/image23.png)Piston nhỏ của máy nâng thủy lực có diện tích mặt cắt ngang 3,00 𝑐𝑚2, và piston lớn có diện tích mặt cắt ngang là 200 𝑐𝑚2. Cần phải áp lực nén 𝐹1 bằng bao nhiêu lên piston nhỏ để máy nâng nâng được tải trọng 𝐹𝑔 = 15𝑘𝑁?


ĐS:
_F_ 1 .

  4. ![](images/image24.jpeg)Bể chứa trong hình chứa đầy nước với chiều cao d = 2,00 m. Mặt bên của bể chứa có một cửa sổ hình chữ nhật (chiều cao h=1,00 m và chiều rộng w=2,00 m) với bản lề đặt ở phía trên của cửa sổ.

1. Xác định độ lớn của lực mà nước tác động lên cửa sổ.

2. ![](images/image25.png)![](images/image26.png)![](images/image28.png)![](images/image29.jpeg)Tìm độ lớn của mô-men xoắn của lực mà nước tác động lên cửa sổ đối với bản lề.


ĐS: a)
_F_

  5. Piston 1 trong hình bên có đường kính 0.250 in (1in=2.54cm). Piston 2 có đường kính 1,50 in. Xác định độ lớn của lực F, cần thiết để đỡ được tải trọng 500 lb (1lb=0.453592) khi không có ma sát.


![](images/image20.png)ĐS: _F_

  6. ![](images/image30.jpeg)Blaise Pascal làm một bản sao áp kế của Torricelli nhưng sử dụng rượu vang đỏ Bordeaux, mật độ khối lượng 984 kg/𝑚3 thay thế cho thủy ngân.

1. Chiều cao h của cột rượu đối với áp suất bình thường của khí quyển bằng bao nhiêu?

2. Chân không ở phía trên cột rượu có tốt như khi dùng thủy ngân không?


![](images/image32.png)ĐS: a) _h_ 10.5 _m_ .

  7. Đổ thủy ngân vào ống chữ U. Nhánh trái của ống có diện tích ngang 𝐴1 là 10,0 𝑐𝑚2, nhánh phải có diện tích ngang 𝐴2 là 5,00 𝑐𝑚2. Đổ 100gr nước vào nhánh phải như hình.

1. Xác định chiều dài của cột nước ở nhánh phải của ống chữ U.

2. ![](images/image33.png)![](images/image35.png)Với mật độ thủy ngân là 13,6 g/𝑐𝑚3, chiều dài của cột thủy ngân ở nhánh bên trái sẽ tăng thêm một đoạn h bằng bao nhiêu?


ĐS: a)
_h_
![](images/image36.jpeg)

  8. ![](images/image37.jpeg)Khối kim loại nặng 10,0 kg có kích thước 12,0 cm x 10,0 cmx 10,0 cm được treo vào lực kế và đươc nhúng vào nước. Chiều cao của khối kim loại là 12,0 cm, và mặt trên của khối cách mặt nước 5.00 cm.

1. Tính độ lớn lực tác động lên mặt trên và mặt dưới của khối?

2. Đọc số chỉ lực kế?

3. Chứng minh rằng lực nâng bằng với độ chênh lệch của hai lực trên?


![](images/image38.png)ĐS: a) _Ftop_ b)
![](images/image39.png) _T_

  9. Cần phải có bao nhiêu mét khối hêli để nâng một khí cầu nhẹ có treo một tải trọng 400 kg lên đến độ cao 8 000 m? Lấy khối lượng riêng của He 𝜌𝐻𝑒 = 0,179 kg/𝑚3. Giả sử thể tích khí cầu không đổi và mật độ không khí giảm theo độ cao z theo biểu thức


−𝑧
𝜌𝑘ℎô𝑛𝑔 𝑘ℎí = 𝜌0𝑒 ⁄8000, trong đó z tính bằng mét và 𝜌 = 1,20 kg/𝑚3 là mật độ không
![](images/image42.png)khí ở mực nước biển. ĐS: _V_

  10. Nước chảy qua một ống có đường kính 2.74 cm, đổ đầy một thùng 25 lít trong 1.50 phút.

1. Tốc độ của nước rời khỏi đầu ống là bao nhiêu?

2. ![](images/image43.png)![](images/image44.png)Một vòi phun được gắn vào đầu ống. Nếu đường kính vòi phun bằng 1/3 đường kính của ống, tốc độ của nước rời khỏi vòi phun là bao nhiêu?


ĐS: a)
_v_
b) _v_

  11. ![](images/image45.jpeg)Nước di chuyển qua một đường ống có tiết diện nhỏ dần trong dòng chảy ổn định (lý tưởng). Tại điểm thấp hơn thể hiện trong hình, áp suất là P1 = 1.75x104 Pa và đường kính ống là 6,00 cm. Tại một điểm khác cao hơn một đoạn y = 0,250 m, áp suất là P2 = 1,20x104 Pa và đường kính ống là 3,00 cm.

1. Tìm tốc độ dòng chảy qua các tiêt diện ở hai đầu của đoạn ống trên.

2. ![](images/image47.png)![](images/image48.png)![](images/image49.png)Tìm lưu lượng nước chảy qua ống.


ĐS: a)
_v_ 1
b) 1.80

  12. Một ống hút được sử dụng để lấy nước từ một bể như minh họa trong hình bên. Giả sử dòng chảy ổn định không có ma sát.

1. ![](images/image50.jpeg)Nếu h = 1,00 m, hãy tìm tốc độ dòng chảy ở cuối ống hút.

2. ![](images/image52.png)Tìm giới hạn về chiều cao của đỉnh ống hút (y) ở phía trên đầu của ống hút. Lưu ý: đối với dòng chảy của chất lỏng liên tục, áp suất của nó không được giảm xuống dưới áp suất hơi bão hòa của nó. Giả sử nước ở 20,00C, tại đó áp suất hơi bão hòa là 2,3 kPa.


ĐS: a)
_v_
b) _y_

  13. ![](images/image54.png)![](images/image55.jpeg)Nước bị ép ra khỏi bình chữa cháy nhờ áp suất không khí được nén trong bình như trong hình. Áp suất khí trong bình bằng bao nhiêu để nước bị ép ra khỏi bình có tốc độ 30,0 m/s, khi mực nước trong bình thấp hơn vòi phun 0,500 m?


![](images/image28.png)ĐS: _P_

  14. ![](images/image56.jpeg)Một tia nước phun ra theo chiều ngang từ một lỗ gần đáy bể. Nếu lỗ có đường kính 3,50 mm, chiều cao h của mực nước trong bể là bao nhiêu?


![](images/image33.png)ĐS: _h_

# Public_139

Chuyển động tuần hoàn là một chuyển động lặp đi lặp lại của một vật theo thời gian. Sau một khoảng thời gian nhất định, vật trở về một vị trí cho trước. Một loại chuyển động tuần hoàn đặc biệt xảy ra trong các hệ cơ học được gọi là dao động. Đặc điểm của các hệ thống này là:

  * Hệ có một vị trí cân bằng bền và chuyển động qua lại hai bên vị trí đó.

  * Lực tác dụng lên hệ luôn hướng về vị trí cân bằng (thường gọi là lực hồi phục).


Chúng ta có thể gặp các dao động trong thực tế như: dây đàn ghi ta, mặt trống khi rung động, dao động của cây cầu, của nhà cao tầng.
Nếu trong hệ dao động, lực tác dụng lên vật tỉ lệ thuận với độ dời của vật (so với vị trí cân bằng) thì dao động này được gọi là dao động điều hòa.Đây là loại dao động sẽ được nghiên cứu kỹ trong chương này.Tầm quan trọng của việc nghiên cứu này là ở chỗ: các dao động trong tự nhiên và trong kỹ thuật thường có tính chất rất gần với dao động điều hòa và mọi dao động tuần hoàn có thể được biểu diễn như sự tổng hợp của các dao động điều hòa.
Lý thuyết về dao động là cơ sở quan trọng để nghiên cứu một hiện tượng vật lý khác là hiện tượng sóng.

## ![](images/image1.png) Chuyển động của vật gắn với lò xo

![](images/image2.png)Xét một vật nhỏ có khối lượng _m_ (xem như chất điểm) được gắn với một lò xo có một đầu cố định. Vật _m_ có thể chuyển động không ma sát trên mặt phẳng ngang như Hình
15.1.Khi lò xo không co giãn, vật sẽ ở đứng yên ở vị trí gọi là vị trí cân bằng.Khi truyền cho vật một vận tốc từ vị trí
cân bằng, vật sẽ dao động xung quanh vị trí này.
Chọn trục x dọc theo phương của lò xo, gốc O tại vị trí

_Hình 15.1_

cân bằng. Khi vật ở vị trí có tọa độ _x_ thì lực đàn hồi do lò xo tác dụng lên vật được xác định theo định luật Hooke:
𝐹𝑠 = −𝑘. 𝑥 (15.1)
Lực _Fs_ luôn hướng về vị trí cân bằng và luôn ngược dấu với tọa độ _x. x_ được gọi là độ dời của vật (tính từ vị trí cân bằng, dưới đây gọi là li độ).
Áp dụng định luật Newton thứ hai cho vật, ta tìm được gia tốc của vật như sau:

𝐹𝑥 = 𝑚𝑎𝑥 → −𝑘𝑥 = 𝑚𝑎𝑥

𝑘
𝑎𝑥 = − 𝑚 𝑥 (15.2)
Từ 15.2 ta thấy gia tốc của vật tỉ lệ thuận với độ dời và ngược dấu với độ dời của vật.
Những hệ thống hoạt động theo quy luật này sẽ thực hiện một dao động điều hòa.
Một vật thực hiện dao động điều hòa khi gia tốc của vật tỉ lệ thuận với độ dời và ngược dấu với độ dời của vật.

## ![](images/image4.png) Khảo sát dao động cơ điều hòa

Thay 𝑎𝑥 = 𝑑𝑣/𝑑𝑡 = 𝑑2𝑥/𝑑𝑡2 vào 15.2 ta được phương trình:

𝑑2𝑥 𝑘

Đặt
𝑑𝑡2 = − 𝑚 𝑥 (15.3)
thì phương trình 15.3 trở thành:
𝜔2 = 𝑘

𝑚

(15.4)
Nghiệm của phương trình 15.5 là:
𝑑2𝑥
𝑑𝑡2
= −𝜔2𝑥 (15.5)
𝑥(𝑡) = 𝐴 cos(𝜔𝑡 + 𝜙) (15.6) Trong đó _A_ là biên độ dao động, _ω_ là tần số góc và 𝜙 là pha ban đầu. _A_ , _ω_ và 𝜙 đều là các hằng số. Biên độ _A_ và pha ban đầu 𝜙 được xác định từ các điều kiện ban đầu (độ dời và vận
tốc lúc _t_ = 0).
Đại lượng (𝜔𝑡 + 𝜙) gọi là pha của dao động.
Từ 15.4 ta có biểu thức xác địnhtần số góc dao động:

𝜔 = √𝑘

𝑚

(15.7)

Hai đại lượng quan trọng đặc trưng cho dao động là chu kỳ và tần số dao động. Chu kỳ _T_ của dao động là khoảng thời gian vật hoàn thành một dao động. Dựa vào tính chất tuần hoàn của hàm số _x(t)_ cho bởi phương trình 15.6, ta tìm được:

𝑇 =

2𝜋
𝜔
𝑚
= 2𝜋√
𝑘

(15.8)

Tần số _f_ của dao động là số dao động diễn ra trong một đơn vị thời gian:
1 1
𝑓 = ![](images/image5.png) =
√𝑘

(15.9)

𝑇 2𝜋 𝑚
Từ 15.6 chúng ta suy ra biểu thức của vận tốc và gia tốc như sau:
𝑣(𝑡) = −𝐴𝜔 sin(𝜔𝑡 + 𝜙) (15.10)
𝑎(𝑡) = −𝐴𝜔2 cos(𝜔𝑡 + 𝜙) (15.11)
![](images/image6.jpeg)Các phương trình 15.6, 15,10 và 15.11 cho thấy: li độ _x_ và vận tốc _v_ lệch pha một góc π/2 còn li độ _x_ và gia tốc _a_ lệch pha một góc bằng π. Ngoài ra các giá trị cực đại của vận tốc và gia tốc được suy ra từ các phương trình 15.10 và
15.11 là

𝑣𝑚𝑎𝑥

= 𝜔𝐴 = √𝑘

𝑚

𝐴 (15.12)

𝑎𝑚𝑎𝑥

= 𝜔2𝐴 = 𝑘 𝐴 (15.13)
𝑚
_**Câu hỏi 15.1:**_ Một vật gắn với lò xo được kéo đến vị trí _x = A_ và được thả ra từ trạng thái nghỉ. Trong một dao động hoàn chỉnh, chiều dài quãng đường vật đi được bằng:
(a) _A/_ 2 (b) _A_ (c) 2 _A_ (d) 4 _A_
_Hình 15.2 Đồ thị biểu diễn sự phụ thuộc theo thời gian của: a.Li độ_
_b. Vận tốc c. Gia tốc_
_**Câu hỏi 15.2:**_ Một hạt dao động điều hòa có đồ thị li độ theo thời gian được cho như hình vẽ. Khi hạt ở điểm A trên đồ thị, Chúng ta có thể nói gì về li độ và vận tốc của hạt ?

  1. Li độ và vận tốc của hạt đều dương.

  2. Li độ của hạt âm, vận tốc của hạt bằng không.

  3. Li độ và vận tốc của hạt đều âm.

  4. Li độ của hạt âm, vận tốc của hạt dương.


![](images/image7.png)
_Hình vẽ cho câu hỏi 15.2_
_**Câu hỏi 15.3:**_ Hình bên là đồ thị của li độtheo thời gian của hai hạt A và B dao động điều hòa. Dao động điều hòa của B

  1. có tần số góc lớn hơn và biên độ lớn hơn của A.

  2. có tần số góc lớn hơn và biên độ nhỏ hơn của A.

  3. có tần số góc nhỏ hơn và biên độ lớn hơn của A.

  4. có tần số góc nhỏ hơn và biên độ nhỏ hơn của A.


_**Câu hỏi 15.4:**_ Một vật khối lượng _m_ treo vào một lò xo rồi cho dao động. Chu kỳ của dao động này là _T_. Thay vật _m_ bằng vật có khối lượng 2 _m_. Cho vật 2 _m_ dao động thì chu kỳ của dao động bằng:
(a) 2 _T_ (b) √2𝑇 (c) _T_ (d) 𝑇/√2e. _T/_ 2

![](images/image8.png)

_Hình vẽ cho câu hỏi 15.3_

## ![](images/image9.png) Năng lượng của vật dao động điều hòa

Trong nội dung này chúng ta sẽ xem xét cơ năng của hệ dao động. Vì bỏ qua tác dụng của lực ma sát nên cơ năng của hệ được bảo toàn. Chúng ta sẽ sử dụng hệ dao động con lắc lò xo để thực hiện việc khảo sát này.
Động năng của hệ dao động chỉ là động năng của vật và bằng:
1
𝐾 =
2
𝑚𝑣2 = 1

2

𝑚𝜔2𝐴2 sin2(𝜔𝑡 + 𝜙) (15.14)
Thế năng đàn hồi dự trữ ở lò xo và bằng (Lưu ý rằng 𝑘 = 𝑚𝜔2):
1
𝑈 =
2
𝑘𝑥2 = 1

2

𝑚𝜔2𝐴2 cos2(𝜔𝑡 + 𝜙) (15.15)
Cơ năng của hệ dao động điều hòa bằng:
1
𝐸 = 𝐾 + 𝑈 =
2
𝑚𝜔2𝐴2[sin2(𝜔𝑡 + 𝜙) + cos2(𝜔𝑡 + 𝜙)]
1
𝐸 =
2
𝑚𝜔2𝐴2 = 1

2

𝑘𝐴2 (15.16)
Kết quả thu được cho chúng ta thấy cơ năng của hệ dao động điều hòa là một hằng số và tỉ lệ thuận với bình phương biên độ dao động. Đồ thị ở hình 15.3 minh họa sự bảo toàn năng lượng của hệ.

![](images/image10.png)K + U = hằng số

_Hình 15.3: a. Đồ thị biểu diễn biểu diễn sự phụ thuộc của động năng và thế năng_
_theo thời gian với_ 𝜙 = 0 _._
_b. Đồ thị biểu diễn biểu diễn sự phụ thuộc của động năng và thế năng_
_theo li độ._
Ngoài ra, từ kết quả thu được cho năng lượng, ta có thể suy ra vận tốc của vật:
1
𝐸 = 𝐾 + 𝑈 =
2
𝑚𝑣2 \+ 1

2

𝑘𝑥2 = 1

2

𝑘𝐴2
𝑘
𝑣 = ± √
𝑚
(𝐴2 − 𝑥2) = ± 𝜔√(𝐴2 − 𝑥2) (15.17)

## ![](images/image12.png) Liên hệ giữa dao động điều hòa và chuyển động tròn đều

![](images/image13.png)Trong thực tế cuộc sống, có nhiều thiết bị thể hiện mối liên hệ giữa dao độngđiều hòa và chuyển động tròn đều. Ví dụ, bộ phận truyền động của máy may cơ như hình 15.4 dưới đây. Khi chân của thợ may đạp tới lui vào bàn đạp tạo ra những dao động lên xuống chogờ bàn đạp và kéo theo chuyển động tròn của bánh xe truyền động. Chuyển động tròn này được truyền vào máy may nhờ sợi dây truyền động và dẫn đến kết quả là kim khâu dao động thẳng đứng. Trong phần này chúng ta sẽ tìm hiểu
mối quan hệ giữa hai loại chuyển động này.
Hình 15.5 là một bố trí thực nghiệm để chỉ ra
mối liên hệ giữa chuyển động tròn đều và dao động cơ điều hòa. Một quả cầu nhỏ(được xem như một chất điểm) gắn vào vành của đĩa tròn bán kính _A_ để chuyển động cùng với đĩa khi đĩa quay. Cho đĩa tròn quay đều. Chiếu đèn vào quả cầu, ta sẽ thấy cái bóng của quả cầuthực hiện một dao động trên màn.
Cụ thể hơn, hãy quan sát hình 15.6 trong đó chất điểm chuyển động tròn đềuvới tốc độ góc _ω_ trên đường tròn tâm O bán kính _A_.Ở thời điểm _t_ = 0 chất điểm ở vị trí P trên đường tròn có bán kính OP tạo với trục _x_ một góc 𝜙 (Hình 15.6a). Ởthời điểm _t_ , vị trí P của chất điểm trên đường tròn có bán kính OP tạo với trục x một góc𝜃 = (𝜔𝑡 + 𝜙) (Hình 15.6b). Gọi Q là hình chiếu của P lên trục _x_ , thì tọa độ của Q được xác định như sau:
𝑥(𝑡) = 𝐴cos(𝜔𝑡 + 𝜙) (15.18)
_Hình 15.4_

![](images/image15.png)

_Hình 15.5_

_Hình 15.6_

Kết quả này chứng tỏ chứng tỏ Q dao động điều hòa trên trục _x_ quanh vị trí cân bằng O với biên độ là _A(A_ là bán kính quỹ đạo tròn của P). Chúng ta cũng thấy rằng tốc độ góc _ω_ của
P bằng với tần số góc của Q, chu kỳ chuyển động tròn của P bằng với chu kỳ dao động của
Q và pha ban đầu 𝜙 của Q bằng góc mà OP hợp với trục x ở thời điểm _t_ = 0.
\+ 𝜙) tương ứng bằng với vận tốc và gia tốc trong

# Public_140

Thế giới chúng ta sống tràn ngập các loại sóng. Sóng nước là ví dụ thực tế cho ta hình dung khá rõ về sóng. Bằng cách ném một viên sỏi vào mặt nước phẳng lặng,tại điểm tiếp xúc của viên sỏi và mặt nước các sóng hình tròn được tạo ra và bắt đầu mở rộng dần từ điểm tiếp xúc (viên sỏi gọi là nguồn phát sóng). Nếu quan sát kỹ một vật nhỏ
nổi trên mặt nước ở gần nguồn sóng, ta sẽ thấy vật này di chuyển theo phương thẳng đứng và phương ngang quanh một vị trí gốc nhưng thực sự không di chuyển về phía nguồn phát sóng hoặc ra xa nguồn phát sóng. Chuyển động của vật nổi trên thực ra là do chuyển động của các phần tử nước tiếp xúc với vật truyền cho vật. Mọi phần tử nước khác trên mặt nước cũng chuyển động như vậy. Điều này có nghĩa là sóng nước thì cứ chuyển động ra xa nguồn nhưng nước thì không được vận chuyển theo. Trong hiện tượng sóng, dao động của các phần tử được lan truyền, nghĩa là năng lượng cũng đã được lan truyền từ nguồn sóng.
Chúng ta sẽ khảo sát hai loại sóng: sóng cơ học và sóng điện từ. Đối với sóng cơ học, để sóng hình thành và lan truyền được cần thiết phải có môi trường vật chất. Sóng điện từ có thể lan truyền trong môi trường vật chất và cả trong chân không.
Trong chương này, chúng ta sẽ tìm hiểu rõ hơn về sóng cơ học.

## ![](images/image2.png) Sự lan truyền nhiễu loạn

  1. **Sự hình thành sóng**


Tất cả các sóng cơ học đều đòi hỏi phải có nguồn nhiễu loạn, môi trường vật chất để có thể truyền nhiễu loạn và một số cơ chế vật lý nhờ đó các phần tử môi trường tương tác lẫn nhau.
Để minh họa cho chuyển động sóng, chúng ta hãy xét thí nghiệm trình bày ở hình 16.1. Sau khikéo căng một sợi dây dài đã cố định một đầu, bằng cách giật nhanh tay lên và xuống đầu tự do của sợi dây ta sẽ thấy trên dây hình thành một cái bướu và nó dịch chuyển dọc trên dây. Bướu này gọi là _**xung**_. Trong thí nghiệm này, bàn tay là nguồn nhiễu loạn và sợi dây là môi trường để xung truyền đi. Các phần tử riêng biệt trên dây bị nhiễu loạn từ vị trí cân bằng của chúng và sự liên kết giữa các phần tử của dây làm cho nhiễu loạn được lan truyền dọc theo dây. Xung có chiều cao xác định và truyền dọc theo dây với tốc độ xác định. Hình dáng của xung thay đổi rất ít khi xung lan truyền dọc theo dây.
Bằng cách liên tục di chuyển lên và xuống đầu tự do của dây, chúng ta sẽ tạo ra được một sóng lan truyền trên dây. Sóng là một nhiễu loạn tuần hoàn di chuyển qua một môi trường.

  2. **Phân loại sóng**


![](images/image3.png)

_Hình 16.1: Mỗi lần bàn tay di chuyển một đầu dây lên và xuống sẽ tạo ra một xung truyền dọc theo dây_
Tùy thuộc vào phương dao động của các phần tử môi trường, sóng được chia thành hai loại: sóng ngang và sóng dọc.
_**Sóng ngang:**_ Khi lan truyền, sóng loại này sẽ làm cho các phần tử của môi trường chuyển động vuông góc với phương truyền sóng.Hình 16.2 mô tả một sóng ngang lan truyền trên sợi dây. Chuyển động của phần tử tại P được biểu diễn bằng mũi tên thẳng đứng. Hướng truyền của sóng được biểu diễn bằng mũi tên nằm ngang.
_**Sóng dọc:**_ Khi sóng này truyền qua, cho các phần tử của môi trường chuyển động song song với phương truyền sóng. Hình 16.3 là một ví dụ về sóng dọc khi tay liên tục di chuyển qua tới và lui. Một trường hợp khác cho sóng dọc là sóng âm.
![](images/image5.png)
_Hình 16.2_
![](images/image6.png)
_Hình 16.3: Một xung lan truyền dọc theo một lò xo_
Một số sóng thể hiện sự kết hợp đặc tính chuyển dời của cả sóng dọc và sóng ngang. Sóng trên mặt nước là một ví dụ. Khi sóng truyền trên mặt nước, các phần tử nước trên bề mặt di chuyển gần như thành vòng tròn. Nhiễu loạn có cả thành phần dọc và thành phần ngang.

  3. **Hàm sóng**


![](images/image8.png)

_Hình 16.4: Sóng nước_
Khảo sát một xung lan truyền về bên phải với vận tốc _v_ trên một sợi dây dài như trên hình
16.5. Hình 16.5a trình bày hình dạng và vị trí của xung tại thời điểm _t_ = 0 và xung này được mô tả bằng hàm số 𝑦(𝑥, 0) = 𝑓(𝑥). Hàm số này cho biết tọa độ y (độ dời) của phần tử có tọa độ _x_ trên dây vào thời điểm _t_ = 0. Sau khoảng thời gian _t_ , xung đi được quãng đường _vt_ (Hình 16.5b). Chúng ta giả sử rằng hình dạng của xung là không thay đổi theo thời gian. Trong trường hợp này,tọa độ _y_ của phần tử có tọa độ _x_ trên dây ở thời điểm _t_ bằngtọa độ _y_ của phần tử có tọa độ ( _x_ – _vt_ )trên dây ở thời điểm t = 0:
𝑦(𝑥, 𝑡) = 𝑦(𝑥 − 𝑣𝑡, 0)
![](images/image10.png)Tóm lại: Khi xung di chuyển về bên phải (theo chiều dương trục Ox),tọa độ _y_ của phần tử có tọa độ _x_ trên dây ở thời điểm _t_ được xác định bởi hàm số:
𝑦(𝑥, 𝑡) = 𝑓(𝑥 − 𝑣𝑡) (16.1)
Tương tự: Khi xung di chuyển về bên trái, tọa độ _y_ của phần tử có tọa độ _x_ trên dây ở thời điểm _t_ được xác định bởi hàm số:
𝑦(𝑥, 𝑡) = 𝑓(𝑥 + 𝑣𝑡) (16.2) Hàm _y(x,t)_ được gọi là _**hàm sóng**_. Hàm số này cho biết tọa độ _y_ của phần tử bất kỳ tại vị trí _x_ vào thời điểm

_t_. Khi cố định _t_ , hàm sóng _y(x)_ cho biết hình dạng của

sóng ở thời điểm _t_ đó.

## ![](images/image12.png) Sóng hình sin

Chúng ta sẽ xem xét một loại sóng có hình dạng như đồ thị của hàm sin, sóng loại này được gọi là sóng hình sin. Hình 16.6 mô tả một sóng hình sin đang di chuyển về phía bên phải với vận tốc _v_. Sóng này có thể được tạo ra trên một sợi dây như trong hình 16.1 khi đầu tự do của dây được rung để di chuyển lên xuống như một dao động điều hòa. Chúng ta chọn sóng hình sin để khảo sát vì mọi dạng sóng đều có thể xây dựng được bằng cách cộng các sóng hình sin có tần số và biên độ xác định. Sự hiểu biết về sóng hình sin là cơ sở để hiểu được các sóng có bất kỳ dạng nào.
Cần phân biệt hai loại chuyển động xảy ra khi một sóng lan truyền: chuyển động của sóng về phía bên phải theo trục Ox và dao động điều hòa của các phần tử môi trường theo trục Oy.
Chúng ta sẽ xem xét một loại sóng được đơn giản hóa như sau: sóng có một tần số duy nhất và có chiều dài vô hạn.

  1. **Các khái niệm và các đại lượng đặc trưng của sóng**


![](images/image13.png)

_Hình 16.6: Hình dạng sóng sin_

  * _**Đỉnh sóng**_ là điểm trong không gian mà phần tử môi trường tại đó có vị trí cao nhất. (Hình 16.7a).

  * _**Hõm sóng**_ là điểm trong không gian mà phần tử môi trường tại đó có vị trí thấp nhất.

  * _**Biên độ A của sóng**_ : là biên độ dao động của các phần tử môi trường. (Hình 16.7).

  * _**Tần số f của sóng**_ : là số đỉnh sóng (hoặc là bất kỳ điểm nào trên sóng) đi qua một điểm cho trước trong một đơn vị thời gian. Tần số sóng bằng với tần số dao động điều hòa của các phần tử môi trường.

  * Chu kỳ _**T của sóng**_ : là khoảng thời gian để hai đỉnh sóng liền nhau đi qua một một điểm cho trước trong không gian.Chu kỳ của sóng bằng với chu kỳ dao động điều hòa của các phần tử môi trường. (Hình 16.7b).


Chu kỳ và tần số của sóng liên hệ với nhau theo công thức:
1
T =
𝑓

(16.3)

  * _**Bước sóng λ**_ : là khoảng cách từ đỉnh (hõm) sóng này đến đỉnh (hõm) sóng kế tiếp. Tổng quát hơn, bước sóng là khoảng cách ngắn nhất giữa hai điểm đồng nhất trên sóng. (Phần tử môi trường tại hai điểm này dao động giống hệt nhau.)

  * _**Tốc độ truyền sóng v**_ : mỗi sóng sẽ lan truyền với tốc độ riêng, tốc độ này phụ thuộc vào tính chất của môi trường truyền sóng.


Tốc độ truyền sóng liên hệ với bước sóng và chu kỳ của sóng theo công thức:
𝜆
𝑣 =
𝑇
= 𝜆. 𝑓 (16.4)
![](images/image14.png) ![](images/image15.png)

  2. **Hàm sóng**


_Hình 16.7: (a) Hình ảnh của một sóng hình sin. (b) Vị trí của một phần tử môi trường như một hàm số của thời gian._

Giả sử xét một sóng hình sin ở thời điểm _t_ = 0 có hình dạng như ở hình 16.7a thì hàm sóng ở thời điểm này được cho bởi hàm số 𝑦(𝑥, 0) = 𝐴sin𝑎𝑥. Do tính chất tuần hoàn của hàm số này, ta suy ra được 𝑎 = 2𝜋/𝜆. Nên

𝑦(𝑥, 0) = 𝐴𝑠𝑖𝑛 (

2𝜋

𝜆
𝑥)
Nếu sóng truyền về bên phải (theo chiều dương trục x) thì theo 16.1, hàm sóng ở thời điểm _t_ là

𝑦(𝑥, 𝑡) = 𝐴𝑠𝑖𝑛 [

2𝜋

𝜆
(𝑥 − 𝑣𝑡)] (16.5)
Nếu sóng truyền về phía bên trái thì thay ( _x – vt_ ) thành ( _x + vt_ ) trong 16.5.
trong đó 𝜙là pha ban đầu.

  3. **Sóng hình sin trên dây**


Để tạo một một sóng trên dây, ta gắn một đầu dây vào một cần rung và cho cần rung dao động điều hòa (Hình 16.8). Mỗi phần tử trên dây dao động điều hòa theo phương thẳng đứng _y_ với tần số bằng tần số của cần rung, trong khi đó sóng truyền về bên phải theo chiều dương của trục Ox với tốc độ _v_.
Giả sử chọn _t_ = 0 là lúc hình dạng của dây như ở hình
16.8a thì hàm sóng được viết là:
𝑦 = 𝐴sin(𝑘𝑥 − 𝜔𝑡)
_sóng sin trên sợi dây._
𝑎𝑦,𝑚𝑎𝑥 = 𝜔2𝐴 (16.12)
Cần lưu ý rằng: tốc độ truyền sóng _v_ là hằng số đối với một môi trường đồng nhất, trong khi đó vận tốc của một phần tử trên dây _vy_ là một hàm sin của thời gian.

## ![](images/image16.png) Tốc độ của sóng trên dây

Tốc độ của sóng phụ thuộc vào tính chất vật lý của dây và lực căng dây theo công thức:
𝑇
𝑣 = √
𝜇

(16.13)

với _μ_ là khối lượng trên một đơn vị chiều dài của dây (kg/m) và _T_ là lực căng dây.

## ![](images/image17.png) Sự phản xạ và truyền qua của sóng

Ở nội dung này chúng ta sẽ xem xét một sóng bị ảnh hưởng như thế nào trong quá trình lan truyền khi gặp phải sự thay đổi trong môi trường.

![](images/image18.png)![](images/image19.png)

_Hình 16.9: Sự phản xạ của một xung ở đầu cố định của sợi dây._
_Hình 16.10: Sự phản xạ của một xung ở đầu tự do của sợi dây._
Hình 16.9 mô tả một xung lan truyền trên một sợi dây căng ngang có một đầu buộc vào giá cố định. Khi xung di chuyển đến giá cố định, nghĩa là đến cuối dây, thì môi trường truyền bị thay đổi đột ngột. Kết quả là xung chuyển động dọc trên dây theo chiều ngược lại tạo thành xung phản xạ. Xung phản xạ này bị đảo ngược so với xung ban đầu (xung tới) nhưng không bị thay đổi hình dạng. Sự đảo ngược của xung phản xạ so với xung tới có thể được giải thích nhờ định luật Newton thứ ba.
Trong trường hợp trên đầu cuối của dây được buộc cố định. Ở một trường hợp khác, đầu cuối dây có thể di chuyển tự do theo phương thẳng đứng như hình 16.10. Xung phản xạ lúc này không bị đảo ngược và cũng có cùng hình dạng như xung tới.
Cuối cùng là một trường hợp trung gian của hai trường hợp trên. Khi xung di chuyển đến biên giữa hai môi trường, một phần năng lượng của xung tới sẽ bị phản xạ ngược lại, một phần năng lượng sẽ truyền qua môi trường kia.

![](images/image20.png)

_Hình 16.11: Một xung di chuyển trên một dây Hình 16.12: Một xung di chuyển trên một nhẹ đến chỗ nối với một dây nặng hơn. dây nặng đến chỗ nối với một dây nhẹ hơn._
Chẳng hạn như một sợi dây nhẹ được nối với một sợi dây nặng hơn như trên hình 16.11. Khi xung di chuyển trên dây nhẹ đến gặp điểm tiếp xúc của hai dây thì hai xung được hình thành đồng thời: xung phản xạ trở lại (bị đảo ngược và có biên độ nhỏ hơn xung tới) và xung truyền qua chuyển động trên dây nặng hơn (không bị đảo ngược). Trong trường hợp xung di chuyển trên dây nặng đến gặp điểm tiếp xúc với dây nhẹ hơn như ở hình 16.12 thì các xung phản xạ và xung truyền qua vẫn hình thành nhưng xung phản xạ không bị đảo ngược.

## ![](images/image22.png) Tốc độ truyền năng lượng bởi sóng sin trên dây

![](images/image24.png)Chúng ta hãy xem xét sự truyền sóng hình sin theo trục x trên một sợi dây căng ngang trên như hình 16.13.
Nguồn năng lượng là tác nhân bên ngoài gắn với đầu bên trái của dây. Tác nhân này thực hiện công ở
đầu bên trái của dây (bằng cách di chuyển lên xuống), nhờ đó năng lượng được truyền vào hệ và sau đó được
_Hình 16.13_
truyền dọc theo chiều dài của dây. Xét phần tử nhỏ có tọa độ _x_ , chiều dài _dx_ và khối lượng _dm_. Phần tử này (cũng như các phần tử khác trên dây) thực hiện dao động điều hòa theo phương thẳng đứng _y_ với phương trình
𝑦 = 𝐴sin(𝑘𝑥 − 𝜔𝑡)

# Public_141

Trong cơ học, chúng ta đã xác định khái niệm về khối lượng, lực và động năng để tạo tiền đề cho phương pháp định lượng. Tương tự như vậy, một khái niệm định lượng về các hiện tượng nhiệt đòi hỏi phải định nghĩa đầy đủ về nhiệt độ, nhiệt lượng và nội năng. Chương này bắt đầu với bài viết về nhiệt độ. Tiếp theo, chúng ta xem xét

tầm quan trọng khi nghiên cứu các hiện tượng nhiệt của các chất đặc biệt. Ví dụ: các loại khí giãn nở đáng kể khi nung nóng, trong khi chất lỏng và chất rắn giãn nở ít hơn. Chương này kết thúc với một nghiên cứu về khí lý tưởng ở mức vĩ mô. Ở đây, chúng ta chỉ quan tâm đến các mối quan hệ định lượng giữa áp suất, thể tích và nhiệt độ của một chất khí.

## ![](images/image1.png) Nhiệt độ và nguyên lý thứ không của nhiệt động lực học

### Nhiệt độ

Chúng ta thường kết hợp các khái niệm về nhiệt độ với độ nóng hoặc lạnh một đối tượng khi chúng ta chạm vào nó. Bằng cách này, các giác quan cho ta chỉ số định tính của nhiệt độ. Tuy nhiên, giác quan của chúng ta không đáng tin cậy và thường đánh lừa chúng ta.

Ví dụ, nếu bạn đứng bằng đôi chân trần với một chân trên thảm và một chân trên sàn gạch liền kề, ta cảm thấy gạch lạnh hơn so với thảm mặc dù cả hai đều ở cùng một nhiệt độ, lý do là vì gạch trao đổi năng lượng dưới dạng nhiệt mạnh hơn so với thảm. Làn da của bạn “đo đạc” mức độ trao đổi năng lượng bằng nhiệt chứ không phải là nhiệt độ thực tế.

Những gì chúng ta cần là một phương pháp đáng tin cậy và có thể lặp lại để đo độ nóng hoặc lạnh của đối tượng chứ không phải là tỷ lệ chuyển đổi năng lượng. Các nhà khoa học đã chế tạo và phát triển các nhiệt kế khác nhau để phục vụ các phép đo định lượng như vậy.

![1901](images/image2.jpeg)

_Hình 19.1: Nguyên lý thứ không của nhiệt động lực học, A và B cân bằng nhiệt với nhau_

### Nguyên lý thứ không của nhiệt động lực học

Hai đối tượng có nhiệt độ ban đầu khác nhau cuối cùng đạt được nhiệt độ trung bình khi được đặt tiếp xúc với nhau.

Ví dụ, khi nước nóng và nước lạnh được trộn lẫn trong một bồn tắm, năng lượng được chuyển từ nước nóng đến nước lạnh và nhiệt độ cuối cùng của hỗn hợp là giá trị nào đó giữa nhiệt độ nóng và lạnh ban đầu.

Nguyên lý thứ không nhiệt động học (định luật trạng thái cân bằng) phát biểu như sau:
_**Nếu hai vật lần lượt cân bằng nhiệt với một vật thứ ba nào đó, thì chúng cũng cân bằng nhiệt với nhau.**_
_Cân bằng nhiệt có nghĩa là trạng thái trong đó hai vật tiếp xúc vật lí với nhau có nhiệt độ bằng nhau._

Cái quan trọng nhất mà nguyên lý thứ không thiết lập là nhiệt độ là một tính chất căn bản và có thể đo được của vật chất.

_**Câu hỏi 19.1** :_ Hai đối tượng, với các kích thước, khối lượng và nhiệt độ khác nhau, được đặt tiếp xúc nhiệt. Chiều chuyển đổi năng lượng như thế nào?

  1. Năng lượng đi từ đối tượng lớn đến đối tượng nhỏ hơn.

  2. Năng lượng đi từ vật có khối lượng lớn đến vật có khối lượng nhỏ hơn.

  3. Năng lượng đi từ đối tượng ở nhiệt độ cao hơn đến đối tượng ở nhiệt độ thấp hơn.


## ![](images/image4.png) Nhiệt kế và thang đo độ C (Celcius)

### Nhiệt kế

![1902](images/image5.jpeg)Nhiệt kế là thiết bị được sử dụng để đo nhiệt độ của một hệ, dựa trên nguyên lý: một số tính chất vật lý của một hệ thống thay đổi khi nhiệt độ của hệ thay đổi.

Một số tính chất vật lý thay đổi theo nhiệt độ là

  * thể tích của chất lỏng,

  * các kích thước của chất rắn,

  * áp suất của chất khí ở thể tích không đổi,

  * thể tích của chất khí ở áp suất không đổi,

  * điện trở của dây dẫn

  * màu sắc của vật.


Nhiệt kế thông dụng có chứa một lượng chất lỏng, thường là thủy ngân hoặc rượu, có thể giãn nở trong một ống mao dẫn thủy tinh khi

_Hình 19.2: Nhiệt kế thủy ngân trước và sau khi tăng nhiệt độ của nó._

bị nung nóng (Hình 19.2). Trong trường hợp này, đặc tính thay đổi là thể tích của chất lỏng.

Một sự thay đổi nhiệt độ bất kỳ trong nhiệt kế được định nghĩa là tỷ lệ thuận với sự thay đổi độ cao của cột chất lỏng. Có thể hiệu chỉnh nhiệt kế bằng cách đặt nó tiếp xúc nhiệt với một hệ tự nhiên được duy trì ở nhiệt độ không đổi.

### Thang nhiệt độ Celsius (độ C)

Thang nhiệt độ Celsius xác định nhiệt độ của vật theo độ C (viết tắt 0C), do nhà thiên văn học Anders Celsius đưa ra vào năm 1742.

Thang nhiệt độ Celsius lấy nhiệt độ của nước khi đóng băng (00C) và nhiệt độ sôi của nước (1000C) làm chuẩn, trong điều kiện áp suất tiêu chuẩn. Sau đó chia nhỏ thành 100 vạch chia, mỗi vạch chia tương ứng với 1 độ.

## ![](images/image6.png) Nhiệt kế khí đẳng tích và thang nhiệt độ tuyệt đối

### Nhiệt kế khí đẳng tích

![](images/image7.jpeg)Tính chất vật lý được khai thác trong thiết bị này là sự thay đổi của áp suất theo nhiệt độ ứng với thể tích không đổi.

Bình P được ngâm trong nước đá và cột B chứa thủy ngân. Thể tích của khí trong bình cầu P được giữ không đổi, cột thủy ngân B có thể nâng lên hay hạ xuống để mức thủy ngân trong cột A ở điểm "0" trên thang đo. Độ chênh lệch cột thủy ngân là h. Từ đó, ta tính được áp suất của khí ở 0 0C bằng phương trình 𝑃 = 𝑃0 \+ 𝜌𝑔ℎ.

Kế tiếp cho bình P ngâm trong nước sôi. Cột thủy ngân B cũng được điều chỉnh sao cho mức thủy ngân ở cột A ở điểm "0" trên thang đo. Tiếp tục đo độ chênh lệch cột thủy ngân và từ đó, ta tính được áp suất của khí ở 100 0C.

![](images/image8.png)Nhiệt kế khí đẳng tích dễ dàng cho ra kết quả áp suất trên một dải nhiệt độ. Nó khá chính
xác - miễn là chúng ta tránh gần
với nhiệt độ ngưng tụ của khí. Thật thú vị khi ngoại suy biểu đồ này để xem ở nhiệt độ nào, áp suất bằng 0.

### Độ không tuyệt đối

_Hình 19.3: Nhiệt kế khí đẳng tích_
_Hình 19.4: Đồ thị biểu diễn mối quan hệ của áp suất theo nhiệt độ của nhiệt kế_
_khí đẳng tích_

Nếu ta sử dụng nhiệt kế khí đẳng tích với các loại khí khác nhau, thực nghiệm cho thấy giá trị đọc được từ nhiệt kế không phụ thuộc vào loại khí được sử dụng. Nếu kéo dài đồ thị cho các loại khí khác nhau, áp suất luôn bằng không khi nhiệt độ là –273,15oC. Nhiệt độ này được gọi là số không tuyệt đối – không độ tuyệt đối.

Không độ tuyệt đối được sử dụng như là cơ sở của các thang nhiệt độ tuyệt đối. Kích thước thang chia độ của thang nhiệt độ tuyệt đối giống kích thước của thang chia độ trên thang nhiệt giai Celsius.

T 0C = T – 273,15

![](images/image9.png)

_Hình 19.5: Đồ thị từ thực nghiệm biểu diễn áp suất theo nhiệt độ_

### Thang nhiệt độ tuyệt đối (thang nhiệt độ Kelvin)

Thang nhiệt độ tuyệt đối được thông qua vào năm 1954 bởi Ủy ban quốc tế về Khối lượng và Đo lường, nó dựa trên hai điểm cố định mới:

  * Một điểm là điểm 0 tuyệt đối, là _[trạng thái](https://vi.wikipedia.org/w/index.php?title=Tr%E1%BA%A1ng_th%C3%A1i&action=edit&redlink=1) [nhiệt động học](https://vi.wikipedia.org/wiki/Nhi%E1%BB%87t_%C4%91%E1%BB%99ng_l%E1%BB%B1c_h%E1%BB%8Dc)_ lý tưởng của [_vật chất_](https://vi.wikipedia.org/wiki/V%E1%BA%ADt_ch%E1%BA%A5t), trong đó mọi _[chuyển động nhiệt](https://vi.wikipedia.org/w/index.php?title=Chuy%E1%BB%83n_%C4%91%E1%BB%99ng_nhi%E1%BB%87t&action=edit&redlink=1)_ đều ngừng.

  * Điểm thứ hai là điểm ba của nước. Điểm ba của nước nghĩa là ứng với cùng một giá trị _[nhiệt độ](https://vi.wikipedia.org/wiki/Nhi%E1%BB%87t_%C4%91%E1%BB%99)_ và _[áp suất](https://vi.wikipedia.org/wiki/%C3%81p_su%E1%BA%A5t)_ của nước, ba _[pha](https://vi.wikipedia.org/wiki/Pha_v%E1%BA%ADt_ch%E1%BA%A5t)_ của nước ( _[khí](https://vi.wikipedia.org/wiki/Ch%E1%BA%A5t_kh%C3%AD), [lỏng](https://vi.wikipedia.org/wiki/Ch%E1%BA%A5t_l%E1%BB%8Fng), [rắn](https://vi.wikipedia.org/wiki/Ch%E1%BA%A5t_r%E1%BA%AFn)_) có thể cùng tồn tại trong [_cân bằng nhiệt động lực học_](https://vi.wikipedia.org/w/index.php?title=C%C3%A2n_b%E1%BA%B1ng_nhi%E1%BB%87t_%C4%91%E1%BB%99ng_l%E1%BB%B1c_h%E1%BB%8Dc&action=edit&redlink=1). Điểm ba của nước xảy ra ở 0,01oC và 4,58 mm thủy ngân. Nhiệt độ này được đặt bằng giá trị 273,16 trên thang nhiệt độ tuyệt đối.


Cách làm này làm cho thang độ không tuyệt đối cũ phù hợp với các thang nhiệt độ mới. Đơn vị đo nhiệt độ trong hệ đơn vị SI là Kelvin.
Thang nhiệt độ tuyệt đối cũng được gọi là thang nhiệt độ Kelvin.
Nhiệt độ điểm ba là 273,16 K. Khi dùng kelvin thì không sử dụng ký hiệu độ.

Kelvin được định nghĩa là 1/273,16 của độ chênh lệch giữa không độ tuyệt đối và nhiệt độ của điểm ba của nước.

### Vài ví dụ về nhiệt độ tuyệt đối

Các con số ở hình 19.6 cho biết giá trị nhiệt độ tuyệt đối của các quá trình vật lý khác nhau. Thang đo là thang logarit.

Thực tế, không thể đạt nhiệt độ không tuyệt đối.

Các thí nghiệm đã đến được gần nhiệt độ này.

### Thang nhiệt độ Fahrenheit (độ F)

Đây là một thang đo thông dụng được sử dụng thường ngày ở Mỹ, đặt tên theo Daniel Fahrenheit. Nhiệt độ đóng băng của nước là 32oF, và nhiệt độ hóa hơi của nước là 212oF. Có 180 khoảng chia (độ) giữa hai điểm tham chiếu.

### Mối quan hệ giữa các thang đo

Mối quan hệ giữa độ Celsius và Kelvin
𝑇𝐶 = 𝑇 − 273,15
Mối quan hệ giữa độ Celsius và độ F

9

𝑇𝐹 = 5 𝑇𝐶 + 32
Nhiệt độ đóng băng của nước
0oC = 273,15 K = 32o F
Nhiệt độ hóa hơi của nước
100oC = 373,15 K = 212o F

![](images/image10.png)

_Hình 19.6: Nhiệt độ tuyệt đối của các quá trình vật lý khác nhau_

_**Câu hỏi 19.2:**_ Hãy xem xét các cặp vật liệu sau đây. Cặp nào có hai vật liệu, vật liệu này nóng gấp đôi vật liệu kia? (a) nước sôi ở 100 0C, một ly nước ở 50 0C (b) nước sôi ở 100 0C, mêtan đông lạnh tại – 50 0C (c) một khối băng ở -20 0C, ngọn lửa 233 0C (d) không có cặp nào trong số đó

### Bài tập mẫu19.1:

Nhiệt độ 50 0F đổi ra nhiệt độ Celcius và Kelvin bằng bao nhiêu? (Đáp số 10 0C và 283 K)

## ![](images/image11.png) Sự giãn nở nhiệt của chất rắn và chất lỏng

### Giãn nở nhiệt

Giãn nở nhiệt là sự gia tăng kích thước của một vật khi nhiệt độ của nó tăng lên. Giãn nở nhiệt là hệ quả của sự thay đổi khoảng cách tương đối giữa các nguyên tử trong một vật. Nếu sự giãn nở tương đối nhỏ so với kích thước ban đầu của vật, sự thay đổi theo chiều bất kỳ,

![](images/image12.jpeg)
_Hình 19.7: Ví dụ về giãn nở nhiệt_

lấy xấp xỉ, là tỷ lệ thuận với lũy thừa bậc nhất của sự thay đổi về nhiệt độ. Các ví dụ về giãn nở nhiệt được minh họa trong hình 19.7.

### Giãn nở dài

Giả sử một đối tượng có chiều dài ban đầu 𝐿𝑖. Nhiệt độ thay đổi một lượng ∆𝑇 = 𝑇𝑓 − 𝑇𝑖 , chiều dài thay đổi một lượng

∆𝐿 = 𝐿𝑓 − 𝐿𝑖. Ta định nghĩa hệ số giãn nở dài là:

![C:\Users\ACER\Desktop\Untitled.png](images/image13.jpeg)∆𝐿⁄

Khi vòng bị đốt nóng, kích thước theo các chiều đều tăng lên. Khoảng trống trong vòng đệm và vòng đệm giãn nở như nhau

Hay:

𝛼 =
𝐿𝑖
∆𝑇
∆𝐿 = 𝛼𝐿𝑖∆𝑇

Hệ số giãn nở dài, _α_ , có đơn vị là (oC)-1

Một số vật liệu giãn nở dọc theo một chiều, nhưng co lại theo các chiều khác khi nhiệt độ tăng. Do các kích thước dài thay đổi, diện tích bề mặt và thể tích cũng thay đổi theo sự thay đổi về nhiệt độ. Một lỗ hở trong một mẩu vật liệu cũng giãn nở giống như phần rỗng đã được lấp đầy bởi vật liệu ấy. Khái niệm về sự nở vì nhiệt có thể được xem là tương tự với sự phóng ảnh.

### Giãn nở khối

Sự giãn nở khối tỷ lệ thuận với khối lượng ban đầu và sự thay đổi về nhiệt độ.

∆𝑉 = 𝛽𝑉𝑖∆𝑇

  * _β_ là hệ số giãn nở khối.


_Hình 19.8: Sự giãn nở vì nhiệt của một cái vòng._

  * Đối với một vật rắn, _β_ = 3 _α_ (Giả định vật liệu là đẳng hướng, giống nhau ở tất cả các hướng).

  * Đối với một chất lỏng hoặc khí, _β_ được cho trong bảng.


_Bảng 19.1: Hệ số giãn nở nhiệt của một số vật liệu_

![](images/image14.jpeg)

### ![](images/image15.jpeg)Giãn nở diện tích

Sự thay đổi diện tích tỷ lệ thuận với diện tích ban đầu và sự thay đổi về nhiệt độ:

∆𝐴 = 2𝛼𝐴𝑖∆𝑇

### Dải lưỡng kim (băng kép)

Một thiết bị cơ đơn giản được gọi là dải lưỡng kim, được tìm thấy trong các thiết bị thực tế như máy điều nhiệt cơ học, sử dụng sự khác biệt về hệ số giãn nở khác nhau của các nguyên vật liệu. Nó bao gồm hai dải kim loại mỏng làm bằng các vật liệu khác nhau, nối với nhau. Khi nhiệt độ của dải tăng lên, hai kim loại mở rộng bằng các lượng khác nhau và uốn cong như trong hình 19.9.

_Hình 19.9: a) Dải lưỡng kim uốn cong khi nhiệt độ thay đổi do hai kim loại có hệ số giãn nở nhiệt khác nhau và b) Một dải lưỡng kim được sử dụng trong bộ điều nhiệt để ngắt hoặc làm tiếp xúc điện._

### Sự giãn nở nhiệt của nước

  * Khi tăng nhiệt độ từ 0oC đến 4oC, nước co lại. Mật độ của nó tăng lên.

  * Trên 4oC, nước giãn nở khi nhiệt độ tăng. Mật độ của nó giảm.

  * Mật độ nước tối đa (1 000 g / cm3) xảy ra ở 4oC


![](images/image16.jpeg)

_Hình 19.10: Mật độ nước thay đổi theo nhiệt độ ở áp suất khí quyển._

_**Câu hỏi 19.3** :_ Nếu bạn được yêu cầu làm một nhiệt kế thủy tinh rất nhạy,bạn sẽ chọn loại chất lỏng nào sau đây? (a) thủy ngân (b) rượu (c) xăng (d) glycerin

_**Câu hỏi 19.4** :_ Hai khối cầu được làm bằng cùng một kim loại và có cùng bán kính, nhưng một cái rỗng và một cái đăc. Khi nhiệt độ tăng, quả cầu nào mở rộng hơn? (a) Quả cầu đặc

(b) Quả cầu rỗng (c) Hai quả cầu mở rộng như nhau (d) Không có đủ thông tin.

### Bài tập mẫu 19.2:

Một đoạn đường ray làm bằng thép có chiều dài 30 m khi nhiệt độ là 0 0C. Độ dài của nó bằng bao nhiêu khi nhiệt độ là 40 0C?
(Đáp số: 30,013m)

## ![](images/image17.png) Mô tả vĩ mô về khí lý tưởng

### Khí lý tưởng

Khí lý tưởng là một loại _[chất khí](https://vi.wikipedia.org/wiki/Ch%E1%BA%A5t_kh%C3%AD)_ tưởng tượng chứa các hạt giống nhau có kích thước vô cùng nhỏ so với _[thể tích](https://vi.wikipedia.org/wiki/Th%E1%BB%83_t%C3%ADch)_ của khối khí và không tương tác với nhau, chúng chỉ _[va chạm đàn](https://vi.wikipedia.org/w/index.php?title=Va_ch%E1%BA%A1m_%C4%91%C3%A0n_h%E1%BB%93i&action=edit&redlink=1) [hồi](https://vi.wikipedia.org/w/index.php?title=Va_ch%E1%BA%A1m_%C4%91%C3%A0n_h%E1%BB%93i&action=edit&redlink=1)_ với tường bao quanh khối khí.

Đối với chất khí, thể tích phụ thuộc vào kích thước của bình chứa.

### Phương trình trạng thái của chất khí:

### 

Rất hữu ích để biết mối liên hệ giữa khối lượng, áp suất và nhiệt độ của khí có khối lượng
_m_.
Phương trình mô tả sự liên hệ giữa các đại lượng này được gọi là _phương trình trạng thái_. Một cách tổng quát, phương trình trạng thái là khá phức tạp. Tuy nhiên, nếu khí được

duy trì ở áp suất thấp, thì phương trình trạng thái trở nên đơn giản hơn nhiều. Các phương trình trạng thái có thể được xác định từ kết quả thí nghiệm.

Khí có mật độ thấp thường được xem là _khí lý tưởng_. Và ta có thể dùng mô hình khí lý tưởng để đưa ra các dự đoán phù hợp để mô tả hành vi của các khí thực ở áp suất thấp.

### Mô hình khí lý tưởng

Các mô hình khí lý tưởng có thể được sử dụng để đưa ra dự đoán về các cách biến dổi của chất khí.

Nếu chất khí ở áp suất thấp, mô hình này mô tả đầy đủ các biến đổi của các khí thực sự.

### Mol

Lượng khí trong một thể tích nhất định được biểu diễn bởi số mol, _n_.

Một mol của một chất là lượng chất đó có chứa NA hạt cấu thành của chất đó. Với NA là số Avogadro: NA = 6 022 x 1023. Các hạt cấu thành có thể là các nguyên tử hay phân tử.

Số mol có thể được xác định từ khối lượng của các chất:
𝑚
𝑛 =
𝑀

M là khối lượng mol của chất, có thể thu được từ bảng tuần hoàn, là khối lượng nguyên tử thể hiện trong gam/mol, _m_ là khối lượng của mẫu, _n_ là số mol.

Ví dụ: Một người có khối lượng 4,00 u nên M = 4,00 g / mol

### Các định luật về khí

  * Khi một chất khí được giữ ở nhiệt độ không đổi, tích giữa áp suất _p_ và thể tích _V_ của nó là một hằng số hay áp suất tỷ lệ nghịch với thể tích của nó (Định luật Boyle).

  * Khi một chất khí được giữ ở áp suất không đổi, tỉ số giữa thể tích _V_ và nhiệt độ _T_ không đổi hay thể tích và nhiệt độ tỉ lệ thuận với nhau (Định luật Charles và Gay- Lussac).

  * Khi khối lượng của khí được giữ không đổi, tỉ số giữa áp suất _p_ và nhiệt độ _T_ không đổi hay áp suất tỷ lệ thuận với nhiệt độ (Định luật Guy-Lussac).


### Phương trình trạng thái của chất khí lý tưởng:

Phương trình trạng thái khí lý tưởng:
𝑃𝑉 = 𝑛𝑅𝑇

_R_ là hằng số, được gọi là hằng số khí lý tưởng.

_R_ = 8,314 J / mol ∙ K = 0,08214 atm .l / mol ∙ K

Từ đây, bạn có thể xác định rằng 1 mol của bất kỳ chất khí ở áp suất khí quyển và ở 0 oC là 22,4 l.

Định luật khí lý tưởng thường được viết theo tổng số của các phân tử, N, hiện diện trong mẫu.

𝑃𝑉 = 𝑛𝑅𝑇 = (𝑁⁄

𝐴

) 𝑅𝑇 = 𝑁𝑘𝐵𝑇

# Public_142

Nhiệt động lực học và cơ học đã được xem là hai ngành riêng biệt của vật lý. Cho đến khoảng năm 1850, các thí nghiệm của James Joule và những người khác đã cho thấy sự liên kết giữa chúng. Mối liên kết đã được tìm thấy giữa việc trao đổi năng lượng bởi nhiệt trong các quá trình nhiệt và sự trao đổi năng lượng bởi công
trong các quá trình cơ học.
Khái niệm về năng lượng đã được khái quát hóa để bao gồm cả nội năng.
Các nguyên lý bảo toàn năng lượng nổi lên như là một quy luật phổ quát của tự nhiên.

## ![](images/image1.png) Nhiệt lượng và nội năng

Trong phần này sẽ thảo luận về nội năng, nguyên lý thứ nhất của nhiệt động lực học, và các ứng dụng của nguyên lý này.

Nguyên lý thứ nhất của nhiệt động lực học mô tả các hệ mà trong đó sự thay đổi năng lượng duy nhất là nội năng. Sự trao đổi năng lượng thực hiện bởi nhiệt và công.

Ta sẽ xem xét công thực hiện bởi các hệ có thể biến dạng.
![](images/image2.jpeg) **Nội năng Eint**

Nội năng là tổng năng lượng của một hệ có được từ các thành phần vi mô của nó.

  * Các thành phần vi mô này là các nguyên tử và phân tử.

  * Hệ được quan sát từ một hệ quy chiếu đứng yên đối gắn với khối tâm của hệ.


### Nhiệt lượng Q

Nhiệt lượng được định nghĩa là năng lượng chuyển đổi qua ranh giới của một hệ do sự khác biệt nhiệt độ giữa hệ và môi trường xung quanh, được viết tắt là nhiệt.

### Đơn vị năng lượng

Trong lịch sử, calo (cal) là đơn vị được sử dụng cho năng lượng.

Một calo là lượng năng lượng trao đổi cần thiết để làm tăng nhiệt độ của 1g nước từ 14.5oC đến 15.5oC.

1 kilocalo = 1000 calo.
Theo hệ thống đo lường của Mỹ, đơn vị là một BTU (British Thermal Unit).

Một BTU là lượng năng lượng trao đổi cần thiết để làm tăng nhiệt độ 1 lb của nước từ 63oF đến 64oF.

Ngoài ra, đơn vị của năng lượng theo hệ SI là Joules (J)
_1 cal = 4,186 J_ (20.1)

## ![](images/image5.png) Nhiệt dung riêng và phép đo nhiệt lượng

### Nhiệt dung C

Nhiệt dung, _C_ , của một vật cụ thể được định nghĩa là lượng năng lượng cần thiết để làm tăng nhiệt độ của vật thêm 1°C.

Nếu năng lượng Q tạo ra sự thay đổi nhiệt độ là ∆T, thì
Q ≡ C ∆T (20.2)

### Nhiệt dung riêng c

Nhiệt dung riêng, c, là nhiệt dung của mỗi khối lượng đơn vị.

Nếu trao đổi một lượng năng lượng Q để làm một vật có khối lượng m và thay đổi nhiệt độ ∆T, thì nhiệt dung riêng là:

_c_ ≡ _Q m_ ∆ _T_

(20.3)

Nhiệt dung riêng của chất càng lớn, năng lượng phải thêm vào một khối lượng đã cho để tạo nên một sự thay đổi nhiệt độ cụ thể càng lớn.

Phương trình thường được viết theo thuật ngữ Q:
_Q = mc∆T_ (20.4)

### Sự thay đổi của nhiệt dung riêng theo nhiệt độ

Về mặt kỹ thuật, nhiệt dung riêng thay đổi theo nhiệt độ. Phương trình vi phân là
T𝐹

Q = m ∫ cdT

Ti

Tuy nhiên, nếu các khoảng biến đổi nhiệt độ không quá lớn, sự thay đổi này có thể bỏ qua và c có thể được coi như một hằng số.

### Nhiệt dung riêng của nước

Nước có nhiệt dung riêng cao nhất so với vật liệu thông thường.

### Phép đo nhiệt lượng

Muốn đo nhiệt dung riêng của một vật, ta nung nóng vật đó đến nhiệt độ Tx, sau đó nhúng nó vào nước (khối lượng đã biết) có nhiệt độ 𝑇𝑤 < 𝑇𝑥 , rồi ghi lại nhiệt độ của nước sau khi

chúng cân bằng nhau. Phép đo này được gọi là phép đo nhiệt lượng. Thiết bị đo gọi là nhiệt lượng kế.

![](images/image6.jpeg)Hình 20.2 mô tả vật nóng trong nước lạnh và nhiệt lượng truyền từ nhiệt độ cao đến nhiệt độ thấp. Nếu hệ vật và nước bị cô lập, sự bảo toàn năng lượng đòi hỏi nhiệt lượng thoát ra khỏi vật Qhot bằng với nhiệt lượng đi vào nước Qcold. Biểu thức bảo toàn năng lượng:

Q _cold =_ −Q _hot_ (20.5)

Xét một mẫu vật ta đang muốn xác định nhiệt độ. Giả sử mx là khối lượng của nó, cx là nhiệt dung riêng và Tx là nhiệt độ ban đầu. Tương tự, ta có các đại lượng mw, cw và Tw đại diện cho các giá trị tương ứng cho nước. Gọi Tf là nhiệt độ cuối cùng sau khi hệ (gồm nước và mẫu vật) đạt trạng thái cân bằng. Phương trình (20.4) cho thấy rằng nhiệt lượng truyền cho nước là 𝑄𝑤 = 𝑚𝑤𝑐𝑤(𝑇𝑓 − 𝑇𝑤)>0 vì 𝑇𝑓 >

𝑇𝑤
Nhiệt lượng truyền cho mẫu vật là 𝑄𝑥 = 𝑚𝑥𝑐𝑥(𝑇𝑓 − 𝑇𝑥 ) <0 Từ phương trình (20.5), ta có phương trình

mwcw(Tf − Tw) = −mxcx(Tf − Tx) = mxcx(Tx − Tf)

  * Phương trình này giúp xác định nhiệt dung riêng chưa biết.

  * Về mặt kỹ thuật, cần xác định khối lượng của bình chứa, nhưng nếu _m_ w >> _m_ bình chứa , nó có thể được bỏ qua.


_Bảng 20.1: Một số giá trị nhiệt dung riêng_

![20T1](images/image8.jpeg)

_**Câu hỏi 20.1**_ : Hãy tưởng tượng bạn có 1 kg sắt, thủy tinh và nước, và tất cả đều ở nhiệt độ 10°C. (a) Sau khi thêm năng lượng 100J vào mỗi vật, sắp xếp các vật theo thứ tự nhiệt độ từ cao đến thấp. (b) sắp xếp các vật theo thứ tự nhiệt lượng nhận được từ nhiều đến ít nếu nhiệt độ các vật được tăng thêm 20°C.

## ![](images/image9.png) Nhiệt chuyển pha

Trong một số trường hợp, mặc dù có sự trao đổi năng lượng giữa khối chất và môi trường nhưng nhiệt độ khối chất không thay đổi. Đó là khi xảy ra sự chuyển pha. Pha là một tập hợp các phần đồng tính, có tính chất như nhau của một hệ thống. Chẳng hạn nước có thể tồn tại ở pha rắn, lỏng hoặc khí. Những hình thức kết tinh khác nhau của một chất cũng là những pha khác nhau của chất đó. Sự chuyển từ pha này sang pha khác của một hệ gọi là sự chuyển pha. Nước khi hạ nhiệt độ đến 00C thì chuyển từ pha lỏng sang pha rắn là một ví dụ cho sự chuyển pha.

Các chất khác nhau phản ứng khác nhau đối với năng lượng truyền vào hoặc lấy đi trong quá trình chuyển pha do chúng có các sắp xếp phân tử bên trong khác nhau. Lượng năng lượng này cũng phụ thuộc vào khối lượng của chất. Khi nói đến hai pha của một chất, chúng ta sử dụng thuật ngữ _chất ở pha cao hơn_ để chỉ chất ở nhiệt độ cao hơn. Ví dụ khi nói về hai pha của nước là nước lỏng và và nước đá thì nước lỏng là chất ở pha cao hơn.

Xét một hệ gồm hai pha của một chất đang ở trạng thái cân bằng. Gọi khối lượng ban đầu của chất ở pha cao hơn là _m_ i. Sau khi nhận nhận nặng lượng Q khối lượng sau cùng của chất ở pha cao hơn là _m_ f. Nhiệt chuyển pha L được định nghĩa là:

𝐿 ≡

𝑄
∆𝑚

(20.6)

trong đó ∆𝑚 = 𝑚𝑓 − 𝑚𝑖 là độ biến thiên khối lượng của chất ở pha cao hơn. Giá trị của L phụ thuộc vào loại chuyển pha và các tính chất của chất chuyển pha.

Trong một quá trình chuyể pha, không có sự thay đổi về nhiệt độ của các chất. Nhiệt chuyển pha khi có sự chuyển pha từ rắn sang lỏng gọi là nhiệt nóng chảy. Nhiệt chuyển pha khi có sự chuyển pha từ lỏng sang khí gọi là nhiệt hóa hơi.

Nếu toàn bộ lượng vật chất ở pha thấp trải qua một sự chuyển pha, thì sự thay đổi khối lượng của vật chất ở pha cao bằng khối lượng ban đầu của vật liệu ở pha thấp. Ta cũng có thể viết lại phương trình

Q = L∆m (20.7)
Nếu năng lượng đi vào hệ:

  * Sẽ dẫn đến sự nóng chảy hoặc hóa hơi

  * Lượng vật chất ở pha cao sẽ tăng

  * Δ _m_ và _Q_ mang dấu dương


Nếu năng lượng được rút ra khỏi hệ:

  * Sẽ dẫn đến kết tinh hoặc hóa lỏng (ngưng tụ)

  * Lượng vật chất ở pha cao sẽ giảm

  * Δ _m_ và _Q_ mang dấu âm


_Bảng 20.2: Một số giá trị của của hệ số nhiệt chuyển pha_

![20T2](images/image10.jpeg)

### Bài tập mẫu 20.2:

Tính tổng năng lượng cần cung cấp để chuyển toàn bộ 1 g nước đá ở -300C thành hơi nước ở 1200C.

### Giải:

Hình 20.3 mô tả quá trình chuyển hóa của nước từ dạng đặc sang dạng hơi.

![2003](images/image11.jpeg)

_Hình 20.3: Đồ thị từ nước đá sang hơi nước_

Đồ thị có các phần sau
_Phần A: Nước đá tăng nhiệt độ_
Bắt đầu từ 1 gram nước đá ở -30 ºC, trong giai đoạn A, nhiệt độ của nước đá thay đổi từ -30ºC đến 0ºC, dựa vào bảng 20.1, ta có phương trình Q = mici∆T = (1 × 10−3)(2090)(30) = 62,7J
Trong trường hợp này, hệ thu năng lượng là 62,7 J.
_Phần B: băng tan_
Năng lượng chuyển hóa 1g nước đá sang dạng nước (chất lỏng), dựa vào bảng 20.2, sử dụng phương trình Q = 𝐿𝑓∆𝑚𝑤 = 𝐿𝑓𝑚𝑖 = (1 × 10−3)(3,33 × 105) = 333 J
Năng lượng thu vào: 333 J
_Phần C: nước tăng nhiệt độ_
Giữa 0 ºC và 100 ºC, vật liệu là chất lỏng và không có sự thay đổi trạng thái. Nước vẫn giữ nguyên pha. Hệ thu năng lượng làm tăng nhiệt độ.
Ta có Q = m𝑤cw∆T = (1 × 10−3)(4,19 × 103)(100) = 419 J
Năng lượng thu vào: 419 J
_Phần D: nước sôi_
Tại 100ºC, sự thay đổi trạng thái xảy ra (sôi). Nhiệt độ không thay đổi.
Sử dụng Q = 𝐿𝑣∆𝑚𝑠 = (1 × 10−3)(2,26 × 106) = 2260J
Năng lượng cần: 2260 J
_Phần E: bay hơi_
Sau khi toàn bộ nước được chuyển thành hơi nước, hơi nước sẽ nóng lên. Không xảy ra thay đổi trạng thái. Hệ thu năng lượng để tăng nhiệt độ.
Sử dụng Q = m𝑠c𝑠∆T = (1 × 10−3)(2,01 × 103)(20 =)40,2J
Khi nhiệt độ tăng từ 100oC đến 120oC, năng lượng cần: 40,2 J
Vậy tổng năng lượng 1gram nước đá thay đổi từ -30ºC đến 1200C cần năng lượng tổng là 3110 J.

### Sự chậm đông

Nếu nước ở dạng lỏng được giữ đứng yên trong một bình rất sạch thì có thể giảm nhiệt độ của nước xuống dưới 0oC mà không làm nó đóng băng. Hiện tượng này gọi là sự chậm đông.

Sự đóng băng chỉ xảy ra khi nước cần một sự nhiễu loạn theo cách nào đó để các phân tử tách nhau ra và tạo thành một cấu trúc băng rộng và mở để làm cho mật độ băng thấp hơn mật độ của nước. Nếu nước chậm động bị nhiễu loạn, nó sẽ đóng băng ngay lập tức. Hệ rơi về cấu hình năng lượng thấp của các phân tử liên kết của cấu trúc băng và năng lượng tỏa ra nâng nhiệt độ trở về 0 oC.

### Sự quá nhiệt

Nước sạch có thể tăng nhiệt độ đến trên 100o C mà không sôi. Hiện tượng này được gọi là **_sự quá nhiệt_.**

Sự hình thành bong bóng hơi trong nước đòi hỏi tâm hóa hơi. Tâm hóa hơi này có thể là một vết xước trên bình chứa hoặc một tạp chất trong nước. Khi bị nhiễu loạn, nước quá nhiệt có thể phát nổ. Bong bóng nước hình thành ngay lập tức, nước nóng được đẩy lên trên và trào ra ngoài bình chứa.

_**Câu hỏi 20.2:**_ Giả sử có một quá trình tương tự nhằm thêm năng lượng vào cục đá như trên, nhưng thay vào đó, ta sẽ vẽ đồ thị nội năng của hệ như là một hàm của năng lượng vào. Đồ thị đó sẽ như thế nào?

## ![](images/image12.png) Công và nhiệt trong các quá trình nhiệt động

### Các biến trạng thái

Các biến trạng thái mô tả trạng thái của một hệ. Bao gồm: Áp suất, nhiệt độ, thể tích, nội năng.

Trạng thái của một hệ cô lập chỉ được xác định khi hệ đang ở trạng thái cân bằng nhiệt. Đối với chất khí trong bình chứa, mọi thành phần của chất khí phải ở cùng nhiệt độ và áp suất.

### Sự trao đổi năng lượng

Nhiệt lượng, _Q_ , thu vào hoặc mất đi của một hệ phụ thuộc vào quá trình biến đổi. Nguồn nhiệt là một nguồn năng lượng được xem là đủ lớn để một sự trao đổi năng lượng có giới hạn không làm thay đổi nhiệt độ của nó.

Piston được giữ cố định ở vị trí ban đầu nhờ một tác nhân bên ngoài. Bỏ qua ngoại lực tác dụng lên hệ. Piston di chuyển lên và khí sinh ra một công trên piston. Suốt quá trình giãn nở, chỉ cần năng lượng vừa đủ để chuyển hóa năng lượng nhiệt từ bình chứa sang chất khí để duy trì nhiệt độ không đổi.

### Sự chuyển hóa năng lượng, hệ cô lập

Xét chất khí trong một xy lanh có một màng như hình vẽ. Ban đầu, khí bị nhốt ở bên dưới màng ngăn Hệ hoàn toàn cách nhiệt. Khi màng bị vỡ, chất khí nhanh chóng giãn nở lấp đầy khoảng trống cho đến khi đạt được thể tích cuối cùng. Lúc này, chất khí không sinh công vì nó không tác dụng lực. Không có năng lượng được trao đổi dưới dạng nhiệt thông qua lớp vỏ cách nhiệt

![](images/image13.jpeg)

_Hình 20.7: Sự trao đổi năng lượng của khí trong xylanh_
Tóm lại:

  * Năng lượng chuyển hóa bởi nhiệt, sinh công, phụ thuộc vào trạng thái đầu, cuối và trung gian của hệ.

  * Cả công và nhiệt đều phụ thuộc quá trình biến đổi.

  * Không thể xác định giá trị của công và nhiệt nếu chỉ dựa vào trạng thái đầu và cuối của một quá trình nhiệt động lực học.


## ![](images/image14.jpeg)![](images/image15.png) Nguyên lý thứ nhất của nhiệt động lực học

Nguyên lý thứ nhất của nhiệt động lực học là trường hợp đặc biệt của định luật bảo toàn năng lượng. Đó là trường hợp đặc biệt khi chỉ có sự biến đổi nội năng và chỉ có sự trao đổi năng lượng bởi nhiệt và công.

Nguyên lý thứ nhất của nhiệt động lực học
∆𝐸𝑖𝑛𝑡 = 𝑄 + 𝑊
Tất cả các đại lượng phải có cùng đơn vị của năng lượng.

Một hệ quả của nguyên lý này là sự tồn tại đại lượng được biết đến như là nội năng – được xác định bởi trạng thái của hệ. Nội năng là một biến trạng thái.

_Hình 20.8: Nguyên lý 1 nhiệt động lực học_

Hệ cô lập là hệ không tương tác với môi trường xung quanh. Không có sự trao đổi năng lượng bằng nhiệt. Công thực hiện trên hệ bằng 0.

_Q_ = _W_ = 0, nên ∆ _E_ int = 0 Nội năng của hệ cô lập không đổi.

### Các chu trình

Chu trình là một tiến trình bắt đầu và kết thúc ở cùng một trạng thái.
Trên giản đồ PV, chu trình được biểu diễn như một đường cong khép kín. Độ biến thiên nội năng bằng 0 vì nó là một biến trạng thái
Nếu ∆ _E_ int = 0, _Q_ = - _W_

Trong một chu trình, công thực hiện trên hệ trong mỗi chu trình có độ lớn bằng diện tích của vùng giới hạn bởi đường cong biểu diễn chu trình trên giản đồ PV.

## ![](images/image16.png) Một vài ứng dụng của nguyên lý thứ nhất nhiệt động lực học

### Quá trình đoạn nhiệt

Quá trình đoạn nhiệt là quá trình trong đó không có năng lượng vào hoặc ra khỏi hệ dưới dạng nhiệt.

_Q_ = 0

Điều này có được do: Các thành cách nhiệt của bình, Các quá trình được thực hiện nhanh nên không có sự trao đổi nhiệt.

Vì _Q_ = 0, ∆ _E_ int = _W_
Nếu khí bị nén đoạn nhiệt, _W_ mang dấu dương, ∆ _E_ int mang dấu dương và nhiệt độ tăng. Nếu khí giãn nở đoạn nhiệt, nhiệt độ khí giảm.
Một số ví dụ điển hình về quá trình đoạn nhiệt trong kỹ thuật:

  * Sự giãn nở của khí nóng trong động cơ đốt trong.

  * Khí ga hóa lỏng trong hệ thống làm mát.

  * Nén đột ngột trong động cơ diesel.


### Sự giãn nở tự do đoạn nhiệt

Đây là quá trình đoạn nhiệt vì nó diễn ra trong bình cách nhiệt. Vì chất khí giãn nở vào khoảng trống, nó không tác dụng lực lên piston và _W_ = 0.

Vì _Q_ = 0 và _W_ = 0 => Δ _E_ int = 0, nghĩa là nội năng của khối khí ở trạng thái đầu và cuối bằng nhau.

Nếu khối khí thực hiện quá trình là khí lý tưởng thì nhiệt độ của khối khí trong quá trình này không thay đổi.

### Quá trình đẳng áp

Quá trình đẳng áp là quá trình xảy ra khi áp suất không đổi.

Có thể thực hiện bằng cách cho piston di chuyển tự do, vì vậy hệ luôn ở trạng thái cân bằng giữa lực tổng hợp từ khí đẩy lên và trọng lượng của piston cộng với lực do áp suất của không khí đẩy xuống.

Giá trị nhiệt và công nói chung đều khác 0.
Công là _W_ = - _P_ ( _Vf_ – _Vi_ ) với _P_ là áp suất không đổi.

### Quá trình đẳng tích

Quá trình đẳng tích là quá trình xảy ra khi thể tích không đổi. Thực hiện bằng cách kẹp piston ở vị trí cố định.
Vì thể tích không đổi, _W_ = 0. Từ định luật 1, ∆ _E_ int = _Q_

Nếu năng lượng được truyền bởi nhiệt vào một hệ có thể tích không đổi, toàn bộ năng lượng sẽ truyền vào cho hệ và nội năng của hệ tăng lên.

### ![](images/image17.png)Quá trình đẳng nhiệt

Quá trình đẳng nhiệt là quá trình trong đó nhiệt độ không đổi.

Thực hiện bằng cách đặt các xylanh tiếp xúc với nguồn nhiệt có nhiệt độ không đổi.

Vì nhiệt độ không đổi, ∆ _E_ int = 0. Nên, _Q_ = − _W_

Năng lượng bất kỳ đi vào hệ dưới dạng nhiệt phải ra khỏi hệ dưới dạng công.

Hình 20.9 mô tả giản đồ PV của quá trình giãn nở đẳng nhiệt.

Đường cong có dạng hypebol. Đường cong gọi là đường đẳng nhiệt

Phương trình:
_Hình 20.9: Quá trình đẳng nhiệt_
![](images/image18.png) _pV_ = _n R T_ = hằng số

# Public_143

## ![](images/image1.png) Mô hình phân tử của khí lý tưởng

### Mô hình khí lý tưởng

Một số giả thiết đơn giản hóa tính chất của một hệ khí lý tưởng:

  * Chất khí bao gồm một số rất lớn các phân tử. Mỗi phân tử có khối lượng và kích thước có thể bỏ qua so với khoảng cách trung bình giữa các phân tử.

  * Chuyển động của các phân tử cá thể được mô tả bằng cơ học Newton.

  * Phân tử chuyển động tự do trừ khi nó va chạm với phân tử khác hay với thành bình chứa nó. Tất cả va chạm xem là đàn hồi.

  * Bỏ qua thế năng tương tác giữa các phân tử khí.


### Số bậc tự do của phân tử khí _i_

Từ lý thuyết về _**sự phân bố đều năng lượng**_ của hệ khí như trình bày ở trên, ta phân tích cụ thể số bậc tự do của một hệ khí bất kỳ:

  * Khí đơn nguyên tử (phân tử khí có một nguyên tử): ví dụ các phân tử khí hiếm heli, neon, argon… Các phân tử khí đơn nguyên tử chuyển động tịnh tiến theo ba trục tọa độ xyz, mỗi chuyển động tịnh tiến sẽ có động năng tương ứng là _**½kBT**_. Chuyển động quay của phân tử khí đơn nguyên tử ứng với trục quay qua khối tâm của phân tử khí có năng lượng không đáng kể. _Tóm lại, phân tử khí đơn nguyên tử có số bậc tự do i = 3_.

  * Khí hai nguyên tử (hay lưỡng nguyên tử là phân tử khí có hai nguyên tử): ví dụ khí oxy, nito… Các phân tử khí lưỡng nguyên tử có ba chuyển động tịnh tiến và hai chuyển động quay quanh hai trục không đi qua hai nguyên tử của phân tử (một trục quay qua hai nguyên tử của phân tử có năng lượng không đáng kể), mỗi chuyển động này tương ứng động năng là _**½kBT**_. _Tóm lại, phân tử khí lưỡng nguyên tử có số bậc tự do i = 5_.

  * Khí đa nguyên tử (phân tử khí có ba nguyên tử trở lên): Các phân tử khí đa nguyên tử có 3 chuyển động tịnh tiến và 3 chuyển động quay quanh 3 trục, mỗi chuyển động này tương ứng động năng là _**½kBT**_. _Tóm lại, phân tử khí đa nguyên tử có số bậc tự do i = 6._


Tuy nhiên đối với phân tử đa nguyên tử, nhiều trường hợp i có giá trị lớn hơn do có thêm năng lượng dao động giữa các nguyên tử, phân tử.

### Nội năng của khí lý tưởng

Nội năng của một hệ khí là năng lượng bên trong hệ bao gồm động năng phân tử (năng lượng do chuyển động tự do của các phân tử), thế năng tương tác giữa các phân tử và năng lượng bên trong mỗi phân tử, nguyên tử.
Đối với khí lý tưởng, ta có thể bỏ qua thế năng tương tác giữa các phân tử do lực tương tác giữa các phân tử là rất yếu. Ngoài ra, chúng ta cũng không xét đến các quá trình biến đổi diễn ra trong
từng phân tử.
Độ biến thiên nội năng của một hệ khí lý tưởng khi hệ khí thay đổi một lượng nhiệt ∆𝑇
là:
𝑖
∆𝐸𝑖𝑛𝑡 = 𝑛 2 𝑅. ∆𝑇 (21.9)
Ví dụ một vài quá trình làm thay đổi nhiệt độ của một khối khí lý tưởng như hình 21.4.
Cả ba quá trình đều làm thay đổi một lượng nhiệt ∆𝑇 = 𝑇𝑓 − 𝑇𝑖 . Do ∆𝑇 là như nhau ở 3 quá
trình trên nên ∆ _E_ int cũng như nhau. Tuy nhiên công thực hiện trên chất khí là khác nhau đối với mỗi đường đi và nhiệt lượng tương ứng với mỗi đường biến đổi cũng không giống nhau. Bởi vì _**công và nhiệt lượng là hàm quá trình**_ , quá trình biến đổi khác nhau thì chúng khác nhau.

### ![](images/image3.png) Nhiệt dung phân tử (nhiệt dung mol) của khí lý tưởng

Giả sử một khối khí lý tưởng biến đổi từ trạng thái _i_ có các thông số (Pi, Vi, Ti) sang trạng thái _f_ (Pf, Vf, Tf) có khối lượng m, phân tử gam M suy ra số mol của khối khí 𝑛 = 𝑚. Xét một

𝑀

số quá trình đặc biệt thường xảy ra như sau:
Suy ra _**nhiệt dung mol đẳng tích**_ :
𝑖
𝐶V = 2 𝑅 (21.11)
![](images/image4.jpeg)
_Hình 21.5: Năng lượng được truyền bởi nhiệt cho hệ khí theo 2 cách._
_**Quá trình đẳng áp:**_ là quá trình áp suất của khí không đổi Pi = Pf, hình 21.5 là đường thẳng nằm ngang.

  * Nhiệt lượng trao đổi trong quá trình này là


𝑄 = 𝑛𝐶P∆𝑇 (21.12)
với _C_ P là nhiệt dung mol đẳng áp.

  * Công thực hiện trong quá trình này


𝑊 = − ∫ 𝑃𝑑𝑉 = −𝑃 ∫ 𝑑𝑉 = 𝑃(𝑉𝑖 − 𝑉𝑓)

  * Áp dụng nguyên lý 1 nhiệt động lực học ∆𝐸𝑖𝑛𝑡 = 𝑊 + 𝑄 cho quá trình đẳng tích:


𝑖
𝑛 2 𝑅. ∆𝑇 = 𝑃(𝑉𝑖 − 𝑉𝑓) + 𝑛𝐶P∆𝑇
Cộng thêm từ phương trình trạng thái khí lý tưởng 𝑃𝑉 = 𝑛𝑅𝑇 thay vào phương trình trên, ta được:
Hay
𝑖

𝑛 2 𝑅. ∆𝑇 = 𝑛𝑅(𝑇𝑖 − 𝑇𝑓 ) + 𝑛𝐶P∆𝑇

𝑖

𝑛 2 𝑅. ∆𝑇 = −𝑛𝑅∆𝑇 + 𝑛𝐶P∆𝑇

_Bảng 21.2: Tỷ số nhiệt dung phân tử của một số chất khí_

![](images/image5.jpeg)

_**Câu hỏi 21.2:**_ (i) Nội năng của khí lý tưởng thay đổi từ trạng thái i đến f như trên hình 21.5.
(a) nội năng tăng, (b) nội năng giảm, (c) nội năng không đổi và (d) không đủ thông tin để xác định nội năng như thế nào. (ii) Cùng các lựa chọn như phần (i), nội năng thay đổi như thế nào khi hệ khí biến đổi từ f  f’ như trên hình 21.5.

### Bài tập mẫu 21.2:

Một xylanh chứa 3 mol khí lý tưởng heli ở 300 K.

  1. Khối khí được nung nóng đẳng tích, tính nhiệt lượng truyền cho khối khí để làm nó tăng nhiệt độ lên 500K.

  2. Khối khí được nung nóng đẳng áp, tính nhiệt lượng truyền cho khối khí để làm nó tăng nhiệt độ lên 500K.


### Giải:

He là khí đơn nguyên tử nên ta có i = 3

  1. Nhiệt lượng truyền cho khối khí để làm nó tăng nhiệt độ lên 500K trong quá trình đẳng tích là:


𝑖

𝑄1 = 𝑛𝐶V∆𝑇 = 𝑛 2 𝑅

(𝑇𝑓 − 𝑇𝑖 )

3

= 3 × ![](images/image6.png) × 8,31 ×

2

(500 − 300)
= 7,5 × 103𝐽

  2. Nhiệt lượng truyền cho khối khí để làm nó tăng nhiệt độ lên 500K trong quá trình đẳng áp là:


𝑄2

= 𝑛𝐶P

∆𝑇 = 𝑛 𝑖+2 𝑅

2

(𝑇𝑓 − 𝑇𝑖 )

5

= 3 × ![](images/image7.png) × 8,31 ×

2

(500 − 300)
= 12,5 × 103𝐽

## ![](images/image8.png) Quá trình đoạn nhiệt cho khí lý tưởng

![](images/image9.jpeg)Nhiều quá trình quan trọng diễn ra nhanh đến nỗi phần nhiệt được thêm vào cho hệ là không đáng kể, đó là quá trình đoạn nhiệt. Nếu chất khí lý tưởng thực hiện một quá trình đoạn nhiệt chuẩn tĩnh, khi đó chất khí đi qua một chuỗi các trạng thái cân bằng được biểu diễn bằng đường cong trên giản đồ p-V. Ta xét một bước vô cùng nhỏ trong quá trình đoạn nhiệt dQ = 0.
Áp dụng định luật thứ nhất cho quá trình đoạn nhiệt:
𝑑𝐸𝑖𝑛𝑡 = 𝑛𝐶𝑉𝑑𝑇 = −𝑃𝑑𝑉
Lấy vi phân phương trình trạng thái khí lý tưởng:
𝑃𝑉 = 𝑛𝑅𝑇
ta có
𝑃𝑑𝑉 + 𝑉𝑑𝑃 = 𝑛𝑅𝑑𝑇
_Hình 21.6: Đường biểu diễn quá trình đoạn nhiệt_

# Câu hỏi lý thuyết chương 21

  1. Tại sao ở cùng một nhiệt độ, lượng năng lượng trên mỗi mol của khí lưỡng nguyên tử lại lớn hơn của khí đơn nguyên tử?

  2. Cái nào đậm đặc hơn: không khí khô, hay không khí bão hòa với hơi nước? Giải thích.

  3. Một thùng chứa đầy khí heli và một bình khác chứa khí argon. Cả hai thùng chứa đều ở cùng nhiệt độ. Những phân tử nào có tốc độ hiệu dụng vrms cao hơn? Giải thích.


# Bài tập chương 21

  1. Trong khoảng thời gian 30 s, 500 cục mưa đá tấn công tới bề mặt một cửa sổ làm bằng kính có diện tích 0,6 m2 theo một góc 450. Mỗi cục mưa đá có khối lượng 5 g và tốc độ 8 m/s. Giả sử các va chạm là đàn hồi, tìm (a) lực trung bình và (b) áp suất trung bình lên cửa sổ trong khoảng thời gian này **.**


ĐS: 0,94 N; 1,57 Pa

  2. Một bình 5 lít chứa khí nitơ ở 27°C và 3 atm. Tìm (a) tổng động năng chuyển động tịnh tiến của các phân tử khí và (b) động năng trung bình trên mỗi phân tử.


ĐS: 2,3 kJ; 6,2.10-21 J

  3. Trong quá trình đẳng tích, 209 J nhiệt lượng được truyền tới 1 mol khí đơn nguyên tử ở trạng thái lý tưởng, ban đầu ở 300 K. Tìm (a) công thực hiện của khí, (b) độ tăng nội năng của khí, và (c) nhiệt độ cuối cùng của nó.


ĐS: 0; 209 J; 317 K

  4. Cho 1mol khí hydro được nung nóng ở áp suất không đổi từ 300 K đến 420 K. Tính (a) nhiệt lượng khí nhận được, (b) độ tăng nội năng của nó, và (c) công khí thực hiện .


ĐS: 3,46 kJ; 2,45 kJ; -1,01kJ

  5. Một xylanh đứng với một piston nặng ở phía trên có chứa một khối không khí (xem là khí lưỡng nguyên tử) ở 300 K. Áp suất khí ban đầu là 2.105 Pa, thể tích ban đầu 0,35 m3. Khối lượng mol của không khí là 28,9 g/mol. (a) Tính nhiệt dung riêng đẳng tích của khối khí theo đơn vị kJ/kg.oC. (b) Tính khối lượng của khối khí trong xylanh. (c) Giả sử piston được giữ cố định, hỏi cần truyền cho khối khí một năng lượng bằng bao nhiêu để khí tăng nhiệt độ lên 700 K. (d) Giả sử piston được tự do dịch chuyển, hỏi cần truyền cho khối khí một năng lượng bằng bao nhiêu để khí tăng nhiệt độ lên 700 K.


ĐS: 0,719 kJ/kg.oC; 0,811 kg; 233 kJ; 327 kJ (giả sử đẳng áp)

  6. Tính công cần thiết để nén 5 mol không khí ở 200C và 1atm đến một phần mười của thể tích ban đầu. (a) trong quá trình đẳng nhiệt? (b) trong quá trình đoạn nhiệt? (c) Tính áp suất cuối trong quá trình đẳng nhiệt? (d) Tính áp suất cuối trong quá trình đoạn nhiệt?


ĐS: 28 kJ; 46 kJ; 10 atm; 25,1 atm

  7. ![](images/image10.jpeg)Trong quá trình sinh công của động cơ ô tô bốn thì, Piston chuyển động xuống dưới cylinder (xi-lanh) tạo ra một khoảng không trong cylinder để chứa nhiên liệu phun sương từ bộ chế hoà khí. Xem nhiên liệu gồm hỗn hợp của các sản phẩm đốt và không khí. Chúng thực hiện quá trình giãn đoạn nhiệt. Giả sử (1) động cơ đang chạy ở tốc độ 2500 vòng/phút; (2) áp suất đo ngay lập tức trước khi giãn nở là 20 atm; (3) thể tích của hỗn hợp ngay trước và sau khi giãn nở là 50 cm3 và 400 cm3, tương ứng (Hình. P21.31); (4) khoảng thời gian cho việc giãn nỡ là một phần tư trong tổng chu kỳ; và (5) hỗn hợp hoạt động như một loại khí lý tưởng


với tỷ lệ nhiệt cụ thể 1,4. Tìm công suất trung bình được tạo ra trong quá trình sinh công trên.
ĐS: 25 kW

# Public_144

Trong chương này, ta sẽ bắt đầu nghiên cứu về thuyết điện từ trường. Mối liên kết đầu tiên mà ta có với các kiến thức cũ là khái niệm về lực. Lực điện từ giữa các hạt mang điện là một trong những lực cơ bản của tự nhiên. Ta bắt đầu bằng việc mô tả một số tính chất cơ bản của biểu hiện đầu tiên của lực điện từ là lực tĩnh điện. Sau đó ta sẽ nghiên cứu định luật Coulomb, một định luật chi phối tương tác điện giữa hai điện tích bất kỳ. Từ đây, ta sẽ giới thiệu khái niệm về điện trường, gắn liền với một phân bố điện tích và mô tả ảnh hưởng của nó lên các hạt mang điện khác. Ta sẽ dùng định luật Coulomb để tìm cường độ điện trường của một phân bố điện cho trước. Ngoài ra, ta cũng sẽ tìm hiểu chuyển động của một hạt mang điện trong điện trường đều.
Liên hệ thứ hai giữa thuyết điện từ với các nội dung trước đây là khái niệm về _năng lượng_. Nội dung này sẽ được trình bày trong chương 25

## ![](images/image1.png) Các tính chất của điện tích

Nhiều thí nghiệm đơn giản đã minh họa cho sự tồn tại của các lực điện. Ví dụ như khi dùng tay cọ xát một quả bóng cao su trong một ngày khô ráo thì ta có thể thấy rằng quả bóng có thể hút các mẩu giấy nhỏ. Lực hút thường là đủ lớn để làm các mẩu giấy treo lơ lửng bên dưới quả bóng.
Khi vật chất hành xử theo cách này, ta nói chúng bị nhiễm điện hay đã tích điện. Trong một loạt thí nghiệm đơn giản, người ta tìm thấy rằng có hai loại điện tích mà
Benjamin Franklin (1706–1790) gọi là điện tích dương và điện tích âm. Các electron được
![](images/image2.jpeg)xem là mang điện tích âm và các proton mang điện tích dương. Để kiểm chứng sự tồn tại của hai loại điện tích, giả sử ta cọ xát một thanh cứng bằng cao su vào lông thú rồi treo nó lên trên một sợi dây như trong hình 23.1. Nếu đưa một thanh thủy tinh (đã được cọ xát vào lụa) lại gần thanh cao su thì chúng sẽ hút nhau (hình 23.1a). Mặt khác, nếu để hai thanh cao su (hoặc thủy tinh) đã nhiễm điện lại gần nhau thì chúng sẽ đẩy nhau (hình23.1b). Trên cơ sở các quan sát này, ta Biện luận rằng các điện tích cùng dấu thì đẩy nhau và các điện tích trái dấu thì hút nhau.
Theo qui ước của Franklin thì điện tích trên thanh thủy tinh nói trên được gọi là điện tích dương và điện tích trên thanh cao su được gọi là điện tích âm. Vì vậy, vật tích điện nào bị hút vào thanh cao su tích điện (hoặc bị đẩy ra xa thanh thủy tinh tích điện) sẽ phải có điện tích dương.
Một khía cạnh quan trong khác về điện được rút ra từ các quan sát thực nghiệm là trong một hệ cô lập thì **điện tích luôn được bảo toàn**. Nghĩa là khi cọ xát vật này vào vật khác thì điện tích không được sinh ra
trong quá trình này. Trạng thái nhiễm điện là do có điện tích _Hình_ 23.1
chuyển từ vật này sang vật kia. Một vật nhận một lượng điện tích âm thì vật kia nhận một lượng điện tích dương tương ứng. Ví dụ như khi cọ xát thanh thủy tinh vào lụa thì lụa nhận một lượng điện tích âm có độ lớn bằng lượng điện tích dương mà thanh thủy tinh có được. Vận dụng hiểu biết về cấu tạo của nguyên tử thì ta có thể nói rằng trong quá trình này một số electron đã được chuyển từ thanh thủy tinh sang lụa. Tương tự như vậy, khi cọ xát cao su vào lông thú thì electron được chuyển từ lông thú sang cho cao su. Sở dĩ như vậy là do bình thường thì vật chất trung hòa về điện.
Vào năm 1909, Robert Millikan (1868–1953) khám phá ra rằng các hạt mang điện luôn luôn xuất hiện như là bội của một đện lượng e. Theo cách nói hiện đại, điện tích _q_ (ký hiệu chuẩn dùng cho điện tích) được xem là bị _**lượng tử hóa**_. Nghĩa là hạt mang điện
![](images/image4.png)
_Hình_ 23.2
tồn tại như là các “gói” rời rạc và ta có thể viết _q_ = ± _Ne_ với _N_ là một số nguyên bất kỳ. Một số thí nghiệm khác vào thời gian này đã cho thấy là electron có điện tích − _e_ và proton có điện tích + _e_. Một số hạt khác, neutron chẳng hạn, thì không mang điện.
_**Trắc nghiệm nhanh 23.1:**_ Ba vật được đưa lại gần nhau từng đôi một. Vật A và vật B đẩy nhau. Vật B và vật C cũng đẩy nhau. Phát biểu nào sau đây có thể đúng? (a) Các vật A và C có điện tích cùng dấu. (b) Các vật A và C có điện tích trái dấu. (c) Cả ba vật này mang điện cùng dấu. (d) Một trong ba vật trung hòa về điện. (e) Cần làm thêm một vài thí nghiệm khác để xác định dấu của các điện tích.

## ![](images/image5.png) Nhiễm điện do cảm ứng

Việc phân loại vật chất theo khả năng di chuyển của electron trong vật chất là một cách làm thuận tiện.
Khi đó, **chất dẫn điện** là các vật liệu mà electron là electron tự do, không bị liên kết với các nguyên tử và có thể di chuyển tương đối tự do trong vật liệu; **chất cách điện** là các vật liệu mà mọi electron bị liên kết với nguyên tử và không thể di chuyển tục do trong vật liệu. Các vật liệu như thủy tinh, cao su và gỗ khô được xếp vào nhóm chất cách điện. Khi các vật liệu này bị nhiễm điện do cọ xát thì chỉ vùng bị cọ xát bị nhiễm điện và các điện tích không dịch chuyển sang các vùng khác. Ngược lại, các vật liệu như đồng, nhôm và bạc là các vật dẫn điện tốt. Khi một vùng nhỏ của các vật liệu này bị nhiễm điện thì điện tích sẽ tự phân bố trên toàn bộ bề mặt của vật chất.
**Chất bán dẫn** là loại vật chất thứ ba. Tính dẫn điện của nó nằm giữa chất dẫn điện và chất cách điện. Silic (Si) và germani (Ge) là những ví dụ rõ ràng về chất bán dẫn, thường dùng để sản xuất các loại vi mạch (chíp) trong máy tính, điện thoại di động và các hệ thống giải trí tại nhà. Các tính chất điện của chất bán dẫn có thể thay đổi nhiều lần bằng cách thêm vào một lượng nguyên tử của một chất khác.
Để hiểu cách làm nhiễm điện một chất dẫn điện bằng quá trình cảm ứng, ta dùng một quả cầu kim loại rỗng đặt cách điện với mặt đất như hình 23.3. Nếu điện tích của quả cầu đúng bằng 0 thì nó có một số lượng proton và electron như nhau. Khi đưa một thanh cao su nhiễm điện lại gần quả cầu, các electron ở vùng gần thanh nhất sẽ bị đẩy sang phía đối diện của quả cầu. Sự dịch chuyển này để lại một vùng mang điện dương trên quả cầu.
![](images/image6.jpeg) ![](images/image7.jpeg)![](images/image8.jpeg)

![](images/image11.jpeg)![](images/image12.jpeg)

_Hình 23.3: Hiện tượng tích điện do cảm ứng._

a: Quả cầu có số điện tích dương và điện tích âm bằng nhau.
b: Một thanh cao su nhiễm điện được đặt gần quả cầu, không tiếp xúc với quả cầu.
Các electron trong quả cầu trung hòa điện sẽ được phân bố lại.
c: Quả cầu được nối với mặt đất. Một số electron có thể rời quả cầu thông qua dây tiếp
đất.
d: Bỏ dây tiếp đất. Bây giờ quả cầu sẽ có nhiều điện tích dương hơn. Điện tích không
được phân bố đồng đều. Điện tích dương đã bị cảm ứng bởi quả cầu.
e: Bỏ thanh cao su. Các electron tự phân bố lại trên quả cầu. Vẫn có một tập hợp các điện tích dương trên quả cầu. Điện tích bây giờ được phân bố đồng đều trên quả cầu. Chú ý rằng thanh không mất điện tích âm trong quá trình này.
Để làm nhiễm điện một vật dẫn điện bằng cảm ứng không cần phải có sự tiếp xúc với vật cảm ứng. Điều này khác với cách làm nhiễm điện do cọ xát là cách mà cần phải có sự tiếp xúc giữa hai vật.
Một quá trình tương tự với sự cảm ứng có thể xảy ra trong vật cách điện. Trong hầu hết các phân tử trung hòa thì tâm điện âm trùng với tâm điện dương. Khi đến gần một vật mang điện, các tâm này rời xa nhau một khoảng nhỏ và làm xuất hiện điện tích âm ở một phía và điện tích dương ở phía kia. Sự sắp xếp diễn ra bên trong các phân tử này tạo ra một lớp điện tích trên bề mặt của chất cách điện như trong hình 23.4a. Từ đó làm xuất hiện lực hút giữa vật tích điện và vật cách điện. Nhờ đó ta giải thích được tại sao một thanh nhiễm điện lại có thể hút các mẩu giấy trung hòa về điện như trong hình 23.4b.
![](images/image15.jpeg)

_Hình 23.4_

**Trắc nghiệm nhanh 23.2** : Ba vật được đưa lại gần nhau, từng đôi một. Khi vật A và vật B ở gần nhau thì chúng hút nhau. Khi vật B và vật C ở gần nhau thì chúng đẩy nhau. Phát biểu nào sau đây là chắc chắn đúng? a) Vật A và C có điện tích cùng dấu. b) Vật A và C có điện tích trái dấu. c) Cả ba vật đều tích điện cùng dấu. d) Một trong ba vật trung hoà về điện. e) Cần làm thêm một vài thí nghiệm để xác định thông tin về điện tích của các vật.

## ![](images/image16.png) Định luật Coulomb

Charles Coulomb đã đo độ lớn của các lực điện giữa các vật tích điện bằng cân xoắn do ông chế tạo. Nguyên tắc hoạt động của cân xoắn cũng giống như thiết bị do Cavendish dùng để đo khối lượng riêng của Trái đất, trong đó, quả cầu trung hòa về điện được thay bằng một quả cầu tích điện. Lực điện giữa các quả cầu tích điện A và B trong hình 23.5 làm cho chúng hút vào nhau hoặc tách xa nhau ra. Do đó, dây treo bị xoắn lại. Vì lực xoắn của dây tỉ lệ với góc mà thanh treo quay được nên số đo góc này sẽ cho biết độ lớn của lực hút hoặc đẩy giữa các quả cầu. Lực điện có độ lớn lớn hơn nhiều so với lực hấp dẫn giữa chúng, do đó có thể bỏ qua lực hấp dẫn.
![](images/image17.jpeg)
![](images/image18.jpeg)Hình 23.5: Cân xoắn
Charles Coulomb đã đo cường độ lực điện giữa 2 quả cầu nhỏ tích điện. Lực này tỉ lệ nghịch với bình phương khoảng cách _r_ giữa các điện tích và hướng dọc theo đường nối giữa chúng, tỉ lệ thuận với tích của các điện tích _q1_ và _q2_. Các điện tích trái dấu thì hút nhau (lực hút). Các điện tích cùng dấu thì đẩy nhau (lực đẩy).
Trong SI, đơn vị của điện tích coulomb (C). Trong tự nhiên giá trị điện tích nhỏ nhất là
Charles Coulomb (1736 – 1806) Nhà vật lý người Pháp.
Ông có những đóng góp lớn liên quan đến lĩnh vực tĩnh điện và từ tính.
Các lĩnh vực nghiên cứu khác

  * Sức bền vật liệu

  * Cơ học kết cấu

  * Công thái học (Ergonomics)


_e_ = 1,60218 × 10−19 C. Một điện tích có độ lớn là 1 C tương ứng với 6,2460218 × 1018 electron hoặc proton. Các điện tích thường gặp có giá trị khoảng vài µC.
Electron và proton giống nhau về độ lớn điện tích nhưng khác nhau về khối lượng.
Proton và neutron giống nhau về khối lượng nhưng khác nhau về điện tích.
Khi sử dụng định luật Coulomb, cần nhớ rằng lực là một đại lượng vec-tơ và phải xem xét nó một cách phù hợp. Nếu biểu diễn định luật Coulomb dưới dạng vec-tơ, ta sẽ có:

![](images/image19.png)12

_e_

_r_ 2 12
(23.2)
![](images/image20.jpeg)
Hình 23.6: Lực điện tác dụng giữa các hạt mang điện
Trong đó: _r_ ˆ12 là vec-tơ đơn vị, hướng từ điện tích _q_ 1 đến điện tích _q_ 2 như trong hình
![](images/image21.png)![](images/image22.png)23.6. _F_ 12 là lực điện mà điện tích _q_ 1 tác dụng lên điện tích _q_ 2, bằng độ lớn của lực _F_ 21
(do _q_ 2 tác dụng lên điện tích _q_ 1).
Lưu ý về hướng của lực: Dấu của tích _q_ 1 _q_ 2 sẽ cho biết hướng của lực điện tác dụng giữa _q_ 1 và _q_ 2\. Trong hình 23.6a, hai điện tích là dùng dấu nên lực là lực đẩy, hướng ra phía ngoài hai điện tích. Trong hình 23.6b, hai điện tích trái dấu nên lực là lực đẩy, hướng vào phía trong 2 điện tích.
Nếu có nhiều hơn 2 điện tích thì lực tác dụng giữa mỗi cặp điện tích được tính bởi (23.2). Lực tổng hợp tác dụng lên một điện tích bất kỳ sẽ bằng tổng vec-tơ của các lực tác
dụng lên điện tích đó từ các điện tích còn lại. Ví dụ, nếu có 4 điện tích thì lực tổng hợp tác dụng lên điện tích thứ nhất sẽ là:

![](images/image23.png)

Trắc nghiệm nhanh 23.3:

![](images/image24.png)![](images/image26.png)![](images/image27.png)Vật A có điện tích 12 μC và vật B có điện tích 16 μC. Phát biểu nào dưới đây về lực điện tác dụng lên các điện tích này là đúng?

### ![](images/image28.png) **F** AB = −3 **F** BA

  1. **F** AB = − **F** BA

  2. 3 **F** AB = − **F** BA

  3. **F** AB = 3 **F** BA


![](images/image29.png)![](images/image30.png)e) **F** AB = **F** BA f) 3 **F** AB = **F** BA

Bài toán mẫu 23.2:

![](images/image31.jpeg)Xét 3 điện tích điểm nằm ở 3 góc của một tam giác vuông như trong hình 23.7. Biết _q_ 1 = _q_ 3 = 5,00 μC, _q_ 2 = −2,00 μC và _a_ = 0,100 m. Tìm lực tổng hợp tác dụng lên điện tích _q_ 3.
_**Khái niệm hóa**_ : Xét điện tích _q_ 3\. Vì nó nằm gần 2 điện tích còn lại nên sẽ chịu tác dụng của hai lực điện. Các lực này tác dụng theo hai hướng khác nhau (hình 23.7). Dựa vào các lực này, ta ước lượng được vec-tơ lực tổng hợp.
_**Phân loại**_ : Bài toán này thuộc dạng tính tổng vec-tơ.
Hình 23.7

#### 

**F** 23

#### _F_ 23 _x_ = − _F_ 23cos(180°) = −8,99 N .

![](images/image32.png)Từ đó tính được các thành phần của lực **F** 3 :

_F_ 3 _x_

_F_ 3 _y_

= _F_ 13 _x_ \+ _F_ 23 _x_
= _F_ 13 _y_ \+ _F_ 23 _y_

###   
= 7,94 + (−8,99) = −1, 05 N

###### = 7,94 + 0 = 7,94 N .

###### 

![](images/image33.png)Tức là: **F** 3 = (−1, 04ˆ **i** \+ 7,94ˆ **j** ) N
_**Biện luận**_ : Lực tổng hợp tác dụng lên điện tích _q_ 3 hướng chéo lên phía trên, sang trái.
_**Biện luận**_ : Về mặt toán học, phương trình nói trên có thể có một nghiệm khác là x = −3,44 m nhưng không phù hợp với bài toán. Ở tọa độ này, hai lực tác dụng lên _q_ 3 cùng chiều nên không thể triệt tiêu lẫn nhau.

## ![](images/image34.jpeg)![](images/image35.png) Hạt trong điện trường

Trong trường hợp các lực điện, Faraday đã phát triển khái niệm về trường. Theo hướng tiếp cận này, một điện trường được cho là tồn tại trong vùng không gian xung quanh các vật tích điện, điện tích nguồn. Có thể phát
hiện ra sự tồn tại của điện trường bằng cách đặt một điện tích thử vào trong trường đó và xem xét lực điện tác dụng lên nó. Ví dụ, trong hình 23.10 là một điện tích thử dương
Hình 23.10: Điện tích thử đặt gần điện tích nguồn.
Nếu đặt một điện tích _q_ bất kỳ vào điện trường thì nó sẽ chịu một lực điện cho bởi:
![](images/image36.png) **F =** _q_ **E** (23.4)
Nếu _q_ dương, lực điện và điện trường cùng chiều nhau. Nếu _q_ âm, lực điện và điện trường ngược chiều nhau.
![](images/image37.png)![](images/image38.png)Công thức (23.4) có sự tương tự với công thức của vật trong trường trọng lực **F =** _m_ **g** . Công thức này được dùng để tìm lực điện tác dụng lên một điện tích bất kỳ tại một vị trí mà ở đó đã biết điện trường.
Áp dụng định luật Coulomb ta tìm được lực điện tác dụng bởi điện tích điểm _q_ lên điện tích thử _q_ 0 đặt gần nó:
![](images/image39.png) _e r_ 2
Từ đó, điện trường tại điểm đặt điện tích thử _q_ 0 sẽ là:
**E** = _k_
_q_ **r** ˆ

![](images/image40.png) _e r_ 2

(23.5)
Nếu điện tích _q_ dương, lực hướng ra xa _q_. Điện trường hướng ra xa điện tích nguồn dương. Nếu _q_ âm, lực hướng lại gần _q_. Điện trường hướng lại gần điện tích nguồn âm.
![](images/image41.jpeg)
Hình 23.11: Lực điện và điện trường do các điện tích khác nhau tạo ra
Để tính điện trường tại một điểm _P_ do một số hữu hạn điện tích điểm gây ra thì ta lần lượt áp dụng công thức (23.5) cho mỗi điện tích điểm _q_ i rồi lấy tổng vec-tơ các điện trường thành phần này:
**E** = _ke_

∑ _qi_

![](images/image42.png) _i_

**r** ˆ _i_
(23.6)

Trắc nghiệm nhanh 23.4:

Một điện tích +3 μC được đặt tại điểm _P_ thì nó chịu tác dụng bởi một lực điện từ bên ngoài, hướng sang phải và có độ lớn 4 × 106 N/C. Nếu thay điện tích này bằng một điện tích −3 μC thì lực điện tác dụng lên điện tích này sẽ thế nào? (a) Không bị ảnh hưởng gì;
(b) Đổi hướng; (c) Lực bị thay đổi theo một cách không thể xác định được.
**Bài toán mẫu 23.5:** Một giọt nước nhỏ có khối lượng 3,00 × 10−12 kg nằm gần mặt đất, trong không khí vào một ngày mưa bão. Một điện trường trong khí quyển có hướng thẳng đứng từ trên xuống và có độ lớn là 6,00 × 103 N/C trong vùng có giọt nước. Giọt nước nằm lơ lửng trong không khí. Hỏi điện tích của giọt nước là bao nhiêu?
_**Khái niệm hóa:**_ Hình ảnh một giọt nước nằm lơ lửng trong không khí là không bình thường. Vậy phải có cái gì đó kéo giọt nước lên để nó không rơi xuống.
_**Phân loại:**_ Bài toán này thuộc dạng bài toán cân bằng của hạt trong điện trường và trong trường hấp dẫn.
_**Phân tích:**_ Từ điều kiện cân bằng của giọt nước ta có lực điện tác dụng vào giọt
nước cùng phương, ngược chiều với trọng lực tác dụng lên nó: _F e_ = _mg_ . Từ đó,
ta tìm được độ lớn của điện tích là:
_q_ = _mg_ . Do điện trường hướng thẳng đứng

##### E

##### 

xuống dưới và lực điện hướng lên trên nên điện tích của giọt nước là âm.
_**Đáp số**_ : _q_ = −4,90 × 10−15 C
![](images/image43.jpeg) **Bài toán mẫu 23.6:** Điện trường do hai hạt mang điện tạo ra
Hai điện tích _q_ 1 và _q_ 2 được đặt trên trục _x_ và lần lượt cách trục một khoảng là _a_ và _b_. (A) Tìm các thành phần của điện trường tổng hợp tại điểm _P_ nằm tại vị trí (0, _y_ ).

  2. Xét trường hợp đặc biệt khi các điện tích này cùng độ lớn và _a_ = _b_.

  3. Xét trường hợp _P_ nằm rất xa gốc tọa độ, tức là y >> a. Giải:


_**Khái niệm hóa**_ : Trong bài toán này, điện trường tổng hợp do hai điện tích điểm tạo ra ở _P_ là tổng vec-tơ của điện trường do mỗi điện tích tạo ra.
_**Phân loại**_ : Đây là bài toán mà ta sử dụng công thức (23.6) để giải.

Phân tích:

Hình 23.12

  1. Điện trường do _q_ 1 và _q_ 2 gây ra tại _P_ được chỉ ra trong hình 23.12. Độ lớn của chúng lần lượt là:


_E_ 1 = _ke_
= _k q_ 1
_e a_2 \+ _y_ 2
_E_ 2 = _ke_
= _k q_ 2
_e b_2 \+ _x_ 2
Biểu diễn các điện trường này dưới dạng vec-tơ:
**E** 1 = _k_
_q_ 1

![](images/image44.png) _e a_2 \+ _y_ 2

cosΦ
ˆ **i +** _k_
_q_ 1

_e a_2 \+ _y_ 2

sinΦ ˆ **j** ;
**E** 2 = _k_
_q_ 2

![](images/image45.png) _e b_2 \+ _y_ 2

cos _θ_ ˆ **i** − _k_
_q_ 2

_e b_2 \+ _y_ 2

sin _θ_ ˆ **j**
Từ đó tìm được các thành phần của điện trường tổng hợp:
_E_ = _k q_ 1 cosΦ **+** _k q_ 2 cos _θ_

  24. _e a_ 2 + _y_ 2


_e b_2 \+ _y_ 2
_E_ = _k q_ 1 sinΦ − _k q_ 2 sin _θ_

  25. _e a_ 2 + _y_ 2


_e b_2 \+ _y_ 2

  1. Trong trường hợp hai điện tích bằng nhau về độ lớn và _a_ = _b_ thì các kết quả trên sẽ trở thành:


_Ex_ = _ke a_ 2 + _y_ 2 cos _θ_ = _ke_ ( _a_ 2 + _y_ 2 )3/ 2 và _Ey_ = 0

  2. Nếu y >> a thì kết quả trên sẽ là:


_Ex_ ≈ _ke y_ 3
trong đó tích phân được lấy trên toàn bộ phân bố điện. Tích phân này là một phép toán vec-tơ nên phải có cách tính phù hợp. Ta phải tính theo các thành phần tọa độ của hệ trục tọa độ không gian tương ứng với phân bố điện.
Các phân bố điện thường gặp là phân bố theo một đường, phân bố theo mặt và phân bố theo khối. Để thuận tiện trong tính toán, ta thường sử dụng khái niệm _mật độ điện tích_. Giả sử điện tích được _phân bố đều (đồng nhất)_ thì:

  * Đối với phân bố theo khối: Đơn vị của ρ là C/m3.

  * Đối với phân bố theo mặt:


Đơn vị của σ là C/m2.
_ρ_ ≡ _Q_ ; tỉ số giữa tổng điện tích và thể tích của vật.

##### V

_σ_ ≡ _Q_ ; tỉ số giữa tổng điện tích và diện tích của vật.

##### A

##### 

  * ![](images/image46.png)Đối với phân bố theo đường: _λ_ ≡ _Q_ ; tỉ số giữa tổng điện tích và độ dài của vật Đơn vị của λ là C/m.


Nếu phân bố điện không đều (đồng nhất) thì điện lượng của một vi phân thể tích, diện tích
và độ dài sẽ lần lượt là:

##### ![](images/image47.png)dq = ρdV dq = σdA dq = λd

##### 

Chiến lược giải toán

  1. _**Khái niệm hóa**_ : Thiết lập một hình ảnh trong đầu về bài toán: suy nghĩ về các điện tích riêng biệt hoặc một phân bố điện và tưởng tượng về dạng điện trường mà chúng có thể tạo ra. Xem xét tính đối xứng của các hệ điện tích để hình dung về điện trường.

  2. _**Phân loại**_ : Bài toán đề cập đến hệ điện tích điểm rời rạc hay một phân bố điện liên tục? Tìm được câu trả lời cho câu hỏi này thì ta sẽ biết cách làm tiếp theo trong phần phân tích.


Phân tích

  1. Nếu là một nhóm các điện tích riêng lẻ: Sử dụng nguyên lý chồng chất, tìm các điện trường do những điện tích riêng gây ra tại điểm khảo sát, rồi cộng chúng lại như các vec-tơ để tìm ra điện trường tổng hợp. Chú ý số lượng các vec-tơ.

  2. Nếu là một phân bố điện tích liên tục: Tổng vec-tơ để đánh giá điện trường tổng hợp tại một điểm phải được thay thế bằng tích phân vec-tơ. Chia phân bố điện tích thành nhiều phần tử nhỏ, tính vec-tơ tổng bằng cách lấy tích phân trên toàn bộ miền phân bố điện tích đó.


Lưu ý về tính đối xứng của hệ điện tích để đơn giản hóa tính toán. Sự khử của các thành phần điện trường trong bài toán mẫu 23.8 là một minh họa cho việc áp dụng tính đối xứng.

Biện luận

  * Kiểm tra xem biểu thức của điện trường có phù hợp với hình dung ban đầu hay không và có phản ánh tính đối xứng mà ta đã lưu ý trước đó không.

  * Hình dung sự thay đổi các thông số để xem kết quả tính toán có thay đổi một cách hợp lý hay không.


![](images/image48.jpeg) **Bài toán mẫu 23.9:** Điện trường của một đĩa tròn tích điện đều
Một đĩa tròn bán kính _R_ với mật độ điện tích s. Hãy tính điện trường tại một điểm _P_ nằm trên trục của đĩa và cách tâm đĩa một khoảng _x_ (hình 23.16).

Giải:

_**Khái niệm hóa:**_ Nếu xem đĩa như là một tập hợp các vòng tròn xếp kề nhau thì ta có thể sử dụng kết quả của bài toán mẫu 23.8 – điện trường do một vòng tròn bán kính _a_ tạo ra – và tính tổng đối với tất cả các vòng tạo nên đĩa.
**_Phân loại_ :** Vì đĩa là một vật liên tục nên ta phải tìm điện trường đối với một phân bố liên tục.
**_Phân tích_ :** Trước tiên, cần tìm điện tích _dq_ của một phần diện tích có dạng một vành tròn có bán kính trong là _r_ và bề rộng _dr_ như trong hình 23.16:
_dq_ = _σ dA_ = _σ_ (2 _π r dr_ ) = 2 _π σ r dr_ **.**

## ![](images/image49.png) ĐƯỜNG SỨC ĐIỆN TRƯỜNG

Trong các phần trước ta đã định nghĩa điện trường bằng biểu diễn toán học với phương trình (23.3). Bây giờ ta sẽ tìm cách trực quan hóa điện trường bởi một biểu diễn bằng hình ảnh. Một cách thuận tiện để trực quan hóa các mẫu điện trường là vẽ các đường gọi là đường sức điện trường (được Faraday giới thiệu đầu tiên). Đường sức điện trường có một số tính chất sau:
\+ Vec-tơ điện trường tiếp tuyến với đường sức điện trường tại mỗi điểm. Hướng của đường sức cùng hướng với vec-tơ điện trường.
\+ Số đường sức đi qua một đơn vị diện tích bề mặt vuông góc với các đường sức tỉ lệ thuận với độ lớn của điện trường trong khu vực đó. Nếu các đường sức nằm sát nhau thì ở đó điện trường mạnh, nếu các đường sức nằm xa nhau thì điện trường ở đó yếu.
Các tính chất này được thể hiện trên hình 23.17. Mật độ của các đường sức đi qua mặt A lớn hơn mật độ của các đường sức đi qua mặt B. Do đó, điện trường ở mặt A lớn hơn ở mặt B. Ngoài ra, vì các đường sức ở các vị trí khác nhau có hướng khác nhau nên điện trường này là không đều.
Ta có thể kiểm chứng được rằng mối quan hệ giữa cường độ điện trường với mật độ của đường sức là phù
![](images/image50.png)

Hình 23.17

hợp với công thức (23.5) (công thức tìm điện trường từ định luật Coulomb).
Hình 23.18 cho thấy các đường sức biểu diễn cho điện trường của điện tích điểm trong không gian 2 chiều. Các đường sức này là các đường xuyên tâm, xuất phát từ điện tích điểm. Nếu điện tích là dương thì các đường sức hướng ra xa điện tích. Nếu điện tích là âm thì các đường sức hướng ra xa điện tích. Trong cả hai trường hợp, đường sức là dài vô hạn.

![](images/image51.jpeg)

Hình 23.18 Dưới đây là một số qui tắc để vẽ đường sức:
\+ Đường sức phải xuất phát từ điện tích dương và kết thúc ở điện tích âm. Trong
trường hợp số điện tích âm và dương khác nhau thì một số đường có thể xuất phát hoặc kết thúc ở rất xa.
\+ Số đường sức đi vào hoặc ra khỏi một điện tích tỉ lệ với độ lớn của điện tích đó.
\+ Các đường sức không được cắt nhau.
Hình 23.19 cho thấy các đường sức đối với hệ hai điện tích điểm cùng độ lớn nhưng trái dấu (a); hai điện tích điểm dương, cùng độ lớn (b) và hệ gồm hai điện tích 2 _q_ và – _q_

  3. Hệ gồm hai điện tích điểm cùng độ lớn nhưng trái dấu được gọi là một lưỡng cực điện.


.

![](images/image52.jpeg)

Hình 23.19: Đường sức điện trường của các hệ điện tích điểm khác nhau
Trắc nghiệm nhanh 23.5: Trong hình 23.19, hãy xếp hạng độ lớn điện trường tại các điểm
_A_ , _B_ và _C_ theo thứ tự giảm dần.

## ![](images/image55.png) Chuyển động của hạt mang điện trong điện trường đều

Khi một hạt mang điện được đặt trong một điện trường, nó sẽ chịu một lực điện. Nếu đây là lực duy nhất đặt trên hạt mang điện thì nó chính là lực tổng hợp. Lực này sẽ gây ra gia tốc cho hạt theo định luật II Newton. Do đó
![](images/image57.png)![](images/image59.png)![](images/image60.png)![](images/image62.png) **F** _e_ = _q_ **E** = _m_ **a** , tức là:

##### m

(23.8)
Nếu điện trường là đều (có độ lớn và hướng không đổi) và hạt chuyển động tự do thì lực tác dụng lên hạt là không đổi. Ta có thể áp dụng mô hình hạt chuyển động với gia tốc không đổi đối với chuyển động của hạt mang điện. Nghĩa là trong trường hợp này, có thể dùng 3 mô hình cho chuyển động của hạt trong điện trường đều: hạt chuyển động trong một trường lực, hạt chuyển động dưới tác dụng của lực tổng hợp và hạt chuyển động với gia tốc không đổi.
Nếu hạt mang điện tích dương, gia tốc của nó hướng theo điện trường. Nếu hạt mang điện tích âm, gia tốc của nó ngược chiều với điện trường.
**Bài toán mẫu 23.10:** Electron trong điện trường đều
![](images/image63.png)Một điện trường đều **E** giữa hai bản tích điện đặt song song cách nhau một khoảng _d_ có hướng dọc theo trục _x_ như trong hình 23.20. Một hạt mang điện dương _q_ và có khối lượng _m_ được thả không vận tốc đầu tại điểm _A_ gần bản dương và chuyển động nhanh dần về điểm _B_ gần bản âm.

  1. Hãy tìm tốc độ của hạt tại _B_ bằng cách xem hạt mang điện như là một hạt chuyển động với gia tốc không đổi.


![](images/image65.png)Giải:

_**Khái niệm hóa:**_ Khi hạt mang điện dương ở tại điểm _A_ , nó chịu tác dụng của lực điện hướng sang phải (cùng chiều với điện trường). Kết quả là nó sẽ chuyển động nhanh dần về _B_.
_**Phân loại**_ : Có thể mô hình hóa chuyển động của hạt như là hạt chuyển động với gia tốc không đổi.
_**Phân tích**_ : Dùng phương trình của hạt chuyển động với gia tốc không đổi thể hiện quan hệ giữa tốc độ, gia tốc và vị trí của hạt:
_v_ 2 = _v_ 2 \+ 2 _a_ ( _x_ − _x_ ) = 2 _a d_
_f f f i_
Ta tìm được
Hình 23.20
_vf_ = = =

  2. Tìm tốc độ của hạt mang điện tại _B_ bằng cách xem hạt như là một hệ không cô lập theo phương pháp năng lượng


_**Phân loại**_ : Phát biểu của bài toán cho ta biết rằng hạt mang điện là một hệ _không cô lập về năng lượng_. Lực điện sẽ thực hiện công lên hệ. Năng lượng được truyền vào hệ bởi công do lực điện tác dụng lên hạt. Cấu hình ban đầu của hệ là khi hạt ở trạng thái đứng yên tại _A_ và cấu hình cuối của hệ là khi hạt có tốc độ nào đó tại _B_.
_**Phân tích**_ : Viết phương trình của định lý công – động năng: _W_ = ∆ _K_
Thay biểu thức của công và động năng ứng với các vị trí _A_ và _B_ :
_F d_ = 1 _mv2_ . Từ đó tìm ra kết quả đã có ở phần A).
_e_ 2 _f_

# Public_145

Điện trường đã được nghiên cứu về phương diện tác dụng lực trong các chương trước. Trong chương này, điện trường sẽ được khảo sát ở khía cạnh năng lượng. Bằng cách tiếp cận theo hướng năng lượng, các bài toán có thể được giải theo hướng không cần đến việc sử dụng lực. Khái niệm về thế năng có giá trị lớn trong
các nghiên cứu về điện. Do lực tĩnh điện là lực bảo toàn, hiện tượng tĩnh điện có thể được mô tả một cách dễ dàng dưới dạng năng lượng điện thế.

## ![](images/image1.png) Điện thế và hiệu điện thế

![](images/image2.png)![](images/image4.png)Khi một điện tích _q_ đặt trong điện trường nó sẽ chịu tác dụng một lực bằng
Đây là lực bảo toàn bởi vì theo bản chất, các tương tác đều tuân theo định luật Coulomb. Hãy xem xét dưới góc độ một hệ kín các điện tích, khi điện tích _q_ chuyển động chỉ dưới tác dụng
![](images/image6.png)của các điện tích còn lại. Với một chuyển dời vô cùng bé trường lực thế Coulomb sinh
![](images/image8.png)một công bằng Trong cơ học ta biết rằng, công do trường lực thế sinh ra bằng đúng độ
suy giảm thế năng, cho nên:

![](images/image10.png)− _dU_ =

Khi điện tích _q_ di chuyển từ vị trí A đến vị trí B trong điện trường, độ biến thiên thế năng bằng:
![](images/image12.png)( _B_ )
∆ _U_ = − ∫
( _A_ ) ( _A_ )

(25.1)

Ở đây tích phân đường tính dọc theo quỹ đạo di chuyển của điện tích _q_ từ A đến B. Tuy nhiên vì trường lực bảo toàn nên dù đi theo con đường nào, giá trị của tích phân này cũng không thay đổi.
Khi đã có biểu thức tính độ biến thiên thế năng, chỉ cần chọn một điểm O nào đó làm gốc thế năng ( _U_ = 0 ), ta đã có thể tính _**thế năng**_ của điện tích đặt trong điện trường:

![](images/image13.png)(P)

_U_ = − _q_ ∫

(O) (P)
![](images/image15.png) _Thế năng của điện tích q tại vị trí P bất kì trong điện trường có trị số bằng công của lực điện trường làm di chuyển điện tích q đó từ P về gốc thế năng_.
Thế năng tại vị trí P của một đơn vị điện tích trong điện trường tại điểm đó:
được gọi là _**điện thế**_

_V_ = _U_

_q_

(P)
![](images/image17.png)= − ∫
(O) (P)

(25.2)

_Điện thế tại vị trí P bất kì trong điện trường có trị số bằng công của lực điện trường làm di chuyển điện tích 1 Coulomb từ P về gốc điện thế (gốc thế năng)_.
Tương tự như độ biến thiên thế năng ∆ _U_ ta cũng có khái niệm _**hiệu điện thế**_ giữa hai điểm B và A:
![](images/image19.png)( _B_ )
∆ _V_ = _VB_ − _VA_ = − ∫ (25.3)
( _A_ )
Từ (25.1) và (25.3), ta có mối liên hệ giữa độ biến thiên thế năng và hiệu điện thế:

∆ _U_ = _q_ ∆ _V_ (25.4)

Theo định luật bảo toàn năng lượng: ∆ _U_ \+ ∆ _K_ = 0, suy ra động năng mà điện tích _q_ thu

được khi di chuyển từ điểm A đến điểm B nói trên bằng độ suy giảm của thế năng:
∆ _K_ = −∆ _U_ = − _q_ ∆ _V_ = _q_ ( _VA_ − _VB_ )
Điện thế và hiệu điện thế có thứ nguyên của năng lượng trên một đơn vị điện tích, được gán cho một đơn vị đặc biệt trong hệ SI – _**Volt**_ : 1V = 1J/C.
Mối liên hệ (25.2), (25.3) cũng cho ta một đơn vị khác của cường độ điện trường là V/m: 1N/C = 1V/m.
![](images/image21.png)Khi một electron mang điện tích nguyên tố − _e_ chuyển động dưới tác dụng của điện trường, đi qua đoạn đường có hiệu điện thế bằng 1V, ta nói rằng electron đã thu được thêm động năng bằng 1 _**electron-volt**_ :
1 _eV_ = 1,6×10−19 _C_ ⋅1 _V_ = 1,6×10−19 _J_
(25.5)
_**Câu hỏi 25.1:**_ Hai điểm A và B nằm trong một điện trường như hình 25.1. (i) Hiệu điện thế ∆ _V_ = _VB_ − _VA_ có giá trị như thế nào?
(a) dương (b) âm (c) bằng không. (ii) Một điện tích âm ban đầu nằm tại A, sau đó di chuyển đến vị trí B. Sự biến thiên của thế
năng ∆ _U_ có giá trị như thế nào? Lựa chọn trong các khả năng như phần trước.

## ![](images/image23.png) Hiệu điện thế trong điện trường đều

_Hình 25.1: Hai điện tích_
_điểm trong điện trường_
Ta tiến hành khảo sát một điện trường đều, theo đó các đường sức điện trường hướng song song và đều đặn như miêu tả trên hình 25.2a. Từ phương trình (25.3) suy ra được hiệu điện thế giữa hai điểm A và B nằm trên cùng một đường sức điện trường:
![](images/image24.png)
_Hình 25.2: (a) Hạt mang điện tích q chuyển động dọc theo đường sức điện trường đều (b) Hạt khối lượng m rơi trong trường trọng lực đều._

_B A_

( _B_ )

![](images/image25.png)∫
∆ _V_ = _V_ − _V_
= − _E_ ⋅ _ds_ ⋅ cos(00 ) = −
( _A_ ) ( _A_ ) ( _A_ )

_E_ ⋅ _ds_

Trong điện trường đều _E_ có độ lớn không đổi nên có thể đưa ra ngoài dấu tích phân:
( _B_ )
∆ _V_ = − _E_ ∫ _ds_
( _A_ )
∆ _V_ = − _Ed_
(25.6)
Dấu “–“ ở đây nói rằng, điện thế tại B thấp hơn điện thế tại A:
_sức điện trường luôn hướng theo chiều suy giảm của điện thế_.
_VB_ < _VA_. Như vậy, _các đường_
Khi một điện tích _q_ di chuyển từ A đến B, thế năng của hạt trong điện trường thay đổi một lượng bằng

∆ _U_ = _q_ ∆ _V_ = − _qEd_

(25.7)

Có nghĩa nếu hạt mang điện tích dương:
_q_ > 0,
thế năng sẽ giảm:
∆ _U_ < 0.
Nói cách khác,
khi một điện tích dương di chuyển xuôi theo chiều của đường sức điện trường, thế năng của nó sẽ giảm. Như hình 25.2a miêu tả, nếu ban đầu hạt mang điện tích dương _q_ thả tự do từ
![](images/image26.png)trạng thái đứng yên, nó sẽ chịu tác dụng một lực hướng xuống dưới, bắt đầu đi xuống
và tăng tốc. Hạt dần thu động năng từ chính sự suy giảm của thế năng. Đó là minh chứng rõ ràng cho định luật bảo toàn năng lượng.
Hình 25.2b miêu tả hình ảnh tương tự, khi một hạt khối lượng _m_ rơi tự do trong trường hấp dẫn gần mặt đất. Hạt cũng chịu tác dụng của trọng lực hướng xuống và tăng tốc. Động năng tích luỹ tự sự suy giảm của thế năng trọng trường.
Phép so sánh nói trên giữa hạt mang điện tích dương trong điện trường với hạt chuyển động dưới trường trọng lực rất hữu ích cho việc hình dung về các hiện tượng tĩnh điện. Chỉ
một điểm lưu ý rằng: khối lượng thì luôn dương, nhưng điện tích có thể dương, cũng có thể âm.
Với trường hợp điện tích âm, khi hạt di chuyển theo chiều của đường sức điện trường, thế năng của hạt sẽ tăng, thay vì giảm. Nếu ban đầu hạt đứng yên, nó sẽ tăng tốc về phía ngược chiều của đường sức.
![](images/image28.png)Ta khảo sát trường hợp tổng quát hơn, khi hạt mang điện tích di chuyển từ vị trí A đến vị trí B trong điện trường đều, nhưng không nằm trên cùng một đường sức như hình 25.3. Lúc này hiệu điện thế giữa A và B bằng:
![](images/image30.png)( _B_ )
∆ _V_ = _VB_ − _VA_ = − ∫
( _A_ ) ( _A_ )
(25.8)
![](images/image15.png)Ở đây vector của điện trường đều có thể đưa ra ngoài dấu
tích phân. Độ biến thiên của thế năng:
![](images/image31.png)∆ _U_ = _q_ ∆ _V_ = − _qE_ ⋅ _s_
Tích vô hướng (25.8) có thể tính qua hình học:
∆ _V_ = _VB_ − _VA_ = − _Ed_
(25.9)
Mặt khác hiệu điện thế giữa hai điểm A và C nằm trên cùng một đường sức:
_Hình 25.3: Hạt mang điện tích chuyển động không_

_V_ − _V_

= − _Ed_
_song song với đường sức_
_C A của điện trường đều_
Từ đây suy ra rằng _VB_ = _VC_ . Tổng quát lên có thể thấy rằng,
_mọi điểm nằm trên cùng một mặt phẳng vuông góc với đường sức điện trường đều có cùng một điện thế_. Ta gọi mặt phẳng chứa tất cả các điểm có cùng điện thế như vậy là một _**mặt đẳng thế**_. Đối với điện trường đều, họ các mặt đẳng thế cấu thành từ những mặt phẳng song song với nhau và cùng vuông góc với các đường sức điện trường.

![](images/image32.jpeg)

_Hình 25.4: Các mặt đẳng thế_
_**Câu hỏi 25.2:**_ Các điểm được đánh dấu trên hình 25.4 nằm trên các mặt đẳng thế. Hãy sắp xếp công thực hiện của điện trường lên một điện tích dương theo thứ tự giảm dần, khi điện tích này di chuyển từ A sang B, từ B sang C, từ C sang D và từ D sang E.

### ![](images/image33.jpeg)Bài tập mẫu 25.1: Điện trường giữa hai bản phẳng song song tích điện trái dấu

Một ắc-quy hiệu điện thế 12V mắc vào hai bản phẳng đặt song song như hình 25.5. Khoảng cách giữa hai
bản _d_ = 0,3cm, đủ nhỏ để xem rằng điện trường giữa
hai bản là đều. Tính cường độ điện trường giữa hai bản phẳng.

### Giải:

Dùng công thức (25.6), có thể tính cường độ điện trường giữa hai bản phẳng song song:
_Hình 25.5: Hai bản phẳng song song nối vào nguồn điện_
_E_ = =

_d_

12 _V_
0,3×10−2 _m_
= 4×103 _V_ / _m_

### Bài tập mẫu 25.2: Chuyển động của hạt proton trong điện trường đều

![](images/image34.png)Một proton được thả ra từ trạng thái đứng yên tại vị trí A trong một điện trường đều có độ lớn 8,0 ×104 V/m (hình 25.6). Proton di chuyển đến
điểm B cách đó một đoạn _d_ = 0,50 m dọc theo
![](images/image35.png)hướng của điện trường _E_ . Tìm tốc độ của proton sau đoạn đường đó.

### Giải:

**Khái niệm.** Hình dung rằng hạt proton rơi xuống tựa như đang ở trong một trường trọng lực. Trong bài tập này, hạt cũng chịu tác dụng một gia tốc không đổi bởi lực điện trường.
**Phân loại.** Do hệ không tương tác với bên ngoài nên ta có thể quy vấn đề về chủ đề bảo toàn năng lượng.
_Hình 25.6: Proton tăng tốc theo hướng của điện trường_
**Phân tích.** Áp dụng định luật bảo toàn năng lượng cho điểm A và điểm B:
∆ _K_ \+ ∆ _U_ = 0
Thế biểu thức của động năng và thế năng tại A và B tương ứng:
 1 _mv_ 2 − 0  + _e_ ∆ _V_ = 0
 2 
 
Từ đó suy ra vận tốc _v_ đồng thời tính ∆ _V_ theo công thức (25.6):
_v_ = = =
=
= 2,8 ×106 _m_ / _s_
**Nhận định.** Điện thế giảm theo chiều chuyển động của proton, ∆ _V_ < 0, kéo theo sự suy giảm của thế năng: ∆ _U_ < 0\. Để cân bằng sự suy giảm này, proton lại tích luỹ động năng trong chuyển động có gia tốc, tuân theo định luật bảo toàn năng lượng.

## ![](images/image36.png) Điện thế và thế năng tạo bởi điện tích điểm

![](images/image37.jpeg)Từ trình bày ở chương 23, ta đã biết rằng một điện
tích điểm _q_ > 0 tạo ra trong không gian xung quanh một
điện trường đối xứng xuyên tâm với những đường sức hướng ra ngoài. Hiệu điện thế giữa hai điểm A và B bất kì (hình 25.7) có thể tính theo công thức (25.3):
![](images/image38.png)( _B_ )
_VB_ − _VA_ = − ∫
![](images/image15.png)( _A_ )
Vector cường độ điện trường điện tích điểm có dạng
đối với điện trường của
![](images/image39.png)
Thế vào thu được
![](images/image40.png) _VB_ − _VA_ = −

( _A_ )

_Hình 25.7: Tính hiệu điện thế giữa hai điểm bất kì trong điện trường đối xứng xuyên tâm_
Lưu ý rằng gốc thế năng lấy ở trạng thái hai điện tích cách xa nhau vô cùng. Nếu _q_ 1, _q_ 2 cùng
dấu, chúng có sức mạnh đẩy nhau ra xa nhất có thể, chứng tỏ hệ có mang năng lượng _U_ > 0.
Ngược lại nếu _q_ 1, _q_ 2 trái dấu, cần phải bổ sung một năng lượng nhờ một lực bên ngoài mới
tách chúng ra xa được, chứng tỏ hệ mang năng lượng âm. Nếu biện luận theo hướng cho rằng
điện tích _q_ 1 nằm trong điện trường do _q_ 2 tạo ra, ta cũng đi đến kết quả như (25.13).

## ![](images/image42.png) Mối liên hệ giữa điện trường và điện thế

Công thức (25.3) viết lại dưới dạng vi phân

![](images/image44.png) _dV_ = − _E_ ⋅ _ds_

cho ta giá trị của hiệu điện thế nếu biết trước điện trường

(25.15)

![](images/image15.png)tại các điểm trong không gian.

Có nghĩa _thành phần Ex của vector cường độ điện trường bằng đạo hàm riêng của điện thế_
_theo biến x đảo dấu_. Ta cũng thu được kết luận tương tự đối với thành phần theo _y_ và _z_ ,
viết thành bộ đầy đủ:

_E_ = − ∂ _V_ , _E_

_x_ ∂ _x y_

= − ∂ _V_ , _E_
![](images/image46.png)∂ _y z_
= − ∂ _V_

∂ _z_

(25.16)
![](images/image15.png)Hình chiếu của vector tự như thế:
theo hướng của vector _l_ bất kì cũng được tính theo cách tương
_E_ =− _dV_
_l dl_
![](images/image15.png)![](images/image15.png)Xét hai điểm lân cận nằm trên cùng một mặt đẳng thế, hiệu điện thế giữa hai điểm này:
_dV_ = 0. Do vậy, hình chiếu của vector
theo phương tiếp tuyến với mặt đẳng thế cũng bằng
không. Nói cách khác, _vector cường độ điện trường thế_.
_luôn hướng vuông góc với mặt đẳng_
Hình 25.11 miêu tả họ các mặt đẳng thế trong các trường hợp khác nhau: điện trường đều, điện trường sinh ra bởi điện tích điểm và điện trường tạo bởi lưỡng cực điện. Trong tất cả các trường hợp, các mặt đẳng thế luôn vuông góc với những đường sức điện trường tại giao điểm:

  * Trên mục 25.2 ta đã phân tích được rằng, họ các mặt đẳng thế trong điện trường đều là những mặt phẳng song song, cố nhiên vuông góc với đường sức điện trường.

  * Ở mục 25.3 ta cũng làm sáng tỏ rằng, điện thế tạo bởi điện tích điểm chỉ phụ thuộc vào khoảng cách đến điện tích điểm, nên họ các mặt đẳng thế là những mặt cầu, giao nhau vuông góc với đường sức đối xứng xuyên tâm.


![](images/image47.jpeg)

_Hình 25.11: Họ các mặt đẳng thế trong các trường hợp: (a) điện trường đều (b) điện trường của điện tích điểm (c) điện trường tạo bởi lưỡng cực điện_
![](images/image15.png)Hãy thử suy vector (25.11):
của điện trường tạo bởi điện tích điểm từ biểu thức của điện thế

## ![](images/image48.png) Điện thế sinh ra bởi sự phân bố điện tích liên tục

Ở mục 25.3, chúng ta tính được điện thế sinh ra bởi tập hợp các điện tích điểm rời rạc. Mục này trình bày phương pháp tính điện thế sinh ra bởi sự phân bố điện tích liên tục, tức vật tích điện có kích thước đáng kể. Có hai phương pháp tiến hành: phương pháp chia nhỏ và phương pháp dùng định lý Gauss.

### Phương pháp chia nhỏ

Ta chia vật tích điện có kích thước lớn nói trên thành những phần rất nhỏ, nhỏ đến mức có thể xem mỗi phần như thế là một điện tích điểm. Đối với mỗi điện tích điểm vừa cắt ra ấy, ta đã có thể áp dụng công thức (25.11) để tính điện thế _dV_ do nó tạo ra tại điểm P cần khảo sát:

![](images/image49.jpeg)

_Hình 25.12: Tính điện thế sinh ra bởi sự phân bố_

_dq_

_dV ke r_

(25.18)
_điện tích liên tục_
trong đó _r_ là khoảng cách từ phần nhỏ đang xét đến điểm P. Điện thế do vật sinh ra tại điểm P là sự tổng hợp của tất cả các phần nhỏ trên toàn bộ vật tích điện:

_V_ = ∑ _dV_ =

∫ _dV_ = _ke_ ∫

__dq_ r_

(25.19)

_**Cần lưu ý ở phương pháp này rằng: gốc lấy điện thế**_ ( _V_ = 0) _**nằm ở xa vô cùng**_ (∞).

### Phương pháp dùng định lý Gauss

![](images/image15.png)Đối với những hệ tích điện mang tính đối xứng, ta có thể dùng định lý Gauss để tính điện
trường trước. Sau đó dùng công thức () để tính điện thế:
![](images/image50.png)(O)

_V_ = ∫

(P)
trong đó gốc lấy điện thế ( _V_ = 0)
có thể quy ước tại một điểm O nào đó.

### ![](images/image51.jpeg)Bài tập mẫu 25.4: Điện thế tạo bởi vành tròn tích điện đều

  1. Tìm biểu thức của điện thế tại điểm P nằm trên trục đối xứng của một vành tròn bán kính _a_ với điện tích _Q_ phân bố đều, cách tâm vành tròn một


đoạn _x_.

### Giải:

Chia vành tròn ra rất nhiều phần nhỏ, mỗi phần có điện tích _dq_ nhỏ đến mức có thể xem như điện tích điểm. Áp dụng công thức (20.20), ta có thể tính điện thế tại điểm P:
_Hình 25.13: Tính điện thế tại điểm nằm trên trục của vành tròn tích điện đều_
_V_ = _ke_ ∫ _r_
Để ý rằng điểm P nằm cách đều tất cả các phần của vành tròn, do vậy tích phân trên dễ dàng chuyển thành:
_V_ = _ke dq r_
Tích phân trên thể hiện tổng toàn bộ điện tích chứa trên vành. Còn khoảng cách _r_ có
thể biểu diễn thành _r_ =
_V_ = _keQ_

  2. Tìm biểu thức của cường độ điện trường tại P.


### Giải:

Do tính chất đối xứng, có thể kết luận rằng vector cường độ điện trường
![](images/image15.png)tại điểm P
![](images/image15.png)phải hướng dọc theo trục x. Nói cách khác _E_ chỉ có thành phần theo (25.16) giữa cường độ điện trường và thế năng:
_x_. Từ mối liên hệ
_E_ = − _dV_
= − _k Q d_  1  =
_ke x Q_
_x dx_

_e_  

 

( _a_ 2 + _x_ 2 )3/2

### ![](images/image52.jpeg)Bài tập mẫu 25.5: Điện thế tạo bởi thanh tích điện đều

Một thanh có chiều dài _l_ đặt dọc theo trục _x_ như hình vẽ.
Thanh có điện tích _Q_ phân bố đều với mật độ dài λ. Tính
điện thế tại điểm P nằm trên trục _y_ cách đầu thanh một
đoạn bằng _a_.

### Giải:

Điện thế tại P được tạo bởi các phần điện tích phân bố khắp chiều dài thanh. Xét một đoạn _dx_ rất nhỏ trên thanh, mang
điện tích _dq_ = λ _dx_ đủ nhỏ để có thể xem như điện tích điểm.
Điện thế do điện tích điểm _dq_ nói trên tạo ra tại P:
_Hình 25.14: Tính điện thế tạo bởi thanh tích_
_dV_ = _ke_
_dq_ = _k r e_
λ _dx_

_điện đều_

Điện thế do rất nhiều điện tích điểm như thế trên toàn bộ thanh tạo ra tại P là tích phân:
_l_
_V_ = ∫ _ke_
0
λ _dx_
Theo đó cận tích phân lấy từ
_x_ = 0 cho đến
_x_ = _l_.
Để ý rằng

_l_

_ke_ và λ = _Q_ / _l_
_dx Q_
là những số không đổi, có thể cho ra ngoài dấu tích phân:
_l_
_V_ = _ke_ λ ∫

0

= _ke a_ 2 \+ _x_ 2
ln(x+
_l_
_a_ 2 \+ _x_ 2 )
0
= __Q__  _l_ \+ _a_ 2 \+ _l_ 2 
_ke l_ ln  _a_ 
 

## ![](images/image53.png) Điện thế tạo bởi vật dẫn tích điện

Từ chương 24, ta biết rằng đối với _vật dẫn điện ở trạng thái cân bằng, điện tích chỉ phân bố trên bề mặt vật dẫn_. Ngoài ra ta cũng biết rằng, _điện trường chỉ tồn tại bên ngoài vật dẫn và vuông góc với bề mặt vật dẫn. Bên trong vật dẫn điện trường hoàn toàn bị triệt tiêu_.
Chương này ta tiếp tục bàn đến vật dẫn điện về phương diện điện thế. Áp dụng công thức (25.3) cho hai điểm A và B bất kì nằm trong hoặc trên bề mặt vật dẫn, ta có:
![](images/image54.png)( _B_ )

_VB_ − _VA_ = − ∫

( _A_ )
Như vậy _mọi điểm thuộc vật dẫn đều có điện thế bằng nhau_.
![](images/image55.jpeg)Hình 25.15 miêu tả điện thế tại các điểm bên trong và bên ngoài quả cầu làm bằng vật liệu dẫn điện. Theo trình bày ở chương 24, việc áp dụng định lý Gauss cho ra kết quả rằng: điện trường bên ngoài quả cầu tích điện có dạng y hệt như điện trường tạo bởi điện tích điểm:

_E_ = _k_

_q_

_e r_ 2

Do đó điện thế tại một điểm bất kì nằm ngoài quả cầu cũng sẽ có dạng như điện thế sinh ra bởi điện tích điểm đặt tại tâm quả cầu:
_V_ = _k q_
_e r_
Từ đó suy ra điện thế ngay trên bề mặt quả cầu tích điện:

_V_ = _k q_

_e R_

(25.20)

với _R_ là bán kính quả cầu. Trong trường hợp quả cầu làm bằng vật liệu dẫn điện, biểu thức (25.20) cũng chính là điện thế tại mọi điểm thuộc quả cầu. Hình 25.15b diễn tả điều đó bằng đoạn nằm ngang tương ứng với các điểm bên trong quả cầu.

### Bài tập mẫu 25.6: Hai quả cầu tích điện nối nhau

_Hình 25.15: (a) vật dẫn hình cầu (b) điện thế (c) điện trường_
![](images/image56.jpeg)Hai vật dẫn hình cầu có bán kính lần lượt bằng _r_ 1 và _r_ 2 ban đầu
đặt cách xa nhau. Sau đó chúng được nối với nhau nhờ sợi dây dẫn điện như hình 25.16. Khi hệ cân bằng, điện tích trên mỗi quả
cầu lần lượt bằng _q_ 1 và _q_ 2 , phân bố đều trên mỗi bề mặt. Tìm tỉ
số của cường độ điện trường trên bề mặt của hai quả cầu này.

### Giải:

Do hai quả cầu đặt cách nhau đủ xa, sự ảnh hưởng lẫn nhau về điện trường là không đáng kể, dẫn đến điện tích mỗi bên vẫn phân bố đều trên mỗi bề mặt và điện trường trên mỗi quả cầu vẫn giữ được nguyên tính đối xứng.
Việc nối hai quả cầu bằng dây dẫn làm cho điện thế cả hai bằng nhau:
_V_ = _k_ _q_ _1_ = _k_ _q_ _2_
_Hình 25.16: Hai quả cầu dẫn điện nối với nhau_
_r_ 1 _r_ 2
hay:
_q_ 1 = _r_ 1 (1)
_q_ 2 _r_ 2
Cường độ điện trường trên bề mặt mỗi quả cầu có độ lớn:
_E_ 1 = _k_
_q_ 1 , _E_

_e r_ 2 2

= _k q_ 2
_e r_ 2
1 2
Lấy tỉ số của cường độ điện trường:

2

_1_ _1 2_

2

2 2 1

Thế (1) vào thu được:
_E r r_ 2 _r_
_1_ = _1 2_ = _2_
_E r r_ 2 _r_
2 2 1 1
Từ kết quả thu được có thể thấy rằng, khi hai quả cầu nối nhau bằng dây dẫn điện, điện trường trên bề mặt của quả cầu nhỏ thì lớn hơn điện trường trên bề mặt quả cầu lớn.

### Vật dẫn rỗng ruột

![](images/image57.jpeg)Vật dẫn rỗng ruột có thể miêu tả như hình 25.17. Với loại vật dẫn hết sức đặc biệt này, ta sẽ chứng minh rằng _điện trường bên trong phần rỗng của vật dẫn phải luôn luôn bằng không, dù điện trường bên ngoài có thay đổi thế nào đi nữa_! Thực vậy, xét hai điểm A và B bất kì thuộc thành bên trong sát phần rỗng, theo (25.3) ta có:
![](images/image38.png)( _B_ )
_VB_ − _VA_ = − ∫
( _A_ )
Nhưng đối với vật dẫn bất kì ta cũng đã chứng minh rằng
điện thế tại mọi điểm trong nó đều bằng nhau: _VA_ = _VB_ .
![](images/image15.png)Nên vector cường độ điện trường buộc phải bằng không.
Vật dẫn rỗng ruột dưới dạng những hộp có vỏ bằng kim loại có nhiều ứng dụng trong việc cách ly các vật bên trong khỏi ảnh hưởng của điện trường ngoài.

### Tia lửa điện

_Hình 25.17: Vật dẫn rỗng ruột_
Tia lửa điện thường quan sát thấy ở gần vật dẫn điện cao thế. Khi điện trường gần vật dẫn đủ lớn, các electron tự do, vốn phát sinh do sự ion hoá ngẫu nhiên của phân tử khí, sẽ được gia tốc và bị đẩy xa khỏi phân tử mẹ. Chúng chuyển động nhanh và va chạm với nhiều
phân tử khí xung quanh, làm phát sinh thêm rất nhiều sự ion hoá thứ cấp, kéo theo sự xuất hiện càng lúc càng nhiều electron tự do khác. Các electron này sau đó tái kết hợp với những ion phân tử, di chuyển từ trạng thái tự do sang trạng thái liên kết ở mức năng lượng thấp hơn làm phát ra năng lượng dưới dạng ánh sáng. Đó chính là tia lửa điện.
Ở những phần nhọn của vật dẫn, điện tích tập trung nhiều hơn và sinh ra điện trường lớn hơn so với những phần khác. Do đó tia lửa điện thường hay xuất hiện ở những điểm nhọn này.
Tia lửa điện có thể được quan sát rõ hơn nhờ máy quay tử ngoại

## ![](images/image58.png) Thí nghiệm giọt dầu Millikan

![](images/image59.jpeg)

_Hình 25.18: Thí nghiệm giọt dầu Millikan_
Trong giai đoạn 1909-1913, Robert Millikan đã tiến hành phép đo điện tích của electron, xác định giá trị của điện tích nguyên tố _e_. Thiết bị thí nghiệm được mô tả như hình 25.18. Bộ phận chính của thiết bị gồm hai đĩa kim loại đặt song song, đấu vào hai cực của ắc quy để tạo ra điện trường giữa chúng. Millikan dùng bình phun sương phun những giọt dầu li ti vào khoảng trống giữa hai đĩa, đồng thời rọi x-quang làm ion hoá không khí, khiến cho các electron được giải phóng và dính vào những giọt dầu. Những giọt dầu được chiếu sáng, hiện giữa ống kính quan sát như những ngôi sao hiện giữa trời đêm.
_Hình 25.21: Bộ lọc bụi tĩnh điện_
![](images/image15.png)![](images/image60.png)
**Khái niệm và nguyên lý**

![](images/image2.png)![](images/image60.png)![](images/image15.png)

# Câu hỏi lý thuyết chương 25

  1. Phân biệt hai khái niệm điện thế và thế năng.

  2. Hãy mô tả mặt đẳng thế trong điện trường tạo bởi một dây tích điện dài vô hạn và của một mặt cầu tích điện đều.

  3. Khi hai hạt mang điện tích điểm đặt xa nhau vô cùng, thế năng của hệ được quy ước bằng không. Khi đưa các hạt tiến lại gần nhau, thế năng của hệ mang giá trị dương nếu hai điện tích cùng dấu, mang giá trị âm nếu hai điện tích trái dấu. Hãy giải thích tại sao như vậy.


# Bài tập chương 25

  1. Hai bản phẳng đặt song song cách nhau 5,33 mm, đặt dưới hiệu điện thế 600 V.

1. Tính cường độ điện trường giữa hai bản phẳng.

2. Tìm lực tác dụng lên một electron đang nằm trong điện trường này.

3. Để di chuyển một electron từ vị trí cách bản dương 2,90 mm đến bản âm cần thực hiện một công bằng bao nhiêu?


ĐS: (a) 1,13×105 N/C (b) 1,8×10−14 N (c) 4,37 ×10−17 J

  2. Một proton được gia tốc từ trạng thái đứng yên bằng hiệu điện thế 120 V. Tính tốc độ mà nó thu được sau khi gia tốc.


ĐS: 1,52 ×105 m/s

  3. ![](images/image61.jpeg)Một điện trường đều có cường độ 325 V/m hướng theo chiều âm của trục _y_ như hình vẽ. Tính hiệu điện thế _VB_ − _VA_ giữa hai điểm A(-0,2 ;-0,3) và B(0,4 ;0,5). Gợi ý: lấy tích phân đường theo đường đứt nét như hình vẽ.


ĐS: +260 V

  4. Khi một electron chuyển động song song theo trục _x_ từ vị


trí

_x_ = 0
đến vị trí
_x_ = 2 cm, tốc độ của nó suy giảm từ
3,7 ×106 m/s xuống còn 1, 4 ×105 m/s.

  1. Tính hiệu điện thế giữa hai điểm nói trên

  2. Điểm nào có điện thế lớn hơn? ĐS: (a) -38,9 V


_Hình bài 3_

  5. Hai điện tích điểm được bố trí cách nhau _d_ = 2 cm như hình vẽ. Tính điện thế tại điểm A cách đều các điện tích một khoảng _d_ và tại điểm B nằm chính giữa hai điện tích.


![](images/image62.jpeg)ĐS: _VA_ = 5,39 kV, _VA_ = 10,8kV
_Hình bài 5_

  6. ![](images/image63.jpeg)Ba điện tích điểm có giá trị lần lượt bằng 20 nC, 10 nC và - 20 nC được gắn cố định trên một trục thẳng đứng như hình vẽ.

1. Tính thế năng của hệ ba điện tích gắn cố định nói trên.

2. Đặt thêm hạt có điện tích 40 nC và khối lượng


2 ×10−13
kg vào vị trí như hình vẽ. Hạt này bị đẩy và chuyển động ra xa do tương tác với ba điện tích cố định. Tính vận tốc của hạt khi nó bị đẩy tới xa vô cùng.
ĐS: (a)
−4,5×10−5 J (b) 3, 46×104 m/s

  7. Hai điện tích điểm đặt cách nhau biết _Q_ = 5 nC. Hãy tính:

1. Điện thế tại A.

2. Điện thế tại B.

3. Hiệu điện thế giữa B và A.


_d_ = 2 cm như hình vẽ. Cho
_Hình bài 6_
![](images/image64.jpeg)
_Hình bài 7_
ĐS: (a) _VA_ = 5, 43 kV (b) _VB_ = 6,08 kV (c)
∆ _V_ = 658 V

  8. Tại một vị trí P nào đó gần điện tích điểm có cường độ điện trường bằng 500 V/m và điện thế -3 kV. Hãy tính :

1. Khoảng cách giữa điểm P và điện tích điểm.

2. Độ lớn của điện tích điểm. ĐS: (a) 6 m (b) -2 µC

  9. Bốn hạt có cùng điện tích _Q_ đặt trên bốn góc của hình vuông có cạnh bằng _a_. Hãy tính:

1. Điện thế ở tâm của hình vuông.

2. Công cần thực hiện để đưa một hạt điện tích _q_ từ xa vô cùng về tâm của hình vuông.


![](images/image65.png) _Q_

ĐS: (a) 4 2 _ke a_
_qQ_
![](images/image66.png)(b) 4 2 _ke a_

  10. Năm 1911, Rutherford cùng hai trợ lý Geiger và Marsden đã tiến hành thí nghiệm tán xạ


tia alpha trên nguyên tử vàng. Mỗi hạt alpha có điện tích bằng +2 _e_ và khối lượng
6,64 ×10−27 kg. Kết quả thí nghiệm chỉ ra rằng, hầu hết khối lượng của nguyên tử gần như tập trung vào hạt nhân với kích thước rất nhỏ, được bao quanh bởi các quỹ đạo electron.
Bắn một hạt alpha từ khoảng cách xa hướng thẳng tới hạt nhân vàng với điện tích +79 _e_.
Tốc độ ban đầu của alpha bằng 2,00×107 m/s. Hạt alpha có khả năng tiến lại gần nhất so
với hạt nhân vàng một khoảng bằng bao nhiêu? Cho rằng hạt nhân vàng luôn nằm cố định.
ĐS: 2,74 ×10−14 m

  11. Dựa vào độ thị sự phụ thuộc của điện thế vào toạ độ _V_ ( _x_ ), hãy vẽ đồ thị sự phụ thuộc


của thành phần _x_ của cường độ điện trường theo toạ độ _Ex_ ( _x_ ).

![](images/image67.jpeg)

_Hình bài 11_

  12. Trong phạm vi từ _x_ = 0 đến _x_ = 6, 00 m, điện thế có dạng hàm số _V_ = _a_ \+ _bx_ , với


_a_ = 10, 0 V và _b_ = 7, 00 V/m. Hãy xác định :

  1. Điện thế tại _x_ = 0, _x_ = 3, 00 và _x_ = 6, 00 m.

  2. Độ lớn và hướng của điện trường tại _x_ = 0, _x_ = 3, 00 và _x_ = 6, 00 m.


ĐS: (a) 10V, -11V và -32V (b) 7 N/C tại mọi điểm _x_ > 0

  13. ![](images/image68.jpeg)Trên một vùng không gian nhất định nào đó, điện thế có dạng hàm số


_V_ = 5 _x_ − 3 _x_ 2 _y_ \+ 2 _yz_ 2.

  1. ![](images/image69.png)Tìm hàm số biểu diễn các thành phần _Ex_ , _Ey_ , _Ez_ của vector cường độ điện trường

  2. Tính cường độ điện trường tại điểm P có toạ độ (1, 00;0; −2, 00) m.


![](images/image70.png)ĐS: (a) (b) 7,07 N/C

  14. Một thanh tích điện đều dài 14 cm được uốn cong thành nửa cung tròn như hình vẽ. Tổng điện tích trên thanh bằng -7,5 µC. Tính điện thế tại tâm O của cung tròn.


_Hình bài 14_
ĐS: −1,51×106 V

  15. Một dây tích điện đều với mật độ điện dài λ được uốn thành dạng như hình vẽ. Hãy tính điện thế tại điểm O.


![](images/image71.jpeg)

ĐS:
_ke_ λ(π + 2ln 3)
_Hình bài 15_

  16. Một vật dẫn hình cầu có bán kính 14 cm và điện tích 26 µC. Tính cường độ điện trường và điện thế tại điểm cách tâm vật dẫn:

1. _r_ = 10 cm

2. _r_ = 20 cm

3. _r_ =14 cm


ĐS: (a) 1, 67 ×106 V (b) 1,17 ×106 V (c) 1, 67 ×106 V

  17. ![](images/image72.jpeg)Ống Geiger-Mueller có cấu tạo gồm anode và cathode từ hai ống kim loại hình trụ lồng vào nhau như hình vẽ.


Anode có bán kính _rB_ và tích điện với mật độ dài λ.
Cathode có bán kính _rA_ và tích điện với mật độ dài −λ.

  1. Chứng tỏ rằng hiệu điện thế giữa anode và cathode có dạng:


∆ _V_ = 2 _k_ λ ln  _rA_ 

_e_  _r_ 

 _B_ 

_Hình bài 17_

  2. Chứng tỏ rằng cường độ điện trường phụ thuộc vào khoảng cách _r_ đến trục đối xứng theo biểu thức:


_E_ = ∆ _V_ 1

ln( _rA_ / r _B_ ) _r_

# Public_146

Ánh sáng là cơ sở cho hầu như mọi sự sống trên trái đất. Ví dụ, thực vật chuyển đổi năng lượng của ánh sáng mặt trời thành năng lượng hóa học thông qua quá trình quang hợp. Ngoài ra, ánh sáng là phương tiện chính mà chúng ta có thể truyền và nhận thông tin đến và đi từ các vật thể xung quanh cũng như từ trong vũ trụ.

Ánh sáng là một dạng bức xạ điện từ, truyền năng lượng từ nguồn sáng tới người quan sát. Nhiều hiện tượng trong cuộc sống hàng ngày của chúng ta phụ thuộc vào tính chất của ánh sáng. Khi bạn xem tivi hoặc xem ảnh trên màn hình máy tính, bạn sẽ thấy hàng triệu màu được tạo thành từ sự kết hợp chỉ có ba màu là: đỏ, xanh dương và xanh lục. Màu xanh của bầu trời ban ngày, màu đỏ và màu cam trên bầu trời lúc bình minh hay hoàng hôn là kết quả của hiện tượng _tán xạ_ ánh sáng bởi các phân tử không khí. Bạn thấy hình ảnh của mình trong gương phòng tắm buổi sáng hoặc hình ảnh của những chiếc xe khác trong gương chiếu hậu khi đang lái xe là kết quả từ _sự phản xạ_ ánh sáng. Nếu bạn đeo kính để nhìn cho rõ thì bạn đang nhờ vào hiện tượng _khúc xạ_ ánh sáng. Màu sắc của cầu vồng là do sự _tán sắc_ ánh sáng khi nó đi qua những hạt mưa lơ lửng trên bầu trời sau cơn mưa. Nếu bạn đã từng nhìn thấy những vòng tròn màu của hào quang xung quanh cái bóng của chiếc máy bay bạn đang đi trên những đám mây thì bạn đang thấy kết quả của hiện tượng _giao thoa_ ánh sáng.

Trong phần giới thiệu của chương 35, chúng ta sẽ thảo luận về _lưỡng tính sóng-hạt_ của ánh sáng. Trong một số trường hợp, ánh sáng được mô hình như một dòng hạt; ở những trường hợp khác, mô hình sóng hoạt động tốt hơn. Chương 35 đến hết 38 tập trung vào các khía cạnh của ánh sáng được hiểu rõ nhất thông qua _mô hình sóng_ của ánh sáng. Trong phần 6, chúng ta sẽ tìm hiểu về _bản chất hạt_ của ánh sáng.

Chương này bắt đầu giới thiệu hai mô hình lịch sử của ánh sáng và thảo luận các phương pháp đo tốc độ ánh sáng trước đây. Tiếp theo là những hiện tượng cơ bản của quang hình học: sự _phản xạ_ ( _reflection_ ) của ánh sáng từ một bề mặt và sự _khúc xạ_ ( _refraction_ ) khi ánh sáng đi qua biên giới giữa hai môi trường. Chúng ta cũng sẽ
nghiên cứu sự _tán sắc (dispersion)_ của ánh sáng khi nó khúc xạ qua vật liệu, dẫn đến hiện tượng xuất hiện cầu vồng. Cuối cùng, chúng ta sẽ nghiên cứu hiện tượng _phản xạ toàn phần_ ( _total internal reflection_ ), là cơ sở cho hoạt động của sợi quang và công nghệ sợi quang.

## 35.1. Bản chất của ánh sáng

Trong lịch sử có hai mô hình cơ bản về bản chất của ánh sáng. Trước thế kỷ thứ 19, ánh sáng được xem như một dòng hạt. Các hạt này hoặc được phát ra từ các vật hoặc xuất phát từ mắt người quan sát. Newton là người chủ xướng cho lý thuyết hạt ánh sáng. Ông cho rằng các hạt ánh sáng xuất phát từ các vật và đi đến mắt để kích thích cảm giác sáng của người

quan sát.

Christian Huygens thì lại tin rằng ánh sáng có thể là một dạng sóng chuyển động nào đó. Ông đã chỉ ra rằng các tia sáng giao thoa với nhau. Những nghiên cứu khác suốt thể kỷ thứ 19 đã dẫn đến một sự thừa nhận chung về lý thuyết sóng của ánh sáng. Thomas Young là người cung cấp bằng chứng rõ ràng đầu tiên (năm 1801) về bản chất sóng của ánh sáng. Ông đã giải thích hiện tượng giao thoa của ánh sáng dựa trên nguyên lý chồng chất. Hiện tượng này không thể giải thích được bằng lý thuyết hạt ánh sáng. Maxwell đã khẳng định rằng ánh sáng là một dạng sóng điện từ có tần số cao và Hertz đã cung cấp bằng chứng thực nghiệm cho lý thuyết của Maxwell vào năm 1887.

Mặc dù mô hình sóng và lý thuyết cổ điển về điện - từ có thể giải thích được hầu hết các tính chất của ánh sáng, nhưng chúng không thể giải thích được một số kết quả thí nghiệm sau đó. Nổi bật nhất là hiệu ứng quang điện được phát hiện bởi Hertz: Khi ánh sáng bắn vào một bề mặt kim loại thì các electron có thể được thoát ra khỏi bề mặt. Các thí nghiệm cho thấy động năng của một electron thoát ra độc lập với cường độ ánh sáng. Phát hiện này mâu thuẫn với mô hình sóng. Einstein đã đề xuất một giải thích về hiệu ứng quang điện vào năm 1905 sử dụng mô hình dựa trên khái niệm lượng tử hóa được Max Planck phát triển vào năm 1900. Mô hình lượng tử giả định năng lượng của sóng ánh sáng nằm trong các hạt gọi là photon và do đó năng lượng được cho là bị lượng tử hóa. Theo lý thuyết của Einstein, năng lượng E của một photon tỉ lệ thuận với tần số f của sóng điện từ :

E = hf

h = 6,63. 10-34 J.s là hằng số Planck.

Như vậy, ánh sáng phải có lưỡng tính sóng hạt. Trong một số hoàn cảnh ánh sáng biểu hiện các đặc trưng của sóng và trong một số hoàn cảnh khác ánh sáng lại biểu hiện các đặc trưng của hạt.

## 35.2. Đo tốc độ ánh sáng

## Vì ánh sáng di chuyển với tốc độ rất cao (c = 3,00.108 m/s) nên những cố gắng trước đây để đo tốc độ của nó đều không thành công. Galileo đã cố gắng đo tốc độ ánh sáng bằng cách cho hai người quan sát đứng cách nhau 10 km xác định thời gian ánh sáng truyền đi qua khoảng cách giữa hai người và ông đã kết luận rằng vì thời gian phản ứng của người quan sát lớn hơn nhiều thời gian chuyển động của ánh sáng nên không thể đo được tốc độ ánh sáng

bằng cách này.

### Phương pháp Roemer

![](images/image2.jpeg)Năm 1675, Ole Roemer đã sử dụng các quan sát thiên văn để ước lượng tốc độ ánh sáng. Ông đã sử dụng chu kỳ quay của Io, một mặt trăng của sao Mộc, khi sao Mộc quay xung quanh Mặt Trời. Góc quay của sao Mộc trong khoảng thời gian Trái Đất quay quanh Mặt Trời một góc 900 có thể tính được.

Chu kỳ quay dài hơn khi Trái Đất lùi xa dần sao Mộc, ngắn hơn khi Trái Đất tiến lại gần.

![](images/image3.jpeg)Sử dụng số liệu của Roemer, Huygens đã ước tính giới hạn dưới của tốc độ ánh sáng là 2,3.108 m/s. Đây là một kết quả rất quan trọng trong lịch sử vì nó đã cho thấy rằng ánh sáng có tốc độ hữu hạn và đã cho một ước lượng về tốc độ đó.

### Phương pháp Fizeau

Phương pháp thành công đầu tiên để đo tốc độ ánh sáng bằng các kỹ thuật thuần túy trên mặt đất được phát triển vào năm 1849 bởi nhà vật lý người Pháp Armand H. L. Fizeau.

Hình 35.2 biểu diễn một sơ đồ đơn giản của thiết bị đo. Nếu d là khoảng cách giữa nguồn sáng (được xem là vị trí của bánh xe) và gương và ∆t là thời gian ánh sáng di chuyển từ bánh xe đến gương thì tốc độ của ánh sáng là c = 2d/∆t.

Để đo thời gian vận chuyển, Fizeau đã sử dụng một bánh xe răng cưa, chuyển đổi một chùm ánh sáng liên tục thành một loạt các xung ánh sáng. Nếu một xung ánh sáng di chuyển về phía

_Hình 35.1: Phương pháp Roemer_
_Hình 35.2: Phương pháp Fizeau_

gương và đi qua khe hở tại điểm A trong hình 35.2 và quay trở lại bánh xe tại răng B thì xung phản xạ sẽ không tới được người quan sát. Với tốc độ quay lớn hơn, điểm C có thể di chuyển vào vị trí để cho phép xung phản xạ đi tới người quan sát. Biết khoảng cách d, số răng của bánh xe và tốc độ góc của bánh xe, Fizeau đã xác định được giá trị tốc độ ánh sáng là 3,1×108 m/s.

Các phép đo mang lại giá trị chính xác hơn được chấp nhận hiện tại là 2,997 924 58×108 m/s.

## Gần đúng tia trong quang hình học (quang học tia)

Quang học tia ( _Ray Optics_ ), còn gọi là quang hình học ( _Geometric Optics_ ), nghiên cứu sự lan truyền của ánh sáng. Nó sử dụng giả thuyết rằng ánh sáng truyền đi theo đường thẳng trong một ![](images/image4.png)môi trường đồng dạng và thay đổi hướng khi gặp bề mặt của một môi trường khác hoặc nếu như tính chất quang học của môi trường

là không đồng dạng. Gần đúng tia ( _Ray approximation_ ) được sử dụng để biểu diễn các chùm sáng. Các tia sáng là những đường thẳng vuông góc với mặt sóng ( _front wave_ ). Với gần đúng tia, chúng ta giả thiết rằng một sóng ánh sáng truyền đi trong môi trường trên một đường thẳng theo hướng của các tia đó.

Nếu một sóng gặp một vật cản với bước sóng λ << d thì sóng đó sẽ xuất phát từ khoảng trống và tiếp tục di chuyển theo một đường thẳng, d là đường kính của khoảng trống. Đây là một gần đúng tốt để nghiên cứu gương, kính, lăng kính ...Các hiệu ứng xảy ra đối với những khoảng trống có kích thước khác nhau.

![](images/image5.jpeg)

_Hình 35.3: Quang học tia_

![](images/image6.jpeg)

![](images/image7.png)

_Hình 35.4: Một sóng phẳng bước sóng_ λ _chiếu tới màn chắn có một lỗ trống đường kính d._

## Sự phản xạ ánh sáng

Một tia sáng (tia tới) di chuyển trong một môi trường khi gặp biên giới với một môi trường thứ hai thì một phần của tia tới sẽ bị phản xạ ngược lại môi trường đầu tiên, có nghĩa là nó sẽ hướng ngược lại môi trường thứ nhất. Đối với các sóng ánh sáng truyền trong không gian ba chiều thì hướng của các tia phản xạ khác với hướng của các tia tới.

**_Phản xạ gương_ ( _specular reflection_ )** là sự phản xạ từ một bề mặt nhẵn. Các tia phản xạ song song với nhau.

Tất cả hiện tượng phản xạ ánh sáng trong sách này đều được giả thiết là phản xạ gương.

_**Sự phản xạ tràn lan (Diffuse reflection)**_ là sự phản xạ trên một bề mặt thô. Các tia phản xạ truyền đi theo nhiều hướng khác nhau. Một bề mặt được coi là bề mặt thô nếu sự biến đổi bề mặt nhỏ hơn nhiều bước sóng ánh sáng.

### Định luật phản xạ (Law of reflection)

Pháp tuyến là một đường thẳng vuông góc với bề mặt. Nó nằm tại vị trí tia tới đập lên bề mặt. Tia tới tạo với pháp tuyến một góc θ1. Tia phản xạ tạo với tia tới một góc θ’1.

Góc phản xạ bằng góc tới :

![](images/image8.jpeg)

_Hình 35.5: Sự phản xạ gương_
![](images/image9.jpeg)θ’1 = θ1 (35.1)
Mối liên hệ này được gọi là định luật phản xạ.
Tia tới, tia phản xạ và pháp tuyến đều nằm trên một mặt phẳng. Bởi vì sự phản xạ sóng là một hiện tượng phổ biến, thường xảy ra nên chúng ta sẽ đưa ra một mô hình phân tích cho trường hợp này được gọi là _**mô hình phân tích sóng bị phản xạ** (the wave under reflection model_) _._

_**Câu hỏi 35.1:**_ Trong phim, bạn có thể nhìn thấy diễn viên nhìn vào một chiếc gương và thấy mặt mình trong đó. Có thể nói chắc chắn rằng trong cảnh đó người diễn viên nhìn thấy trong gương a) mặt anh ta b) mặt bạn c) mặt đạo diễn d) camera quay cảnh e) không thể xác định được.

### Bài tập mẫu 35.1: Phản xạ nhiều lần

Hai gương hợp nhau một góc 120o như hình vẽ. Tia tới chiếu lên gương M1 dưới góc 65o, tia phản xạ hướng đến gương M2. Hãy xác định hướng của tia sáng sau khi phản xạ trên gương M2.

### Giải:

Theo định luật phản xạ, tia phản xạ trên M1 hợp với gương một góc
δ = 90o – 65o = 25o
γ = 180° - 25° - 120° = 35°
_Hình 35.6: Định luật phản xạ_

![](images/image10.jpeg)

_Hình 35.7: Sự phản xạ nhiều lần_
θM2 = 90° - 35° = 55°
Tia phản xạ trên gương M2 hợp với pháp tuyến một góc
θ’M2 = θM2 = 55°

### Sự phản xạ ngược (retroreflection)

Giả sử góc hợp giữa hai gương là 90o thì chùm tia phản xạ sẽ quay trở về nguồn phát song song với chùm tia tới ban đầu. Hiện tượng này được gọi là _**sự phản xạ ngược**_. Có nhiều áp dụng của hiện tượng này như đo khoảng cách tới Mặt Trăng, gương chiếu hậu, tín hiệu giao thông...

![](images/image11.jpeg)

_Hình 35.8: Ứng dụng hiện tượng phản xạ ngược_

Vào năm 1969, một bảng gồm nhiều gương phản xạ nhỏ đã được các phi hành gia tàu Apollo 11 đưa lên Mặt trăng (hình 35.8a). Một chùm tia laser từ Trái đất chiếu đến bảng gương này sẽ được phản xạ trực tiếp trở lại chính nó và thời gian di chuyển của nó có thể đo được. Từ đó có thể xác định được khoảng cách từ Trái đất đến Mặt trăng với sai số 15 cm.

Một ứng dụng hàng ngày khác được tìm thấy trong đèn hậu ô tô. Một phần nhựa của đèn hậu được tạo thành bởi nhiều góc hình khối nhỏ (hình 35.8b) để các chùm đèn pha từ ô tô phía sau chiếu đến sẽ phản xạ lại người lái xe.

![](images/image12.png)Thay vì các góc hình lập phương, các hình cầu nhỏ đôi khi được sử dụng (hình 35.8c). Những quả cầu nhỏ trong suốt được sử dụng trong một vật liệu phủ trên nhiều biển báo đường bộ. Do sự phản xạ ngược từ những quả cầu này, dấu hiệu dừng xe trong hình 35.8d sẽ sáng hơn nhiều so với khi nó chỉ đơn giản là một bề mặt phẳng, sáng bóng. Sự phản xạ ngược cũng được sử dụng cho các tấm phản quang trên giày chạy bộ và quần áo chạy để cho phép người chạy bộ được nhìn thấy vào ban đêm.

## Sự khúc xạ ánh sáng

Khi một tia sáng lan truyền trong một môi trường trong ![](images/image13.png)suốt đến gặp mặt phân cách với một môi trường trong suốt khác thì một phần tia tới bị phản xạ và một phần sẽ đi vào môi

trường thứ hai.

Tia sáng đi vào môi trường thứ hai này có hướng bị thay đổi. Sự gãy tia sáng này được gọi là khúc xạ ( _refraction_ ).

Tia tới, tia phản xạ, tia khúc xạ và pháp tuyến đều nằm trong cùng một mặt phẳng. Góc khúc xạ ( _angle of refraction_ ) phụ thuộc vào vật liệu và góc tới ( _angle of incidence_ ).

sin θ 2

sin θ1

= v 2
v1
(35.2)

v1 là tốc độ ánh sáng trong môi trường thứ nhất và v2 là tốc độ ánh sáng trong môi trường thứ hai. Đường đi của tia sáng qua bề mặt khúc xạ là có thể đảo ngược. Ví dụ một tia sáng truyền từ A đến B thì nếu có một tia xuất phát từ B sẽ đi theo con đường AB để đến A.

_**Câu hỏi 35.2** :_ Trên hình 35.9, tia tới tà tia (1), hãy chỉ ra các tia phản xạ và tia khúc xạ trong những tia sáng 2, 3, 4, 5.

_Hình 35.9: Sự khúc xạ ánh sáng_

![](images/image14.jpeg)

Ánh sáng có thể khúc xạ vào trong một vật liệu mà ở đó tốc độ của nó nhỏ hơn. Góc khúc xạ nhỏ hơn góc tới. Tia sáng bị gập về phía pháp tuyến (hình 35.10.a).

Ánh sáng có thể khúc xạ vào trong một vật liệu mà ở đó tốc độ của nó lớn hơn. Góc khúc xạ lớn hơn góc tới. Tia sáng bị lệch xa khỏi pháp tuyến (hình 35.10.b).

Trong một môi trường, ánh sáng có tốc độ nhỏ hơn trong chân không. Điều đó có thể giải thích như sau. Ánh sáng đập vào một electron. Electron đó có thể hấp thụ ánh sáng, dao động và bức xạ ánh sáng. Sự hấp thụ và phát xạ có thể làm cho tốc độ di chuyển trung bình trong môi trường giảm xuống.

### Chiết suất - Chỉ số khúc xạ

![](images/image15.jpeg)

_Hình 35.11: Sự giảm vận tốc của tia sáng khí đi vào môi trường_

Tốc độ của ánh sáng trong một vật liệu bất kỳ đều nhỏ hơn tốc độ ánh sáng trong chân không. Chiết suất n của một môi trường được xác định như sau:

_n_ = _c_

v

(35.3)

Trong đó, c là tốc độ ánh sáng trong chân không, v là tốc độ ánh sáng trong môi trường. Đối với chân không n = 1, đối với không khí n cũng được coi là bằng 1. Đối với các môi trường khác, n > 1\. Chiết suất n là một số không thứ nguyên lớn hơn 1.

_Bảng 35.1: Chiết suất của một số môi trường_

![](images/image16.jpeg)

### Tần số ánh sáng giữa hai môi trường

# Public_147

Nội dung của chương này đề cập đến các ảnh được tạo thành khi chùm tia sáng gặp các bề mặt ngăn cách giữa hai môi trường. Các ảnh được tạo ra do sự phản xạ hoặc khúc xạ gây bởi các bề mặt này. Chúng ta có thể thiết kế các gương và thấu kính để tạo ra các ảnh có các đặc điểm như mong muốn. Trong chương này, ánh
sáng được thể hiện gần đúng như các tia và giả thiết rằng ánh sáng truyền đi theo đường thẳng. Đầu tiên chúng ta xem xét quá trình tạo ảnh bởi các loại gương và thấu kính và xác định vị trí cũng như kích thước của ảnh. Sau đó chúng ta sẽ kết hợp các gương và thấu kính để tạo ra các thiết bị quang học hữu ích như kính hiển vi và kính thiên văn.

## Ảnh tạo bởi gương phẳng

![](images/image1.png)Xét một nguồn sáng điểm đặt ở O trước một gương phẳng và cách gương một đoạn _p_ như trong hình vẽ. Khoảng cách _p_ được gọi là khoảng cách vật. Chùm sáng phân kỳ từ nguồn đến gương và bị phản xạ bởi gương tạo ra chùm tia phản xạ cũng là chùm tia phân kỳ. Đường kéo dài (dường đứt nét trong hình) của chùm tia phản xạ giao nhau ở điểm _I_. Chùm tia phản xạ dường như được phát ra từ điểm _I_ ở sau gương. Điểm _I_ được gọi là ảnh của vật ở
_O_. Khoảng cách _q_ từ _I_ đến gương được gọi là khoảng cách ảnh.
Một ảnh tạo bởi giao điểm của các tia sáng gọi là ảnh thật và một ảnh tạo bởi đường kéo dài của các tia sáng gọi là ảnh ảo.
_Hình 36.1_
Ảnh của một vật tạo bởi gương phẳng luôn là ảnh ảo. Một ảnh thật có thể hứng được trên màn ảnh, còn ảnh ảo thì không.
Để xác định ảnh của một vật có kích thước, ta cần xác định ảnh của tất cả các điểm trên vật. Mặc dù có vô hạn tia sáng đi từ một điểm trên vật, nhưng chúng ta chỉ cần xét hai tia sáng phát ra từ điểm này và vẽ các tia phản xạ tương ứng nhờ định luật phản xạ ánh sáng để xác định vị trí ảnh. Trong hình 36.2, ảnh của điểm _P_ trên vật được xác định nhờ hai tia: tia _PQ_ và _PR_. Do hai tam giác _PQR_ và _P'QR_ bằng nhau nên _PQ_ = _P'Q_ , vì vậy |𝑝| = |𝑞|. Do đó ảnh tạo bởi gương phẳng của một vật đối xứng với vật qua gương.
![](images/image3.png)Hình 36.2 cũng chỉ ra rằng chiều cao _h_ của vật bằng với chiều cao _h’_ của ảnh. Độ phóng đại ảnh của một vật được định nghĩa như sau:

𝑀 =

𝑐ℎ𝑖ề𝑢 𝑐𝑎𝑜 ả𝑛ℎ ℎ′
=
𝑐ℎ𝑖ề𝑢 𝑐𝑎𝑜 𝑣ậ𝑡 ℎ
(36.1)
Định nghĩa này cũng sẽ được dùng cho tất cả các loại gương và thấu kính. _M_ sẽ có giá trị dương khi ảnh và vật cùng chiều, _M_ sẽ có giá trị âm khi ảnh và vật ngược chiều. Với gương
_Hình 36.2_
phẳng 𝑀 = +1.
Bổ sung câu hỏi 36.1 vì tất cả các câu Quick Quiz đều có khả năng ra đề thi trắc nghiệm.

### ![](images/image4.png)Bài tập mẫu 36.1: Các ảnh tạo bởi hai gương.

Hai gương phẳng được đặt vuông góc nhau như hình 36.3 và vật được đặt ở _O_. Xác định các ảnh được tạo ra.

### Giải:

Ảnh của vật qua gương 1 là _I_ 1 và qua gương 2 là _I_ 2\. Ảnh _I_ 3 là ảnh của _I_ 1 qua gương 2 và cũng là ảnh của _I_ 2 qua gương 1.

_Hình 36.3_

Bổ sung phần ứng dụng trong gương chiếu hậu của ô tô (như trong giáo trình gốc).

## Ảnh tạo bởi gương cầu

Có nhiều loại gương cong khác nhau nhưng ở đây chúng ta chỉ khảo sát gương có bề mặt là một phần của mặt cầu (thường là một chỏm cầu), gọi là gương cầu.
Trong hình 36.4, tâm _C_ của mặt cầu chứa gương gọi là tâm của gương, bán kính _R_ của mặt cầu này gọi là bán kính của gương. Đường thẳng qua _C_ và _V_ ( _V_ là điểm chính giữa của gương gọi là đỉnh gương) gọi là trục chính của gương. Nếu mặt phản xạ của gương là mặt lõm thì gọi là gương cầu lõm và nếu mặt phản xạ của gương là mặt lồi thì gọi là gương cầu lồi.

### Gương cầu lõm

Xét một nguồn sáng điểm đặt trước gương tại một điểm _O_ tùy ý trên trục chính (Hình 36.5). Hai tia sáng phân kỳ từ _O_ tới gương cho hai tia phản xạ giao nhau tại ảnh _I,_ rồi chúng phân kỳ từ _I_ như
thể có một nguồn sáng tại đó. Ảnh _I_ này là ảnh thật.
Trong chương này chúng ta chỉ xét các tia sáng đi từ vật và tạo một góc nhỏ

![](images/image6.png)

_Hình 36.4_

Gương

![](images/image8.png)

_Hình 36.5_

![](images/image10.png)với trục chính (điều kiện tương điểm). Tất các tia này đều cho tia phản xạ qua một điểm duy nhất và làm cho ảnh của vật rõ nét. Các tia xa trục chính cho các tia phản xạ hội tụ tại các điểm khác nhau trên trục chính, tạo ra một ảnh mờ (Hình 36.6). Hiệu ứng này gọi là cầu sai.

2

Hình 36.7 cho phép chúng ta tính được khoảng cách ảnh _q_ khi biết khoảng cách vật _p_ và bán kính _R_ của gương. Các khoảng cách _p_ và _q_ là đo từ điểm _V_. Các tia sáng trong hình xuất phát từ đỉnh của vật: một tia qua _C_ cho tia phản xạ truyền ngược lại và một tia tới gương tại _V_ cho tia phản xạ đối xứng tia tới qua trục chính.
![](images/image11.png)Từ hình vẽ ta có: 𝑡𝑎𝑛𝜃 = ℎ/𝑝 và 𝑡𝑎𝑛𝜃 =
−ℎ′/𝑞 (ℎ′ < 0 vì ảnh ngược chiều với vật). Độ phóng đại ảnh
ℎ′ 𝑞
𝑀 = = − ℎ 𝑝
(36.2)
Mặt khác ta cũng có:
−ℎ′
𝑡𝑎𝑛𝛼 =
𝑅 − 𝑞
𝑣à 𝑡𝑎𝑛𝛼 =

ℎ

𝑝 − 𝑅
Suy ra:
ℎ′ 𝑅 − 𝑞
= −
ℎ 𝑝 − 𝑅
(36.3)
_Hình 36.7_
Từ 36.2 và 36.3 ta được:
Suy ra:

𝑅 − 𝑞 𝑞

= ![](images/image13.png)

𝑝 − 𝑅 𝑝

1 1 2 ![](images/image15.png) + ![](images/image15.png) =
𝑝 𝑞 𝑅

(36.4)

Phương trình 36.4 gọi là phương trình gương cầu.
![](images/image16.png)Nếu vật ở rất xa gương, nghĩa là _p_ rất lớn so với _R_ thì 1/𝑝 ≈ 0 và phương trình 36.4 cho 𝑞 ≈ 𝑅/2. Nghĩa là khi vật ở rất xa gương thì ảnh ở vị trí trung điểm của đoạn _CV_ như hình 36.8. Điểm ảnh đặc biệt này gọi là tiêu điểm _F_ và khoảng cách ảnh này gọi là tiêu cự _f_ , trong đó

𝑅

𝑓 =
2
(36.5)
Tiêu cự _f_ là một thông số đặc biệt của gương và được dùng để so sánh gương này với gương khác. Dùng _f_ phương trình 36.4 được viết lại thành:
_Hình 36.8_
1 1 1 ![](images/image17.png) + ![](images/image17.png) = ![](images/image17.png)

𝑝 𝑞 𝑓

(36.6)

### Gương cầu lồi

Hình 36.9 cho thấy ảnh của vật ở trước gương là một ảnh ảo và luôn cùng chiều với vật nhưng nhỏ hơn vật.
Các phương trình 36.2, 36.4 và 36.6 sử dụng được cho cả gương cầu lõm và gương cầu lồi, nhưng cần tuân theo quy ước về dấu theo bảng 36.1.

![](images/image18.png)

_Hình 36.9_

_Bảng 36.1- Quy ước dấu cho gương cầu_


| Đại lượng | Dương khi | Âm khi |
| --- | --- | --- |
| P | Vật ở trước gương (vật thật) | Vật ở sau gương (vật ảo) |
| Q | Ảnh ở trước gương (ảnh thật) | Ảnh ở sau gương (ảnh ảo) |
| h’ | Ảnh cùng chiều với vật | Ảnh ngược chiều với vật |
| fvàR | Gương là gương lõm | Gương là gương lồi |
| M | Ảnh cùng chiều với vật | Ảnh ngược chiều với vật |

 

### Các tia sáng đặc biệt

Vị trí và kích thước của ảnh tạo bởi gương có thể được xác định bằng hình vẽ và có thể dùng để kiểm tra các kết quả tính toán bằng các công thức. Việc vẽ hình trở nên đơn giản bằng cách sử dụng hai trong ba tia sáng xuất phát từ một điểm trên vật (thường là đỉnh của vật) theo các phương truyền đặc biệt theo từng loại gương như sau:

  * Tia tới song song với trục chính cho tia phản xạ qua tiêu điểm _F (_ hoặc có phương qua tiêu điểm _F_ ).

  * Tia tới qua tiêu điểm _F_ (hoặc có phương qua tiêu điểm _F_ ) cho tia phản xạ song song với trục chính.

  * Tia tới gương tại tâm _C_ (hoặc có phương qua tâm _C_ ) cho tia phản xạ truyền ngược lại theo phương của tia tới.


Giao điểm của hai trong ba tia trên xác định vị trí ảnh.
Đối với gương cầu lõm, khi cho vật từ xa gương tiến đến _F_ thì ảnh thật (ngược chiều với vật) sẽ tiến ra xa gương và càng lớn dần. Khi vật ở tại _F,_ ảnh ở xa vô cùng. Khi vật ở giữa _F_ và gương thì ảnh là ảo, cùng chiều với vật, lớn hơn vật và cứ lớn dần lên.
Đối với gương cầu lồi, ảnh luôn là ảo, cùng chiều và nhỏ hơn vật. Khi vật tiến về phía gương thì ảnh lớn dần và tiến về phía gương.
Bổ sung câu hỏi 36.2 và 36.3 vì tất cả các câu Quick Quiz đều có khả năng ra đề thi trắc nghiệm.

### Bài tập mẫu 36.2: Một gương cầu có tiêu cự 10,0 cm.

Một gương cầu có tiêu cự 10,0 cm .
(A) Xác định vị trí và mô tả ảnh của một vật đặt cách gương 25 cm.
(B)Xác định vị trí và mô tả ảnh của một vật đặt cách gương 10 cm.

### Giải:

(A) Theo công thức gương cầu:
1 1 1 ![](images/image17.png) + ![](images/image17.png) =
𝑝 𝑞 𝑓
=> 𝑞 =
𝑝𝑓
𝑝 − 𝑓
25.10
=
25 − 10
= 16,7 𝑐𝑚
Độ phóng đại ảnh:
𝑞
𝑀 = −
𝑝
= −0,667
Kết luận: Ảnh thu được là ảnh thật, nhỏ hơn vật và ngược chiều với vật. (B)
1 1 1 ![](images/image17.png) + ![](images/image17.png) =
𝑝 𝑞 𝑓
=> 𝑞 =
𝑝𝑓
𝑝 − 𝑓
10.10
= → ∞
10 − 10
Kết luận: Ảnh ở xa vô cực, nghĩa là chùm tia xuất phát từ vật đến gương cho chùm tia phản xạ song song nhau.
Bổ sung thêm bài tập mẫu 36.4 như trong giáo trình gốc

## Ảnh tạo bởi sự khúc xạ

![](images/image19.png)Xét hai môi trường trong suốt có chiết suất 𝑛1 và 𝑛2 và ngăn cách nhau bởi mặt cầu có bán kính _R_ (Hình 36.16). Giả sử nguồn sáng điểm đặt ở _O_ trong môi trường có chiết suất 𝑛1. Một chùm sáng từ _O_ khúc xạ ở mặt cầu và hội tụ ở _I,_ là ảnh của nguồn.
Với một tia sáng từ _O_ khúc xạ qua _I_ (Hình 36.17), định luật Snell cho
𝑛1 𝑠𝑖𝑛𝜃1 = 𝑛2 𝑠𝑖𝑛𝜃2
Với các góc 𝜃 nhỏ sao cho có thể sử dung gần đúng 𝑠𝑖𝑛𝜃 ≈ 𝜃 (góc 𝜃 tính theo radian) thì phương trình trên có thể viết lại thành

![](images/image21.png)

𝑛1𝜃1 = 𝑛2𝜃2

Theo hình vẽ ta cũng có

𝜃1 = 𝛼 + 𝛽 𝑣à 𝛽 = 𝜃2 \+ 𝛾

Kết hợp các phương trình trên để khử 𝜃1 và 𝜃2 thì thu được
𝑛1𝛼 + 𝑛2𝛾 = (𝑛2 − 𝑛1)𝛽 (36.7)
Sử dụng các tam giác trong hình vẽ chúng ta cũng thu được các kết quả
𝑑
𝑡𝑎𝑛𝛼 ≈ 𝛼 =
𝑝
𝑑
; 𝑡𝑎𝑛𝛽 ≈ 𝛽 =
𝑅

𝑑

𝑣à 𝑡𝑎𝑛𝛾 ≈ 𝛾 = ![](images/image22.png)

𝑞

Thay các biểu thức này vào (36.7) rồi rút gọn thì được
𝑛1
+
𝑝
𝑛2
𝑞
𝑛2 − 𝑛1
=
𝑅
(36.8)
Kết quả này không phụ thuộc 𝛼 (với 𝛼 nhỏ) nên tất cả các tia sáng đều hội tụ tại cùng một điểm ảnh _I_.
![](images/image24.png)Để cho thuận tiện khi xét các trường hợp khác nhau, chúng ta gọi phía mặt ngăn cách chứa chùm sáng tới là phía trước và phía bên kia gọi là phía sau. Ngược với ảnh tạo bởi gương, ảnh thực tạo bởi các tia khúc xạ xuất hiện ở phía sau mặt ngăn cách nên quy ước về dấu cho _q_ và _R sẽ_ ngược với quy ước dấu cho gương.

### Sự khúc xạ qua các bề mặt phẳng

Nếu bề mặt khúc xạ là phẳng thì 𝑅 → ∞ và phương trình 36.8 trở thành

𝑛1

𝑝

𝑛2
= −
𝑞
(36.9)

6

Phương trình (36.9) cho thấy _q_ và _p_ ngược dấu nhau nên ảnh và vật ở cùng phía so với bề mặt khúc xạ như minh họa ở hình 36.18, nghĩa là ảnh thu được là ảnh ảo.
Bổ sung câu hỏi 36.4 và 36.5 vì tất cả các câu Quick Quiz đều có khả năng ra đề thi trắc nghiệm.

### Bài tập mẫu 36.7: Một con cá đang bơi ở độ sâu _d_ so với mặt nước của một hồ nước.

Một con cá đang bơi ở độ sâu _d_ so với mặt nước của một hồ nước.

  1. Một người quan sát con cá theo hướng vuông góc với mặt nước sẽ thấy con cá ở độ sâu biểu kiến bằng bao nhiêu?


### Giải:

Từ phương trình (36.9), suy ra

𝑞 = −

𝑛2
𝑛1
𝑝 = −
1,00
1,33
𝑑 = −0,752 𝑑
𝑞 < 0 nên ảnh là ảo và người sẽ thấy con cá ở độ sâu biểu kiến khoảng bằng 3/4 độ sâu thực sự (Hình 36.20a).

![](images/image25.png)

_Hình 36.20_

  2. Nếu mặt của người quan sát cách mặt nước một đoạn _d_ thì con cá sẽ thấy mặt người cách mặt nước một đoạn biểu kiến bằng bao nhiêu?


### Giải:

Phương trình 36.9 cho

𝑞 = −

𝑛2
𝑛1
𝑝 = −
1,33
1,00
𝑑 = −1,33 𝑑
Ảnh của mặt người là ảo, nghĩa là ảnh trong môi trường không khí trên mặt nước (Hình 36.20b).

  3. Nếu con cá có chiều cao thực sự là _h_ (đo từ vây trên đến vây dưới của con cá) thì chiều cao biểu kiến của con cá mà người quan sát nhìn thấy bằng bao nhiêu so với _h_?


### Giải:

Ảnh của vây trên và vây dưới của con cá ở các vị trí
𝑞1 = −0,752 𝑑 𝑣à 𝑞2 = −0,752 (𝑑 + ℎ)
Chiều cao biểu kiến của con cá là
ℎ′ = 𝑞1 − 𝑞2 = 0,752 ℎ
Vì vậy chiều cao biểu kiến của con cá chỉ bằng khoảng 3/4 chiều cao thực của con cá.

## Ảnh tạo bởi thấu kính mỏng

Thấu kính thường được dùng để tạo ảnh bởi sự khúc xạ trong các hệ thống quang học của các thiết bị như máy ảnh, kính hiển vi, kính viễn vọng. Với thấu kính, ánh sáng sẽ khúc xạ ở cả hai bề mặt của thấu kính và ảnh do sự khúc xạ ở bề mặt thứ nhất của thấu kính sẽ trở thành vật đối với mặt thứ hai. Chúng ta sẽ xem xét thấu kính dày trước rồi cho độ dày của thấu kính xấp xỉ bằng không để có kết quả cho thấu kính mỏng.
Xét một thấu kính đặt trong không khí, thấu kính có chiết suất _n_ và được giới hạn bởi hai mặt cầu có bán kính là 𝑅1 và 𝑅2 như ở hình 36.21. Một vật được đặt ở _O_ sẽ cho ảnh tạo bởi bề mặt 1 ở _I_ 1 xác định bởi 𝑞1 thỏa phương trình

1

𝑝1

𝑛
+
𝑞1
𝑛 − 1
=
𝑅1
(36.10)
Nếu ảnh là ảo (như trong hình 36.21a) thì 𝑞1 < 0 và nếu ảnh là thật (như trong hình 36.21b) thì 𝑞1 > 0.
![](images/image26.png)![](images/image27.png)

_Hình 36.21_

Đối với bề mặt thứ hai, vật và ảnh xác định bởi 𝑝2 và 𝑞2 thỏa phương trình

𝑛

𝑝2

1
+
𝑞2
1 − 𝑛
=
𝑅2
(36.11)
Gọi _t_ là độ dày của thấu kính thì 𝑝2 = −𝑞1 \+ 𝑡. Đối với thấu kính mỏng (bề dày rất nhỏ so với các bán kính là 𝑅1 và 𝑅2) thì có thể bỏ qua _t_ nên 𝑝2 = −𝑞1. Phương trình 36.11 trở thành
𝑛
−
𝑞1
1
+
𝑞2
1 − 𝑛
=
𝑅2
(36.12)
Kết hợp hai phương trình 36.10 và 36.12 chúng ta thu được
1 1 1 1
![](images/image28.png)+ = (𝑛 − 1) ( − ) (36.13)

𝑝1

𝑞2

𝑅1

𝑅2
Với thấu kính mỏng, gọi _p_ và _q_ lần lượt là khoảng cách ảnh và khoảng cách vật như hình 36.22 thì phương trình 36.13 được viết lại thành
1 1 1 1
![](images/image17.png) + ![](images/image17.png) = (𝑛 − 1) ( − ) (36.14)

𝑝 𝑞

𝑅1

𝑅2
Tiêu cự _f_ của một thấu kính mỏng là khoảng cách ảnh của vật ở xa vô cùng. Theo định nghĩa này chúng ta thu được công thức để xác định _f_ là
_Hình 36.22_
1 1 1
![](images/image17.png) = (𝑛 − 1) ( − ) (36.15)
𝑓 𝑅1 𝑅2
Chúng ta có thể viết phương trình 26.14 theo _f_ như sau
1 1 1 ![](images/image17.png) + ![](images/image15.png) = ![](images/image17.png)
𝑝 𝑞 𝑓
(36.16)
Phương trình 36.16 được gọi là phương trình thấu kính mỏng.
Một thấu kính có hai tiêu điểm 𝐹1 , 𝐹2 và hai tiêu điểm này có cùng khoảng cách tới thấu kính. Có hai loại thấu kính: thấu kính hội tụ và thấu kính phân kỳ. Hình 36.23 là một số hình dạng của hai loại thấu kính này.

![](images/image31.png)![](images/image32.png)

_Hình 36.23. (a) Thấu kính hội tụ. (b) Thấu kính phân kỳ Bảng 36.2 \- Quy ước dấu cho thấu kính._


| Đại lượng | Dương khi | Âm khi |
| --- | --- | --- |
| p | Vật ở trước thấu kính (vật thật) | Vật ở sau thấu kính (vật ảo) |
| q | Ảnh ở sau thấu kính (ảnh thật) | Ảnh ở trước thấu kính (ảnh ảo) |
| h’ | Ảnh cùng chiều với vật | Ảnh ngược chiều với vật |
| R1vàR2 | Tâm của mặt cầu ở sau thấu kính | Tâm của mặt cầu ở trước thấu kính |
| f | Thấu kính hội tụ | Thấu kính phân kỳ |

 

### Độ phóng đại ảnh.

ℎ′ 𝑞

𝑀 = = − ![](images/image17.png) ℎ 𝑝
(36.17)

  * Khi 𝑀 > 0 thì ảnh cùng chiều với vật, ảnh và vật ở cùng phía so với thấu kính.

  * Khi 𝑀 < 0 thì ảnh ngược chiều với vật, ảnh và vật ở hai phía so với thấu kính.


### Các tia sáng đặc biệt

Để dựng ảnh của vật qua thấu kính cho thuận tiện, chúng ta vẽ hai trong ba tia sáng xuất phát từ đỉnh của vật đến thấu theo các phương đặc biệt sau:

### Đối với thấu kính hội tụ

  * Tia sáng tới thấu kính song song với trục chính, tia khúc xạ qua thấu kính đi qua tiêu điểm ở sau thấu kính.

  * Tia sáng tới qua tiêu điểm (hoặc có phương qua tiêu điểm) ở trước thấu kính, tia khúc xạ qua thấu kính song song với trục chính.

  * Tia sáng tới qua tâm của thấu kính cho tia khúc xạ truyền thẳng.


### Đối với thấu kính phân kỳ

### 

  * Tia sáng tới thấu kính song song với trục chính, tia khúc xạ qua thấu kính có phương đi qua tiêu điểm ở trước thấu kính.

  * Tia sáng tới có phương qua tiêu điểm ở sau thấu kính, tia khúc xạ qua thấu kính song song với trục chính.

  * Tia sáng tới qua tâm của thấu kính cho tia khúc xạ truyền thẳng.


![](images/image33.png)

_Hình 36.22. Ảnh của vật qua thấu kính mỏng_
Chỉnh kích thước của hình lớn lên Đánh số sai hình (không đúng thứ tự)

### Bài tập mẫu 36.8: Một thấu kính hội tụ có tiêu cự 10,0 cm.

  1. Một vật đặt cách thấu kính 30,0 cm. Tìm vị trí ảnh và mô tả ảnh. Vẽ hình.


### Giải:

![](images/image34.png)Từ phương trình thấu kính
Suy ra:
1 1 1 ![](images/image17.png) + ![](images/image17.png) = ![](images/image17.png)
𝑝 𝑞 𝑓

𝑞 =

𝑝. 𝑓
𝑝 − 𝑓
30.10
=
30 − 10
= 15 𝑐𝑚
Độ phóng đại ảnh:
𝑞
𝑀 = −
𝑝
15 𝑐𝑚
= −
30 𝑐𝑚
= −0,5
Ảnh của vật là ảnh thật ở sau thấu kính, ngược chiều với vật, cao bằng 0,5 lần vật.

  2. Một vật đặt cách thấu kính 10,0 cm. Tìm vị trí ảnh và mô tả ảnh.


### Giải:

Tương tự câu a,

𝑞 =

𝑝. 𝑓
𝑝 − 𝑓
10.10
=
10 − 10
=> 𝑞 → ∞
Ảnh ở xa vô cùng so với thấu kính

  3. Một vật đặt cách thấu kính 5,0 cm. Tìm vị trí ảnh và mô tả ảnh. Vẽ hình.


### Giải:

![](images/image36.png)Từ phương trình thấu kính, suy ra:

𝑞 =

Độ phóng đại ảnh:
𝑝. 𝑓
𝑝 − 𝑓
5.10
=
5 − 10
= −10 𝑐𝑚
𝑞
𝑀 = −
𝑝

−10 𝑐𝑚

= − = 2

5 𝑐𝑚

Ảnh của vật là ảnh ảo, cùng chiều với vật, cao bằng hai lần vật.
Bổ sung bài tập mẫu 36.9 đối với thấu kính phân kỳ như trong giáo trình gốc

### Hệ thấu kính mỏng.

Giả sử vật được đặt trước hệ gồm hai thấu kính. Ảnh của vật được xác định theo trình tự sau:

  * Xác định ảnh của vật tạo ra bởi thấu kính thứ nhất như là khi không có thấu kính thứ hai.

  * Ảnh tạo ra bởi thấu kính thứ nhất là vật của thấu kính thứ hai. Nếu vật này ở sau thấu kính thứ hai thì vật này là vật ảo (nghĩa là 𝑝 < 0).


Ảnh tạo bởi thấu kính thứ hai là ảnh tạo bởi hệ thống hai thấu kính trên. Độ phóng đại ảnh của hệ hai thấu kính:
𝑀 = 𝑀1. 𝑀2 (36.18)
Cách thức xác định ảnh như trên cũng được sử dụng cho hệ gồm nhiều hơn hai thấu kính.
Trong trường hợp hệ hai thấu kính được đặt sát nhau thì ảnh của vật tạo bởi hệ giống như ảnh tạo bởi một thấu kính có tiêu cự _f_ thỏa phương trình:
trong đó 𝑓1 và 𝑓2 là tiêu cự của hai thấu kính.

### Bài tập mẫu 36.10:

1 1
![](images/image17.png) =
𝑓 𝑓1
1
+
𝑓2
(36.19)
Hai thấu kính hội tụ mỏng có tiêu cự lần lượt là 𝑓1 = 10,0 𝑐𝑚 và 𝑓2 = 20,0 𝑐𝑚 được đặt cách nhau 20 cm. Một vật ở bên trái thấu kính thứ nhất và cách thấu kính này 30 cm. Tìm vị trí và độ phóng đại của ảnh tạo ra bởi hệ hai thấu kính.

### Giải:

![](images/image37.png)Vị trí của ảnh tạo ra bởi thấu kính thứ nhất:

𝑞1 = 𝑝

𝑝1𝑓1

− 𝑓
30.10
=
30 − 10
1 1
= 15 𝑐𝑚
Độ phóng đại ảnh này bằng:
𝑞1
𝑀1 = − 𝑝 = −0,5
Vật của thấu kính thứ hai (là ảnh trên) có khoảng cách vật là:
_Hình 36.30. Ví dụ_
𝑝2 = 𝑡 − 𝑞1 = 20 𝑐𝑚 − 15 𝑐𝑚 = 5 𝑐𝑚
Vị trí của ảnh tạo ra bởi thấu kính thứ hai:

𝑞2 = 𝑝

𝑝2𝑓2

− 𝑓
5.20
= = −6,67 𝑐𝑚
5 − 20

2 2

Độ phóng đại ảnh này bằng:

𝑞2

6,67𝑐𝑚

𝑀2 = − 𝑝 = −

= 1,33
5𝑐𝑚
Độ phóng đại của ảnh tạo ra bởi hệ hai thấu kính:
𝑀 = 𝑀1. 𝑀2 = −0,667
Nghĩa là ảnh tạo ra bởi hệ ở trước thấu kính thứ hai, ngược chiều với vật và nhỏ hơn vật.

## Quang sai

Các kết quả phân tích của chúng ta về gương và thấu kính được thực hiện với điều kiện các tia sáng tạo với trục chính một góc nhỏ (điều kiện tương điểm) và thấu kính là mỏng. Dưới các điều kiện này, mọi tia sáng đi từ một nguồn điểm đều hội tụ tại một điểm nên ảnh thu được sẽ sắc nét. Khi các điều kiện này không được thỏa, ảnh sẽ không hoàn hảo.
Để phân tích chính xác về ảnh, chúng ta cần dùng định luật Snell để xác định sự phản xạ và khúc xạ cho mỗi tia sáng khi bị phản xạ hoặc khúc xạ ở các bề mặt. Theo cách thực hiện này, một điểm trên vật sẽ không tương ứng một điểm ảnh duy nhất và như vậy ảnh bị nhòe. Sự sai lệch của ảnh thực tế so với ảnh dự đoán (nhờ các kết quả thu được ở các nội dung trước) được gọi là quang sai.

### Các loại quang sai Cầu sai

Quang sai loại này xảy ra do tiêu điểm ứng với chùm tia sáng tới càng xa trục chính của thấu kính (hoặc gương) sẽ khác với tiêu điểm ứng với chùm tia sáng tới đi gần trục chính như hình minh họa 36.31 và 36.8. Nguyên nhân gây ra cầu sai là do sử dụng các thấu kính(hoặc gương) có bề mặt hình cầu.
Nhiều máy ảnh có khẩu độ điều chỉnh được để thay đổi cường độ sáng và giảm bớt cầu sai. Bằng cách giảm khẩu độ, ảnh thu được sẽ rõ nét nhưng cần tăng thời gian phơi sáng.
![](images/image38.png) _Hình 36.31_
Đối với gương, để giảm cầu sai thì dùng gương parabol thay cho gương cầu.

### Sắc sai

![](images/image40.png)Sắc sai xảy do chiết suất của môi trường trong suốt phụ thuộc vào bước sóng ánh sáng. Vì vậy khi sử dụng ánh sáng trắng, tia màu tím bị khúc xạ mạnh hơn tia màu đỏ. Điều này dẫn đến kết quả là tiêu cự thấu kính giảm dần đối với ánh sáng có màu từ đỏ đến tím như hình 36.32.
Sắc sai làm mờ ảnh. Để giảm sắc sai, có thể dùng kết hợp một thấu kính hội tụ và một thấu kính phân kỳ làm
bằng hai loại thủy tinh có chiết suất khác nhau.

## Máy ảnh

Máy ảnh là một thiết bị quang học đơn giản được mô tả như hình 36.33. Máy ảnh gồm một buồng tối, một thấu kính hội tụ để tạo ra ảnh thật và một bộ phận nhạy sáng (để lưu ảnh) được điều chỉnh ở đúng vị trí của ảnh.
Máy ảnh sẽ lưu ảnh trên phim hoặc được số hóa để lưu thông tin về ảnh vào một thẻ nhớ (máy ảnh kỹ thuật số). Bằng cách thay đổi khoảng cách từ thấu kính đến bộ phận lưu ảnh cho phù hợp chúng ta sẽ thu được ảnh rõ nét của vật.
Chưa nhắc đến khẩu độ

## Mắt

_Hình 36.32_

![](images/image42.png)

_Hình 36.33: Máy ảnh kỹ thuật số_
Giống như máy ảnh, mắt hội tụ áng sáng và tạo ra ảnh rõ nét. Mắt điều chỉnh lượng sáng đi vào và tạo ảnh bằng một cơ chế rất phức tạp, chính xác và hiệu quả hơn rất nhiều so

![](images/image43.png)

_Hình 36.34: Các thành phần cơ bản của mắt_
với một máy ảnh tinh vi. Mắt thực sự là một kỳ quan sinh lý học.Hình 36.34 trình bày các thành phần cơ bản của mắt.
Giác mạc là một màng mỏng cứng và trong suốt cho phép ánh sáng đi vào mắt. Lòng đen điều chỉnh lượng ánh sáng vào mắt bằng cách mở rộng ra khi gặp ánh sáng yếu hoặc thu hẹp lại khi gặp ánh sáng mạnh. Hệ thống giác mạc và thủy tinh thể hội tụ ánh sáng vào võng mạc, nơi đây gồm hàng triệu tế bào cảm thụ ánh sáng. Khi bị ánh sáng kích thích, các tế bào này sẽ gửi các xung về não nhờ các dây thần kinh thị giác giúp chúng ta cảm nhận được vật. Ảnh của vật được cảm nhận rõ khi ảnh này hiện ra ở võng mạc.
Khi cần nhìn một vật, hình dạng của thủy tinh thể được thay đổi (tiêu cự của thủy tinh thể thay đổi theo) cho phù hợp nhờ cơ vòng. Quá trình này gọi là sự điều tiết. Do khả năng điều tiết bị hạn chế nên mắt chỉ thấy rõ vật khi vật được đặt trong một khoảng giới hạn gọi là giới hạn nhìn rõ của mắt. Điểm gần mắt nhất của giới hạn nhìn rõ gọi là điểm cực cận và điểm xa mắt nhất gọi là điểm cực viễn. Người có mắt bình thường thì điểm cực cận cách mắt trung bình khoảng 25 cm và điểm cực viễn ở xa vô cùng. Tuy nhiên khi người càng lớn tuổi khoảng cách từ cực cận đến mắt sẽ tăng.
Có hai loại tế bào cảm thụ ánh sáng: tế bào hình que và tế bào hình nón. Tế bào hình que rất nhạy cảm với ánh sáng giúp chúng ta nhìn trong tối nhưng không phân biệt được màu sắc. Tế bào hình nón nhạy cảm với các bước sóng khác nhau của ánh sáng. Tế bào hình nón được chia thành ba loại: đỏ, xanh lá cây và xanh dương. Nếu hai loại tế bào hình nón đỏ và xanh là cây kích thích đồng thời, bộ não sẽ hiểu là màu vàng. Nếu cả ba loại tế bào hình nón đều bị kích thích đồng thời bởi các ánh sáng đỏ, xanh lá cây và xanh dương thì bộ não sẽ hiểu là màu trắng. cả ba loại tế bào hình nón đều bị kích thích đồng thời bởi các ánh sáng với mọi màu sắc khác nhauthì bộ não cũng sẽ hiểu là màu trắng.

### Các tật của mắt Viễn thị

### 

Người bị viễn thị có thể nhìn rõ các vật ở xa nhưng không thể nhìn rõ các vật ở gần. Điểm cực cận của mắt người bị viễn thị ở xa hơn so với người có mắt bình thường. Khi nhìn các vật ở gần, khả năng khúc xạ của giác mạc và thủy tinh thể không đủ để hội tụ ánh sáng trên võng mạc (Hình 36.37a). Tật này có thể khắc phục bằng cách đeo kính hội tụ (Hình 36.37b) để hội tụ ánh sáng trên võng mạc.

![](images/image45.png)

_Hình 36.37_

### Cận thị

![](images/image47.png)

_Hình 36.38_

Người bị cận thị có thể nhìn rõ các vật ở gần nhưng không thể nhìn rõ các vật ở xa. Điểm cực viễn của mắt người bị cận thị không ở xa vô cực (như mắt bình thường) và có thể cách mắt nhỏ hơn 1m. Tiêu cự lớn nhất của mắt cận thị không đủ để tạo ra ảnh rõ nét của vật ở xa trên võng mạc mà ở trước võng mạc nên mắt không nhìn rõ được vật (Hình 36.38a). Tật này có thể khắc phục bằng cách đeo kính phân kỳ (Hình 36.38b) giúp điểm hội tụ ở trên võng mạc.
ss

# Public_148

Quang sóng là một nghiên cứu liên quan đến hiện tượng mà không thể được giải thích một cách đầy đủ bằng quang hình học. Đôi khi được gọi là quang vật lý. Những hiện tượng này bao gồm: giao thoa, nhiễu xạ, phân cực. Trong chương 18, chúng ta đã

nghiên cứu về mô hình giao thoa sóng và thấy rằng sự chồng chất của hai sóng cơ học có thể được tăng cường hay bị triệt tiêu. Trong cấu trúc giao thoa, biên độ của sóng tổng hợp lớn hơn biên độ của sóng thành phần nếu ở đó hiện tượng giao thoa được tăng cường (cực đại giao thoa). Trong khi đó, giao thoa triệt tiêu (cực tiểu giao thoa) có biên độ tổng hợp nhỏ hơn biên độ của sóng lớn hơn (khi có hai nguồn sóng). Sóng ánh sáng cũng giao thoa với nhau. Về cơ bản, tất cả sự giao thoa liên quan đến sóng ánh sáng phát sinh khi điện từ trường tạo thành sự kết hợp các sóng đơn lẻ.

# Giao thoa

### Sơ lược lịch sử

Người đầu tiên đề ra thuyết sóng ánh sáng có sức thuyết phục là nhà vật lý người Hà Lan Christiaan Huygens năm 1678. Ưu điểm lớn của nó là giải thích được những định luật về phản xạ và khúc xạ theo thuyết sóng và ý nghĩa vật lý của chiết suất.


|  | ![](images/image1.png)![](images/image2.png)![](images/image3.png)![](images/image4.png)![](images/image5.png)![](images/image6.png)![](images/image7.png)![](images/image8.png)![](images/image9.png)![](images/image10.png)![](images/image11.png)Cực đại giao thoa tương ứng
vớimột vân sáng trong hình bS1 S2B![](images/image23.png)Màn quan sátNhững điểm hai sóng gặp nhau![](images/image25.png)a b | Hình 37.1:(a) Sơ đồ thí nghiệm giao thoa
khe Young. Hai khe S1 và S2 được xem như hai nguồn sóng ánh sáng kết hợp
tạo thành sự giao thoa trên màn chắn (hình vẽ không theo tỷ lệ). (b)
Bứctranh giao thoa được phóng to từ màn chắn. |
| --- | --- | --- |

 

Năm 1801, Thomas Young là người đầu tiên xây dựng lý thuyết sóng của ánh sáng trên một cơ sở thực nghiệm vững vàng khi chứng minh rằng hai sóng ánh sáng chồng lên nhau có thể giao thoa với nhau. Sơ đồ dụng cụ thí nghiệm của Young được thể hiện như trong hình

37.1a. Sóng ánh sáng của máy bay đến một rào chắn B (chứa hai khe S1 và S2). Ánh sáng từ hai khe S1, S2 tạo ra trên màn quan sát thành các dải sáng, tối (được gọi là vân giao thoa) song song và cách đều nhau (hình 37.1b). Khi tia sáng từ hai khe S1 và S2 hội tụ tại một điểm trên màn cùng một lúc thì chúng tăng cường lẫn nhau và tạo thành vân sáng (cực đại giao thoa) tại điểm đó. Ngược lại, khi ánh sáng từ hai khe triệt tiêu nhau tại bất cứ vị trí nào trên màn thì chúng triệt tiêu lẫn nhau và tạo thành vân tối (cực tiểu giao thoa).

### Giao thoa ánh sáng

Hình 37.2 cho thấy hình ảnh giao thoa thực sự tạo nên trên bề mặt của một bể chứa nước. Các sóng được phát đi từ hai quả cầu nối với cùng một máy rung cơ học và dao động lên xuống đối với mặt nước. Hai quả cầu này làm nhiệm vụ giống như hai khe S1 và S2 của hình 37.1, chúng là các nguồn của hai sóng chồng lên nhau để tạo nên hình ảnh giao thoa.


| ![](images/image27.jpeg) | Hình 37.2:Bức tranh giao thoa thu được từ
các sóng nước được tạo ratừ hai nguồn rung trên bề mặt của một bể nước. |
| --- | --- |

 

Ánh sáng từ hai khe hẹp hình thành một ảnh hiển thị trên màn quan sát. Ảnh gồm một loạt những vạch sáng tối xen kẽ song song nhau được gọi là vân.

  * Giao thoa cực đại (tăng cường) sẽ xảy ra nơi mà một vân sáng xuất hiện.

  * Giao thoa cực tiểu (triệt tiêu) sẽ hình thành một vân tối.


### Cực đại giao thoa

Giả sử có hai sóng giao thoa xảy ra tại điểm O. Hai sóng lan truyền cùng một khoảng cách. Do đó, chúng đến cùng pha. Kết quả là, giao thoa xảy ra tại điểm này và một vân sáng trung tâm sẽ được quan sát (hình 37.3a).

Sóng tần số thấp hơn phải lan truyền xa hơn sóng tần số cao để đạt đến điểm P. Sóng tần số thấp hơn sẽ lan truyền một bước sóng lớn hơn. Do đó, các sóng đến cùng pha. Một vân sáng thứ hai xảy ra tại vị trí này (hình 37.3b).

### Cực tiểu giao thoa

Sóng tần số cao lan truyền xa hơn một nửa bước sóng so với sóng có tần số thấp để đạt đến điểm R. Sóng có tần số cao trùng với đỉnh của sóng có tần số thấp hơn nên giao thoa bị triệt tiêu (hình 37.3c).

![](images/image28.jpeg)

_**Hình 37.3:**_ Trong thí nghiệm giao thoa của Young, ánh sáng nhiễu xạ từ hai khe S1, S2 chồng trên nhau tạo nên các điểm giao thoa trên màn quan sát: (a) vân sáng trung tâm, (b) cực đại giao thoa, (c) cực tiểu giao thoa.

_Điều kiện giao thoa:_ Để xuất hiện hình ảnh giao thoa trên màn quan sát từ hai nguồn phải thỏa mãn những điều kiện sau đây:

  * Các nguồn phát ánh sáng là nguồn kết hợp, có nghĩa là hiệu số pha dao động phải không đổi theo thời gian.

  * Các nguồn sáng đơn sắc, có nghĩa là chúng phải có cùng một giá trị bước sóng.


### Cách tạo các nguồn kết hợp

Ánh sáng từ một nguồn đơn sắc được sử dụng để chiếu vào một rào chắn. Rào chắn chứa hai khe hở (hẹp), có hình dạng rãnh (như thí nghiệm của Young được minh họa trong hình 37.1).

Ánh sáng ló ra từ hai khe sáng tương quan nhau vì một nguồn duy nhất sẽ tạo ra chùm sáng ban đầu, đây là một phương pháp thường được sử dụng.

### Nhiễu xạ qua khe Young

Nếu ánh sáng vẫn lan truyền theo hướng ban đầu sau khi đi qua các khe thì không có hiện tượng giao thoa (hình 37.4a). Theo nguyên lý Huygens, sóng phát ra từ các khe sẽ bị lan ra (phân kỳ) thành nhiều hướng khác nhau được gọi là nhiễu xạ (hình 37.4b).

![](images/image29.jpeg)
_**Hình 37.4:**_ (a) Nếu sóng ánh sáng không lan ra sau khi đi qua các khe hẹp thì không xảy ra hiện tượng giao thoa. (b) Sóng ánh sáng từ hai khe chồng chất lên nhau khi chúng bị nhiễu xạ.

# 37.2. Thí nghiệm giao thoa khe Young kép

Hình 37.5 cho thấy tia sáng truyền từ hai khe S1 và S2 trên màn B đến một điểm P trên màn quan sát. Màn quan sát được đặt vuông góc với khoảng cách từ màn chắn chứa hai khe một khoảng L. Trục chính được vẽ từ điểm chính giữa hai khe đến màn quan sát, P được xác định bởi góc θ với trục chính, y là khoảng cách từ điểm P đến trục chính.

![](images/image30.jpeg)

_**Hình 37.5:**_ (a) Cấu trúc hình học mô tả thí nghiệm giao thoa khe Young (hình vẽ không theo tỷ lệ). (b) Khi L >>d chúng ta xem gần đúng các tia r1 và r2 song song với nhau khi chúng đến P.

Sóng ánh sáng đi qua S2 cùng pha với sóng ánh sáng đi qua S1 vì hai sóng này là những phần của một sóng duy nhất dọi vào màn chắn B. Tuy nhiên, sóng đến P từ nguồn S2 không thể cùng pha với sóng đến P từ S1 vì rằng sóng thứ hai phải đi qua một quãng đường dài hơn sóng thứ nhất.

_Điều kiện cực đại giao thoa:_ Nếu như hiệu quang lộ bằng không hoặc bằng một bội số nguyên lần bước sóng thì các sóng tới sẽ cùng pha với nhau và khi giao thoa sẽ tăng cường nhau, tạo thành cực đại giao thoa (vân sáng).

δ = dsin θ = mλ, với m = 0, ± 1, ± 2....

Khi: m = 0, gọi là cực đại bậc không. m = ±1, gọi là cực đại bậc một. m = ±2, gọi là cực đại bậc hai.

(37.2)

Hiệu quang lộ δ (đối với giao thoa cực đại) tương ứng với độ lệch pha 2π rad. Hiệu quang lộ cùng tỉ lệ với λ khi độ lệch pha φ bằng 2π. Độ lệch pha giữa hai sóng tại P phụ thuộc vào hiệu quang lộ của chúng: δ = r2 − r1 = dsinθ

## φ = 2π δ = 2π dsin θ

λ λ

biểu thức (37.10) cho thấy, độ lệch pha φ phụ thuộc vào góc θ (như trong hình 37.5).

(37.10)

Hình 37.6 là đồ thị của phương trình (37.14) biểu thị cường độ của hình ảnh giao thoa của hai khe như một hàm của dsin θ. Chú ý rằng từ phương trình (37.14) cường độ biến thiên từ 0 tại vân cực tiểu đến Imax tại vân cực đại.

Với hệ nhiều hơn 2 khe hẹp (hình 37.7), ảnh nhiễu xạ chứa các cực đại chính và cực đại phụ. Đối với N khe hẹp thì cường độ của các cực đại chính lớn hơn N2 lần so với cường độ của các cực đại tạo bởi 1 khe hẹp. Khi số khe hẹp tăng lên thì cường độ của các cực đại chính cũng tăng và trở nên hẹp hơn, khi đó, các cực đại phụ giảm theo cường độ tương đối so với các cực đại chính. Số cực đại phụ bằng N−2, trong đó N là số khe hẹp. Hiện tượng giao thoa không thể sinh ra hoặc làm biến mất năng lượng mà chỉ đơn thuần là phân bố lại cường độ ánh sáng trên màn quan sát.

![](images/image31.jpeg)![](images/image32.jpeg)

_**Hình 37.6:**_ Sự phụ thuộc của cường độ ánh sáng vào hiệu quang lộ giữa hai sóng khi màn quan sát được đặt rất xa so với khoảng cách giữa hai khe hẹp ( ![](images/image33.png) ).

_**Hình 37.7:**_ Hình ảnh giao thoa nhiều khe. Khi số khe N tăng lên thì cực đại chính (các đỉnh cao nhất trong mỗi biểu đồ) càng hẹp hơn nhưng vẫn giữ nguyên vị trí và số lượng cực đại phụ tăng lên.

# Gương LLOYD

Trong phương pháp giao thoa khe Young đã tạo được hai nguồn sáng kết hợp xuất phát từ một nguồn duy nhất. Phương pháp đơn giản khác cũng tạo được hai nguồn kết hợp là dùng gương Lloyd. Một nguồn sáng điểm S được đặt gần một gương phẳng và một màn quan sát được đặt ở xa và vuông góc với gương phẳng như hình 37.8. Ánh sáng đến điểm quan sát P trên màn có thể được truyền trực tiếp từ nguồn S hoặc có thể được truyền từ S tới gương, bị phản xạ rồi tới P. Tia phản xạ có thể được xem như xuất phát từ nguồn S’ là ảnh của S qua gương phẳng. S và S’ là hai nguồn sáng kết hợp, tương tự như hai khe Young. Tuy nhiên, những điểm theo lý thuyết (thí nghiệm khe Young) được dự đoán là điểm sáng thì thực tế lại là điểm tối và ngược lại. Điều này chứng tỏ hai nguồn S và S’ ngược pha với nhau.

![](images/image34.png)Xét điểm P’ là giao giữa gương và màn quan sát (P’ cách đều S và S’). Nếu sự khác biệt về quãng đường dẫn đến sự khác biệt về pha thì chúng ta sẽ thấy một vân sáng tại P’ (hiệu quang lộ bằng không), tương ứng với vân sáng trung tâm cho hệ giao thoa hai khe. Thay vào đó, một vân tối được quan sát tại P’. Vậy, khi phản xạ trên bề mặt gương, tia phản xạ ngược pha với tia tới hay quang lộ của tia phản xạ tăng thêm nửa bước sóng.

Xung phản xạ trên một sợi dây đàn hồi trải qua sự thay đổi pha 180o khi bị phản xạ từ ranh giới của một sợi dây dày hoặc một trụ chống đỡ cố định, nhưng không có sự thay đổi pha khi xung được phản xạ từ sợi dây mãnh hoặc một trụ chống đỡ cố định. Tương tự, một sóng điện từ bị thay đổi pha 180o (hay π rad) khi bị phản xạ từ môi trường có chiết suất lớn hơn chiết suất của môi trường

tới (hình 37.9a). Nếu phản xạ từ môi trường có chiết suất nhỏ hơn chiết suất của môi trường tới thì tia phản xạ không bị thay đổi pha (hình 37.9b). Tương tự như một xung trên một sợi dây bị phản xạ từ một cột chống đỡ.

_**Hình 37.8:**_ Gương Lloyd. Tia phản xạ bị đổi pha 180o.
![](images/image35.jpeg)
_**Hình 37.9:**_ So sáng sự phản xạ của sóng ánh sáng và sóng trên dây:
(a) Sự biến đổi pha do phản xạ, (b) Sự biến đổi pha do đổi pha.

# Giao thoa của màn mỏng

### Giao thoa do phản xạ

Màu sắc mà chúng ta nhìn thấy được từ ánh sáng mặt trời đập trên một bong bóng xà phòng hoặc trên ván dầu là kết quả giao thoa của sóng ánh sáng phản xạ từ mặt ngoài và mặt trong của một bản mỏng trong suốt.

Giả sử các tia sáng lan truyền trong không khí hầu như vuông góc với hai bề mặt của màng mỏng. Tia phản xạ 1 bị phản xạ tại mặt trên (A) trải qua sự biến đổi pha 1800 so với tia tới. Tia 2 bị phản xạ tại bề mặt màng dưới (B) không bị thay đổi pha vì chiết suất của không khí nhỏ hơn màng mỏng. Vì vậy, tia phản xạ 1 bị lệch pha 180o so với tia phản xạ 2, khi đó

hiệu quang lộ giữa chúng là λn ![](images/image36.png)2. Tuy nhiên, tia phản xạ 2 di chuyển xa hơn tia phản xạ 1

![](images/image37.png)Các yếu tố ảnh hưởng tới sự giao thoa:

  * Pha có thể sẽ bị đảo ngược trong sự phản xạ

  * Hiệu quang lộ


_Chú ý:_

  * Các điều kiện sẽ thỏa mãn nếu môi trường ở bề mặt trên của màng mỏng giống với môi trường ở bề mặt dưới của nó. Nếu có những môi trường khác nhau, những điều kiện này sẽ đúng nếu chiết suất cả hai môi trường nhỏ hơn n.

  * Nếu màng mỏng giữa hai môi trường, một môi trường có chiết suất nhỏ hơn màng mỏng và môi trường còn lại có chiết suất cao hơn chiết suất màng mỏng, những điều kiện cho giao thoa cực đại và giao thoa cực tiểu sẽ bị đảo ngược.

  * Với các vật liệu khác nhau trên 2 mặt của màng, có thể có một sự biến đổi pha 1800 tại cả hai bề mặt hoặc không bề mặt nào, do đó phải kiểm tra


(37.18)

hiệu quang lộ và biến đổi pha. _**Hình 37.10:**_ Giao thoa qua màn mỏng.
![](images/image38.jpeg) ![](images/image39.jpeg)
_**Hình 37.11:**_ Giao thoa qua màng mỏng − bong bóng xà phòng.
(a) Một màn mỏng dầu nổi trên mặt nước được thể hiện bằng các hoa văn màu sắc khi ánh sáng trắng tương tác với màn mỏng, (b) Giao thoa qua bong bóng xà phòng, màu sắc có được là do sự giao thoa giữa các tia sáng phản chiếu từ bên trong và bên ngoài bề mặt của
màn xà phòng.

### Vân tròn Newton

Một phương pháp khác để quan sát giao thoa sóng ánh sáng là đặt một thấu kính phẳng

− lồi lên trên tấm thủy tinh phẳng như hình 37.12a. Với sự sắp xếp này, lớp không khí giữa tấm thủy tinh và mặt cong của thấu kính tạo thành một bản mỏng không khí có bề dày thay đổi. Điểm quan sát M nằm trên bề mặt cong của thấu kính, cách quang trục của thấu kính một khoảng r và cách tấm thủy tinh một khoảng d. Nếu bán kính mặt cong R của thấu kính rất lớn so với khoảng cách r và hệ thống được quan sát từ phía trên, gần với trục chính của thấu kính thì ảnh giao thoa quan sát được là các vòng sáng, tối xen kẽ nhau (vân giao thoa quan sát bằng ánh sáng phản xạ với cách bố trí như hình 37.12b là những đường tròn đồng tâm). Ảnh giao thoa này được Newton khám phá ra nên được gọi là vân tròn Newton.

![](images/image40.jpeg)![](images/image41.jpeg)

a b
![](images/image42.png)![](images/image43.png) _ **Hình 37.12:**_ Vân tròn Newton: (a) Thí nghiệm, (b) Hình ảnh vân tròn.

Các vân tròn sáng, tối quan sát được là do hiệu ứng giao thoa của hai chùm tia phản xạ 1 và 2. Chùm tia 1 phản xạ tại bề mặt cong của thấu kính. Chùm tia này không bị đổi pha, vì chiết suất của không khí nhỏ hơn chiết suất của chất làm thấu kính. Chùm tia 2 phản xạ tại bề mặt tấm thủy tinh có chiết suất lớn hơn chiết suất không khí nên pha được tăng thêm 1800, hay quang lộ tăng thêm λ/2. Bán kính của các vân sáng, vân tối phụ thuộc vào bán kính mặt cong R và bước sóng λ.

Vân sáng: bề dày của lớp không khí giữa hai bản thỏa mãn:
d = (2m +1) _λ_

## 4

Vân tối: bề dày của lớp không khí giữa hai bản thỏa mãn:

## d = m λ

2

(37.19)
(37.20)

Các vân giao thoa là các vòng tròn tại tâm O (d<<R). Bán kính của các vân tối thỏa mãn điều kiện:

r2 = R2 −(R − d )2 ≈ 2Rd

(37.21)

Thay thế:

## d = m λ

m 2
m m m

vào biểu thức (37.21), ta được:

rm ≈

(37.22)
**Chiến thuật giải bài toán với giao thoa của màng mỏng:** Khi giải bài toán giao thoa của màng mỏng cần chú ý một số vấn đề sau đây:

_Đặc điểm:_ Nhận dạng nguồn sáng, vị trí của người quan sát.

_Phân loại:_ Nhận dạng màng mỏng gây ra giao thoa
_Phân tích:_

  * Loại giao thoa xuất hiện được xác định bởi mối quan hệ giữa tỷ lệ bước sóng phản chiếu bên trên và bên dưới bề mặt của màng mỏng.

  * Độ lệch pha thay đổi dựa vào hiệu quang lộ hoặc các biến đổi pha xảy ra nếu như phản xạ. Cả hai nguyên nhân cần được xem xét khi xác định giao thoa cực đại và giao thoa cực tiểu.

  * Xác định chiết suất của môi trường để xác định các phương trình đúng.


_Kiểm tra:_ Kiểm tra kết quả tính toán cuối cùng xem có hợp lý hay không, ý nghĩa vật lý như thế nào.

# Giao thoa kế Michelson

Giao thoa kế được phát minh bởi nhà Vật lý người Mỹ A. A. Michelson. Giao thoa kế chia ánh sáng làm hai phần và sau đó tái kết hợp các phần để tạo thành ảnh giao thoa. Thiết bị có thể được sử dụng để đo bước sóng hoặc độ dài với độ chính xác cao.

_Sơ đồ nguyên lý:_ Một tia sáng được chia thành hai tia bởi gương M0. Gương được bố trí nghiêng 450 so với chùm tia tới. Gương đóng vai trò là bộ tách chùm tia, nó truyền qua một nửa tia sáng và phản xạ phần còn lại. Tia phản xạ đi về phía gương M1 (gương M1 có thể di chuyển được) cách M0 một đoạn L1. Tia sáng truyền qua đi về phía gương M2 cách M0 một đoạn L2. Sau khi phản xạ trên M1 và M2, các tia phản xạ tái kết hợp tại M0 và hình thành ảnh giao thoa. Ảnh giao thoa được quan sát bởi kính ngắm Telescope.

_Nguyên lý hoạt động:_ Điều kiện giao thoa cho hai tia sáng được xác định bởi hiệu quang lộ giữa chúng. Khi dịch chuyển gương M1 song song với trục chính của nó và dọc theo

tia sáng ra xa một đoạn λ 4 thì hiệu quang lộ của tia phản xạ tăng thêm λ 2 và hệ vân giao

thoa dịch chuyển đi một nửa khoảng vân. Độ dài của bước sóng ánh sáng được đo bằng cách đếm số vân dịch chuyển cho mỗi lần dịch gương M1.

![](images/image44.jpeg)

_**Hình 37.14:**_ Giao thoa kế Michelson cho thấy đường đi của ánh sáng bắt đầu từ nguồn sáng. Gương M0 tách ánh sáng thành 2 chùm phản xạ từ các gương M1 và M2 trở về M0 và sau đó đến kính ngắm Telescope.

_Ứng dụng:_ Giao thoa kế Michelson đã được sử dụng để bác bỏ ý tưởng Trái đất chuyển động xuyên qua một vòng trời. Một số ứng dụng hiện đại, bao gồm: Quang phổ hồng ngoại biến đổi Fourier (FTIR) và đài quan sát sóng hấp dẫn dùng giao thoa kế Laser (LIGO).

  * Quang phổ hồng ngoại biến đổi Fourier: Được dùng để tạo một phổ với độ phân giải cao trong một khoảng thời gian rất ngắn. Kết quả là một tập hợp các dữ liệu liên quan cường độ sáng phụ thuộc vào vị trí của gương. Nó được gọi là ảnh giao thoa (interferogram). Ảnh giao thoa có thể được phân tích bởi máy tính để cung cấp tất cả các thành phần của bước sóng. Quá trình này được gọi là biến đổi Fourier.

  * Đài quan sát sóng hấp dẫn dùng giao thoa kế Lazer: Thuyết tương đối rộng tiên đoán sự tồn tại của sóng hấp dẫn. Theo lý thuyết của Einstein, trọng lực tương đương với một biến đổi của không gian, những biến đổi này có thể lan truyền trong không gian. Thiết bị LEGO được thiết kế để phát hiện sự biến dạng tạo bởi một rung động khi nó băng qua gần Trái đất. Giao thoa kế sử dụng chùm tia lazer với hiệu quang lộ khoảng vài km. Tại điểm cuối của một nhánh của giao thoa kế, một gương được gắn vào một con lắc lớn. Khi một sóng hấp dẫn đi qua, con lắc di chuyển và tạo ảnh giao thoa tạo bởi các chùm tia lazer từ hai nhánh sẽ thay đổi.


Nhờ giao thoa kế của Michelson mà ta so sánh được chiều dài của _mét mẫu_ so với bước sóng ánh sáng, là cơ sở để định nghĩa _mét_ qua bước sóng ánh sáng. Cũng chính nhờ giao thoa kế của mình, năm 1881, Michelson đã tiến hành thí nghiệm chứng tỏ rằng vận tốc ánh sáng trong chân không là bằng nhau và bằng c = 3.108 m/s trong tất cả các hệ qui chiếu quán tính – là một cơ sở thực nghiệm để Einstein xây dựng _lý thuyết tương đối_ năm 1907.

![](images/image45.jpeg)

_**Hình 37.15:**_ Đài quan sát sóng hấp dẫn bằng giao thoa kế Lazer (LIGO) gần Richland, Washington. Chú ý hai nhánh vuông góc của giao thoa kế Michelson.
**Tóm tắt chương 37**
**Định nghĩa**
**Phân tích mô hình và giải quyết vấn đề**

# Câu hỏi lý thuyết chương 37

  1. Một chùm ánh sáng đơn sắc có bước sóng 500 nm chiếu đến hai khe hẹp cách nhau 2 m. Góc tạo bởi vân sáng thứ hai so với vân sáng trung tâm là?

1. 0,05 rad

2. 0,025 rad

3. 0,1 rad

4. 0,25 rad

5. 0,01 rad

  2. ![](images/image46.jpeg)Một màn bong bóng xà phòng được dựng thẳng đứng trong không khí và quan sát hiện tượng phản xạ ánh sáng như trong hình 37.16. Giải thích tại sao màn bong bóng xà phòng tối ở phần đầu?


#### Hình 37.16

#### 

  3. (a) Trong thí nghiệm giao thoa khe Young, tại sao chúng ta dùng ánh sáng đơn sắc? (b) Nếu sử dụng áng sáng trắng thì hệ vân giao thoa trên màn sẽ thay đổi như thế nào?

  4. Giải thích tại sao khi đặt hai đèn pin gần nhau thì không tạo ra hệ vân giao thoa trên màn quan sát?


# Bài tập chương 37

  1. Người ta thực hiện giao thoa ánh sáng đơn sắc bằng hai khe Young cách nhau 0,32 mm với ánh sáng có bước sóng λ = 500 nm. Hãy xác định số cực đại giao thoa có được khi thay đổi góc lệch −300 < θ < 300.


ĐS: 641 cực đại

  2. Trong thí nghiệm Young về hiện tượng giao thoa ánh sáng, nguồn sáng đơn sắc có bước sóng 530 nm. Khoảng cách giữa hai khe hẹp S1 và S2 là 0,3 mm. Vân giao thoa được hứng trên một màn ảnh đặt sau hai khe, song song với chúng và cách chúng 2 m. Xác định khoảng cách giữa vân tối thứ nhất và thứ hai.


ĐS: 3,53 mm

  3. Chiếu một chùm tia lazer vào hai khe hẹp cách nhau 0,2 mm, khoảng cách từ hai khe đến màn quan sát là 5 m. Xảy ra hiện tượng giao thoa trên màn quan sát. Nếu góc hợp bởi vân sáng trung tâm và vân sáng bậc 1 là 0,1810 thì giá trị bước sóng của nguồn sáng lazer là bao nhiêu.


ĐS: 632 nm

  4. Thí nghiệm giao thoa khe Young được thực hiện với đèn lazer argon (màu xanh lam). Khoảng cách giữa hai khe là 0,5 mm, khoảng cách từ hai khe đến màn quan sát là 3,3 m. Vân sáng đầu tiên cách vân sáng trung tâm một khoảng là 3,4 mm. Hãy xác định giá trị bước sóng của ánh sáng lazer argon.


ĐS: 515 nm

  5. Tại sao trường hợp sau đây không thể xảy ra? Hai khe hẹp trên một tấm kim loại đặt cách nhau 8 mm. Một chùm sóng cực ngắn được chiếu vuông góc đến tấm kim loại đi qua hai khe và được hứng ảnh trên màn quan sát. Cho biết bước sóng của bức xạ là 1,00 cm ± 5%, nhưng chúng ta muốn đo chính xác hơn giá trị của bước sóng. Di chuyển đầu dò sóng cực ngắn dọc theo đường thẳng song song với màn quan sát để khảo sát hình ảnh giao thoa, chúng ta đo được vị trí của vân sáng bậc 1, từ đó xác định được chính xác giá trị bước sóng của nguồn bức xạ.


ĐS: sinθsáng = 1, 25 (không thể xảy ra)

  6. Hai khe Young S1S2 cách nhau một khoảng d được chiếu bằng ánh sáng có bước sóng là 620 nm. Vân sáng đầu tiên (tính từ vân sáng trung tâm) được quan sát tại một góc 150 so với phương ngang. Xác định khoảng cách d giữa hai khe.


ĐS: 240 μm

  7. Thực hiện thí nghiệm Young về giao thoa ánh sáng với các thông số sau: khoảng cách giữa hai khe 0,1 mm, ánh sáng được chiếu có bước sóng 589 nm, khoảng cách từ hai khe đến màn quan sát 4 m.


  1. Xác định hiệu quang lộ của hai sóng tới từ mỗi khe tại vị trí vân sáng bậc ba.

  2. Xác định hiệu quang lộ của hai sóng tới từ mỗi khe tại vị trí vân tối thứ ba. ĐS: (a) 240 μm, (b) 1,47 μm

1. Một khe sáng đơn sắc S phát ra ánh sáng có bước sóng 442 nm chiếu vào hai khe S1 và S2 cách nhau 0,4 mm. Xác định khoảng cách xa nhất đặt màn quan sát, sao cho vị trí của hai vân tối đối diện với hai khe và chỉ có một vân sáng ở giữa chúng.


ĐS: 36,2 cm

  2. Hai loa của một thùng nổ cách nhau 35 cm. Một bộ dao động điện từ tạo ra dao động cho hai loa với cùng tần số là 2 kHz. Xác định góc được tạo bởi đường thẳng vuông góc tại trung điểm của đường nối hai loa để người quan sát nghe được âm có cường độ lớn nhất, nhỏ nhất? Biết tốc độ truyền âm là 340 m/s.


ĐS: âm có cường độ lớn nhất: 00; 29,10; 76,30 âm có cường độ nhỏ nhất: 14,10, 46,80

  3. Một nhà kho ven sông có một số cánh cửa nhỏ hướng ra bờ sông. Hai trong số các của này được mở (hình 37.17). Các bức tường của nhà kho được lót bằng vật liệu hấp thụ âm. Hai người đứng cách hai cánh cửa tại khoảng cách L = 150 m. Người A đứng dọc theo một đường thẳng đi qua điểm giữa hai cánh cửa, người B đứng cách người A một khoảng y = 20 m. Một chiếc tàu ven sông phát ra tiếng còi. Để người A nghe được âm thanh to và rõ, còn người B thì không nghe được âm thì khoảng cách giữa hai cánh cửa mở phải bằng bao nhiêu? Biết bước sóng của nguồn âm là 3 m và giả sử người B đang đứng ở vị trí cực tiểu đầu tiên.


#### ![](images/image47.jpeg) Hình 37.17

ĐS: 11,3 m

  4. Thực hiện thí nghiệm giao thoa qua hai khe (hình 37.18) với: d = 0,15 mm, L = 140 cm, λ = 643 nm, y = 1,8 cm. Hãy xác định:


  1. Hiệu quang lộ δ của sóng từ hai khe tại điểm P.

  2. Mối quan hệ giữa hiệu quang lộ và bước sóng λ.

  3. ![](images/image48.png)Tại điểm P là điểm cực đại, cực tiểu hay trạng thái trung gian? Giải thích? ĐS: (a) 1,93 μm, (b) δ = 3λ, (c) cực đại


#### Hình 37.18

  1. Thực hiện giao thoa ánh sáng như hình 37.19 (hình vẽ không theo tỷ lệ): L = 1, 2 m,


d = 0,12 mm , λ = 500 nm. Hãy xác định độ lệch pha giữa hai sóng tới P khi:

  1. θ = 0,50

  2. y = 5 mm

  3. Giá trị của θ là bao nhiêu khi độ lệch pha là 0,333 rad ?

  4. Giá trị của θ là bao nhiêu khi hiệu quang lộ δ = λ 4


#### ![](images/image49.jpeg)Hình 37.19

ĐS: (a) 13,2 rad, (b) 6,28 rad, (c) 1,27.10−2, (d) 5,97.10−2

  1. ![](images/image50.jpeg)Các tia sáng kết hợp có bước sóng λ chiếu vào hai khe hẹp cách nhau một khoảng d, với góc tới θ1 theo phương ngang (hình 37.20). Các tia ló ra khỏi hai khe một góc θ2 tương ứng.


#### Hình 37.20

Hình ảnh giao thoa cực đại tạo thành bởi các tia sáng được hứng trên màn quan sát đặt cách hai khe khá xa. Hãy chứng minh rằng góc θ2 được xác định như sau:

θ = sin−1 sin θ − mλ 
2  2 d 
 

  2. Hai khe hẹp đặt cách nhau 0,18 mm. Hình ảnh giao thoa được hứng trên màn chắn cách hai khe một khoảng 80 cm bằng ánh sáng có bước sóng 656,3 nm. Hãy xác định phần trăm cường độ cực đại tại khoảng cách y = 0,6 cm so với cường độ cực đại tại vân sáng trung tâm.


ĐS: 96,8%

  3. Cường độ ánh sáng tại một điểm giao thoa hai khe trên màn là 64,0% giá trị cực đại.


  1. Xác định độ lệch pha nhỏ nhất (tính bằng rad) giữa hai nguồn.

  2. Biểu diễn độ lệch pha dưới dạng hiệu quang lộ đối với ánh sáng có bước sóng 486,1 nm.


ĐS: (a) 1,29 rad, (b) δ = r − r = dsin θ = φλ
2 1 2π

  1. Một màng bong bóng xà phòng (chiết suất n = 1,33) bay trong không khí, lớp bong bóng dạng hình cầu, bề dày 120 nm.


  1. Bước sóng của ánh sáng nhìn thấy được phản xạ mạnh nhất là?

  2. Xác định độ dày nhỏ nhất của màng xà phòng (lớn hơn 120 nm) để ánh sáng phản xạ là lớn nhất với cùng giá trị bước sóng.


ĐS: (a) 638 nm, (b) 360 nm

  1. Cho một màng mỏng có chiết suất là 1,5. Chiếu một ánh sáng có bước sóng trong khoảng 0,4 μm ≤ λ ≤ 0,75 μm, góc chiếu tới là 00. (a) Tìm độ dày t nhỏ nhất sao cho để ngoài ánh sáng màu vàng (λ = 0,58 μm) cho cực đại giao thoa còn có giao thoa của một ánh sáng λ khác. (b) Xác định giá trị λ ở câu (a).


ĐS: (a) 0,483 μm, (b) 0,414 μm

  2. Một màng dầu mỏng (n = 1,25) nằm trên mặt ván trơn và ẩm ướt. Ánh sáng đỏ có bước sóng 640 nm và ánh sáng xanh có bước sóng 512 nm bị phản xạ mạnh nhất. Coi các tia sáng được chiếu vuông góc đến màng mỏng. Xác định bề dày của lớn màng dầu?


ĐS: 512 nm

  3. Một vật liệu có chiết suất 1,3 được sử dụng để làm lớp phủ chống sự phản xạ trên bề mặt thủy tinh (n = 1,5). Tính độ dày tối thiểu của lớp vật liệu này để sự phản xạ từ ánh sáng có bước sóng 500 nm là nhỏ nhất.


ĐS: 96,2 nm

  4. Một lớp màng mỏng MgF2 có chiết suất 1,38 được sử dụng để phủ trên ống kính của máy ảnh.


  1. Xác định ba bước sóng dài nhất được tăng cường.

  2. ![](images/image51.jpeg)Có bất kỳ bước sóng ánh sáng nào trong quang phổ có thể nhìn thấy được không? ĐS: (a) 276 nm, 138 nm, 92,0 nm, (b) không (thuộc vùng tử ngoại)

1. Hình 37.21 cho thấy mặt thấu kính có bán kính cong R, đặt trên


một bản thủy tinh phẳng và được dọi từ trên bằng ánh sáng có bước sóng λ. Hình cho thấy các vân giao thoa tròn (gọi là vân tròn Newton) xuất hiện, tương ứng với độ dày thay đổi ek của lớp không khí giữa thấu kính và bản thủy tinh.

  1. ![](images/image52.png)Tìm bán kính r của các vân sáng, thừa nhận

  2. Chứng minh rằng hiệu bán kính các vân sáng liên tiếp cho bởi biểu thức:


#### Hình 37.21

#### 

∆r = r − r ≈
k+1 k

  3. Chứng minh rằng diện tích giữa các vân sáng liên tiếp cho bởi biểu thức:


![](images/image55.png)A = πλR, với k

(chú ý rằng diện tích này không phụ thuộc vào k)

# Public_149

Sóng cơ (mechanical waves) đòi hỏi sự hiện diện của một môi trường trong khi đó sóng điện từ (electromagnetic waves) có thể truyền qua chân không. Các phương trình của Maxwell dựa vào lý thuyết sóng điện từ truyền trong không gian với vận tốc của ánh sáng. Herzt xác nhận những tiên đoán của Maxwell là đúng khi ông đã tạo ra và phát hiện ra sóng điện từ vào năm 1887. Sóng điện từ được tạo ra bằng cách dao động điện tích. Sóng phát ra từ những điện tích có thể dò được tại những nơi rất xa. Sóng điện từ vừa mang năng lượng, vừa mang động lượng.

# Dòng điện dịch và dạng tổng quát của định luật Ampere

### Sơ lược lịch sử

![](images/image1.jpeg)Nhà vật lý lý thuyết Scottish (1831−1879) đã phát triển lý thuyết sóng điện từ của ánh sáng, lý thuyết về động lực của khí và giải thích bản chất màu sắc tự nhiên và chu kỳ của sao Thổ.
Ông đã xây dựng thành công hệ phương trình về trường điện từ và được biết đến với tên gọi hệ phương trình Maxwell. Maxwell là người đã làm được một việc rất quan trọng là khái quát hóa định luật Ampere, đây là một đóng góp rất quan trọng.
Khả năng toán học đáng gờm kết hợp với cái nhìn
sâu sắc tuyệt vời cho phép Maxwell dẫn đầu trong nghiên cứu về điện từ và lý thuyết động học. Ông chết vì ung thư trước khi ông 50 tuổi.

### Sự mở rộng định luật Ampere do Maxwell thực hiện

**James Clerk Maxwell**

(1831–1879)

Trong chương 30, chúng ta đã sử dụng định luật Ampere để phân tích từ trường tạo bởi dòng điện:

![](images/image3.png)![](images/image4.png)![](images/image5.png)

Trong phương trình này, tích phân đường qua bất kỳ đường cong khép kín có dòng
điện chạy qua, dòng điện dẫn chạy qua vòng ampere được xác định: I = dq dt (Trong phần
này, chúng ta sử dụng thuật ngữ “ _dòng điện dẫn_ ” để chỉ dòng điện được mang bởi các hạt mang điện trong dây dẫn để phân biệt nó với một loại dòng điện khác sẽ được giới thiệu sau). Biểu thức trên chỉ đúng nếu điện trường là tĩnh, tức không phụ thuộc vào thời gian. Maxwell đã ghi nhận giới hạn của định luật Ampere và thay đổi biểu thức này trong trường hợp điện trường thay đổi theo thời gian.
![](images/image6.jpeg)Xét một tụ điện được tích điện như hình 34.1. Khi xuất hiện dòng điện dẫn thì điện tích trên bản dương của tụ thay đổi nhưng không có dòng điện nào tồn tại trong khe hỡ giữa hai bản tụ vì không xuất hiện các hạt mang điện. Bây giờ hãy xét hai mặt S1 và S2 được giới hạn bởi cùng một đường P,
![](images/image9.png)![](images/image10.png)![](images/image11.png)định luật Ampere nói rằng xung quanh
đường dẫn P này phải bằng μ0I, trong đó I là cường độ dòng điện tổng cộng qua bất kỳ bề mặt nào được bao bọc bởi đường P.
Khi đường dẫn P được coi là ranh giới của S1
![](images/image12.png)![](images/image16.png)![](images/image17.png)thì trong đó I là dòng điện dẫn qua
mặt S1. Khi đường dẫn P được coi là ranh giới của
![](images/image3.png)![](images/image18.png)![](images/image22.png)S2 thì ∫ B⋅ds = 0 , bởi vì không có dòng điện dẫn
qua mặt S2. Do đó, một trường hợp mâu thuẩn có thể xảy ra từ sự gián đoạn của dòng điện. Maxwell đã giải quyết vấn đề này bằng cách đưa ra một số hạn bổ sung ở phía bên phải của định luật Ampere. Số hạn cộng thêm được gọi là dòng điện dịch (displacement current, Id).
_**Hình 34.1:**_ Hai mặt phẳng S1 và S2 gần một bản của tụ điện được giới hạn bởi đường P.

I ≡ε dΦE

(34.1)

d 0 dt

![](images/image23.png)trong đó, ε0 là hằng số điện môi và ΦE ≡ ∫E ⋅dA là thông lượng electron xuyên qua bề mặt
được giới hạn bởi đường tích phân.
Khi tụ điện đang được tích điện (hoặc phóng điện), sự thay đổi điện trường giữa hai bản cực của tụ được coi là tương đương với dòng điện dẫn trong dây. Do đó, biểu thức dòng điện dịch (34.1) được thêm vào dòng điện dẫn trong định luật Ampere, để đi tới một định luật dạng hoàn thiện hơn mà ở đó từ trường được tạo bởi dòng điện dẫn và điện trường thay đổi theo thời gian (time-varying electric field). Biểu thức tổng quát của định luật Ampere (nhiều người gọi là định luật Ampere−Maxwell.

![](images/image26.png)![](images/image27.png)![](images/image28.png)Id ) = μ0I + μ0ε0

dΦE
dt

(34.2)

![](images/image29.png)Hình 34.2 mô tả sự thay đổi điện trường tồn tại giữa các bản của tụ điện tạo ra một
![](images/image33.png)thông lượng electron. Thông lượng electron qua bề mặt S được xác định: ΦE ≡ ∫E ⋅dA = EA,
trong đó A là diện tích của các bản của tụ điện và E là độ lớn của điện trường đều giữa hai
![](images/image34.jpeg)bản tụ: E = q![](images/image35.png)(ε0A), trong đó q là điện tích trên bản
cực dương của tụ điện, A là diện tích bản cực. Khi đó, thông lượng electron:
ΦE = EA = ε

0

Do đó, dòng điện dịch qua mặt S là:

I = ε

dΦE
= dq
(34.3)
d 0 dt dt
Phương trình (34.3) cho thấy dòng điện dịch trong khe giữa các bản của tụ có cùng một giá trị. Bằng cách xét bề mặt S, chúng ta có thể xác định dòng điện dịch khi nguồn của từ trường trên bề mặt giới hạn. Dòng điện dịch có nguồn gốc vật lý từ điện trường thay đổi theo thời gian. Điểm chính của phần này là từ trường được tạo ra bởi dòng điện dẫn và điện trường thay đổi theo thời gian.
_**Hình 34.2:**_ Khi dòng điện dẫn tồn tại trong các dây dẫn, sự thay đổi điện trường ![](images/image36.png) tồn tại giữa các bản của tụ điện.
_**Câu hỏi 34.1:**_ Trong một mạch RC, tụ điện bắt đầu phóng điện.

  1. Trong quá trình phóng điện, khoảng không gian giữa hai bản của tụ điện. Xuất hiện:

1. Dòng điện dẫn nhưng không có dòng điện dịch

2. Dòng điện dịch nhưng không có dòng điện dẫn

3. Cả hai dòng điện dẫn và dòng điện dịch

4. Không xuất hiện dòng điện

  2. Trong cùng một vùng không gian, xuất hiện:

1. Điện trường nhưng không có từ trường

2. Từ trường nhưng không có điện trường

3. Cả hai điện và từ trường

4. Không xuất hiện điện trường hay từ trường


### Bài tập mẫu 34.1: Dòng điện dịch trong tụ điện

Một điện áp thay đổi hình sin được áp vào hai đầu một tụ điện như trong hình 34.3. Điện dung của tụ điện là C = 8, 00 μF, tần số của điện áp là f = 3, 00 kHz , biên độ điện
áp là ∆Vmax = 30,0 V. Hãy xác định dòng điện dịch giữa hai bản của tụ điện.

### Giải:

_Khái niệm:_ Hình 34.3 biểu diễn sơ đồ mạch điện trong trường hợp này. Hình 343 cho thấy chi tiết của tụ điện và điện trường giữa hai bản tụ.
_Phân loại:_ Chúng ta xác đinh kết quả bằng cách sử dụng các phương trình được đưa ra trong phần này, vì vậy ví dụ này được xem như điển hình.
Tần số góc của nguồn:
![](images/image37.jpeg)
_**Hình 34.3** (bài tập 34.1)_
ω = 2πf = 2π.(3,00.103 ) = 1,88.104 s−1
Sự khác biệt về điện áp qua tụ điện như một hàm theo thời gian:
∆v = ∆V sinωt = 30,0sin(1,88.104 t)
Điện tích của tụ điện: q = C∆vc
Từ phương trình (34.3) về định nghĩa dòng điện dịch:
i = dq = d (C∆v ) = C d (∆V sin ωt) = ωC∆Vcosωt
Thay số:
d dt dt
C dt max
i = (1,88.104s−1 )(8,00.10−6 C)(30,0V)cos(1,88.104 t) = 4,51cos(1,88.104 t)

# Phương trình Maxwell và phát minh của Hertz

Trong lý thuyết thống nhất của Maxwell về điện từ cho rằng, sóng điện từ là một hệ quả tự nhiên của những định luật cơ bản của điện từ học giống như các định luật Newton về chuyển động đối với cơ học. Tuy nhiên cũng có một sự khác nhau rất quan trọng. Einstein đưa ra thuyết tương đối hẹp vào năm 1905, khoảng 200 năm sau thì xuất hiện các định luật Newton và 40 năm sau thì xuất hiện các phương trình Maxwell. Sau khi có lý thuyết tương đối, các định luật Newton phải thay đổi rất nhiều khi tốc độ tương đối đạt đến giá trị xấp xỉ vận tốc ánh sáng. Tuy nhiên, đối với phương trình Maxwell thì không cần thay đổi gì, chúng hoàn toàn phù hợp với thuyết tương đối hẹp.
Các phương trình Maxwell đại diện cho các định luật về điện và từ tính mà chúng ta đã bàn luận, nhưng chúng có hệ quả rất quan trọng. Để đơn giản, các phương trình Maxwell áp dụng cho không gian trống, tức là không có bất cứ vật liệu điện môi hoặc từ tính nào sẽ được trình bày.

### Phương trình Maxwell 1 − Định luật Gauss

Tổng thông lượng điện (electric flux) qua bề mặt kín bất kỳ bằng tổng điện tích bên
![](images/image38.png)![](images/image39.png)trong bề mặt kín chia cho ε0. Định luật này liên quan đến sự phân bố điện tích để tạo ra điện trường.

(34.4)

### Phương trình Maxwell 2 − Định luật Gauss trong từ trường

Từ thông (magnetic flux) toàn phần qua một mặt kín bằng không, có nghĩa là số đường sức từ đi vào phải bằng số đường sức từ đi ra khỏi một mặt kín. Điều này có nghĩa là các đường sức từ không thể bắt đầu hoặc kết thúc tại bất kỳ điểm nào. Nếu điều này đúng thì những đơn cực từ (isolated magnetic monopoles) sẽ được tìm thấy trong tự nhiên. Tuy nhiên, cho đến nay vẫn chưa tìm thấy được.

![](images/image40.png)![](images/image41.png)(34.5)

### Phương trình Maxwell 3 − Định luật Faraday về cảm ứng

Phương trình này dùng để mô tả việc tạo ra điện trường bằng cách làm cho từ trường biến thiên theo thời gian. Theo điện động lực học, tích phân đường của điện trường dọc theo một đường cong khép kín bằng tốc độ biến thiên của từ thông gửi qua diện tích bề mặt được giới hạn bởi đường cong đó. Một hệ quả của định luật Faraday là tồn tại dòng điện dẫn trong vòng dây dẫn đặt trong một từ trường biến thiên theo thời gian.

![](images/image44.png)![](images/image45.png)![](images/image48.png)(34.6)

### Phương trình Maxwell 4 − Định luật Ampere-Maxwell

Định luật Ampere-Maxwell dùng để mô tả việc tạo ra từ trường bằng điện trường biến thiên và dòng điện. Tích phân đường của từ trường dọc theo một đường cong khép kín bằng tổng của μ0 nhân với dòng điện và ε0μ0 nhân với tốc độ biến thiên từ thông gửi qua diện tích
![](images/image49.png)![](images/image50.png)![](images/image54.png)bề mặt được giới hạn bởi đường cong đó:

### Lực Lorentz

∫ B⋅ds = μ0I + ε0μ0
dΦE
dt
(34.7)
Tại một điểm trong không gian tồn tại điện trường và từ trường, lực tác dụng lên một hạt mang điện tích q có thể được tính toán từ điện và từ trường của hạt như sau:

![](images/image55.png)(34.8)

![](images/image29.png)![](images/image56.png)Những phương trình của Maxwell và lực Lorentz mô tả đầy đủ về tương tác điện từ trước đó. Cần chú ý tính đối xứng của hệ bốn phương trình Maxwell. Các phương trình (34.4)
![](images/image29.png)![](images/image56.png)và (34.5) lần lượt là các tích phân mặt của E và B lấy trên một mặt kín. Phương trình (34.6) và (34.7) lần lượt là các tích phân đường của E và B lấy dọc theo một chu vi kín. Phương trình của Maxwell có tầm quan trọng cơ bản không chỉ đối với điện từ học nói riêng và ngành
khoa học nói chung.

### Thí nghiệm của Hertz

![](images/image57.jpeg)Heinrich Rudolf Hertz (1857−1894) là nhà Vật lý người Đức. Ông là người đầu tiên tạo ra sóng điện từ và phát hiện ra sóng điện từ tại phòng thí nghiệm vào năm 1887. Ông cũng chỉ ra một khía cạnh sóng khác của ánh sáng. Những tia lửa điện được cảm ứng qua khoảng trống của hai điện cực của mạch thu, khi hiệu chỉnh tần số của mạch thu trùng với mạch phát. Trong một loạt các thí nghiệm khác, Herzt cũng chỉ ra bức xạ được tạo ra bởi những thiết bị này có thể thể hiện bản chất sóng. Giao thoa, nhiễu xạ, phản xạ, khúc xạ và phân cực. Ông cũng đo được vận tốc bức xạ gần đúng bằng vận tốc của ánh sáng.
_Mô tả thí nghiệm:_ Một cuộn dây cảm ứng được nối với mạch phát. Mạch phát gồm 2 cực dạng hình cầu đặt cách

###   
Heinrich Rudolf Hertz

(1857–1894)
nhau một khoảng rất nhỏ. Cuộn dây cung cấp một điện áp tăng vọt trong một khoảng thời gian ngắn đến các điện cực. Khi đó, không khí ở khoảng giữa 2 điện cực bị oxy hóa và trở thành một dây dẫn tốt hơn. Việc xả điện giữa các điện cực tạo thành một dao động có tần số rất cao, điều này tương đương mạch LC.
Vận tốc của bức xạ điện từ trong chân không là rất quan trọng không những đối với lý thuyết điện từ của Maxwell mà còn đối với cả lý thuyết của Einstein. Trong một không gian trống rỗng ( q = 0 và I = 0 ), hai phương trình (34.6) và (34.7), Maxwell đã tiên đoán rằng ánh
sáng là một dạng bức xạ điện từ (electromagnetic radiation). Thí nghiệm của Hertz cho ta một ví dụ về sự phát sóng điện từ (hình 34.4). Lõi của cuộn dây cung cấp một điện thế cho các điện cực electron, một điện cực dương và một điện cực âm. Trong thí nghiệm đó rõ ràng rằng là điện tích trên hai quả cầu biến thiên một cách tuần hoàn theo thời gian. Một tia lửa điện được tạo ra giữa hai quả cầu khi điện trường của các điện cực lớn hơn cường độ điện trường giữa hai quả cầu trong không khí (3.106 V/m). Các electron tự do trong điện trường mạnh được gia tốc và tích đủ năng lượng để ion hóa các phân tử mà chúng va chạm. Sự ion hóa này tạo ra nhiều electron để gia tốc và gây ra các quá trình ion hóa khác. Khi không khí trong khe bị ion hóa trở thành một chất dẫn điện tốt và sự phóng điện giữa các điện cực làm xuất hiện trạng thái dao động ở tần số rất cao. Theo quan điểm mạch điện, mô hình thí nghiệm của Hertz tương đương với mạch LC, trong đó độ tự cảm của cuộn dây và điện dung của tụ điện được tạo ra từ các điện cực hình cầu.
![](images/image58.jpeg)Bởi vì giá trị của L và C trong thí nghiệm của Hertz là nhỏ và tần số dao động rất lớn,
khoảng 100 MHz (với ω= 1 LC cho mạch dao
động LC). Sóng điện từ phát ra tại giá trị tần số này là kết quả của các electron tự do di chuyển trong mạch điện. Hertz đã ghi nhận các sóng này bằng cách sử dụng một vòng dây đơn với khoảng cách giữa các tia lửa điện (máy thu). Mạch nhận sóng, có độ tự cảm L, điện dung C và tần số dao động f, được đặt cách một vài mét từ máy phát. Trong thí nghiệm của Hertz, các tia lửa điện được tạo ra giữa khoảng không gian giữa hai điện cực của máy thu khi tần số của máy thu được điều chỉnh sao cho trùng với tần số của máy phát. Từ thí nghiệm này, Hertz đã chứng minh được rằng dòng điện trong máy thu được tạo ra bởi sóng điện từ được phát ra từ máy phát.
Ngoài ra, Hertz đã thực hiện một loạt các thí nghiệm liên quan đến bức xạ được tạo ra bởi thiết bị tia lửa của mình nhằm thể hiện các tính chất sóng của hiện tượng giao thoa, nhiễu xạ, phản xạ, khúc xạ và phân cực. Đó là tất cả các tính chất của ánh sáng như chúng ta đã được biết. Sóng vô tuyến mà Hertz đã tạo ra có các tính chất tương tự như sóng ánh sáng, tuy nhiên chúng khác nhau về tần số và bước sóng. Thí nghiệm thuyết phục nhất của ông là đo tốc độ của bức xạ này. Sóng có
_**Hình 34.4:**_ Sơ đồ thí nghiệm của Hertz để tạo ra và ghi nhận sóng điện từ.
tần số đã biết được phản xạ từ một tấm kim loại và tạo ra mô hình giao thoa sóng. Bằng cách đo khoảng cách giữa hai điểm nút cho phép xác định được giá trị bước sóng λ. Sử dụng mối
quan hệ v = λf trong quá trình lan truyền sóng, Hertz đã tính được vận tốc của sóng điện từ
là v = 3.108 m s , giá trị này được biết đến như vận tốc của ánh sáng khả kiến.

# Sóng điện từ phẳng

Giả sử rằng vector điện trường và từ trường của một sóng điện từ có quan hệ không −

thời gian đặc biệt, phù hợp với các phương trình của Maxwell. Giả sử một sóng điện từ truyền

![](images/image29.png)![](images/image56.png)![](images/image29.png)theo phương x với và B như được minh họa trong hình 34.5. Vector điện trường E hướng
![](images/image56.png)![](images/image29.png)theo phương y và từ trường B hướng theo phương z. Sóng mà trong đó điện trường và từ
![](images/image56.png)trường bị hạn chế là song song với một cặp trục vuông góc được gọi là sóng phân cực tuyến
![](images/image59.jpeg)tính (linearly polarized waves). Giả sử rằng tại bất kỳ mọi điểm trong không gian thì độ lớn của
![](images/image29.png)![](images/image56.png)E và chỉ phụ thuộc vào tọa độ x và thời gian t.
Giả sử nguồn phát sóng điện từ tại bất kỳ
vị trí nào trong mặt phẳng yz. Nếu chúng ta định nghĩa tia (ray) là một đường thẳng mà sóng truyền đi thì tất cả các tia của sóng phân cực tuyến tính đều song song với nhau. Tập hợp của các sóng này được gọi là sóng phẳng (plane waves). Bề mặt nối những điểm cùng pha của tất cả các sóng phẳng gọi là mặt sóng (wave front) có dạng mặt phẳng. Tuy nhiên, khi một nguồn điểm bức xạ phát sóng theo mọi hướng thì bề mặt nối những điểm cùng pha của những vị trí này có dạng hình cầu, sóng này được gọi là sóng cầu (spherical wave).

### Điện trường cảm ứng

_**Hình 34.5:**_ Điện trường và từ trường của sóng điện từ truyền với vận tốc ![](images/image60.png) dọc theo chiều dương của trục x.
Bây giờ chúng ta bắt đầu với định luật Faraday từ phương trình (34.6) để chứng minh sự có mặt của sóng điện từ phẳng:

![](images/image44.png)![](images/image45.png)![](images/image48.png)

### Từ trường cảm ứng

∂E ∂B
∂x =− ∂t
(34.11)
Một cách tương tự, chúng ta có thể suy ra phương trình thứ hai để chứng minh sự tồn tại của sóng điện từ phẳng bằng cách xuất phát từ phương trình thứ tư của Maxwell (phương trình (34.7)).
![](images/image49.png)![](images/image50.png)![](images/image54.png)∫ B⋅ds = μ0I + ε0μ0
dΦE
dt
![](images/image9.png)![](images/image10.png)![](images/image11.png)tích phân lấy ngược chiều kim đồng hồ vòng quanh hình chữ nhật nằm trên mặt phẳng
xz, có chiều rộng dx và chiều dài ![](images/image62.png) như trên hình 34.7. Chú ý rằng độ lớn của từ trường thay
![](images/image63.png)![](images/image64.png)Chúng ta thấy rằng sự thay đổi của thông lượng ΦE sẽ cảm ứng một từ trường với các
vector
và B(x + dx)
có hướng như được vẽ trong hình 34.7. Thông lượng electron
![](images/image66.png)xuyên qua hình chữ nhật ấy là ΦE = E dx , lấy vi phân của thông lượng electron theo thời gian ta có:
∂ΦE
∂t
=

![](images/image67.png)(34.13)

Nếu chúng ta thay phương trình (34.12) và (34.13) vào phương trình (34.7), chúng ta tìm được:

### Sự truyền tải năng lượng

Bằng cách lấy đạo hàm phương trình (34.11) theo x sau đó kết hợp với phương trình (34.14) ta có:

![](images/image68.jpeg)![](images/image69.jpeg)

_**Hình 34.6:**_ Khi sóng đi qua các hình chữ nhật tại điểm P, sự thay đổi từ thông qua hình chữ nhật trong mặt phẳng xy cảm ứng
_**Hình 34.7:**_ Khi sóng đi qua các hình chữ nhật tại điểm P, sự thay đổi điện thông qua hình chữ nhật trong mặt phẳng xz cảm ứng
![](images/image70.png)một điện trường
theo các cạnh của hình chữ nhật ấy.
dọc
một từ trường
![](images/image71.png)các cạnh của hình chữ nhật ấy.
dọc theo

(

Tương tự, lấy đạo hàm phương trình (34.14) theo x sau đó kết hợp với phương trình (34.11) ta có:

## ∂2B = μ ε ∂2B

## 

∂x2

0 0 ∂t2

(34.16)

Phối hợp phương trình (34.15) và (34.16) ta có kết quả cuối cùng:

c = 1

(34.17)

Thay số vào ta được:
c = 1 = 1
= 2,997.108 m s
Chúng ta đã chứng minh rằng phương trình Maxwell (34.6) và (34.7) có nghiệm dạng sóng, với hai thành phần E và B cùng thỏa mãn một phương trình sóng. Sóng điện từ truyền đi với vận tốc bằng vận tốc ánh sáng.
Nghiệm của phương trình (34.15) và (34.16) là sóng dạng hình sin, có độ lớn của vector điện trường và từ trường thay đổi theo x và t theo các biểu thức:

## E = Emax cos(kx − ωt)

B = Bmax cos(kx − ωt)

(34.18)

(34.19)

trong đó: Emax và Bmax là các giá trị cực đại của điện trường và từ trường. Số sóng k = 2π![](images/image72.png)λ,
với λ là bước sóng. Tần số góc ω = 2πf , với f là tần số sóng (Hz). Trong quá trình truyền sóng điện từ, tỷ số ω k bằng tốc độ của sóng điện từ:
ω = 2πf k
= λf = c
![](images/image73.jpeg)Mối quan hệ giữa vận tốc, tần số và bước sóng của một sóng hình sin được xác định theo biểu thức: v = c = λf . Do đó, trong quá trình lan truyền sóng điện từ thì bước sóng và tần số có mối liên hệ với nhau như sau:

## λ = c =

(34.20)

## f f

## 

Hình 34.8 biểu diễn sóng điện từ phân cực tuyến tính hình sin tại một thời điểm di chuyển theo chiều dương của trục x.
_**Hình 34.8:**_ Sóng điện từ hình sin di chuyển theo chiều dương của trục x với vận tốc c.
Bằng việc lấy đạo hàm phương trình (34.18) theo x và phương trình (34.19) theo t, chúng ta có thể biểu diễn toán học quá trình di chuyển của sóng điện từ như sau:

_∂E_ = −kE sin(kx − ωt)

∂x max

_∂B_ = ωB sin(kx − ωt)

∂t max

Thay các kết quả đạo hàm vừa tìm được vào phương trình (34.11) ta được:

kEmax = ωBmax

Emax

Bmax

= ω = c k
Kết hợp phương trình (34.18) và (34.19):

Emax

Bmax

= E = c B

(34.21)

Trong quá trình lan truyền sóng điện từ, tỷ lệ giữa độ lớn cường độ điện trường và cường độ từ trường bằng với tốc độ của ánh sáng. Cuối cùng, cần chú ý rằng sóng điện từ vẫn tuân theo nguyên lý chồng chất như sóng cơ học, bởi vì các phương trình vi phân liên quan đến E và B là các phương trình tuyến tính.
Người ta đã chứng minh được rằng đối với sóng điện từ phẳng đơn sắc:

  1. ![](images/image29.png)![](images/image56.png)![](images/image56.png)![](images/image74.png)Hai vector E và B luôn vuông góc với nhau.

  2. ![](images/image29.png)Ba vector E , góc.


và c , theo thứ tự đó, hợp thành một tam diện thuận ba mặt vuông
_**Câu hỏi 34.2:**_ Một sóng điện từ lan truyền theo chiều âm của trục y. Điện trường tại một điểm trong không gian được định hướng theo chiều dương của trục x. Từ trường tại điểm đó hướng theo chiều nào?

  1. chiều âm của trục x

  2. chiều dương của trục y

  3. chiều dương của trục z

  4. chiều âm của trục z


### Bài tập mẫu 34.2: Sóng điện từ

Một sóng điện từ hình sin có tần số 40,0 kHz truyền trong không gian tự do theo trục x như hình 34.9.

  1. Hãy xác định bước sóng và chu kỳ của sóng.


### Giải

![](images/image75.jpeg) _Khái niệm:_ Hãy tưởng tượng sóng điện từ trong hình 34.9 truyền theo chiều dương của trục x, với điện trường và từ trường dao động cùng pha.
_Phân loại:_ Chúng ta sử dụng biểu thức toán học của mô hình truyền sóng cho song điện từ.
_Phân tích:_ Sử dụng phương trình (34.20) để tìm độ dài bước sóng:
λ = c = 3, 00.108 m s =
f 40, 0.106 Hz
7,50 m
_**Hình 34.9:** (bài tập 34.2)_
Chu kỳ của sóng là nghịch đảo của tần số:
T = 1 = 1
= 2,50.10−8s
f 40, 0.106 Hz

  2. Tại cùng một vị trí và cùng thời gian, điện trường có giá trị cực đại là 750 N/C hướng theo chiều dương của trục y. Hãy xác định cường độ và hướng của từ trường tại vị trí này.


### Giải

Sử dụng phương trình (34.21) để xác định độ lớn của từ trường:

Bmax

= Emax
c
= = 2,50.10−6 T
![](images/image29.png)![](images/image56.png)Bởi vì E và B phải vuông góc với nhau và vuông góc với phương truyền sóng như trên hình 34.9 nên từ trường phải hướng theo trục z.

# Năng lượng sóng điện từ

![](images/image76.png)Trong mô hình hệ không đồng nhất về năng lượng, chúng ta đã xác định bức xạ sóng điện từ như là một phương pháp truyền năng lượng qua mặt giới hạn của một hệ. Phần năng lượng sóng điện từ truyền qua được ký hiệu là TER . Tốc độ truyền năng lượng của sóng điện
từ được mô tả bởi vector S, gọi là vector Poynting, được xác định bởi biểu thức:

![](images/image77.png)![](images/image78.jpeg)![](images/image79.png)μ0

![](images/image76.png)Độ lớn của vector Poynting cho biết tốc độ truyền năng lượng xuyên qua một đơn vị diện tích vuông góc với phương truyền sóng. Do
đó, độ lớn của S đại diện cho năng lượng trên một đơn vị diện tích. Hướng của vector này dọc theo phương truyền sóng (hình 34.10). Đơn vị
(34.22)
![](images/image76.png)của vector S trong hệ SI là

##   
J s.m2 =W

m2 .
![](images/image80.png)Đối với sóng điện từ phẳng:
![](images/image76.png)khi đó độ lớn của S được xác định như sau:

S = EB

μ0

Bởi vì B = E c, khi đó biểu thức (34.23) được viết lại như sau:
(34.23)
Biểu thức độ lớn của S áp dụng tại bất kỳ thời điểm nào và biểu thị cho tốc độ tức thời của năng lượng xuyên qua một đơn vị diện tích ứng với giá trị tức thời của E và B. Đối với sóng điện từ phẳng hình sin thì trung bình theo thời gian S qua một hoặc nhiều chu kỳ được gọi là _cường độ sóng I_. (Cường độ của sóng âm đã được nhắc đến trong chương 17.) Khi thực hiện tính giá trị trung bình này, chúng ta sẽ thu được một công thức miêu tả giá trị trung bình theo
thời gian của cos2 (kx − ωt ) và bằng 1 2 . Khi đó, giá trị trung bình của S (hay nói cách khác
là cường độ sóng) là:
Cường độ của sóng điện từ tỷ lệ với bình phương biên độ của cường độ điện trường hay cường độ từ trường.
Cần nhắc lại rằng năng lượng trên một đơn vị thể tích gắn liền với điện trường, được gọi là mật độ năng lượng tức thời:
và mật độ năng lượng tức thời gắn liền với từ trường:
2

uB = 2μ

0
Do E và B thay đổi theo thời gian đối với sóng điện từ nên mật độ năng lượng cũng thay đổi
theo thời gian. Sử dụng mối liên hệ B = E![](images/image81.png)c và c = 1 μ0ε0 , biểu thức của uB được viết lại như sau:
μ ε 1

u = = _0 0_ E2 = ![](images/image82.png) ε E2

B 2μ 2μ 2
0 0
So sáng kết quả này với biểu thức của uE , ta có:
1 2 B2

uB = uE = 2 ε0E

=
2μ0
Cuối cùng, mật độ năng lượng tức thời của sóng điện từ gắn liền với từ trường bằng với mật độ năng lượng tức thời gắn liền với điện trường. Do đó, đối với một thể tích nhất định thì năng lượng của sóng điện từ được chia đều cho hai thành phần điện trường và từ trường.
Tổng mật độ năng lượng tức thời u của sóng điện từ bằng tổng mật độ năng lượng của điện trường và từ trường:

u = uB + uE = ε0E

= B2
μ
0
Khi giá trị mật độ năng lượng tức thời của sóng điện từ này được tính trung bình trong một hoặc nhiều chu kỳ,
2 1 2 B2

uavg = ε0 (E

avg

= ![](images/image83.png) ε0Emax = _max_

2 2μ0

(34.25)
So sáng kết quả này với biểu thức (34.24) ta có:

I = Savg = cuavg

(34.26)
Nói cách khác, cường độ của sóng điện từ bằng mật độ năng lượng trung bình nhân với vận tốc của ánh sáng.

### Bài tập mẫu 34.3:

Hãy xác định độ lớn cực đại của điện trường và từ trường của ánh sáng khả kiến từ chiếc đèn để bàn chiếu đến một mặt giấy. Coi bóng đèn như một nguồn bức xạ điện từ có hiệu suất phát sáng là 5%.

### Giải

_Khái niệm:_ Dây tóc bóng đèn phát ra bức xạ điện từ. Ánh sáng càng mạnh thì cường độ của điện trường và từ trường càng lớn.
_Phân loại:_ Coi dây tóc bóng đèn như một nguồn sáng điểm phát ra theo mọi hướng. Quá trình lan truyền bức xạ điện từ có thể được mô hình hóa như sóng cầu.
_Phân tích:_ Cường độ sóng tại một điểm cách nguồn một khoảng r được xác định:
I = P 4πr2 , trong đó Pavg là công suất trung bình của nguồn và 4πr2 là diện tích của
hình cầu bán kính r từ nguồn. Khi đó, cường độ của sóng điện từ được cho bởi công thức (34.24):
Pavg E2
I = = _max_
4πr2 2μ c
0
Giải phương trình trên để xác định cường độ điện trường cực đại:

Emax =

Giả sử công suất bức xạ của bóng đèn là 60 W, với hiệu suất là 5% là 3 W (phần năng lượng hao phí do dẫn nhiệt và bức xạ không nhìn thấy). Khoảng cách từ bóng đèn đến mặt cầu là 0,3 m. Thay số ta được:
Emax = = 45V![](images/image84.png)m
Sử dụng biểu thức (34.21) để xác định độ lớn của cường độ từ trường:

Bmax

= Emax
c
= = 1,5.10−7 T
_Kết luận:_ Giá trị này của cường độ từ trường là nhỏ hơn hai bậc so với từ trường của Trái đất.

# Động lượng và áp suất bức xạ

Sóng điện từ vận chuyển động lượng cũng như năng lượng. Khi động lượng này hấp thụ bởi những bề mặt thì áp lực sẽ tác dụng lên các bề mặt này. Giả sử sóng vận chuyển với
![](images/image85.png)tổng năng lượng TER đến bề mặt trong một khoảng thời gian ∆t thì tổng động lượng p
(trường hợp hấp thụ hoàn toàn) được xác định:

p = TER

c

(34.27)
trong đó c là vận tốc ánh sáng. Chiều của sự biến thiên động lượng là chiều của chùm tia tới. Áp suất P gây ra trên một bề mặt được xác định bằng lực tác dụng trên một đơn vị diện tích: F A , kết hợp với định luật II Newton, ta có:

P = F = 1 dp

A A dt
Thay phương trình (34.27) vào biểu thức tính áp suất:

P = _1 dp_ = _1 d_  TER  = _1 (dTER dt)_

A dt A dt  c  c A

 
(dTER ![](images/image86.png)dt)![](images/image87.png)A là tốc độ năng lượng đến bề mặt trên một đơn vị diện tích, được gọi là độ lớn
của vector Poynting. Do đó, áp suất bức xạ P gây ra trên bề mặt hấp thụ hoàn toàn được xác định:

P = S

c

(34.28)

Nếu như bề mặt phản xạ toàn phần (như gương) và bức xạ được chiếu tới thẳng góc thì độ lớn của sự biến thiên động lượng của vật dịch chuyển trong khoảng thời gian ∆t sẽ có giá trị lớn gấp hai lần giá trị động lượng trong công thức (34.27). Điều này có nghĩa, động lượng được truyền trên một bề mặt bởi ánh sáng tới và ánh sáng phản xạ có giá trị bằng nhau là
p = TER
c . Vì vậy,
p = 2TER

c

(34.29)
Áp suất bức xạ gây ra trên một bề mặt phản xạ toàn phần khi bức xạ được chiếu tới thẳng góc là:

P = 2S

c

(34.30)

Đối với bề mặt xảy ra phản xạ một phần, sự thay đổi áp suất nằm giữa S c và 2S![](images/image88.png)c.
Đối với ánh sáng mặt trời trực tiếp, áp suất bức xạ khoảng 5.10−6 N![](images/image89.png)m2 .

### Bài tập mẫu 34.4: Quét ngang Hệ Mặt trời

Một lượng lớn bụi tồn tại trong không gian. Mặc dù trên lý thuyết những hạt bụi này có thể thay đổi về kích thước từ kích thước phân tử tới kích thước lớn hơn, nhưng rất ít bụi trong hệ mặt trời nhỏ hơn 0,2 μm. Giải thích tại sao?

### Giải

Các hạt bụi chịu tác dụng của 2 lực chính: lực hấp dẫn kéo chúng về phía Mặt Trời và lực áp suất-bức xạ đẩy chúng ra xa khỏi Mặt Trời. Lực hấp dẫn tỷ lệ thuận với bậc 3 của bán kính của các hạt bụi hình cầu bởi vì nó tỷ lệ với khối lượng và vì vậy tỷ lệ với
thể tích của hạt 4πr3 3 . Áp suất bức xạ tỷ lệ thuận với bình phương bán kính bởi vì nó
phụ thuộc vào tiết diện cắt ngang của hạt. Đối với các hạt lớn, lực hấp dẫn sẽ lớn hơn lực áp suất bức xạ. Đối với các hạt có bán kính nhỏ hơn 0,2 μm lực gây ra từ áp suất- bức xạ sẽ lớn hơn lực hấp dẫn. Do đó, các hạt bị quét ra khỏi hệ mặt trời bởi ánh sáng mặt trời.

### Bài tập mẫu 34.5: Áp suất của bút chiếu Lazer

Khi trình bày báo cáo, nhiều người sử dụng bút laser để hướng sự chú ý của người theo dõi tới thông tin trên màn hình. Nếu một bút laser 3,0 mW tạo ra một điểm sáng trên màn hình có đường kính 2,0 mm, xác định áp suất bức xạ trên màn hình phản xạ 70% ánh sáng đập vào nó. Công suất 3,0 mW là giá trị được lấy trung bình theo thời gian.

ss

# Public_150

![](images/image1.jpeg)Trong chương 37 chúng ta đã định nghĩa nhiễu xạ một cách không mấy chặt chẽ là sự loe ra của ánh sáng xuất

phát từ một khe hẹp. Tuy nhiên, không đơn giản chỉ là loe ra vì ánh sáng còn tạo nên một bức tranh giao thoa gọi là vân nhiễu xạ. Thí dụ, ánh sáng đơn sắc từ một nguồn ở xa vô cực (hay một lazer) đi qua một khe hẹp và sau đó được hứng bằng một màn quan sát, chúng sẽ tạo nên một bức tranh nhiễu xạ trên

màn như trong hình 38.1. Bức tranh này bao gồm một dải sáng trung tâm mạnh, rộng (gọi là cực đại trung tâm) được bao quanh bởi một dải hẹp và yếu hơn (gọi là cực đại thứ cấp) và một loạt các dải tối xen kẽ.

## Nhiễu xạ ánh sáng

_**Hình 38.1:**_ Hình ảnh nhiễu xạ hiện trên một màn quan sát khi ánh sáng đến màn, sau khi đi qua một khe hẹp dọc. Quá trình nhiễu xạ làm cho ánh sáng loe ra vuông góc với chiều dài của khe.

Sự nhiễu xạ ánh sáng không giới hạn trong trường hợp khi ánh sáng đi qua một khoảng trống hẹp mà nó còn xảy ra khi ánh sáng đi qua một cạnh (mép) của đối tượng, chẳng hạn như hình 38.2. Chú ý rằng, các đường cực đại và cực tiểu chạy dọc gần như song song với nhau để tạo nên bức tranh dọc theo mép trái. Một lần nữa, chúng ta thấy hình ảnh các vân sáng và tối, giống như hình ảnh giao thoa trong chương 37.

![](images/image3.png)

_**Hình 38.2:**_ Ảnh nhiễu xạ qua cạnh của một vật.

Ánh sáng có bước sóng tương đương hoặc lớn hơn chiều rộng của một khe hẹp sẽ lan truyền mọi hướng trước khi đi qua khe. Hiện tượng này gọi là nhiễu xạ ánh sáng. Điều này

chỉ ra rằng ánh sáng lan truyền hướng qua khe hẹp đến được cả những khu vực đáng ra tạo thành vùng tối nếu như ánh sáng truyền thẳng.

_Phân loại:_ Gọi L, d là khoảng cách từ vân nhiễu xạ đến màn quan sát và nguồn sáng.

Ta có hai loại nhiễu xạ:

  * Nếu L, d là hữu hạn thì sóng phát ra từ S là sóng cầu: nhiễu xạ của sóng cầu được gọi là nhiễu xạ Fresnel

  * Nếu L, d là vô hạn thì sóng phát ra từ S là sóng phẳng: nhiễu xạ của sóng phẳng được gọi là nhiễu xạ Fraunhofer.


#### Chấm sáng Fresnel

![](images/image4.jpeg)Hình 38.3 cho thấy một mẫu nhiễu xạ kết hợp với bóng của một đồng xu. Một điểm sáng xuất hiện ở trung tâm, và các đường viền hình tròn mở rộng ra ngoài từ mép của bóng đồng xu. Chúng ta có thể giải thích điểm sáng trung tâm bằng cách sử dụng lý thuyết sóng ánh sáng và dự đoán xuất hiện cực đại giao thoa tại vị trí này. Từ quan điểm của tia quang học (trong đó ánh sáng được xem là tia di chuyển theo đường thẳng), chúng ta dự đoán tại tâm của ảnh nhiễu xạ là một bóng tối vì màn quan sát được che chắn hoàn toàn bởi đồng xu.

Quan điểm của Newton là quan điểm thịnh hành trong giới khoa học Pháp thời bấy giờ. Sau đó mới đến Fresnel, một kỹ sư quân đội trẻ theo đuổi sự đam mê của mình đối với quang học đến nỗi sao

nhãng cả nhiệm vụ quân đội. Fresnel tin tưởng vào thuyết sóng ánh sáng và gửi một bài báo cho Viện Hàn Lâm khoa học để mô tả những thí nghiệm của mình và cách giải thích những thí nghiệm ấy bằng thuyết sóng.

_**Hình 38.3:**_ Ảnh nhiễu xạ của một đồng xu. Chú ý đến những vòng nhiễu xạ đồng tâm và chấm sáng Fresnel tại tâm của ảnh nhiễu xạ.

Năm 1819 Viện Hàn Lâm mà đa số những người ủng hộ Newton nghĩ rằng để thách thức quan điểm sóng đã tổ chức một cuộc thi tranh giải về đề tài nhiễu xạ, Fresnel đã thắng. Tuy nhiên, những người ủng hộ Newton vẫn không chịu nghe theo mà cũng không chịu im lặng. Một trong những người ấy là Poisson, nếu lý thuyết Fresnel đúng thì sóng sáng sẽ nhiễu xạ vào vùng bóng tối của quả cầu khi chúng đi qua mép của quả cầu và tạo thành một chấm sáng tại tâm điểm của bóng tối đó. Trước sự ngạc nhiên của Poisson, vị trí này đã được quan sát bởi Dominique Arago ngay sau đó. Do đó, dự đoán của Poisson đã củng cố lý thuyết sóng hơn là bác bỏ nó.

  1. **Nhiễu xạ Fraunhofer**


Giả sử màn quan sát được đặt rất xa khe hẹp và các tia sáng tới khe là song song nhau (hình 38.4). Trong mô hình này, hình ảnh thu được trên màn quan sát được gọi là mẫu nhiễu xạ Fraunhofer.

Nhiễu xạ ám chỉ tới hoạt động chung của sóng khi chúng đi qua một khe hẹp. Trên thực tế, ảnh được thấy trên màn quan sát thực sự là ảnh giao thoa. Sự giao thoa giữa các phần của ánh sáng tới chiếu lên các khu vực khác nhau của khe. Một vân sáng được quan sát dọc theo trục chính (θ = 0), các vân sáng và tối được quan sát xen kẽ hai bên của vân sáng trung tâm.


| ![](images/image5.png) | Hình 38.4:(a) Hình học để phân tíchnhiễu xạ Fraunhofer qua một khe,(b) Ảnh nhiễu xạ Fraunhofer. |
| --- | --- |

 

#### Nhiễu xạ qua một khe hẹp

Độ rộng hữu hạn của khe là điều kiện cho nhiễu xạ Fraunhofer. Theo nguyên lý Huygens, từng phần của khe hẹp đóng vai trò như một nguồn của sóng ánh sáng. Do đó, ánh sáng từ một phần của khe có thể giao thoa với ánh sáng từ một phần khác. Cường độ sáng sau cùng quan sát trên màn hình tùy thuộc vào hướng θ. Dựa vào những phân tích trên, hình ảnh nhiễu xạ thực sự là một ảnh giao thoa, trong đó các nguồn sáng khác nhau là các phần khác nhau của cùng một khe.

Để phân tích hình ảnh nhiễu xạ, chúng ta chia khe thành hai đới có độ rộng bằng nhau a![](images/image6.png)2 , như hình 38.5. Lưu ý rằng tất cả các sóng rời khỏi khe đều cùng pha, xét các tia 1 và 3. Tuy nhiên, tất cả sóng tới cùng pha khi chúng ló ra khỏi khe hẹp thì sóng 1 lan truyền xa hơn

sóng 3 một đoạn bằng với hiệu quang lộ: a sin θ , trong đó: a là độ rộng của khe. Tương tự,

2

chúng ta có thể lặp lại cách phân tích trên cho từng cặp tia xuất phát từ những điểm tương ứng


| ![](images/image7.png) | Hình 38.5:Nhiễu xạ qua một khe hẹp,
khi![](images/image8.png)L a chúng ta có thể xem gần
đúng các tia1, 2, 3, 4, 5 song song với nhau, làm một góc θ với trục chính
giữa. |
| --- | --- |

 

Biết trước độ rộng khe a và bước sóng λ, phương trình (38.1) cho chúng ta góc θ ứng với vân tối thứ nhất nằm trên và dưới trục chính giữa.

Bây giờ chúng ta chia khe thành bốn đới bằng nhau có độ rộng a![](images/image10.png)4 . Hiệu lộ trình giữa

mỗi cặp tia xuất phát từ những điểm tương ứng trong hai đới kề nhau bằng a sin θ . Trong

4

trường hợp như vậy hiệu quang lộ bằng λ![](images/image11.png)2 nên chúng ta có:

a sin λ λ

![](images/image12.png) θ = ± ![](images/image13.png) → sin θ = ±2 ![](images/image14.png)

4 2 a

Tương tự, khi chia khe thành sáu đới bằng nhau có độ rộng a![](images/image15.png)6 thì vân tối xuất hiện trên màn quan sát khi:

sin θ = ±3 λ

a

#### Giải:

Dựa vào phương trình (38.1), độ lớn của góc nhiễu xạ θ ứng với các cực tiểu nhiễu xạ sẽ giảm khi tăng độ rộng của khe, do đó ảnh nhiễu xạ sẽ bị thu hẹp lại.
λ λ 580.10−9 −4

2 y1

= 2 Lsin θ

= 2 ±L

a

= 2L

a

= 2.2.

3.10−3

= 7, 73.10 m = 0, 773 mm

Cần chú ý rằng giá trị này lớn hơn nhiều lần so với độ rộng của khe.

#### Sự phân bố cường độ ảnh nhiễu xạ qua một khe

Khi chú ý đến những hiệu ứng nhiễu xạ, sự biến thiên cường độ ảnh giao thoa qua một khe được tính theo công thức:

###  _sin(πasinθ λ)_ 2

### 

I = Imax 

###   
πa sin θ![](images/image16.png)λ 

(38.2)

 

trong đó, Imax là giá trị lớn nhất của cường độ tại tâm của bức tranh nhiễu xạ tương ứng với

θ= 0, λ là bước sóng của ánh sáng chiếu đến khe hẹp. Từ điều kiện cường độ cực tiểu:
πa sinθtối
λ

= mπ

![](images/image17.png)λ

sinθtối = m a , với m = ±1, ±2, ±3


| ![](images/image18.png) | Hình 38.6:(a) Đồ thị biểu diễn sự phụ
thuộc cường độ sáng I so với (π λ)a sin θ cho nhiễuxạ Fraunhofer qua một khe, (b) Ảnh nhiễu xạ Fraunhofer. |
| --- | --- |

 

#### Nhiễu xạ qua hai khe

![](images/image19.png)Trong những thí nghiệm hai khe của chương 37, chúng ta đã cho rằng các khe rất hẹp so với bước sóng của ánh sáng dọi đến hai khe ( a λ ). Với những khe hẹp như thes cực đại chính giữa của ảnh nhiễu xạ của từng khe bao phủ toàn bộ màn quan sát. Hơn nữa sự giao

![](images/image19.png)thoa của áng sáng từ hai khe tạo nên những vân có cường độ xấp xỉ bằng nhau. Tuy nhiên, trong thực tế với ánh sáng khả kiến điều kiện ( a λ ) không phải bao giờ cũng thỏa mãn. Với những khe tương đối rộng, sự giao thoa của áng sáng từ hai khe tạo nên những vân sáng mà cường độ không phải tất cả đều bằng nhau. Thực tế là cường độ của chúng bị thay đổi do nhiễu xạ của ánh sáng qua mỗi khe.

#### Phương trình biểu diễn cường độ của ảnh nhiễu xạ qua hai khe hẹp

#### Sự phân bố cường độ ảnh nhiễu xạ qua hai khe

Ảnh nhiễu xạ của hai khe, mô tả bởi phương trình (38.3) và được thể hiện trong hình

38.7. Đường màu xanh nét đứt là ảnh nhiễu xạ qua một khe hẹp. Đường cong màu nâu là do giao thoa qua hai khe hẹp, thành phần này sẽ tạo ra tất cả các đỉnh cùng độ cao (cường độ). Chiều cao các đỉnh không đồng đều do thành phần nhiễu xạ qua mỗi khe (thừa số trong dấu ngoặc vuông).

Phương trình (37.2) cho biết điều kiện để xảy ra cực đại giao thoa là: dsin θ = mλ , trong đó: d là khoảng cách giữa hai khe. Phương trình (38.1) cho biết cực tiểu nhiễu xạ đầu

tiên xảy ra khi asin θ = λ , trong đó a là độ rộng của mỗi khe. Chia phương trình (37.2) cho

phương trình (38.1) (với m = 1) cho phép chúng ta xác định cực đại giao thoa đầu tiên trùng với cực tiểu nhiễu xạ đầu tiên:

dsin θ = mλ ⇒
asin θ λ

d = m a

(38.4)

  * Điều kiện cho cực đại giao thoa: dsin θ = mλ

  * Điều kiện cho cực tiểu nhiễu xạ đầu tiên: a sin θ = λ


Như vậy, cường độ sáng ở cực đại thứ 1, 2, 3… rất nhỏ hơn so với cường độ sáng của cực đại chính giữa nên trong trường hợp nhiễu xạ qua nhiều khe ta chỉ xét trong vân giữa nhiễu xạ.

![](images/image20.jpeg)

_**Hình 38.7:**_ Cường độ sáng của ảnh nhiễu xạ qua nhiều khe hẹp.

#### Năng suất phân giải

Khả năng của các hệ thống quang học để phân biệt giữa các nguồn ở gần nhau bị giới hạn do bản chất sóng của ánh sáng. Thực chất, các ảnh qua thấu kính đều là ảnh nhiễu xạ, điều này rất quan trọng khi chúng ta muốn phân biệt hai nguồn điểm ở xa mà khoảng cách góc giữa chúng rất nhỏ. Hình 38.8 cho thấy hai nguồn sáng cách xa một khe hẹp có độ rộng là a. Nếu hai nguồn sáng đủ xa để giữ cho các cực đại trung tâm không chồng lấn lên nhau thì ảnh có thể phân biệt được (hình 38.8a). Ngược lại, nếu hai nguồn sáng ở gần nhau thì hai cực đại trung tâm chồng lấn lên nhau và ảnh không phân giải được vì nhiễu xạ (hình 38.8b).

![](images/image21.jpeg)

_**Hình 38.8:**_ Hai nguồn điểm cách xa một khe hẹp tạo ra hình ảnh nhiễu xạ:

(a) Ảnh phân giải được, (b) Ảnh không phân giải được.

#### Tiêu chuẩn Rayleigh

Trong hình 38.9 cho thấy khoảng cách góc của hai nguồn điểm có giá trị sao cho cực đại chính giữa của ảnh nhiễu xạ của nguồn này rơi đúng vào cực tiểu thứ nhất của bức tranh nhiễu xạ của nguồn kia. Điều kiện giới hạn này được gọi là tiêu chuẩn Rayleigh về khả năng phân giải.

Theo tiêu chuẩn Rayleigh, chúng ta có thể xác định sự tách biệt góc tối thiểu θmin giữa hai nguồn sáng tại khe trong hình 38.8 (hình ảnh đã được phân giải). Phương trình 38.1 chỉ ra rằng cực tiểu đầu tiên của ảnh nhiễu xạ một khe thỏa điều kiện:

sin θ= λ

a

Khi ảnh được phân giải thì khoảng cách góc giữa các nguồn lớn hơn θmin , chúng ta sẽ có thể phân ly hai nguồn ấy, còn nếu nó nhỏ hơn quá nhiều thì không thể phân ly được. Các nguồn cũng phải có độ sáng tương đối bằng nhau thì mới có thể dùng tiêu chuẩn Rayleigh. Thêm vào đó chúng ta thừa nhận điều kiện nhìn phải lý tưởng.

![](images/image22.jpeg)

_**Hình 38.9:**_ Hình ảnh nhiễu xạ của hai nguồn (đường nét liền) và ảnh tổng hợp (đường nét đứt) khi thay đổi khoảng cách góc giữa các nguồn khi ánh sáng truyền qua một khẩu độ tròn.

Đường nét đứt là tổng hợp từ hai đường cong nét liền.

Khi các nguồn sáng ở xa nhau thì ảnh được phân giải tốt. Các đường cong liền nét là các ảnh nhiễu xạ riêng biệt còn các đường đứt nét là ảnh sau cùng (hình 38.9a).

Các nguồn sáng chia cách nhau bởi một góc thỏa mãn tiêu chuẩn Rayleigh thì ảnh được phân giải. Các đường cong liền nét là ảnh nhiễu xạ riêng biệt. Các đường đứt nét là ảnh sau cùng (hình 38.9b).

Các nguồn sáng gần nhau thì ảnh không được phân giải. Các đường liền nét là ảnh nhiễu xạ riêng biệt. Các đường đứt nét là ảnh sau cùng và ảnh trông giống như một nguồn duy nhất (hình 38.8c).

Hình ảnh sao Diêm Vương và Mặt trăng Charon như trên hình 38.11 là một ví dụ về độ phân giải. Nếu như dùng kính thiên văn Trái đất thì sẽ không phân biệt được mà phải cần dùng đến kính viễn vọng Hubble mới có thể phân giải rõ ràng hai vật.

![](images/image23.jpeg)![](images/image24.png) ![](images/image25.jpeg)
_**Hình 38.11:**_ Hình ảnh sao Diêm Vương và Mặt Trăng Charon.

## Cách tử Nhiễu xạ

#### Nhiễu xạ qua cách tử

Cách tử nhiễu xạ, một dụng cụ dùng cho việc phân tích các nguồn sáng, là hệ thống gồm N khe hẹp giống hệt nhau với độ rộng của mỗi khe là a, khoảng cách giữa hai khe liền kề là d, được đặt cách đều nhau với khoảng cách giữa hai khe liên tiếp là ![](images/image26.png) (chu kỳ của cách tử). Cách tử có cấu tạo rất tinh vi, trên mỗi milimet chiều dài có đến hàng trăm khe. Một cách tử truyền qua có thể được tạo ra bằng cách cắt các rãnh (khe) song song trên một tấm kính bằng máy khắc có độ chính xác cao. Khoảng cách giữa các rãnh trong suốt đối với ánh sáng vì vậy đóng vai trò như các khe riêng biệt. Một cách tử phản xạ có thể được tạo ra bằng cách cắt các rãnh song song trên bề mặt của một vật liệu phản xạ. Sự phản xạ của ánh sáng từ các khoảng không gian giữa các rãnh rõ hơn là sự phản xạ từ các rãnh được khắc vào bên trong vật liệu. Vì vậy, các khoảng không gian giữa các rãnh đóng vai trò giống như là các nguồn sáng phản xạ song song giống như các khe trong một cách tử truyền qua. Công nghệ hiện nay có thể sản xuất các cách tử có các khe rất nhỏ. Ví dụ: một cách tử điển hình được khắc với

5000 khe/cm có độ rộng mỗi khe d = (1 / 5000)cm = 2.10−4 cm.

Một phần của một cách tử nhiễu xạ được minh họa trong hình 38.12. Một sóng phẳng tới từ bên trái, vuông góc với mặt phẳng cách tử. Hình dạng thu được trên màn nằm bên phải mặt cách tử là kết quả của các hiệu ứng giao thoa và nhiễu xạ được kết hợp.

_Chú ý:_ Cách tử nhiễu xạ là một cách tử giao thoa. Giống với dạng nhiễu xạ, cách tử nhiễu xạ là một thuật ngữ sai nhưng được dùng nhiều trong ngôn ngữ vật lý. Cách tử nhiễu xạ phụ thuộc vào sự nhiễu xạ trên cùng phương khi hai khe lan truyền ánh sáng rộng ra để ánh sáng từ các khe khác nhau có thể giao thoa. Sẽ là chính xác hơn nếu gọi thiết bị này là cách tử giao thoa, nhưng cách tử nhiễu xạ lại là tên được sử dụng.

![](images/image27.jpeg) _ **Hình 38.12:**_ Nhiễu xạ qua cách tử. Khoảng cách giữa các khe là d, hiệu quang lộ của hai tia sáng từ hai khe liền kề là dsin θ.

Sóng từ tất cả các khe đồng pha nhau khi chúng ra khỏi các khe. Đối với một hướng bất kỳ θ được xác định từ phương ngang, tuy nhiên, các sóng di chuyển những quãng đường khác nhau trước khi đập vào màn. Cần chú ý trên hình 38.12 rằng hiệu lộ trình δ giữa các tia từ hai khe kề nhau bất kỳ bằng dsin θ. Nếu sự khác nhau của quãng đường di chuyển này bằng với một bước sóng hoặc một số nguyên lần bước sóng thì sóng từ tất cả các khe sẽ đồng pha nhau tại màn và sẽ tạo thành một vân sáng. Vì vậy, điều kiện để đạt được cực đại trong hình dạng giao thoa tại góc θ là

### ![](images/image28.png)dsinθsáng = mλ, với m = 0, ±1, ±2, ±3

(38.7)

Công thức này có thể được sử dụng để tính bước sóng nếu biết được độ rộng khe d và góc θ . Nếu bức xạ tới bao gồm nhiều bước sóng thì cực đại bậc m đối với mỗi bước sóng

xảy ra tại một góc xác định. Tất cả các bước sóng tại θ= 0 , tương ứng với m = 0 là cực đại

bậc 0 (cực đại trung tâm). Cực đại bậc nhất (m = 1) được xác định tại góc thoả mãn mối liên

hệ sinθ = λ d , cực đại bậc hai (m = 2) được xác định tại một góc θ lớn hơn và tương

tự cho các cực đại bậc cao hơn. Khi các giá trị d nhỏ điển hình trong một cách tử nhiễu xạ thì góc θsáng lớn, giống như ví dụ 38.5.

#### Sự phân bố cường độ qua cách tử nhiễu xạ

Sự phân bố cường độ đối với một cách tử nhiễu xạ đạt được khi sử dụng một nguồn đơn sắc được chỉ ra trong hình 38.13. Chú ý độ sắc nét của cực đại trung tâm và độ rộng của các vùng tối được so sánh với các vân sáng rộng đặc trưng của dạng giao thoa hai khe (xem hình 37.6). Bên cạnh đó cũng có thể tham khảo hình 37.7 để thấy rằng độ rộng của cực đại cường độ giảm khi số khe tăng lên. Bởi vì cực đại bậc trung tâm rất sắc nét, chúng sáng hơn nhiều cực đại giao thoa hai khe.


| ![](images/image29.png) | Hình 38.13:Đồ thị biểu diễn sự phụ thuộc
củacường độ theo sinθ của cách tử nhiễu xạ. Cực đại trung tâm, bậc một,
bậc hai được biểu diễn. |
| --- | --- |

 

Đặc điểm của quang phổ cách tử:

  * Quang phổ của cách tử chỉ có một vài giá trị.

  * Trong quang phổ của lăng kính thì tia tím bị lệch ít nhất, tia đỏ bị lệch nhiều nhất.

  * So với quang phổ của lăng kính thì quang phổ của cách tử có các vệt vào phân bố đều đặn hơn.


_**Câu hỏi 38.1:**_ Ánh sáng cực tím có bước sóng 350 nm đập vào một cách tử nhiễu xạ có độ
rộng khe d và hình thành một dạng giao thoa trên màn ở khoảng cách L. Các góc
sáng
cực đại giao thoa có giá trị lớn. Các vị trí của vân sáng được đánh dấu trên màn. Bây giờ ánh sáng đỏ có bước sóng 700 nm được sử dụng với một cách tử nhiễu xạ để tạo thành một dạng nhiễu xạ khác trên màn. Các vân sáng của dạng nhiễu xạ này sẽ được cố định tại các vị trí đánh dấu trên màn hay không nếu:

  1. Màn được di chuyển tới khoảng cách 2L từ cách tử nhiễu xạ.

  2. Màn được di chuyển tới khoảng cách L/2 từ cách tử nhiễu xạ.

  3. Cách tử nhiễu xạ được thay thế bằng một khe có độ rộng 2d.

  4. Cách tử nhiễu xạ được thay thế bằng một khe có độ rộng d/2.

  5. ![](images/image30.jpeg)Không gì thay đổi?


_**Câu hỏi 38.2:**_ Đĩa compact là một cách tử nhiễu xạ. Ánh sáng phản xạ từ bề mặt của một đĩa compact bao gồm nhiều màu như trên hình 38.14. Các màu và cường độ của chúng phụ thuộc vào hướng của CD so với mắt và so với nguồn sáng. Giải thích hiện tượng này.

#### Trả lời:

Bề mặt của một CD có một rãnh hình xoắn ốc (các rãnh kề nhau có khoảng cách là 1 μm). Vì vậy, bề mặt đĩa đóng vai trò như một cách tử nhiễu xạ. Ánh sáng phản xạ từ các vùng giữa các khe hẹp này chỉ giao thoa chồng chập trên những hướng cụ thể phụ thuộc vào bước sóng và hướng của ánh sáng tới. Các phần khác nhau của đĩa CD đóng vai trò như cách tử nhiễu xạ đối với ánh sáng trắng và truyền đi các màu khác nhau, theo các hướng

_**Hình 38.14:**_ Các vạch rất mảnh, mỗi vạch có độ rộng 1 μm, trên đĩa compact laser tác dụng như một cách tử nhiễu xạ

khác nhau. Các màu khác nhau được nhìn thấy trên một phần nào đó của đĩa sẽ thay đổi khi nguồn sáng, trong trường hợp này là CD, hoặc khi thay đổi hướng nhìn. Sự thay đổi hướng nhìn làm cho góc tới hay góc của ánh sáng nhiễu xạ bị thay đổi.

#### Bài tập mẫu 38.2:

Ánh sáng đơn sắc từ một laser heli-neon (λ = 632,8 nm) chiếu vuông góc vào một cách tử nhiễu xạ có 6000 khe trên một centimet. Tìm các góc ứng với cực đại bậc nhất và bậc hai.

#### Giải:

Quan sát hình 38.12 và tưởng tượng rằng ánh sáng tới từ bên trái phát ra từ laser heli- neon. Chúng ta hãy xác định các giá trị thích hợp của góc θ đối với cực đại giao thoa.
Khoảng cách giữa các khe là nghịch đảo của số khe trên mỗi centimet:

d = 1

6000

cm = 1,667.10−4 cm = 1667 nm

Giải phương trình (38.7) đối với sinθ và cực địa bậc nhất ứng với m = 1 để tìm giá trị của góc θ1:
sin θ = 1.λ = 632,8 nm ⇒ θ = 22,310
1 d 1667 nm 1
Lặp lại đối với cực đại bậc hai (m = 2):
sin θ = 2.λ = 2.632,8 nm ⇒ θ = 49, 410
2 d 1667 nm 2
_**Mở rộng:**_ Điều gì sẽ thay đổi nếu cực đại bậc ba cần được xác định? Có thể xác định được không?
_Trả lời:_ Với m = 3 thì sinθ3 = 1,139. Vì sinθ luôn nhỏ hơn 1, kết quả này không phải
là một kết quả hợp lí. Vì vậy, chỉ các cực đại trung tâm, bậc nhất và bậc hai có thể được xác định trong trường hợp này.

#### Một số ứng dụng của cách tử nhiễu xạ

  1. **Phổ kế cách tử nhiễu xạ**


Hình vẽ của một thiết bị đơn giản được sử dụng để đo các góc trong một dạng nhiễu xạ được chỉ ra trên hình 38.15. Thiết bị này là một phổ kế cách tử nhiễu xạ. Ánh sáng di chuyển qua một khe, và một chùm ánh sáng được chuẩn trực chiếu vào cách tử. Ánh sáng nhiễu xạ rời khỏi cách tử tại các góc thoả mãn phương trình (38.7) và một kính viễn vọng được sử dụng để quan sát ảnh của khe. Bước sóng có thể được xác định bằng việc đo lường các góc chính xác tại đó ảnh của khe xuất hiện tại các góc khác nhau.

Phổ kế này là một thiết bị được sử dụng trong phổ kế nguyên tử, trong đó ánh sáng từ một nguyên tử được phân tích để tìm các thành phần bước sóng. Các thành phần bước sóng

có thể được sử dụng nhận dạng nguyên tử. Các phổ nguyên tử sẽ được khảo sát trong chương 42 của phần mở rộng của giáo trình này.

![](images/image31.jpeg)

_**Hình 38.15:**_ Quang phổ kế cách tử nhiễu xạ.

#### Van cách tử nhiễu xạ

![](images/image32.jpeg)Ứng dụng khác của các cách tử nhiễu xạ là van ánh sáng cách tử − grating light valve (GLV), thiết bị này cạnh tranh với các thiết bị micromirror số (DMDs). GLV là một microchip silicon được lắp vào một dãy băng silicon nitride song song được phủ một lớp bạc mỏng (hình 38.16). Mỗi dãy dài xấp xỉ 20 μm, rộng 5 μm và được tách biệt với lớp silicon bởi một lớp không khí có độ dày là bậc của 100 nm . Khi không có điện thế, tất cả các dãy ở cùng mức nhau. Trong trường hợp này, dãy băng đóng vai trò như một bề mặt phẳng, phản xạ ánh sáng tới.

**Hình 38.16:** Một phần nhỏ của van ánh sáng cách tử. Băng phản chiếu xen kẽ ở các mức hoạt động khác nhau như một cách tử nhiễu xạ, cung cấp khả năng điều khiển tốc độ rất cao của hướng ánh sáng đến một thiết bị kỹ thuật số.

Khi có điện thế áp vào giữa một dãy băng và điện cực trên lớp silicon, một lực điện xuất hiện kéo dãy băng hạ xuống, gần hơn với lớp silicon. Các dãy băng có thể được luân phiên kéo xuống trong khi các khoảng không gian giữa chúng được nâng cao. Vì vậy, các dãy băng đóng vai trò như một cách tử nhiễu xạ mà ở đó sự giao thoa tăng cường đối với một bước sóng ánh sáng cụ thể có thể được hướng vào một màn hoặc các hệ hiển thị quang học

khác. Nếu ba thiết bị − một cho ánh sáng đỏ, một cho ánh sáng xanh da trời, và một cho ánh sáng xanh lá cây – được sử dụng thì việc hiển thị toàn màu có thể thực hiện.

Bên cạnh việc sử dụng trong hiển thị video, GLV còn được ứng dụng trong công nghệ cảm biến điều hướng quang học laser, việc in thương mại từ máy tính thành tấm, và các loại thiết bị chụp ảnh khác.

#### Hologram − Kỹ thuật chụp ảnh giao thoa Lazer

Một ứng dụng thú vị khác của cách tử nhiễu xạ là phương pháp toàn ảnh (holography), sử dụng trong việc tạo ảnh ba chiều của vật. Nguyên lý vật lý của phương pháp toàn ảnh được phát triển bởi Dennis Gabor (1900-1979) vào năm 1948 và giúp ông giành giải Nobel Vật lý vào năm 1971. Sự yêu cầu về ánh sáng kết hợp cho phương pháp toàn ảnh đã trì hoãn thành phương pháp tạo ảnh của Gabor cho đến khi laser được phát triển vào những năm 1960. Hình

38.17 cho thấy một ảnh toàn ký (ảnh ba chiều – hologram) nhìn từ hai vị trí khác nhau và đặc tính ba chiều của ảnh. Lưu ý sự khác nhau khi nhìn ảnh thông qua kính khuếch đại trong các hình 38.17a và 38.17b.

![](images/image33.jpeg)![](images/image34.jpeg)

**Hình 38.17:** Bảng mạch được hiển thị ở hai chế độ xem khác nhau.

Hình 38.18 cho thấy cách mà một hologram được tạo ra. Ánh sáng từ nguồn laser được tách thành hai phần bởi một gương mạ bạc tại B. Một phần của chùm tia phản xạ từ vật được chụp ảnh và đập vào một phim ảnh. Phần còn lại của chùm tia bị phân kỳ bởi kính L2, phản xạ từ các gương M1 và M2, và cuối cùng đập vào phim. Hai chùm tia chồng chập lên nhau để tạo thành một dạng giao thoa cực kỳ phức tạp trên phim. Dạng giao thoa này có thể được tạo ra chỉ khi mối quan hệ về pha của hai sóng là hằng số thông qua sự phơi sáng của phim. Điều kiện này đạt được bằng việc chiếu vào màn hình chùm ánh sáng thông qua một pinhole hoặc sử dụng bức xạ laser kết hợp. Hologram thu nhận không chỉ cường độ của ánh sáng tán xạ từ vật (giống như trong phương pháp chụp ảnh truyền thống), mà còn ghi nhận sự khác biệt về pha giữa chùm tia tham chiếu (reference light) và chùm tia tán xạ từ vật. Do bởi sự khác nhau về pha này, một dạng giao thoa được hình thành và tạo thành ảnh mà trong đó tất cả thông tin ba chiều được bảo toàn.

![](images/image35.jpeg)
_**Hình 38.18:**_ Phương pháp chụp ảnh Hologram.

Trong một ảnh được chụp bằng phương pháp bình thường, môt kính được sử dụng để hội tụ ảnh để mỗi điểm trên vật tương ứng với một điểm trên ảnh. Chú ý rằng kính không được sử dụng trong hình 38.18 để hội tụ ánh sáng lên phim. Vì vậy, ánh sáng từ mỗi điểm trên vật sẽ xuất hiện tại tất cả các điểm trên phim. Vì vậy, mỗi vùng của phim trong đó hologram được ghi nhận sẽ chứa đựng thông tin về tất cả các điểm được chiếu trên vật, điều này sẽ đưa đến một kết quả đáng chú ý: nếu một vùng nhỏ của hologram được cắt ra từ phim, ảnh hoàn chỉnh của vật có thể được tạo ra từ phần nhỏ này. (Chất lượng của ảnh bị giảm xuống nhưng một ảnh hoàn chỉnh được tạo thành).

Một hologram được quan sát tốt nhất bằng việc cho chùm ánh sáng kết hợp di chuyển qua một tấm phim giống như quan sát ngược lại dọc theo hướng từ đó chùm ánh sáng được phát ra. Hình ảnh giao thoa trên phim đóng vai trò như là một cách tử nhiễu xạ. Hình 38.19 cho thấy 2 tia sáng đập vào và di chuyển qua phim. Đối với mỗi tia, các tia m = 0 và m = ±1 trên hình ảnh nhiễu xạ cho thấy xuất hiện từ bên phải của phim. Các tia m = +1 hội tụ để tạo thành một ảnh thực của màn và đây không phải là được quan sát một cách bình thường. Bằng việc mở rộng các tia sáng tương ứng với m = −1 về phía sau phim, sẽ xuất hiện một ảnh ảo tại đó và ánh sáng tới từ đó sẽ giống với ánh sáng tới từ vật thật khi phim được phơi sáng. Ảnh này là ảnh được nhìn thấy khi quan sát thông qua phim toàn ảnh (holographic film).

Phương pháp toàn ảnh có một vài ứng dụng. Chúng ta có thể có một hologram trên thẻ tín dụng. Loại hologram đặc biệt này được gọi là _rainbow hologram_ và được thiết kế để được quan sát trong ánh sáng trắng được phản xạ.

#### Nhiễu xạ của tia X bởi các tinh thể

Về nguyên tắc, bước sóng của bất kỳ sóng điện từ có thể được xác định nếu có một cách tử thích hợp (các rãnh được chia nhỏ ở mức độ bước sóng). Tia X, được khám phá bởi

Wilhelm Roentgen (1845−1923) vào năm 1895, là sóng điện từ có bước sóng rất ngắn (ở mức 0,1 nm). Sẽ không thể tạo một cách tử có khoảng cách giữa các khe nhỏ đến mức đó bằng quá trình cắt được miêu tả ở phần mở đầu của phần 38.4. Tuy nhiên, khoảng cách ở mức độ nguyên tử trong vật rắn lại vào khoảng 0,1 nm. Năm 1913, Max von Laue (1879−1960) đề nghị rằng mạng nguyên tử bình thường trong tinh thể có thể đóng vai trò như một cách tử nhiễu xạ ba chiều đối với tia X. Những thí nghiệm sau đó đã chứng minh dự đoán này. Hình dạng nhiễu xạ từ tinh thể trông phức tạp do bởi tính chất ba chiều của cấu trúc tinh thể. Tuy nhiên, sự nhiễu xạ tia X đã chứng minh là một phương pháp hiệu quả trong việc giải thích các cấu trúc này và trong việc nghiên cứu cấu trúc vật chất.

![](images/image36.jpeg)

_**Hình 38.20:**_ Nhiễu xạ tia X qua tinh thể.

![](images/image37.png)Hình 38.20 cho thấy một bố trí thực nghiệm trong việc quan sát nhiễu xạ tia X từ một tinh thể. Một chùm tia X đơn sắc được chuẩn trực chiếu vào một tinh thể. Các chùm tia nhiễu xạ có cường độ mạnh trong các hướng xác định, tương ứng với sự giao thoa tăng cường từ các sóng phản xạ từ các lớp của nguyên tử trong tinh thể. Các chùm tia nhiễu xạ, có thể được ghi nhận bằng một tấm phim, tạo thành một mảng các vết được gọi là hình dạng Laue giống như trên hình 38.21a. Cấu trúc tinh thể có thể được xác định bằng việc phân tích vị trí và cường độ của các vết khác nhau trên hình ảnh nhiễu xạ này. Hình 38.21b cho thấy hình ảnh Laue từ tinh thể enzyme, sử dụng một phạm vi rộng lớn các bước sóng để hình ảnh này được tạo ra.

_**Hình 38.21:**_ (a) Ảnh Laue tinh thể đơn của nguyên tố Be, (b) Ảnh Laue của enzym Rubisco.

Sự sắp xếp của các nguyên tử trong một tinh thể muối natriclorua (NaCl) được chỉ ra trên hình 38.22. Mỗi ô đơn vị (khối hình học lặp lại trong tinh thể) là một hình lập phương có độ dài cạnh là a. Một sự khảo sát cẩn thận cấu trúc NaCl cho thấy rằng các ion nằm trên các mặt phằng rời rạc (phần được bôi đen trên hình 38.22). Bây giờ giả sử rằng chùm tia X tới hợp thành một góc θ với một trong các mặt phẳng được chỉ ra trên hình

38.23. Chùm tia có thể được phản xạ từ cả mặt phẳng trên và mặt phẳng dưới nhưng chùm tia phản xạ từ mặt phẳng dưới di chuyển xa hơn chùm tia phản xạ từ mặt phẳng trên. Sự khác nhau của quãng đường hiệu dụng là 2dsin θ . Hai chùm tia giao thoa tăng cường nhau khi sự khác nhau của quãng đường bằng với số nguyên lần bước sóng λ. Kết quả giống như vậy vẫn đúng khi ánh sáng phản xạ từ một tập hợp toàn bộ các mặt

![](images/image38.png)
_**Hình 38.22:**_ Cấu trúc lập thể của NaCl.

phẳng song song. Vì vậy, điều kiện để có giao thoa tăng cường (cực đại trên chùm tia phản xạ) là

![](images/image39.png)2dsin θ = mλ, với m = 1, 2,3 (38.8)

Điều kiện này còn gọi là **định luật Bragg,** được đặt theo tên W. L. Bragg (1890−1971), người đầu tiên rút ra được mối liên hệ này. Nếu bước sóng và góc nhiễu xạ được đo, phương trình (38.8) có thể được sử dụng để tính khoảng các giữa các mặt phẳng nguyên tử.

![](images/image40.jpeg)

_**Hình 38.23:**_ Một chùm tia X tới chịu sự nhiễu xạ bởi cấu trúc trong tinh thể.

## Sự phân cực của sóng ánh sáng

#### Ánh sáng không phân cực

Trong chương 34, chúng ta đã miêu tả tính chất theo phương ngang của ánh sáng và tất cả các sóng điện từ. Sự phân cực, được thảo luận trong phần này, là bằng chứng cho tính chất ngang của sóng ánh sáng.

![](images/image41.png)![](images/image42.jpeg)Một chùm ánh sáng bình thường chứa đựng một số lượng lớn các sóng được phát ra bởi các nguyên tử của nguồn sáng. Mỗi nguyên tử tạo ra một sóng có hướng cụ thể của vector điện

trường E , tương ứng với hướng của sự dao động nguyên tử. Hướng của sự phân cực của mỗi sóng riêng lẻ được

định nghĩa là hướng mà theo đó điện trường đang dao động. Trong hình

_**Hình 38.24:**_ Sự phân cực của sóng ánh sáng.

![](images/image41.png)![](images/image41.png)38.24, hướng này nằm dọc theo trục y _._ Tất cả các sóng điện từ riêng lẻ chuyển động dọc theo

phương x có vector

song song với mặt phẳng yz _,_ nhưng vector

này có thể hợp thành

![](images/image43.png)một góc bất kỳ so với trục y _._ Bởi vì sự dao động xảy ra theo tất cả các hướng, vì vậy sóng điện từ sau cùng là chồng chập của sóng dao động từ nhiều hướng. Kết quả là một chùm sáng không phân cực, được chỉ ra trên hình 38.25a. Hướng lan truyền của sóng trong hình này vuông góc với mặt phẳng của trang giấy. Các mũi tên cho thấy một số hướng của vector điện trường của các sóng riêng lẻ tạo thành sóng tổng hợp. Tại một điểm bất kỳ và trong một thời gian ngắn, tất cả các vector điện trường riêng lẻ này sẽ tổng hợp lại để tạo thành vector điện trường tổng.

_**Hình 38.25:**_ (a) Ánh sáng không phân cực được biểu diễn theo hướng truyền. Điện trường ngang dao động theo mọi hướng có xác suất bằng nhau, (b) Một chùm ánh sáng phân cực ban đầu với điện trường dao động theo phương thẳng đứng.
Như được chú ý trong mục 34.3, một sóng được xem là phân cực tuyến tính nếu như

![](images/image41.png)vector điện trường được tao thành dao động theo cùng hướng tại một điểm bất kỳ tại mọi

lúc như được chỉ ra trên hình 38.25b. (Ngoài ra, vector này còn được miêu tả như bị phân cực

![](images/image41.png)phẳng hoặc đơn giản chỉ là bị phân cực). Mặt phẳng được tạo thành bởi và hướng lan truyền

được gọi là mặt phẳng lan truyền của sóng. Nếu sóng trong hình 38.24 đại diện cho sóng được tạo thành từ tất cả các sóng đơn, mặt phẳng phân cực là mặt phẳng xy _._

Một chùm tia phân cực tuyến tính có thể đạt được từ một chùm tia không phân cực bằng việc bỏ đi tất cả các sóng từ chùm tia ngoại trừ các sóng có vector điện trường dao động trong một mặt phẳng đơn. Bây giờ, chúng ta sẽ thảo luận bốn quá trình được sử dụng để tạo ra ánh sáng phân cực từ ánh sáng không phân cực.

#### Sự phân cực bằng sự hấp thụ có chọn lọc

Kỹ thuật thông thường nhất dùng để tạo ra ánh sáng phân cực là sử dụng một vật liệu có tính truyền sóng. Điện trường của sóng truyền qua này dao động trong một mặt phẳng song song với một hướng xác định. Bên cạnh đó, vật liệu được sử dụng này sẽ hấp thụ sóng có điện trường dao động theo các hướng khác.

Năm 1938, E. H. Land (1909−1991) đã phát hiện một loại vật liệu mà sau đó ông ấy gọi là _Polaroid_. Vật liệu này phân cực ánh sáng thông qua sự hấp thụ có chọn lọc. Vật liệu này được chế tạo thành các tấm hydrocarbon chuỗi dài và mỏng. Các tấm này được kéo căng trong suốt quá trình sản xuất để các phân tử chuỗi dài được căng chỉnh thẳng hàng. Sau khi nhúng các tấm hydrocarbon này vào dung dịch chứa iốt, các phân tử trở thành các vật dẫn điện tốt. Sự dẫn điện xảy ra chủ yếu dọc theo các chuỗi hydrocarbon bởi vì các electron có thể di chuyển một cách dễ dàng dọc theo các chuỗi. Nếu ánh sáng có vector điện trường song song với các chuỗi chiếu vào vật liệu, điện trường gia tốc các electron dọc theo các chuỗi và năng lương được hấp thụ từ bức xạ. Vì vậy, ánh sáng không truyền qua vật liệu. Ánh sáng có vector điện trường vuông góc với các chuỗi truyền qua vật liệu bởi vì các electron không thể di chuyển từ phân tử này tới phân tử khác. Vì vậy, khi ánh sáng không phân cực chiếu vào vật liệu, ánh sáng thoát ra bị phân cực vuông góc với các chuỗi phân tử.

Thông thường hướng vuông góc với các chuỗi phân tử được xem như là trục truyền

![](images/image41.png)qua. Trong một kính phân cực lý tưởng, tất cả ánh sáng với song song với trục truyền qua

![](images/image41.png)thì được truyền qua và tất cả ánh sáng với vuông góc với trục truyền qua thì bị hấp thụ.

![](images/image44.jpeg) _ **Hình 38.26:**_ Phân cực ánh sáng bằng phương pháp hấp thụ chọn lọc.

![](images/image45.png)![](images/image45.png)Hình 38.26 thể hiện một chùm ánh sáng không phân cực chiếu vào một tấm phân cực đầu tiên, gọi là kính phân cực. Bởi vì trục truyền qua được định hướng theo phương thẳng đứng trong hình, ánh sáng truyền qua tấm phân cực này sẽ bị phân cực thoe phương thẳng đứng. Tấm phân cực thứ hai, được gọi là thiết bị phân tích, chắn chùm tia. Trong hình 38.26, trục truyền qua của thiết bị phân tích được đặt tại một góc θ so với trục phân cực. Vector điện

trường của chùm tia truyền qua đầu tiên là

E0 . Thành phần

vuông góc với trục phân tích

![](images/image45.png)sẽ bị hấp thụ hoàn toàn. Thành phần song song với trục phân tích, truyền qua thiết bị phân

tích, là E0 cosθ. Bởi vì cường độ của chùm tia truyền qua thay đổi như là bình phương của

biên độ nên có thể kết luận rằng cường độ I của chùm tia phân cực truyền qua thiết bị phân tích thay đổi như sau,

ở đây,

Imax

I = I cos2 θ (38.9)

là cường độ của chùm tia phân cực chiếu vào thiết bị phân tích. Công thức này,

được biết đến là quy luật Malus, áp dụng đối với hai vật liệu phân cực bất kỳ có các trục truyền qua hợp với nhau thành một góc θ. Công thức này cho thấy rằng cường độ của chùm tia truyền qua đạt cực đại khi các trục truyền qua song song ( θ= 0 hoÆc 1800 ) và bằng không (hấp thụ hoàn toàn bởi thiết bị phân tích) khi các trục truyền qua vuông góc với nhau. Sự thay đổi trong cường độ truyền qua này thông qua một cặp các tấm phân cực được minh hoạ trong hình

38.27. Bởi vì giá trị trung bình của cos2 θ = 1 2 , cường độ của ánh sáng không phân cực ban

đầu bị giảm bởi một hệ số của 1/2 khi ánh sáng truyền qua một kính phân cực lý tưởng.

![](images/image46.jpeg)
_**Hình 38.27:**_ Cường độ ánh sáng truyền qua hai bản phân cực phụ thuộc vào tính định hướng tương đối của các trục lan truyền. Mũi tên màu đỏ biểu thị trục truyền của các bản phân cực.

#### Sự phân cực bằng sự phản xạ

Khi một chùm ánh sáng không phân cực bị phản xạ từ một bề mặt, sự phân cực của ánh sáng phản xạ phụ thuộc vào góc tới. Nếu góc tới là 00 thì chùm tia phản xạ không phân cực. Đối với các góc tới khác ánh sáng phản xạ sẽ bị phân cực đến một mức độ nào đó, và đối với một góc tới cụ thể, ánh sáng phản xạ sẽ bị phân cực hoàn toàn. Chúng ta hãy khảo sát sự phản xạ tại góc đặc biệt đó.

Giả sử một chùm sáng không phân cực chiếu vào một bề mặt như minh hoạ trong hình

38.28a. Mỗi vector điện trường có thể được phân tích thành hai thành phần: một song song với bề mặt (và vuông góc với trang giấy như trong hình 38.28, được thể hiện bởi các chấm) và phần còn lại (được minh hoạ bởi các mũi tên màu cam) vuông góc với cả thành phần đầu tiên và với hướng lan truyền sóng. Vì vậy, sự phân cực của toàn bộ chùm tia có thể được diễn tả bởi hai thành phần điện trường theo các hướng này. Thành phần song song được minh hoạ bởi các chấm, phản xạ mạnh hơn nhiều so với thành phần còn lại được thể hiện bởi các dấu mũi tên, tạo ra một chùm tia phản xạ phân cực không hoàn toàn. Hơn nữa, chùm tia khúc xạ cũng bị phân cực không hoàn toàn.

Bây giờ giả sử rằng góc tới θ1 thay đổi đến khi góc giữa chùm tia phản xạ và chùm tia khúc xạ là 900 như được minh hoạ trên hình 38.28b. Tại góc tới này, chùm tia phản xạ bị phân cực hoàn toàn (với vector điện trường song song với bề mặt) và chùm tia khúc xạ vẫn bị phân cực không hoàn toàn. Góc tới tại đó sự phân cực này xảy ra được gọi là góc phân cực θp.

![](images/image47.jpeg)
_**Hình 38.28:**_ (a) Phân cực một phần, (b) Phân cực toàn phần.

# Tóm tắt chương 38

![](images/image48.png)

![](images/image26.png)![](images/image28.png)

# Public_151

_Chương 1 giới thiệu các khái niệm về an toàn thông tin, an toàn hệ thống thông tin và các yêu cầu đảm bảo an toàn thông tin và an toàn hệ thống thông tin. Chương này cũng đề cập các rủi ro và nguy cơ trong các vùng của hạ tầng công nghệ thông tin theo mức kết nối mạng. Phần cuối của chương giới thiệu mô hình tổng quát đảm an toàn hệ thống thông tin._

# Khái quát về an toàn thông tin 

## An toàn thông tin là gì? 

_An toàn thông tin_ (Information security) là việc bảo vệ chống truy nhập, sử dụng, tiết lộ, sửa đổi, hoặc phá hủy thông tin một cách trái phép, theo trang Wikipedia (https://en.wikipedia.org/wiki/Information_security).
Theo cuốn Principles of Information Security, _An toàn thông tin_ là việc bảo vệ các thuộc tính _bí mật_ (confidentiality), tính _toàn vẹn_ (integrity) và tính _sẵn dùng_ (availability) của các tài sản thông tin trong quá trình chúng được lưu trữ, xử lý, hoặc truyền tải. Hình 1.1 minh họa ba thuộc tính cần bảo vệ nói trên của các tài sản thông tin, bao gồm dữ liệu (Data) và dịch vụ (Services).
|<image_1>|
_Hình 1.1. Các thuộc tính cần bảo vệ của tài sản thông tin: Bí mật (Confidentiality), Toàn vẹn (Integrity) và Sẵn dùng (Availability)_
An toàn thông tin gồm hai lĩnh vực chính là _An toàn công nghệ thông tin_ (Information technology security, hay IT security) và _Đảm bảo thông tin_ (Information assurance). An toàn công nghệ thông tin, hay còn gọi là _An toàn máy tính_ (Computer security) là việc đảm bảo an toàn cho các hệ thống công nghệ thông tin, bao gồm các hệ thống máy tính và mạng, chống lại các cuộc tấn công phá hoại. Đảm bảo thông tin là việc đảm bảo thông tin không bị mất khi xảy ra các sự cố, như thiên tai, hỏng hóc, trộm cắp, phá hoại,…Đảm bảo thông tin thường được thực hiện sử dụng các kỹ thuật _sao lưu ngoại vi_ (offsite
backup), trong đó dữ liệu thông tin từ hệ thống gốc được sao lưu ra các thiết bị lưu trữ vật lý đặt ở một vị trí khác.
_Một số khái niệm khác trong an toàn thông tin:_
_Truy nhập_ (Access) là việc một chủ thể, người dùng hoặc một đối tượng có khả năng sử dụng, xử lý, sửa đổi, hoặc gây ảnh hưởng đến một chủ thể, người dùng hoặc một đối tượng khác. Trong khi người dùng hợp pháp có quyền truy nhập hợp pháp đến một hệ thống thì tin tặc truy nhập bất hợp pháp đến hệ thống.
_Tài sản_ (Asset) là tài nguyên của các tổ chức, cá nhân được bảo vệ. Tài sản có thể là tài sản lô gíc, như một trang web, thông tin, hoặc dữ liệu. Tài sản có thể là tài sản vật lý, như hệ thống máy tính, thiết bị mạng, hoặc các tài sản khác.
_Tấn công_ (Attack) là hành động có chủ ý hoặc không có chủ ý có khả năng gây hại, hoặc làm thỏa hiệp các thông tin, hệ thống và các tài sản được bảo vệ. Tấn công có thể chủ động hoặc thụ động, trực tiếp hoặc gián tiếp.

## Các thành phần của an toàn thông tin 

An toàn thông tin có thể được chia thành ba thành phần chính: _an toàn máy tính và dữ liệu_ (Computer & data security), _an ninh mạng_ (Network security) và _quản lý an toàn thông tin_ (Management of information security). Ba thành phần của an toàn thông tin có quan hệ mật thiết và giao thoa với nhau, trong đó phần chung của cả ba thành phần trên là _chính sách an toàn thông tin_ (Policy) như minh họa trên Hình 1.2.
|<image_2>|
_Hình 1.2. Các thành phần chính của An toàn thông tin_

###  An toàn máy tính và dữ liệu 

An toàn máy tính và dữ liệu là việc đảm bảo an toàn cho hệ thống phần cứng, phần mềm và dữ liệu trên máy tính; đảm bảo cho máy tính có thể vận hành an toàn, đáp ứng các yêu cầu của người sử dụng. An toàn máy tính và dữ liệu bao gồm các nội dung:
\- Đảm bảo an toàn hệ điều hành, ứng dụng, dịch vụ;
\- Vấn đề điều khiển truy nhập;
\- Vấn đề mã hóa và bảo mật dữ liệu;
\- Vấn đề phòng chống phần mềm độc hại;
\- Việc sao lưu tạo dự phòng dữ liệu, đảm bảo dữ liệu lưu trong máy tính không bị mất mát khi xảy ra sự cố.
|<image_3>|
_Hình 1.3. Đảm bảo an toàn máy tính và dữ liệu_

### An ninh mạng 

An ninh mạng là việc đảm bảo an toàn cho hệ thống mạng và các thông tin truyền tải trên mạng, chống lại các tấn công, xâm nhập trái phép. Các kỹ thuật và công cụ thường được sử dụng trong an ninh mạng bao gồm:
\- Các tường lửa, proxy cho lọc gói tin và điều khiển truy nhập;
\- Mạng riêng ảo và các kỹ thuật bảo mật thông tin truyền như SSL/TLS, PGP;
\- Các kỹ thuật và hệ thống phát hiện, ngăn chặn tấn công, xâm nhập; - Vấn đề giám sát mạng.
|<image_4>|
_Hình 1.4. Đảm bảo an toàn cho hệ thống mạng và thông tin truyền trên mạng_

### Quản lý an toàn thông tin 

Quản lý an toàn thông tin là việc quản lý và giám sát việc thực thi các biện pháp đảm bảo an toàn thông tin, giúp nâng cao hiệu quả của chúng. Một trong các nội dung cốt lõi của quản lý an toàn thông tin là việc quản lý các rủi ro (Risk management), trong đó việc nhận dạng và đánh giá rủi ro (Risk assessment) đóng vai trò then chốt. Các nội dung khác của quản lý an toàn thông tin, bao gồm các chuẩn an toàn thông tin, chính sách an toàn thông tin và vấn đề đào tạo, nâng cao ý thức an toàn thông tin của người dùng.
|<image_5>|
_Hình 1.5. Chu trình quản lý an toàn thông tin_
Việc thực thi quản lý an toàn thông tin cần được thực hiện theo chu trình lặp lại, từ khâu lập kế hoạch (Plan), thực thi kế hoạch (Implement), giám sát kết quả thực hiện (Monitor) và thực hiện các kiểm soát (Control) như minh họa trên Hình 1.5, do các điều kiện bên trong và bên ngoài thay đổi theo thời gian.

###  Chính sách an toàn thông tin 

|<image_6>|
_Hình 1.6. Chính sách an toàn thông tin_
Chính sách an toàn thông tin (Information security policy) là các nội quy, quy định của cơ quan, tổ chức, nhằm đảm bảo các biện pháp đảm bảo an toàn thông tin được thực thi và tuân thủ. Chính sách an toàn thông tin, như minh họa trên Hình 1.6 gồm 3 thành phần:
\- Chính sách an toàn ở mức vật lý (Physical security policy);
\- Chính sách an toàn ở mức tổ chức (Organizational security policy); \- Chính sách an toàn ở mức logic (Logical security policy).
Một ví dụ về chính sách an toàn thông tin: để tăng cường an toàn cho hệ thống công nghệ thông tin, một tổ chức có thể áp dụng chính sách xác thực ‘mạnh’ sử dụng các đặc điểm sinh trắc (Biometrics), như xác thực sử dụng vân tay thay cho mật khẩu truyền thống cho hệ thống cửa ra vào trung tâm dữ liệu, hoặc đăng nhập vào hệ thống máy tính.

##  Sự cần thiết của an toàn thông tin 

|<image_7>| _Hình 1.7. Số lượng các thiết bị kết nối vào Internet đến 2015 và dự báo đến 2021_
Trong những năm gần đây, cùng với sự phát triển mạnh mẽ của các thiết bị di động, và đặc biệt là các thiết bị IoT (Internet of Things), số lượng người dùng mạng Internet và số lượng thiết bị kết nối vào mạng Internet tăng trưởng nhanh chóng. Theo thống kê và dự báo của Forbes [3] cho trên Hình 1.7, số lượng các thiết bị có kết nối Internet là khoảng 15 tỷ và dự báo sẽ tăng mạnh lên khoảng 28 tỷ thiết bị có kết nối vào năm 2021. Các thiết bị IoT kết nối thông minh là nền tảng cho phát triển nhiều ứng dụng quan trọng trong các lĩnh vực của đời sống xã hội, như thành phố thông minh, cộng đồng thông minh, ngôi nhà thông minh, ứng dụng giám sát và chăm sóc sức khỏe,…
Cùng với những lợi ích to lớn mà các thiết bị kết nối Internet mạng lại, các sự cố mất an toàn thông tin đối với các hệ thống máy tính, điện thoại di động thông minh, các thiết bị IoT và người dùng cũng tăng vọt. Theo số liệu ghi nhận của Cơ quan Thống kê quốc gia Hoa Kỳ cho trên Hình 1.8, số lượng các sự cố mất an toàn hệ thống thông tin được thông báo đến Cơ quan ứng cứu khẩn cấp máy tính (US-CERT) trong giai đoạn 2006 – 2014 tăng rất mạnh, từ 5.503 vụ vào năm 2006 lên đến 67.168 vụ vào năm 2014\. Ở Việt Nam, trong báo cáo “ _Tổng kết an ninh mạng năm 2015 và dự báo xu hướng 2016_ ” [5], Tập đoàn Bkav cho biết 8.700 tỷ đồng là tổng thiệt hại ước tính do vi rút máy tính gây ra đối với người dùng Việt Nam trong năm 2015. Con số này vẫn ở mức cao và tiếp tục tăng so với 8.500 tỷ đồng của năm 2014. Dự báo trong năm 2016 và các năm tiếp theo, số lượng sự cố và thiệt hại do mất an toàn thông tin gây ra còn có thể lớn hơn nữa, do số lượng thiết bị kết nối tăng trưởng nhanh chóng và nguy cơ từ sự phát triển mạnh của các phần mềm độc hại và các kỹ thuật tấn công, phá hoại tinh vi.
|<image_8>| _Hình 1.8. Số lượng các sự cố toàn hệ thống thông tin được thông báo đến Cơ quan ứng cứu khẩn cấp máy tính (US-CERT) trong giai đoạn 2006 – 2014_
Như vậy, việc đảm bảo an toàn cho thông tin, máy tính, hệ thống mạng và các thiết bị kết nối khác, chống lại các truy nhập trái phép và các cuộc tấn công phá hoại là rất cần thiết không chỉ đối với các cá nhân, cơ quan, tổ chức, doanh nghiệp mà còn đối với an ninh quốc gia. Hơn nữa, việc xây dựng các giải pháp an toàn thông tin chỉ thực sự hiệu quả khi được thực hiện bài bản, đồng bộ, đảm bảo cân bằng giữa tính an toàn, tính hữu dụng của hệ thống và chi phí đầu tư cho các biện pháp đảm bảo an toàn.

# Public_152

#  Khái quát về an toàn hệ thống thông tin 

##  Các thành phần của hệ thống thông tin 

|<image_1>|
_Hình 1.9. Mô hình hệ thống thông tin của cơ quan, tổ chức_
_Hệ thống thông tin_ (Information system), theo cuốn sách Fundamentals of Information Systems Security [2] là một hệ thống tích hợp các thành phần nhằm phục vụ việc thu thập, lưu trữ, xử lý thông tin và chuyển giao thông tin, tri thức và các sản phẩm số. Trong nền kinh tế số, hệ thống thông tin đóng vai trò rất quan trọng trong hoạt động của các tổ chức, cơ quan và doanh nghiệp (gọi chung là tổ chức). Có thể nói, hầu hết các tổ chức đều sử dụng các hệ thống thông tin với các quy mô khác nhau để quản lý các hoạt động của mình. Hình 1.9 minh họa mô hình một hệ thống thông tin điển hình. Trong mô hình này, mỗi hệ thống thông tin gồm ba thành phần chính: (i) thành phần thu thập thông tin (Input), (ii) thành phần xử lý thông tin (Processing) và (iii) thành phần kết xuất thông tin (Output). Hệ thống thông tin được sử dụng để tương tác với khách hàng (Customers), với nhà cung cấp (Suppliers), với cơ quan chính quyền (Regulatory Agencies), với cổ đông và với đối thủ cạnh tranh (Competitors). Có thể nêu là một số hệ thống thông tin điển hình như các hệ lập kế hoạch nguồn lực doanh nghiệp, các máy tìm kiếm và các hệ thống thông tin địa lý.
Trong lớp các hệ thống thông tin, hệ thống thông tin dựa trên máy tính (Computer based information system), hay sử dụng công nghệ máy tính để thực thi các nhiệm vụ là lớp hệ thống thông tin được sử dụng rộng rãi nhất. Hệ thống thông tin dựa trên máy tính thường gồm các thành phần: phần cứng (Hardware) để thu thập, lưu trữ, xử lý và biểu diễn dữ liệu; phần mềm (Software) chạy trên phần cứng để xử lý dữ liệu; cơ sở dữ liệu (Databases) để lưu trữ dữ liệu; mạng (Networks) là hệ thống truyền dẫn thông tin/dữ liệu; và các thủ tục (Procedures) là tập hợp các lệnh kết hợp các bộ phận nêu trên để xử lý dữ liệu, đưa ra kết quả mong muốn.

##  An toàn hệ thống thông tin là gì? 

_An toàn hệ thống thông tin_ (Information systems security) là việc đảm bảo các thuộc tính an ninh, an toàn của hệ thống thông tin, bao gồm tính _bí mật_ (confidentiality), tính _toàn vẹn_ (integrity) và tính _sẵn dùng_ (availability). Hình 1.10 minh họa các thành phần của Hệ thống thông tin dựa trên máy tính và An toàn hệ thống thông tin.
|<image_2>|
_Hình 1.10. Các thành phần của hệ thống thông tin và an toàn hệ thống thông tin_

#  Các yêu cầu đảm bảo an toàn hệ thống thông tin 

Như đã trình bày trong Mục 1.1.1 **Error! Reference source not found.** , việc đảm bảo an toàn thông tin, hoặc hệ thống thông tin là việc đảm bảo ba thuộc tính của thông tin, hoặc hệ thống, bao gồm tính _Bí mật_ (Confidentiality), tính _Toàn vẹn_ (Integrity) và tính _Sẵn dùng_ (Availability). Đây cũng là ba yêu cầu đảm bảo an toàn thông tin và hệ thống thông tin.

##  Bí mật 

Tính bí mật đảm bảo rằng chỉ người dùng có thẩm quyền mới được truy nhập thông tin, hệ thống. Các thông tin bí mật có thể bao gồm: (i) dữ liệu riêng của cá nhân, (ii) các thông tin thuộc quyền sở hữu trí tuệ của các doanh nghiệp hay các cơ quan, tổ chức và (iii) các thông tin có liên quan đến an ninh của các quốc gia và các chính phủ. Hình 1.11
minh họa một văn bản được đóng dấu _Confidential_ (Mật), theo đó chỉ những người có thẩm quyền (có thể không gồm người soạn thảo văn bản) mới được đọc và phổ biến văn bản.
|<image_3>|
_Hình 1.11. Một văn bản được đóng dấu Confidential (Mật)_
|<image_4>| _Hình 1.12. Đảm bảo tính bí mật bằng đường hầm VPN, hoặc mã hóa_
Thông tin bí mật lưu trữ hoặc trong quá trình truyền tải cần được bảo vệ bằng các biện pháp phù hợp, tránh bị lộ lọt hoặc bị đánh cắp. Các biện pháp có thể sử dụng để đảm bảo tính bí mật của thông tin như bảo vệ vật lý, hoặc sử dụng mật mã (cryptography). Hình 1.12 minh họa việc đảm bảo tính bí mật bằng cách sử dụng đường hầm VPN, hoặc mã hóa để truyền tải thông tin.

## Toàn vẹn 

Tính toàn vẹn đảm bảo rằng thông tin và dữ liệu chỉ có thể được sửa đổi bởi những người dùng có thẩm quyền. Tính toàn vẹn liên quan đến tính hợp lệ (validity) và chính xác (accuracy) của dữ liệu. Trong nhiều tổ chức, thông tin và dữ liệu có giá trị rất lớn, như bản quyền phần mềm, bản quyền âm nhạc, bản quyền phát minh, sáng chế. Mọi thay đổi không có thẩm quyền có thể ảnh hưởng rất nhiều đến giá trị của thông tin. Thông tin hoặc dữ liệu là toàn vẹn nếu nó thỏa mãn ba điều kiện: (i) không bị thay đổi, (ii) hợp lệ và (iii) chính xác.

## Sẵn dùng 

Tính sẵn dùng, hoặc khả dụng đảm bảo rằng thông tin, hoặc hệ thống có thể truy nhập bởi người dùng hợp pháp bất cứ khi nào họ có yêu cầu. Tính sẵn dùng có thể được đo bằng các yếu tố:
\- Thời gian cung cấp dịch vụ (Uptime);
\- Thời gian ngừng cung cấp dịch vụ (Downtime);
\- Tỷ lệ phục vụ: A = (Uptime) / (Uptime + Downtime);
\- Thời gian trung bình giữa các sự cố;
\- Thời gian trung bình ngừng để sửa chữa;
\- Thời gian khôi phục sau sự cố.
|<image_5>| _Hình 1.13. Minh họa tính sẵn dùng: (a) không đảm bảo và (b) đảm bảo tính sẵn dùng_
Hình 1.13 minh họa tính sẵn dùng: trường hợp (a) hệ thống không đảm bảo tính sẵn dùng khi có một số thành phần gặp sự cố thì không có khả năng phục vụ tất cả các yêu cầu của người dùng và (b) hệ thống đảm bảo tính sẵn dùng khi các thành phần của nó hoạt động bình thường.

##  Bảy vùng trong hạ tầng CNTT và các mối đe dọa 

###  Bảy vùng trong cơ sở hạ tầng CNTT 

Hạ tầng công nghệ thông tin (IT Infrastructure) của các cơ quan, tổ chức, doanh nghiệp có thể có quy mô lớn hay nhỏ khác nhau, nhưng thường gồm bảy vùng theo mức kết nối mạng như minh họa trên Hình 1.14.
Các vùng cụ thể gồm: vùng người dùng (User domain), vùng máy trạm (Workstation domain), vùng mạng LAN (LAN domain), vùng LAN-to-WAN (LAN-to-WAN domain), vùng mạng WAN (WAN domain), vùng truy nhập từ xa (Remote Access domain) và vùng hệ thống/ứng dụng (Systems/Applications domain). Do mỗi vùng kể trên có đặc điểm khác nhau nên chúng có các mối đe dọa và nguy cơ mất an toàn thông tin khác nhau.
|<image_6>| _Hình 1.14. Bảy vùng trong hạ tầng CNTT theo mức kết nối mạng_

### Các mối đe dọa 

_Vùng người dùng_
Có thể nói vùng người dùng là vùng có nhiều mối đe dọa và nguy cơ nhất do người dùng có bản chất khó đoán định và khó kiểm soát hành vi. Các vấn đề thường gặp như thiếu ý thức, coi nhẹ vấn đề an ninh an toàn, vi phạm các chính sách an ninh an toàn; đưa CD/DVD/USB với các file cá nhân vào hệ thống; tải ảnh, âm nhạc, video trái phép; phá hoại dữ liệu, ứng dụng và hệ thống; các nhân viên bất mãn có thể tấn công hệ thống từ
bên trong, hoặc nhân viên có thể tống tiền hoặc chiếm đoạt thông tin nhạy cảm, thông tin quan trọng.
_Vùng máy trạm_
Vùng máy trạm cũng có nhiều mối đe dọa và nguy cơ do vùng máy trạm tiếp xúc trực tiếp với vùng người dùng. Các nguy cơ thường gặp gồm: truy nhập trái phép vào máy trạm, hệ thống, ứng dụng và dữ liệu; các lỗ hổng an ninh trong hệ điều hành, trong các phần mềm ứng dụng máy trạm; các hiểm họa từ vi rút, mã độc và các phần mềm độc hại. Ngoài ra, vùng máy trạm cũng chịu các nguy cơ do hành vi bị cấm từ người dùng, như đưa CD/DVD/USB với các file cá nhân vào hệ thống; tải ảnh, âm nhạc, video trái phép.
_Vùng mạng LAN_
Các nguy cơ có thể có đối với vùng mạng LAN bao gồm: truy nhập trái phép vào mạng LAN vật lý, truy nhập trái phép vào hệ thống, ứng dụng và dữ liệu; các lỗ hổng an ninh trong hệ điều hành và các phần mềm ứng dụng máy chủ; nguy cơ từ người dùng giả mạo trong mạng WLAN; tính bí mật dữ liệu trong mạng WLAN có thể bị đe dọa do sóng mang thông tin của WLAN truyền trong không gian có thể bị nghe trộm. Ngoài ra, các hướng dẫn và cấu hình chuẩn cho máy chủ LAN nếu không được tuân thủ nghiêm ngặt sẽ
dẫn đến những lỗ hổng an ninh mà tin tặc có thể khai thác.
_Vùng mạng LAN-to-WAN_
Vùng mạng LAN-to-WAN là vùng chuyển tiếp từ mạng nội bộ ra mạng diện rộng, nên nguy cơ lớn nhất là tin tặc từ mạng WAN có thể thăm dò và rà quét trái phép các cổng dịch vụ, nguy cơ truy nhập trái phép. Ngoài ra, một nguy cơ khác cần phải xem xét là lỗ hổng an ninh trong các bộ định tuyến, tường lửa và các thiết bị mạng khác.
_Vùng mạng WAN_
Vùng mạng WAN, hay mạng Internet là vùng mạng mở, trong đó hầu hết dữ liệu được truyền dưới dạng rõ, nên các nguy cơ lớn nhất là dễ bị nghe trộm và dễ bị tấn công phá hoại, tấn công từ chối dịch vụ (DoS) và từ chối dịch vụ phân tán (DDoS). Kẻ tấn công có thể tự do, dễ dàng gửi email có đính kèm vi rút, sâu và các phần mềm độc hại.
_Vùng truy nhập từ xa_
Trong vùng truy nhập từ xa, các nguy cơ điển hình bao gồm: tấn công kiểu vét cạn vào tên người dùng và mật khẩu, tấn công vào hệ thống đăng nhập và điều khiển truy nhập; truy nhập trái phép vào hệ thống CNTT, ứng dụng và dữ liệu; các thông tin bí mật có thể bị đánh cắp từ xa; và vấn đề rò rỉ dữ liệu do vi phạm các tiêu chuẩn phân loại dữ
liệu.
_Vùng hệ thống và ứng dụng_
Trong vùng hệ thống và ứng dụng, các nguy cơ có thể bao gồm: truy nhập trái phép đến trung tâm dữ liệu, phòng máy hoặc tủ cáp; các khó khăn trong quản lý các máy chủ với yêu cầu tính sẵn dùng cao; các lỗ hổng trong quản lý các phần mềm ứng dụng của hệ điều hành máy chủ; các vấn đề an ninh trong các môi trường ảo của điện toán đám mây; và vấn đề hỏng hóc hoặc mất dữ liệu.

## Mô hình tổng quát đảm bảo an toàn hệ thống thông tin 

### Giới thiệu mô hình Phòng vệ theo chiều sâu

Mô hình tổng quát đảm bảo an toàn hệ thống thông tin là _Phòng vệ theo chiều sâu_ (Defence in Depth). Theo mô hình này, ta cần tạo ra nhiều lớp bảo vệ, kết hợp tính năng, tác dụng của mỗi lớp để đảm bảo an toàn tối đa cho thông tin, hệ thống và mạng. Một lớp, một công cụ phòng vệ riêng rẽ dù có hiện đại, nhưng vẫn không thể đảm bảo an toàn. Do vậy, việc tạo ra nhiều lớp bảo vệ có khả năng bổ sung cho nhau là cách làm hiệu quả. Một điểm khác cần lưu ý khi thiết kế và triển khai hệ thống đảm bảo an toàn thông tin là cần cân bằng giữa _tính hữu dụng_ (Usability), _chi phí_ (Cost) và _an toàn_ (Security), như minh họa trên Hình 1.15. Hệ thống đảm bảo an toàn thông tin chỉ thực sự phù hợp và hiệu quả khi hệ thống được bảo vệ đạt mức an toàn phù hợp mà vẫn có khả năng cung cấp các tính năng hữu dụng cho người dùng, với chi phí cho đảm bảo an |<image_7>|toàn phù hợp với tài sản được bảo vệ.
_Hình 1.15. Các lớp bảo vệ cần cân bằng giữa Tính hữu dụng (Usability), Chi phí (Cost) và An toàn (Security)_

###  Các lớp bảo vệ trong mô hình Phòng vệ theo chiều sâu 

|<image_8>|Hình 1.16 minh họa mô hình đảm bảo an toàn thông tin với bảy lớp bảo vệ, bao gồm lớp chính sách, thủ tục, ý thức (Policies, procedures, awareness); lớp vật lý (Physical); lớp ngoại vi (Perimeter); lớp mạng nội bộ (Internal network); lớp host (Host); lớp ứng dụng (Application) và lớp dữ liệu (Data). Trong mô hình này, để truy nhập được đến đối tượng đích là dữ liệu, tin tặc cần phải vượt qua cả 7 lớp bảo vệ.
_Hình 1.16. Mô hình đảm bảo an toàn thông tin với bảy lớp_
Tương tự, Hình 1.17 minh họa mô hình phòng vệ gồm 3 lớp: lớp an ninh cơ quan/tổ chức, lớp an ninh mạng và lớp an ninh hệ thống. Mỗi lớp trên lại gồm một số lớp con như sau:
\- Lớp an ninh cơ quan/tổ chức (Plant Security), gồm 2 lớp con:
\+ Lớp bảo vệ vật lý (Physical Security) có nhiệm vụ kiểm soát các truy nhập vật lý đến các trang thiết bị hệ thống và mạng.
\+ Lớp chính sách & thủ tục (Policies & procedures) bao gồm các quy trình quản lý ATTT, các hướng dẫn vận hành, quản lý hoạt động liên tục và phục hồi sau sự cố.
\- Lớp an ninh mạng (Network Security), gồm 2 lớp con:
\+ Lớp bảo vệ vùng hạn chế truy nhập (Security cells and DMZ) cung cấp các biện pháp bảo vệ cho từng phân đoạn mạng.
\+ Lớp các tường lửa, mạng riêng ảo (Firewalls and VPN) được triển khai như điểm truy nhập duy nhất đến một phân đoạn mạng.
\- Lớp an ninh hệ thống (System Integrity), gồm 4 lớp con:
\+ Lớp tăng cường an ninh hệ thống (System hardening) đảm bảo việc cài đặt và cấu hình các thành phần trong hệ thống đảm bảo các yêu cầu an toàn. + Lớp quản trị tài khoản người dùng (User Account Management) thực hiện kiểm soát truy nhập dựa trên quyền truy nhập và các đặc quyền của người dùng. + Lớp quản lý các bản vá (Patch Management) có nhiệm vụ định kỳ cài đặt các bản vá an ninh và các bản cập nhật cho hệ thống.
|<image_9>|+ Lớp phát hiện và ngăn chặn phần mềm độc hại (Malware detection and prevention) có nhiệm vụ bảo vệ hệ thống, chống vi rút và các phần mềm độc hại khác.
_Hình 1.17. Mô hình đảm bảo an toàn thông tin với ba lớp chính_

# Public_153

_Chương 2 giới thiệu khái quát về mối đe dọa, điểm yếu, lỗ hổng tồn tại trong hệ thống và tấn công. Phần tiếp theo phân tích chi tiết các dạng tấn công điển hình vào các hệ thống máy tính và mạng, bao gồm tấn công vào mật khẩu, tấn công nghe lén, người đứng giữa, tấn công DoS, DDoS, tấn công sử dụng các kỹ thuật xã hội,… Nửa cuối của chương đề cập đến các dạng phần mềm độc hại, gồm cơ chế lây nhiễm và tác hại của chúng. Kèm theo phần mô tả mỗi tấn công, hoặc phần mềm độc hại, chương đề cập các biện pháp, kỹ thuật phòng chống._

# Khái quát về mối đe dọa, điểm yếu, lỗ hổng và tấn công

## Khái niệm mối đe dọa, điểm yếu, lỗ hổng và tấn công

_Mối đe dọa (Threat)_ là bất kỳ một hành động nào có thể gây hư hại đến các tài nguyên hệ thống. Các tài nguyên hệ thống bao gồm phần cứng, phần mềm, cơ sở dữ liệu, các file, dữ liệu, hoặc hạ tầng mạng vật lý,…
_Các điểm yếu hệ thống_ (System weaknesses) là các lỗi hay các khiếm khuyết tồn tại trong hệ thống. Nguyên nhân của sự tồn tại các điểm yếu có thể do lỗi thiết kế, lỗi cài đặt, lỗi lập trình, hoặc lỗi quản trị, cấu hình hoạt động. Các điểm yếu có thể tồn tại trong cả các mô đun phần cứng và các mô đun phần mềm. Một số điểm yếu được phát hiện và đã được khắc phục. Tuy nhiên, có một số điểm yếu được phát hiện nhưng chưa được khắc phục, hoặc các điểm yếu chưa được phát hiện, hoặc chỉ tồn tại trong một điều kiện đặc biệt nào đó.

|<image_1>|

_Hình 2.1. Phân bố lỗ hổng bảo mật trong các thành phần của hệ thống_

_Lỗ hổng bảo mật_ (Security vulnerability) là một điểm yếu tồn tại trong một hệ thống cho phép tin tặc khai thác gây tổn hại đến các thuộc tính an ninh của hệ thống đó, bao gồm tính toàn vẹn, tính bí mật, tính sẵn dùng. Nói chung, lỗ hổng bảo mật tồn tại trong tất cả các thành phần của hệ thống, bao gồm phần cứng, hệ điều hành và các phần mềm ứng dụng. Theo số liệu thống kê từ Cơ sở dữ liệu lỗ hổng quốc gia Hoa Kỳ [6], trong năm 2012, phân bố lỗ hổng bảo mật được phát hiện trên các thành phần của hệ thống lần lượt là phần cứng – 4%, hệ điều hành – 10% và phần mềm ứng dụng – 86%, như minh họa trên Hình 2.1. Như vậy, có thể thấy các lỗ hổng bảo mật chủ yếu xuất hiện trong hệ thống phần mềm và phần lớn tồn tại trong các phần mềm ứng dụng.

|<image_2>|

_Hình 2.2. Phân bố lỗ hổng bảo mật theo mức độ nghiêm trọng_
Phụ thuộc vào khả năng bị khai thác, các lỗ hổng bảo mật có mức độ nghiêm trọng (severity) khác nhau. Theo Microsoft, có 4 mức độ nghiêm trọng của các lỗ hổng bảo mật: _nguy hiểm_ (Critical), _quan trọng_ (Important), _trung bình_ (Moderate) và _thấp_ (Low). Tuy nhiên, một số tổ chức khác chỉ phân loại các lỗ hổng bảo mật theo 3 mức độ nghiêm trọng: _cao_ (High), _trung bình_ (Medium) và _thấp_ (Low). Cũng theo số liệu thống kê từ [6] cho trên Hình 2.2, các lỗ hổng có mức độ nghiêm trọng cao chiếm 35%, các lỗ hổng có mức độ nghiêm trọng trung bình chiếm 55% và các lỗ hổng có mức độ nghiêm trọng thấp chỉ chiếm 10%. Như vậy, ta có thể thấy, đa số các lỗ hổng bảo mật có mức độ nghiêm trọng từ trung bình trở lên và cần được xem xét khắc phục càng sớm càng tốt.
_Tấn công (Attack)_ là một, hoặc một chuỗi các hành động vi phạm các chính sách an ninh an toàn của cơ quan, tổ chức, gây tổn hại đến các thuộc tính bí mật, toàn vẹn và sẵn dùng của thông tin, hệ thống và mạng. Một cuộc tấn công vào hệ thống máy tính hoặc các tài nguyên mạng thường được thực hiện bằng cách khai thác các lỗ hổng tồn tại trong hệ thống. Như vậy, tấn công chỉ có thể trở thành hiện thực nếu có sự tồn tại đồng thời của mối đe dọa và lỗ hổng, hay có thể nói:
Tấn công = Mối đe dọa + Lỗ hổng
Như vậy, mối đe dọa và lỗ hổng bảo mật có quan hệ hữu cơ với nhau: Các mối đe dọa thường khai thác một hoặc một số lỗ hổng bảo mật đã biết để thực hiện các cuộc tấn công phá hoại. Điều này có nghĩa là nếu tồn tại một lỗ hổng trong hệ thống, sẽ có khả năng một mối đe dọa trở thành hiện thực. Nói chung, không thể triệt tiêu được hết các mối đe dọa do đó là yếu tố khách quan, nhưng có thể giảm thiểu các lỗ hổng, qua đó giảm thiểu khả năng bị khai thác để thực hiện tấn công.

## Các dạng mối đe dọa thường gặp

Trên thực tế, không phải tất cả các mối đe dọa đều là ác tính hay độc hại (malicious). Một số mối đe dọa là chủ động, cố ý, nhưng một số khác chỉ là ngẫu nhiên, hoặc vô tình. Các mối đe dọa thường gặp đối với thông tin, hệ thống và mạng:

  * Phần mềm độc hại

  * Kẻ tấn công ở bên trong

  * Kẻ tấn công ở bên ngoài

  * Hư hỏng phần cứng hoặc phần mềm

  * Mất trộm các thiết bị

  * Tai họa thiên nhiên

  * Gián điệp công nghiệp

  * Khủng bố phá hoại.


## Các loại tấn công

Có thể chia tấn công theo mục đích thực hiện thành 4 loại chính như sau:

  * Giả mạo (Fabrications): Tấn công giả mạo thông tin thường được sử dụng để đánh lừa người dùng thông thường;

  * Chặn bắt (Interceptions): Tấn công chặn bắt thường liên quan đến việc nghe lén trên đường truyền và chuyển hướng thông tin để sử dụng trái phép;

  * Gây ngắt quãng (Interruptions): Tấn công gây ngắt quãng làm ngắt, hoặc chậm kênh truyền thông, hoặc làm quá tải hệ thống, ngăn cản việc truy nhập dịch vụ của người dùng hợp pháp;

  * Sửa đổi (Modifications): Tấn công sửa đổi liên quan đến việc sửa đổi thông tin trên đường truyền hoặc sửa đổi dữ liệu file.


Theo hình thức thực hiện, có thể chia các loại tấn công thành 2 kiểu chính như sau:

  * Tấn công chủ động (Active attacks): Tấn công chủ động là một đột nhập, xâm nhập (intrusion) về mặt vật lý vào hệ thống, hoặc mạng. Các tấn công chủ động thực hiện sửa đổi dữ liệu trên đường truyền, sửa đổi dữ liệu trong file, hoặc giành quyền truy nhập trái phép vào máy tính hoặc hệ thống mạng.

  * Tấn công thụ động (Passive attacks): Tấn công thụ động thường không gây ra thay đổi trên hệ thống. Các tấn công thụ động điển hình là nghe trộm và giám sát lưu lượng trên đường truyền.


Trên thực tế, tấn công thụ động thường là giai đoạn đầu của tấn công chủ động, trong đó tin tặc sử dụng các kỹ thuật tấn công thụ động để thu thập các thông tin về hệ thống, mạng, và trên cơ sở thông tin có được sẽ lựa chọn kỹ thuật tấn công chủ động có xác suất thành công cao nhất.

# Các công cụ hỗ trợ tấn công

Các công cụ hỗ trợ tấn công (Attacking assistant tools) là các công cụ phần cứng, phần mềm, hoặc các kỹ thuật hỗ trợ kẻ tấn công, tin tặc (attacker) thu thập các thông tin
về các hệ thống máy tính, hoặc mạng. Trên cơ sở các thông tin thu được, tin tặc sẽ lựa chọn công cụ, kỹ thuật tấn công có xác suất thành công cao nhất. Các công cụ hỗ trợ tấn công bao gồm 4 nhóm chính: công cụ quét điểm yếu, lỗ hổng bảo mật, công cụ quét cổng dịch vụ, công cụ nghe lén và công cụ ghi phím gõ.

## Công cụ rà quét lỗ hổng, điểm yếu hệ thống

Các công cụ rà quét các điểm yếu hệ thống và lỗ hổng bảo mật có thể được người quản trị sử dụng để chủ động rà quét các hệ thống, nhằm tìm ra các điểm yếu và lỗ hổng bảo mật tồn tại trong hệ thống. Trên cơ sở kết quả rà quét, phân tích và đề xuất áp dụng các biện pháp khắc phục phù hợp. Mặt khác, các công cụ này cũng có thể được kẻ tấn công sử dụng để rà quét hệ thống và dựa trên kết quả rà quét điểm yếu, lỗ hổng để quyết định dạng tấn công có khả năng thành công cao nhất. Các công cụ bao gồm, các công cụ rà quét lỗ hổng bảo mật hệ thống, và các công cụ rà quét lỗ hổng ứng dụng web, hay các trang web.

### Công cụ rà quét lỗ hổng bảo mật hệ thống

Các công cụ rà quét lỗ hổng bảo mật hệ thống cho phép rà quét hệ thống, tìm các điểm yếu và các lỗ hổng bảo mật. Đồng thời, chúng cũng cung cấp phần phân tích chi tiết từng điểm yếu, lỗ hổng, kèm theo là hướng dẫn khắc phục, sửa chữa. Các công cụ được sử dụng rộng rãi là Microsoft Baseline Security Analyzer (Hình 2.3) cho rà quét các hệ thống chạy hệ điều hành Microsoft Windows và Nessus Vulnerability Scanner cho rà quét các hệ thống chạy nhiều loại hệ điều hành khác nhau.

|<image_3>|

_Hình 2.3. Báo cáo kết quả quét của Microsoft Baseline Security Analyzer_

### Công cụ rà quét lỗ hổng ứng dụng web

Các công cụ rà quét lỗ hổng ứng dụng web cho phép rà quét, phân tích các trang web, tìm các lỗi và lỗ hổng bảo mật. Chúng cũng hỗ trợ phân tích tình trạng các lỗi tìm được, như các lỗi XSS, lỗi chèn mã SQL, lỗi CSRF, lỗi bảo mật phiên,… Các công cụ được sử
|<image_4>|dụng phổ biến bao gồm Acunetix Web Vulnerability Scanner (Hình 2.4), IBM AppScan, Beyond Security AVDS và SQLmap.

_Hình 2.4. Kết quả quét website sử dụng Acunetix Web Vulnerability Scanner_

## Công cụ quét cổng dịch vụ

|<image_5>|

_Hình 2.5. Giao diện của công cụ Zenmap_
Các công cụ quét cổng dịch vụ (Port scanners) cho phép quét các cổng, tìm các cổng đang mở, đang hoạt động, đồng thời tìm các thông tin về ứng dụng, dịch vụ và hệ điều hành đang hoạt động trên hệ thống. Dựa trên thông tin quét cổng dịch vụ, có thể xác định được dịch vụ, ứng dụng nào đang chạy trên hệ thống:

  * Cổng 80/443 mở có nghĩa là dịch vụ web đang hoạt động;

  * Cổng 25 mở có nghĩa là dịch vụ gửi/nhận email SMTP đang hoạt động;

  * Cổng 1433 mở có nghĩa là máy chủ Microsoft SQL Server đang hoạt động;

  * Cổng 53 mở có nghĩa là dịch vụ tên miền DNS đang hoạt động,...


Các công cụ quét cổng dịch vụ được sử dụng phổ biến bao gồm: Nmap, Zenmap, Portsweep, Advanced Port Scanner, Angry IP Scanner, SuperScan và NetScanTools. Hình 2.5 là giao diện của công cụ quét cổng dịch vụ Nmap/ Zenmap – một trong các công cụ quét cổng dịch vụ được sử dụng rộng rãi. Nmap cung cấp tập lệnh rà quét rất mạnh. Tuy nhiên, Nmap hơi khó dùng do chỉ hỗ trợ giao diện dòng lệnh.

## Công cụ nghe trộm

Công cụ nghe trộm hay nghe lén (Sniffers) cho phép bắt các gói tin khi chúng được truyền trên mạng. Công cụ nghe lén có thể là mô đun phần cứng, phần mềm hoặc kết hợp. Các thông tin nhạy cảm như thông tin tài khoản, thẻ tín dụng, hoặc mật khẩu nếu không được mã hóa thì có thể bị kẻ tấn công nghe lén khi được truyền từ máy trạm đến máy chủ và bị lạm dụng. Một số công cụ phần mềm cho phép bắt gói tin truyền trên mạng:

  * Tcpdump

  * Wireshark (minh họa trên Hình 2.6)

  * Pcap / Wincap / Libcap (Packet capture)

  * IP Tools ([http://www.softpedia.com).](http://www.softpedia.com/)


|<image_6>|

_Hình 2.6. Sử dụng Wireshark để bắt gói tin có chứa thông tin nhạy cảm_

## Công cụ ghi phím gõ

Công cụ ghi phím gõ (Keyloggers) là một dạng công cụ giám sát bằng phần cứng hoặc phần mềm có khả năng ghi lại mọi phím người dùng gõ và lưu vào một file. File đã ghi sau đó có thể được gửi cho kẻ tấn công theo địa chỉ chỉ định trước hoặc sao chép trực tiếp. Ngoài kẻ tấn công, người quản lý cũng có thể cài đặt Keylogger vào máy tính của nhân viên để theo dõi hoạt động của các nhân viên. Việc cài đặt Keylogger có thể được thực hiện tương đối đơn giản: Hình 2.7 minh họa một Keylogger dưới dạng một khớp nối phần cứng kết nối cổng bàn phím với đầu nối bàn phím, hỗ trợ cả giao diện cổng bàn phím PS/2 và USB. Với Keylogger phần mềm, kẻ tấn công có thể tích hợp Keylogger vào một phần mềm thông thường và lừa người dùng cài đặt vào máy tính của mình.

|<image_7>||<image_8>|

_Hình 2.7. Mô đun Keylogger phần cứng và cài đặt trên máy tính để bà_

# Public_154

# Tấn công từ chối dịch vụ và từ chối dịch vụ phân tán

## Tấn công từ chối dịch vụ

### Giới thiệu

Tấn công từ chối dịch vụ (Denial of Service - DoS) là dạng tấn công nhằm ngăn chặn người dùng hợp pháp truy nhập các tài nguyên mạng. Tấn công DoS có thể được chia thành 2 loại: (1) tấn công logic (Logic attacks) và (2) tấn công gây ngập lụt (Flooding attacks). Tấn công logic là dạng tấn công khai thác các lỗi phần mềm làm dịch vụ ngừng hoạt động, hoặc làm giảm hiệu năng hệ thống. Tấn công DoS sử dụng sâu Slammer đề cập ở Mục 2.3.2.2 là dạng tấn công khai thác lỗi tràn bộ đệm trong phần mềm. Ngược lại, trong tấn công gây ngập lụt, kẻ tấn công gửi một lượng lớn yêu cầu gây cạn kiệt tài nguyên hệ thống hoặc băng thông đường truyền mạng.

Có nhiều kỹ thuật tấn công DoS đã được phát hiện trên thực tế. Các kỹ thuật tấn công DoS thường gặp bao gồm: SYN Flood, Smurf, Teardrop, Ping of Death, Land Attacks, ICMP Flood, HTTP Flood, UDP Flood,… Trong phạm vi của môn học này, chúng ta chỉ đề cập đến 2 kỹ thuật phổ biến nhất là SYN Flood và Smurf.

### Tấn công SYN flood

  * _Giới thiệu_


Tấn công SYN Flood là kỹ thuật tấn công DoS khai thác điểm yếu trong thủ tục bắt tay 3 bước (3-way handshake) khi hai bên tham gia truyền thông thiết lập kết nối TCP để bắt đầu phiên trao đổi dữ liệu. SYN là bit cờ điều khiển của giao thức TCP dùng để đồng bộ số trình tự gói tin. Thủ tục bắt tay khi một người dùng hợp pháp thiết lập một kết nối TCP đến máy chủ, như minh họa trên hình Hình 2.21 (a) gồm 3 bước như sau:

  * Người dùng thông qua máy khách gửi yêu cầu mở kết nối (SYN hay SYN-REQ) đến máy chủ;

  * Máy chủ nhận được lưu yêu cầu kết nối vào Bảng kết nối (Backlog) và gửi lại xác nhận kết nối SYN-ACK cho máy khách;

  * Khi nhận được SYN-ACK từ máy chủ, máy khách gửi lại xác nhận kết nối ACK đến máy chủ. Khi máy chủ nhận được xác nhận kết nối ACK từ máy khách, nó xác nhận kết nối mở thành công, máy chủ và máy khách bắt đầu phiên truyền thông TCP. Bản ghi mở kết nối được xóa khỏi Bảng kết nối.


|<image_1>|

  1. |<image_2>|Thủ tục bắt tay 3 buớc bình


thuờng của giao thức TCP (b) Tấn công SYN Flood

_Hình 2.21. (a) Thủ tục bắt tay 3 bước của TCP và (b) Tấn công SYN Flood_

  * _Kịch bản tấn công_


Kịch bản tấn công SYN Flood, như minh họa trên Hình 2.21 (b) gồm các bước sau:

  * Kẻ tấn công gửi một lượng lớn yêu cầu mở kết nối (SYN-REQ) đến máy nạn nhân;

  * Nhận được yêu cầu mở kết nối, máy nạn nhân lưu yêu cầu kết nối vào Bảng kết nối trong bộ nhớ;

  * Máy nạn nhân sau đó gửi xác nhận kết nối (SYN-ACK) đến kẻ tấn công;

  * Do kẻ tấn công không gửi lại xác nhận kết nối ACK, nên máy nạn nhân vẫn phải lưu tất cả các yêu cầu kết nối chưa được xác nhận trong Bảng kết nối. Khi Bảng kết nối bị điền đầy thì các yêu cầu mở kết nối của người dùng hợp pháp sẽ bị từ chối;

  * Máy nạn nhân chỉ có thể xóa một yêu cầu kết nối đang mở khi nó hết hạn (timed- out).


Do kẻ tấn công thường sử dụng địa chỉ IP giả mạo, hoặc địa chỉ không có thực làm địa chỉ nguồn (Source IP) trong gói tin IP yêu cầu mở kết nối, nên xác nhận kết nối SYN- ACK của máy nạn nhân không thể đến đích. Đồng thời, kẻ tấn công cố tình tạo một lượng rất lớn yêu cầu mở kết nối dở dang để chúng điền đầy bảng kết nối. Hậu quả là máy nạn nhân không thể chấp nhận yêu cầu mở kết nối của những người dùng khác. Tấn công SYN Flood làm cạn kiệt tài nguyên bộ nhớ (cụ thể là bộ nhớ Bảng kết nối) của máy nạn nhân, có thể làm máy nạn nhân ngừng hoạt động và gây nghẽn đường truyền mạng.

  * _Phòng chống_


Nhiều biện pháp phòng chống tấn công SYN Flood được đề xuất, nhưng chưa có giải pháp nào có khả năng ngăn chặn triệt để dạng tấn công này. Do vậy, để phòng chống tấn công SYN Flood hiệu quả, cần kết hợp các biện pháp sau:

  * Sử dụng kỹ thuật lọc địa chỉ giả mạo (Spoofed IP Filtering): Kỹ thuật này đòi hỏi chỉnh sửa giao thức TCP/IP không cho phép kẻ tấn công giả mạo địa chỉ;

  * Tăng kích thước Bảng kết nối: Tăng kích thước Bảng kết nối cho phép tăng khả năng chấp nhận các yêu cầu mở kết nối;

  * Giảm thời gian chờ (SYN-RECEIVED Timer): Các yêu cầu mở kết nối chưa được xác nhận sẽ bị xóa sớm hơn khi thời gian chờ ngắn hơn;

  * SYN cache: Một yêu cầu mở kết nối chỉ được cấp phát không gian nhớ đầy đủ khi nó được xác nhận;

  * Sử dụng tường lửa (Firewall) và Proxy: Tường lửa và proxy có khả năng nhận dạng các địa chỉ IP nguồn là địa chỉ không có thực, đồng thời chúng có khả năng tiếp nhận yêu cầu mở kết nối, chờ đến khi có xác nhận mới chuyển cho máy chủ đích.


### Tấn công Smurf

  * _Giới thiệu_


Tấn công Smurf là dạng tấn công DoS sử dụng giao thức điều khiển truyền ICMP và kiểu phát quảng bá có định hướng để gây ngập lụt đường truyền mạng của máy nạn nhân. Trên mỗi phân vùng mạng IP thường có 1 địa chỉ quảng bá, theo đó khi có một gói tin gửi tới địa chỉ này, nó sẽ được router của mạng chuyển đến tất cả các máy trong mạng đó.

|<image_3>|

_Hình 2.22. Mô hình tấn công Smurf_

  * _Kịch bản tấn công_


Hình 2.22 minh họa mô hình tấn công DoS Smurf. Theo đó, kịch bản tấn công Smurf gồm các bước:

  * Kẻ tấn công gửi một lượng lớn gói tin chứa yêu cầu ICMP (Ping) với địa chỉ IP nguồn là địa chỉ của máy nạn nhân đến một địa chỉ quảng bá (IP Broadcast address) của một mạng;

  * Router của mạng nhận được yêu cầu ICMP gửi đến địa chỉ quảng bá sẽ tự động chuyển yêu cầu này đến tất cả các máy trong mạng;

  * Các máy trong mạng nhận được yêu cầu ICMP sẽ gửi trả lời (reply) đến máy có địa chỉ IP là địa nguồn trong yêu cầu ICMP (là máy nạn nhân). Nếu số lượng máy trong mạng rất lớn thì máy nạn nhân sẽ bị ngập lụt đường truyền, hoặc ngừng hoạt động.

* _Phòng chống_


Có thể sử dụng các biện pháp sau để phòng chống tấn công Smurf:

  * Cấu hình các máy trong mạng và router không trả lời các yêu cầu ICMP, hoặc các yêu cầu phát quảng bá;

  * Cấu hình các router không chuyển tiếp yêu cầu ICMP gửi đến các địa chỉ quảng bá;

  * Sử dụng tường lửa để lọc các gói tin với địa chỉ giả mạo địa chỉ trong mạng.


Việc cấu hình các router không chuyển tiếp yêu cầu ICMP, hoặc các máy trong mạng không trả lời các yêu cầu ICMP có thể gây khó khăn cho các ứng dụng dựa trên phát quảng bá và giao thức ICMP, như ứng dụng giám sát trạng thái hoạt động của các máy trong mạng dựa trên ICMP/Ping.

## Tấn công từ chối dịch vụ phân tán

### Giới thiệu

Tấn công DDoS (Distributed Denial of Service) là một loại tấn công DoS đặc biệt, liên quan đến việc gây ngập lụt các máy nạn nhân với một lượng rất lớn các yêu cầu kết nối giả mạo. Điểm khác biệt chính giữa DDoS và DoS là phạm vi (scope) tấn công: trong khi số lượng máy tham gia tấn công DoS thường tương đối nhỏ, chỉ gồm một số ít máy tại một, hoặc một số ít địa điểm, thì số lượng máy tham gia tấn công DDoS thường rất lớn, có thể lên đến hàng ngàn, hoặc hàng trăm ngàn máy, và các máy tham gia tấn công DDoS có thể đến từ rất nhiều vị trí địa lý khác nhau trên toàn cầu. Do vậy, việc phòng chống tấn công DDoS gặp nhiều khó khăn hơn so với việc phòng chống tấn công DoS.

Có thể chia tấn công DDoS thành 2 dạng chính theo mô hình kiến trúc: tấn công DDoS trực tiếp (Direct DDoS) và tấn công DDoS gián tiếp, hay phản xạ (Indirect/Reflective DDoS). Trong tấn công DDoS trực tiếp, các yêu cầu tấn công được các máy tấn công gửi trực tiếp đến máy nạn nhân. Ngược lại, trong tấn công DDoS gián tiếp, các yêu cầu tấn công được gửi đến các máy phản xạ (Reflectors) và sau đó gián tiếp chuyển đến máy nạn nhân.

### Tấn công DDoS trực tiếp

Hình 2.23 minh họa kiến trúc điển hình của dạng tấn công DDoS trực tiếp. Tấn công DDoS trực tiếp được thực hiện theo nhiều giai đoạn theo kịch bản như sau:

  * Kẻ tấn công (Attacker) chiếm quyền điều khiển hàng ngàn, thậm chí hàng chục ngàn máy tính trên mạng Internet, sau đó bí mật cài các chương trình tấn công tự động (Automated agents) lên các máy này. Các automated agents còn được gọi là các Bot hoặc Zombie (Máy tính ma);

  * Các máy bị chiếm quyền điều khiển hình thành mạng máy tính ma, gọi là botnet hay zombie network. Các botnet, hay zombie network không bị giới hạn bởi chủng loại thiết bị và tô pô mạng vật lý;

  * Kẻ tấn công có thể giao tiếp với các máy botnet, zombie thông qua một mạng lưới các máy trung gian (handler) gồm nhiều tầng. Phương thức giao tiếp có thể là IRC (Internet Relay Chat), P2P (Peer to Peer), HTTP,…

  * Tiếp theo, kẻ tấn công ra lệnh cho các automated agents đồng loạt tạo các yêu cầu giả mạo gửi đến các máy nạn nhân tạo thành cuộc tấn công DDoS;

  * Lượng yêu cầu giả mạo có thể rất lớn và đến từ rất nhiều nguồn, vị trí địa lý khác nhau nên rất khó đối phó và lần vết để tìm ra kẻ tấn công thực sự.


|<image_4>|

_Hình 2.23. Kiến trúc tấn công DDoS trực tiếp_

|<image_5>|

_Hình 2.24. Kiến trúc tấn công DDoS gián tiếp hay phản xạ_

### Tấn công DDoS gián tiếp

Hình 2.24 minh họa kiến trúc tấn công DDoS gián tiếp, hay phản xạ. Tấn công DDoS gián tiếp cũng được thực hiện theo nhiều giai đoạn theo kịch bản như sau:

  * Kẻ tấn công chiếm quyền điều khiển của một lượng lớn máy tính trên mạng Internet, cài đặt phần mềm tấn công tự động bot/zombie (còn gọi là slave), hình thành nên mạng botnet;

  * Theo lệnh của kẻ tấn công điều khiển các Slave/Zombie gửi một lượng lớn yêu cầu giả mạo với địa chỉ nguồn là địa chỉ máy nạn nhân đến một số lớn các máy khác (Reflectors) trên mạng Internet;

  * Các Reflectors gửi các phản hồi (Reply) đến máy nạn nhân do địa chỉ của máy nạn nhân được đặt vào địa chỉ nguồn của yêu cầu giả mạo;

  * Khi các Reflectors có số lượng lớn, số phản hồi sẽ rất lớn và gây ngập lụt đường truyền mạng hoặc làm cạn kiệt tài nguyên của máy nạn nhân, dẫn đến ngắt quãng hoặc ngừng dịch vụ cung cấp cho người dùng. Các Reflectors bị lợi dụng để tham gia tấn công thường là các hệ thống máy chủ có công suất lớn trên mạng Internet và không chịu sự điều khiển của tin tặc.


### Phòng chống tấn công DDoS

Nhìn chung, để phòng chống tấn công DDoS hiệu quả, cần kết hợp nhiều biện pháp và sự phối hợp của nhiều bên do tấn công DDoS có tính phân tán cao và hệ thống mạng máy tính ma (botnet) được hình thành và điều khiển theo nhiều tầng, lớp. Một số biện pháp có thể xem xét áp dụng:

  * Sử dụng các phần mềm rà quét vi rút và các phần mềm độc hại khác nhằm loại bỏ các loại bot, zombie, slaves khỏi các hệ thống máy tính;

  * Sử dụng các hệ thống lọc đặt trên các router, tường lửa của các nhà cung cấp dịch vụ Internet (ISP) để lọc các yêu cầu điều khiển (C&C – Command and Control) gửi từ kẻ tấn công đến các bot;

  * Sử dụng các hệ thống giám sát, phát hiện bất thường, nhằm phát hiện sớm các dấu hiệu của tấn công DDoS.

  * Sử dụng tường lửa để chặn (block) tạm thời các cổng dịch vụ bị tấn công.


## Tấn công giả mạo địa chỉ

### Giới thiệu

Dạng tấn công giả mạo địa chỉ thường gặp nhất là tấn công giả mạo địa chỉ IP, trong đó kẻ tấn công sử dụng địa chỉ IP giả làm địa chỉ nguồn (Source IP) của các gói tin IP, thường để đánh lừa máy nạn nhân nhằm vượt qua các hàng rào kiểm soát an ninh thông thường. Chẳng hạn, nếu kẻ tấn công giả địa chỉ IP là địa chỉ cục bộ của mạng LAN, hắn có thể có nhiều cơ hội xâm nhập vào các máy khác trong mạng LAN đó do chính sách kiểm soát an ninh với các máy trong cùng mạng LAN thường được giảm nhẹ.

### Kịch bản

Hình 2.25 minh họa một cuộc tấn công giả mạo địa chỉ IP vào một máy nạn nhân trong mạng cục bộ. Các bước thực hiện như sau:

  * Giả sử máy của kẻ tấn công có địa chỉ IP là 192.168.0.25 và hắn muốn gửi gói tin tấn công đến máy nạn nhân có địa chỉ IP là 100.0.0.75;

  * Kẻ tấn công tạo và gửi yêu cầu giả mạo với địa chỉ IP nguồn của các gói tin IP của yêu cầu là 100.0.0.80 đến máy nạn nhân. Địa chỉ 100.0.0.80 là địa chỉ cùng mạng LAN với máy nạn nhân 100.0.0.75;

  * Nếu tường lửa của mạng LAN không lọc được các gói tin với địa chỉ nguồn giả mạo, yêu cầu giả mạo của kẻ tấn công có thể đến được và gây tác hại cho máy nạn nhân.


|<image_6>|

_Hình 2.25. Minh họa tấn công giả mạo địa chỉ IP_

### Phòng chống

Biện pháp phòng chống tấn công giả mạo địa chỉ IP hiệu quả nhất là sử dụng kỹ thuật lọc trên tường lửa, hoặc các router với nguyên tắc lọc: các gói tin từ mạng ngoài đi vào mạng LAN mà có địa chỉ nguồn là địa chỉ nội bộ của mạng LAN đó thì chúng là các gói tin giả mạo và phải bị chặn.

## Tấn công nghe lén

Tấn công nghe lén (Sniffing/Eavesdropping), như minh họa trên Hình 2.26 là dạng tấn công sử dụng thiết bị phần cứng hoặc phần mềm, lắng nghe trên card mạng, hub, switch, router, hoặc môi trường truyền dẫn để bắt các gói tin dùng cho phân tích, hoặc lạm dụng về sau. Đây là kiểu tấn công thụ động nhằm thu thập các thông tin nhạy cảm, hoặc giám sát lưu lượng mạng. Các thông tin nhạy cảm như tên người dùng, mật khẩu, thông tin thanh toán nếu không được mã hóa có thể bị nghe lén và lạm dụng. Các thông tin truyền trong mạng WiFi, hoặc các mạng không dây cũng có thể bị nghe lén dễ dàng do môi trường truyền dẫn vô tuyến và nếu không sử dụng các cơ chế bảo mật đủ mạnh.

Để phòng chống tấn công nghe lén, có thể áp dụng các biện pháp sau:

  * Có cơ chế bảo vệ các thiết bị mạng và hệ thống truyền dẫn ở mức vật lý;

  * Sử dụng các biện pháp, cơ chế xác thực người dùng đủ mạnh;

  * Sử dụng các biện pháp bảo mật thông tin truyền dựa trên các kỹ thuật mã hóa.


|<image_7>|

_Hình 2.26. Tấn công nghe lén_

# Public_156

# Giới thiệu

Các phần mềm độc hại (Malware hay Malicious software) là các chương trình, phần mềm được viết ra nhằm các mục đích xấu, như đánh cắp thông tin nhạy cảm, hoặc phá hoại các hệ thống. Có nhiều phương pháp phân loại các phần mềm độc hại, trong đó một phương pháp được thừa nhận rộng rãi là chia các phần mềm độc hại thành 2 nhóm chính như biểu diễn trên Hình 2.33:

  * Các phần mềm độc hại cần chương trình chủ, vật chủ (host) để ký sinh và lây nhiễm. Các phần mềm độc hại thuộc nhóm này gồm Logic bomb (Bom logic), Back door (Cửa hậu), Trojan horse (Con ngựa thành Tơ roa), Virus (Vi rút), Rootkit, Adware (Phần mềm quảng cáo) và Spyware (Phần mềm gián điệp).

  * Các phần mềm độc hại không cần chương trình chủ, vật chủ để lây nhiễm. Các phần mềm độc hại thuộc nhóm này gồm Worm (Sâu) và Zombie hay Bot (Phần mềm máy tính ma).


Trong số các phần mềm độc hại, các phần mềm độc hại có khả năng tự lây nhiễm (self-infection), hay tự nhân bản (self-replicate) gồm Vi rút, Sâu và Phần mềm máy tính ma. Các dạng còn lại không có khả năng tự lây nhiễm. Việc phân loại các phần mềm độc hại kể trên mang tính chất tương đối do hiện nay, có một số phần mềm độc hại có các đặc tính của cả Vi rút, Sâu và Phần mềm gián điệp.

|<image_1>|
_Hình 2.33. Các dạng phần mềm độc hại_

# Các dạng phần mềm độc hại

## Logic bomb

Logic bomb (Bom lô gíc) là các đoạn mã độc thường được “nhúng” vào các chương trình bình thường và thường hẹn giờ để “phát nổ” trong một số điều kiện cụ thể. Điều kiện để bom “phát nổ” có thể là sự xuất hiện hoặc biến mất của các file cụ thể, một thời điểm cụ thể, hoặc một ngày trong tuần. Khi “phát nổ” bom logic có thể xoá dữ liệu, file, tắt cả hệ thống...

Thực tế đã ghi nhận quả bom logic do Tim Lloyd cài lại đã “phát nổ” tại công ty Omega Engineering vào ngày 30/7/1996, 20 ngày sau khi Tim Lloyd bị sa thải. Bom lô gíc này đã xoá sạch các bản thiết kế và các chương trình, gây thiệt hại 10 triệu USD cho công ty. Bản thân Tim Lloyd bị phạt 2 triệu USD và 41 tháng tù.

## Trojan Horse

Trojan horse lấy tên theo tích “Con ngựa thành Tơ roa”, là chương trình chứa mã độc, thường giả danh những chương trình có ích, nhằm lừa người dùng kích hoạt chúng. Trojan horse thường được sử dụng để thực thi gián tiếp các tác vụ, mà tác giả của chúng không thể thực hiện trực tiếp do không có quyền truy nhập. Chẳng hạn, trong một hệ thống nhiều người dùng, một người dùng (kẻ tấn công) có thể tạo ra một trojan đội lốt một chương trình hữu ích đặt ở thư mục chung. Khi trojan này được thực thi bởi một người dùng khác, nó sẽ thay đổi quyền truy nhập các file và thư mục của người dùng đó, cho phép tất cả người dùng (trong đó có kẻ tấn công) truy nhập vào các file của người dùng đó.

## Back door

Back door (Cửa hậu) thường được các lập trình viên tạo ra, dùng để gỡ rối và kiểm thử chương trình trong quá trình phát triển. Cửa hậu thường cho phép truy nhập trực tiếp vào hệ thống mà không qua các thủ tục kiểm tra an ninh thông thường. Khi cửa hậu được lập trình viên tạo ra để truy nhập bất hợp pháp vào hệ thống, nó trở thành một mối đe dọa đến an ninh hệ thống. Cửa hậu thường được thiết kế và cài đặt khéo léo và chỉ được kích hoạt trong một ngữ cảnh nào đó, do vậy nó rất khó bị phát hiện.

## Virus

### Giới thiệu

|<image_2>|

_Hình 2.34. Minh họa vi rút máy tính_

Vi rút (Virus) là một chương trình có thể “nhiễm” vào các chương trình khác, bằng cách sửa đổi các chương trình này. Nếu các chương trình đã bị sửa đổi chứa vi rút được kích hoạt thì vi rút sẽ tiếp tục “lây nhiễm” sang các chương trình khác. Tương tự như vi rút sinh học, vi rút máy tính cũng có khả năng tự nhân bản, tự lây nhiễm sang các chương trình khác mà nó tiếp xúc. Có nhiều con đường lây nhiễm vi rút, như sao chép file, gọi các ứng dụng và dịch vụ qua mạng, email...

Vi rút có thể thực hiện được mọi việc mà một chương trình thông thường có thể thực hiện. Khi đã lây nhiễm vào một chương trình, vi rút tự động được thực hiện khi chương trình này chạy. Hình 2.35 minh họa việc chèn mã vi rút vào cuối một chương trình và chỉnh sửa chương trình để khi chương trình được kích hoạt, mã vi rút luôn được thực hiện trước, sau đó mới thực hiện mã chương trình.

|<image_3>|

_Hình 2.35. Chèn và gọi thực hiện mã vi rút_

### Các loại vi rút

Các loại vi rút thường gặp bao gồm file vi rút, boot vi rút, macro vi rút và email vi rút. Boot vi rút là dạng vi rút lây nhiễm vào cung khởi động (boot sector) của đĩa hoặc phần hệ thống của đĩa như cung khởi động chủ của đĩa cứng (master boot record). Do boot vi rút lây nhiễm vào cung khởi động nên nó luôn được nạp vào bộ nhớ mỗi khi hệ thống máy khởi động. Boot vi rút có thể gây hỏng phần khởi động của đĩa, thậm chí có thể làm cho đĩa không thể truy nhập được.

File vi rút là dạng vi rút phổ biến nhất, đối tượng lây nhiễm của chúng là các file chương trình và các file dữ liệu. Mỗi khi chương trình được kích hoạt hoặc file dữ liệu được nạp vào bộ nhớ, vi rút được kích hoạt. Mọi chương trình tiếp theo được kích hoạt đều bị lây nhiễm vi rút này. File vi rút có thể làm hỏng chương trình, hỏng hoặc phá hủy các file dữ liệu, đánh cắp các dữ liệu nhạy cảm,…

Macro vi rút là một loại file vi rút đặc biệt do chúng chỉ lây nhiễm vào các tài liệu của bộ phần mềm Microsoft Office. Macro vi rút hoạt động được nhờ tính năng cho phép tạo và thực hiện các đoạn mã macro trong các tài liệu của bộ ứng dụng Microsoft Office, gồm ứng dụng soạn thảo Word, bảng tính Excel, trình email Outlook,…. Các đoạn mã macro thường được dùng để tự động hóa 1 số việc và được viết bằng ngôn ngữ Visual Basic for Applications (VBA). Macro vi rút thường lây nhiễm vào các file định dạng chuẩn (các template như normal.dot và normal.dotx) và từ đó lây nhiễm vào tất cả các file tài liệu được mở. Macro vi rút cũng có thể được tự động kích hoạt nhờ các auto- executed macros, như AutoExecute, Automacro và Command macro. Theo thống kê, macro vi rút chiếm khoảng 2/3 tổng lượng vi rút đã được phát hiện. Lượng tài liệu bị lây nhiễm macro vi rút đã giảm đáng kể từ khi Microsoft Office 2010 có thiết lập ngầm định không cho phép tự động chạy các macro.

Email vi rút lây nhiễm bằng cách tự động gửi một bản copy của nó như 1 file đính kèm đến tất cả các địa chỉ email trong sổ địa chỉ của người dùng trên máy bị lây nhiễm. Nếu người dùng mở email hoặc file đính kèm, vi rút được kích hoạt. Email vi rút có thể lây nhiễm rất nhanh chóng, lan tràn trên khắp thế giới trong một thời gian ngắn.

## Worm

Worm (Sâu) là một loại phần mềm độc hại có khả năng tự lây nhiễm từ máy này sang máy khác mà không cần chương trình chủ, vật chủ, hoặc sự trợ giúp của người dùng. Khi sâu lây nhiễm vào một máy, nó sử dụng máy này làm “bàn đạp” để tiếp tục rà quét, tấn công các máy khác. Một trong các dạng sâu phổ biến là _sâu mạng_ (network worm) sử dụng kết nối mạng để lây lan từ máy này sang máy khác. Mặc dù sử dụng phương thức lây lan khác vi rút, khi sâu hoạt động, nó tương tự vi rút.

Sâu có thể lây lan sử dụng nhiều phương pháp khác nhau. Một số sâu chỉ sử dụng một phương pháp lây lan, nhưng một số sâu khác có khả năng lây lan theo nhiều phương pháp. Các phương pháp lây lan chính của sâu gồm:

  * Lây lan qua thư điện tử: Sâu sử dụng email để gửi bản sao của mình đến các máy khác.

  * Lây lan thông qua khả năng thực thi từ xa: Sâu gửi và thực thi một bản sao của nó trên một máy khác thông qua việc khai thác các lỗ hổng an ninh của hệ điều hành, các dịch vụ, hoặc phần mềm ứng dụng.

  * Lây lan thông qua khả năng log-in (đăng nhập) từ xa: Sâu đăng nhập vào hệ thống ở xa như một người dùng và sử dụng lệnh để sao chép bản thân nó từ máy này sang máy khác.


|<image_4>|

_Hình 2.36. Minh họa sâu máy tính_

Sâu Code Red được phát hiện vào tháng 7/2001 lây nhiễm thông qua việc khai thác lỗi tràn bộ đệm khi xử lý các file .ida trong máy chủ web Microsoft IIS (Internet Information Service). Code Red quét các địa chỉ IP ngẫu nhiên để tìm các hệ thống có lỗi và lây nhiễm vào 360.000 máy chủ trong vòng 14 giờ. Sau đó, sâu Nimda được phát hiện vào tháng 9/2001 là sâu có khả năng lây lan theo nhiều con đường:

  * Qua email từ máy client sang client.

  * Qua các thư mục chia sẻ trên mạng.

  * Từ máy chủ web sang trình duyệt.

  * Từ máy khách đến máy chủ nhờ khai thác các lỗi máy chủ.


Chỉ 22 phút sau khi ra đời, Nimda trở thành sâu có tốc độ lan truyền nhanh nhất trên Internet vào thời điểm đó.

## Zombie

Zombie (còn gọi là _Bot_ hoặc _Automated agent_ ) là một chương trình được thiết kế để giành quyền kiểm soát một máy tính có kết nối Internet, và sử dụng máy tính bị kiểm soát để tấn công các hệ thống khác, hoặc gửi spam email. Tương tự như sâu, zombie có khả năng tự lây nhiễm sang các hệ thống khác mà không cần chương trình chủ, hoặc các hỗ trợ từ người dùng. Một tập hợp các máy tính zombie/bot dưới sự kiểm soát của một, hoặc một nhóm tin tặc được gọi là mạng máy tính ma, hay zombie network/botnet. Các zombie thường được điều phối và sử dụng để thực hiện các cuộc tấn công DDoS các máy chủ, các website của các công ty, hoặc các tổ chức chính phủ. Các máy tính zombie cũng có

thể được sử dụng để gửi thư rác tạo ra khoản tiền không nhỏ cho các nhóm tin tặc, như minh họa trên Hình 2.37.

|<image_5>|

_Hình 2.37. Mô hình tin tặc sử dụng các máy tính Zombie để gửi thư rác_

## Rootkit

Rootkit là một dạng phần mềm độc hại gồm một tập các công cụ có mục đích giành quyền truy nhập vào hệ thống máy tính mà người dùng không có thẩm quyền không thể truy nhập. Rootkit thường che giấu mình bằng cách đội lột một phần mềm khác. Rootkit có thể được cài đặt tự động, hoặc tin tặc cài đặt rootkit khi chiếm được quyền quản trị hệ thống. Do rootkit có quyền truy nhập hệ thống ở mức quản trị nên nó có toàn quyền truy nhập vào các thành phần trong hệ thống và rất khó bị phát hiện.

## Adware và Spyware

Adware (tên đầy đủ là advertising-supported software) là các phần mềm tự động hiển thị các bảng quảng cáo trong thời gian người dùng tải hoặc sử dụng các phần mềm. Adware thường được đóng gói chung với các phần mềm khác có thể dưới dạng như một phần của một phần mềm hoặc một dịch vụ miễn phí. Adware trong một số trường hợp có thể được coi là một phần mềm độc hại nếu chúng được tự động cài đặt và kích hoạt mà không được sự đồng ý của người dùng.

Spyware là một dạng phần mềm độc hại được cài đặt tự động nhằm giám sát, thu thập và đánh cắp các thông tin nhạy cảm trên hệ thống nạn nhân. Có 4 loại spyware thường gặp, gồm system monitor (giám sát hệ thống), trojan, adware, and tracking cookies (các cookie theo dõi). Spyware có thể được cài đặt vào hệ thống nạn nhân thông qua nhiều phương pháp, như tích hợp, đóng gói vào các phần mềm khác, bẫy nạn nhân tự tải và cài đặt, hoặc tin tặc có thể sử dụng vi rút, sâu để tải và cài đặt. Spyware thường được trang bị khả năng ẩn mình nên rất khó có thể phát hiện bằng các phương pháp thông thường.

# Public_157

_Chương 3 giới thiệu các khái niệm cơ bản về mật mã, hệ mã hóa, các phương pháp mã hóa. Phần tiếp theo của chương trình bày một số giải thuật cơ bản của mã hóa khóa đối xứng (DES, 3-DES và AES), mã hóa khóa bất đối xứng (RSA), các hàm băm (MD5 và SHA1), chữ ký số, chứng chỉ số và PKI. Phần cuối của chương đề cập vấn đề quản lý và phân phối khóa, và một số giao thức đảm bảo an toàn thông tin dựa trên mã hóa._

# Khái quát về mã hóa thông tin và ứng dụng

## Các khái niệm

_Mật mã_

Theo từ điển Webster's Revised Unabridged Dictionary: “cryptography is the act or art of writing secret characters”, hay _mật mã (cryptography) là một hành động hoặc nghệ thuật viết các ký tự bí mật_. Còn theo từ điển Free Online Dictionary of Computing: “cryptography is encoding data so that it can only be decoded by specific individuals”, có nghĩa là _mật mã là việc mã hóa dữ liệu mà nó chỉ có thể được giải mã bởi một số người chỉ định_.

_Bản rõ, Bản mã, Mã hóa và Giải mã_

Bản rõ (Plaintext), hay thông tin chưa mã hóa (Unencrypted information) là thông tin ở dạng có thể hiểu được.

Bản mã (Ciphertext), hay thông tin đã được mã hóa (Encrypted information) là thông tin ở dạng đã bị xáo trộn.

Mã hóa (Encryption) là hành động xáo trộn (scrambling) bản rõ để chuyển thành bản mã.

Giải mã (Decryption) là hành động giải xáo trộn (unscrambling) bản mã để chuyển thành bản rõ.

|<image_1>|

_Hình 3.1. Các khâu Mã hóa (Encryption) và Giải mã (Decryption) của một hệ mã hóa_

Hình 3.1 minh họa các khâu của một hệ mã hóa, trong đó khâu mã hóa thực hiện ở phía người gửi: chuyển bản rõ thành bản mã và khâu giải mã được thực hiện ở phía người nhận: chuyển bản mã thành bản rõ.

_Giải thuật mã hóa & giải mã, Bộ mã hóa, Khóa/Chìa, Không gian khóa_

Giải thuật mã hóa (Encryption algorithm) là giải thuật dùng để mã hóa thông tin và giải thuật giải mã (Decryption algorithm) dùng để giải mã thông tin.

Một bộ mã hóa (Cipher) gồm một giải thuật để mã hóa và một giải thuật để giải mã thông tin.

Khóa/Chìa (Key) là một chuỗi được sử dụng trong giải thuật mã hóa và giải mã.

Không gian khóa (Keyspace) là tổng số khóa có thể có của một hệ mã hóa. Ví dụ, nếu sử dụng khóa kích thước 64 bit thì không gian khóa là 264.

_Mã hóa khóa đối xứng, Mã hóa khóa bất đối xứng, Hàm băm, Thám mã_

Mã hóa khóa đối xứng (Symmetric key cryptography) là dạng mã hóa trong đó một khóa được sử dụng cho cả khâu mã hóa và khâu giải mã. Do khóa sử dụng chung cần phải được giữ bí mật nên mã hóa khóa đối xứng còn được gọi là mã hóa khóa bí mật (Secret key cryptography). Hình 3.2 minh họa hoạt động của một hệ mã hóa khóa đối xứng, trong đó một khóa bí mật duy nhất được sử dụng cho cả hai khâu mã hóa và giải mã một thông điệp.

|<image_2>|

_Hình 3.2. Mã hóa khóa đối xứng sử dụng chung 1 khóa bí mật_

|<image_3>|

_Hình 3.3. Mã hóa khóa bất đối xứng sử dụng một cặp khóa_

Mã hóa khóa bất đối xứng (Asymmetric key cryptography) là dạng mã hóa trong đó một cặp khóa được sử dụng: khóa công khai (public key) dùng để mã hóa, khóa riêng (private key) dùng để giải mã. Chỉ có khóa riêng cần phải giữ bí mật, còn khóa công khai có thể phổ biến rộng rãi. Do khóa để mã hóa có thể công khai nên đôi khi mã hóa khóa bất đối xứng còn được gọi là mã hóa khóa công khai (Public key cryptography). Hình 3.3 minh họa hoạt động của một hệ mã hóa khóa bất đối xứng, trong đó một khóa công khai (public key) được sử dụng cho khâu mã hóa và khóa riêng (private key) cho khâu giải mã thông điệp.

Hàm băm (Hash function) là một ánh xạ chuyển các dữ liệu có kích thước thay đổi về dữ liệu có kích thước cố định. Hình 3.4 minh họa đầu vào (Input) và đầu ra (Digest) của hàm băm. Trong các loại hàm băm, hàm băm 1 chiều (One-way hash function) là hàm băm, trong đó việc thực hiện mã hóa tương đối đơn giản, còn việc giải mã thường có độ phức tạp rất lớn, hoặc không khả thi về mặt tính toán.

|<image_4>|

_Hình 3.4. Minh họa đầu vào (Input) và đầu ra (Digest) của hàm băm_

Thám mã hay phá mã (Cryptanalysis) là quá trình giải mã thông điệp đã bị mã hóa mà không cần có trước thông tin về giải thuật mã hóa và khóa mã.

## Các thành phần của một hệ mã hóa

Một hệ mã hóa hay hệ mật mã (Cryptosystem) là một bản cài đặt của các kỹ thuật mật mã và các thành phần có liên quan để cung cấp dịch vụ bảo mật thông tin. Hình 3.5 nêu các thành phần của một hệ mã hóa đơn giản dùng để đảm bảo tính bí mật của thông tin từ người gửi (Sender) truyền đến người nhận (Receiver) mà không bị một bên thứ ba nghe lén (Interceptor). Các thành phần của một hệ mã hóa đơn giản gồm bản rõ (plaintext), giải thuật mã hóa (Encryption Algorithm), bản mã (ciphertext), giải thuật giải mã (Decryption Algorithm), khóa mã hóa (encryption key) và khóa giải mã (decryption key). Một thành phần quan trọng khác của một hệ mã hóa là không gian khóa (Keyspace) - là tập hợp tất cả các khóa có thể có. Ví dụ, nếu chọn kích thước khóa là 64 bit thì không

gian khóa sẽ là 264. Nhìn chung, hệ mã hóa có độ an toàn càng cao nếu không gian khóa lựa chọn càng lớn.

|<image_5>|

_Hình 3.5. Các thành phần của một hệ mã hóa đơn giản_

## Lịch sử mã hóa

Có thể nói mã hóa hay mật mã là con đẻ của toán học nên sự phát triển của mật mã đi liền với sự phát triển của toán học. Tuy nhiên, do nhiều giải thuật mật mã đòi hỏi khối lượng tính toán lớn nên mật mã chỉ thực sự phát triển mạnh cùng với sự ra đời và phát triển của máy tính điện tử. Sau đây là một số mốc trong sự phát triển của mật mã và ứng dụng mật mã:

  * Các kỹ thuật mã hoá thô sơ đã được người cổ Ai cập sử dụng cách đây 4000 năm.

  * Người cổ Hy lạp, Ấn độ cũng đã sử dụng mã hoá cách đây hàng ngàn năm.

  * Các kỹ thuật mã hoá chỉ thực sự phát triển mạnh từ thế kỷ 1800 nhờ công cụ toán học, và phát triển vượt bậc trong thế kỷ 20 nhờ sự phát triển của máy tính và ngành công nghệ thông tin.

  * Trong chiến tranh thế giới thứ I và II, các kỹ thuật mã hóa được sử dụng rộng rãi trong liên lạc quân sự sử dụng sóng vô tuyến. Quân đội các nước đã sử dụng các công cụ phá mã, thám mã để giải mã các thông điệp của quân địch.

  * Năm 1976 chuẩn mã hóa DES (Data Encryption Standard) được Cơ quan mật vụ Mỹ (NSA – National Security Agency) thừa nhận và sử dụng rộng rãi.

  * Năm 1976, hai nhà khoa học Whitman Diffie và Martin Hellman đã đưa ra khái niệm mã hóa khóa bất đối xứng (Asymmetric key cryptography), hay mã hóa khóa công khai (Public key cryptography) đưa đến những thay đổi lớn trong kỹ thuật mật mã. Theo đó, các hệ mã hóa khóa công khai bắt đầu được sử dụng rộng rãi nhờ khả năng hỗ trợ trao đổi khóa dễ dàng hơn và do các hệ mã hóa khóa bí mật gặp khó khăn trong quản lý và trao đổi khóa, đặc biệt khi số lượng người dùng lớn.

  * Năm 1977, ba nhà khoa học Ronald Rivest, Adi Shamir, và Leonard Adleman giới thiệu giải thuật mã hóa khóa công khai RSA. Từ đó, RSA trở thành giải thuật mã


hóa khóa công khai được sử dụng rộng rãi nhất do RSA có thể vừa được sử dụng để mã hóa thông tin và sử dụng trong chữ ký số.

  * Năm 1991, phiên bản đầu tiên của PGP (Pretty Good Privacy) ra đời.

  * Năm 2000, chuẩn mã hóa AES (Advanced Encryption Standard) được thừa nhận và ứng dụng rộng rãi.


## Mã hóa dòng và mã hóa khối

### Mã hóa dòng

|<image_6>|

_Hình 3.6. Mã hóa dòng (Stream cipher)_

Mã hóa dòng (Stream cipher) là kiểu mã hóa mà từng bit, hoặc ký tự của bản rõ được kết hợp với từng bit, hoặc ký tự tương ứng của khóa để tạo thành bản mã. Hình 3.6 biểu diễn quá trình mã hóa (Encrypt) và giải mã (Decrypt) trong mã hóa dòng. Theo đó, ở bên gửi các bit _P i_ của bản rõ (plaintext) được liên tục đưa vào kết hợp với bit tương ứng _K i_ của khóa để tạo thành bit mã _C i_; Ở bên nhận, bit mã _C i_ được kết hợp với bit khóa _C i_ để khôi phục bit rõ _P i_. Một bộ sinh dòng khóa (Keystream Generator) được sử dụng để liên tục sinh các bit khóa _K i_ từ khóa gốc _K_. Các giải thuật mã hóa dòng tiêu biểu như A5, hoặc RC4 được sử dụng rộng rãi trong viễn thông.

### Mã hóa khối

|<image_7>|

_Hình 3.7. Mã hóa khối (Block cipher)_

Mã hóa khối (Block cipher) là kiểu mã hóa mà dữ liệu được chia ra thành từng khối có kích thước cố định để mã hóa và giải mã. Hình 3.7 biểu diễn quá trình mã hóa và giải mã trong mã hóa khối. Theo đó, ở bên gửi bản rõ (Plaintext) được chia thành các khối

(block) có kích thước cố định, sau đó từng khối được mã hóa để chuyển thành khối mã. Các khối mã được ghép lại thành bản mã (Ciphertext). Ở bên nhận, bản mã lại được chia thành các khối và từng lại được giải mã để chuyển thành khối rõ. Cuối cùng ghép các khối rõ để có bản rõ hoàn chỉnh. Các giải thuật mã hóa khối tiêu biểu như DES, 3-DES, IDEA, AES được sử dụng rất rộng rãi trong mã hóa dữ liệu với kích thước khối 64, hoặc 128 bit.

## Ứng dụng của mã hóa

Mã hoá thông tin có thể được sử dụng để đảm bảo an toàn thông tin với các thuộc tính: bí mật (confidentiality), toàn vẹn (integrity), xác thực (authentication), không thể chối bỏ (non-repudiation). Cụ thể, các kỹ thuật mã hóa được ứng dụng rộng rãi trong các hệ thống, công cụ và dịch vụ bảo mật như:

  * Dịch vụ xác thực (Kerberos, SSO, RADIUS,…)

  * Điều khiển truy nhập

  * Các công cụ cho đảm bảo an toàn cho truyền thông không dây

  * Các nền tảng bảo mật như PKI, PGP

  * Các giao thức bảo mật như SSL/TLS, SSH, SET, IPSec

  * Các hệ thống bảo mật kênh truyền, như VPN.


# Các phương pháp mã hóa

## Phương pháp thay thế

Phương pháp thay thế (Substitution) là phương pháp thay thế một giá trị này bằng một giá trị khác, như thay một ký tự bằng một ký tự khác, hoặc thay một bit bằng một bit khác. Hình 3.8 biểu diễn bộ chữ gốc, bộ chữ mã và ví dụ mã hóa sử dụng hệ mã hóa nổi tiếng thời La Mã là Caesar cipher. Nguyên tắc của Caesar cipher là dịch 3 chữ trong bộ ký tự tiếng Anh sang bên phải (AD, BE, CF,….). Bản rõ “LOVE” được mã hóa thành “ORYH”.

|<image_8>||<image_9>|

_Hình 3.8. Mã hóa bằng hệ mã hóa Caesar cipher_

Để tăng độ an toàn của phương pháp thay thế, người ta có thể sử dụng nhiều bộ chữ mã, như minh họa trên Hình 3.9 với 4 bộ chữ mã (Substitution cipher), với nguyên tắc thay thế: ký tự số 1 ở bản rõ thay thế sử dụng bộ chữ mã số 1, ký tự số 2 sử dụng bộ chữ mã số 2,…, ký tự số 5 sử dụng bộ chữ mã số 1, ký tự số 6 sử dụng bộ chữ mã số 2,… Nếu các bộ chữ mã được sắp đặt ngẫu nhiên thì một ký tự xuất hiện ở các vị trí khác nhau trong bản rõ sẽ được chuyển đổi thành các ký tự khác nhau trong bản mã. Điều này giúp tăng độ an toàn do làm tăng độ khó trong việc phân tích đoán bản rõ từ bản mã.

|<image_10>||<image_11>|

_Hình 3.9. Phương pháp thay thế với 4 bộ chữ mã_

## Phương pháp hoán vị

Phương pháp hoán vị, hoặc đổi chỗ (permutation) thực hiện sắp xếp lại các giá trị trong một khối bản rõ để tạo bản mã. Thao tác hoán vị có thể thực hiện với từng bit hoặc từng byte (ký tự). Hình 3.10 minh họa ví dụ mã hóa bằng phương pháp hoán vị thực hiện đổi chỗ các bit, trong đó việc đổi chỗ được thực hiện theo khóa (Key) trong khối 8 bit, tính từ bên phải. Hình 3.11 minh họa ví dụ mã hóa bằng phương pháp hoán vị thực hiện đổi chỗ các ký tự, trong đó việc đổi chỗ được thực hiện theo khóa trong khối 8 ký tự, tính từ bên phải. Với bản rõ “SACKGAULSPARENOONE” ta có 3 khối, 2 khối đầu đủ 8 ký tự, còn khối cuối chỉ có 2 ký tự “NE” nên phải chèn thêm dấu trắng cho đủ khối 8 ký tự.

|<image_12>||<image_13>|

_Hình 3.10. Phương pháp hoán vị thực hiện đổi chỗ các bit_

|<image_14>||<image_15>|

_Hình 3.11. Phương pháp hoán vị thực hiện đổi chỗ các ký tự_

## Phương pháp XOR

Phương pháp mã hóa XOR sử dụng phép toán logic XOR để tạo bản mã, trong đó từng bit của bản rõ được XOR với bit tương ứng của khóa. Để giải mã, ta thực hiện XOR từng bit của bản mã với bit tương ứng của khóa. Hình 3.12 minh họa quá trình mã hóa

bản rõ “CAT” với khóa “VVV”. Theo đó, các ký tự của bản rõ và khóa được chuyển thành mã ASCII và biểu diễn dưới dạng nhị phân. Sau đó, thực hiện phép toán XOR trên các bit tương ứng của bản rõ và khóa để tạo bản mã (Cipher).

|<image_16>| _Hình 3.12. Mã hóa bằng phương pháp XOR_

## Phương pháp Vernam

Phương pháp Vernam sử dụng một tập ký tự để nối vào các ký tự của bản rõ để tạo bản mã. Tập ký tự này được gọi là _one-time pad_ và mỗi ký tự trong tập chỉ dùng 1 lần trong một tiến trình mã hóa. Với bộ chữ tiếng Anh có 26 chữ, mã hóa bằng phương pháp Vernam được thực hiện như sau:

  * Các ký tự của bản rõ và các ký tự của tập nối thêm ( _one-time pad_ ) được chuyển thành số trong khoảng 1-26;

  * Cộng giá trị của ký tự trong bản rõ với giá trị tương ứng trong tập nối thêm;

  * Nếu giá trị cộng lớn hơn 26 thì đem trừ cho 26 (đây chính là phép modulo – chia lấy phần dư).

  * Chuyển giá trị số thành ký tự mã.


|<image_17>||<image_18>|

_Hình 3.13. Mã hóa bằng phương pháp Vernam_

Hình 3.13 minh họa mã hóa bản rõ “SACKGAULSPARENOONE” bằng phương pháp Vernam với tập nối thêm “FPQRNSBIEHTZLACDGJ”.

## Phương pháp sách hoặc khóa chạy

Phương pháp sách, hoặc khóa chạy thực hiện việc mã hóa và giải mã sử dụng các khóa mã chứa trong các cuốn sách. Hiện nay phương pháp này thường được dùng trong các bộ phim trinh thám do tính chất kỳ bí của nó. Ví dụ như, với bản mã “259,19,8; 22,3,8; 375,7,4; 394,17,2” và cuốn sách được dùng chứa khóa là “A Fire Up on the Deep”, ta có thể giải mã như sau:

  * Trang 259, dòng 19, từ thứ 8 là _sack_

  * Trang 22, dòng 3, từ thứ 8 là _island_

  * Trang 375, dòng 7, từ thứ 4 là _sharp_

  * Trang 394, dòng 17, từ thứ 2 là _path_


Bản rõ tương ứng của bản mã “259,19,8;22,3,8;375,7,4;394,17,2” là “sack island sharp path”.

## Phương pháp hàm băm

Các hàm băm (Hash functions) là các giải thuật để tạo các bản tóm tắt (digest) của thông điệp, thường được sử dụng để nhận dạng và đảm bảo tính toàn vẹn của thông điệp. Độ dài của thông điệp đầu vào là bất kỳ, nhưng đầu ra hàm băm thường có độ dài cố định. Chi tiết về các hàm băm được ở mục 3.3.3. Các hàm băm thông dụng gồm:

  * Các hàm băm MD2, MD4, MD5 với độ dài chuỗi đầu ra là 128 bit;

  * Hàm băm MD6 cho chuỗi đầu ra có độ dài trong khoảng 0 đến 512 bit;

  * Các hàm băm SHA0, SHA1 với độ dài chuỗi đầu ra là 160 bit;

  * Các hàm băm SHA2, gồm SHA256, SHA384, SHA512 cho phép một số lựa chọn chuỗi đầu ra tương ứng 256, 384 và 512 bit;

  * Hàm băm SHA3 cho chuỗi đầu ra có độ dài trong khoảng 0 đến 512 bit;

  * Hàm băm CRC32 với chuỗi đầu ra 32 bit sử dụng trong kiểm tra dư thừa mạch vòng.

# Public_158

# Khái quát về mã hóa khóa đối xứng

Mã hóa khóa đối xứng (Symmetric key encryption) hay còn gọi là mã hóa khóa bí mật (Secret key encryption) sử dụng một khóa bí mật (Secret key) duy nhất cho cả quá trình mã hóa và giải mã. Khóa bí mật được sử dụng trong quá trình mã hóa và giải mã còn được gọi là _khóa chia sẻ_ (Shared key) do bên gửi và bên nhận cần chia sẻ khóa bí mật một cách an toàn trước khi có thể thực hiện việc mã hóa và giải mã. Hình 3.14 minh họa quá trình mã hóa và giải mã sử dụng chung một khóa bí mật chia sẻ.

|<image_1>|

_Hình 3.14. Mã hóa khóa đối xứng (Symmetric key encryption)_
Các hệ mã hóa khóa đối xứng thường sử dụng khóa với kích thước tương đối ngắn. Một số kích thước khóa được sử dụng phổ biến là 64, 128, 192 và 256 bit. Do sự phát triển nhanh về tốc độ tính toán của máy tính, nên các khóa có kích thước nhỏ hơn 128 bit được xem là không an toàn và hầu hết các hệ mã hóa khóa đối xứng đảm bảo an toàn hiện tại sử dụng khóa có kích thước từ 128 bit trở lên. Ưu điểm nổi bật của các hệ mã hóa khóa đối xứng là có độ an toàn cao và tốc độ thực thi nhanh. Tuy nhiên, nhược điểm lớn nhất của các hệ mã hóa khóa đối xứng là việc quản lý và phân phối khóa rất khó khăn, đặc biệt là trong các môi trường mở như mạng Internet do các bên tham gia phiên truyền thông cần thực hiện việc trao đổi các khóa bí mật một cách an toàn trước khi có thể sử dụng chúng để mã hóa và giải mã các thông điệp trao đổi.
Một số hệ mã hóa khóa đối xứng tiêu biểu, gồm DES (Data Encryption Standard), 3- DES (Triple-DES), AES (Advanced Encryption Standard), IDEA (International Data Encryption Algorithm), Blowfish, Twofish, RC4 và RC5. Phần tiếp theo của mục này là mô tả các giải thuật mã hóa DES, 3-DES và AES do chúng là các giải thuật đã và đang được sử dụng rộng rãi nhất trên thực tế.

## Giải thuật mã hóa DES và 3-DES

### DES

DES (Data Encryption Standard) được phát triển tại IBM với tên gọi Lucifer vào đầu những năm 1970 và được chấp nhận là chuẩn mã hóa ở Mỹ vào năm 1977. DES được sử dụng rộng rãi trong những năm 1970 và 1980. DES là dạng mã hóa khối với khối dữ liệu vào kích thước 64 bit và khóa 64 bit, trong đó thực sử dụng 56 bit (còn gọi là kích thước hiệu dụng của khóa) và 8 bit dùng cho kiểm tra chẵn lẻ. Một ưu điểm của DES là sử dụng chung một giải thuật cho cả khâu mã hóa và khâu giải mã, như minh họa trên Hình 3.15, trong đó _P_ là khối bản rõ 64 bit, K là khóa với kích thước hiệu dụng 56 bit, _C_ là khối bản mã 64 bit, _DES_ biểu diễn khâu mã hóa và _DES -1_ biểu diễn khâu giải mã. Hiện nay DES được coi là không an toàn do nó có không gian khóa nhỏ, dễ bị vét cạn và tốc độ tính toán của các hệ thống máy tính ngày càng nhanh.

|<image_2>|

_Hình 3.15. Các khâu mã hóa và giải mã của DES_
Với mỗi khối dữ liệu đầu vào 64 bit, DES thực hiện 3 bước xử lý như minh họa trên Hình 3.16 để chuyển nó thành khối mã 64 bit tương ứng. Các bước cụ thể gồm:

  * Bước 1: Hoán vị khởi tạo (IP – Initial Permutation);

  * Bước 2: 16 vòng lặp chính thực hiện xáo trộn dữ liệu sử dụng hàm Feistel (F). Sau mỗi vòng lặp, các kết quả trung gian được kết hợp lại sử dụng phép ⊕ (XOR);

  * Bước 3: Hoán vị kết thúc (FP – Final Permutation).


|<image_3>|
_Hình 3.16. Các bước xử lý chuyển khối rõ 64 bit thành khối mã 64 bit của DES_

|<image_4>|

_Hình 3.17. Các bước xử lý của hàm Feistel (F)_
Hàm Feistel (F) là hạt nhân trong các vòng lặp xử lý dữ liệu của DES. Trước hết, khối 64 bit được chia thành 2 khối 32 bit và được xử lý lần lượt. Hàm Feistel được thực hiện
trên một khối dữ liệu 32 bit (Half Block 32 bits) gồm 4 bước xử lý như minh họa trên Hình 3.17. Cụ thể, các bước xử lý như sau:

  * E (Expansion): thực hiện mở rộng 32 bit khối đầu vào thành 48 bit bằng cách nhân đôi một nửa số bit.

  * ⊕: Trộn khối 48 bit kết quả ở bước E với khóa phụ 48 bit. Có 16 khóa phụ (Subkey) được tạo từ khóa chính để sử dụng cho 16 vòng lặp.

  * Si (Substitution): Khối dữ liệu 48 bit được chia thành 8 khối 6 bit và được chuyển cho các bộ thay thế (S1-S8). Mỗi bộ thay thế Si sử dụng phép chuyển đổi phi tuyến tính để chuyển 6 bit đầu vào thành 4 bit đầu ra theo bảng tham chiếu. Các bộ thay thế là thành phần nhân an ninh (Security core) của DES.

  * P (Permutation): khối 32 bit đầu ra từ các bộ thay thế được sắp xếp bằng phép hoán vị cố định (Fixed permutation) cho ra đầu ra 32 bit.


DES sử dụng một thủ tục sinh 16 khóa phụ từ khóa chính để sử dụng trong 16 vòng lặp hàm Feistel. Hình 3.18 minh họa thủ tục sinh 16 khóa phụ từ khóa chính của DES. Các bước xử lý chính của thủ tục sinh khóa phụ như sau:

  * 56 bit khóa được chọn từ khóa gốc 64 bit bởi PC1 (Permuted Choice 1). 8 bit còn lại được hủy hoặc dùng để kiểm tra chẵn lẻ;

  * 56 bit được chia thành 2 phần 28 bit, mỗi phần được xử lý riêng;

  * Mỗi phần được quay trái 1 hoặc 2 bit;

  * Hai phần được ghép lại và 48 bit được chọn làm khóa phụ 1 (Subkey 1) bởi PC2;

  * Lặp lại bước trên để tạo 15 khóa phụ còn lại.


|<image_5>|

_Hình 3.18. Thủ tục sinh các khóa phụ từ khóa chính của DES_
Như đã đề cập, giải thuật DES có thể sử dụng cho cả khâu mã hóa và giải mã. Trong khâu giải mã các bước xử lý tương tự khâu mã hóa. Tuy nhiên, các khóa phụ sử dụng cho các vòng lặp được sử dụng theo trật tự ngược lại: khóa phụ số 16, 15,…, 2, 1 được sử dụng cho các vòng lặp số 1, 2,…, 15, 16 tương ứng.

### 3-DES

3-DES hay Triple DES có tên đầy đủ là Triple Data Encryption Algorithm (TDEA) được phát triển từ giải thuật DES bằng cách áp dụng DES 3 lần cho mỗi khối dữ liệu đầu vào 64 bit. 3-DES sử dụng một bộ gồm 3 khóa DES: K1, K2, K3, trong đó mỗi khóa kích thước hiệu dụng là 56 bit. 3-DES cho phép lựa chọn các bộ khóa:

  * Lựa chọn 1: cả 3 khóa độc lập, với tổng kích thước bộ khóa là 168 bit;

  * Lựa chọn 2: K1 và K2 độc lập, K3 = K1, với tổng kích thước bộ khóa là 112 bit;

  * Lựa chọn 3: 3 khóa giống nhau, K1 = K2 = K3, với tổng kích thước bộ khóa là 56 bit.


Hình 3.19 biểu diễn quá trình mã hóa và giải mã với giải thuật 3-DES, trong đó khâu mã hóa được ký hiệu là E và khâu giải mã được ký hiệu là D. Theo đó, ở bên gửi bản rõ (Plaintext) được mã hóa bằng khóa K1, giải mã bằng khóa K2 và mã hóa bằng khóa K3 để cho ra bản mã (Ciphertext). Ở bên nhận, quá trình giải mã bắt đầu bằng việc giải mã bằng khóa K3, sau đó mã hóa bằng khóa K2 và cuối cùng giải mã bằng khóa K1 để khôi phục bản rõ. Ưu điểm của 3-DES là nâng cao được độ an toàn nhờ tăng kích thước khóa. Tuy nhiên, nhược điểm chính của 3-DES là tốc độ thực thi chậm do phải thực hiện DES lặp 3 lần cho mỗi khâu mã hóa và giải mã.

|<image_6>|

_Hình 3.19. Mã hóa và giải mã với giải thuật 3-DES_

# Giải thuật mã hóa AES

## Giới thiệu

AES (Advanced Encryption Standard) là một chuẩn mã hóa dữ liệu được Viện Tiêu chuẩn và Công nghệ Mỹ (NIST) công nhận năm 2001. AES được xây dựng dựa trên Rijndael cipher phát triển và công bố năm 1998 bởi 2 nhà mật mã học người Bỉ là Joan Daemen và Vincent Rijmen. AES là dạng mã hóa khối, với khối dữ liệu vào có kích thước là 128 bit và khóa bí mật với kích thước có thể là 128, 192, hoặc 256 bit. AES
được thiết kế dựa trên mạng hoán vị-thay thế (Substitution-permutation network) và nó có thể cho tốc độ thực thi cao khi cài đặt bằng cả phần mềm và phần cứng. Đặc biệt, giải thuật AES đã được tích hợp vào các bộ vi xử lý gần đây của hãng Intel dưới dạng tập lệnh AES-NI, giúp tăng đáng kể tốc độ thực thi các thao tác mã hóa và giải mã dựa trên AES.
AES vận hành dựa trên một ma trận vuông 4x4, được gọi là _state_ (trạng thái). Ma trận này gồm 16 phần tử, mỗi phần tử là 1 byte dữ liệu. State được khởi trị là khối 128 bit bản rõ và qua quá trình biến đổi sẽ chứa khối 128 bit bản mã ở đầu ra. Như đã đề cập, AES hỗ trợ 3 kích thước khóa và kích thước của khóa quyết định số vòng lặp chuyển đổi cần thực hiện để chuyển bản rõ thành bản mã như sau:

  * 10 vòng lặp với khóa 128 bit;

  * 12 vòng lặp với khóa 192 bit;

  * 14 vòng lặp với khóa 256 bit.


## Mô tả khái quát giải thuật

Giải thuật AES cho mã hóa dữ liệu, như minh họa trên Hình 3.20, gồm các bước xử lý chính như sau:

  * Mở rộng khóa (Key Expansion): các khóa vòng (Round key) dùng trong các vòng lặp được sinh ra từ khóa chính AES sử dụng thủ tục sinh khóa Rijndael.


|<image_7>|

_Hình 3.20. Các bước xử lý mã hóa dữ liệu của AES_

  * Vòng khởi tạo (Initial Round): Thực hiện hàm AddRoundKey, trong đó mỗi byte trong _state_ được kết hợp với khóa vòng sử dụng phép XOR.

  * Các vòng lặp chính (Rounds): Có 4 hàm biến đổi dữ liệu được thực hiện trong mỗi vòng, gồm:


\+ SubBytes: hàm thay thế phi tuyến tính, trong đó mỗi byte trong _state_ được thay thế bằng một byte khác sử dụng bảng tham chiếu S-box;
\+ ShiftRows: hàm đổi chỗ, trong đó mỗi dòng trong _state_ được dịch một số bước theo chu kỳ;
\+ MixColumns: trộn các cột trong _state_ , kết hợp 4 bytes trong mỗi cột.
\+ AddRoundKey.

  * Vòng cuối (Final Round): Tương tự các vòng lặp chính, nhưng chỉ thực hiện 3 hàm biến đổi dữ liệu, gồm:


\+ SubBytes;
\+ ShiftRows;
\+ AddRoundKey.

## Mở rộng khóa

|<image_8>|

_Hình 3.21. Thủ tục sinh khóa Rijndael_
Khâu mở rộng khóa AES sử dụng thủ tục sinh khóa Rijndael để sinh các khóa vòng (Round key) cho các vòng lặp xử lý như biểu diễn trên Hình 3.21. Thủ tục Rijndael nhận đầu vào là khóa chính AES (cipher key) và xuất ra một khóa vòng (Subkey/Round key) sau mỗi vòng lặp. Một vòng lặp của thủ tục Rijndael gồm các khâu:

  * Rotword: quay trái 8 bit từng từ 32 bit từ khóa gốc;

  * SubBytes: thực hiện phép thay thế sử dụng bảng tham chiếu S-box.

  * Rcon: tính toán giá trị Rcon(i) = _x_ (i-1) mod _x_ 8 \+ _x_ 4 \+ _x_ 3 \+ _x_ \+ 1

  * ShiftRow: thực hiện đổi chỗ tương tự hàm ShiftRows của AES.


## Các hàm xử lý chính

_Hàm SubBytes_ : Mỗi byte trong ma trận _state_ được thay thế bởi 1 byte trong Rijndael S-box, hay bij = S(aij) như minh họa trên Hình 3.22. S-box là một bảng tham chiếu phi tuyến tính, được tạo ra bằng phép nhân nghịch đảo một số cho trước trong trường GF(28). Nếu như trong khâu mã hóa S-box được sử dụng thì bảng S-box _đảo_ được sử dụng trong khâu giải mã.

|<image_9>|

_Hình 3.22. Hàm SubBytes sử dụng Rijndael S-box_

|<image_10>|

_Hình 3.23. Hàm ShiftRows_

|<image_11>|

_Hình 3.24. Hàm MixColumns_
_Hàm ShiftRows_ : Các dòng của ma trận _state_ được dịch theo chu kỳ sang trái theo nguyên tắc: hàng số 0 giữ nguyên, hàng số 1 dịch 1 byte sang trái, hàng số 2 dịch 2 byte và hàng số 3 dịch 3 byte, như minh họa trên Hình 3.23.
_Hàm MixColumns_ : Mỗi cột của ma trận _state_ được nhân với một đa thức c(x), như minh họa trên Hình 3.24. Đa thức c(x) = 3 _x_ 3 \+ _x_ 2 \+ _x_ +2.
|<image_12>|
_Hình 3.25. Hàm AddRoundKey_
_Hàm AddRoundKey_ : Mỗi byte của ma trận _state_ được kết hợp với một byte tương ứng của khóa vòng sử dụng phép ⊕ (XOR), như minh họa trên Hình 3.25.

## Giải mã

|<image_13>|

_Hình 3.26. Quá trình mã hóa và giải mã trong AES_
Khâu giải mã trong AES cũng gồm các bước xử lý tương tự như khâu mã hóa. Hình
3.26 biểu diễn quá trình mã hóa và giải mã trong AES. Theo đó, ngoài bước Mở rộng khóa, quá trình giải mã gồm Vòng khởi tạo (AddRoundKey), Các vòng lặp chính (Decryption round) và Vòng cuối (Last round) để chuyển khối mã thành khối rõ. Điểm khác biệt chính của khâu giải mã so với khâu mã hóa là các _hàm đảo_ được sử dụng, như
các hàm đảo InvSubBytes, InvShiftRows và InvMixColumns tương ứng thay cho các hàm SubBytes, ShiftRows và MixColumns.

# Public_159

# CÁC GIẢI THUẬT MÃ HÓA KHÓA BẤT ĐỐI XỨNG

## Khái quát về mã hóa khóa bất đối xứng

Mã hóa khóa bất đối xứng, đôi khi được gọi là mã hóa khóa công khai sử dụng một cặp khóa cho quá trình mã hóa và giải mã. Trong cặp khóa, khóa công khai được sử dụng cho mã hóa và khóa riêng được sử dụng cho giải mã. Chỉ khóa riêng cần giữ bí mật, còn khóa công khai có thể phổ biến rộng rãi, nhưng phải đảm bảo tính toàn vẹn và xác thực chủ thể của khóa.

Hình 3.27 minh họa quá trình mã hóa (Encrypt) và giải mã (Decrypt) sử dụng mã hóa khóa bất đối xứng. Theo đó, người gửi (Sender) sử dụng khóa công khai (Public key) của người nhận (Recipient) để mã hóa bản rõ (Plaintext) thành bản mã (Ciphertext) và gửi nó cho người nhận. Người nhận nhận được bản mã sử dụng khóa riêng (Private key) của mình để giải mã khôi phục bản rõ.

Đặc điểm nổi bật của các hệ mã hóa khóa bất đối xứng là kích thước khóa lớn, lên đến hàng ngàn bit. Do vậy, các hệ mã hóa dạng này thường có tốc độ thực thi chậm hơn nhiều lần so với các hệ mã hóa khóa đối xứng với độ an toàn tương đương. Mặc dù vậy, các hệ mã hóa khóa bất đối xứng có khả năng đạt độ an toàn cao và ưu điểm nổi bật nhất là việc quản lý và phân phối khóa đơn giản hơn do khóa công khai có thể phân phối rộng rãi.

|<image_1>|

_Hình 3.27. Mã hóa và giải mã trong hệ mã hóa bất đối xứng_

Các giải thuật mã hóa khóa bất đối xứng điển hình bao gồm: RSA, Rabin, ElGamal, McEliece và Knapsack. Trong mục tiếp theo chúng ta tìm hiểu về giải thuật mã hóa RSA – một trong các giải thuật mã hóa khóa đối xứng được sử dụng rộng rãi nhất trên thực tế.

## Giải thuật mã hóa RSA

### Giới thiệu

Giải thuật mã hóa RSA được 3 nhà khoa học người Mỹ là Ronald Rivest, Adi Shamir và Leonard Adleman phát minh năm 1977, và tên giải thuật RSA lấy theo chữ cái đầu của tên 3 đồng tác giả. Độ an toàn của RSA dựa trên tính khó của việc phân tích số nguyên rất lớn, với độ lớn cỡ hàng trăm chữ số thập phân. Giải thuật RSA sử dụng một cặp khóa, trong đó khóa công khai dùng để mã hóa và khóa riêng dùng để giải mã. Chỉ khóa riêng RSA cần giữ bí mật. Khóa công khai có thể công bố rộng rãi. Hiện nay, các khóa RSA có kích thước nhỏ hơn 1024 bit được coi là không an toàn do tốc độ các hệ thống máy tính tăng nhanh. Để đảm bảo an toàn, khuyến nghị sử dụng khóa 2048 bit trong giai đoạn 2010-2020. Trong tương lai, cần sử dụng khóa RSA có kích thước lớn hơn, chẳng hạn 3072 bit.

### Sinh khóa

RSA cung cấp một thủ tục sinh cặp khóa (khóa công khai và khóa riêng) tương đối đơn giản. Cụ thể, thủ tục sinh khóa gồm các bước như sau:

  * Tạo 2 số nguyên tố _p_ và _q_ ;

  * Tính modulo _n_ = _p_ × _q_


\- Tính Φ( _n_ ) = ( _p_ -1) × ( _q_ -1)

  * Chọn số _e_ sao cho 0 < _e_ < Φ( _n_ ) và gcd( _e_ , Φ( _n_ )) = 1, trong đó hàm gcd() tính ước số chung lớn nhất của 2 số nguyên. Nếu gcd( _e_ , Φ( _n_ )) = 1 thì _e_ và Φ( _n_ ) là 2 số nguyên tố cùng nhau.

  * Chọn số _d_ sao cho _d_ ≡ _e_ -1 mod Φ( _n_ ),


hoặc ( _d_ × _e_ ) mod Φ( _n_ ) = 1

hay _d_ là modulo nghịch đảo của _e_.

  * Ta có ( _n_ , _e_ ) là khóa công khai, ( _n_ , _d_ ) là khóa riêng và _n_ còn được gọi là modulo.


### Mã hóa và giải mã

  * Mã hóa


\+ Thông điệp bản rõ _m_ đã được chuyển thành số, với _m_ < _n_. Nếu thông điệp bản rõ _m_ có kích thước lớn thì được chia thành các khối _m i_, với _m i_ < _n_.

\+ Bản mã _c_ = _m e_ mod _n_

  * Giải mã


\+ Bản mã _c_ , với _c_ < _n_

\+ Bản rõ _m_ = _c d_ mod _n_

### Ví dụ

  * Sinh khóa:


\+ Chọn 2 số nguyên tố _p_ = 3 và _q_ = 11

\+ Tính _n_ = _p_ × q = 3 × 11 = 33

\+ Tính Φ( _n_ ) = ( _p_ -1) × ( _q_ -1) = 2 × 10 = 20

\+ Chọn số _e_ sao cho 0 < _e_ < 20, và _e_ và Φ( _n_ ) là số nguyên tố cùng nhau (Φ( _n_ ) không chia hết cho _e_ ). Chọn _e_ = 7

\+ Tính ( _d_ x e) mod Φ(n)  ( _d_ × 7) mod 20 = 1

_d_ = (20 × _k_ +1)/7  _d_ = 3 ( _k_ =1)

\+ Ta có: khóa công khai là (33, 7) và khóa riêng là (33, 3)

  * Mã hóa:


\+ Với bản rõ _m_ = 6,

\+ _c_ = _m e_ mod _n_ = 67 mod 33 = 279936 mod 33 = 30

\+ Vậy bản mã _c_ = 30

  * Giải mã:


\+ Với bản mã _c_ = 30

\+ _m_ = _c d_ mod _n_ = 303 mod 33 = 27000 mod 33 = 6

\+ Vậy bản rõ _m_ = 6.

### Một số yêu cầu với quá trình sinh khóa

Dưới đây liệt kê các yêu cầu đặt ra với các tham số sinh khóa và khóa để đảm bảo sự an toàn cho cặp khóa RSA. Các yêu cầu cụ thể gồm:

  * Yêu cầu với các tham số sinh khóa _p_ và _q_ :


\+ Các số nguyên tố _p_ và _q_ phải được chọn sao cho việc phân tích _n_ ( _n_ = _p_ × _q_ ) là không khả thi về mặt tính toán. _p_ và _q_ nên có cùng độ lớn (tính bằng bit) và phải là các số đủ lớn. Nếu _n_ có kích thước 2048 bit thì _p_ và _q_ nên có kích thước khoảng 1024 bit.

\+ Hiệu số _p – q_ không nên quá nhỏ, do nếu _p – q_ quá nhỏ, tức _p_ ≈ _q_ và _p_ ≈ √ _𝑛_. Như vậy, có thể chọn các số nguyên tố ở gần √𝑛 và thử. Khi có được _p_ , có thể tính _q_ và tìm ra _d_ là khóa bí mật từ khóa công khai _e_ và Φ( _n_ ) = ( _p_ \- 1)( _q_ \- 1). Nếu _p_ và _q_ được chọn ngẫu nhiên và _p_ – _q_ đủ lớn, khả năng hai số này bị phân tích từ _n_ giảm đi.

  * Vấn đề sử dụng số mũ mã hóa ( _e_ ) nhỏ: Khi sử dụng số mũ mã hóa ( _e_ ) nhỏ, chẳng hạn


_e_ = 3 có thể tăng tốc độ mã hóa. Kẻ tấn công có thể nghe lén và lấy được bản mã, từ đó phân tích bản mã để khôi phục bản rõ. Do số mũ mã hóa nhỏ nên chi phí cho phân tích, hoặc vét cạn không quá lớn. Do vậy, nên sử dụng số mũ mã hóa _e_ đủ lớn và thêm chuỗi ngẫu nhiên vào khối rõ trước khi mã hóa để giảm khả năng bị vét cạn hoặc phân tích bản mã.

  * Vấn đề sử dụng số mũ giải mã ( _d_ ) nhỏ: Khi sử dụng số mũ giải mã ( _d_ ) nhỏ, có thể tăng tốc độ giải mã. Nếu _d_ nhỏ và gcd( _p_ -1, _q_ -1) cũng nhỏ thì _d_ có thể tính được tương đối dễ dàng từ khóa công khai ( _n_ , _e_ ). Do vậy, để đảm bảo an toàn, nên sử dụng số mũ giải mã _d_ đủ lớn.


# Các hàm băm

## Khái quát về hàm băm

### Giới thiệu

Hàm băm (hash function) là một hàm toán học _h_ có tối thiểu 2 thuộc tính:

  * Nén (Compression): _h_ là một ánh xạ từ chuỗi đầu vào _x_ có chiều dài bất kỳ sang một chuỗi đầu ra _h_ ( _x_ ) có chiều dài cố định _n_ bit;

  * Dễ tính toán (Ease of computation): cho trước hàm _h_ và đầu vào _x_ , việc tính toán


_h_ ( _x_ ) là dễ dàng.

|<image_2>|

_Hình 3.28. Mô hình nén thông tin của hàm băm_

Hình 3.28 minh họa mô hình nén thông tin của hàm băm, theo đó thông điệp (Message) đầu vào với chiều dài tùy ý đi qua nhiều vòng xử lý của hàm băm để tạo chuỗi rút gọn, hay chuỗi đại diện (Digest) có kích thước cố định ở đầu ra.

### Phân loại

Có thể phân loại các hàm băm theo khóa sử dụng hoặc theo chức năng. Theo khóa sử dụng, các hàm băm gồm 2 loại: hàm băm không khóa (unkeyed) và hàm băm có khóa (keyed), như biểu diễn trên Hình 3.29. Trong khi hàm băm không khóa nhận đầu vào chỉ là thông điệp (dạng _h_ ( _x_ ), với hàm băm _h_ và thông điệp _x_ ), hàm băm có khóa nhận đầu vào gồm thông điệp và khóa bí mật (theo dạng _h_ ( _x_ , _K_ ), với hàm băm _h_ và thông điệp _x_ và _K_ là khóa bí mật). Trong các hàm băm không khóa, các mã phát hiện sửa đổi (MDC – Modification Detection Code) được sử dụng rộng rãi nhất, bên cạnh một số hàm băm không khóa khác. Tương tự, trong các hàm băm có khóa, các mã xác thực thông điệp (MAC - Message Authentication Code) được sử dụng rộng rãi nhất, bên cạnh một số hàm băm có khóa khác.

|<image_3>|

_Hình 3.29. Phân loại các hàm băm theo khóa sử dụng_

Theo chức năng, có thể chia các hàm băm thành 2 loại chính:

  * Mã phát hiện sửa đổi (MDC - Modification Detection Code): MDC thường được sử dụng để tạo chuỗi đại diện cho thông điệp và dùng kết hợp với các kỹ thuật khác (như chữ ký số) để đảm bảo tính toàn vẹn của thông điệp. MDC thuộc loại hàm băm không khóa. MDC gồm 2 loại nhỏ:


\+ Hàm băm một chiều (OWHF - One-way hash functions): Với hàm băm một chiều, việc tính giá trị băm là dễ dàng, nhưng việc khôi phục thông điệp từ giá trị băm là rất khó khăn;

\+ Hàm băm chống đụng độ (CRHF - Collision resistant hash functions): Với hàm băm chống đụng độ, sẽ là rất khó để tìm được 2 thông điệp khác nhau nhưng có cùng giá trị băm.

  * Mã xác thực thông điệp (MAC - Message Authentication Code): MAC cũng được dùng để đảm bảo tính toàn vẹn của thông điệp mà không cần một kỹ thuật bổ sung nào khác. MAC là loại hàm băm có khóa như đã đề cập ở trên, với đầu vào là thông điệp và một khóa bí mật.


### Mô hình xử lý dữ liệu

Hình 3.30 biểu diễn mô hình tổng quát xử lý dữ liệu của các hàm băm. Theo đó, thông điệp đầu vào với độ dài tùy ý (arbitrary length input) đi qua hàm nén lặp nhiều vòng (iterated compression function) để tạo chuỗi đầu ra có kích thước cố định (fixed length output). Chuỗi này đi qua một khâu chuyển đổi định dạng tùy chọn (optional output transformation) để tạo ra chuỗi băm kết quả (output).

|<image_4>|

_Hình 3.30. Mô hình tổng quát xử lý dữ liệu của hàm băm_

Hình 3.31 mô tả chi tiết quá trình xử lý dữ liệu của các hàm băm. Theo đó, quá trình xử lý gồm 3 bước chính: (1) tiền xử lý (preprocessing), (2) xử lý lặp (iterated processing) và (3) chuyển đổi định dạng. Trong bước tiền xử lý, thông điệp đầu vào _x_ trước hết được nối đuôi thêm một số bit và kích thước khối, sau đó chia thành các khối có kích thước xác định. Kết quả của bước này là _t_ khối dữ liệu có cùng kích thước có dạng _x_ = _x 1x2…xt_ làm đầu vào cho bước 2\. Trong bước 2, từng khối dữ liệu _x i_ được xử lý thông qua hàm nén _f_

để tạo đầu ra là _H i_. Kết quả của bước 2 là chuỗi đầu ra _H t_ và _H t_ được chuyển đổi định dạng bởi hàm _g_ để tạo chuỗi giá trị băm hết quả _h_ ( _x_ ).

|<image_5>|

_Hình 3.31. Mô hình chi tiết xử lý dữ liệu của hàm băm_

## Một số hàm băm thông dụng

Các hàm băm thông dụng giới thiệu trong mục này đều là các hàm băm không khóa, gồm các họ hàm băm chính như sau:

  * Họ hàm băm MD (Message Digest) gồm các hàm băm MD2, MD4, MD5 và MD6.

  * Họ hàm băm SHA (Secure Hash Algorithm) gồm các hàm băm SHA0, SHA1, SHA2 và SHA3.

  * Một số hàm băm khác, gồm CRC (Cyclic redundancy checks), Checksums,...


Các mục con tiếp theo của mục này giới thiệu 2 hàm băm đã và đang được sử dụng rộng rãi nhất là hàm băm MD5 và SHA1.

### Hàm băm MD5

  * Giới thiệu


MD5 (Message Digest) là hàm băm không khóa được Ronald Rivest thiết kế năm 1991 để thay thế MD4. Chuỗi giá trị băm đầu ra của MD5 là 128 bit (16 byte) và thường được biểu diễn thành 32 số hexa. MD5 được sử dụng khá rộng rãi trong nhiều ứng dụng, như tạo chuỗi đảm bảo tính toàn vẹn thông điệp, tạo chuỗi kiểm tra lỗi, hoặc kiểm tra tính toàn vẹn dữ liệu (Checksum) và mã hóa mật khẩu trong các hệ điều hành và các ứng dụng. MD5 hiện nay được khuyến nghị không nên sử dụng do nó không còn đủ an toàn.

Nhiều điểm yếu của MD5 đã bị khai thác, như điển hình MD5 bị khai thác bởi mã độc Flame vào năm 2012.

  * Quá trình xử lý thông điệp


Quá trình xử lý thông điệp của MD5 gồm 2 khâu là _tiền xử lý_ và _các vòng lặp xử lý_.

Cụ thể, chi tiết về các khâu này như sau:

  * Tiền xử lý: Thông điệp được chia thành các khối 512 bit (16 từ 32 bit). Nếu kích thước thông điệp không là bội số của 512 thì nối thêm số bit còn thiếu.

  * Các vòng lặp xử lý: Phần xử lý chính của MD5 làm việc trên _state_ 128 bit, chia thành 4 từ 32 bit (A, B, C, D):


\+ Các từ A, B, C, D được khởi trị bằng một hằng cố định;

\+ Từng phần 32 bit của khối đầu vào 512 bit được đưa dần vào để thay đổi _state_ ;

\+ Quá trình xử lý gồm 4 vòng, mỗi vòng gồm 16 thao tác tương tự nhau.

\+ Mỗi thao tác gồm: Xử lý bởi hàm F (4 dạng hàm khác nhau cho mỗi vòng), Cộng modulo và Quay trái. Hình 3.32 biểu diễn lưu đồ xử lý của một thao tác của MD5, trong đó A, B, C, D là các từ 32 bit của _state_ , Mi: khối 32 bit thông điệp đầu vào, Ki là 32 bit hằng khác nhau cho mỗi thao tác, <<<s là thao tác dịch trái _s_ bit, |<image_6>| biểu diễn phép cộng modulo 32 bit và F là hàm phi tuyến tính.

|<image_7>|

_Hình 3.32. Lưu đồ xử lý một thao tác của MD5_

Hàm F gồm 4 dạng được dùng cho 4 vòng lặp. Cụ thể, F có các dạng như sau: F(B, C, D) = (B ∧ C) ∨ (¬B ∧ D)

G(B, C, D) = (B ∧ D) ∨ (C ∧ ¬D) H(B, C, D) = B ⊕ C ⊕ D

I(B, C, D) = C ⊕ (B ∨ ¬D)

trong đó, các ký hiệu ⊕, ∧, ∨, ¬ biểu diễn các phép toán lô gíc XOR, AND, OR và NOT tương ứng.

### Hàm băm SHA1

  * Giới thiệu


SHA1 (Secure Hash Function) được Cơ quan mật vụ Mỹ thiết kế năm 1995 để thay thế cho hàm băm SHA0. Chuỗi giá trị băm đầu ra của SHA1 có kích thước 160 bit và thường được biểu diễn thành 40 số hexa. Tương tự MD5, SHA1 được sử dụng rộng rãi để đảm bảo tính xác thực và toàn vẹn thông điệp.

  * Quá trình xử lý thông điệp


SHA1 sử dụng thủ tục xử lý thông điệp tương tự MD5, cũng gồm 2 khâu là _tiền xử lý_

và _các vòng lặp xử lý_. Cụ thể, chi tiết về các khâu này như sau:

  * Tiền xử lý: Thông điệp được chia thành các khối 512 bit (16 từ 32 bit). Nếu kích thước thông điệp không là bội số của 512 thì nối thêm số bit còn thiếu.

  * Các vòng lặp xử lý: Phần xử lý chính của SHA1 làm việc trên _state_ 160 bit, chia thành 5 từ 32 bit (A, B, C, D, E):


\+ Các từ A, B, C, D, E được khởi trị bằng một hằng cố định;

\+ Từng phần 32 bit của khối đầu vào 512 bit được đưa dần vào để thay đổi _state_ ;

\+ Quá trình xử lý gồm 80 vòng, mỗi vòng gồm các thao tác: add, and, or, xor, rotate, mod.

\+ Mỗi vòng xử lý gồm: Xử lý bởi hàm phi tuyến tính F (có nhiều dạng hàm khác nhau), Cộng modulo và Quay trái. Hình 3.33 biểu diễn lưu đồ một vòng xử lý của SHA1, trong đó A, B, C, D, E là các từ 32 bit của _state_ , Wt: khối 32 bit thông điệp đầu vào, Kt là 32 bit hằng khác nhau cho mỗi vòng, <<<n là thao tác dịch trái _n_ bit, |<image_8>| biểu diễn phép cộng modulo 32 bit và F là hàm phi tuyến tính.

|<image_9>|

_Hình 3.33. Lưu đồ một vòng xử lý của SHA1_

# Public_160

# Chữ ký số

## Một số khái niệm

_Chữ ký số_ (Digital signature) là một chuỗi dữ liệu liên kết với một thông điệp (message) và thực thể tạo ra thông điệp. Chữ ký số thường được sử dụng để đảm bảo tính toàn vẹn của thông điệp.

_Giải thuật tạo chữ ký số_ (Digital signature generation algorithm) là một phương pháp sinh chữ ký số;

_Giải thuật kiểm tra chữ ký số_ (Digital signature verification algorithm) là một phương pháp xác minh tính xác thực của chữ ký số, có nghĩa là nó thực sự được tạo ra bởi 1 bên chỉ định;

_Một hệ chữ ký số_ (Digital signature scheme) bao gồm giải thuật tạo chữ ký số và giải thuật kiểm tra chữ ký số.

_Quá trình tạo chữ ký số_ (Digital signature signing process) bao gồm:

  * Giải thuật tạo chữ ký số, và

  * Phương pháp chuyển dữ liệu thông điệp thành dạng có thể ký được.


_Quá trình kiểm tra chữ ký số_ (Digital signature verification process) bao gồm:

  * Giải thuật kiểm tra chữ ký số, và

  * Phương pháp khôi phục dữ liệu từ thông điệp.


## Quá trình ký và kiểm tra

|<image_1>|

_Hình 3.34. Quá trình tạo chữ ký số và kiểm tra chữ ký số_

Hình 3.34 biểu diễn quá trình tạo chữ ký số và kiểm tra chữ ký số cho một thông điệp (Message). Trong khi quá trình tạo chữ ký số cho thông điệp được thực hiện ở bên người gửi (Sender) thì quá trình kiểm tra chữ ký số của thông điệp được thực hiện ở bên người nhận (Receiver). Để có thể tạo và kiểm tra chữ ký số cho thông điệp, người gửi phải sở hữu cặp khóa công khai (Public key) và khóa riêng (Private key). Khóa riêng dùng để tạo chữ ký số và khóa công khai dùng để kiểm tra chữ ký số.

Các bước của quá trình tạo chữ ký số cho thông điệp (bên người gửi - Sender):

  * Tính toán chuỗi đại diện (message digest/hash value) của thông điệp sử dụng một giải thuật băm (Hashing algorithm);

  * Chuỗi đại diện được ký sử dụng khóa riêng (Private key) của người gửi và một giải thuật tạo chữ ký (Signature/Encryption algorithm). Kết quả là chữ ký số (Digital signature) của thông điệp hay còn gọi là chuỗi đại diện được mã hóa (Encrypted message digest);

  * Thông điệp ban đầu (message) được ghép với chữ ký số (Digital signature) tạo thành thông điệp đã được ký (Signed message);

  * Thông điệp đã được ký (Signed message) được gửi cho người nhận.


Các bước của quá trình kiểm tra chữ ký số của thông điệp (bên người nhận - Receiver):

  * Tách chữ ký số và thông điệp gốc khỏi thông điệp đã ký để xử lý riêng;

  * Tính toán chuỗi đại diện MD1 (message digest) của thông điệp gốc sử dụng giải thuật băm (là giải thuật sử dụng trong quá trình ký);

  * Sử dụng khóa công khai (Public key) của người gửi để giải mã chữ ký số để khôi phục chuỗi đại diện thông điệp MD2. Trên thực tế, người gửi thường chuyển chứng chỉ số khóa công khai của mình cho người nhận và người nhận thực hiện việc kiểm tra chứng chỉ số của người gửi và tách lấy khóa công khai nếu việc kiểm tra thành công.

  * So sánh hai chuỗi đại diện MD1 và MD2:


\+ Nếu MD1 = MD2 : chữ ký kiểm tra thành công. Thông điệp đảm bảo tính toàn vẹn và thực sự xuất phát từ người gửi (do khóa công khai được chứng thực).

\+ Nếu MD1 <> MD2 : chữ ký không hợp lệ. Thông điệp có thể đã bị sửa đổi hoặc không thực sự xuất phát từ người gửi.

## Các giải thuật chữ ký số

Mục này trình bày 2 giải thuật chữ ký số thông dụng là RSA và DSA. RSA được sử dụng rộng rãi do RSA có thể được sử dụng để mã hóa thông điệp và tạo chữ ký số cho thông điệp. DSA là thuật toán chữ ký chuẩn được Viện NIST (Hoa Kỳ) phát triển.

### Giải thuật chữ ký số RSA

Giải thuật RSA đề cập ở mục 3.3.2.2 có thể được sử dụng với hai mục đích để mã hóa

\- giải mã thông điệp và tạo chữ ký số - kiểm tra chữ ký số cho thông điệp. Điểm khác biệt

giữa việc sử dụng RSA cho mã hóa và chữ ký số là bên sở hữu các cặp khóa và việc sử dụng các khóa trong quá trình mã hóa và giải mã. Cụ thể:

\- RSA sử dụng cho mã hóa thông điệp:

\+ Người nhận phải sở hữu cặp khóa công khai (Public key) và khóa riêng (Private key). Người nhận chuyển khóa công khai của mình cho người gửi;

\+ Người gửi mã hóa thông điệp sử dụng khóa công khai của người nhận và chuyển bản mã cho người nhận;

\+ Người nhận giải mã thông điệp sử dụng khóa riêng của mình để khôi phục bản rõ của thông điệp.

\- RSA sử dụng cho tạo chữ ký số thông điệp:

\+ Người gửi phải sở hữu cặp khóa công khai (Public key) và khóa riêng (Private key). Người gửi chuyển khóa công khai của mình cho người nhận;

\+ Người gửi sử dụng khóa riêng để tạo chữ ký số cho thông điệp (bản chất là sử dụng khóa riêng để mã hóa chuỗi đại diện cho thông điệp);

\+ Người nhận sử dụng khóa công khai của người gửi để kiểm tra chữ ký số của thông điệp (bản chất là sử dụng khóa công khai để giải mã khôi phục chuỗi đại diện cho thông điệp).

Quá trình ký và kiểm tra chữ ký số sử dụng giải thuật RSA tương tự như quá trình ký và kiểm tra chữ ký số tổng quát đã trình bày ở mục 3.4.1.2 và Hình 3.34, trong đó quá trình ký sử dụng giải thuật mã hóa RSA với khóa riêng của người gửi và quá trình kiểm tra sử dụng giải thuật giải mã RSA với khóa công khai của người gửi.

### Giải thuật chữ ký số DSA

DSA (Digital Signature Algorithm) là thuật toán chữ ký số được phát triển từ giải thuật ElGamal Signature Algorithm và được công nhận là chuẩn chữ ký số sử dụng trong các cơ quan chính phủ bởi Viện NIST (Hoa Kỳ) vào năm 1991. DSA gồm 3 gồm 3 khâu:

(1) sinh cặp khóa, (2) quá trình ký thông điệp và (3) quá trình kiểm tra chữ ký của thông điệp.

  * Sinh khóa cho một người dùng:

* Chọn số ngẫu nhiên x sao cho 0 < x < q;

* Tính y = gx mod p;

* Khóa công khai là (q, p, g, y);

* Khóa riêng là x.

  * Quá trình ký thông điệp:

* H là hàm băm sử dụng và m là thông điệp gốc;

* Tính H(m) từ thông điệp gốc;

* Tạo số ngẫu nhiên k cho mỗi thông điệp, 0 < k < q;

* Tính r = (gk mod p) mod q;

* Nếu r = 0, chọn một k mới và tính lại r;

* Tính s = k-1(H(m) + xr) mod q;

* Nếu s = 0, chọn một k mới và tính lại r và s;

* Chữ ký là cặp (r, s).

  * Quá trình kiểm tra chữ ký

* Loại bỏ chữ ký nếu r và s không thỏa mãn 0 < r , s < q;

* Tính H(m) từ thông điệp nhận được;

* Tính w = s-1 mod q;

* Tính u1 = H(m) * w mod q;

* Tính u2 = r * w mod q;

* Tính v = ((gu1 * yu2) mod p) mod q;

* Chữ ký là xác thực nếu v = r.


Theo một số nghiên cứu, giải thuật chữ ký số DSA và giải thuật chữ ký số RSA có độ an toàn tương tương. Ưu điểm của giải thuật chữ ký số DSA so với giải thuật chữ ký số RSA là quá trình sinh cặp khóa và quá trình ký nhanh hơn. Tuy nhiên, quá trình kiểm tra chữ ký số bởi DSA thực hiện chậm hơn RSA. Trên thực tế, giải thuật chữ ký số RSA được sử dụng rộng rãi hơn do RSA có thể sử dụng cho cả mục đích mã hóa/giải mã và ký/kiểm tra chữ ký, trong khi DSA chỉ có thể sử dụng để ký/kiểm tra chữ ký.

# Chứng chỉ số

## Giới thiệu

Chứng chỉ số (Digital certificate), còn gọi là chứng chỉ khóa công khai (Public key certificate), hay chứng chỉ nhận dạng (Identity certificate) là một tài liệu điện tử sử dụng một chữ ký số để liên kết một khóa công khai và thông tin nhận dạng của một thực thể. Ba thành phần cơ bản nhất của một chứng chỉ số gồm:

  * Chữ ký số: là chữ ký của một bên thứ 3 tin cậy cung cấp chứng chỉ số, thường gọi là CA – Certificate Authority;

  * Khóa công khai: là khóa công khai trong cặp khóa công khai và khóa riêng của thực thể;

  * Thông tin nhận dạng: là tên, địa chỉ, tên miền hoặc các thông tin định danh của thực thể.


Chứng chỉ số có thể được sử dụng để xác minh chủ thể thực sự của một khóa công khai. Hình 3.35 là giao diện biểu diễn một chứng chỉ số do bên thứ 3 là một đơn vị của công ty Verisign cấp cho tên miền [_www.vietcombank.com.vn_](http://www.vietcombank.com.vn/) của ngân hàng TMCP Ngoại thương Việt Nam.

## Nội dung chứng chỉ số

Như biểu diễn trên Hình 3.36, nội dung của một chứng chỉ số gồm nhiều trường thông tin. Các trường thông tin cụ thể theo chuẩn chứng chỉ số X.509 gồm:

  * Serial Number: Số nhận dạng của chứng chỉ số;

  * Subject: Thông tin nhận dạng một cá nhân hoặc một tổ chức;


|<image_2>|

_Hình 3.35. Giao diện biểu diễn một chứng chỉ số_

  * Signature Algorithm: Giải thuật tạo chữ ký;

  * Signature Hash Algorithm: Giải thuật tạo chuỗi băm cho tạo chữ ký;

  * Signature: Chữ ký của người/tổ chức cấp chứng chỉ;

  * Issuer: Người/tổ chức có thẩm quyền/tin cậy cấp chứng chỉ;

  * Valid-From: Ngày bắt đầu có hiệu lực của chứng chỉ;

  * Valid-To: Ngày hết hạn sử dụng chứng chỉ;

  * Key-Usage: Mục địch sử dụng khóa (chữ ký số, mã hóa,…);

  * Public Key: Khóa công khai của chủ thể;

  * Thumbprint Algorithm: Giải thuật băm sử dụng để tạo chuỗi băm cho khóa công khai;

  * Thumbprint: Chuỗi băm tạo từ khóa công khai; Các mục thông tin của trường Subject gồm:

  * CN (Common Name): Tên chung, nhưng một tên miền được gán chứng chỉ;

  * OU (Organisation Unit): Tên bộ phận/phòng ban;

  * O (Organisation): Tổ chức/Cơ quan/công ty;

  * L (Location): Địa điểm/Quận huyện;

  * S (State/Province): Bang/Tỉnh/Thành phố;

  * C (Country): Đất nước.


|<image_3>|

_Hình 3.36. Nội dung chi tiết của một chứng chỉ số_

## Ứng dụng của chứng chỉ số

Chứng chỉ số được sử dụng rộng rãi trong bảo mật thông tin truyền và xác thực thông tin nhận dạng của các bên tham gia giao dịch điện tử, trao đổi khóa trong nhiều ứng dụng khác nhau. Cụ thể:

  * Sử dụng chứng chỉ số trong đảm bảo an toàn giao dịch trên nền web: với chứng chỉ số, một website có thể được cấu hình để hoạt động theo chế độ “an toàn” (HTTPS), trong đó toàn bộ thông tin trao đổi giữa máy chủ và máy khách được đảm bảo tính bí mật (sử dụng mã hóa khóa đối xứng), tính toàn vẹn và xác thực (sử dụng hàm băm có khóa MAC). Ngoài ra, các máy chủ và máy khách có thể xác thực thông tin nhận dạng của nhau sử dụng chứng chỉ số.

  * Chứng chỉ số cũng có thể được sử dụng để bảo mật thông tin truyền trong nhiều ứng dụng khác, như email, truyền file,…

  * Sử dụng chứng chỉ số có thể ngăn chặn hiệu quả dạng tấn công người đứng giữa do các bên tham gia giao dịch có thể xác thực thông tin nhận dạng của nhau. Nếu các bên sử dụng thêm chữ ký số thì có thể ngăn chặn việc sửa đổi các thông điệp trao đổi trên đường truyền.

  * Chứng chỉ số có thể được sử dụng trong trao đổi khóa.


# PKI

Hạ tầng khóa công khai (Public-key infrastructure - PKI) là một tập các phần cứng, phần mềm, nhân lực, chính sách và các thủ tục để tạo, quản lý, phân phối, sử dụng, lưu trữ và thu hồi các chứng chỉ số. Một PKI gồm các thành phần sau:

  * Certificate Authority (CA): Cơ quan cấp và kiểm tra chứng chỉ số;

  * Registration Authority (RA): Bộ phận tiếp nhận, kiểm tra thông tin nhận dạng của người dùng theo yêu cầu của CA;

  * Validation Authority (VA): Cơ quan xác nhận thông tin nhận dạng của người dùng thay mặt CA;

  * Central Directory (CD): Là nơi lưu danh mục và lập chỉ số các khóa;

  * Certificate Management System: Hệ thống quản lý chứng chỉ;

  * Certificate Policy: Chính sách về chứng chỉ.


|<image_4>|

_Hình 3.37. Lưu đồ cấp và sử dụng chứng chỉ số trong PKI_

Hình 3.37 biểu diễn lưu đồ cấp và sử dụng chứng chỉ số trong PKI, trong đó gồm 2 khâu chính:

  * Đăng ký, xét duyệt và cấp chứng chỉ số:


\+ Người dùng có yêu cầu cấp chứng chỉ số tạo một cặp khóa, gồm 1 khóa công khai và 1 khóa riêng;

\+ Người dùng tạo yêu cầu cấp chứng chỉ số (Certificate request), trong đó tích hợp khóa công khai và thông tin định danh của mình. Yêu cầu cấp chứng chỉ số thường được lưu dưới dạng 1 file văn bản theo định dạng của chuẩn X.509;

\+ Người dùng gửi yêu cầu cấp chứng chỉ số đến Bộ phận tiếp nhận (RA). RA kiểm tra các thông tin trong yêu cầu cấp chứng chỉ số, nếu hợp lệ thì chuyển yêu cầu đến Cơ quan cấp chứng chỉ (CA);

\+ CA sẽ thực hiện việc xác minh các thông tin nhận dạng của chủ thể và nếu xác minh thành công thì cấp chứng chỉ số cho người yêu cầu. Chứng chỉ số được CA ký bằng khóa riêng của mình để đảm bảo tính xác thực và toàn vẹn và thường được lưu dưới dạng 1 file văn bản theo định dạng của chuẩn X.509;

\+ Sau khi phát hành chứng chỉ số cho người dùng, CA chuyển thông tin về chứng chỉ số đã cấp cho thành phần VA để xác nhận thông tin nhận dạng theo yêu cầu;

\+ Người dùng cài đặt chứng chỉ số vào hệ thống và có thể bắt đầu sử dụng trong các ứng dụng của mình.

  * Sử dụng và kiểm tra chứng chỉ số:


\+ Người dùng tạo đơn hàng, ký vào đơn hàng bằng khóa riêng, gửi đơn hàng đã ký và chứng chỉ số cho nhà cung cấp;

\+ Nhà cung cấp chuyển chứng chỉ số của người dùng cho VA để kiểm tra, nếu chứng chỉ số hợp lệ thì tiến hành xác thực chữ ký số của người dùng sử dụng khóa công khai của người dùng lấy từ chứng chỉ số. Nếu chữ ký của người dùng xác thực thành công thì đơn hàng được duyệt.

# Public_162

# Khái niệm

## Quan hệ khóa

Quan hệ khóa (Keying relationship) là trạng thái mà trong đó các bên tham gia truyền thông chia sẻ dữ liệu chia sẻ (thường là khóa hoặc thành phần tạo ra khóa) để sử dụng cho các kỹ thuật mã hóa. Các dữ liệu chia sẻ có thể gồm:

  * Khóa bí mật

  * Khóa công khai

  * Các giá trị khởi tạo

  * Các tham số bổ sung không bí mật.


## Quản lý khóa

Quản lý khóa (Key management) là một tập các kỹ thuật cho phép thiết lập và duy trì các quan hệ khóa giữ các bên có thẩm quyền. Cụ thể, quản lý khóa gồm các kỹ thuật và thủ tục cho phép:

  * Khởi tạo các người dùng hệ thống (system users) trong một vùng (domain);

  * Sinh khóa, phân phối và cài đặt các dữ liệu khóa;

  * Kiểm soát việc sử dụng các dữ liệu khóa;

  * Cập nhật, thu hồi và hủy các dữ liệu khóa;

  * Lưu, sao lưu/khôi phục và lưu trữ các dữ liệu khóa.


## Phân phối khóa

Phân phối khóa (Key distribution) là một thành phần của quản lý khóa, trong đó các khóa mật mã được vận chuyển, hoặc trao đổi giữa các thực thể trong một hệ thống, hay giữa các bên tham gia phiên truyền thông.

# Vai trò và các nguy cơ mất an toàn quản lý khóa

Quản lý khóa là một khâu có vai trò quan trọng trong việc đảm bảo tính bí mật, toàn vẹn, xác thực, không thể chối bỏ và dịch vụ chữ ký số của một hệ mã hóa. Khâu quản lý khóa được thực hiện phù hợp sẽ đảm bảo cho các thông tin khóa được an toàn, đặc biệt khi có nhiều thực thể tham gia truyền thông. Các thông tin khóa được đảm bảo an toàn là yếu tố tiên quyết cho việc đảm bảo tính an toàn của hệ mã hóa.

Đứng trên góc độ quản lý, vấn đề quản lý khóa phải luôn được thực hiện trong khuôn khổ chính sách an ninh (Security policies) cụ thể. Chính sách an ninh của cơ quan, tổ chức cần có các nội dung mô tả về quản lý khóa, bao gồm:

  * Các thực tế và thủ tục cần thực hiện trong các khía cạnh kỹ thuật và quản trị khóa tự động hoặc thủ công;

  * Trách nhiệm của các bên có liên quan;

  * Các bản ghi dữ liệu cần phải lưu để tạo các báo cáo về các vấn đề có liên quan đến an toàn khóa.


Ngoài ra, việc phân tích, nhận dạng các nguy cơ đe dọa an toàn của khâu quản lý khóa là một việc cần thiết, từ đó có thể đề ra và áp dụng các biện pháp đảm bảo an toàn phù hợp. Các nguy cơ đối với quản lý khóa bao gồm:

  * Các khóa bí mật bị lộ;

  * Tính xác thực của các khóa bí mật và công khai bị thỏa hiệp (compromise). Tính xác thực bao gồm các hiểu biết và việc kiểm chứng thông tin nhận dạng của một bên mà khóa được chia sẻ;

  * Sử dụng trái phép các khóa bí mật và công khai:


\+ Sử dụng các khóa đã hết hiệu lực;

\+ Sử dụng các khóa sai mục đích.

# Phân loại khóa

Các khóa/chìa mật mã (Cryptographic key) có thể được phân loại theo (1) khả năng sử dụng và (2) thời gian sử dụng. Theo khả năng sử dụng, có thể chia các khóa thành 3 lớp:

## Khóa chủ (Master key):

\+ Là các khóa ở mức cao nhất và không được bảo vệ bằng các kỹ thuật mật mã.

\+ Các khóa chủ thường được chuyển giao trực tiếp và được bảo vệ bằng các cơ chế kiểm soát vật lý.

## Khóa dùng cho trao đổi khóa (Key – encrypting key):

\+ Là những khóa được sử dụng để vận chuyển hoặc lưu trữ các khóa khác.

\+ Các khóa này cũng có thể được bảo vệ bằng khóa khác.

## Khóa dữ liệu (Data keys):

\+ Là các khóa được sử dụng để mã hóa dữ liệu cho người dùng.

\+ Thường là các khóa ngắn hạn.

Theo thời gian sử dụng, có thể chia các khóa thành 2 lớp:

## Khóa dài hạn (long-term key):

\+ Là các khóa được sử dụng trong một khoảng thời gian dài;

\+ Gồm khóa chủ, khóa dùng cho trao đổi khóa, hoặc khóa dùng cho thỏa thuận khóa.

## Khóa ngắn hạn:

\+ Là các khóa được sử dụng trong một khoảng thời gian ngắn hoặc chỉ trong một phiên làm việc;

\+ Gồm các khóa được trao đổi trong quá trình trao đổi khóa, thỏa thuận khóa;

\+ Thường được dùng để mã hóa dữ liệu của người dùng.

# Phân phối khóa bí mật

## Đặt vấn đề

Như đã đề cập trong mục 3.3.1, các hệ mã hóa khóa đối xứng, hay khóa bí mật (Secret key cryptosystem) có ưu điểm là tính an toàn cao và tốc độ xử lý nhanh do kích thước khóa tương đối nhỏ. Tuy nhiên, hạn chế lớn nhất của chúng là khó khăn trong quản lý và phân phối khóa bí mật – các khóa bí mật dùng chung phải được phân phối, chia sẻ an toàn đến các bên tham gia trước khi có thể thực hiện phiên truyền thông an toàn.

Vấn đề phân phối khóa bí mật được khái quát hóa thành bài toán phân phối n2 khóa. Bài toán này phát biểu như sau: Nếu một hệ thống có n người dùng tham gia truyền thông sử dụng kỹ thuật mã hóa khóa đối xứng và mỗi cặp người dùng cần trao đổi thông tin an toàn, thì mỗi cặp người dùng cần chia sẻ một khóa bí mật duy nhất. Như vậy, mỗi người dùng cần sở hữu n-1 khóa bí mật và tổng số khóa cần quản lý trong hệ thống là n(n-1)/2 ≈ n2. Ví dụ, nếu hệ thống có 10 người dùng, tổng số khóa cần quản lý là 10×9/2 = 45 khóa; với 100 người dùng, số khóa là 100×99/2 = 4.950 khóa; và với 1000 người dùng, số khóa là 1000×999/2 = 499.500 khóa. Số khóa cần quản lý sẽ rất lớn nếu số người dùng lớn và việc quản lý số lượng lớn khóa đảm bảo an toàn là rất khó khăn.

Để giải quyết bài toán phân phối n2 khóa và đảm bảo an toàn trong phân phối các khóa bí mật, một số mô hình và kỹ thuật phân phối khóa bí mật được đề xuất và ứng dụng, bao gồm:

  * Phân phối khóa điểm – điểm (Point-to-point key distribution)

  * Trung tâm phân phối khóa (Key distribution center – KDC)

  * Trung tâm dịch khóa (Key translation center – KTC)

  * Sử dụng mã hóa khóa công khai để phân phối khóa bí mật.


Các mục tiếp theo mô tả chi tiết các mô hình và kỹ thuật phân phối khóa bí mật này.

## Phân phối khóa điểm – điểm

Phân phối khóa điểm – điểm (Point-to-point key distribution) là hình thức phân phối khóa chỉ liên quan trực tiếp đến 2 thực thể tham gia truyền thông, như minh họa trên Hình 3.38. Hình thức phân phối khóa điểm – điểm có thể thực hiện thông qua các kênh tin cậy, như kênh truyền thuê riêng, hoặc thư bảo đảm. Phương pháp này có thể sử dụng với các trao đổi không thường xuyên và thích hợp với các hệ thống cỡ nhỏ hoặc đóng kín. Nhược điểm của phương pháp này là trễ có thể lớn (như sử dụng thư bảo đảm) và các kênh tin cậy dùng riêng thường đắt tiền.

|<image_1>|

_Hình 3.38. Phân phối khóa điểm – điểm_

## Trung tâm phân phối khóa

### Giới thiệu

Trung tâm phân phối khóa (Key distribution center – KDC) là một trong các kỹ thuật được sử dụng rộng rãi để giải quyết bài toán n2 khóa trong hệ thống có n người dùng. Mục tiêu là KDC tạo và phân phối khóa bí mật an toàn đến các thực thể trong hệ thống và giảm thiểu số lượng khóa dài hạn mà mỗi thực thể và KDC phải quản lý. Hình 3.39 biểu diễn mô hình hoạt động của hệ thống KDC gồm 3 thực thể: Trung tâm phân phối khóa KDC ký hiệu là T và 2 thực thể thành viên tham gia trao đổi khóa là A và B. Khóa bí mật cần trao đổi là K. Hoạt động của hệ thống KDC gồm 2 khâu: (1) Khởi tạo – thiết lập môi trường và các tham số hoạt động và (2) Thủ tục phân phối khóa sử dụng KDC.

|<image_2>|

_Hình 3.39. Mô hình hoạt động của trung tâm phân phối khóa – KDC_

### Khởi tạo

Trong quá trình khởi tạo, thực thể A sở hữu khóa dài hạn KAT và A chia sẻ KAT với KDC T. Thực thể B sở hữu khóa dài hạn KBT và B chia sẻ KBT với KDC T. Trung tâm phân phối khóa T là một máy chủ tin cậy, cho phép hai bên A và B không trực tiếp chia sẻ thông tin khóa thiết lập kênh truyền thông an toàn sử dụng hai khóa dài hạn KAT và KBT.

### Thủ tục phân phối khóa

Hình 3.39 biểu diễn mô hình hoạt động của trung tâm phân phối khóa. Gọi E là hàm mã hóa, D là hàm giải mã, thủ tục phân phối khóa sử dụng KDC T như sau:

  * A yêu cầu chia sẻ khóa với B;

  * T sẽ tạo ra hoặc lấy khóa có sẵn K và mã hóa K thành EKAT(K) và gửi cho A;

  * T cũng có thể gửi khóa cho B dưới dạng EKBT(K) thông qua A (hình i);

  * T cũng có thể gửi khóa trực tiếp cho B dưới dạng EKBT(K) (hình ii);

  * A nhận được EKAT(K), giải mã sử dụng KAT để có được K: DKAT(EKAT(K)) = K

  * B nhận được EKBT(K), giải mã sử dụng KBT để có được K: DKBT(EKBT(K)) = K


## Trung tâm dịch khóa

### Giới thiệu

Trung tâm dịch chuyển khóa (Key translation center – KTC) là một trong các kỹ thuật được sử dụng rộng rãi để giải quyết bài toán n2 khóa trong hệ thống có n người dùng. Vai trò của KTC tương tự KDC, tuy nhiên một bên tham gia truyền thông sẽ cung cấp khóa trao đổi. Mục tiêu là KTC chuyển khóa bí mật an toàn đến các thực thể còn lại tham gia truyền thông trong hệ thống và giảm thiểu số lượng khóa dài hạn mà mỗi thực thể và KTC phải quản lý. Điểm khác biệt của KTC so với KDC là KTC cho phép sinh khóa phân tán (các thực thể tự sinh khóa), còn KDC cho phép sinh khóa tập trung (KDC sinh khóa). Hình 3.40 biểu diễn mô hình hoạt động của hệ thống KTC gồm 3 thực thể: Trung tâm dịch chuyển khóa KTC ký hiệu là T và 2 thực thể thành viên tham gia trao đổi khóa là A và B. Khóa bí mật cần trao đổi là K. Hoạt động của hệ thống KTC gồm 2 khâu: (1) Khởi tạo – thiết lập môi trường và các tham số hoạt động và (2) Thủ tục phân phối khóa sử dụng KTC.

|<image_3>|

_Hình 3.40. Mô hình hoạt động của trung tâm dịch chuyển khóa – KTC_

  1. Khởi tạo


Trong quá trình khởi tạo, thực thể A sở hữu khóa dài hạn KAT và A chia sẻ KAT với KTC T. Thực thể B sở hữu khóa dài hạn KBT và B chia sẻ KBT với KTC T. Trung tâm phân phối khóa T là một máy chủ tin cậy, cho phép hai bên A và B không trực tiếp chia sẻ thông tin khóa thiết lập kênh truyền thông an toàn sử dụng hai khóa dài hạn KAT và KBT.

### Thủ tục phân phối khóa

Hình 3.40 biểu diễn mô hình hoạt động của trung tâm dịch chuyển khóa. Gọi E là hàm mã hóa, D là hàm giải mã, thủ tục phân phối khóa sử dụng KTC T như sau:

  * A tạo ra khóa K và mã hóa K thành EKAT(K) và gửi cho T;

  * T nhận được EKAT(K), giải mã sử dụng KAT thu được K: DKAT(EKAT(K)) = K

  * Sau đó, T mã hóa khóa K sử dụng KBT để có EKBT(K);

  * T có thể gửi khóa cho B dưới dạng EKBT(K) thông qua A (hình i);

  * T cũng có thể gửi khóa trực tiếp cho B dưới dạng EKBT(K) (hình ii);

  * B nhận được EKBT(K), giải mã sử dụng KBT để có được K: DKBT(EKBT(K)) = K


### Ưu điểm và nhược điểm của quản lý khóa tập trung (KDC và KTC)

  * Ưu điểm:


\+ Hiệu quả trong lưu trữ khóa: mỗi bên chỉ cần duy trì một khóa bí mật dài hạn với bên tin cậy (không phải với bên trao đổi thông tin);

\+ Tổng số khóa dài hạn cần lưu trữ là n khóa (so với n2 khóa).

  * Nhược điểm:


\+ Cả hệ thống có thể bị mất an toàn nếu trung tâm quản lý khóa bị thỏa hiệp (bị điều khiển);

\+ Trung tâm quản lý khóa có thể thành điểm nút cổ chai;

\+ Dịch vụ sẽ phải ngừng nếu trung tâm quản lý khóa gặp trục trặc;

\+ Cần có một máy chủ tin cậy ở chế độ trực tuyến.

### Sử dụng mã hóa khóa công khai để phân phối khóa bí mật

Do các hệ mã hóa khóa công khai có ưu điểm là phân phối khóa công khai dễ dàng, có thể sử dụng mã hóa khóa công khai để phân phối khóa bí mật. Các giao thức SSL/TLS và PGP đều sử dụng phương pháp này một cách hiệu quả để trao đổi khóa bí mật, hoặc dữ liệu khóa bí mật cho phiên làm việc. Chi tiết về các giao thức này được đề cập ở mục 3.6.

Giả thiết bên A cần chuyển khóa bí mật Ks cho bên B. Các bước hai bên A và B cần thực hiện để chuyển khóa bí mật Ks từ A đến B sử dụng mã hóa khóa công khai như sau:

  * B tạo cặp khóa, khóa công khai Kp và khóa riêng Kr;

  * B gửi khóa công khai Kp của mình cho A (cần đảm bảo tính xác thực và toàn vẹn của Kp);

  * A sử dụng Kp để mã hóa khóa bí mật Ks tạo bản mã Cs và gửi cho B;

  * B sử dụng khóa riêng Kr để giải mã Cs để khôi phục khóa bí mật Ks.


# Phân phối khóa công khai

## Giới thiệu

Khác với khóa bí mật, việc phân phối khóa công khai thuận lợi hơn do khóa công khai có thể trao đổi công khai giữa các thực thể tham gia truyền thông. Tuy nhiên, việc phân phối khóa công khai phải đảm bảo tính xác thực (authentic public keys). Tính xác thực của khóa công khai thể hiện ở 2 yếu tố: (1) tính toàn vẹn và chủ thể luôn xác định. Các phương pháp phân phối khóa công khai được sử dụng rộng rãi bao gồm:

  * Trao đổi kiểu điểm-điểm thông qua kênh tin cậy;

  * Truy nhập trực tiếp vào danh mục công cộng (public-key registry);

  * Sử dụng một máy chủ trực tuyến tin cậy;

  * Sử dụng một máy chủ không trực tuyến và chứng chỉ.


Phương pháp trao đổi khóa công khai kiểu điểm-điểm thông qua kênh tin cậy được thực hiện tương tự như phương pháp trao đổi khóa bí mật kiểu điểm-điểm đã được trình

bày ở mục 3.5.2.2. Các phương pháp phân phối khóa công khai còn lại được trình bày trong các mục tiếp theo.

## Truy nhập trực tiếp vào danh mục công cộng (public-key registry)

Trong phương pháp này, một cơ sở dữ liệu công cộng tin cậy được thiết lập, trong đó mỗi bản ghi gồm tên người dùng và khóa công khai tương ứng. Cơ sở dữ liệu công cộng này có thể được vận hành bởi 1 bên tin cậy và người dùng có thể truy nhập khóa công khai từ cơ sở dữ liệu này nếu biết tên người dùng. Một phương pháp thực hiện được sử dụng phổ biến là cây xác thực khóa công khai (Tree authentication of public keys).

## Sử dụng một máy chủ trực tuyến tin cậy

Trong phương pháp này, một máy chủ trực tuyến tin cậy được sử dụng để cung cấp truy nhập đến cơ sở dữ liệu công cộng các khóa công khai. Khóa công khai cần phân phối được ký sử dụng khóa riêng của máy chủ và gửi cho bên yêu cầu. Phương pháp này không đòi hỏi phải sử dụng kênh truyền bí mật. Bên yêu cầu sử dụng khóa công khai của máy chủ để xác thực chữ ký của máy chủ và qua đó kiểm tra tính xác thực, toàn vẹn của khóa. Phương pháp này có nhược điểm là máy chủ phải luôn trực tuyến để hệ thống có thể hoạt động và bản thân máy chủ có thể trở thành điểm nút cổ chai trong hệ thống.

## Sử dụng một máy chủ không trực tuyến và chứng chỉ

Đây là phương pháp phân phối khóa dựa trên chứng chỉ khóa công khai (Public key certificate) được sử dụng rất rộng rãi trong bảo mật thông tin truyền trên mạng Internet. Các bước thực hiện của phương pháp này gồm:

  * Bên A liên hệ với một bên tin cậy (được gọi là Cơ quan cấp chứng chỉ - Certification Authority (CA)) để đăng ký khóa công khai của mình và nhận được chữ ký xác nhận khóa công khai của CA;

  * CA cấp một chứng chỉ (Certificate) cho khóa công khai của A, trong đó kết hợp khóa công khai của A với thông tin định danh của A sử dụng chữ ký số của CA;

  * Khi A đã có chứng chỉ khóa công khai (Public key certificate), A có thể gửi khóa công khai cho các bên có liên quan bằng cách gửi chứng chỉ khóa công khai.

  * Chứng chỉ khóa công khai cũng có thể được đưa vào danh mục công cộng và người dùng khác có thể truy nhập.


Chi tiết về chứng chỉ khóa công khai và quá trình cấp phát – sử dụng chứng chỉ đã được đề cập ở các mục 3.4.2 và 3.4.3.

# Public_163

# SSL/TLS

## Giới thiệu

SSL (Secure Socket Layer) là giao thức bảo mật do công ty Netscape phát minh năm 1993. Các phiên bản SSL được phát triển bao gồm: phiên bản 1.0 phát hành năm 1993, phiên bản 2.0 phát hành năm 1995 và phiên bản 3.0 phát hành năm 1996. Sau phiên bản 3.0, SSL chính thức dừng phát triển. SSL hiện ít được sử dụng do có nhiều lỗi và không được cập nhật.

TLS (Transport Layer Security) được phát triển vào năm 1999 dựa trên SSL 3.0 do tổ chức IETF phê chuẩn. Các phiên bản của TLS gồm: phiên bản 1.0 phát hành năm 1999, phiên bản 1.1 phát hành năm 2005, phiên bản 1.2 phát hành năm 2008, phiên bản 1.3 vẫn là bản thảo và chưa được phát hành chính thức cho đến tháng 10 năm 2017. Hiện nay phiên bản TLS 1.2 được sử dụng rộng rãi nhất, còn SSL chỉ được giữ lại tên với lý do lịch sử.

|<image_1>|

_Hình 3.41. SSL/TLS trong bộ giao thức TCP/IP_

Hình 3.41 biểu diễn vị trí của giao thức SSL/TLS trong chồng giao thức TCP/IP. Có thể thấy SSL/TLS hoàn toàn độc lập với các giao thức tầng ứng dụng nên nó có thể được sử dụng để bảo mật thông tin truyền cho nhiều giao thức ứng dụng khác nhau, như HTTP, SMTP và FTP. Chẳng hạn, giao thức bảo mật web HTTPS = HTTP + SSL/TLS, có nghĩa là HTTPS tạo ra bởi HTTP chạy trên nền SSL/TLS. Một trong các điều kiện để SSL/TLS có thể hoạt động là ít nhất một thực thể (thường là máy chủ) tham gia phiên truyền thông phải có chứng chỉ số cho khoá công khai (Public key certificate).

|<image_2>|

_Hình 3.42. Các giao thức con của SSL/TLS_

SSL/TLS là một bộ gồm có 4 giao thức con, như minh họa trên Hình 3.42. Các giao thức con của SSL/TLS gồm:

  * SSL Handshake Protocol: Giao thức bắt tay của SSL có nhiệm vụ trao đổi các thông điệp xác thực thực thể và thiết lập các thông số cho phiên làm việc;

  * SSL Change Cipher Spec Protocol: Giao thức thiết lập việc sử dụng các bộ mã hóa được hỗ trợ bởi cả 2 bên tham gia phiên truyền thông;

  * SSL Alert Protocol: Giao thức cảnh bảo của SSL;

  * SSL Record Protocol: Giao thức bản ghi của SSL có nhiệm vụ tạo đường hầm an toàn để chuyển thông tin đảm bảo tín bí mật, toàn vẹn và xác thực.


## Hoạt động của SSL/TS

|<image_3>|

_Hình 3.43. Mô hình truyền thông giữa Web Server và Browser dựa trên SSL/TLS_

Hình 3.43 biểu diễn mô hình một phiên truyền thông giữa máy chủ web (Web Server) và máy khách web (Browser) dựa trên SSL/TLS. Theo đó, giao thức Bắt tay (Handshake) khởi tạo phiên làm việc (có sự hỗ trợ của giao thức Change Cipher Spec), giao thức Bản ghi (Record) vận chuyển dữ liệu an toàn và giao thức Cảnh báo (Alert) gửi các cảnh báo khi xảy ra lỗi, hoặc một sự kiện đặc biệt.

### Khởi tạo phiên làm việc

|<image_4>|

_Hình 3.44. Khởi tạo phiên làm việc trong SSL/TLS_

Quá trình khởi tạo phiên làm việc trong SSL/TLS được thực hiện bởi giao thức SSL Handshake với sự hỗ trợ của giao thức SSL Change Cipher Spec. Các nhiệm vụ được các

bên tham gia truyền thông thực hiện trong quá trình này bao gồm: (1) xác thực thông tin nhận dạng, (2) đàm phán thống nhất các bộ mã hóa sử dụng và (3) trao đổi khóa và các thông số khác cho phiên truyền thông.

Quá trình khởi tạo phiên làm việc biểu diễn trên Hình 3.44 giữa SSL Client (máy khách) và SSL Server (máy chủ) gồm các bước sau:

  1. SSL Client gửi thông điệp “client hello” và thông tin mã hóa (Cryptographic information) đến SSL Server;

  2. SSL Server gửi thông điệp “server hello”, các bộ mã hóa hỗ trợ (CipherSuite) và chứng chỉ máy chủ (Server certificate) đến SSL Client. SSL Server cũng có thể gửi yêu cầu máy khách cung cấp chứng chỉ máy khách (Client certificate) nếu cần thiết;

  3. Nhận được yêu cầu, SSL Client kiểm tra chứng chỉ máy chủ và kiểm tra các tham số mã hóa. Hai bên thống nhất sử dụng các bộ mã hóa tốt nhất cùng hỗ trợ cho phiên làm việc. Nếu chứng chỉ máy chủ không hợp lệ quá trình quá trình khởi tạo phiên kết thúc không thành công. Nếu chứng chỉ máy chủ hợp lệ tiếp tục bước tiếp theo;

  4. Trao đổi khóa máy khách (Client key exchange). SSL Client sinh khóa phiên (hoặc các tham số mã hóa cho phiên), mã hóa khóa phiên sử dụng khóa công khai của SSL Server lấy từ chứng chỉ máy chủ và gửi cho SSL Server;

  5. SSL Client cũng có thể gửi chứng chỉ máy khách cho máy chủ nếu được yêu cầu;

  6. SSL Server sử dụng khóa riêng của mình để giải mã khôi phục khóa phiên gửi từ SSL Client. SSL Server cũng có thể kiểm tra chứng chỉ máy khách nếu cần thiết;

  7. Client gửi thông điệp kết thúc khởi tạo phiên “Finished”;

  8. Server gửi thông điệp kết thúc khởi tạo phiên “Finished”.


Sau khi quá trình khởi tạo thành công, hai bên SSL Client và SSL Server xác thực được các thông tin nhận dạng của nhau sử dụng chứng chỉ số, thống nhất các bộ mã hóa tốt nhất sử dụng và trao đổi được các khóa phiên, hoặc các tham số mã hóa phiên, hai bên thiết lập thành công kênh bảo mật cho truyền dữ liệu trong phiên.

### Vận chuyển dữ liệu an toàn

Quá trình vận chuyển dữ liệu an toàn thực hiện bởi giao thức SSL Record sau khi khởi tạo phiên làm việc thành công. Giao thức SSL Record sử dụng các tham số mã hóa và các bộ mã hóa thiết lập trong quá trình khởi tạo để tạo đường hầm vận chuyển dữ liệu an toàn. SSL Record đảm bảo tính bí mật cho khối dữ liệu sử dụng mã hóa đối xứng với khóa phiên, và đảm bảo tính toàn vẹn và xác thực cho khối dữ liệu sử dụng hàm băm có khóa (MAC). Hình 3.45 biểu diễn quá trình xử lý dữ liệu bởi SSL Record tại bên gửi, gồm các bước:

  * Phân mảnh dữ liệu (Fragment): Dữ liệu từ ứng dụng (Application Data) được phân mảnh thành các khối cho phù hợp với việc đóng gói và truyền của các lớp giao thức tầng thấp hơn;


|<image_5>|

_Hình 3.45. Quá trình xử lý dữ liệu bởi SSL Record tại bên gửi_

  * Nén dữ liệu (Compress): Từng khối dữ liệu được được nén để giảm kích thước.


Bước nén dữ liệu là không bắt buộc;

  * Thêm MAC (Add MAC): Tính toán giá trị MAC (sử dụng hàm băm có khóa) cho khối dữ liệu nén và ghép giá trị MAC vào khối dữ liệu. Việc thêm MAC và kiểm tra MAC ở bên nhận để đảm bảo tính toàn vẹn và xác thực khối dữ liệu;

  * Mã hóa (Encrypt): Mã hóa khối dữ liệu (gồm khối dữ liệu nén và MAC) để đảm bảo tính bí mật sử dụng mã hóa khóa đối xứng với khóa phiên;

  * Thêm đề mục của SSL Record (Append SSL Record Header): thêm đề mục của SSL Record vào khối dữ liệu đã mã hóa và chuyển xuống tầng giao vận để chuyển sang bên nhận.


Quá trình xử lý dữ liệu khối dữ liệu nhận được tại bên nhận được thực hiện bởi SSL Record theo trình tự ngược lại, gồm các bước: Tách đề mục của SSL Record, Giải mã, Tách và kiểm tra MAC, Giải nén và Ghép các mảnh dữ liệu thành chuỗi dữ liệu để chuyển cho lớp ứng dụng.

# SET

SET (Secure Electronic Transaction) là giao thức cho phép thanh toán điện tử an toàn sử dụng thẻ tín dụng do 2 công ty Visa International và MasterCard (Hoa Kỳ) phát triển. SET có khả năng đảm bảo các thuộc tính bí mật, toàn vẹn thông tin truyền, xác thực tài khoản chủ thẻ và xác thực nhà cung cấp.

Hình 3.46 biểu diễn một mô hình tương tác giữa các thực thể tham gia thực hiện SET. Các thực thể tham gia mô hình này gồm: Chủ thẻ/Khách hàng (Cardholder), Nhà cung cấp dịch vụ/Người bán hàng (Merchant), Cổng thanh toán (Payment Gateway), Ngân hàng của nhà cung cấp/Ngân hàng của người bán (Acquirer), Ngân hàng của chủ thẻ/Ngân hàng của người mua (Issuer) và Nhà cung cấp chứng chỉ (Certificate Authority). Tất cả các bên tham gia quá trình xử lý giao dịch thanh toán (Cardholder, Merchant, Payment Gateway, Acquirer, Issuer) đều phải đăng ký với Nhà cung cấp

chứng chỉ và được cấp chứng chỉ khóa công khai. Các chứng chỉ khóa công khai được các bên sử dụng để xác thực thông tin nhận dạng của nhau và hỗ trợ trao đổi khóa. Quá trình thực hiện một giao dịch dựa trên SET gồm các bước sau:

|<image_6>|

_Hình 3.46. Một mô hình tương tác giữa các thực thể tham gia SET_

  1. Khách hàng xem các sản phẩm trên website của Người bán hàng và quyết định các mặt hàng sẽ mua;

  2. Khách hàng gửi thông điệp gồm thông tin đơn hàng và thanh toán gồm 2 phần: (i) Đơn hàng – dành cho Người bán hàng và (ii) Thông tin thẻ \- dành cho hệ thống thanh toán;

  3. Người bán hàng chuyển thông tin thẻ cho Cổng thanh toán. Cổng thanh toán chuyển tiếp cho Ngân hàng của người bán;

  4. Ngân hàng của người bán gửi yêu cầu xác thực giao dịch thanh toán đến Ngân hàng của người mua;

  5. Ngân hàng của người mua gửi xác nhận giao dịch đến Ngân hàng của người bán;

  6. Ngân hàng của người bán gửi xác nhận giao dịch đến Người bán hàng;

  7. Người bán hàng hoàn tất đơn hàng và gửi xác nhận đơn hàng đến Khách hàng;

  8. Người bán hàng ghi nhận giao dịch theo thông tin từ Ngân hàng người bán cung cấp;

  9. Ngân hàng của người mua in hóa đơn giao dịch cho thẻ tín dụng của Khách hàng.


# PGP

## Giới thiệu

PGP (Pretty Good Privacy) là phương pháp bảo mật do Philip Zimmermann phát triển năm 1991 có khả năng cung cấp tính riêng tư và tính xác thực các thông điệp truyền. PGP được sử dụng rộng rãi và đã được thừa nhận thành chuẩn thực tế (RFC 3156). PGP hỗ trợ

mã hoá dữ liệu sử dụng mã hoá khoá bí mật và mã hóa khoá công khai, đồng thời cho phép tạo và kiểm tra chữ ký số.

PGP được sử dụng rộng rãi để truyền email và file an toàn. PGP hỗ trợ hầu hết các giải thuật mã hóa hiện đại như 3DES, AES, IDEA, RSA, ElGamal. Có nhiều bản cài đặt PGP trên thực tế như OpenPGP, GnuPG, Gpg4win,….

## Hoạt động của PGP

PGP hỗ trợ 3 mô hình hoạt động, bao gồm (1) Mô hình PGP chỉ đảm bảo tính xác thực thông điệp, (2) Mô hình PGP chỉ đảm bảo tính bí mật thông điệp và (3) Mô hình PGP đảm bảo tính bí mật và xác thực thông điệp. Để thuận tiện cho mô tả hoạt động của các mô hình PGP, gọi H là hàm băm một chiều, EC là hàm mã hóa khóa đối xứng, DC là hàm giải mã khóa đối xứng, EP là hàm mã hóa khóa bất đối xứng, DP là hàm giải mã khóa bất đối xứng, Z là hàm nén, Z-1 là hàm giải nén, PUa là khóa công khai của bên A, PRa là khóa riêng của bên A, PUb là khóa công khai của bên B, PRb là khóa riêng của bên B và Ks là khóa phiên. Phần tiếp theo trình bày chi tiết về hoạt động của các mô hình này.

|<image_7>|
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Bên gửi</th>
<th>====&gt;</th>
<th>Bên nhận</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

_Hình 3.47. Mô hình PGP chỉ đảm bảo tính xác thực thông điệp_

Hình 3.47 biểu diễn mô hình PGP chỉ đảm bảo tính xác thực thông điệp truyền. Theo đó, mô hình này sử dụng chữ ký số để xác thực tính toàn vẹn và chủ thể gửi thông điệp. Điều kiện thực hiện mô hình này là bên gửi A phải sở hữu cặp khóa (khóa công khai PUa và khóa riêng PRa). Quá trình thực hiện gửi/nhận thông điệp _M_ đảm bảo tính xác thực tại mỗi bên như sau:

\- Bên gửi A:

\+ Tính toán giá trị băm (giá trị đại diện) của thông điệp _M_ sử dụng hàm băm H;

\+ Sử dụng khóa riêng PRa để mã hóa (ký) giá trị băm của M tạo thành chữ ký số;

\+ Ghép chữ ký số vào thông điệp _M_ ;

\+ Nén thông điệp và chữ ký số sử dụng hàm nén Z;

\+ Gửi bản dữ liệu đã nén cho người nhận.

\- Bên nhận B:

\+ Giải nén dữ liệu nhận được sử dụng hàm Z-1;

\+ Tách chữ ký số khỏi thông điệp _M_ và sử dụng khóa công khai của bên gửi PUa để kiểm tra (giải mã) chữ ký số để khôi phục giá trị băm h1. Bên gửi A có thể sử

dụng các phương pháp trao đổi khóa công khai đã nêu ở mục 3.5.3 để chuyển khóa công khai PUa cho bên nhận;

\+ Tính toán giá trị băm h2 của thông điệp _M_ sử dụng hàm băm H;

\+ So sánh 2 giá trị băm h1 và h2, nếu h1 = h2 thì thông điệp truyền là toàn vẹn và thông điệp được gửi bởi bên gửi A. Nếu h1 ≠ h2 thì thông điệp _M_ có thể đã bị sửa đổi, hoặc không được ký và gửi bởi bên gửi A.

|<image_8>|
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Bên gửi</th>
<th>====&gt;</th>
<th>Bên nhận</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

_Hình 3.48. Mô hình PGP chỉ đảm bảo tính bí mật thông điệp_

Hình 3.48 biểu diễn mô hình PGP chỉ đảm bảo tính bí mật thông điệp truyền. Theo đó, mô hình này sử dụng kết hợp giữa mã hóa khóa đối xứng và mã hóa khóa bất đối xứng để đảm bảo tính bí mật của thông điệp. Điều kiện thực hiện mô hình này là bên nhận B phải sở hữu cặp khóa (khóa công khai PUb và khóa riêng PRb). Quá trình thực hiện gửi/nhận thông điệp _M_ đảm bảo tính bí mật tại mỗi bên như sau:

\- Bên gửi A:

\+ Nén thông điệp _M_ sử dụng hàm nén Z;

\+ Sinh khóa phiên Ks và sử dụng khóa Ks để mã hóa thông điệp M sử dụng hàm mã hóa đối xứng EC;

\+ Sử dụng khóa công khai PUb của bên nhận B để mã hóa khóa phiên Ks sử dụng hàm mã hóa bất đối xứng EP. Bên nhận B có thể sử dụng các phương pháp trao đổi khóa công khai đã nêu ở mục 3.5.3 để chuyển khóa công khai PUb cho bên gửi;

\+ Ghép chữ bản mã của Ks vào bản mã của thông điệp _M_ ;

\+ Gửi bản mã dữ liệu cho người nhận.

\- Bên nhận B:

\+ Tách bản mã của Ks vào bản mã của thông điệp _M_ ;

\+ Giải mã bản mã Ks sử dụng hàm giải mã khóa bất đối xứng DP và khóa riêng PRb để khôi phục Ks;

\+ Sử dụng khóa phiên Ks và hàm giải mã khóa đối xứng DC để giải mã khôi phục thông điệp đã nén _M_ ;

\+ Giải nén khôi phục thông điệp _M_ sử dụng hàm Z-1;

|<image_9>|
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Bên gửi</th>
<th>===&gt;</th>
<th>Bên nhận</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

_Hình 3.49. Mô hình PGP đảm bảo tính bí mật và xác thực thông điệp_

Hình 3.49 biểu diễn mô hình PGP đảm bảo tính xác thực và bí mật thông điệp truyền. Theo đó, mô hình này sử dụng chữ ký số để xác thực tính toàn vẹn và chủ thể gửi thông điệp. Đồng thời mô hình sử dụng kết hợp giữa mã hóa khóa đối xứng và mã hóa khóa bất đối xứng để đảm bảo tính bí mật của thông điệp. Điều kiện thực hiện mô hình này là bên gửi A phải sở hữu cặp khóa (khóa công khai PUa và khóa riêng PRa) và bên nhận B phải sở hữu cặp khóa (khóa công khai PUb và khóa riêng PRb). Mô hình này là sự kết hợp của mô hình PGP chỉ đảm bảo tính xác thực và mô hình PGP chỉ đảm bảo tính bí mật. Theo đó, bên gửi A thực hiện ký và mã hóa thông điệp, còn bên nhận B thực hiện giải mã và kiểm tra chữ ký của thông điệp.

# Public_165

# Tường lửa

## Giới thiệu tường lửa

Tường lửa (Firewall) là một trong các kỹ thuật được sử dụng phổ biến nhất để bảo hệ thống và mạng cục bộ tránh các mối đe dọa từ bên ngoài. Tường lửa có thể là một thiết bị phần cứng chuyên dụng, hoặc mô đun phần mềm chạy trên máy tính. Hình 4.12 là hình ảnh một tường lửa phần cứng chuyên dụng của hãng Cisco.
Để đảm bảo hiệu quả bảo vệ, tường lửa phải miễn dịch với các loại tấn công, xâm nhập và thường được đặt ở vị trí cổng vào của mạng nội bộ cơ quan hoặc tổ chức, như minh họa trên Hình 4.13. Nhờ vị trí đặt ở cổng mạng, tất cả các gói tin từ trong ra và từ
ngoài vào đều phải đi qua tường lửa và chỉ các gói tin hợp pháp được phép đi qua tường lửa. Việc xác định một gói tin là hợp pháp hay không được thực hiện bởi thao tác lọc (filtering) dựa trên các luật (rules). Tập các luật sử dụng cho việc lọc các gói tin được tạo ra dựa trên chính sách an ninh của cơ quan, tổ chức.

|<image_1>|

_Hình 4.12. Một tường lửa phần cứng chuyên dụng của Cisco_

|<image_2>|

_Hình 4.13. Tường lửa bảo vệ mạng gia đình hoặc văn phòng nhỏ_

|<image_3>|

_Hình 4.14. Tường lửa bảo vệ các máy chủ dịch vụ_
Hình 4.14 biểu diễn sơ đồ mạng trong đó tường lửa được sử dụng để bảo vệ các máy chủ dịch vụ email Microsoft Exchange. Tất cả các kết nối đến hệ thống máy chủ email đều phải đi qua tường lửa. Hình 4.15 sơ đồ mạng sử dụng 2 tưởng lửa để bảo vệ, trong đó một tường lửa phần cứng (Hardware Firewall) được sử dụng tại cổng kết nối Internet để bảo vệ các máy chủ dịch vụ (dịch vụ web, dịch vụ FTP và dịch vụ DNS) và một tường lửa phần mềm (ISA Firewall) được sử dụng để bảo vệ các máy chủ nội bộ và các máy trạm trong mạng LAN của cơ quan, tổ chức. Hai tường lửa có chính sách kiểm soát truy nhập và tập luật khác nhau phù hợp với đối tượng bảo vệ khác nhau.

## Các loại tường lửa

Có nhiều phương pháp phân loại các tường lửa, chẳng hạn như dựa trên vị trí các lớp giao thức mạng và khả năng lưu trạng thái của các kết nối mạng. Dựa trên vị trí các lớp giao thức mạng, có thể chia tường lửa thành 3 loại: tường lửa lọc gói (Packet-filtering), cổng ứng dụng (Application-level gateway) và cổng chuyển mạch (Circuit-level gateway). Tường lửa lọc gói thường thực hiện việc lọc các gói tin IP, theo đó một tập, hoặc một nhóm các luật được áp dụng cho mỗi gói tin gửi đi, hoặc chuyển đến để quyết định chuyển tiếp các gói tin hợp pháp, hay loại bỏ gói tin bất hợp pháp. Cổng ứng dụng, còn gọi là máy chủ proxy thường được sử dụng để phát lại lưu lượng mạng ở mức ứng dụng. Cổng ứng dụng thực hiện việc lọc các yêu cầu, hoặc hồi đáp (request/response) ở các giao thức ứng dụng phổ biến như HTTP, SMTP, FTP,... Cổng chuyển mạch hoạt động ở mức thấp nhất, với cơ chế tương tự như các bộ chuyển mạch (switch). Hình 4.16 minh họa mô hình tường lửa lọc gói (a), cổng ứng dụng (b) và cổng chuyển mạch (c).

|<image_4>|

_Hình 4.15. Hệ thống tường lửa bảo vệ các máy chủ dịch vụ và máy trạm_
|<image_5>|

|<image_6>||<image_7>|

_Hình 4.16. Mô hình tường lửa lọc gói (a), Cổng ứng dụng (b) và Cổng chuyển mạch (c)_
Dựa trên khả năng lưu trạng thái của các kết nối mạng, tường lửa được chia thành 2 loại: tường lửa có trạng thái (Stateful firewall) và tường lửa không trạng thái (Stateless firewall). Tường lửa có trạng thái có khả năng lưu trạng thái của các kết nối mạng đi qua và được lập trình để phân biệt các gói tin thuộc về các kết nối mạng khác nhau. Theo đó, chỉ những gói tin thuộc một kết nối mạng đang hoạt động mới được đi qua tường lửa, còn các gói tin khác không thuộc kết nối đang hoạt động sẽ bị chặn lại. Hình 4.17 minh hoạt một tường lửa có trạng thái chặn các gói tin IP gửi từ người dùng ngoài (Outside User) đến địa chỉ IP 200.1.1.10 do chúng không thuộc kết nối đang hoạt động. Ngược lại, tường lửa không trạng thái thực hiện việc lọc các gói tin riêng rẽ mà không quan tâm mỗi gói tin thuộc về kết nối mạng nào. Tường lửa dạng này dễ bị tấn công bởi kỹ thuật giả mạo
địa chỉ, giả mạo nội dung gói tin do tường lửa không có khả năng nhớ các gói tin đi trước thuộc cùng một kết nối mạng.

|<image_8>|

_Hình 4.17. Tường lửa có trạng thái chặn gói tin không thuộc kết nối đang hoạt động_

## Các kỹ thuật kiểm soát truy nhập

Hầu hết các tường lửa hỗ trợ nhiều kỹ thuật kiểm soát truy nhập, gồm kiểm soát dịch vụ, kiểm soát hướng, kiểm soát người dùng và kiểm soát hành vi. Cụ thể:

  * Kiểm soát dịch vụ xác định dịch vụ nào có thể được truy nhập và thường được thực hiện thông qua việc mở hoặc đóng một cổng dịch vụ nào đó. Chẳng hạn, để cung cấp dịch vụ web và cấm tất cả các dịch vụ khác, tường lửa mở cổng HTTP 80 và HTTPS 443, còn đóng tất cả các cổng dịch vụ khác.

  * Kiểm soát hướng điều khiển hướng được phép đi của các gói tin của mỗi dịch vụ. Hướng có thể gồm luồng từ mạng nội bộ đi ra (outgoing) và luồng từ ngoài đi vào mạng nội bộ (incoming).

  * Kiểm soát người dùng xác định người dùng nào được quyền truy nhập và thường áp dụng cho người dùng mạng nội bộ.

  * Kiểm soát hành vi thực hiện kiểm soát việc sử dụng các dịch vụ cụ thể. Ví dụ như, tường lửa có thể được cấu hình để lọc loại bỏ các thư rác, hoặc hạn chế truy nhập đến một bộ phận thông tin của máy chủ web.


## Các hạn chế của tường lửa

Mặc dù tường lửa được sử dụng rộng rãi để bảo vệ mạng nội bộ khỏi các cuộc tấn công, xâm nhập, nhưng cũng như hầu hết các kỹ thuật và công cụ đảm bảo an toàn khác, tường lửa cũng có những hạn chế. Các hạn chế của tường lửa gồm:

  * Không thể chống lại các tấn công không đi qua tường lửa. Đó có thể là các dạng tấn công khai thác yếu tố con người, hoặc kẻ tấn công có thể xâm nhập trực tiếp vào hệ thống mạng nội bộ mà không đi qua tường lửa.

  * Không thể chống lại các tấn công hướng dữ liệu, hoặc tấn công vào các lỗ hổng bảo mật của các phần mềm.

  * Không thể chống lại các hiểm hoạ từ bên trong, như từ người dùng trong mạng nội bộ.

  * Không thể ngăn chặn việc vận chuyển các chương trình hoặc các file bị nhiễm vi rút hoặc các phần mềm độc hại (thường ở dạng nén hoặc mã hóa).


# Các hệ thống phát hiện và ngăn chặn xâm nhập

## Giới thiệu

|<image_9>|

_Hình 4.18. Vị trí các hệ thống IDS và IPS trong sơ đồ mạng_

Các hệ thống phát hiện, ngăn chặn tấn công, xâm nhập (IDS/IPS) là một lớp phòng vệ quan trọng trong các lớp giải pháp đảm bảo an toàn cho hệ thống thông tin và mạng theo mô hình phòng thủ có chiều sâu (defence in depth). IDS (Intrusion Detection System) là hệ thống phát hiện tấn công, xâm nhập và IPS (Intrusion Prevention System) là hệ thống ngăn chặn tấn công, xâm nhập. Các hệ thống IDS/IPS có thể được đặt trước hoặc sau tường lửa trong mô hình mạng, tùy theo mục đích sử dụng. Hình 4.18 cung cấp vị trí các hệ thống IDS và IPS trong sơ đồ mạng, trong đó IDS thường được kết nối vào bộ switch phía sau tường lửa, còn IPS được ghép vào giữa đường truyền từ cổng mạng, phía sau tường lửa.
Nhiệm vụ chính của các hệ thống IDS/IPS bao gồm:

  * Giám sát lưu lượng mạng hoặc các hành vi trên một hệ thống để nhận dạng các dấu hiệu của tấn công, xâm nhập;

  * Khi phát hiện các hành vi tấn công, xâm nhập, thì ghi logs các hành vi này cho phân tích bổ sung sau này;

  * Ngăn chặn hoặc dừng các hành vi tấn công, xâm nhập;

  * Gửi thông báo cho người quản trị về các các hành vi tấn công, xâm nhập đã phát hiện được.


Về cơ bản IPS và IDS giống nhau về chức năng giám sát lưu lượng mạng hoặc các sự kiện trong hệ thống. Tuy nhiên, IPS thường được đặt giữa đường truyền thông và có thể chủ động ngăn chặn các tấn công, xâm nhập bị phát hiện. Trong khi đó, IDS thường được kết nối vào các bộ định tuyến, switch, card mạng và chủ yếu làm nhiệm vụ giám sát và cảnh bảo, không có khả năng chủ động ngăn chặn tấn công, xâm nhập.

## Phân loại

Có 2 phương pháp phân loại chính các hệ thống IDS và IPS, gồm (1) phân loại theo nguồn dữ liệu và (2) phân loại theo phương pháp phân tích dữ liệu. Theo nguồn dữ liệu, có 2 loại hệ thống phát hiện xâm nhập:

  * Hệ thống phát hiện xâm nhập mạng (NIDS – Network-based IDS): NIDS phân tích lưu lượng mạng để phát hiện tấn công, xâm nhập cho cả mạng hoặc một phần mạng.


Hình 4.19 biểu diễn một sơ đồ mạng, trong đó các NIDS được bố trí để giám sát phát hiện xâm nhập tại cổng vào và cho từng phân đoạn mạng.

|<image_10>|

_Hình 4.19. Các NIDS được bố trí để giám sát phát hiện xâm nhập tại cổng vào và cho từng phân đoạn mạng_

  * Hệ thống phát hiện xâm nhập cho host (HIDS – Host-based IDS): HIDS phân tích các sự kiện xảy ra trong hệ thống/dịch vụ để phát hiện tấn công, xâm nhập cho hệ thống đó. Hình 4.20 minh họa một sơ đồ mạng, trong đó sử dụng NIDS để giám sát lưu lượng tại cổng mạng và HIDS để giám sát các host thông qua các IDS agent. Một trạm quản lý (Management station) được thiết lập để thu nhập các thông tin từ các NIDS và HIDS để xử lý và đưa ra quyết định cuối cùng.


Theo phương pháp phân tích dữ liệu, có 2 kỹ thuật phân tích chính, gồm (1) phát hiện xâm nhập dựa trên chữ ký, hoặc phát hiện sự lạm dụng (Signature-based / misuse
intrusion detection) và (2) phát hiện xâm nhập dựa trên các bất thường (Anomaly intrusion detection). Mục tiếp theo trình bày chi tiết hơn về hai kỹ thuật phát hiện này.

|<image_11>|

_Hình 4.20. Sử dụng kết hợp NIDS và HIDS để giám sát lưu lượng mạng và các host_

## Các kỹ thuật phát hiện xâm nhập

### Phát hiện xâm nhập dựa trên chữ ký

Phát hiện xâm nhập dựa trên chữ ký trước hết cần xây dựng cơ sở dữ liệu các chữ ký, hoặc các dấu hiệu của các loại tấn công, xâm nhập đã biết. Hầu hết các chữ ký, dấu hiệu được nhận dạng và mã hóa thủ công và dạng biểu diễn thường gặp là các luật phát hiện (Detection rule). Bước tiếp theo là sử dụng cơ sở dữ liệu các chữ ký để giám sát các hành vi của hệ thống, hoặc mạng, và cảnh báo nếu phát hiện chữ ký của tấn công, xâm nhập. Hình 4.21 biểu diễn lưu đồ giám sát phát hiện tấn công, xâm nhập dựa trên chữ ký điển hình.

|<image_12>|

_Hình 4.21. Lưu đồ giám sát phát hiện tấn công, xâm nhập dựa trên chữ ký_
Ưu điểm lớn nhất của phát hiện xâm nhập dựa trên chữ ký là có khả năng phát hiện các tấn công, xâm nhập đã biết một cách hiệu quả. Ngoài ra, phương pháp này cho tốc độ xử lý cao, đồng thời yêu cầu tài nguyên tính toán tương đối thấp. Nhờ vậy, các hệ thống phát hiện xâm nhập dựa trên chữ ký được ứng dụng rộng rãi trong thực tế. Tuy nhiên, nhược điểm chính của phương pháp này là không có khả năng phát hiện các tấn công, xâm nhập mới, do chữ ký của chúng chưa tồn tại trong cơ sở dữ liệu các chữ ký. Hơn nữa, nó cũng đòi hỏi nhiều công sức xây dựng và cập nhật cơ sở dữ liệu chữ ký, dấu hiệu của các tấn công, xâm nhập.

### Phát hiện xâm nhập dựa trên bất thường

Phát hiện xâm nhập dựa trên bất thường dựa trên giả thiết: _các hành vi tấn công, xâm nhập thường có quan hệ chặt chẽ với các hành vi bất thường_. Quá trình xây dựng và triển khai một hệ thống phát hiện xâm nhập dựa trên bất thường gồm 2 giai đoạn: (1) huấn luyện và (2) phát hiện. Trong giai đoạn huấn luyện, hồ sơ (profile) của đối tượng trong chế độ làm việc bình thường được xây dựng. Để thực hiện giai đoạn huấn luyện này, cần giám sát đối tượng trong một khoảng thời gian đủ dài để thu thập được đầy đủ dữ liệu mô tả các hành vi của đối tượng trong điều kiện bình thường làm dữ liệu huấn luyện. Tiếp theo, thực hiện huấn luyện dữ liệu để xây dựng mô hình phát hiện, hay hồ sơ của đối tượng. Trong giai đoạn phát hiện, thực hiện giám sát hành vi hiện tại của hệ thống và cảnh báo nếu có khác biệt rõ nét giữa hành vi hiện tại và các hành vi lưu trong hồ sơ của đối tượng.

|<image_13>|

_Hình 4.22. Giá trị entropy của IP nguồn của các gói tin từ lưu lượng hợp pháp (phần giá trị cao, đều) và entropy của IP nguồn của các gói tin_
_từ lưu lượng tấn công DDoS (phần giá trị thấp)_
Hình 4.22 biểu diễn giá trị entropy của IP nguồn của các gói tin theo cửa sổ trượt từ lưu lượng bình thường và entropy của IP nguồn của các gói tin từ lưu lượng tấn công DDoS. Có thể thấy sự khác biệt rõ nét giữa giá trị entropy của lưu lượng bình thường và lưu lượng tấn công và như vậy, nếu một ngưỡng entropy được chọn phù hợp ta hoàn toàn có thể phát hiện sự xuất hiện của cuộc tấn công DDoS dựa trên sự thay đổi đột biến của giá trị entropy.
Ưu điểm của phát hiện xâm nhập dựa trên bất thường là có tiềm năng phát hiện các loại tấn công, xâm nhập mới mà không yêu cầu biết trước thông tin về chúng. Tuy nhiên, phương pháp này có tỷ lệ cảnh báo sai tương đối cao so với phương pháp phát hiện dựa trên chữ ký. Điều này làm giảm khả năng ứng dụng thực tế của phát hiện xâm nhập dựa trên bất thường. Ngoài ra, nó cũng tiêu tốn nhiều tài nguyên hệ thống cho việc xây dựng hồ sơ đối tượng và phân tích hành vi hiện tại.

# Public_166

# Khái quát về quản lý an toàn thông tin

Chúng ta bắt đầu mục này với khái niệm _Tài sản_ (Asset) trong lĩnh vực an toàn thông tin, gọi tắt là _Tài sản an toàn thông tin_. Tài sản an toàn thông tin là thông tin, thiết bị, hoặc các thành phần khác hỗ trợ các hoạt động có liên quan đến thông tin. Tài sản an toàn thông tin có thể gồm:

  * Phần cứng (máy chủ, các thiết bị mạng,…);

  * Phần mềm (hệ điều hành, các phần mềm máy chủ dịch vụ,…); và

  * Thông tin (thông tin khách hàng, nhà cung cấp, hoạt động kinh doanh,…).


Khái niệm tiếp theo là _Quản lý an toàn thông tin_ (Information security management). Quản lý an toàn thông tin là một tiến trình (process) nhằm đảm bảo các tài sản an toàn thông tin quan trọng của cơ quan, tổ chức, doanh nghiệp được bảo vệ đầy đủ với chi phí phù hợp.

|<image_1>|

_Hình 5.1. Quan hệ giữa các khâu trong quản lý an toàn thông tin_

Quản lý an toàn thông tin là một thành phần rất quan trọng trong an toàn thông tin và nó phải trả lời được 3 câu hỏi:

  1. Những tài sản nào cần được bảo vệ?

  2. Những mối đe dọa nào có thể có đối với các tài sản này?

  3. Những biện pháp có thể thực hiện để ứng phó với các mối đe dọa đó?


Quản lý an toàn thông tin có thể gồm các khâu: (1) xác định rõ mục đích đảm bảo an toàn thông tin và hồ sơ tổng hợp về các rủi ro; (2) đánh giá rủi ro với từng tài sản an toàn thông tin cần bảo vệ; và (3) xác định và triển khai các biện pháp quản lý, kỹ thuật kiểm soát, giảm rủi ro về mức chấp nhận được. Một điểm quan trọng cần lưu ý là, quá trình quản lý an toàn thông tin cần được thực hiện liên tục theo chu trình do sự thay đổi nhanh chóng của công nghệ và môi trường xuất hiện rủi ro.

# Đánh giá rủi ro an toàn thông tin

## Giới thiệu

Đánh giá rủi ro an toàn thông tin (Security risk assessment) là một bộ phận quan trọng của vấn đề quản lý rủi ro an toàn thông tin. Theo đó, mỗi tài sản của tổ chức cần được xem xét, nhận dạng các rủi ro có thể có và đánh giá mức rủi ro. Đánh giá rủi ro là một trong các cơ sở để xác định mức rủi ro chấp nhận được với từng loại tài sản. Trên cơ sở xác định mức rủi ro, có thể đề ra các biện pháp xử lý, kiểm soát rủi ro trong mức chấp nhận được, với mức chi phí phù hợp.

Có 4 phương pháp tiếp cận đánh giá rủi ro: phương pháp đường cơ sở (Baseline approach), phương pháp không chính thức (Informal approach), phương pháp phân tích chi tiết rủi ro (Detailed risk analysis) và phương pháp kết hợp (Combined approach). Tùy theo quy mô của hệ thống thông tin của đơn vị và tài sản an toàn thông tin cần được bảo vệ, đơn vị có thể xem xét lựa chọn phương pháp đánh giá rủi ro cho phù hợp.

|<image_2>|

_Hình 5.2. Mô hình đánh giá rủi ro an toàn thông tin_

## Các phương pháp đánh giá rủi ro

### Phương pháp đánh giá rủi ro đường cơ sở

Phương pháp đánh giá rủi ro đường cơ sở là phương pháp đơn giản nhất. Mục đích của phương pháp này là thực thi các kiểm soát an ninh ở mức cơ bản dựa trên các tài liệu cơ bản, các quy tắc thực hành và các thực tế tốt nhất của ngành đã được áp dụng. Phương pháp đường cơ sở có ưu điểm là không đòi hỏi các chi phí cho các tài nguyên bổ sung sử dụng trong đánh giá rủi ro chính thức và cùng nhóm các biện pháp có thể triển khai trên nhiều hệ thống. Tuy nhiên, nhược điểm của nó là không xem xét kỹ đến các điều kiện nảy sinh các rủi ro ở các hệ thống của các tổ chức khác nhau. Một vấn đề khác của phương pháp này là mức đường cơ sở được xác định chung nên có thể không phù hợp với từng tổ chức cụ thể. Nếu chọn mức quá cao có thể gây tốn kém, nhưng nếu chọn mức quá thấp có thể gây mất an toàn. Nhìn chung, phương pháp đường cơ sở phù hợp với các tổ chức với hệ thống công nghệ thông tin có quy mô nhỏ, có nguồn lực hạn chế.

### Phương pháp không chính thức

Phương pháp không chính thức là phương pháp tiếp cận đánh giá rủi ro tiếp theo.

Phương pháp không chính thức liên quan đến việc thực hiện các nội dung sau:

  * Thực hiện một số dạng phân tích rủi ro hệ thống công nghệ thông tin của tổ chức một cách không chính thức,

  * Sử dụng kiến thức chuyên gia của các nhân viên bên trong tổ chức, hoặc các nhà tư vấn từ bên ngoài, và

  * Không thực hiện đánh giá toàn diện các rủi ro đối với tất cả các tài sản công nghệ thông tin của tổ chức.


Phương pháp này có ưu điểm là không đòi hỏi các nhân viên phân tích rủi ro có các kỹ năng bổ sung, nên có thể thực hiện nhanh với chi phí thấp, và việc có phân tích hệ thống công nghệ thông tin của tổ chức giúp cho việc đánh giá rủi ro, lỗ hổng chính xác hơn và các biện pháp kiểm soát đưa ra cũng phù hợp hơn phương pháp đường cơ sở. Phương pháp không chính thức có các nhược điểm là:

  * Do đánh giá rủi ro không được thực hiện toàn diện nên có thể một rủi ro không được xem xét kỹ, nên có thể để lại nguy cơ cao cho tổ chức, và

  * Kết quả đánh giá dễ phục thuộc vào quan điểm của các cá nhân.


Trên thực tế phương pháp không chính thức phù hợp với các tổ chức với hệ thống công nghệ thông tin có quy mô nhỏ và vừa, có nguồn lực tương đối hạn chế.

### Phương pháp phân tích chi tiết rủi ro

Phương pháp phân tích chi tiết rủi ro là phương pháp đánh giá toàn diện, được thực hiện một cách chính thức và được chia thành nhiều giai đoạn, bao gồm:

  * Nhận dạng các tài sản,

  * Nhận dạng các mối đe dọa và lổ hổng đối với các tài sản này,

  * Xác định xác suất xuất hiện các rủi ro và các hậu quả có thể có nếu rủi ro xảy ra với cơ quan, tổ chức, và

  * Lựa chọn các biện pháp xử lý rủi ro dựa trên kết quả đánh giá rủi ro của các giai đoạn trên.


Ưu điểm của phương pháp này là cho phép xem xét chi tiết các rủi ro đối với hệ thống công nghệ thông tin của tổ chức, và lý giải rõ ràng các chi phí cho các biện pháp kiểm soát rủi do đề xuất. Đồng thời, nó cung cấp thông tin tốt nhất cho việc tiếp tục quản lý vấn đề an ninh của các hệ thống công nghệ thông tin khi chúng được nâng cấp, sửa đổi. Tuy nhiên, phương pháp này có 2 nhược điểm là:

  * Chi phí lớn về thời gian, các nguồn lực và yêu cầu kiến thức chuyên gia có trình độ cao, và

  * Có thể dẫn đến chậm trễ trong việc đưa ra các biện pháp xử lý, kiểm soát rủi ro phù hợp.


Phương pháp phân tích chi tiết rủi ro phù hợp với các tổ chức chính phủ cung cấp các dịch vụ thiết yếu cho người dân và doanh nghiệp, hoặc các tổ chức có hệ thống công

nghệ thông tin quy mô lớn, hoặc các tổ chức cung cấp nền tảng hạ tầng truyền thông cho quốc gia.

### Phương pháp kết hợp

Phương pháp kết hợp là phương pháp tiếp cận đánh giá rủi ro cuối cùng. Phương pháp này kết hợp các thành phần của 3 phương pháp đường cơ sở, không chính thức và phân tích chi tiết, với các mục tiêu là cung cấp mức bảo vệ hợp lý càng nhanh càng tốt và sau đó kiểm tra và điều chỉnh các biện pháp bảo vệ trên các hệ thống chính theo thời gian. Phương pháp kết hợp được thực hiện theo 3 bước:

  * Thực hiện phương pháp đường cơ sở với tất cả các thành phần của hệ thống công nghệ thông tin của tổ chức;

  * Tiếp theo, các thành phần có mức rủi ro cao, hoặc trọng yếu được xem xét đánh giá theo phương pháp không chính thức;

  * Cuối cùng hệ thống được xem xét đánh giá toàn diện rủi ro ở mức chi tiết.


Các ưu điểm của phương pháp kết hợp là việc bắt đầu bằng việc đánh giá rủi ro ở mức cao dễ nhận được sự ủng hộ của cấp quản lý, thuận lợi cho việc lập kế hoạch quản lý an toàn thông tin, đồng thời có thể giúp sớm triển khai các biện pháp xử lý và kiểm soát rủi ro ngay từ giai đoạn đầu, cũng như có thể giúp giảm chi phí với đa số các tổ chức. Tuy nhiên, phương pháp kết hợp có nhược điểm là nếu đánh giá ở mức cao trong giai đoạn đầu không chính xác có thể dẫn đến áp dụng các biện pháp kiểm soát không phù hợp, hệ thống có thể gặp rủi ro trong thời gian chờ đánh giá chi tiết. Nói chung, phương pháp kết hợp phù hợp các tổ chức với hệ thống công nghệ thông tin quy mô vừa và lớn.

# Phân tích chi tiết rủi ro an toàn thông tin

## Giới thiệu

Phân tích chi tiết rủi ro an toàn thông tin là phương pháp xem xét, phân tích toàn diện các rủi ro của từng thành phần trong hệ thống công nghệ thông tin của cơ quan, tổ chức. Phân tích chi tiết rủi ro an toàn thông tin gồm nhiều hoạt động được chia thành 9 bước:

  1. Mô tả đặc điểm hệ thống

  2. Nhận dạng các mối đe dọa

  3. Nhận dạng các lỗ hổng bảo mật

  4. Phân tích các kiểm soát

  5. Xác định xác suất rủi ro

  6. Phân tích các ảnh hưởng

  7. Xác định các rủi ro

  8. Đề xuất các kiểm soát

  9. Viết tài liệu kết quả phân tích.


## Nội dung phân tích chi tiết rủi ro

Nội dung cụ thể từng bước của phân tích chi tiết rủi ro an toàn thông tin như sau.

_Bước 1_ : Mô tả đặc điểm hệ thống

\- Đầu vào: Các thành phần của hệ thống:

\+ Phần cứng, phần mềm, giao diện

\+ Dữ liệu và thông tin

\+ Con người

\+ Sứ mệnh của hệ thống.

\- Đầu ra:

\+ Ranh giới và chức năng hệ thống;

\+ Tính trọng yếu của dữ liệu và hệ thống;

\+ Tính nhạy cảm

_Bước 2_ : Nhận dạng các mối đe dọa

\- Đầu vào:

\+ Lịch sử tấn công vào hệ thống

\+ Dữ liệu từ các tổ chức chuyên về an toàn thông tin

\+ Dữ liệu từ các phương tiện thông tin đại chúng.

  * Đầu ra:


\+ Báo cáo về các mối đe dọa đối với hệ thống

_Bước 3_ : Nhận dạng các lỗ hổng bảo mật

  * Đầu vào:


\+ Các báo cáo đánh giá rủi ro đã có

\+ Các nhận xét kiểm toán hệ thống

\+ Các yêu cầu an ninh, an toàn

\+ Các kết quả kiểm tra an ninh, an toàn

  * Đầu ra:


\+ Danh sách các lỗ hổng bảo mật tiềm tàng.

_Bước 4_ : Phân tích các kiểm soát (control)

  * Đầu vào:


\+ Các kiểm soát hiện có

\+ Các kiểm soát được lập kế hoạch

  * Đầu ra:


\+ Danh sách các kiểm soát hiện có và được lập kế hoạch.

_Bước 5_ : Xác định xác suất rủi ro

  * Đầu vào:


\+ Động cơ của các nguồn đe dọa

\+ Khả năng của đe dọa

\+ Bản chất của lỗ hổng bảo mật

\+ Các kiểm soát hiện có

  * Đầu ra:


\+ Đánh giá xác suất rủi ro.

_Bước 6_ : Phân tích các ảnh hưởng (liên quan sự vi phạm tính toàn vẹn, sẵn dùng và bí mật của các tài sản hệ thống)

  * Đầu vào:


\+ Phân tích ảnh hưởng sứ mệnh

\+ Đánh giá tầm quan trọng của tài sản

\+ Tầm quan trọng của dữ liệu

\+ Tính nhạy cảm của dữ liệu

  * Đầu ra:


\+ Đánh giá các ảnh hưởng.

_Bước 7_ : Xác định các rủi ro

  * Đầu vào:


\+ Khả năng bị mối đe dọa khai thác

\+ Tầm quan trọng của ảnh hưởng

\+ Sự phù hợp của các kiểm soát theo kế hoạch, hoặc hiện có

  * Đầu ra:


\+ Các rủi ro và các mức rủi ro có liên quan.

_Bước 8_ : Đề xuất các kiểm soát

  * Đầu vào: Không

  * Đầu ra: Đề xuất các biện pháp xử lý, kiểm soát rủi ro


_Bước 9_ : Viết tài liệu kết quả phân tích

  * Đầu vào: Không

  * Đầu ra: Báo cáo đánh giá rủi ro.


# Thực thi quản lý an toàn thông tin

## Giới thiệu

Thực thi quản lý an toàn thông tin là bước tiếp theo của khâu đánh giá rủi ro, nhằm triển khai, thực thi các kiểm soát (control) nhằm đảm bảo an toàn thông tin cho hệ thống công nghệ thông tin của tổ chức. Các nội dung chính của thực thi quản lý an toàn thông tin gồm:

  * Thực thi (Implementation): Thực thi các kiểm soát, và nâng cao ý thức và đào tạo an toàn thông tin.

  * Thực thi tiếp tục (Implementation follow-up): Bảo trì, kiểm tra hợp chuẩn, quản lý thay đổi và xử lý sự cố.


Kiểm soát (control), đảm bảo an toàn (safeguard), hoặc biện pháp đối phó (countermeasure) là các thuật ngữ có thể được sử dụng tương đương, hoặc tráo đổi cho nhau trong quản lý an toàn thông tin. Kiểm soát là phương tiện để quản lý rủi ro, bao

gồm các chính sách, thủ tục, các hướng dẫn, các thực tế, hoặc cấu trúc tổ chức. Kiểm soát có thể là vấn đề quản lý hành chính hoặc kỹ thuật, hoặc có bản chất luật pháp.

Các kiểm soát được thực thi trong quản lý an toàn thông tin có thể gồm 6 loại:

  * Kiểm soát quản lý (Management controls)

  * Kiểm soát vận hành (Operational controls)

  * Kiểm soát kỹ thuật (Technical controls)

  * Kiểm soát hỗ trợ (Supportive controls)

  * Kiểm soát ngăn ngừa (Preventive controls)

  * Kiểm soát phát hiện và phục hồi (Detection and recovery controls).


## Các loại kiểm soát

_Kiểm soát quản lý bao gồm các nội dung:_

  * Tập trung vào các chính sách, lập kế hoạch, hướng dẫn và chuẩn an toàn thông tin;

  * Các kiểm soát có ảnh hưởng đến việc lựa chọn các kiểm soát vận hành và kiểm soát kỹ thuật nhằm giảm tổn thất do rủi ro và bảo vệ sứ mệnh của tổ chức;

  * Các kiểm soát tham chiếu đến các vấn đề được giải quyết thông qua lĩnh vực quản lý.


_Kiểm soát vận hành bao gồm các nội dung:_

  * Giải quyết vấn đề thực thi chính xác và sử dụng các chính sách và chuẩn an toàn thông tin, đảm bảo tính nhất quán trong vận hành an toàn thông tin và khắc phục các khiếm khuyết vận hành đã được nhận dạng;

  * Các kiểm soát này liên quan đến các cơ chế và thủ tục được thực thi chủ yếu bởi con người, hơn là bởi hệ thống;

  * Được sử dụng để tăng cường an ninh cho một hệ thống hoặc một nhóm các hệ thống.


_Kiểm soát kỹ thuật bao gồm các nội dung:_

  * Liên quan đến việc sử dụng đúng đắn các biện pháp đảm bảo an ninh bằng phần cứng và phần mềm trong hệ thống;

  * Bao gồm các biện pháp từ đơn giản đến phức tạp để đảm bảo an toàn cho các thông tin nhạy cảm và các chức năng trọng yếu của các hệ thống;

  * Một số kiểm soát kỹ thuật: xác thực, trao quyền và thực thi kiểm soát truy nhập,...


_Kiểm soát hỗ trợ_ là các kiểm soát chung ở lớp dưới, có quan hệ với và được sử dụng bởi nhiều kiểm soát khác.

_Kiểm soát ngăn ngừa_ là kiểm soát tập trung vào việc ngăn ngừa việc xảy ra các vi phạm an ninh, bằng cách khắc chế các nỗ lực vi phạm chính sách an ninh hoặc khai thác các lỗ hổng bảo mật.

_Kiểm soát phát hiện và phục hồi_ là kiểm soát tập trung vào việc đáp trả vi phạm an ninh bằng cách đưa ra cảnh báo vi phạm, hoặc các nỗ lực vi phạm chính sách an ninh,

hoặc khai thác các lỗ hổng bảo mật, đồng thời cung cấp các biện pháp phục hồi các tài nguyên tính toán bị ảnh hưởng do vi phạm an ninh.

## Xây dựng kế hoạch đảm bảo an toàn

Kế hoạch đảm bảo an toàn (Security plan) là một tài liệu chỉ rõ các phần việc sẽ được thực hiện, các tài nguyên cần sử dụng và những người, hoặc nhân viên chịu trách nhiệm thực hiện. Mục đích của Kế hoạch đảm bảo an toàn là cung cấp chi tiết về các hành động cần thiết để cải thiện các vấn đề đã được nhận dạng trong hồ sơ đánh giá rủi ro một cách nhanh chóng. Kế hoạch đảm bảo an toàn nên gồm các thông tin chi tiết sau (theo chuẩn hướng dẫn quản lý rủi ro năm 2002 của NIST):

  * Các rủi ro (sự kế hợp của tài sản/mối đe dọa/lỗ hổng)

  * Các kiểm soát được khuyến nghị (từ đánh giá rủi ro)

  * Các hành động ưu tiên cho mỗi rủi ro

  * Các kiểm soát được chọn (dựa trên phân tích lợi ích – chi phí)

  * Các tài nguyên cần có cho thực thi các kiểm soát đã chọn

  * Nhân sự chịu trách nhiệm

  * Ngày bắt đầu và kết thúc việc thực thi

  * Các yêu cầu bảo trì và các nhận xét khác.


## Nội dung thực thi quản lý an toàn thông tin

Như đã đề cập trong mục 5.1.4.1, việc thực thi quản lý an toàn thông tin gồm 2 khâu là (1) _thực thi_ (Implementation) và (2) _thực thi tiếp tục_ (Implementation follow-up). Khâu _thực thi_ gồm 2 phần việc là thực thi các kiểm soát, và nâng cao ý thức và đào tạo an toàn thông tin. Thực thi các kiểm soát là phần việc tiếp theo cần thực hiện trong kế hoạch đảm bảo an toàn của tiến trình quản lý an toàn thông tin. Thực thi các kiểm soát có liên hệ mật thiết với việc đào tạo nâng cao ý thức an toàn thông tin cho nhân viên nói chung và đào tạo chuyên sâu về an toàn thông tin cho nhân viên an toàn thông tin trong tổ chức.

Khâu _thực thi tiếp tục_ là việc cần lặp lại trong chu trình quản lý an toàn thông tin để đáp ứng sự thay đổi trong môi trường công nghệ thông tin và môi trường rủi ro. Trong đó, các kiểm soát đã được thực thi cần được giám sát để đảm bảo tính hiệu quả, và bất kỳ một sự thay đổi trên hệ thống cần được xem xét vấn đề an ninh và hồ sơ rủi ro của hệ thống bị ảnh hưởng cần được xem xét nếu cần thiết. Giai đoạn thực thi tiếp tục bao gồm các khía cạnh: bảo trì các kiểm soát an ninh, kiểm tra hợp chuẩn an ninh, quản lý thay đổi và cấu hình và xử lý các sự cố.

_Bảo trì các kiểm soát an ninh_ gồm các phần việc phải đảm bảo các yêu cầu sau:

  * Các kiểm soát được xem xét định kỳ để đảm bảo chúng hoạt động như mong muốn;

  * Các kiểm soát cần được nâng cấp khi các yêu cầu mới được pháp hiện;

  * Các thay đổi với hệ thống không được có các ảnh hưởng tiêu cực đến các kiểm soát;

  * Các mối đe dọa mới hoặc các lỗ hổng đã không trở thành được biết đến.


_Kiểm tra hợp chuẩn an ninh_ là quá trình kiểm toán việc quản lý an toàn thông tin của tổ chức nhằm đảm bảo tính phù hợp với kế hoạch đảm bảo an ninh. Việc kiểm toán có thể được thực hiện bởi nhân sự bên trong hoặc bên ngoài tổ chức. Cần sử dụng danh sách kiểm tra (checklist) các vấn đề: các chính sách và kế hoạch an ninh được tạo ra, các kiểm soát phù hợp được lựa chọn và các kiểm soát được sử dụng và bảo trì phù hợp.

_Quản lý thay đổi và cấu hình_ là tiến trình được sử dụng để xem xét các thay đổi được đề xuất cho hệ thống trong quá trình sử dụng. Các thay đổi với các hệ thống hiện có là cần thiết do nhiều lý do, như hệ thống có trục trặc, hoặc sự xuất hiện của các mối đe dọa hoặc lỗ hổng mới, sự xuất hiện của yêu cầu mới, nhiệm vụ mới,… Các thay đổi cần được xem xét kỹ lưỡng cả vấn đề vận hành, tính năng và vấn đề an toàn,… Quản lý cấu hình liên quan đến việc lưu vết các cấu hình của mỗi hệ thống khi chúng được nâng cấp, thay đổi. Việc này bao gồm danh sách các phiên bản của phần cứng, phần mềm cài đặt trong mỗi hệ thống, và thông tin quản lý cấu hình hữu ích để khôi phục hệ thống khi việc thay đổi hoặc nâng cấp thất bại.

_Xử lý các sự cố_ bao gồm các thủ tục được sử dụng để phản ứng lại các sự cố an ninh. Xử lý sự cố có liên quan đến vấn đề đào tạo nâng cao ý thức an toàn thông tin cho người dùng và đào tạo chuyên sâu cho chuyên viên an toàn thông tin.

# Public_167

# Các chuẩn quản lý an toàn thông tin

## Giới thiệu

Trong các chuẩn quản lý an toàn thông tin, bộ chuẩn NIST SP 800 của Viện tiêu chuẩn và công nghệ Mỹ và bộ chuẩn quốc tế ISO/IEC 27000 được tham chiếu và sử dụng rộng rãi nhất. Nhiều quốc gia, trong đó có Việt Nam đã dịch và chấp thuận nguyên vẹn một số chuẩn trong bộ chuẩn quốc tế ISO/IEC 27000 làm chuẩn quản lý an toàn thông tin quốc gia. Trong phạm vi của môn học, mục này giới thiệu khái quát về bộ chuẩn quản lý an toàn thông tin ISO/IEC 27000. Chi tiết về bộ chuẩn ISO/IEC 27000 và các bộ chuẩn khác được đề cập trong môn học Quản lý an toàn thông tin.
Chuẩn ISO/IEC 27000: 2009 giới thiệu khái quát về bộ chuẩn ISO/IEC 27000 và định nghĩa các thuật ngữ và từ vựng sử dụng cho toàn bộ các chuẩn con trong bộ chuẩn ISO/IEC 27000.
Chuẩn ISO/IEC 17799 được soạn thảo năm 2000 bởi International Organization for Standardization (ISO) và International Electrotechnical Commission (IEC) là tiền thân của ISO 27000. Năm 2005, ISO 17799 được chỉnh sửa và trở thành ISO 17799:2005. Năm 2007, ISO 17799:2005 được đổi tên thành ISO 27002 song hành với ISO 27001.
Chuẩn ISO/IEC 27001:2005 chuyên về hệ thống quản lý an toàn thông tin (Information Security Management System - ISMS). Chuẩn này cung cấp các thông tin để thực thi các yêu cầu của ISO/IEC 27002 và cài đặt một hệ thống quản lý an toàn thông tin. Trong việc xây dựng hệ thống ISMS, chuẩn cung cấp các chi tiết cho thực hiện chu kỳ Lập kế hoạch – Thực hiện – Giám sát – Hành động (Plan-Do-Check-Act). Một điểm cần lưu ý là ISO/IEC 27001 chỉ tập trung vào các phần việc phải thực hiện mà không chỉ dẫn cách thức thực hiện.
Chuẩn ISO/IEC 27002 gồm 127 điều, cung cấp cái nhìn tổng quan về nhiều lĩnh vực trong an toàn thông tin. Nó đề ra các khuyến nghị về quản lý an toàn thông tin cho những người thực hiện việc khởi tạo, thực hiện và duy trì an ninh an toàn trong tổ chức của họ. Chuẩn này được thiết kế để cung cấp nền tảng cơ sở giúp đề ra các chuẩn an toàn thông tin cho tổ chức và các thực tế quản lý an toàn thông tin một cách hiệu quả.
Chuẩn ISO/IEC 27005: 2009 chuyên về quản lý rủi ro cho hệ thống quản lý an toàn thông tin. Chuẩn này hỗ trợ ISO/IEC 27001, nhưng nó không đề cập đến phương pháp kiểm soát rủi ro cụ thể.

## Chu trình Plan-Do-Check-Act

|<image_1>|

_Hình 5.3. Chu trình Plan-Do-Check-Act của ISO/IEC 27001:2005_
Chuẩn ISO/IEC 27001:2005 chuyên về hệ thống quản lý an toàn thông tin cung cấp các chi tiết cho thực hiện chu kỳ Plan-Do-Check-Act gồm 4 pha: Plan - Lập kế hoạch, Do – Thực hiện kế hoạch, Check – Giám sát việc thực hiện và Act – Thực hiện các cải tiến, hiệu chỉnh. Phần tiếp theo là nội dung chi tiết của các pha này.
Pha _**Plan**_ gồm các nội dung:

  * Đề ra phạm vi của ISMS;

  * Đề ra chính sách của ISMS;

  * Đề ra hướng tiếp cận đánh giá rủi ro;

  * Nhận dạng các rủi ro;

  * Đánh giá rủi ro;

  * Nhận dạng và đánh giá các lựa chọn phương pháp xử lý rủi ro;

  * Lựa chọn các mục tiêu kiểm soát và biện pháp kiểm soát;

  * Chuẩn bị tuyến bố, báo cáo áp dụng.


Pha Do gồm các nội dung:

  * Xây dựng kế hoạch xử lý rủi ro;

  * Thực thi kế hoạch xử lý rủi ro;

  * Thực thi các kiểm soát;

  * Thực thi các chương trình đào tạo chuyên môn và giáo dục ý thức;

  * Quản lý các hoạt động;

  * Quản lý các tài nguyên;

  * Thực thi các thủ tục phát hiện và phản ứng lại các sự cố an ninh.


Pha _**Check**_ gồm các nội dung:

  * Thực thi các thủ tục giám sát;

  * Thực thi việc đánh giá thường xuyên tính hiệu quả của ISMS;

  * Thực hiện việc kiểm toán (audits) nội bộ với ISMS;

  * Thực thi việc đánh giá thường xuyên với ISMS bởi bộ phận quản lý;

  * Ghi lại các hành động và sự kiện ảnh hưởng đến ISMS.


Pha _**Act**_ gồm các nội dung:

  * Thực hiện các cải tiến đã được nhận dạng;

  * Thực hiện các hành động sửa chữa và ngăn chặn;

  * Áp dụng các bài đã được học;

  * Thảo luận kết quả với các bên quan tâm;

  * Đảm bảo các cải tiến đạt được các mục tiêu.


# Pháp luật và chính sách an toàn thông tin

## Giới thiệu về pháp luật và chính sách an toàn thông tin

Các chính sách và pháp luật an toàn thông tin có vai trò rất quan trọng trong việc đảm bảo an toàn cho thông tin, hệ thống và mạng. Trong đó, vai trò của nhân viên đảm bảo an toàn thông tin là rất quan trọng trong việc giảm thiểu rủi ro, đảm bảo an toàn cho thông tin, hệ thống và mạng và giảm thiệt hại nếu xảy ra sự cố. Các nhân viên đảm bảo an toàn cho thông tin phải hiểu rõ những khía cạnh pháp lý và đạo đức an toàn thông tin. Theo đó, họ phải luôn nắm vững môi trường pháp lý hiện tại (các luật và các quy định luật pháp) và luôn thực hiện công việc nằm trong khuôn khổ cho phép của luật pháp. Ngoài ra, cần thực hiện việc giáo dục ý thức về luật pháp và đạo đức an toàn thông tin cho cán bộ quản lý và nhân viên trong tổ chức, đảm bảo sử dụng đúng mục đích các công nghệ đảm bảo an toàn thông tin.
Chính sách (Policy - còn gọi là quy định, nội quy) là các quy định về các hành vi chấp nhận được của các nhân viên trong tổ chức tại nơi làm việc. Chính sách là các "luật" của tổ chức có giá trị thực thi trong nội bộ, gồm một tập các quy định và các chế tài xử phạt bắt buộc phải thực hiện. Các chính sách, hoặc nội quy cần được nghiên cứu, soạn thảo kỹ lưỡng. Đồng thời, chính sách cần đầy đủ, đúng đắn và áp dụng công bằng với mọi nhân viên. Điểm khác biệt giữa luật và chính sách là Luật luôn bắt buộc, còn với Chính sách, việc thiếu hiểu biết chính sách là 1 cách bào chữa chấp nhận được.
Cần có phân biệt rõ ràng giữa _luật_ (Law) và _đạo đức_ (Ethic). Luật gồm những điều khoản bắt buộc hoặc cấm những hành vi cụ thể. Các điều luật thường được xây dựng từ các vấn đề đạo đức. Trong khi đó, đạo đức định nghĩa những hành vi xã hội chấp nhận được. Đạo đức thường dựa trên các đặc điểm văn hóa. Do đó, hành vi đạo đức giữa các dân tộc, các nhóm người khác nhau là khác nhau. Một số hành vi vi phạm đạo đức được luật hóa trên toàn thế giới, như trộm, cướp, cưỡng dâm, bạo hành trẻ em,... Khác biệt giữa luật và đạo đức thể hiện ở chỗ luật được thực thi bởi các cơ quan chính quyền, còn đạo đức không được thực thi bởi các cơ quan chính quyền.
|<image_2>|
_Hình 5.4. Vấn đề tuân thủ (Compliance) pháp luật, chính sách và các nội quy, quy định_
Để các chính sách có thể được áp dụng hiệu quả, chúng phải đạt được các yêu cầu sau:

  * Có khả năng phổ biến rộng rãi, bằng tài liệu giấy hoặc điện tử;

  * Nhân viên có thể xem, hiểu được – cần thực hiện trên nhiều ngôn ngữ, ví dụ bằng tiếng Anh và tiếng địa phương;

  * Chính sách cần rõ ràng dễ hiểu – tổ chức cần có các điều tra/khảo sát về mức độ hiểu biết/nắm bắt các chính sách của nhân viên;

  * Cần có biện pháp để nhân viên cam kết thực hiện – thông qua ký văn bản cam kết hoặc tick vào ô xác nhận tuân thủ;

  * Chính sách cần được thực hiện đồng đều, bình đẳng, nhất quán, không có ưu tiên với bất kỳ nhân viên nào, kể cả người quản lý.


## Luật quốc tế về an toàn thông tin

Mục này đề cập đến một số luật và văn bản có liên quan đến an toàn thông tin của Mỹ và Châu Âu – là những nước và khu vực đã phát triển và có hệ thống luật pháp về an toàn thông tin tương đối hoàn thiện.
Có thể nói hệ thống luật pháp về an toàn thông tin của nước Mỹ khá đầy đủ và được chia thành các nhóm: các luật tội phạm máy tính, các luật về sự riêng tư, luật xuất khẩu và chống gián điệp, luật bản quyền và luật tự do thông tin. Các luật về tội phạm máy tính gồm:

  * Computer Fraud and Abuse Act of 1986 (CFA Act): quy định về các tội phạm lừa đảo và lạm dụng máy tính;

  * Computer Security Act, 1987: đề ra các nguyên tắc đảm bảo an toàn cho hệ thống máy tính;

  * National Information Infrastructure Protection Act of 1996: là bản sửa đổi của CFA Act, tăng khung hình phạt một số tội phạm máy tính đến 20 năm tù;

  * USA PATRIOT Act, 2001: cho phép các cơ quan nhà nước một số quyền theo dõi, giám sát các hoạt động trên mạng nhằm phòng chống khủng bố hiệu quả hơn;

  * USA PATRIOT Improvement and Reauthorization Act: Mở rộng của USA PATRIOT Act, 2001, cấp cho các cơ quan nhà nước nhiều quyền hạn hơn cho nhiệm vụ phòng chống khủng bố.


Các luật về sự riêng tư nhằm bảo vệ quyền riêng tư của người dùng, bảo vệ các thông tin cá nhân của người dùng, gồm:

  * Federal Privacy Act, 1974: luật Liên bang Mỹ bảo vệ quyền riêng tư của người dùng;

  * Electronic Communications Privacy Act , 1986: luật bảo vệ quyền riêng tư trong các giao tiếp điện tử;

  * Health Insurance Portability and Accountability Act, 1996 (HIPAA): bảo vệ tính bí mật và an toàn của các dữ liệu y tế của người bệnh. Tổ chức, hoặc cá nhân vi phạm có thể bị phạt đến 250.000 USD hoặc 10 năm tù;

  * Financial Services Modernization Act or Gramm-Leach-Bliley Act, 1999: điều chỉnh các hoạt động liên quan đến nhà nước của các ngân hàng, bảo hiểm và các hãng an ninh.


Luật xuất khẩu và chống gián điệp hạn chế việc xuất khẩu các công nghệ và hệ thống xử lý thông tin và phòng chống gián điệp kinh tế, gồm:

  * Economic Espionage Act, 1996: phòng chống việc thực hiện giao dịch có liên quan đến bí mật kinh tế và công nghệ;

  * Security and Freedom through Encryption Act, 1999: quy định về các vấn đề có liên quan đến sử dụng mã hóa trong đảm bảo an toàn và tự do thông tin.


U.S. Copyright Law là Luật bản quyền của Mỹ, điều chỉnh các vấn đề có liên quan đến xuất bản, quyền tác giả của các tài liệu, phần mềm, bao gồm cả các tài liệu số. Freedom of Information Act, 1966 (FOIA) là Luật tự do thông tin nêu rõ các cá nhân được truy nhập các thông tin không gây tổn hại đến an ninh quốc gia.
Các tổ chức và luật quốc tế có liên quan đến an toàn thông tin, gồm:

  * Hội đồng Châu Âu về chống tội phạm mạng (Council of Europe Convention on Cybercrime);

  * Hiệp ước về chống tội phạm mạng được Hội đồng châu Âu phê chuẩn vào năm 2001;

  * Hiệp ước bảo vệ quyền sở hữu trí tuệ (Agreement on Trade-Related Aspects of Intellectual Property Rights (TRIPS)): do Tổ chức Thương mại thế giới WTO chủ trì đàm phán trong giai đoạn 1986–1994;

  * Digital Millennium Copyright Act (DMCA): Luật bản quyền số Thiên niên kỷ.


## Luật Việt Nam về an toàn thông tin

Luật an toàn thông tin mạng được Quốc hội thông qua vào tháng 11 năm 2015 và chính thức có hiệu lực từ ngày 1/7/2016. Đây là cơ sở pháp lý quan trọng cho việc quản lý các hoạt động liên quan đến an toàn thông tin ở Việt Nam. Ngoài Luật an toàn thông
tin mạng, đã có nhiều văn bản có liên quan đến công nghệ thông tin và an toàn thông tin được Quốc Hội, Chính Phủ và các cơ quan nhà nước ban hành như:

  * Luật công nghệ thông tin số 67/2006/QH11 của Quốc hội, ngày 12/07/2006.

  * Nghị định số 90/2008/NÐ-CP của Chính Phủ "Về chống thư rác", ngày 13/08/2008.

  * Quyết định số 59/2008/QÐ-BTTTT của Bộ Thông tin và Truyền thông "Ban hành Danh mục tiêu chuẩn bắt buộc áp dụng về chữ ký số và dịch vụ chứng thực chữ ký số", ngày 31/12/2008.

  * Quyết định 63/QÐ-TTg của Thủ tướng CP "Phê duyệt Quy hoạch phát triển an toàn thông tin số quốc gia đến năm 2020", ngày 13/01/2010.

  * Chỉ thị số 897/CT-TTg của Thủ tướng CP "V/v tăng cường triển khai các hoạt động đảm bảo an toàn thông tin số", 10/06/2011.

  * Thông tư số 23/2011/TT-BTTTT của Bộ TT&TT "Quy định về việc quản lý, vận hành, sử dụng và bảo đảm an toàn thông tin trên Mạng truyền số liệu chuyên dùng của các cơ quan Đảng, Nhà nước", ngày 11/08/2011.

  * Nghị định số 77/2012/NĐ-CP của Chính Phủ "Sửa đổi, bổ sung một số điều của Nghị định số 90/2008/NĐ-CP ngày 13 tháng 8 năm 2008 của Chính phủ về chống thư rác", ngày 05/10/2012.

  * Nghị định 72/2013/NĐ-CP của Chính Phủ về Quản lý, cung cấp, sử dụng dịch vụ internet và thông tin trên mạng; quy định về việc chia sẻ thông tin trên các trang mạng xã hội.


Ngoài ra, Dự thảo Luật an ninh mạng đã được Bộ Công An soạn thảo, lấy ý kiến các chuyên gia và đưa ra Quốc Hội xem xét thông qua vào cuối năm 2017.

# Public_168

# Giới thiệu tổng quan về Tableau

Trong kỷ nguyên số như hiện nay, dữ liệu được ví như “vàng” của chính doanh nghiệp. Tuy nhiên, để khai thác được giá trị tiềm ẩn đó, chúng ta cần công cụ Tableau mạnh mẽ để chuyển hóa những con số khô khan thành những hiểu biết trực quan và hành động thiết thực. Vậy, [**Tableau là gì** ](https://hvn.vn/tableau-la-gi/)và tại sao nó lại trở nên quan trọng đến vậy? Trước khi tìm hiểu về hướng dẫn sử dụng Tableau hãy cùng khám phá tổng quan về công cụ đầy tiềm năng này.

# Tableau là gì?

**Tableau là một phần mềm Business Intelligence (BI) mạnh mẽ, tập trung vào khả năng trực quan hóa dữ liệu. Thay vì chỉ hiển thị dữ liệu dưới dạng bảng và số liệu nhàm chán, Tableau cho phép người dùng tạo ra các biểu đồ, đồ thị, dashboard tương tác và báo cáo trực quan sinh động.**

|<image_1>|

Mục tiêu chính của Tableau là giúp mọi người, từ các nhà phân tích chuyên nghiệp đến người dùng kinh doanh thông thường, có thể dễ dàng kết nối, khám phá và hiểu dữ liệu của họ một cách trực quan nhất. Với giao diện kéo thả (drag-and-drop) thân thiện, Tableau giúp đơn giản hóa quá trình phân tích phức tạp, cho phép người dùng tập trung vào việc rút ra insight thay vì loay hoay với các dòng lệnh hay công thức phức tạp.

# Các thành phần có trong Tableau

Hệ sinh thái Tableau bao gồm nhiều thành phần khác nhau, được thiết kế để phục vụ các nhu cầu phân tích và chia sẻ dữ liệu đa dạng:

## Tableau Desktop: Ứng dụng cốt lõi, được cài đặt trên máy tính cá nhân, cho phép người dùng kết nối với nhiều nguồn dữ liệu, xây dựng biểu đồ, phân tích và tạo dashboard. Tableau Desktop có hai phiên bản chính:

### Tableau Desktop Personal: Phù hợp cho cá nhân, có giới hạn về khả năng chia sẻ.

### Tableau Desktop Professional: Dành cho doanh nghiệp và nhóm làm việc, hỗ trợ đầy đủ các tính năng chia sẻ và cộng tác.

## Tableau Public: Phiên bản miễn phí của Tableau Desktop, cho phép người dùng tạo và chia sẻ các trực quan hóa dữ liệu lên nền tảng đám mây công khai của Tableau. Dữ liệu được tải lên Tableau Public là công khai và có thể được xem bởi bất kỳ ai.

## Tableau Server: Nền tảng phần mềm cho phép các tổ chức chia sẻ, cộng tác và quản lý các workbook và nguồn dữ liệu Tableau một cách an toàn trong môi trường nội bộ.

## Tableau Online: Phiên bản SaaS (Software as a Service) của Tableau Server, được Tableau quản lý hoàn toàn trên đám mây.

## Tableau Prep: Công cụ được thiết kế để chuẩn bị và làm sạch dữ liệu trước khi phân tích trong Tableau Desktop. Tableau Prep giúp người dùng dễ dàng thực hiện các tác vụ như kết hợp dữ liệu, định hình lại cấu trúc, lọc và làm sạch dữ liệu một cách trực quan.

## Tableau Reader: Ứng dụng miễn phí cho phép người dùng xem và tương tác với các workbook Tableau đã được chia sẻ, nhưng không thể chỉnh sửa hoặc tạo mới.

# Cách thức hoạt động đặc biệt của Tableau

Hướng dẫn sử dụng Tableau được xây dựng dựa trên quy trình làm việc cơ bản của thường bao gồm các bước sau:

## Kết nối dữ liệu: Tableau có khả năng kết nối với rất nhiều nguồn dữ liệu khác nhau, từ các tệp tin (Excel, CSV, Text), cơ sở dữ liệu (SQL Server, PostgreSQL, MySQL,…), dịch vụ đám mây (Google Sheets, Salesforce,…) đến các nền tảng Big Data.

## Chuẩn bị dữ liệu (tùy chọn): Sử dụng Tableau Prep hoặc các công cụ khác để làm sạch, định hình và kết hợp dữ liệu nếu cần thiết.

## Xây dựng trực quan hóa: Trong Tableau Desktop, người dùng sử dụng giao diện kéo thả để chọn các trường dữ liệu (Dimensions và Measures) và tạo ra các biểu đồ, đồ thị phù hợp để khám phá các mối quan hệ và xu hướng trong dữ liệu.

## Phân tích và khám phá: Tương tác với các biểu đồ, sử dụng bộ lọc, sắp xếp, nhóm và các công cụ phân tích khác để đi sâu vào dữ liệu và tìm ra những insight quan trọng.

## Tạo Dashboard: Tập hợp nhiều biểu đồ và các đối tượng trực quan khác trên một trang duy nhất để tạo ra một cái nhìn tổng quan về dữ liệu và kể một câu chuyện mạch lạc.

## Chia sẻ và cộng tác: Xuất bản workbook lên Tableau Public, Tableau Server hoặc Tableau Online để chia sẻ kết quả phân tích và cộng tác với đồng nghiệp hoặc khách hàng.

# Ưu và nhược điểm của Tableau

|<image_2>|

Giống như bất kỳ công cụ nào, Tableau cũng có những ưu và nhược điểm riêng:

## Ưu điểm:

  * **Trực quan hóa mạnh mẽ:** Khả năng tạo ra các biểu đồ và dashboard tương tác trực quan, dễ hiểu và hấp dẫn.

  * **Dễ sử dụng:** Giao diện kéo thả thân thiện, không đòi hỏi kiến thức lập trình chuyên sâu.

  * **Kết nối đa dạng nguồn dữ liệu:** Hỗ trợ kết nối với nhiều loại nguồn dữ liệu khác nhau.

  * **Tốc độ phân tích nhanh:** Khả năng xử lý và trực quan hóa lượng lớn dữ liệu một cách nhanh chóng.

  * **Cộng đồng hỗ trợ lớn:** Cộng đồng người dùng Tableau rộng lớn, cung cấp nhiều tài liệu, diễn đàn và hỗ trợ.

  * **Khả năng tùy biến cao:** Cho phép người dùng tùy chỉnh sâu sắc các biểu đồ và dashboard.


## Nhược điểm:

  * **Chi phí:** Chi phí bản quyền của Tableau Desktop và Server/Online có thể khá cao đối với cá nhân hoặc doanh nghiệp nhỏ.

  * **Hiệu suất với dữ liệu cực lớn:** Với những bộ dữ liệu cực kỳ lớn và phức tạp, hiệu suất có thể bị ảnh hưởng nếu không được tối ưu hóa đúng cách.

  * **Hạn chế tùy chỉnh nâng cao:** Mặc dù có khả năng tùy biến cao, nhưng đối với một số yêu cầu trực quan hóa đặc biệt phức tạp, có thể cần đến các công cụ hoặc kỹ thuật khác.

  * **Đường cong học tập cho các tính năng nâng cao:** Mặc dù giao diện cơ bản dễ sử dụng, nhưng để khai thác hết các tính năng nâng cao như tính toán phức tạp, tham số, hành động,… người dùng cần thời gian học tập và thực hành.


# Lợi ích khi sử dụng Tableau

Khi người dùng tìm hiểu về hướng dẫn sử dụng Tableau có thể ứng dụng vào quy trình làm việc mang lại nhiều lợi ích đáng kể:

  * **Hiểu dữ liệu sâu sắc hơn:** Trực quan hóa giúp phát hiện các xu hướng, mối quan hệ và điểm bất thường trong dữ liệu mà các bảng số liệu khó thể hiện được.

  * **Ra quyết định nhanh chóng và chính xác hơn:** Các dashboard trực quan cung cấp cái nhìn tổng quan về tình hình kinh doanh, giúp nhà quản lý đưa ra quyết định dựa trên dữ liệu thực tế.

  * **Tiết kiệm thời gian phân tích:** Giao diện kéo thả và khả năng kết nối đa dạng giúp giảm thiểu thời gian chuẩn bị và phân tích dữ liệu.

  * **Cải thiện giao tiếp và cộng tác:** Các báo cáo và dashboard trực quan dễ dàng chia sẻ và giúp mọi người trong tổ chức hiểu cùng một bức tranh về dữ liệu.

  * **Khám phá những insight mới:** Quá trình tương tác với dữ liệu trực quan có thể khơi gợi những câu hỏi mới và dẫn đến những khám phá bất ngờ.

  * **Nâng cao hiệu quả kinh doanh:** Bằng cách hiểu rõ hơn về khách hàng, thị trường và hiệu suất hoạt động, doanh nghiệp có thể đưa ra các chiến lược hiệu quả hơn.


Tóm lại, Tableau là một công cụ mạnh mẽ và linh hoạt, mang lại nhiều lợi ích cho việc phân tích và trực quan hóa dữ liệu. Dù bạn là người mới bắt đầu hay một chuyên gia phân tích, Tableau đều có thể giúp bạn khai thác tối đa tiềm năng từ dữ liệu của mình. Tiếp đến, hãy cùng chúng tôi tìm hiểu chi tiết hơn về hướng dẫn sử dụng Tableau chi tiết ở nội dung bên dưới.

# Hướng dẫn đăng ký phần mềm Tableau bản quyền

Trước khi tìm hiểu về cách sử dụng Tableau, người dùng cần phải tìm hiểu về các gói dịch vụ và cách thức đăng ký tài khoản bản quyền. Do đó, chúng tôi sẽ chia sẻ một vài những thông tin hữu ích như sau:

# Các gói đăng ký Tableau

Hiện tại, Tableau có các gói dịch vụ tương ứng với từng nhu cầu sử dụng riêng biệt của khách hàng. Chính vì vậy, chúng tôi sẽ chia sẻ một số những gói phần mềm phổ biến nhất để bạn có thể nắm được như sau:
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><strong>Tên gói phần mềm</strong></th>
<th><strong>Chi tiết</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><ol>
<li><p><strong>Tableau</strong></p></li>
</ol></td>
<td>Gói phần mềm toàn diện giúp bạn tập trung nhiều hơn vào dữ liệu.
Hiện có sẵn trên phiên bản Tableau Cloud và Tableau Server.</td>
</tr>
<tr>
<td>1.1. Tableau Creator</td>
<td>Tableau Desktop, Tableau Prep Builder, một giấy phép Creator trên
Tableau Cloud hoặc Server và Tableau Pulse (chỉ có trên Tableau
Cloud).</td>
</tr>
<tr>
<td>1.2. Tableau Explorer</td>
<td>Một giấy phép Explorer trên Tableau Cloud hoặc Server và Tableau
Pulse (chỉ khả dụng trên Tableau Cloud).</td>
</tr>
<tr>
<td>1.3. Tableau Viewer</td>
<td>Một giấy phép Viewer trên Tableau Cloud hoặc Server và Tableau Pulse
(chỉ khả dụng trên Tableau Cloud).</td>
</tr>
<tr>
<td><strong>2. Enterprise</strong></td>
<td>Gói phần mềm tiên tiến giúp bạn khám phá và quản lý dữ liệu nhanh
hơn. Có sẵn trên Tableau Cloud và Tableau Server.</td>
</tr>
<tr>
<td>2.1. Enterprise Creator</td>
<td>Tableau Desktop, Tableau Prep Builder và một giấy phép Creator trên
Tableau Cloud hoặc Server với tính năng hỗ trợ Quản lý nâng cao và Quản
lý dữ liệu, Tableau Pulse (chỉ có trên phiên bản Tableau Cloud) và một
năm truy cập vào eLearning dành cho Creators.</td>
</tr>
<tr>
<td>2.2. Enterprise Explorer</td>
<td>Một giấy phép Explorer trên phiên bảnTableau Cloud hoặc Server với
tính năng hỗ trợ Quản lý nâng cao và Quản lý dữ liệu, Tableau Pulse (chỉ
có trên Tableau Cloud) và một năm truy cập vào eLearning dành cho
Explorers.</td>
</tr>
<tr>
<td>2.3. Enterprise Viewer</td>
<td>Giấy phép One Viewer trên Tableau Cloud hoặc Server với Quản lý nâng
cao và Quản lý dữ liệu, và Tableau Pulse (chỉ khả dụng trên Tableau
Cloud).</td>
</tr>
<tr>
<td><strong>3. Tableau +</strong></td>
<td>Gói cao cấp hỗ trợ phân tích AI và chỉ khả dụng trên Tableau
AI.</td>
</tr>
</tbody>
</table> 

Với các gói đăng ký trên, bạn có thể cân nhắc lựa chọn tùy thuộc vào nhu cầu sử dụng riêng biệt. Tiếp đến, nếu người dùng muốn đăng ký sử dụng Tableau bản quyền thì có thể tham khảo 02 cách được chúng tôi chia sẻ bên dưới đây. 

# Đăng ký Tableau trực tiếp với hãng

Một trong những phương thức đăng ký phần mềm Tableau được nhiều khách hàng lựa chọn nhất chính là thông qua hãng. Để lựa chọn phương thức này, bạn chỉ cần thao tác với các bước được chúng tôi hướng dẫn chi tiết như sau:

  * **Bước 1** : Truy cập địa chỉ – [**https://buy.tableau.com/en-us/**](https://buy.tableau.com/en-us/) của hãng trên trình duyệt web của bạn.

  * **Bước 2** : Click chọn gói phần mềm phù hợp kèm với số lượng tương ứng > tiếp đến chọn **BUY TABLEAU**. 


|<image_3>|

  * **Bước 3** : Nhập đầy đủ thông tin mà hệ thống yêu cầu sau đó click chọn **NEXT: PAYMENT**.


|<image_4>|

  * **Bước 4** : Nhập thông tin thanh toán > tích chọn đồng ý với chính sách và điều khoản > tiếp đến chọn **COMPLETE** > **YOUR PURCHASE**.


|<image_5>|

  * **Bước 5** : Hoàn thành.


Như vậy, chỉ với 05 bước hướng dẫn như trên, bạn đã đăng ký thành công phần mềm Tableau trực tiếp với hàng. Tuy nhiên, khi bạn lựa chọn hình thức đăng ký này sẽ gặp phải một số những rào cản liên quan đến ngôn ngữ, hỗ trợ kỹ thuật và nhiều bước triển khai khó khăn hơn. Do đó, chúng tôi sẽ chia sẻ thêm với bạn cách thức đăng ký và nhận hướng dẫn sử dụng Tableau thông qua đại lý ủy quyền chính thức tại Việt Nam.

# Public_169

# Đăng ký Tableau thông qua đại lý ủy quyền

HVN Group đã trở thành đối tác chính thức của Salesforce để cung cấp phần mềm Tableau bản quyền với chi phí đăng ký cạnh tranh nhất. Dưới đây là các bước hướng dẫn chi tiết mà bạn có thể tham khảo như sau:

  * **Bước 1** : Trước tiên, bạn chỉ cần nhấn vào nút **ĐĂNG KÝ TẠI ĐÂY**.


  * **Bước 2** : Nhập thông tin theo mẫu yêu cầu như hình bên dưới > sau đó click chọn **LIÊN HỆ VỚI TÔI**.


|<image_1>|

  * **Bước 3** : Chỉ sau khoảng 15 – 20 phút đội ngũ chăm sóc khách hàng của chúng tôi sẽ liên hệ và hỗ trợ nhanh chóng nhất.


***Lưu ý** : Một số những lợi thế đặc biệt mà bạn nhận được khi đăng ký Tableau thông qua HVN Group chính là:

  * **Hỗ trợ chuyên biệt:** Có thể nhận được hỗ trợ bằng ngôn ngữ địa phương và hiểu rõ hơn về các quy định và hóa đơn tại Việt Nam.

  * **Tư vấn chuyên sâu:** HVN Group là đại lý có thể có kinh nghiệm và hiểu biết sâu sắc về thị trường địa phương, cung cấp tư vấn phù hợp hơn với nhu cầu của doanh nghiệp Việt Nam.

  * **Các dịch vụ giá trị gia tăng:** Chúng tôi có thể cung cấp các dịch vụ bổ sung như đào tạo, hỗ trợ kỹ thuật ban đầu hoặc tích hợp hệ thống.

  * **Quy trình mua hàng thuận tiện:** Chúng tôi đã tối ưu quy trình mua hàng và thanh toán trở nên thuận tiện hơn đồng thời hỗ trợ xuất hóa đơn nếu khách hàng cần.


  * Hướng dẫn sử dụng Tableau cơ bản cho người mới bắt đầu


Nếu như bạn là Newbie và chưa biết cách dùng phần mềm này như thế nào thì hãy tham khảo ngay hướng dẫn sử dụng Tableau chi tiết được chúng tôi chia sẻ cụ thể như sau:

# Đăng nhập tài khoản

Sau khi đã có tài khoản bản quyền, hướng dẫn sử dụng Tableau trước tiên mà chúng tôi muốn gợi ý chính là đăng nhập tài khoản. Do đó, để đăng nhập tài khoản này bạn cần triển khai với một số bước cơ bản như sau:

  * **Bước 1** : Truy cập vào địa chỉ [**https://www.tableau.com/tableau-login-hub**](https://www.tableau.com/tableau-login-hub) để tiến hành đăng nhập theo phương thức mà bạn mong muốn.

  * **Bước 2** : Nhập địa chỉ email và mật khẩu vào khung yêu cầu > tiếp đến chọn **SIGN IN.**


|<image_2>|

  * **Bước 3** : Tích chọn tôi đã đồng ý với chính sách và điều khoản sử dụng > click chọn **Activate my trial**. 


[  
](https://hvn.vn/wp-content/uploads/2025/05/kich-hoat-tai-khoan-tableau.webp)|<image_3>|

  * **Bước 4** : Hoàn thành.


Như vậy, chỉ với 04 bước hướng dẫn sử dụng Tableau đơn giản như trên bạn đã biết cách đăng nhập tài khoản nhanh chóng. Tiếp đến, hãy cùng chúng tôi tìm hiểu chi tiết hơn về những tính năng hữu ích mà phần mềm này đang sở hữu.

# Tạo dự án làm việc mới

Để tạo một dự án làm việc mới trên Tableau, bạn cần phải triển khai với một số những bước được chúng tôi hướng dẫn cụ thể như sau:

  * **Bước 1** : Sau khi đăng nhập, tạo giao diện chính của phần mềm click chọn **New** > tiếp đến chọn **Project**.


|<image_4>|

  * **Bước 2** : Nhập tên và mô tả của dự án > sau đó click chọn **Create**.


|<image_5>|

  * **Bước 3** : Hoàn thành.


Tương tự như vậy, bạn hoàn toàn có thể tạo bất kỳ dự án mới nào trên Tableau chỉ với một số những bước cơ bản được chúng tôi hướng dẫn như trên. Tiếp đến, chúng tôi sẽ hướng dẫn sử dụng Tableau cho bạn qua các bước quản lý dự án đã tạo trên công cụ này.

# Quản lý dự án

Sau khi bạn đã tạo dự án thành công trên Tableau, tiếp đến bạn có thể quản lý dự án này một cách dễ dàng bằng các bước hướng dẫn như sau:

  * **Bước 1** : Truy cập mục quản lý dự án bằng cách click chọn **Explore** ở thanh công cụ bên trái giao diện hoặc chọn vào **Manage Projects** như hình bên dưới.


|<image_6>|

  * **Bước 2** : Chọn dự án mà bạn muốn triển khai > click chọn **New** > tiếp đến chọn **Upload Workbook**.


|<image_7>|

  * **Bước 3** : Nhập tên tài liệu trong dự án, thêm mô tả ngắn > chọn **Choose a file** > tiếp đến chọn file tương ứng > chọn **Open** > tiếp đến chọn **Upload**.


|<image_8>|

  * **Bước 4** : Để thay đổi thông tin trong dự án, bạn có thể chỉnh sửa bằng cách click chọn vào dấu “ba chấm” ở bên cạnh tên dự án.


  * Chia sẻ

  * Thêm vào bộ sưu tập

  * Đổi tên

  * Di chuyển

  * Thêm quyền

  * Thay đổi chủ sở hữu

  * Xóa bỏ


|<image_9>|

# Quản lý người dùng

Bạn hoàn toàn có thể quản lý người dùng trong phần mềm Tableau khi triển khai chung một dự án với các bước được chúng tôi chia sẻ với những bước hướng dẫn cụ thể như sau:

  * **Bước 1** : Ở thanh công cụ bên trái màn hình click chọn **Users** > tiếp đến chọn **Add Users** > chọn **Add Users by Username** hoặc **Import Users from file**


|<image_10>|.

  * **Bước 2** : Tiến hành thêm người dùng theo 02 cách:


  * _**Cách 1 – Add Users by Username**_ : Chọn phương thức xác thực > thêm tên tài khoản > chọn vai trò trên trang > tiếp đến click chọn **Add Users**.


|<image_11>|

  * _**Cách 2 – Import Users from file**_ : Chọn phương thức xác thực > chọn file phù hợp > tiếp đến chọn **Import Users**.


|<image_12>|

Với các bước hướng dẫn sử dụng Tableau như trên, bạn đã có thể thêm thành viên vào phần mềm này một cách dễ dàng. Tiếp đến, chúng tôi sẽ chia sẻ thêm với bạn về cách thêm nhãn, thêm nhóm làm việc và tích hợp cùng với các công cụ khác.

# Public_170

# Thêm nhãn dữ liệu

Bạn hoàn toàn có thể bổ sung thêm nhãn trong phần mềm Tableau để đánh dấu. Nếu bạn muốn sử dụng tính năng này có thể thao tác thực hiện với các bước hướng dẫn như sau:

  * **Bước 1:** Click chọn **Data Labels** > tiếp đến chọn **New Label**.


|<image_1>|

  * **Bước 2** : Chọn danh mục cho nhãn > Thêm giá trị nhãn > Thêm mô tả ngắn cho nhãn và click chọn **Save**.


|<image_2>|

  * **Bước 3:** Sau khi thực hiện xong, nhãn mà bạn đã tạo sẽ xuất hiện trong danh sách các nhãn có trong Tableau.

  * **Bước 4** : Hoàn thành.


# Thêm nhóm làm việc

Bạn hoàn toàn có thể tạo nhóm làm việc mới trên phần mềm Tableau nếu áp dụng triển khai theo các bước như sau:

  * **Bước 1** : Trên giao diện chính của phần mềm click chọn **Groups** > tiếp đến chọn **Add Group**.


|<image_3>|

  * **Bước 2** : Nhập tên nhóm vào ô trống > tích chọn vai trò cấp quyền đăng nhập > tiếp đến chọn **Create**.

  * **Bước 3** : Hoàn thành.


Như vậy, chỉ với 03 bước đơn giản như hướng dẫn trên đây bạn đã tạo nhóm làm việc thành công trên phần mềm Tableau. 

# Tích hợp với nền tảng khác

Hiện tại, Tableau cho phép kết nối với các nền tảng khác nhau để hỗ trợ làm việc hiệu quả. Do đó, chúng tôi sẽ hướng dẫn bạn cách để kết nối công cụ này với một vài nền tảng khác điển hình như Slack, Salesforce…

  * **Bước 1** : Click chọn **Settings** > tiếp đến chọn **Integrations** > sau đó chọn **Connects to Salesforce** hoặc **Connect to Slack**.


|<image_4>|

  * **Bước 2** : Một cửa sổ đăng nhập tài khoản kết nối với nền tảng mà bạn muốn sử dụng. Khi đó, bạn chỉ cần nhập địa chỉ email tài khoản > nhập mật khẩu và click chọn **Sign in**.

  * **Bước 3** : Ngoài ra, nếu bạn muốn kết nối với nền tảng khác thì chỉ cần click chọn **Settings** > **Connected Apps** > tiếp đến chọn **New Connected App** > chọn **Direct Trust** hoặc **OAuth 2.0 Trust**


**.**

|<image_5>|

  * **Cách 1:** Thêm tên cho ứng dụng kết nối > lựa chọn dự án kết hợp > thêm danh sách tên miền phù hợp > sau đó click chọn **Create**.


|<image_6>|

  * **Cách 2:** Nhập tên ứng dụng được kết nối > nhập URL > sau đó click chọn **Create**.


|<image_7>|

Như vậy, với những hướng dẫn sử dụng Tableau chi tiết như trên, người dùng có thể chủ động trải nghiệm dùng phần mềm một cách hiệu quả hơn. Trong trường hợp bạn muốn được hỗ trợ chuyên sâu hơn vui lòng liên hệ đến chuyên gia kỹ thuật của HVN Group qua **Hotline 024.9999.7777** để được giải đáp tất tần tật các câu hỏi chuyên sâu nhanh chóng.

# Lưu ý quan trọng để sử dụng Tableau

Tableau là một công cụ mạnh mẽ, nhưng để khai thác tối đa tiềm năng của nó và tạo ra những phân tích, trực quan hóa dữ liệu có giá trị, bạn cần lưu ý một số điểm quan trọng sau:

## Hiểu rõ dữ liệu của bạn:

  * **Nguồn gốc và chất lượng:** Trước khi bắt đầu phân tích, hãy đảm bảo bạn hiểu rõ nguồn gốc của dữ liệu, cách dữ liệu được thu thập và liệu nó có đáng tin cậy hay không. Dữ liệu “rác” sẽ dẫn đến những phân tích “rác”.

  * **Kiểu dữ liệu:** Xác định đúng kiểu dữ liệu của từng trường (Number, String, Date, Boolean, Geographic Role). Tableau dựa vào kiểu dữ liệu để cung cấp các tùy chọn phân tích và trực quan hóa phù hợp. Sai kiểu dữ liệu có thể gây ra lỗi hoặc kết quả không chính xác.

  * **Mối quan hệ giữa các trường:** Hiểu rõ mối quan hệ giữa các bảng dữ liệu nếu bạn làm việc với nhiều nguồn. Việc thiết lập các mối quan hệ (Relationships) hoặc kết nối (Joins, Blends) đúng cách là rất quan trọng để đảm bảo tính chính xác của phân tích.

  * **Làm sạch và chuẩn bị dữ liệu:** Sử dụng Tableau Prep hoặc các công cụ khác để xử lý các vấn đề như dữ liệu trùng lặp, giá trị Null, định dạng không nhất quán trước khi đưa vào Tableau Desktop. Dữ liệu sạch sẽ giúp quá trình phân tích trơn tru và kết quả đáng tin cậy hơn.


## Lựa chọn biểu đồ phù hợp:

  * **Mục đích trực quan hóa:** Xác định rõ mục tiêu bạn muốn truyền tải thông qua biểu đồ. Bạn muốn so sánh các giá trị, theo dõi xu hướng theo thời gian, hiển thị mối quan hệ giữa các biến số hay phân tích tỷ lệ phần trăm?

  * **Loại dữ liệu:** Các loại biểu đồ khác nhau phù hợp với các loại dữ liệu khác nhau. Ví dụ: biểu đồ cột thích hợp để so sánh các danh mục, biểu đồ đường phù hợp cho dữ liệu thời gian, biểu đồ tròn thích hợp cho tỷ lệ phần trăm (nhưng nên sử dụng cẩn thận).

  * **Sự rõ ràng và dễ hiểu:** Ưu tiên sự rõ ràng và dễ hiểu cho người xem. Tránh sử dụng quá nhiều yếu tố gây rối mắt hoặc các loại biểu đồ phức tạp nếu không cần thiết.

  * **Tuân thủ các nguyên tắc trực quan hóa tốt:** Tìm hiểu và áp dụng các nguyên tắc cơ bản về thiết kế biểu đồ để truyền tải thông tin một cách hiệu quả nhất (ví dụ: sử dụng màu sắc nhất quán, chú thích rõ ràng, tránh hiệu ứng 3D không cần thiết).


## Tận dụng một số các tính năng tương tác:

  * **Bộ lọc (Filters):** Cho phép người dùng tập trung vào các phân khúc dữ liệu cụ thể và khám phá sâu hơn.

  * **Hành động (Actions):** Tạo sự liên kết giữa các biểu đồ trên dashboard, cho phép người dùng tương tác để khám phá dữ liệu theo nhiều chiều.

  * **Chú giải công cụ (Tooltips):** Cung cấp thông tin chi tiết khi người dùng di chuột qua các điểm dữ liệu. Tùy chỉnh tooltips để hiển thị thông tin hữu ích và dễ hiểu.

  * **Tham số (Parameters):** Cho phép người dùng thay đổi các biến số trong phân tích một cách linh hoạt.

  * **Highlighting:** Làm nổi bật các điểm dữ liệu dựa trên lựa chọn của người dùng.


## Thiết kế dashboard hiệu quả:

  * **Mục tiêu rõ ràng:** Xác định mục tiêu chính của dashboard và những thông tin quan trọng cần truyền tải.

  * **Bố cục logic:** Sắp xếp các biểu đồ và đối tượng một cách logic và dễ theo dõi, đặt những thông tin quan trọng nhất ở vị trí dễ nhìn.

  * **Sử dụng nhất quán:** Duy trì sự nhất quán về màu sắc, font chữ và kiểu biểu đồ trên toàn bộ dashboard.

  * **Đơn giản và tập trung:** Tránh nhồi nhét quá nhiều thông tin vào một dashboard. Tập trung vào một số những chỉ số được đánh giá là quan trọng nhất.

  * **Tính tương tác:** Tích hợp các yếu tố tương tác để người dùng có thể khám phá dữ liệu theo nhu cầu của họ.

  * **Hiệu suất:** Thiết kế dashboard sao cho tải nhanh và hoạt động mượt mà, đặc biệt khi làm việc với lượng lớn dữ liệu.


##  Quản lý workbook và nguồn dữ liệu:

  * **Lưu trữ có tổ chức:** Lưu trữ workbook và các tệp dữ liệu liên quan một cách có hệ thống để dễ dàng quản lý và tìm kiếm sau này.

  * **Sử dụng Tableau Packaged Workbook (.twbx):** Khi chia sẻ workbook, hãy sử dụng định dạng .twbx để đóng gói cả workbook và dữ liệu, đảm bảo người nhận có thể mở và xem được.

  * **Quản lý kết nối dữ liệu:** Hiểu rõ sự khác biệt giữa Live Connection và Extract và lựa chọn phương pháp phù hợp với nhu cầu hiệu suất và cập nhật dữ liệu của bạn.

  * **Đặt tên rõ ràng:** Đặt tên rõ ràng cho các sheet, dashboard, trường tính toán và tham số để dễ dàng quản lý và hiểu.


##  Học hỏi và liên tục phát triển:

  * **Tận dụng tài liệu và hướng dẫn của Tableau:** Tableau cung cấp rất nhiều tài liệu, video hướng dẫn và khóa học trực tuyến miễn phí.

  * **Tham gia cộng đồng Tableau:** Kết nối với cộng đồng người dùng Tableau trên diễn đàn, mạng xã hội để học hỏi kinh nghiệm và giải đáp thắc mắc.

  * **Thực hành thường xuyên:** Cách tốt nhất để làm chủ Tableau là thực hành càng nhiều càng tốt với các bộ dữ liệu khác nhau và thử nghiệm các tính năng khác nhau.

  * **Cập nhật kiến thức:** Tableau thường xuyên phát hành các phiên bản mới với các tính năng cải tiến. Hãy theo dõi các bản cập nhật để không bỏ lỡ những công cụ hữu ích.


##  Chia sẻ và cộng tác hiệu quả:

  * **Chọn phương pháp chia sẻ phù hợp:** Sử dụng Tableau Public, Tableau Server hoặc Tableau Online tùy thuộc vào nhu cầu chia sẻ công khai hay nội bộ.

  * **Cung cấp ngữ cảnh:** Khi chia sẻ dashboard hoặc báo cáo, hãy cung cấp đủ ngữ cảnh và giải thích để người xem hiểu rõ thông tin được trình bày.

  * **Thu thập phản hồi:** Khuyến khích người xem đưa ra phản hồi để bạn có thể cải thiện các phân tích và trực quan hóa của mình.


Bằng cách ghi nhớ và áp dụng những lưu ý quan trọng này, bạn sẽ có thể sử dụng Tableau một cách hiệu quả hơn, tạo ra những phân tích sâu sắc và những trực quan hóa dữ liệu ấn tượng.

# Public_174

ETL (Extract, Transform, Load) đóng vai trò quan trọng trong quản lý dữ liệu và xử lý thông tin. Để hiểu rõ hơn về ETL là gì và vai trò của nó, chúng ta cần xem xét quy trình và các bước cơ bản trong quá trình này. Từ việc trích xuất dữ liệu từ nguồn, biến đổi chúng để phù hợp với mục đích cụ thể, cho đến việc tải dữ liệu đã chuẩn hóa vào hệ thống lưu trữ, ETL đóng vai trò quan trọng trong việc chuẩn bị dữ liệu cho các hoạt động phân tích và ứng dụng trong môi trường kinh doanh hiện đại. Hãy cùng đi sâu vào quy trình ETL là gì để hiểu rõ hơn về tính chất và cách thức hoạt động của nó nhé!

# ETL là gì?

Trích xuất, chuyển đổi và tải (ETL) đại diện cho việc tập hợp dữ liệu từ nhiều nguồn khác nhau và hợp nhất chúng vào một kho lưu trữ trung tâm lớn, thường gọi là kho dữ liệu. ETL sử dụng các nguyên tắc kinh doanh để xử lý và sắp xếp dữ liệu gốc, sau đó chuẩn bị thông tin để sử dụng trong quá trình lưu trữ, phân tích và các ứng dụng học máy (ML). Qua việc phân tích dữ liệu, người dùng có thể giải quyết các nhu cầu cụ thể về thông tin kinh doanh, bao gồm việc dự đoán kết quả từ các quyết định kinh doanh, tạo ra báo cáo và bảng thông tin, cải thiện khả năng vận hành hiệu quả và nhiều mục đích khác.

|<image_1>|

# Tại sao ETL lại quan trọng?

Ngày nay, các tổ chức sở hữu cả dữ liệu có cấu trúc và dữ liệu phi cấu trúc từ nhiều nguồn khác nhau, bao gồm:

Dữ liệu về khách hàng từ hệ thống quản lý quan hệ khách hàng (CRM) và giao dịch thanh toán trực tuyến.

Dữ liệu liên quan đến hàng tồn kho và các hoạt động từ hệ thống của các nhà cung cấp.

Dữ liệu từ các cảm biến trên các thiết bị Internet của mọi vật IoT.

Dữ liệu tiếp thị từ các phương tiện truyền thông xã hội và phản hồi từ khách hàng.

Dữ liệu về nhân viên từ hệ thống quản lý nhân sự nội bộ.

|<image_2>|

Bằng việc thực hiện quy trình trích xuất, chuyển đổi và tải (ETL), các tập dữ liệu thô riêng lẻ có thể được chuẩn bị theo một định dạng và cấu trúc dễ tiêu thụ hơn cho mục đích phân tích, tạo ra thông tin sâu hơn và có giá trị hơn. Ví dụ, các doanh nghiệp bán lẻ trực tuyến có thể phân tích dữ liệu từ các điểm bán hàng để dự báo nhu cầu và quản lý hàng tồn kho. Các nhóm tiếp thị có thể tích hợp dữ liệu từ CRM với phản hồi từ khách hàng trên mạng xã hội để nghiên cứu hành vi của người tiêu dùng.

# ETL mang lại lợi ích cho việc thu thập thông tin kinh doanh như thế nào?

Lợi ích của ETL là gì trong việc cải thiện việc thu thập và phân tích thông tin kinh doanh:

## 3.1. Lịch sử và bối cảnh

ETL đóng vai trò quan trọng trong việc cung cấp cái nhìn sâu rộng về lịch sử dữ liệu của tổ chức. Điều này cho phép doanh nghiệp kết hợp dữ liệu cũ với thông tin mới từ các nền tảng và ứng dụng hiện đại. Bằng việc xem xét dữ liệu cũ đồng thời với dữ liệu mới, ETL mở ra cái nhìn dài hạn về thông tin.

## 3.2. Hợp nhất dữ liệu

ETL cung cấp một chế độ xem hợp nhất về dữ liệu để phân tích và tạo báo cáo chi tiết. Quản lý nhiều tập dữ liệu yêu cầu thời gian và sự phối hợp, có thể dẫn đến việc xử lý không hiệu quả và chậm trễ. ETL kết hợp các cơ sở dữ liệu và các dạng dữ liệu khác nhau thành một chế độ xem thống nhất và duy nhất. Quá trình tích hợp dữ liệu cải thiện chất lượng dữ liệu và giảm thời gian cần thiết cho việc di chuyển, phân loại hoặc chuẩn hóa dữ liệu. Điều này giúp dễ dàng hơn trong việc phân tích, hình dung và hiểu các tập dữ liệu lớn.

|<image_3>|

## 3.3. Phân tích dữ liệu chính xác

ETL cung cấp khả năng phân tích dữ liệu chính xác hơn để đáp ứng các tiêu chuẩn về tuân thủ và quy định. Bằng cách tích hợp công cụ ETL với các công cụ kiểm soát chất lượng dữ liệu, bạn có thể tạo hồ sơ, kiểm tra và làm sạch dữ liệu, đảm bảo rằng dữ liệu được xác thực và tin cậy.

## 3.4. Tự động hóa tác vụ

ETL tự động hóa các tác vụ xử lý dữ liệu lặp đi lặp lại để tăng hiệu suất trong phân tích. Công cụ ETL tự động hóa việc di chuyển dữ liệu và bạn có thể lập lịch để tích hợp thay đổi dữ liệu theo định kỳ hoặc thậm chí trong quá trình chạy. Điều này giúp nhân viên dữ liệu dành nhiều thời gian hơn cho sáng tạo và ít thời gian hơn trong việc quản lý các công việc tẻ nhạt như di chuyển và chuẩn hóa dữ liệu.

|<image_4>|

# ETL đã phát triển như thế nào?

ETL (Extraction, Transformation, Loading) xuất phát từ sự xuất hiện của cơ sở dữ liệu quan hệ, nơi dữ liệu được tổ chức và lưu trữ dưới dạng các bảng để dễ dàng phân tích. Ban đầu, các công cụ ETL đã được phát triển để chuyển đổi dữ liệu từ định dạng giao dịch sang định dạng quan hệ để phục vụ mục đích phân tích.

## 4.1. ETL truyền thống

Trước đây, dữ liệu nguyên thủy thường được lưu trữ trong cơ sở dữ liệu giao dịch, hỗ trợ nhiều yêu cầu về đọc và ghi dữ liệu nhưng không phù hợp cho mục đích phân tích. Có thể coi nó như việc lưu trữ dữ liệu trong một bảng tính. Ví dụ, trong hệ thống thương mại điện tử, cơ sở dữ liệu giao dịch lưu trữ thông tin về các mặt hàng đã mua, chi tiết về khách hàng và đơn hàng trong một giao dịch. Trong một năm, nó ghi chép một danh sách dài các giao dịch với các mục nhập lặp lại cho cùng một khách hàng đã mua nhiều mặt hàng khác nhau trong năm đó. Với sự trùng lặp dữ liệu này, việc phân tích các mặt hàng phổ biến nhất hoặc xu hướng mua hàng trong năm trở nên phức tạp.

|<image_5>|

Để giải quyết vấn đề này, các công cụ ETL đã tự động chuyển đổi dữ liệu giao dịch sang dạng dữ liệu quan hệ, trong đó các bảng được liên kết với nhau. Nhà phân tích có thể sử dụng các truy vấn để xác định mối quan hệ giữa các bảng, cũng như phân tích các mẫu và xu hướng.

## 4.2. ETL hiện đại

Khi công nghệ ETL phát triển, cả loại dữ liệu và nguồn dữ liệu đều tăng về quy mô. Công nghệ đám mây đã xuất hiện để tạo ra các hệ thống lưu trữ rộng lớn, hay còn gọi là các Data Warehouse. Những Data Warehouse như vậy có khả năng tiếp nhận dữ liệu từ nhiều nguồn và sử dụng các tài nguyên phần cứng có khả năng mở rộng theo thời gian. Các công cụ ETL cũng đã trở nên tinh vi hơn và có khả năng làm việc với các Data Warehouse hiện đại. Chúng có thể chuyển đổi dữ liệu từ các định dạng dữ liệu cổ điển sang các định dạng dữ liệu hiện đại. Dưới đây là một số ví dụ về các hệ thống lưu trữ dữ liệu hiện đại.

### 4.2.1. Kho dữ liệu (Data Warehouse)

Kho dữ liệu là một trung tâm lưu trữ dữ liệu có khả năng chứa nhiều cơ sở dữ liệu khác nhau. Trong mỗi cơ sở dữ liệu, dữ liệu được tổ chức thành các bảng và cột mô tả các loại dữ liệu trong bảng đó. Phần mềm của kho dữ liệu hoạt động trên nhiều loại phần cứng lưu trữ như ổ cứngthể rắn (SSD), ổ cứng và lưu trữ đám mây khác, nhằm tối ưu hóa việc xử lý dữ liệu.

|<image_6>|

### 4.2.2. Hồ dữ liệu (Data Lake)

Data Lake cho phép bạn lưu trữ toàn bộ dữ liệu, bao gồm cả dữ liệu có cấu trúc và không có cấu trúc, ở bất kỳ quy mô nào tại một nơi tập trung. Bạn có thể lưu trữ dữ liệu nguyên gốc mà không cần phải cấu trúc hóa trước dựa trên các câu hỏi có thể xuất hiện trong tương lai. Hồ dữ liệu cho phép sử dụng nhiều phương pháp phân tích khác nhau trên dữ liệu của bạn, từ truy vấn SQL, phân tích dữ liệu lớn, tìm kiếm toàn văn bản, phân tích thời gian thực đến học máy (ML), giúp hướng dẫn quyết định một cách hiệu quả hơn.

|<image_7>|

# ETL hoạt động như thế nào?

Quá trình ETL (Trích xuất, Chuyển đổi, Tải) là quá trình chuyển dữ liệu từ hệ thống nguồn đến hệ thống đích theo các chu kỳ thời gian cố định. Quá trình ETL là gì và bao gồm bao nhiêu giai đoạn cụ thể có thể tóm gọn như sau:

Trích xuất dữ liệu từ cơ sở dữ liệu nguồn.

Chuyển đổi dữ liệu để phù hợp với yêu cầu phân tích.

Tải dữ liệu vào cơ sở dữ liệu đích

# Trích xuất dữ liệu là gì?

Trong quá trình trích xuất dữ liệu, các công cụ ETL (Trích xuất, Chuyển đổi, Tải) thu thập hoặc sao chép dữ liệu thô từ nhiều nguồn và lưu trữ chúng tạm thời trong một khu vực lưu trữ trung gian, thường được gọi là vùng đệm. Vùng đệm hoạt động như một bước trung gian để tạm thời lưu giữ dữ liệu đã được trích xuất. Thông thường, vùng đệm chứa dữ liệu tạm thời và sẽ bị xóa sau khi quá trình trích xuất dữ liệu hoàn tất. Tuy nhiên, nó cũng có thể được sử dụng như một nguồn dữ liệu dự phòng để khắc phục sự cố khi cần thiết.

|<image_8>|

Việc dữ liệu được chuyển từ nguồn đến kho lưu trữ đích phụ thuộc vào cơ chế thu thập và theo dõi sự thay đổi của dữ liệu. Quá trình trích xuất dữ liệu thường được thực hiện theo một trong ba cách sau đây.

**Thông báo cập nhật**

Trong quá trình thông báo cập nhật, hệ thống nguồn thông tin về việc thay đổi bản ghi dữ liệu. Sau đó, bạn có thể thực hiện quá trình trích xuất dữ liệu chỉ từ những thay đổi đó. Đa số cơ sở dữ liệu và ứng dụng web đều cung cấp các cơ chế cập nhật để hỗ trợ tích hợp dữ liệu theo phương pháp này.

**Trích xuất tăng dần**

Một số nguồn dữ liệu không thể gửi thông báo cập nhật, nhưng có khả năng xác định và trích xuất dữ liệu đã được sửa đổi trong một khoảng thời gian cụ thể. Trong tình huống này, hệ thống sẽ kiểm tra các thay đổi theo chu kỳ nhất định, ví dụ như hàng tuần, hàng tháng hoặc khi một chiến dịch kết thúc. Điều này giúp bạn chỉ trích xuất dữ liệu đã có sự thay đổi.

|<image_9>|

**Trích xuất hoàn toàn**

Một số hệ thống không thể xác định sự thay đổi trong dữ liệu hoặc cung cấp thông báo, do đó, việc tải lại toàn bộ dữ liệu là phương pháp duy nhất. Cách tiếp cận này đòi hỏi bạn duy trì một bản sao của lần trích xuất gần nhất để kiểm tra bản ghi nào là mới nhất. Tuy nhiên, do phương pháp này yêu cầu truyền toàn bộ dữ liệu, chúng tôi khuyên bạn chỉ nên áp dụng cho các bảng dữ liệu nhỏ.

# Chuyển đổi dữ liệu là gì?

Trong quá trình chuyển đổi dữ liệu, các công cụ ETL (Trích xuất, Chuyển đổi, Tải) sẽ thực hiện việc chuyển đổi và hợp nhất dữ liệu thô từ vùng đệm để chuẩn bị cho kho dữ liệu đích. Quá trình chuyển đổi dữ liệu có thể bao gồm các loại thay đổi dữ liệu sau đây.

## 7.1. Chuyển đổi dữ liệu cơ bản

Các chuyển đổi cơ bản trong quá trình chuyển đổi dữ liệu:

**Làm sạch dữ liệu** : Làm sạch dữ liệu là quá trình loại bỏ các lỗi và biến đổi dữ liệu nguồn để phù hợp với định dạng dữ liệu đích.

**Ví dụ** : Chuyển đổi trường dữ liệu trống thành giá trị số 0, ánh xạ các dữ liệu "Parent" thành "P" hoặc "Child" thành "C."

|<image_10>|

**Chống trùng lặp dữ liệu** : Quá trình này tập trung vào xác định và loại bỏ các bản ghi trùng lặp trong dữ liệu.

**Sửa đổi định dạng dữ liệu** : Chỉnh sửa định dạng dữ liệu là việc biến đổi dữ liệu sang một định dạng thống nhất, bao gồm đổi đơn vị đo lường, định dạng ngày/tháng/năm theo chuẩn.

**Ví dụ** : Một công ty thực phẩm có thể sử dụng các đơn vị khác nhau trong cơ sở dữ liệu, như kilogram và cân Anh. Quá trình ETL sẽ chuyển đổi tất cả các đơn vị sang cân Anh để có định dạng thống nhất.

## 7.2. Chuyển đổi dữ liệu nâng cao

Chuyển đổi nâng cao áp dụng quy tắc kinh doanh để tối ưu hóa dữ liệu cho việc phân tích thuận lợi hơn. Dưới đây là các ví dụ về các loại chuyển đổi này:

**Dẫn xuất** : Dẫn xuất là việc áp dụng các quy tắc kinh doanh vào dữ liệu để tạo ra các giá trị mới dựa trên thông tin hiện có. Ví dụ: Chuyển đổi doanh thu thành lợi nhuận bằng cách trừ đi chi phí hoặc tính tổng chi phí mua hàng bằng cách nhân giá của mỗi mặt hàng với số lượng đã đặt.

**Gộp ghép** : Trong quá trình chuẩn bị dữ liệu, gộp ghép là việc kết nối dữ liệu tương tự từ các nguồn dữ liệu khác nhau. Ví dụ: Tính tổng chi phí mua một mặt hàng bằng cách cộng giá trị mua hàng từ các nhà cung cấp khác nhau và chỉ lưu tổng kết quả trong hệ thống đích.

|<image_11>|

**Chia tách** : Chia tách dữ liệu cho phép bạn phân chia một cột hoặc thuộc tính dữ liệu thành nhiều cột trong hệ thống đích. Ví dụ: Nếu tên khách hàng trong nguồn dữ liệu được ghi là "Jane John Doe", bạn có thể chia thành các cột riêng biệt cho họ, tên đệm và tên.

**Tổng hợp** : Tổng hợp cải thiện chất lượng dữ liệu bằng việc tổng hợp nhiều giá trị dữ liệu thành một tập dữ liệu nhỏ hơn. Ví dụ: Tính tổng hóa đơn đặt hàng từ khách hàng để xây dựng chỉ số giá trị lâu dài của khách hàng (CLV) bằng cách cộng gộp giá trị trong một khoảng thời gian nhất định.

|<image_12>|

**Mã hóa** : Mã hóa dữ liệu nhạy cảm nhằm bảo vệ tính riêng tư hoặc tuân thủ luật dữ liệu trước khi dữ liệu được truyền đến cơ sở dữ liệu đích.

# Tải dữ liệu là gì?

Trong quá trình tải dữ liệu, công cụ ETL (Extract, Transform, Load) di chuyển dữ liệu đã trải qua quá trình chuyển đổi từ khu vực lưu đệm vào kho dữ liệu đích. Đối với hầu hết các tổ chức sử dụng ETL, quá trình này được tự động hóa, có định rõ, liên tục và theo lịch trình hàng loạt. Dưới đây là hai phương pháp tải dữ liệu.

**Tải hoàn toàn** : Trong quá trình tải hoàn toàn, toàn bộ dữ liệu từ nguồn được chuyển đổi và đưa vào kho dữ liệu. Quá trình này thường diễn ra khi bạn tải dữ liệu từ hệ thống nguồn vào kho dữ liệu lần đầu tiên.

**Tải tăng dần** : Trong phương pháp tải tăng dần, công cụ ETL tải delta (hoặc sự chênh lệch) giữa hệ thống đích và nguồn theo các khoảng thời gian đều đặn. Công cụ này ghi nhớ ngày trích xuất cuối cùng để chỉ tải các bản ghi được thêm vào sau ngày này. Có hai cách để thực hiện tải tăng dần.

|<image_13>|

**Tải tăng dần theo luồng** : Trong trường hợp có khối lượng dữ liệu nhỏ, bạn có thể truyền các thay đổi liên tục qua đường ống dữ liệu tới kho dữ liệu đích. Đối với tốc độ dữ liệu lớn như hàng triệu sự kiện mỗi giây, bạn có thể áp dụng xử lý luồng sự kiện để theo dõi và xử lý dữ liệu đồng thời, cho quyết định nhanh hơn.

**Tải gia tăng theo hàng loạt** : Nếu bạn xử lý khối lượng dữ liệu lớn, bạn có thể thu thập các thay đổi dữ liệu và tải chúng theo từng loạt theo lịch trình định kỳ. Trong khoảng thời gian định kỳ này, không có hành động nào xảy ra với hệ thống nguồn hoặc hệ thống đích khi dữ liệu được đồng bộ hóa.

# ELT là gì?

ELT là viết tắt của "Extract, Load, Transform", một phương pháp mở rộng đảo ngược thứ tự của quá trình "Extract, Transform, Load" (ETL). Trong ELT, dữ liệu có thể được tải trực tiếp vào hệ thống đích trước khi trải qua quá trình xử lý. Không cần phải sử dụng khu vực lưu đệm trung gian, bởi vì kho dữ liệu đích có khả năng xử lý dữ liệu bên trong nó. Sự phổ biến của việc sử dụng cơ sở hạ tầng đám mây đã làm cho ELT trở nên phổ biến hơn, cung cấp sức mạnh xử lý cần thiết cho cơ sở dữ liệu đích.

|<image_14>|

**So sánh ETL và ELT**

ELT thích hợp với việc xử lý các tập dữ liệu không có cấu trúc, có khối lượng lớn và yêu cầu tải dữ liệu thường xuyên. Đây cũng là công cụ lý tưởng cho dữ liệu lớn, vì quá trình lập kế hoạch phân tích có thể được thực hiện sau khi dữ liệu được trích xuất và lưu trữ. Ngược lại, ETL để lại phần lớn công việc chuyển đổi dữ liệu cho giai đoạn phân tích và tập trung vào việc tải dữ liệu thô được xử lý tối thiểu vào kho dữ liệu.

|<image_15>|

Quy trình ETL đòi hỏi sự xác định nhiều hơn từ ban đầu. Cần phải tiến hành phân tích sâu hơn từ đầu để xác định loại, cấu trúc và mối quan hệ của dữ liệu đích. Các nhà khoa học dữ liệu thường sử dụng ETL để tải cơ sở dữ liệu cũ vào kho dữ liệu, và hiện nay, ELT đã trở thành tiêu chuẩn chung.

# Ảo hóa dữ liệu là gì?

Ảo hóa dữ liệu sử dụng lớp trừu tượng hóa phần mềm để tạo ra chế độ xem dữ liệu tích hợp mà không cần phải trích xuất, chuyển đổi hoặc tải dữ liệu một cách vật lý. Các tổ chức sử dụng tính năng này như một kho lưu trữ dữ liệu ảo hợp nhất mà không cần chi phí và sự phức tạp trong việc xây dựng và quản lý các nền tảng nguồn và đích riêng biệt. Mặc dù ảo hóa dữ liệu có thể được kết hợp với quá trình trích xuất, chuyển đổi và tải (ETL), nhưng nó ngày càng được coi là một giải pháp thay thế cho ETL và các phương pháp tích hợp dữ liệu vật lý khác. Ví dụ, bạn có thể sử dụng AWS Glue Elastic Views để nhanh chóng tạo ra một bảng ảo, hay còn gọi là một chế độ xem cụ thể hóa, từ nhiều kho dữ liệu nguồn khác nhau.

|<image_16>|

# AWS Glue là gì?

AWS Glue là một dịch vụ tích hợp dữ liệu không cần máy chủ, giúp người dùng dễ dàng khám phá, chuẩn bị, di chuyển và tích hợp dữ liệu từ nhiều nguồn khác nhau để sử dụng cho hoạt động phân tích, máy học và phát triển ứng dụng.

Tính năng của AWS Glue:

Khả năng khám phá và kết nối với hơn 80 kho lưu trữ dữ liệu đa dạng.

Quản lý dữ liệu một cách tập trung trong một danh mục dữ liệu.

AWS Glue Studio, dành cho kỹ sư dữ liệu, nhà phát triển ETL, nhà phân tích dữ liệu và người dùng doanh nghiệp, để tạo, chạy và theo dõi quy trình ETL nhằm tải dữ liệu vào hồ dữ liệu.

Cung cấp giao diện ETL trực quan, Sổ tay và trình soạn mã cho người dùng với các công cụ phù hợp với bộ kỹ năng của họ.

Phiên tương tác cho phép kỹ sư dữ liệu khám phá, tác giả và kiểm thử tác vụ thông qua IDE hoặc sổ tay mà họ ưa thích.

AWS Glue là dịch vụ không cần máy chủ và tự động điều chỉnh quy mô theo nhu cầu, giúp người dùng tập trung vào việc thu thập thông tin từ dữ liệu ở quy mô petabyte mà không cần lo lắng về quản lý cơ sở hạ tầng

|<image_17>|

Để bắt đầu sử dụng AWS Glue, bạn có thể tạo tài khoản AWS.

# Tạm kết

Tóm lại, việc quản lý dữ liệu ngày nay đang trở nên quan trọng hơn bao giờ hết, và các công cụ như ETL, ELT, ảo hóa dữ liệu cùng với các dịch vụ như AWS Glue đang chơi vai trò quan trọng trong việc thu thập, xử lý và tận dụng thông tin từ nhiều nguồn khác nhau. Chúng mở ra cánh cửa cho sự linh hoạt và tiện ích, giúp tạo ra một môi trường quản lý dữ liệu hiệu quả và linh hoạt. Nhờ vào sự phát triển này, người dùng có khả năng tận dụng dữ liệu một cách nhanh chóng và thông minh hơn, từ đó đưa ra quyết định thông minh và tạo ra sáng kiến đổi mới trong môi trường kinh doanh ngày nay.

# Public_175

# 1\. Tổng quan thông tin

## 1.1. Zoiper là gì?

Zoiper là một ứng dụng phần mềm softphone miễn phí. Cho phép bạn thực hiện cuộc gọi điện thoại qua Internet. Bằng việc kết nối với một nhà cung cấp dịch vụ VoIP. Chương được sử dụng trên máy tính hoặc smartphone của bạn. Nó được thế kế với đầy đủ tính năng thoại như một chiếc điện thoại thông thường. Các bạn có thể sử dụng các chức năng quay số, danh bạ, hộp thư thoại. Có thể trả lời cuộc gọi của mình giống như cách sử dụng điện thoại thông thường. Trong thực tế, chương trình được sử dụng với tai nghe và kết nối với máy tính. Qua card âm thanh hoặc smartphone qua kết nối tai nghe.

## 1.2. Tính năng của sofpthone zoiper

  * Hỗ trợ giao thức SIP, IAX và XMPP

  * Danh bạ, lịch sử cuộc gọi

  * Tích hợp bộ giải mã audio và video G.729 (bản thương mại), GSM, µlaw, alaw, speex, iLBC

  * Cho phép đăng ký nhiều tải khoản

  * Chuyển tiếp cuộc gọi

  * Cuộc gọi chờ

  * Tương thích với nhiều nhà cung cấp Voip

  * Hỗ trợ trên Windows, Linux, Mac OS, IOS, Android và Web browsers

  * Chương trình hỗ trợ đa ngôn ngữ


## 1.3. Điều kiện để sử dụng được Zoiper ?

  * Bạn phải có một tổng đài ảo có hỗ trợ giao thức SIP hoặc IAX. Hầu hết các tổng đài IP hiện tại đều có hỗ trợ giao thức này.

  * Việc lắp đặt xây dựng một hệ thống tổng đài Ip cũng tốn khá nhiều chi phí và cần có IT để vận hành.


## 1.4. Giao diện của softphone zoiper

  * Giao diện người dùng của Zoiper trông giống như những điện thoại thông thường. Bạn có thể chọn giữa 4 skin có sẵn. Thay vì chỉ hỗ trợ một skin giao diện mặt định như một số chương trình khác. Giao diện của chương trình có một danh bạ, nhật ký. Và một bàn phím bấm số giống như trong điện thoại bình thường. Bạn có thể thêm, chỉnh sửa và xóa số liên lạc tương tự như điện thoại bình thường của mình.

  * Zoiper cho phép người dùng thêm danh bạ từ một nguồn khác bằng cách nhập từ một nguồn khác hoặc tìm địa chỉ liên lạc đó đã được đăng ký với softphone này. Bạn có thể sắp xếp hoặc lọc tất cả các địa chỉ liên lạc. Các bạn đều có thể tạo nhiều tài khoản với nhiều nhà cung cấp dịch vụ VoIP .

  * Một khi chúng ta đã cài đặt và thiết lập thông tin trên thiết bị của mình. Thì chúng ta có thể di chuyển và sử dụng chương trình này giống như điện thoại thông thường mà không cần quan tâm tới khu vực hay địa lý. Bên cạnh đó người dùng có thể sử dụng tính năng bổ sung như gọi video, chat, v.v


## 1.5. Đánh giá nhanh Softphone zoiper

  * Đáp ứng được tất cả các tính năng cơ bản cẩn thiết của một thiết bị gọi điện

  * Quá trình cài đặt, cấu hình và sử dụng đơn giản

  * Chương trình hoạt động trên hầu hết các thiết bị và hệ điều hành

  * Hoạt động mượt và ổn định ngay cả sử dụng những máy cấu hình yếu

  * Giao diện tương tác trực quan và dễ sử dụng


# 2\. Hướng dẫn cài đặt và sử dụng Zoiper

Dowload phần mềm Zoiper [**TẠI ĐÂY**](https://vnvoip.com/download-phan-mem/)

Sau khi tải về các bạn tiến hành

## **Bước 1** : Mở file vừa download về ( tiếp tục cài đặt chọn **Next** )

|<image_1>|

## **Bước 2** : Xác nhận các điều khoản sử dụng bằng cách chọn vào **I accept the agreement**. Sau đó chọn **Next**

|<image_2>|

## **Bước 3** : Tùy Chọn cài đặt cùng Zoiper

|<image_3>|

  * Add Desktop Shortcut => tạo ra icon ngoài màn hình máy tính.

  * Add Quick Lauche Shortcut => Tạo ra icon trong chương trình cài đặt

  * Start Zoiper with windown => cho phép phần mềm khởi động cùng hệ điều hành windown.


## **Bước 4** : Chọn đương dẫn cài đặt phần mềm

|<image_4>|

## **Bước 5** : Tiếp tục chọn next với tên mặc định

|<image_5>|

## **Bước 6** : chọn cài đặt Zoiper cho tất cả các user trong máy tính.

|<image_6>|

Tiếp tục bấm **next** để cài đặt và bấm **Finish** để hoàn thành quá trình cài đặt.

## **Bước 7** : Cấu hình Tài khoản Sip Account lên Phần mềm Zoiper

Vào **** setting => Create a new account **** ( tạo tài khoản mới)

|<image_7>|

Tại tài khoản mới

|<image_8>|Chọn giao thức tài khoản

Thường chọn giao thức sip ( đây là giao thức phổ biến của tổng đài ảo )

|<image_9>|Cài đặt thông tin tài khoản sip account được cấp từ tổng đài lên Zoiper

Điền các thông tin tài khoản chi tiết như sau các thông số này khi khách hàng sử dụng dịch vụ tổng đài ảo ở Ngọc Thiên sẽ được chung tôi cung cấp chi tiết.

  * **User:** Đây là số máy nhánh của tổng đài như 101.

  * **Password:** Mật khẩu của máy nhánh.

  * **Sip server:** Là địa chỉ IP của tổng đài.


Tiếp tục chọn Next để hoàn thành quá trình cấu hình tài khoản sip account. Khi các thông tin cài đặt đúng thì tài khoản sẽ báo online. Nếu chưa báo online vui lòng kiểm tra 3 thông số trên 1 lần nữa.

## **Bước 8** : Chọn thiết bị âm thanh và Micro để đàm thoại.

|<image_10>|

Lưu ý với các bạn là đối với các bạn sử dụng tai nghe thì có thể chương trình Softphone Zoiper sẽ cần chúng ta chọn thiết bị để chương trình có thể kết nối với thiết bị. Để thực hiện thì chúng ta thao tác như sau, chọn Menu **Softphone** >> **Preferences** các bạn chọn mục **Device** tại đây. Chúng ta chọn **tab Device** , tại phần **Speaker** và **Microphone** ta chọn thiết bị và bấm OK. VD: ở đây mình sử dụng thiết bị là jabra nên Speaker và Microphone mình chọn thiết bị jabra.

# Public_176

# GraphQL là gì?

Graphql là một cú pháp mạnh mẽ được thiết kế để mô tả cách yêu cầu lấy dữ liệu, thường được sử dụng để tải dữ liệu từ một server đặc biệt cho client. Đơn giản hóa, Graphql có thể được coi là một ngôn ngữ truy vấn và thao tác dữ liệu nguồn mở cho các API. Quan trọng nhất, nó mang đến cho client khả năng đưa ra yêu cầu dữ liệu một cách chính xác và thuận tiện, đồng thời tối ưu hóa quá trình tương tác giữa client và server. GraphQL được xây dựng dựa trên ba đặc điểm chính:

  * GraphQL giúp tổng hợp dữ liệu từ nhiều nguồn khác nhau một cách hiệu quả. Thay vì phải gửi nhiều yêu cầu đến nhiều API khác nhau, GraphQL cho phép lấy đồng thời tất cả các dữ liệu cần thiết chỉ trong một yêu cầu.

  * GraphQL cung cấp sức mạnh cho các client khi có khả năng định dạng chính xác dữ liệu mà họ muốn nhận. Điều này loại bỏ tình trạng "over-fetching" hoặc "under-fetching" thông tin, giúp tối ưu hóa tải trọng dữ liệu.

  * GraphQL sử dụng hệ thống kiểu dữ liệu (type system) để định nghĩa và khai báo cấu trúc dữ liệu. Điều này tạo ra một phương thức mạnh mẽ và dễ đọc để xác định kiểu dữ liệu, quy tắc kiểm soát và phục vụ mục đích tự mô tả của nó.


|<image_1>|

# Một số tính năng của GraphQL

Khi khám phá về GraphQL là gì, hãy chắc chắn rằng bạn không bỏ lỡ những đặc điểm nổi bật dưới đây:

**Thay thế cho REST** : Do REST đôi khi gặp khó khăn khi trả về dữ liệu quá nhiều hoặc quá ít, gây ảnh hưởng đáng kể đến hiệu suất ứng dụng. Điều này làm cho việc GraphQL trở thành sự lựa chọn tự nhiên, bởi nó cho phép khai báo thông tin và dữ liệu tại các điểm mà client có thể xác định chính xác những gì họ cần từ API.

**Mutation** : GraphQL cho phép gửi các truy vấn được gọi là mutation, một tính năng có cú pháp tương tự như khi truy vấn dữ liệu (Fetching Data), nhưng bắt đầu bằng một từ khóa cụ thể. Tính năng này được coi là linh hoạt và hữu ích, giúp hệ thống đạt hiệu quả trong việc phân tích và xử lý dữ liệu hoạt động.

|<image_2>|

**Defining Schema và Type System** : GraphQL có một hệ thống đặc biệt để xác định schema của bất kỳ API nào. Hiện tại, toàn bộ type system được liệt kê trong một API cụ thể sử dụng GraphQL Schema Definition Language để thực hiện các thao tác và hoạt động cần thiết cho ứng dụng.

**Realtime updates và Subscription** : Để đáp ứng nhu cầu kết nối với máy chủ và thực hiện các chức năng realtime, GraphQL mang đến một loại khái niệm và thông tin liên quan được gọi là Subscription.

**Fetching data_Query** : GraphQL không phụ thuộc vào client để xác định thông tin cần thiết, mà thay vào đó, nó nắm giữ khả năng nạp dữ liệu và thông tin một cách linh hoạt. Điều này đặt GraphQL vào một vị trí thuận lợi để phát triển và giới thiệu những cải tiến trong quá trình truy xuất dữ liệu. GraphQL có khả năng khắc phục các hạn chế của các phương thức truy xuất truyền thống và tận dụng ưu điểm để xây dựng và mở rộng hệ thống một cách toàn diện.

|<image_3>|

# Các ưu điểm và nhược điểm của GraphQL

Để triển khai GraphQL một cách hiệu quả, bạn cần hiểu rõ cả ưu điểm và nhược điểm của ngôn ngữ này, từ đó tận dụng các ưu thế và đối mặt với nhược điểm để xây dựng hệ thống một cách hiệu quả.

## 3.1. Ưu điểm

Ưu điểm của GraphQL bao gồm:

  * **Tự động tạo nguồn thông tin** : GraphQL schema có khả năng tự động tạo ra một nguồn thông tin đáng tin cậy, giúp quản lý dữ liệu một cách hiệu quả.

  * **Request hiệu quả** : Chỉ với một yêu cầu, client có thể lấy được lượng thông tin cần thiết để giảm thiểu số lượng request, tối ưu hóa giao tiếp giữa client và server.

  * **Kiểm soát và xử lý kiểu dữ liệu** : GraphQL hỗ trợ người dùng trong việc kiểm soát và xử lý kiểu dữ liệu, giảm sai lệch trong giao tiếp giữa các thành phần.

  * **Phát triển API mở rộng** : GraphQL giúp phát triển API mà không ảnh hưởng đến các truy vấn hiện có, tạo sự linh hoạt trong quá trình phát triển ứng dụng.

  * **Tương thích với rest API** : GraphQL có thể hoạt động như một rest API và làm việc tốt với các công cụ API hiện có, không đưa ra yêu cầu đặc biệt về kiến trúc ứng dụng.

  * **Tài liệu chi tiết** : Có sẵn tài liệu dành cho GraphQL, giúp người dùng dễ dàng học tập và tiếp thu kiến thức.


|<image_4>|

## 3.2. Nhược điểm

GraphQL cũng đối mặt với một số thách thức:

  * **Tương thích với Rest API** : Mặc dù có nhiều extension mã nguồn mở cho GraphQL, nhưng không phải tất cả đều hoạt động tốt và tương thích với rest API, điều này có thể tạo ra những thách thức khi tích hợp vào các hệ thống hiện có.

  * **Tăng công việc cho server** : Việc chuyển nhiều truy vấn lên server có thể làm tăng khối lượng công việc, đặc biệt là khi server phải xử lý nhiều yêu cầu phức tạp cùng một lúc, điều này có thể ảnh hưởng đến hiệu suất của server.

  * **Quản lý bộ nhớ đệm phức tạp** : So với rest, việc quản lý bộ nhớ đệm trong GraphQL có thể trở nên phức tạp hơn nhiều, đặc biệt là khi cần xử lý một lượng lớn dữ liệu động.

  * **Bảo trì GraphQL Schema** : Người viết API phải đảm bảo bảo trì đúng GraphQL Schema, điều này đòi hỏi họ phải chịu trách nhiệm và liên tục cập nhật để đảm bảo tính thống nhất của hệ thống.

  * **Chiến lược triển khai đa dạng** : GraphQL có thể phụ thuộc vào cách triển khai để đáp ứng các yêu cầu khác nhau về chiến lược quản lý API, điều này có thể tạo ra sự phức tạp và đa dạng trong việc triển khai.


|<image_5>|

# 4\. Yếu tố quan trọng của GraphQL

GraphQL phát triển dựa trên các thành phần quan trọng như sau:

**Query** : GraphQL sử dụng khái niệm query (truy vấn) để mô tả các yêu cầu dữ liệu từ client. Khi query được định nghĩa, client có thể sử dụng các từ khóa để đặt tên cho các trường dữ liệu. Việc này giúp hỗ trợ cho việc truy xuất các trường lồng nhau cho tất cả các hệ thống ứng dụng một cách linh hoạt. GraphQL đảm bảo rằng client không cần phải lo lắng về nguồn dữ liệu, vì nó quản lý và thực hiện mọi thứ.

**Schema** : GraphQL sử dụng hệ thống kiểu dữ liệu để định nghĩa API một cách chính xác. Tất cả các kiểu dữ liệu trong API đều được xác định bằng schema thông qua GraphQL Schema Definition Language (SDL). Điều này làm cho schema trở thành một công cụ quan trọng đến việc quy ước cách client và server giao tiếp, cùng lúc đó xác định cách client truy cập dữ liệu.

|<image_6>|

**Resolvers** : Để xác định nơi và cách lấy dữ liệu cho các trường của truy vấn, GraphQL sử dụng resolvers. Resolvers giúp GraphQL hiểu rõ nơi dữ liệu cần được truy xuất và làm thế nào nó có thể được thu thập. Điều quan trọng là resolvers không bị hạn chế hoặc ảnh hưởng bởi dữ liệu và thông tin được thu thập, tạo ra sự linh hoạt trong quá trình xử lý dữ liệu.

Tóm lại, GraphQL là một ngôn ngữ truy vấn mạnh mẽ, linh hoạt và hiệu quả, được thiết kế để giải quyết những thách thức gặp phải trong việc truy vấn dữ liệu. Với khả năng tương tác động, khả năng tùy chỉnh linh hoạt, và sự hỗ trợ cho ứng dụng di động và web, GraphQL đã trở thành một công nghệ ngày càng phổ biến trong cộng đồng phát triển phần mềm. Việc hiểu rõ về cách hoạt động của GraphQL là gì, ưu điểm và nhược điểm của nó sẽ giúp nhà phát triển tận dụng toàn bộ tiềm năng của ngôn ngữ này để xây dựng các ứng dụng mạnh mẽ và linh hoạt.

# Public_178

# Dự án

## Dự án là gì

Dự án là tập hợp nhiều hoạt động mang tính duy nhất, phức tạp liên quan đến nhau theo tính kỹ thuật và chuyên môn riêng. Tập hợp hoạt động đó có mục tiêu xác định làm thỏa mãn nhu cầu của đối tượng mà dự án hướng đến và phải hoàn thành mục tiêu đó trong một thời gian cụ thể với một mức ngân sách nhất định. Có thể đưa ra một định nghĩa khái quát về dự án:

Định nghĩa 1.1

Dự án là tổng thể những chính sách, hoạt động và chi phí liên quan với nhau được thiết kế nhằm đạt được những mục tiêu nhất định trong một thời gian nhất định với một kinh phí nhất định.

|<image_4>|

## Đặc điểm của dự án

Từ khái niệm dự án trên đâ

\- Dự án luôn hướng đến một mục tiêu cụ thể.

\- Kết quả dự án là một sản phẩm xác định và duy nhất .

\- Dự án diễn ra trong khoảng thời gian nhất định với một chi phí nhất định.

\- Dự án do một nhóm người (nhóm dự án) thực hiện

\- Dự án đòi hỏi sự phối hợp giữa những hoạt động có liên quan đến nhau

\- Dự án có tính bất ổn và rủi ro.

## Phân loại các dự án.

Dự án có thể được phân loại theo:

\- Lĩnh vực chuyên môn của dự án, như: khoa học tự nhiên, khoa học xã hội, ứng dụng công nghệ, nghệ thuật, thể thao, quản lý hành chính, tài chính ngân hàng, v.v..

\- Mục tiêu về lợi nhuận kinh tế của dự án: các dự án nhằm thu lợi nhuận, là loại thường gặp nhất, và các dự án phi lợi nhuận (các dự án nhân đạo, các dự án nghiên cứu khoa học cơ bản, các dự án vì lợi ích quốc gia hay lợi ích quốc tế, v.v.);

\- Phạm vi tác dụng kinh tế của dự án: các dự án thuộc kinh tế quốc dân và các dự án thuộc kinh tế doanh nghiệp (kể cả trong nông nghiệp).

Sự phân loại này mang tính chất tương đối và dựa trên đặc điểm đặc thù của dự án. Vì nếu xét một cách chi tiết, một dự án thuộc loại này cũng có thể chứa đựng những yếu tố có trong một hay một vài loại khác. Cần nói thêm là, cho dù dự án đó thuộc lĩnh vực nào thì tính kinh tế vẫn luôn là một tiêu chuẩn, bên cạnh các tiêu chuẩn khác, để lựa chọn giải pháp và đánh giá mức độ thành công của một dự án.

## Đánh giá kết quả của dự án.

### Dự án được xem là thành công khi:

\- Đạt được các mục đích đã đặt ra

\- Được thực hiện và hoàn thành trong thời gian đã định hoặc cho phép, và tổng chi phí không vượt quá giá trị đã định

### Dự án bị xem là không thành công (thất bại) khi:

\- Một hay nhiều mục đích chủ yếu đã đặt ra không đạt được; hoặc

\- Mốc thời gian hoàn thành bị vi phạm nghiêm trọng; hay

\- Tổng chi phí vượt quá giới hạn cho phép.

### **Các nguyên nhân chính dẫn đến sự thất bại của một dự án (số liệu thống kê chỉ có tính cá biệt ở một số dự án, chỉ để tham khảo)**

\- Quản lý dự án kém (31%).

\- Thiếu thông tin (21%).

\- Không rõ mục tiêu (18%).

\- Không lường trước được phạm vi rộng lớn và tính phức tạp của công việc (17%).

\- Các lý do khác (công nghệ, thiết bị, nhân sự,…) (12%).
<table>
<colgroup>
<col/>
</colgroup>
<thead>
<tr>
<th><p>|<image_1>|</p>
<p>Hình 1.1. Các nguyên nhân chính dẫn đến sự thất bại của một dự
ám</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

Khi một dự án do gặp nhiều nguyên nhân khác nhau dẫn đến thất bại thì sẽ gây ra những tổn thất vô cùng lớn, chẳng hạn:

\- Dự án xử lý thông tin tại Sea Games 22 (2003) của Việt Nam dự kiến kinh phí là 15 tỷ VND, nhưng mới đến Tháng 6/2003 số tiền phải bỏ ra là gần 90 tỷ đồng.

\- Năm 1995, các công ty Mỹ đã phải chi 81 tỷ USD cho những dự án bị hủy bỏ, 59 tỷ USD đầu tư thêm cho các dự án không đúng kế hoạch.

\- Olympic 2004 tại Hy Lạp: dự kiến kinh phí là 2 tỷ euro, nhưng phải chi tới 12 tỷ euro (cao hơn tới 10 tỷ so với dự kiến)

Những dự án trên đây được coi là thất bại về mặt tài chính, nhưng vẫn được đánh giá là thành công trên những mục tiêu khác.

Trên thực tế, một dự án ít khi thành công hay thất bại tuyệt đối, tức là đạt được thành công hoặc thất bại trên mọi tiêu chí đã nêu. Mức độ thành công hay thất bại của dự án tuỳ thuộc vào việc đạt được hay không đạt được những yếu tố thành công nào, cũng như mức độ đạt /không đạt, trong số các yếu tố liệt kê ở trên. Việc đánh giá về mức độ thành công này có tính tương đối, vì nó phụ thuộc vào cách nhìn nhận và đánh giá của những người giữ vai trò chủ đạo đối với dự án.

## Những yếu tố quyết định kết quả dự án

Bốn yếu tố quan trọng quyết định thành công của một dự án là:

\- Có kế hoạch tốt, khả thi, được chọn lọc và hoạch định chi tiết.

\- Giám sát có hiệu quả. Có khả năng kiểm soát và điều khiển kịp thời mọi sai lệch so với kế hoạch đã đặt ra.

\- Có kế hoạch đề phòng rủi ro. Xác định được các yếu tố rủi ro chủ yếu và các giải pháp phòng ngừa, giảm thiểu ảnh hưởng cụ thể.

\- Đánh giá dự án đúng, đầy đủ và chuẩn xác.

Trong thực tế, yếu tố thứ nhất và thứ hai thường là các nguyên nhân trực tiếp quyết định thành công hay thất bại của dự án. Tuy nhiên, yếu tố thứ tư, dù là nguyên nhân gián tiếp, lại có tác động lâu dài đến sự thành công hay thất bại của các dự án, không chỉ dự án cụ thể đang bàn tới, mà còn của các dự án khác mà tổ chức hay doanh nghiệp tiến hành. Yếu tố thứ ba sẽ trở thành yếu tố quyết định khi một hay một số điều kiện cực đoan không có lợi cho dự án xảy ra.

Ví dụ, một dự án với một ứng dụng có nhiều dữ liệu quan trọng, nếu không có biện pháp sao lưu dữ liệu thường xuyên (phòng khi rủi ro) thì nếu có sự cố nặng xảy ra, dẫn đến việc mất hoặc không lấy được dữ liệu ra khỏi CSDL, doanh nghiệp có thể sẽ phải tốn một khoản chi phí khổng lồ để khôi phục lại, thậm chí có nguy cơ mất toàn bộ các dữ liệu đã lưu trữ.

Mục tiêu của quản lý dự án là đảm bảo dự án được thực hiện thành công một cách tốt nhất. Tức là đảm bảo được tốt nhất 4 yếu tố thành công đã nêu.

Có một nguyên lý nổi tiếng mà các nhà quản lý dự án nên ghi nhớ, đó là “luật Murphy” , phát biểu rằng: “Cái gì có thể hỏng hóc sẽ hỏng hóc”. Cùng với các kiến thức cơ sở về quản lý dự án, hiểu đúng và luôn ghi nhớ định luật này trong quá trình thực hiện sẽ giúp chúng ta đạt được những yếu tố dẫn đến thành công của dự án.

## Các giai đoạn của một dự án

Đối với một dự án, quá trình triển khai bao gồm những giai đoạn khác nhau, mang những đặc điểm liên quan đến công việc quản trị dự án khác nhau. Đáng kể nhất là sự khác nhau giữa giai đoạn đầu tư và giai đoạn khai thác (và có thể đầu tư tiếp)

Hình 1.2 thể hiện 2 giai đoạn của một dự án.

Trong đó, giai đoạn đầu tư (tb – to ) là giai đoạn thực hiện mọi công việc đầu tư cần thiết cho giải pháp mà dự án đã lựa chọn. Chi phí cho công việc này được gọi là chi phí đầu tư. Nó có thể bao gồm các chi phí về: xây dựng nhà xưởng, văn phòng; mua và lắp đặt trang thiết bị cũng như vật tư cần thiết ban đầu để có thể đưa thiết bị vào hoạt động; v.v... Giai đoạn này, trong phân tích luồng tiền dự án sẽ chỉ có “chi”.

Giai đoạn khai thác (và có thể đầu tư tiếp to – tk) là giai đoạn những đầu tư trong giai đoạn trước được khai thác để đạt được các mục tiêu của dự án. Trong giai đoạn này, về mặt tài chính,dự án sẽ vừa có “thu”, vừa có “chi”. Các chi phí đầu tư nếu có trong giai đoạn này sẽ được coi là các khoản “chi” trong phân tích luồng tiền. Còn trong tính toán giá thành sản phẩm chúng sẽ được cộng gộp vào với tổng chi phí đầu tư trong giai đoạn đầu tư để tạo thành chi phí đầu tư tổng cộng của dự án.
<table>
<colgroup>
<col/>
</colgroup>
<thead>
<tr>
<th><p>|<image_2>|</p>
<p>Hình 1.2. Hai giai đoạn của một dự án</p></th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

Một dự án không bắt buộc phải có cả hai giai đoạn đầu tư và khai thác mà rất có thể chỉ có một trong hai giai đoạn, đặc biệt là khi nó là một dự án cấu thành của một dự án lớn, hay là dự án kế tiếp hoặc khởi đầu của một hay nhiều dự án khác. Hai giai đoạn này cũng có thể đan vào nhau trong một khoảng thời gian nhất định.

**Thí dụ** : Dự án đưa một phần mềm mới ra thị trường của một công ty phần mềm. Đối với công ty phần mềm thì đây có thể là một dự án lớn, trong đó mỗi phiên bản là một dự án cấu thành bao gồm cả hai giai đoạn đầu tư: hoàn tất một phiên bản dưới dạng sản phẩm thương mại, và giai đoạn khai thác: tung sản phẩm ra thị trường.

# Quản lý dự án

## Các khái niêm quản lý dự án

Quản lý dự án là ngành khoa học nghiên cứu về việc lập kế hoạch, tổ chức và quản lý, giám sát quá trình phát triển của dự án nhằm đảm bảo cho dự án hoàn thành đúng thời gian, trong phạm vi ngân sách đã được duyệt, đảm bảo chất lượng, đạt được mục tiêu cụ thể của dự án và các mục đích đề ra.

Mục tiêu cơ bản của việc quản lý dự án thể hiện ở chỗ các công việc phải được hoàn thành theo yêu cầu và bảo đảm chất lượng, trong phạm vi chi phí được duyệt, đúng thời gian và giữ cho phạm vi dự án không thay đổi.

### Quản lý dự án là tập hợp các công việc được thực hiện bởi một tập thể (Nhóm DA) nhằm đạt được một kết quả như dự kiến, trong thời gian dự kiến, với một kinh phí dự kiến.

### Nhóm DA (ban QLDA): là một tập thể thực hiện các công việc quản lý DA. Để dự án thành công, các thành viên dự án phải đảm bảo:

\- Lựa chọn quy trình phù hợp để đạt được mục tiêu của dự án

\- Đáp ứng được nhu cầu và mong đợi của các bên liên quan.

\- Cân bằng được các yêu cầu (nhân tố) cạnh tranh trong dự án như: phạm vi công việc, ngân sách, tiến độ, chất lượng, rủi ro, thay đổi. Tùy theo quy mô của từng dự án mà các mỗi giai đoạn lại có thể gồm những quy trình nhỏ hơn.

### Tầm quan trọng của công tác QLDA:

\- Giúp tổ chức và tiếp cận triển khai dự án

\- Xây dựng một lịch trình khả thi và đáng tin cậy để thực hiện dự án

\- Theo dõi được tiến độ và kiểm soát được chất lượng dự án

\- Phát hiện ra các khâu cần tập trung nguồn lực

\- Phát hiện sớm các rủi ro để giải quyết (trước khi quá muộn!)

\- Tiết kiệm thời gian và ngân sách

Thách thức chính của quản lý dự án là phải đạt được tất cả các mục tiêu đề ra của dự án trong điều kiện bị khống chế bởi phạm vi công việc (khối lượng và các yêu cầu kỹ thuật), thời gian hoàn thành (tiến độ thực hiện) và ngân sách (mức vốn đầu tư) cho phép.

## Các giai đoạn của QLDA:

Mỗi dự án đều bao gồm 5 giai đoạn sau đây theo tiêu chuẩn quản lý dự án của PMI:
<table>
<colgroup>
<col/>
</colgroup>
<thead>
<tr>
<th>|<image_3>|</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

Vẽ lại sơ đồ:

# Public_179

# Kiểm thử tự động là gì?

Định nghĩa: Kiểm thử tự động là một kỹ thuật kiểm thử phần mềm thực hiện bằng cách sử dụng các công cụ kiểm thử tự động đặc biệt để thực hiện một bộ trường hợp kiểm thử. Về cơ bản, đây là một bài kiểm tra để kiểm tra lại xem thiết bị hoặc phần mềm có thực hiện chính xác như theo thiết kế hay không. Trong quá trình phát triển sản phẩm, kiểm thử tự động sẽ kiểm tra để tìm ra các lỗi, các sai sót hay bất kỳ vấn đề phát sinh nào khác. Kiểm thử tự động được sử dụng cho các công việc lặp đi lặp lại cũng như các công việc khó có thể thực hiện bằng kiểm thử thủ công.

# Tầm quan trọng của kiểm thử tự động

  * Ngày nay có rất nhiều dự án/doanh nghiệp không có đủ thời gian và nguồn nhân lực cho việc kiểm thử thủ công. Tự động hoá trở thành lựa chọn hàng đầu của họ vì tính chính xác, nhanh chóng, hiệu quả và không tốn nhiều nguồn lực. Điều này thực sự thúc đẩy năng suất của các dự án/doanh nghiệp.

  * Các chu kỳ phát triển phần mềm luôn yêu cầu việc kiểm tra lặp đi lặp lại. Kiểm thử tự động sẽ giúp cho việc này trở nên khả thi mà không làm mất đi nguồn lực của các thành viên trong nhóm dự án/doanh nghiệp. Nó cũng có thể mang lại kết quả chính xác và đáng tin cậy hơn so với việc chỉ kiểm tra thủ công. Ngoài ra sản phẩm còn được đảm bảo để sẵn sàng đưa ra thị trường hoặc chuyển sang giai đoạn phát triển tiếp theo. Việc này mang lại cho nhóm dự án động lực để tiếp tục phát triển sản phẩm của mình.

  * Quan trọng hơn cả, kiểm thử tự động giúp ích cho việc phát triển sản phẩm bởi khi ứng dụng kiểm thử tự động vào chu trình sản xuất, nó sẽ tạo tiền đề cho sự phát triển liên tục sau khi sản phẩm ra mắt. Nhờ kiểm thử tự động doanh nghiệp/nhóm dự án có thể làm việc trên nhiều phần mềm và sản phẩm hơn, ngay cả khi lượng thành viên trong nhóm không thay đổi. Điều này có nghĩa là họ không chỉ hoàn thiện sản phẩm cuối, mà họ còn luôn tạo ra thêm những phần mềm/sản phẩm mới.


# Quy trình kiểm kiểm thử tự động

Một quy trình kiểm thử tự động thường trải qua những bước cơ bản như sau:

B1: Lựa chọn công cụ kiểm thử tự động

B2: Xác định phạm vi

B3: Lập kế hoạch

B4: Thiết kế kịch bản kiểm thử tự động

B5: Phát triển kịch bản kiểm thử tự động

B6: Thực thi kiểm thử (Execution)

B7: Cập nhật và Bảo trì

## Bước 1: Lựa chọn công cụ kiểm thử

Việc lựa chọn công cụ kiểm thử tự động phù hợp thường phụ thuộc vào Loại của Ứng dụng đang được kiểm tra (Application Under Test) và Môi trường mà ứng dụng đó sẽ chạy.

Ví dụ: Nếu ứng dụng của bạn là ứng dụng Web chạy trên Web browser của máy tính cá nhân (Desktop), thì Selenium Webdriver có thể là lựa chọn phù hợp. Nhưng nếu ứng dụng Web của bạn có cả phiên bản chạy được trên browser của các thiết bị Mobile, thì có thể bạn sẽ cần thêm 1 công cụ có thể hỗ trợ tạo kịch bản test chạy được cho cả các Browsers trên Mobile nữa. Khi đó Appium có thể là một lựa chọn phù hợp. Hiện tại trên thị trường có đa dạng các loại công cụ kiểm thử tự động, từ miễn phí (Open Source, Freeware), đến có phí (License). Chẳng hạn Opensource có thể kể đến như: Selenium IDE, Selenium WebDriver, Appium, Cucumber, hay có License như: Postman, Katalon, akaAT, Ranorex, Tosca Tricentis, Testcomplete, HP-UFT. Các công cụ mã nguồn mở thường yêu cầu bạn phải có kỹ năng làm việc với ngôn ngữ lập trình tương đối thuần thục để có thể đọc hiểu được framework và viết kịch bản dưới dạng test script để tận dụng được sức mạnh của các chức năng mà thư viện công cụ đó cung cấp. Vì thế cũng tốn nhiều thời gian và công sức hơn mới tạo được các kịch bản như mong muốn. Đổi lại, nó cho bạn sự tự do nhất định khi được lựa chọn làm việc với ngôn ngữ lập trình mà bạn yêu thích. Ngược lại, các công cụ có trả phí (License) thường cung cấp giao diện trực quan cùng các tiện ích và nhiều tính năng hỗ trợ tối đa cho người dùng có thể tạo ra kịch bản nhanh chóng, đơn giản mà không phải code, chỉ phải kéo thả, Record và config. Nó giúp bạn tập trung vào việc quản lý Logic của ứng dụng và chất lượng của test case. Là công cụ có License nên bạn hoặc công ty sẽ phải trả phí hàng năm cho việc tiếp tục sử dụng công cụ và nhận được sự hỗ trợ từ nhà cung cấp công cụ đó. Vậy nên để lựa chọn đúng bạn cần tìm hiểu về các loại công cụ khác nhau và cách nó có thể mang lại lợi ích cho công việc kiểm thử của bạn.

|<image_1>|

## Bước 2: Xác định phạm vi Kiểm thử tự động

Trong bước này, bạn sẽ xem xét khoanh vùng các luồng nghiệp vụ test phù hợp cho việc tự động hóa nó, chuẩn bị dữ liệu và môi trường diễn ra kiểm thử. Dưới đây là một số yếu tố cần xem xét khi xác định phạm vi thử nghiệm tự động hóa của bạn: Các tính năng chính, quan trọng của ứng dụng; Các trường hợp kiểm thử có nhiều dữ liệu; Các tính năng dùng chung (common) trên ứng dụng; Những vùng khả thi về kỹ thuật mà công cụ đáp ứng được; Những nghiệp vụ hay được tái sử dụng; Mức độ phức tạp của các test cases; Khả năng sử dụng các trường hợp kiểm thử giống nhau để test trên nhiều trình duyệt (với trường hợp kiểm thử ứng dụng web)

## Bước 3: Lập kế hoạch

Trong giai đoạn này trước hết bạn sẽ xây dựng bản Kế hoạch bao gồm: Thông tin lộ trình thực hiện (Master Schedule); Effort và thời gian cho việc thiết kế Framework; Effort và thời gian cho việc viết kịch bản; Effort cho việc thực thi và báo cáo; Effort cho bảo trì sau phát triển; Các rủi ro phát sinh

## Bước 4 + Bước 5: Thiết kế và Phát triển

Ở giai đoạn này, các thành viên của nhóm sẽ bắt tay vào thiết kế các kịch bản tự động và dùng công cụ được chọn để tạo ra các script tự động hóa. Các công việc điển hình như: Thiết kế Framework và các tính năng của nó; Thiết kế các kịch bản tự động; Viết script và kiểm tra tính ổn định của script; Review tính đúng đắn của script so với thiết kế

## Bước 6: Thực thi kiểm thử (Execution)

Đây là giai đoạn áp chót trong quy trình kiểm thử tự động hóa. Khi bạn đã tạo xong các script tự động của mình, đã đến lúc chạy các script này để thực hiện kiểm thử ngay trên ứng dụng. Kết quả của việc thực thi các script thường sẽ được tổng hợp vào một báo cáo cho biết số lượng test cases PASS/FAIL và kèm theo các bằng chứng (Evidence) ghi lại hình ảnh/trạng thái tại thời điểm xảy ra các lỗi được tìm thấy.

## Bước 7: Bảo trì

Khi phần mềm cần test (Application Under Test) được cập nhật thêm tính năng mới hoặc chỉnh sửa, thì bộ script sẽ được chạy để kiểm tra xem mức độ ảnh hưởng của các tính năng mới tới các tính năng hiện tại, liệu chúng có còn hoạt động đúng hay không. Và khi phần mềm có cập nhật, những thay đổi trên phần mềm có thể làm cho bộ script không còn đúng. Đó là lúc bạn cần có hoạt động xem xét chỉnh sửa, điều chỉnh lại script cho phù hợp với những thay đổi , cũng như thường xuyên nâng cấp nhằm nâng cao hiệu quả của các script tự động ở mỗi chu kỳ phát hành tiếp theo

# Các loại kiểm thử tự động và cách apply vào dự án

Kiểm thử tự động giúp các nhóm dự án và tổ chức tự động kiểm thử phần mềm/sản phẩm của mình nhằm giảm thiểu tối đa sự can thiệp của con người, từ đó dự án đạt được tốc độ, độ chính xác và hiệu quả cao hơn. Chúng ta có thể phân các loại kiểm thử tự động như sau:

  * Unit Testing

  * Linear Testing

  * Keyword Driven Testing

  * Data Driven Testing

  * Behavior Driven Testing

  * Performance Testing


Để có thể lựa chọn được công cụ và loại hình kiểm thử tự động phù hợp, Bạn hãy tham khảo các gợi ý sau:

## Tìm hiểu nhu cầu của dự án và nhu cầu kiểm thử

Việc cân nhắc liệu "kiểm thử tự động" có phải là hướng đi phù hợp cho nhóm dự án của bạn hay không là rất quan trọng. Vì không phải tất cả các nhóm QA đều cần tự động hóa để đẩy nhanh quá trình thử nghiệm của họ. Kiểm thử thủ công vẫn đóng 1 vai trò rất quan trọng trong quy trình sản xuất phần mềm/sản phẩm. Vì vậy, chỉ thực hiện kiểm thử tự động khi:

  * Dự án có nhiều trường hợp kiểm thử lặp đi lặp lại cần thực hiện

  * Khi có các bài kiểm tra hồi quy thường xuyên

  * Khi nhóm dự án phải mô phỏng một số lượng lớn người dùng để kiểm tra hiệu suất

  * Khi giao diện người dùng ổn định

  * Khi các chức năng quan trọng không thể chỉ dựa vào thử nghiệm thủ công


## Tiêu chí đánh giá công cụ kiểm thử tự động

Kiểm thử tự động mang tính kỹ thuật cao hơn nhiều so với kiểm thử thủ công. Với nhiều công cụ kiểm thử tự động, đặc biệt là phần mềm mã nguồn mở, người kiểm thử phải có đủ kiến thức lập trình để viết và thực thi các kịch bản kiểm thử. Rào cản kỹ thuật này dường như là thách thức lớn nhất trong việc áp dụng tự động hóa thử nghiệm cho các nhóm QA có nền tảng CNTT hạn chế. Tuy nhiên, ngày nay các công cụ kiểm tra không yêu cầu code trong quá trình thực thi đã được chứng minh là một giải pháp đầy hứa hẹn cho vấn đề này.

### Ngân sách nhóm dự án là bao nhiêu? 

Thực tế chi phí để thực thi kiểm thử tự động khá cao. Nhưng đổi lại, nó sẽ mang lại tỷ suất hoàn vốn tích cực cho nhóm và doanh nghiệp về lâu dài nếu ngân sách được tính toán kỹ lưỡng. Khi nắm được ngân sách hoạt động, bạn sẽ dễ dàng hơn trong việc chọn phần mềm thích hợp với dự án của mình.

### Cần tìm kiếm những tính năng gì? 

Mặc dù yêu cầu của các nhóm dự án là khác nhau, nhưng vẫn có một số yếu tố chính mà bạn luôn phải cân nhắc khi chọn một công cụ kiểm thử tự động. Cụ thể:

  * Nền tảng được hỗ trợ

  * Ứng dụng được áp dụng theo thử nghiệm

  * Ngôn ngữ lập trình

  * Khả năng tích hợp CI/CD

  * Chức năng báo cáo


### Khả năng tích hợp như thế nào? 

Công cụ kiểm thử tự động được chọn phải có khả năng tích hợp CI/CD và các nền tảng bên ngoài để đảm bảo tính liên tục của thử nghiệm. Tích hợp mạnh mẽ và toàn diện cũng cho phép bạn quản lý thử nghiệm và cộng tác nhóm tốt hơn.

# Public_180

# Khái niệm Performance Test là gì?

Performance Test là một quy trình hoặc phương pháp được sử dụng để đánh giá hiệu suất và khả năng chịu tải của một ứng dụng hoặc hệ thống. Mục đích của việc thực hiện Performance Test nhằm xác định các chỉ số hiệu suất như thời gian phản hồi, tải trọng tối đa mà hệ thống có thể chịu được.

|<image_1>|

Đồng thời, chương trình phát hiện và giải quyết các vấn đề hiệu suất ngẫu nhiên xuất hiện trong quá trình sử dụng ứng dụng hoặc hệ thống. Performance Test thường được thực hiện bằng cách tạo ra một phương án giả lập để mô phỏng các hoạt động thực tế của người dùng. Các chỉ số hiệu suất chính được đánh giá bao gồm:

  * Thời gian phản hồi: Thời gian mà hệ thống mất để phản hồi sau khi nhận một yêu cầu từ người dùng.

  * Tải trọng tối đa: Sức chứa tối đa của hệ thống, tức là số lượng yêu cầu mà hệ thống có thể xử lý trong một khoảng thời gian nhất định mà vẫn đáp ứng được yêu cầu hiệu suất mong muốn.

  * Băng thông: Khả năng truyền dữ liệu của hệ thống, đo bằng số lượng dữ liệu được truyền qua hệ thống trong một khoảng thời gian nhất định.

  * Sự ổn định: Khả năng của hệ thống chịu được tải trọng liên tục trong một thời gian dài mà không gây ra sự sụp đổ hay giảm hiệu suất.


Thông qua Performance Test, người ta có thể đánh giá và cải thiện hiệu suất của ứng dụng hoặc hệ thống. Từ đó đảm bảo rằng chương trình có thể hoạt động một cách ổn định và đáp ứng được nhu cầu của người dùng.

# Phân biệt các loại Performance Test

Trên thực tế có nhiều loại Performance Testing khác nhau trong quy trình kiểm thử phần mềm. Dưới đây là một số loại phổ biến:

## Load Testing

Load Testing kiểm tra hiệu suất của hệ thống khi chịu đựng tải trọng cao. Điều này đảm bảo rằng hệ thống có thể xử lý một lượng lớn yêu cầu từ người dùng trong khi duy trì hiệu suất mong muốn. Load Testing thường xác định ngưỡng tải trọng tối đa mà hệ thống có thể chịu được.

|<image_2>|

## Stress Testing

Stress Testing đo và đánh giá khả năng chịu đựng của hệ thống khi gặp tải trọng ngoại lệ, vượt quá giới hạn bình thường. Mục tiêu của hoạt động này chính là xác định điểm yếu và giới hạn của hệ thống.

## Soak Testing

Soak Testing là quá trình kiểm tra hiệu suất của hệ thống trong thời gian dài. Yếu tố này đánh giá sự ổn định và khả năng chịu được của hệ thống trong môi trường hoạt động liên tục.

## Spike Testing

Spike Testing đánh giá khả năng của hệ thống để xử lý một tải trọng cao đột ngột. Kiểm tra này đảm bảo rằng hệ thống không bị sụp đổ trong trường hợp có một số lượng lớn người dùng truy cập cùng một lúc.

## Endurance Testing

Endurance Testing kiểm tra khả năng hoạt động của hệ thống trong điều kiện chịu tải trọng và liên tục kéo dài thời gian. Mục tiêu của việc này nhằm xác định khả năng hệ thống duy trì hiệu suất mong muốn trong môi trường hoạt động thực tế.

|<image_3>|

## Scalability Testing

Scalability Testing đánh giá khả năng hệ thống mở rộng và tăng cường mức độ xử lý khi tải trọng tăng lên. Kiểm tra này giúp đảm bảo rằng hệ thống có thể mở rộng để đáp ứng nhu cầu người dùng tăng lên theo thời gian.

Mỗi loại Performance Testing phục vụ mục tiêu kiểm tra hiệu suất và khả năng chịu đựng của hệ thống trong các tình huống khác nhau. Việc sử dụng các loại kiểm tra phù hợp sẽ đảm bảo rằng hệ thống hoạt động ổn định. Từ đó đáp ứng hiệu suất mong muốn trong mọi tình huống.

# Những vấn đề về hiệu năng trên hệ thống

## Thời gian phản hồi

Đây là khoảng thời gian mà hệ thống cần để phản hồi sau khi nhận một yêu cầu từ người dùng. Thời gian phản hồi dài có thể làm giảm trải nghiệm người dùng và gây ra cảm giác không hài lòng. Nếu hệ thống không có đủ băng thông thì việc truyền dữ liệu có thể rơi vào tình trạng bị chậm hoặc bị chặn.

|<image_4>|

## Tải trọng và khả năng chịu đựng

Biểu thị khả năng hệ thống để xử lý số lượng yêu cầu từ người dùng mà không gây giảm hiệu suất hay sụp đổ. Nếu tải trọng vượt quá khả năng chịu đựng của hệ thống thì hiệu suất có thể giảm đi hoặc gặp sự cố.

## Hiệu suất hoạt động

Yếu tố này cho thấy tính hiệu quả của các chức năng và quá trình hoạt động trong hệ thống. Nếu một phần hoặc toàn bộ quá trình hoạt động chậm sẽ ảnh hưởng đến hiệu suất của hệ thống. Cách sử dụng và quản lý tài nguyên như bộ nhớ, bộ xử lý và dung lượng đĩa thường ảnh hưởng đến yếu tố này. Nếu tài nguyên không được quản lý tốt thì hệ thống có thể gặp sự cố hoặc hiệu suất giảm đi.

## Các vấn đề sản phẩm

Một số lỗi hoặc vấn đề trong mã nguồn, cấu trúc dữ liệu, cơ sở dữ liệu hoặc cấu hình có thể gây ra vấn đề về hiệu suất. Việc kiểm tra và giải quyết những vấn đề này vô cùng quan trọng. Từ đó mà người dùng có thể đảm bảo hệ thống hoạt động một cách mượt mà và hiệu quả hơn.

# Hướng dẫn cách kiểm thử hiệu năng cơ bản

Quy trình kiểm thử hiệu năng có tác dụng đảm bảo hệ thống hoạt động một cách ổn định. Từ đó đáp ứng được yêu cầu sử dụng hiệu năng của người dùng

|<image_5>|

## Xác định yêu cầu hiệu năng

Đầu tiên, bạn cần xác định các yêu cầu hiệu năng cụ thể cho hệ thống. Điều này bao gồm các hoạt động như: xác định thời gian phản hồi tối đa, tải trọng tối đa, số lượng người dùng đồng thời và các yêu cầu khác liên quan đến hiệu năng của hệ thống.

## Thiết kế kịch bản kiểm thử

Tạo ra các kịch bản kiểm thử phù hợp với yêu cầu hiệu năng đã xác định. Các kịch bản này nên phản ánh các hoạt động thực tế mà người dùng thực hiện trên hệ thống. Ví dụ: thêm sản phẩm vào giỏ hàng, gửi yêu cầu truy vấn cơ sở dữ liệu, đăng nhập vào hệ thống và tìm kiếm thông tin.

## Chuẩn bị môi trường kiểm thử

Chuẩn bị môi trường để thực hiện kiểm thử hiệu năng. Trong đó bao gồm những việc cài đặt và cấu hình các máy chủ, cơ sở dữ liệu và phần mềm kiểm thử hiệu năng.

## Thực hiện kiểm thử

Chạy các kịch bản kiểm thử trên môi trường đã chuẩn bị và thu thập dữ liệu hiệu năng. Đo và ghi lại các chỉ số hiệu năng như thời gian phản hồi, tải trọng và băng thông. Các công cụ kiểm thử hiệu năng như Apache jmeter hoặc Loadrunner có thể được sử dụng trong quy trình này.

|<image_6>|

## Phân tích kết quả

Phân tích dữ liệu hiệu năng thu thập được từ quá trình kiểm thử. Đánh giá hiệu suất thực tế của hệ thống, xác định kỹ thuật và vấn đề hiệu suất tiềm tàng.

## Tối ưu hóa hiệu năng

Dựa trên kết quả phân tích, thực hiện các biện pháp cải thiện hiệu suất cần thiết. Hoạt động này bao gồm việc tinh chỉnh cấu hình hệ thống, tối ưu hóa mã nguồn và cải thiện quy trình xử lý.

## Lặp lại kiểm thử

Chạy lại quy trình kiểm thử sau khi đã thực hiện các biện pháp tối ưu hóa. Tiếp tục thu thập dữ liệu và so sánh với kết quả trước đó để xác minh sự cải thiện trong hiệu suất.

## Báo cáo kết quả

Tạo báo cáo chi tiết về quá trình kiểm thử và kết quả hiệu năng. Báo cáo này nên gồm thông tin về các vấn đề phát hiện được, giải pháp tối ưu và những khuyến nghị để cải thiện hiệu suất của hệ thống.

# Giới thiệu các công cụ Performance Test

## Apache jmeter

Là một công cụ mã nguồn mở và miễn phí, Jmeter được sử dụng rộng rãi để thực hiện kiểm thử hiệu năng. Hệ thống hỗ trợ tạo kịch bản kiểm thử, quản lý, thực hiện quá trình thu thập dữ liệu và phân tích kết quả.

|<image_7>|

## Loadrunner

Bộ công cụ có trả phí do hãng Micro Focus phát triển, Loadrunner cung cấp khả năng kiểm tra hiệu năng, tải trọng và tư duy về quy mô. Phiên bản này hỗ trợ nhiều loại ứng dụng và có giao diện đơn giản giúp người dùng dễ sử dụng.

## Gatling

Đây là một công cụ kiểm thử hiệu năng mã nguồn mở và miễn phí. Gatling sử dụng Scala để tạo ra kịch bản kiểm thử và có khả năng xử lý tải trọng lớn. Chương trình cung cấp tính năng thu thập dữ liệu và phân tích kết quả hiệu năng.

## Webload

Webload là một công cụ kiểm thử hiệu năng có trả phí do hãng Radview Software phát triển. Phần mềm cung cấp khả năng thực hiện kiểm thử hiệu năng trên các ứng dụng web, di động và thiết bị iot. Webload hỗ trợ kiểm thử với tải lớn và cung cấp các tính năng phân tích hiệu năng.

|<image_8>|

## Apache Bench

Apache Bench là một công cụ kiểm thử hiệu năng miễn phí được cung cấp kèm theo bộ phần mềm máy chủ web Apache. Chương trình cung cấp khả năng đánh giá hiệu suất của máy chủ bằng cách gửi yêu cầu HTTP không đồng thời.

## Siege

Siege là một công cụ kiểm thử hiệu năng miễn phí và mã nguồn mở. Hệ thống có thể đánh giá hiệu suất của máy chủ dựa trên tải trọng và số lượng yêu cầu đồng thời.

Những công cụ này có thể hỗ trợ trong việc tạo và thực hiện kịch bản kiểm thử, thu thập dữ liệu hiệu năng và phân tích kết quả. Tuy nhiên, việc lựa chọn công cụ phụ thuộc vào yêu cầu cụ thể của dự án và tiêu chuẩn của nhóm kiểm thử.

# Public_181

Kafka là một trong những nền tảng xử lý luồng dữ liệu phổ biến nhất hiện nay, hàng nghìn tổ chức hàng đầu trên thế giới đang sử dụng Kafka cho các đường ống dẫn dữ liệu hiệu suất cao, phân tích luồng hay tích hợp dữ liệu.

# Kafka là gì?

Apache Kafka là một nền tảng phát trực tuyến sự kiện phân tán mã nguồn mở, được phát triển ban đầu bởi LinkedIn vào năm 2011 như một message broker thông lượng cao, để sử dụng trong chính hệ thống của mình. Sau đó, Kafka đã trở thành dự án mã nguồn mở và được chuyển giao cho Apache Software Foundation.

|<image_1>|

Kafka được thiết kế để xử lý dữ liệu streaming real-time, tức là xử lý các luồng dữ liệu không ngừng trôi qua. Các dữ liệu này có thể bao gồm cả sự kiện hay bản ghi dữ liệu, và chúng có thể được tạo ra từ hàng tỷ nguồn khác nhau như thiết bị cảm biến, ứng dụng web, hệ thống máy chủ và nhiều nguồn dữ liệu khác.

Các ứng dụng của Kafka rất đa dạng, ví dự như việc lưu trữ dữ liệu, phân tích dữ liệu thời gian thực, tích hợp hệ thống hoặc xây dựng các ứng dụng phản hồi dữ liệu trong thời gian thực. Kafka cho phép các nhà phát triển xây dựng, triển khai các ứng dụng xử lý dữ liệu với tốc độ cao, đáng tin cậy và chính xác.

Hiện nay, Kafka là một trong những nền tảng stream dữ liệu phân tán được sử dụng rộng rãi nhất, khi nó có khả năng nhập và xử lý hàng nghìn tỷ bản ghi mỗi ngày mà không gặp vấn đề trễ hiệu suất quá nhiều. Các tổ chức hàng đầu như Target, Microsoft, AirBnB và Netflix đều sử dụng Kafka để cung cấp trải nghiệm theo thời gian thực và dữ liệu chính xác cho khách hàng của họ.

|<image_2>|

# Những khái niệm liên quan

Khi làm việc với Kafka, có một số khái niệm cơ bản sau mà bạn nên để ý:

  * Producer: Các ứng dụng tạo ra dữ liệu và gửi các thông điệp định dạng tới máy chủ Kafka. Dữ liệu này thường được gửi dưới dạng mảng byte tới máy chủ.

  * Cluster: Một tập hợp các máy chủ, trong đó mỗi tập hợp được gọi là một Broker.

  * Broker: Một máy chủ Kafka, đóng vai trò là cầu nối giữa Producer và Consumer để họ có thể trao đổi thông điệp với nhau.

  * Partition: Trong trường hợp một topic nhận nhiều hơn số lượng thông điệp quy định trong một khoảng thời gian, chúng ta có thể chia topic này thành các partition. Các partition được chia sẻ giữa các máy chủ trong Cluster để xử lý các thông điệp này.

  * Consumer: Các ứng dụng đọc các thông điệp từ một partition bất kỳ trong Kafka. Consumer cho phép người dùng mở rộng số lượng thông điệp được sử dụng tương tự như cách Producer cung cấp các thông điệp.

  * Consumer Group: Các nhóm Consumer tổ chức lại với nhau, sử dụng cho một topic cụ thể. Mỗi consumer trong một nhóm chỉ đọc các thông điệp từ một partition duy nhất.

  * Topic: Dữ liệu được truyền trong Kafka theo dạng chủ đề (topic). Khi cần truyền dữ liệu cho các ứng dụng riêng biệt, các topic khác nhau sẽ được tạo ra tương ứng.

  * Zookeeper: Được sử dụng trong việc quản lý, bố trí và triển khai các Broker, đảm bảo tính liên tục của hệ thống Kafka.


|<image_3>|
Ngoài các khái niệm cơ bản này, còn có một số khái niệm khác liên quan đến Kafka mà bạn có thể quan tâm khi làm việc với nền tảng:

  * Offset: Là một con số duy nhất mô tả vị trí của một record trong một partition. Consumer sẽ duy trì offset để theo dõi việc xử lý của mình trong partition.

  * Replication: Quá trình sao chép các partition từ một broker sang các broker khác trong một cluster.

  * Leader và Follower: Trong mỗi partition, có một broker đóng vai trò là leader, nhận và xử lý các yêu cầu ghi và đọc từ producer và consumer. Các broker khác sẽ là follower, sao chép dữ liệu từ leader để sao lưu.

  * Retention Policy: Quy định cách Kafka lưu trữ dữ liệu trong các topic, bao gồm thời gian giữ lại (time-based retention) và kích thước dung lượng (size-based retention).

  * Consumer Lag: Sự chênh lệch giữa offset cuối cùng của một partition và offset mà consumer đang xử lý, thường được sử dụng để đo lường sự trễ xử lý của consumer so với producer.

  * Kafka Connect: Một framework để kết nối Kafka với các hệ thống, nguồn dữ liệu bên ngoài, giúp dễ dàng nhập và xuất dữ liệu đi từ và đến Kafka.

  * Kafka Streams: Thư viện cho phép xây dựng các ứng dụng xử lý dữ liệu phức tạp trên Kafka, hỗ trợ chuyển đổi dữ liệu, tính toán thống kê và phân tích.

  * Security trong Kafka: Bao gồm xác thực (authentication), ủy quyền (authorization) và mã hóa (encryption), đảm bảo tính bảo mật của dữ liệu trong Kafka.


|<image_4>|

# Những tính năng chính của Kafka

## Sử dụng Kafka để phân phối các message

Phân phối các message được thể hiện qua sơ đồ như sau:

|<image_5>|

## Event Streaming Kafka

Event Streaming là tính năng chủ yếu của Kafka, là hành động thu thập dữ liệu dưới dạng các luồng sự kiện (event streams) từ các nguồn dữ liệu như cơ sở dữ liệu, cảm biến, thiết bị di động và lưu trữ chúng lâu dài. Nó cho phép Kafka thực hiện các công việc như truy xuất dữ liệu sau này, phân tích, xử lý các luồng sự kiện theo thời gian thực và định tuyến chúng đến các công nghệ đích khác nhau khi cần thiết.

|<image_6>|

## Lưu trữ dữ liệu trên hệ thống Kafka

Kafka còn cung cấp khả năng lưu trữ lượng lớn thông tin dữ liệu, để tạo thành các kho dữ liệu (data lake). Điều này có nghĩa là Kafka có khả năng thu thập, xử lý và lưu trữ luồng dữ liệu thời gian thực cùng với việc lưu trữ dữ liệu theo phương thức chủ động.

|<image_7>|

Dữ liệu được Kafka lưu trữ có thể được sử dụng để xây dựng các công nghệ tiên tiến như Machine Learning, hay Trí tuệ nhân tạo (AI). Bằng cách sử dụng Kafka làm nền tảng lưu trữ dữ liệu, các nhà phát triển có thể xây dựng các ứng dụng phức tạp và có khả năng dự đoán thông tin quan trọng từ dữ liệu của họ.

# Cơ chế hoạt động của Kafka

Cơ chế hoạt động của Apache Kafka khác biệt so với các message queue truyền thống như RabbitMQ ở một số điểm quan trọng:

## Hệ thống phân tán và mở rộng: 

Kafka được thiết kế để hoạt động như một hệ thống phân tán hiện đại, chạy dưới dạng một cụm và có khả năng mở rộng quy mô một cách linh hoạt để xử lý bất kỳ số lượng ứng dụng nào. Nó cho phép Kafka xử lý lượng dữ liệu lớn, đáp ứng được nhu cầu mở rộng của các hệ thống.

## Hệ thống lưu trữ dữ liệu: 

Khác với các message queue truyền thống, Kafka không chỉ phục vụ như một hàng đợi message, mà còn được thiết kế để hoạt động như một hệ thống lưu trữ dữ liệu. Kafka cho phép lưu trữ dữ liệu trong thời gian cần thiết và không xóa message ngay sau khi consumer xác nhận đã nhận, cho phép các ứng dụng có thể truy xuất lại dữ liệu theo nhu cầu.

## Xử lý stream processing: 

Một trong những điểm mạnh của Kafka là khả năng xử lý stream processing, tức là Kafka có thể tính toán các luồng dẫn xuất và các dataset một cách linh hoạt, cho phép các ứng dụng thực hiện những tính toán phức tạp trên dữ liệu trong thời gian thực.

|<image_8>|

# Ưu và nhược điểm của Kafka

## Ưu điểm

Apache Kafka có nhiều ưu điểm nổi bật như sau:

### **Mã nguồn mở (Open-source):** Apache Kafka là một dự án mã nguồn mở, có nghĩa là mọi người đều có thể truy cập mã nguồn, sửa đổi và phát triển theo nhu cầu của họ mà không cần phải lo lắng về các hạn chế cấp phép.

### Xử lý dữ liệu lớn (High-throughput): Kafka có khả năng xử lý một lượng lớn thông tin một cách liên tục mà gần như không cần thời gian chờ, giúp các ứng dụng có thể xử lý dữ liệu với tốc độ cao và đáp ứng được yêu cầu về hiệu suất.

### Tần suất cao (High-frequency): Kafka có thể xử lý cùng lúc nhiều message và nhiều thể loại topic mà không gặp phải các vấn đề về tốc độ xử lý, hỗ trợ việc truyền tải dữ liệu diễn ra hiệu quả.

### Khả năng mở rộng (Scalability): Kafka dễ dàng mở rộng khi có nhu cầu, cho phép hệ thống mở rộng từ một cụm nhỏ đến một cụm lớn hơn.

### Tự động lưu trữ message: Kafka tự động lưu trữ message, để người dùng dễ dàng kiểm tra lại dữ liệu đã được truyền tải hay xử lý.

### Cộng đồng hỗ trợ đông đảo: Kafka có một cộng đồng người dùng đông đảo, cung cấp hỗ trợ nhanh chóng cũng như giải đáp các vấn đề khi cần thiết, giúp người dùng tiếp cận được thông tin, giải pháp dễ dàng.

|<image_9>|

## Nhược điểm

Mặc dù Apache Kafka mang lại nhiều lợi ích cho việc xử lý dữ liệu phân tán và thời gian thực, nhưng nền tảng này cũng có những nhược điểm nhất định:

### Thiếu công cụ giám sát hoàn chỉnh: Kafka không cung cấp một công cụ giám sát tích hợp hoàn chỉnh, những nhà phát triển có thể phải sử dụng nhiều công cụ khác nhau để quản lý và giám sát hệ thống Kafka, gây ra sự phân tán và khó khăn khi quản lý.

### Không hỗ trợ chọn topic dựa trên wildcard: Kafka không hỗ trợ chọn topic dựa trên wildcard, có nghĩa là người dùng phải chính xác chỉ định tên topic mà họ muốn xử lý message.

### Hiệu suất giảm khi tăng khối lượng dữ liệu: Khi khối lượng và kích thước của các message tăng lên, Kafka cần phải nén và giải nén các message này, dẫn đến giảm hiệu suất tổng thể của hệ thống do tốn thêm tài nguyên và thời gian xử lý.

### Xử lý không linh hoạt: Trong một số trường hợp, khi số lượng queues trong một Cluster Kafka tăng lên, hệ thống có thể trở nên chậm lại và ít nhạy bén hơn trong việc xử lý các message, gây ra gián đoạn và giảm hiệu suất chung.

|<image_10>|

Mặc dù còn tồn đọng những hạn chế nhưng Kafka vẫn là một lựa chọn hợp lý để xử lý dữ liệu phân tán và thời gian thực nhờ vào các ưu điểm về hiệu suất, tính linh hoạt trong mở rộng hay cộng đồng người dùng đông đảo của nó.

# Public_182

# Tìm hiểu về DoS

## DoS là gì?

Đây là một thuật ngữ công nghệ, viết tắt của Denial of Service, có nghĩa là từ chối dịch vụ. Tấn công từ chối dịch vụ là một hình thức tấn công mạng nhằm làm cho một hệ thống (hoặc máy chủ) trở nên không khả dụng bằng cách gửi một lượng lớn yêu cầu vượt quá khả năng xử lý của hệ thống đó. Tin tặc thực hiện DoS bằng cách gửi các yêu cầu đến hệ thống mục tiêu, tạo áp lực lớn lên tài nguyên như băng thông, CPU, hoặc bộ nhớ. Điều này dẫn đến việc hệ thống không thể phản hồi yêu cầu từ người dùng, gây ra sự chậm trễ hoặc ngừng hoạt động hoàn toàn.

|<image_1>|

Trong một cuộc tấn công DoS, tin tặc thường sử dụng nhiều phương pháp lên hệ thống mục tiêu, bao gồm một số phương pháp phổ biến sau:

### Ping Floods: Tin tặc gửi một lượng lớn gói tin ping tới một máy chủ, làm cho máy chủ phải xử lý và phản hồi một cách không hiệu quả.

### SYN Floods: Tin tặc gửi các yêu cầu kết nối TCP mà không hoàn thành việc thiết lập kết nối, chiếm hết tài nguyên kết nối TCP của máy chủ.

### HTTP Floods: Gửi một lượng lớn yêu cầu HTTP đến một máy chủ web, gây ra hiện tượng quá tải và khiến cho máy chủ không thể phản hồi các yêu cầu từ người dùng hợp pháp.

### Smurf Attacks: Tin tặc gửi gói tin ICMP (Internet Control Message Protocol) với địa chỉ nguồn được làm giả, khiến cho các máy chủ trong mạng phản hồi tới một địa chỉ không tồn tại, tạo ra một lượng lớn thông tin phản hồi không mong muốn.

Sau khi bị tấn công DoS, hệ thống sẽ trở nên không còn khả dụng, gây thiệt hại nghiêm trọng đến hoạt động kinh doanh và uy tín của tổ chức hoặc doanh nghiệp bị tấn công.

## Mục đích của các cuộc tấn công DoS

Đối tượng tấn công của DoS luôn rất đa dạng, nhưng chủ yếu đều tập trung vào hệ thống máy chủ của các tổ chức, doanh nghiệp hay Chính phủ. Mục đích của DoS thường sẽ như sau:

### Gây gián đoạn và làm giảm hiệu suất: Cuộc tấn công DoS đều làm cho hệ thống hay dịch vụ trở nên không thể sử dụng được đối với người dùng. Việc này gây ra sự gián đoạn, chậm trễ và ngừng hoạt động, làm suy giảm hiệu suất của hệ thống bị tấn công.

### Đe doạ tiền chuộc: Tin tặc thực hiện tấn công DoS để đe dọa và ép doanh nghiệp phải trả tiền để khôi phục hoạt động bình thường của hệ thống.

### Tác động đến hoạt động kinh doanh và uy tín: Các trang web thương mại điện tử, dịch vụ giao dịch trực tuyến, hay các tổ chức kinh doanh trực tuyến đều có thể trở thành đối tượng của DoS, làm ảnh hưởng nghiêm trọng đến doanh số bán hàng và uy tín của họ.

|<image_2>|

### Tấn công hệ thống Chính phủ hoặc tổ chức lớn: Đối với các tổ chức Chính phủ, DoS có thể được sử dụng như một phương tiện chiến tranh mạng để làm quá tải hệ thống của đối thủ.

### Tạo điều kiện cho các hành động khác: Cuộc tấn công DoS thường tạo cơ hội cho tin tặc thực hiện các hành động xấu khác như xâm nhập vào hệ thống, lợi dụng sự chậm trễ để truy cập thông tin quan trọng, thậm chí là xoá đi dữ liệu.

### Thử nghiệm và nghiên cứu: Một số cá nhân có thể tiến hành các cuộc tấn công DoS như một cách thử nghiệm, để hiểu rõ hơn về cách thức hoạt động của hệ thống, kiểm tra tính ổn định và xác định các lỗ hổng bảo mật.

Vì những lí do trên, tin tặc đã thực hiện tấn công từ chối dịch vụ - DoS, và gây ra nhiều ảnh hưởng nghiêm trọng đến hoạt động hay độ uy tín của các tổ chức, doanh nghiệp chịu sự tấn công này.

## Cách hoạt động của DoS

Bước đầu tiên của cuộc tấn công DoS là lựa chọn mục tiêu, thường là máy chủ hoặc dịch vụ trực tuyến. Sau đó, tin tặc sẽ sử dụng các phương tiện như botnet (một mạng các máy tính bị nhiễm malware) để tạo ra lưu lượng truy cập giả mạo đến mục tiêu.

|<image_3>|

Quá trình tấn công diễn ra khi tin tặc gửi liên tục lưu lượng truy cập giả mạo đến hệ thống hoặc máy chủ. Khi lưu lượng truy cập giả mạo đổ vào hệ thống, nó tạo ra tình trạng quá tải, khiến cho hệ thống không thể xử lý được và dịch vụ trở nên không khả dụng. Tình trạng quá tải này có thể kéo dài từ vài giây đến nhiều ngày liền. Khi cuộc tấn công kết thúc, dịch vụ trực tuyến có thể được khôi phục, nhưng sẽ để lại hậu quả nghiêm trọng đối với doanh nghiệp, tổ chức chịu cuộc tấn công từ chối dịch vụ này.

## Tác hại của DoS

Tác hại của tấn công từ chối dịch vụ DoS là rất lớn và có tác động đáng kể đến các tổ chức và hệ thống mạng:

### Sập hệ thống và máy chủ: Cuộc tấn công DoS có thể làm sập hoặc làm gián đoạn hoạt động của hệ thống và máy chủ, dẫn đến việc người dùng không thể truy cập vào dịch vụ hoặc tài nguyên.

### Thiệt hại tài chính: Các doanh nghiệp chịu ảnh hưởng từ tấn công DoS thường phải tiêu tốn nhiều chi phí để khắc phục sự cố và nâng cấp bảo mật của hệ thống.

### Gián đoạn hoạt động kinh doanh: DoS gây ra mất kết nối mạng, dẫn đến gián đoạn hoạt động kinh doanh, làm suy giảm hiệu suất làm việc của nhân viên và gây ra nhiều rủi ro liên quan đến việc thực hiện các công việc.

|<image_4>|

### Mất uy tín với khách hàng: Việc không thể truy cập vào website hay dịch vụ trực tuyến có thể làm giảm uy tín của doanh nghiệp trong mắt khách hàng. Nếu sự cố kéo dài, có thể làm doanh nghiệp mất đi lượng khách của mình.

### Hình thành lỗ hổng bảo mật: Sau khi bị tấn công, việc tập trung vào việc khôi phục lại trang web và dịch vụ sẽ được ưu tiên. Trong quá trình khôi phục này, hệ thống bảo mật thường bị tạm ngừng hoạt động và các lỗ hổng bảo mật chưa được vá kịp thời, tạo điều kiện thuận lợi cho hacker quay lại tấn công trang web với các phương thức khác.

### Thất thoát doanh thu và dữ liệu: Ngoài thiệt hại tài chính trực tiếp, DoS cũng có thể dẫn đến mất mát tiền bạc do không thể thực hiện các giao dịch kinh doanh quan trọng, và còn có thể làm mất các dữ liệu quan trọng của tổ chức.

Nhìn chung, bất kỳ ai cũng đều có thể trở thành nạn nhân của cuộc tấn công từ chối dịch vụ DoS hay DDoS – tấn công từ chối dịch vụ phân tán, và để có thể bảo vệ được hệ thống của mình, các tổ chức hay doanh nghiệp cần phải thực hiện những biện pháp bảo mật hiệu quả, giúp giảm thiểu tối đa tác hại từ DoS.

# Phân biệt DoS và DDoS

Bên cạnh DoS thì DDoS cũng chính là một hình thức tấn công mạng nguy hiểm mà bạn nên lưu ý tới. Về cơ bản, DoS và DDoS đều là những hình thức tấn công dịch vụ, nhưng DDoS khác ở điểm nó có thể được phân tán từ nhiều dải IP khác nhau, khiến người bị tấn công khó phát hiện để ngăn chặn. Để có thể phân biệt được hai thuật ngữ trên, bạn có thể theo dõi bảng dưới đây:
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><strong>Đặc điểm</strong></th>
<th><strong>DoS</strong></th>
<th><strong>DDoS</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Tên</td>
<td>Tấn công từ chối dịch vụ.</td>
<td>Tấn công từ chối dịch vụ phân tán.</td>
</tr>
<tr>
<td>Số lượng hệ thống tấn công</td>
<td>Chỉ sử dụng một hệ thống để nhắm vào mục tiêu cụ thể.</td>
<td>Sử dụng nhiều hệ thống hoặc một mạng lưới các thiết bị đã bị nhiễm
malware để tấn công mục tiêu.</td>
</tr>
<tr>
<td>Vị trí gửi gói dữ liệu</td>
<td>Gửi gói tin tới mục tiêu từ một nguồn duy nhất.</td>
<td>Gửi gói tin từ nhiều nguồn khác nhau, có thể từ hàng trăm hoặc thậm
chí hàng ngàn địa chỉ IP khác nhau.</td>
</tr>
<tr>
<td>Số lượng thiết bị tấn công</td>
<td>Chỉ một thiết bị duy nhất.</td>
<td>Có nhiều thiết bị đồng thời tham gia vào cuộc tấn công.</td>
</tr>
<tr>
<td>Tốc độ tấn công</td>
<td>Tốc độ tấn công thấp hơn so với DDoS do tập trung từ một nguồn duy
nhất.</td>
<td>Có tốc độ tấn công cao hơn do sử dụng nhiều nguồn tấn công cùng một
lúc.</td>
</tr>
<tr>
<td>Khả năng bị ngăn chặn</td>
<td>Có thể dễ dàng hơn để phát hiện và ngăn chặn.</td>
<td>Khó khăn hơn để ngăn chặn vì sự phân tán của nhiều nguồn tấn công
khác nhau.</td>
</tr>
<tr>
<td>Khă năng bị theo dõi</td>
<td>Dễ theo dõi hơn vì số lượng hệ thống tham gia ít hơn.</td>
<td>Khó để theo dõi và xác định nguồn tấn công vì được phân tán từ nhiều
nguồn.</td>
</tr>
<tr>
<td>Lưu lượng truy cập đến mạng mục tiêu</td>
<td>Gửi lưu lượng truy cập nhất định đến mạng của mục tiêu.</td>
<td>Gửi lưu lượng truy cập lớn đến mạng mục tiêu, gây quá tải và làm
ngừng hoạt động hệ thống.</td>
</tr>
<tr>
<td>Phương pháp tấn công điển hình</td>
<td><p>1. Tấn công tràn bộ đệm</p>
<p>2. Tấn công Ping of Death hoặc ICMP flood</p>
<p>3. Tấn công Teardrop Attack.</p></td>
<td><p>1. Tấn công amplification (khuếch đại)</p>
<p>2. Phân mảnh dữ liệu (Fragmentation Attack)</p>
<p>3. Khai thác lỗ hổng trong ứng dụng (Application Layer
Attack).</p></td>
</tr>
</tbody>
</table> 

# Giải pháp phòng chống DoS và DDoS

Sau khi đã tìm hiểu qua tác hại của DoS là gì, cách thức hoạt động của hình thức tấn công từ chối dịch vụ này và phân biệt DoS với DDoS, tiếp theo hãy cùng tham khảo qua một số phương pháp giúp phòng chống tấn công mạng DoS và DDoS:

## Cài đặt và duy trì phần mềm diệt virus

Đảm bảo cài đặt và duy trì phần mềm diệt virus hiện đại để ngăn chặn vi-rút và phần mềm độc hại truyền qua mạng, từ đó giảm thiểu nguy cơ bị lợi dụng để thực hiện các cuộc tấn công.

|<image_5>|

## Cài đặt tường lửa và cấu hình hạn chế truy cập

Sử dụng tường lửa và cấu hình nó để giới hạn lưu lượng truy cập vào và ra từ máy tính của bạn.

Thiết lập các quy tắc tường lửa chặt chẽ để từ chối hoặc hạn chế lưu lượng truy cập không mong muốn.

## Thực hiện biện pháp bảo mật cho địa chỉ email và bộ lọc thư điện tử

### Áp dụng biện pháp bảo mật để không phân phối địa chỉ email một cách rộng rãi, tránh việc tiếp nhận các email từ nguồn không xác định hoặc không tin cậy.

### Sử dụng các bộ lọc thư điện tử để quản lý lưu lượng truy cập không mong muốn và ngăn chặn email chứa các đính kèm hay nội dung độc hại.

Về cơ bản, để ngăn chặn toàn bộ DoS và DDoS là điều không thể, nhưng việc thực hiện các phương pháp trên cũng sẽ làm giảm bớt một phần tác hại từ các cuộc tấn công từ chối dịch vụ.

# Public_183

**Trong trường hợp sau khi thực hiện xong business logic và persist data xuống database thành công nhưng publish message fail thì cần xử lý thế nào (application crash hoặc lost connection)?**

|<image_1>|

# Transactional outbox pattern?

Mình sẽ lấy ví dụ bài trước để những bạn chưa đọc cũng có thể hiểu được. Tuy nhiên mình khuyến khích nếu những ai chưa đọc hoặc chưa hiểu về SAGA pattern thì nên đọc trước khi tiếp tục nhé.

Thảo hiện tại là Solution Architect của team IT thuộc chuỗi cửa hàng Pizza và những con bug không thể fix. Thời buổi dịch bệnh khó khăn, chủ doanh nghiệp muốn Thảo thiết kế hệ thống bán hàng online để tăng doanh số. Vì đã có thâm niên chục năm vén váy.. à nhầm.. vén tay áo.. nên Thảo rất nhanh apply ngay Microservices Architecture với 4 service chính và sử dụng SAGA pattern để handle distributed transaction:

# Order service.

# Payment service.

# Restaurant service.

# Delivery service.

# 

Sau khi Order service tạo order thành công, publish event ORDER_CREATED và Payment service consume event này để xử lý tiếp. Payment service thực hiện business logic, commit transaction xuống database và thực hiện publish event ORDER_PAID. Tuy nhiên đúng lúc publish event thì... toạch. Application crash, và thế là mất toi message, order tắc ở đấy và khách hàng chờ dài cổ vẫn chưa thấy pizza đâu.

## Problem

Trước khi đi tìm giải pháp thì cần hiểu chính xác vấn đề cần giải quyết là gì:

  * Mất connection đến Message broker dẫn đến việc không publish được event.

  * Có thể mất message nếu application crash/restart.

  * Cần đảm bảo tính atomic và consistent với 2 method persist() và publish(). Hiểu nôm na là nếu persist() thành công thì việc publish cũng phải thành công (thành công được hiểu là event được publish đến Message broker). Nếu không publish được, hay nói cách khác là lost event thì persist() cần được rollback.


## Solution

  * Nếu mất connection và không publish được event thì một cách đơn giản có thể nghĩ đến là retry. Những thứ cần quan tâm là retry trong bao lâu, bao nhiêu lần?

  * Cần store message ở đâu để đảm bảo nếu application crash/restart thì vẫn có message để retry: file, database, distributed storage?

  * Nếu để đảm bảo vừa atomic mà vừa consistent thì chỉ có nhồi vào chung transaction thôi. Có nghĩa là message/event cần được lưu và database và xử lý chung một transaction với business logic?


Từ những idea trên, liệu bạn đã mường tượng ra tổng thể solution cần thực hiện là như thế nào chưa? Đi từng bước một nhé.

## Create new table in database

Bước đầu tiên, tạo một table mới đặt tên là **outbox_table**. Khi xử lý business logic, bên cạnh việc update các table liên quan, ta insert thêm một record vào table **outbox_table** , đương nhiên record này chứa những thông tin cần thiết để publish event (order_id, state) thậm chí có thể lưu luôn event message.

|<image_2>|

Như vậy vấn đề về **atomic** và **consistent** đã được giải quyết một cách triệt để và đơn giản bằng cách sử dụng local transaction.

## Create relay publisher

Như vậy các event được lưu trữ tại database, đảm bảo đầy đủ các tính chất quan trọng:

  * **Consistency** : nếu store business data thành công thì mới có event, và ngược lại.

  * **Durability** : một khi transaction commit thành công thì không thể lost message.

  * **Message ordering** : message lưu trữ tại database theo thứ tự rõ ràng để đảm bảo khi publish message không có chuyện message đến sau lại publish trước.


Bây giờ đã một đống message đang chờ để publish, thì tất nhiên phải có publisher làm nhiệm vụ check xem đang có message nào không, nếu có thì publish. Tất nhiên vẫn không thể tránh trường hợp lost connection đến Message broker, vậy nên việc publish cần có cơ chế retry, và update message state sau khi publish thành công để tránh publish nhiều lần.

Pattern này là polling publisher. Đại khái publisher sẽ query liên tục (theo chu kì) đến outbox_table để tìm event và publish.

|<image_3>|

Một câu hỏi được đặt ra, vậy publisher này nên là một service độc lập hay là một service (class) nằm trong payment-service? Vì sẽ có tình huống payment-service crash còn nhiều event trong outbox_table đang chờ được publish. Nếu relay-publisher thuộc payment-service thì lúc này message không được publish. Nhưng nếu relay-publisher là service độc lập thì nó cần access vào outbox_table của payment-service, có vẻ không hợp lý?

Và đương nhiên, solution này là chính là **transactional outbox pattern**.

## Alternative solution

Về cơ bản solution trên đã giải quyết được problem đưa ra ở đầu bài nếu sử dụng SQL (RDBMS). Tất nhiên, nó cũng có những nhược điểm cần chú ý:

  * Nếu application sử dụng NoSQL thì cần cẩn thận vì không phải NoSQL nào cũng có thể support pattern này (do không đảm bảo tính chất quan trọng của transaction).

  * Extra call đến database để check có event nào cần publish không.


Quay lại vấn đề ban đầu, mấu chốt quan trọng nhất để giải quyết bài toán ở chỗ cần biết chính xác transaction cho business logic đã được commit thành công chưa để thực hiện việc publish event. Việc build event message hoàn toàn có thể thực hiện dựa trên business data... nhưng tất nhiên chẳng ai làm thế cả .

Vì vậy có một biến thể khác để implement relay publisher, và cũng để giải quyết 2 vấn đề trên là apply transaction log tailing pattern.

Nếu bạn đã làm việc MySQL thì chắc hẳn đã nghe đến binlog, hoặc nếu quen thuộc với [Postgres](https://viblo.asia/s/OVlYq8oal8W) là WAL. Có thể hiểu đơn giản rằng transaction log giống như hộp đen của máy bay, lưu trữ tất cả lịch sử thay đổi dữ liệu của database. Khi dữ liệu bị thay đổi thì database cần lưu trữ các thay đổi đó vào log file. Và việc đọc log file này có thể giúp chúng ta biết transaction nào được commit, data nào được thay đổi. Từ có có thể build event để publish đến Message broker.

|<image_4>|

# Case study: Notification service

## Design & Flow

Việc cần làm là tạo ra Notification platform với mục đích chuyên để gửi thông báo đến người dùng thông qua các kênh khác nhau. Và một điều quan trọng là chỉ gửi đến những người đăng kí nhận thông báo.

Như vậy có thể tạm hình dung ra 3 components chính trong bài toán này:

  * Application: tất nhiên là notification-serivce rồi.

  * Database: MySQL, Postgres... để thực hiện được transactional outbox pattern.

  * Subscriber: khách hàng muốn nhận thông báo.


|<image_5>|

Đọc tiếp flow bên dưới kết hợp với hình bên trên để hiểu hơn flow nhé:

  * Đầu tiên, khi client order sẽ có checkbox để lựa chọn việc có nhận thông báo hay không, nhận qua hình thức nào. Nếu có thì sau đó order-service sẽ gửi request tới notification-service để đăng kí nhận thông báo. Ví dụ thông qua HTTP POST /subscribe.

  * Sau đó điều hướng đến SubscriptionService (class) để thực hiện business logic. Store thông tin vào subscription_table, có thể là một hoặc nhiều table khác, mình chỉ vẽ đại diện một table.

  * Sau khi nhà bếp nhận thực đơn, hệ thống muốn gửi thông báo trạng thái order đến người dùng. Lúc này order-service hoặc restaurant-service gửi message đến notification-service. Notification-service apply transactional outbox pattern như hình trên, store business data vào notification table và outbox message vào notify_outbox table.


Tiếp theo và việc publish notification đến người dùng, hiện thời có 3 channel là sms, email, voice call tương ứng với 3 relay publisher. Mỗi publisher sẽ chủ động monitor message của riêng mình để publish đến địa chỉ đích.

|<image_6>|

Với design này có thể dễ dàng thêm các publisher một cách độc lập, dễ dàng scale. Client cũng dễ dàng trong việc lựa chọn việc nhận thông báo, và nhận qua hình thức nào.

# Limitation

Transactional outbox pattern cũng bá đạo thật đấy nhưng vẫn có nhược điểm nhất định mà ta cần nắm rõ để xử lý bài toán cho tốt, cho triệt để.

Duplicate event: rất khó để đảm bảo việc message delivery là exactly once. Vấn đề publish message thành công và chưa kịp update lại vào database (application crash) là chuyện hết sức bình thường. Do vậy đầu consume cần đảm bảo được việc có thể xử lý duplicate message. Hay nói cách khác là cần implement idempotent consumer.

Near real-time: chắc chắn là rất khó để đạt đến trạng thái real-time application. Vấn đề là ta có chấp nhận có độ trễ không và độ trễ là bao nhiêu thì chấp nhận được.

# Cuối cùng

Quay lại câu hỏi ở phần đầu publisher nên là một service độc lập hay là một inner-service?

Theo quan điểm cá nhân, nó sẽ phụ thuộc vào bài toán cần giải quyết là gì, vấn đề có phức tạp hay không, yêu cầu letancy thế nào, có cần mở rộng trong tương lai không?

Ví dụ về **notification-service** phía trên, chắc chắn là việc chia thành các service độc lập là hiệu quả hơn. Trong trường hợp thêm một channel mới ta chỉ việc implement service mới mà không cần sửa code cũ. Nó giúp việc scale dễ dàng và bớt tốn kém. Chỉ có thêm vấn đề nho nhỏ là cần monitor thêm chính service đó. Và như mình nói, vấn đề nho nhỏ nên có thể coi là không thành vấn đề.

# Public_184

**Mở đầu**

Dự án Công nghệ thông tin, trước hết đó cũng là một dự án, cho nên có tất cả các đặc điểm và các giai đoạn như của một dự án thông thường. Tuy nhiên, các dự án CNTT là các dự án được thực hiện trong lĩnh vực công nghệ thông tin và tuân thủ các nguyên tắc hoạt động của công nghệ thông tin. Dự án CNTT thực hiện theo quy trình sản xuất và chế tạo ra các sản phẩm công nghệ thông tin. Quản lý dự án công nghệ thông tin cũng bao gồm các giai đoạn và tuân theo các quy tắc quản lý dự án như đối với dự án thông thường, từ khâu xác lập dự án, lập kế hoạch, thực hiện kế hoạch, giám sát - đánh giá và kết thúc dự án. Tuy nhiên, do các dự án công nghệ thông tin có những đặc điểm riêng, cho nên việc xác định dự án và quản lý dự án cũng có những điểm khác biệt cần quan tâm. Trong chương này, chúng ta sẽ trình bày những vấn đề liên quan đến CNTT và ứng dụng CNTT, từ đó phân tích những đặc điểm khác biệt của một dự án CNTT cùng với những đặc thù riêng của công tác quản lý dự án CNTT.

# Công nghệ thông tin và Dự án công nghệ thông tin 

## Công nghệ thông tin

### Công nghệ Thông tin - Truyền thông (CNTT-TT hay ICT: Information and Communication Technology).

Đây là thuật ngữ mới, nhấn mạnh sự không thể tách rời hiện nay cuả CNTT, với công nghệ truyền thông, chủ yếu là viễn thông, trong thời đại “thế giới trực tuyến”, cái gì cũng “Net” như hiện nay. Viễn thông trong CNTT hiện nay gắn bó hữu cơ đến mức như là một thành phần không thể tách rời của CNTT.

Cơ quan quản lý Nhà nước về Công nghệ Thông tin - Truyền thông là Bộ Thông tin và Truyền thông (Bộ TTTT, hay Bộ 4T). Các dự án CNTT cấp Nhà nước đều chịu sự quản lý của Bộ 4T .

### Tin học là ngành khoa học của CNTT có nhiệm vụ nghiên cứu về xử lý thông tin trên máy tính. Theo phân loại của HĐCDGS Nhà nước (Việt Nam) thì khoa học CNTT bao gồm các chuyên ngành sau:

  * Khoa học máy tính (Computer Science)

  * Kỹ thuật máy tính (Computer Engineering)

  * Hệ thống thông tin (Information Systems)

  * Công nghệ phần mềm (Software Engineering)

  * Truyền thông và mạng máy tính (Communication and Computer Network).


### Hệ thống thông tin

#### Khái niệm: 

Hệ thống thông tin (HTTT) là một tập hợp và kết hợp của các phần cứng, phần mềm và các mạng truyền thông được con người xây dựng và sử dụng để xử lý thông tin (thu thập, tạo, tái tạo, phân phối và chia sẻ các dữ liệu, thông tin và tri thức nhằm phục vụ các mục tiêu của tổ chức, doanh nghiệp).

#### Các thành phần của một hệ thống thông tin: 

Một HTTT bao gồm 5 thành phần chính: Phần cứng, phần mềm, mạng truyền thông, dữ liệu và con người. Có thể mô tả các thành phần của HTTT bằng sơ đồ dưới đây:

|<image_1>|

Hình 2.1 Các thành phần của HTTT

Trong sơ đồ này: Phần lõi mô tả quá trình xử lý thông tin của một HTTT, gồm các đơn vị chức năng thực hiện việc nhập dữ liệu vào, xử lý dữ liệu, xuất thông tin ra. Để thực hiện được các chức năng này, HTTT cần phải có các thành phần tạo nên các nguồn lực (resources) được mô tả ở vòng ngoài của sơ đồ, bao gồm: các tài nguyên về phần cứng, phần mềm, mạng, dữ liệu và nhân lực.

  * Các phần cứng (Hardware Resources): Gồm các thiết bị/phương tiện kỹ thuật dùng để xử lý/lưu trữ thông tin. Trong đó chủ yếu là máy tính, các thiết bị ngoại vi dùng để lưu trữ và nhập vào/xuất ra dữ liệu.

  * Các phần mềm (Software Resources): Gồm các chương trình máy tính, các phần mềm hệ thống, các phần mềm chuyên dụng, các thủ tục dành cho người sử dụng (cho nhập liệu, để sửa lỗi, kiểm tra, v.v…).

  * Các hệ mạng (Network Resources): bao gồm môi trường truyền thông, các dịch vụ mạng… để truyền dữ liệu.

  * Dữ liệu (Data Resources):


\+ Bao gồm CSDL (khách hàng, các hồ sơ nhân viên, hàng hóa, dịch vụ, đối tác…

\+ Cơ sở tri thức: Văn bản pháp luật, các luật, chính sách, nghị định…

  * Con người (People Resources): Các chuyên gia HTTT: phân tích viên hệ thống, lập trình viên, nhân viên đứng máy, v.v., Người dùng cuối: tất cả những người sử dụng HTTT trong doanh nghiệp , từ các nhà lãnh đạo, các cấp quản lý, cho đến các nhân viên thừa hành và tác nghiệp.


Trong các thành phần trên, con người là thành phần quan trọng nhất bởi vì chính con người xây dựng nên hệ thống, đặc biệt các phầm mềm, dữ liệu, và các thủ tục. Các kết quả xử lý, đầu ra của HTTT là dữ liệu đã được biến đổi, được sắp xếp lại, được cấu trúc lại, nhằm làm rõ hơn về đối tượng ta quan tâm, đó là dữ liệu thô đã được “chưng cất” thành thông tin. Cách sử dụng thông tin thu được như thế nào sẽ quyết định hiệu quả của toàn hệ thống. Điều này không thuộc trách nhiệm của phần cứng, phần mềm, dữ liệu, … mà là trách nhiệm của con người. Con người có vai trò quyết định không chỉ trong việc sử dụng các thông tin thu được, mà còn trong toàn bộ các khâu hình thành nên hệ thống và vận hành nó.

### Ứng dụng công nghệ thông tin

Việc ứng dụng CNTT trong các tổ chức, doanh nghiệp nói chung nhằm đạt được các mục đích sau:

  * Hỗ trợ việc quản lý và giao tiếp, cộng tác trong toàn tổ chức, doanh nghiệp.

  * Điều khiển các tiến trình công nghiệp (thí dụ quá trình chế tạo sản phẩm).

  * Xử lý một cách hiệu quả các giao dịch kinh doanh, quan hệ khách hàng, marketing…


Chỉ số ứng dụng Công nghệ thông tin: Theo công bố năm 2010 của VCCI về Chỉ số ứng dụng CNTT-TT tại các doanh nghiệp Việt nam (đã đăng ký kinh doanh)

  * Chỉ có 46% doanh nghiệp sử dụng e-mail trong công việc,

  * Hơn 50% cho rằng không có nhu cầu dùng phần mềm quản lí nhân sự, tiền lương cũng như phần mềm quản lí bán hàng…

  * Ngoài ra, khoảng 20% có website riêng (chủ yếu để giới thiệu hình ảnh, sản phẩm, dịch vụ qua mạng), phần lớn vẫn dè dặt với thương mại điện tử vì cho rằng chưa phải là thời điểm để mua bán qua mạng…


VCCI cũng cho rằng: Các doanh nghiệp cần phải xem xét hệ thống CNTT như là một phần của hạ tầng, cần lựa chọn mô hình ứng dụng phù hợp để trang bị máy tính, phần mềm văn phòng, kết nối Internet, lập website quảng bá thương hiệu... , để dần tiến tới ứng dụng cao hơn như phần mềm quản trị dịch vụ khách hàng, sử dụng chứng thư điện tử, lập web bán lẻ trực tuyến… Ngoài ra, để đảm bảo hoạt động an toàn và ổn định, cũng cần quan tâm tới ứng dụng các biện pháp đảm bảo an toàn, an ninh thông tin.

Các sản phẩm thông tin trong các HTTT bao gồm các báo cáo cho lãnh đạo, các tài liệu kinh doanh, quảng cáo, tiếp thị dưới dạng văn bản, biểu mẫu, đồ thị, audio, video, và các thông tin khác. Các tổ chức, doanh nghiệp có thể sử dụng các hệ thống thông tin với nhiều mục đích khác nhau.

Đối nội: hệ thống thông tin sẽ giúp nhà quản lý nắm vững, thông hiểu tình hình nội bộ của tổ chức, doanh nghiệp…nhằm quản lý tốt doanh nghiệp, thống nhất hành động, duy trì sức mạnh của tổ chức, đạt được lợi thế cạnh tranh

  * Nhân sự,

  * Tài chính, vật tư

  * Kế hoạch công tác…

  * Quản lý sản xuất, kinh doanh


Đối ngoại: Với bên ngoài, hệ thống thông tin giúp nắm bắt được nhiều thông tin về đối tác và khách hàng hơn hoặc cải tiến dịch vụ, nâng cao sức cạnh tranh, tạo đà cho phát triển.

  * Khách hàng: phát triển, chăm sóc khách hàng

  * Đối tác kinh doanh

  * Theo dõi thị trường

  * Maketting, phát triển thị trường


### Dự án công nghệ thông tin

Các dự án thuộc lĩnh vực CNTT nhằm đưa CNTT vào ứng dụng trong quản lý và điều hành sản xuất kinh doanh trong các tổ chức và doanh nghiệp.

  * Khái niệm: Dự án công nghệ thông tin (DACNTT): Dự án Công nghệ thông tin là một dự án được thực hiện trong lĩnh vực công nghệ thông tin và tuân thủ các nguyên tắc hoạt động của công nghệ thông tin. Dự án CNTT thực hiện theo quy trình sản xuất và chế tạo ra các sản phẩm công nghệ thông tin.

  * Tùy theo mục tiêu của việc ứng dụng CNTT, các dự án CNTT có thể chia thành 2 loại chính: Dự án HTTT và dự án phần mềm. Trong chuyên đề này chúng ta chủ yếu nghiên cứu các dự án HTTT.


|<image_2>|

#### _**Dự án Hệ thống thông tin: là dự án mà mục tiêu của nó là xây dựng một HTTT**_

Việc xây dựng một HTTT với các thành phần như trên đòi hỏi phải có một cái nhìn hệ thống không chỉ về mặt công nghệ, mà còn về tổ chức doanh nghiệp của người thực hiện, và một tầm nhìn xa hơn về các biện pháp đưa hệ thống CNTT đó phục vụ cho công việc quản lý, kinh doanh của tổ chức hay doanh nghiệp. Đó là một cách nhìn, một cách tiếp cận hết sức cơ bản: xem xét các sự vật trong các mối tương quan của chúng khi hoạt động nhằm đạt đến mục tiêu đã định, gọi là tiếp cận hệ thống, hay quan điểm hệ thống.

Dự án HTTT có thể có các sản phẩm (mục tiêu) là các loại HTTT sau đây:

  * Các HTTT quản lý - cung cấp thông tin dưới dạng các báo cáo theo mẫu định sẵn, và trình bày chúng cho các nhà quản lý và các chuyên gia khác của doanh nghiệp.

  * Các hệ thống hỗ trợ quyết định - cung cấp trực tiếp các hỗ trợ về mặt tính toán cho các nhà quản lý trong quá trình ra quyết định (không theo mẫu định sẵn, và làm việc theo kiểu tương tác, không phải theo định kỳ).

  * Các HTTT điều hành - cung cấp các thông tin có tính quyết định từ các nguồn khác nhau, trong nội bộ cũng như từ bên ngoài, dưới các hình thức dễ dàng sử dụng cho các cấp quản lý và điều hành.


Trong quá trình thiết kế và quản lý dự án HTTT, phải đảm bảo thực hiện năm giai đoạn của chu trình phát triển HTTT như sau:

  * Khảo sát hệ thống: Giai đoạn này có thể được bắt đầu từ việc hoạch định HTTT và lựa chọn các cơ hội đầu tư. Thông thường giai đoạn này bao gồm việc phân tích chi phí/lợi ích và một phần của nghiên cứu khả thi.

  * Phân tích hệ thống: Phân tích các nhu cầu thông tin của người dùng cuối, môi trường doanh nghiệp, và tất cả các hệ thống hiện dùng, để đưa ra các yêu cầu chức năng đối với hệ thống mới.

  * Thiết kế hệ thống: Đưa ra các đặc tả về phần cứng, phần mềm, nhân lực, và dữ liệu của hệ thống, cũng như các sản phẩm thông tin mong muốn của hệ thống.

  * Thể hiện (cài đặt) hệ thống: Phát triển hoặc mua các phần cứng, phần mềm cần cho việc thể hiện bản thiết kế. Kiểm thử hệ thống được xây dựng. Huấn luyện nhân lực để vận hành và sử dụng hệ thống. Và chuyển đổi ứng dụng sang hệ thống mới.

  * Bảo trì hệ thống: Xem xét hệ thống sau cài đặt. Giám sát, đánh giá và thay đổi hệ thống theo nhu cầu.


Các HTTT khác: Ngoài các HTTT trên, còn có thể kể đến một số loại khác sau đây

  * Các hệ chuyên gia: Đây là các hệ thống cung cấp các tư vấn có tính chuyên gia và hoạt động như một chuyên gia tư vấn cho người dùng cuối. Thí dụ: các hệ tư vấn tín dụng, giám sát tiến trình, các hệ thống chẩn đoán và bảo trì.

  * Các hệ quản trị tri thức: Đây là các HTTT dựa trên tri thức, hỗ trợ cho việc tạo, tổ chức và phổ biến các kiến thức của doanh nghiệp cho nhân viên và các nhà quản lý trong toàn công ty. Thí dụ: truy nhập qua mạng intranet đến các kinh nghiệm và thủ thuật kinh doanh tối ưu, các chiến lược bán hàng, đến hệ thống chuyên trách giải quyết các vấn đề của khách hàng.

  * Các hệ thống chức năng doanh nghiệp (hoặc các hệ thống tác nghiệp): Hỗ trợ nhiều ứng dụng sản xuất và quản lý trong các lĩnh vực chức năng chủ chốt của công ty. Thí dụ: các HTTT hỗ trợ kế toán, tài chính, tiếp thị, quản lý hoạt động, quản trị nguồn nhân lực.

  * Các HTTT chiến lược: HTTT loại này có thể là một HTTT hỗ trợ hoạt động hoặc hỗ trợ quản lý, nhưng với mục tiêu cụ thể hơn là giúp cho công ty đạt được các sản phẩm, dịch vụ và năng lực tạo lợi thế cạnh tranh có tính chiến lược. Thí dụ: buôn bán cổ phiếu trực tuyến, các hệ thống web phục vụ thương mại điện tử (TMĐT), hoặc theo dõi việc chuyển hàng (đối với các hãng vận chuyển).

  * Các HTTT tích hợp, liên chức năng: Đây là các HTTT tích hợp trong chúng nhiều nguồn thông tin và nhiều chức năng tổng hợp nhằm chia sẻ các tài nguyên thông tin cho tất cả các đơn vị trong tổ chức. Còn gọi là các hệ thống “xí nghiệp” trợ giúp việc xử lý thông tin cấp toàn doanh nghiệp . Điển hình là các hệ thống: hoạch định nguồn lực xí nghiệp (viết tắt trong tiếng Anh là ERP), quản trị quan hệ với khách hàng (CRM), quản lý chuối cung ứng (SCM), và một số hệ khác.


|<image_3>|

# Public_185

# Jira là gì

Jira là một ứng dụng theo dõi và quản lý lỗi / vấn đề trong dự án, được phát triển bởi Công ty Phần mềm Atlassian của Australia. Cách thức hoạt động của JIRA dựa vào trọng tâm là kết quả công việc, có thể sử dụng ngay và linh hoạt khi sử dụng.

# Tính năng cơ bản của Jira

  * Quản lý, theo dõi tiến độ của dự án

  * Quản lý các tasks, bugs, cải tiến, tính năng mới hoặc bất kỳ vấn đề gì xảy ra

  * Tạo ra và lưu lại những bộ lọc có cấu hình cao (dynamic queries) xuyên suốt mọi vấn đề trong hệ thống; chia sẻ bộ lọc với người sử dụng khác, hoặc đăng ký và nhận được các kết quả qua hệ thống thư điện tử định kỳ

  * Xây dựng quy trình làm việc tương thích với yêu cầu của từng dự án

  * Bảng dashboard cung cấp cho mỗi người dùng một không gian riêng để xem mọi thông tin liên quan đến cá nhân

  * Cung cấp nhiều loại báo cáo thống kê với nhiều loại biểu đồ khác nhau phù hợp với nhiều loại hình dự án và đối tượng người dùng


|<image_1>|

# Ưu nhược điểm của phần mềm Jira

## Ưu điểm

  * Jira có chức năng phân quyền cực kỳ chi tiết, không chỉ phân quyền trong dự án chung, mà còn phân quyền đối với từng nhiệm vụ, giúp team công nghệ bảo vệ thông tin độc quyền của mình.

  * Dễ dàng tích hợp với các hệ thống khác (như Email, Excel, RSS,…)

  * Hệ thống module và bộ công cụ phát triển bổ trợ cho phép tùy biến, mở rộng và tích hợp Jira vào trong hệ thống hiện tại

  * Jira được phát triển sử dụng chuẩn HTML và được thử nghiệm với tất cả các trình duyệt phổ biến hiện nay.

  * Có thể chạy trên hầu hết các nền tảng phần cứng, hệ điều hành và cơ sở dữ liệu

  * Mỗi màn hình trong Jira có một phiên bản có thể in đảm bảo việc luân chuyển bản cứng một cách dễ dàng

  * Có thể tích hợp trực tiếp với code trên môi trường phát triển, là một công cụ hoàn toàn phù hợp với các developer


## Nhược điểm

  * Chi phí cao, sau 7 ngày dùng thử thì doanh nghiệp càng có quy mô lớn thì càng tốn nhiều chi phí: $10 mỗi tháng dành cho tối đa 10 tài khoản; từ 11-100 tài khoản là $7/tài khoản/tháng

  * Tốn nhiều thời gian và công sức để setup nên chỉ phát huy tối ưu hiệu quả với dự án lớn, không phù hợp với dự án vừa và nhỏ (dưới 3 tháng)

  * Ngôn ngữ tiếng Anh với nhiều thuật ngữ khó sử dụng

  * Quy trình làm việc phức tạp đòi hỏi phải tìm hiểu kỹ lưỡng


Tóm lại, Jira là một phần mềm quản lý dự án khá đặc thù, đây sẽ là lựa chọn hoàn hảo cho các team làm việc theo phương pháp Agile, đặc biệt là các team công nghệ hoặc phát triển phần mềm.

# Các thuật ngữ cần biết khi sử dụng Jira

Jira là phần mềm sử dụng tiếng Anh với khá nhiều thuật ngữ công nghệ. Bên cạnh các thuật ngữ cơ bản như user story – nhu cầu của người dùng đối với chức năng cần có, bug – lỗi phần mềm, task – tác vụ,…, nếu bạn là người mới bắt đầu sử dụng thì đừng quên làm quen với danh sách thuật ngữ “khó nhằn” dưới đây.

  * Sprint: Một vòng lặp ngắn hạn (lý tưởng là 2-4 tuần) mà đội phát triển thực hiện đầy đủ các công việc cần thiết như lập kế hoạch, phân tích yêu cầu, thiết kế, triển khai để cho ra các phần nhỏ của sản phẩm.

  * Backlog: Danh sách tập hợp các user stories, bugs và tính năng cho một sản phẩm hoặc sprint.

  * Scrum: Một phương pháp Agile, nơi sản phẩm được xây dựng theo các lần lặp đi lặp lại trong một sprint.

  * Scrum of Scrums: Một kỹ thuật để mở rộng quy mô Scrum, các dự án đa đội – theo truyền thống gọi là program management.

  * Board: Công cụ dùng để hiển thị hoạt động công việc trong một quy trình làm việc cụ thể. Nó có thể thay đổi thích ứng với các phương pháp Agile khác nhau (ví dụ, một bảng Scrum sẽ hiển thị các công việc được di chuyển từ product backlog đến sprint backlog, trong khi đó một bảng Kanban thường có một quy trình làm việc ba bước: To do, In Progress, và Done).


|<image_2>| _Giao diện scrum board trong Jira_

  * Burndown Chart: Hiển thị số lượng ước tính và thực tế cho tổng số công việc phải hoàn thành trong một sprint.

  * Daily stand-up: Là một cuộc họp nhỏ 15 phút trước khi bắt đầu ngày làm việc, giúp mọi thành viên nắm bắt toàn bộ công việc của ngày hôm qua.

  * Epic: Đại điện cho một user story lớn và cần phải được chia thành các story nhỏ. Người dùng có thể phải chạy nhiều sprint để hoàn thành một epic.

  * Issue: Một đơn vị công việc (task, bug, story, epic) trong Jira, hoạt động trong một quy trình từ khởi tạo đến khi hoàn thành.

  * Swimlane: Phân loại các công việc để xem xét công việc nào nên tiến hành trước.

  * Velocity: Đo lường khối lượng công việc mà một đội có thể xử lý trong một thời hạn nhất định.

  * Cumulative Flow Diagram (CFD): Một biểu đồ thể hiện các trạng thái khác nhau của các mục công việc trong một khoảng thời gian cụ thể. Cột ngang x trong CFD định nghĩa là thời gian, và cột dọc y là mục công việc (issue). Mỗi vùng màu của biểu đồ tương đương với trạng thái luồng công việc (ví dụ một cột trong bảng).

  * Iteration: Dự án sẽ được thực hiện trong các phân đoạn lặp đi lặp lại.

  * Wallboard: Một bảng (viết tay hoặc điện tử) lớn được đặt tại vị trí dễ thấy thể hiện dữ liệu quan trọng về hoạt động của đội development.


# Hướng dẫn các thao tác làm việc trên Jira cho thành viên trong dự án

## Tạo một issue

  * Click vào nút Create trên top bar

  * Nhập các thông tin liên quan: tên dự án, loại issue, tóm tắt nội dung, độ ưu tiên, thời gian hoàn thành, người chịu trách nhiệm, môi trường test, mô tả chi tiết nội dung, ước lượng thời gian cần thiết để hoàn thành, file đính kèm,…

  * Cấu hình issue theo ý muốn

  * Click vào nút Configure Fields > Chọn Custom

  * Chọn trường thông tin muốn ẩn hoặc hiện hoặc chọn All để hiển thị tất cả các trường


|<image_3>| _Hộp thoại tạo mới một issue trên Jira_

## Tương tác với issue

  * Sắp xếp và quản lý các file đính kèm


|<image_4>|

  * Các file đính kèm được tuỳ chọn sắp xếp và phân loại

  * Sao chép issue

  * – Mở issue muốn sao chép

  * – Chọn More > Clone

  * Chuyển đổi sub-task thành issue và ngược lại

  * Chọn sub-task / issue muốn chuyển thành issue / sub-task

  * Chọn More > Convert to Issue / Convert to Sub-Task

  * Bình chọn cho issue yêu thích


|<image_5>|

Bình chọn cho issue là một tính năng mới lạ của Jira

  * Theo dõi issue thông qua nhãn dán để dễ dàng phân loại và tìm kiếm issue

  * Chọn issue

  * Chọn More > Labels để thêm hoặc xóa nhãn


## Tìm kiếm một issue

  * Tìm kiếm nhanh: Nhập từ khoá vào ô Quick Search và ấn Enter

  * Tìm kiếm cơ bản: Từ menu Issues trên header bar, chọn Search for issue

  * Tìm kiếm nâng cao: Từ menu Issues trên header bar, chọn Search for issue > Advanced


|<image_6>|Ví dụ về tìm kiếm nâng cao trên Jira

  * Các thao tác với kết quả tìm kiếm


  * Tuỳ chỉnh giao diện hiển thị: _List view_ / _Detail view_

  * Thay đổi thứ tự sắp xếp trên từng cột: Click vào tên cột

  * Ẩn / Hiện cột: Click _Columns_ và chọn các cột cần ẩn / hiện

  * Di chuyển cột: Kéo thả

  * Xem chi tiết issue: Click vào từ khoá hoặc tên issue


## Tạo bộ lọc tìm kiếm

  * Các loại bộ lọc:


Bộ lọc hệ thống (system filter): các bộ lọc có sẵn của hệ thống như tất cả issue, các mục đã xem gần đây, báo cáo của bạn, các issue bạn đã mở
Bộ lọc yêu thích (favorite filter): Các filter do người dùng tạo ra, được sắp xếp theo thứ tự trong bảng chữ cái.

  * Các thao tác với bộ lọc: Sau khi đã tạo bộ lọc, Jira cho phép người dùng thực hiện các thao tác khác, bao gồm tìm kiếm bộ lọc, cập nhật bộ lọc, xóa bộ lọc, tạo thêm bộ lọc ẩn danh, thêm bộ lọc vào mục ưa thích, chia sẻ bộ lọc hoặc theo dõi bộ lọc.


## Báo cáo

Một trong những tính năng nổi trội của phần mềm Jira chính là việc cung cấp hơn chục loại báo cáo khác nhau, giúp những người quản lý dự án có cái nhìn tổng quan và chi tiết vừa nhanh vừa hiệu quả. Một số loại báo cáo quan trọng nhất là:

  * Thống kê số lượng issue theo thời gian

  * Hiển thị số lượng issue đã được tạo và số lượng issue đã được giải quyết trong một khoảng thời gian nhất định

  * Hiển thị báo cáo thống kê dưới dạng biểu đồ hình tròn dựa trên tiêu chí thống kê do người dùng lựa chọn

  * Báo cáo số lượng issue được tạo trong một khoảng thời gian nhất định do người dùng lựa chọn


|<image_7>| _Jira cung cấp hơn chục loại báo cáo đa dạng và hữu ích_

# Public_186

Cho dù bạn đang lập kế hoạch di chuyển dữ liệu một lần từ MySQL sang PostgreSQL hay muốn liên tục sao chép dữ liệu giữa hai cơ sở dữ liệu này, thì vẫn có nhiều điều cần cân nhắc và một số cách để thực hiện nhiệm vụ.

Trong bài viết này, chúng tôi sẽ hướng dẫn từng bước cách di chuyển MySQL sang PostgreSQL bằng Estuary Flow, cho phép bạn di chuyển dữ liệu lịch sử và liên tục thu thập dữ liệu mới bằng tính năng ghi lại dữ liệu thay đổi (CDC). Chúng tôi cũng sẽ khám phá thêm các phương pháp phổ biến khác để chuyển đổi MySQL sang PostgreSQL.

Nhưng trước tiên, hãy cùng tìm hiểu một số điều kiện tiên quyết thiết yếu. Để đảm bảo quá trình di chuyển thành công, điều quan trọng là phải hiểu những khác biệt chính giữa MySQL và PostgreSQL, đồng thời xác định mục tiêu di chuyển của bạn. Hãy bắt đầu bằng phần giới thiệu (lại) ngắn gọn về MySQL.

# MySQL là gì? 

|<image_1>|

[MySQL](https://www.mysql.com/) là một hệ thống quản lý cơ sở dữ liệu quan hệ (RDBMS) được sử dụng rộng rãi dựa trên SQL. Thuộc sở hữu của Oracle, MySQL là một thành phần quan trọng trong nhiều nền tảng công nghệ, cho phép các nhóm xây dựng và duy trì các dịch vụ và ứng dụng dựa trên dữ liệu.

## Ưu điểm

  * Mã nguồn mở và miễn phí: MySQL là mã nguồn mở, cung cấp hỗ trợ cấp doanh nghiệp và triển khai ngay lập tức mà không mất phí.

  * Hỗ trợ đa nền tảng: Hỗ trợ các hệ điều hành phổ biến như Windows, Linux và Solaris.

  * Khả năng mở rộng: MySQL có thể xử lý hơn 50 triệu hàng và có khả năng mở rộng để quản lý các tập dữ liệu lớn.

  * Bảo mật: Có lớp bảo mật dữ liệu mạnh mẽ, giúp xử lý thông tin nhạy cảm một cách an toàn.


## Nhược điểm

  * Hiệu suất theo quy mô: Hiệu quả của MySQL giảm dần khi dữ liệu mở rộng, đặc biệt là trong các tình huống truy vấn phức tạp hoặc ghi nhiều.

  * Công cụ hạn chế: So với các cơ sở dữ liệu khác, MySQL có ít công cụ phát triển và gỡ lỗi nâng cao hơn.


  1. **PostgreSQL (Postgres) là gì?**


|<image_2>|

PostgreSQL còn được gọi là Postgres, là một hệ thống quản lý cơ sở dữ liệu quan hệ đối tượng (ORDBMS) mã nguồn mở, cấp doanh nghiệp. Nó hỗ trợ cả truy vấn SQL (quan hệ) và JSON (phi quan hệ), mang lại khả năng mở rộng và thích ứng cao hơn MySQL.

## Ưu điểm của việc sử dụng PostgreSQL

  * Hiệu suất: PostgreSQL xử lý các truy vấn phức tạp và dữ liệu quy mô lớn với hiệu quả cao hơn.

  * Khả năng mở rộng: Hỗ trợ các kiểu do người dùng định nghĩa và nhiều ngôn ngữ thủ tục khác nhau.

  * Tuân thủ ACID: PostgreSQL đảm bảo độ tin cậy cao và khả năng chịu lỗi với tính năng ghi nhật ký trước.

  * Khả năng không gian địa lý: Hỗ trợ các đối tượng địa lý, lý tưởng cho các dịch vụ và ứng dụng dựa trên vị trí.


## Nhược điểm của PostgreSQL

  * Đường cong học tập: PostgreSQL có thể khó học và cấu hình hơn so với MySQL.

  * Hiệu suất ở quy mô nhỏ hơn: Có thể chậm hơn đối với các hoạt động đơn giản, quy mô nhỏ.


# Tại sao nên di chuyển từ MySQL sang PostgreSQL

Di chuyển cơ sở dữ liệu là một quá trình quan trọng mà các doanh nghiệp cần thực hiện để đáp ứng nhu cầu dữ liệu đang thay đổi, cải thiện hiệu suất hoặc giảm chi phí. Dưới đây là một số lý do tại sao bạn nên cân nhắc di chuyển từ MySQL sang PostgreSQL:

  * Hiệu suất tốt hơn: Nếu cơ sở dữ liệu MySQL hiện tại của bạn gặp khó khăn với các truy vấn phức tạp hoặc tập dữ liệu lớn, PostgreSQL có thể cung cấp khả năng tăng cường hiệu suất mà bạn cần.

  * Tính năng nâng cao: Hỗ trợ của PostgreSQL cho các kiểu dữ liệu nâng cao và khả năng không gian địa lý có thể mang lại sự linh hoạt hơn trong việc xử lý dữ liệu.

  * Hiệu quả về chi phí: Di chuyển sang PostgreSQL có thể giảm chi phí lưu trữ và vận hành, đặc biệt nếu MySQL không được tối ưu hóa cho các trường hợp sử dụng của bạn.


## Di chuyển dữ liệu so với sao chép dữ liệu

Điều quan trọng là phải phân biệt giữa di chuyển và sao chép cơ sở dữ liệu:

  * [Di chuyển cơ sở dữ liệu](https://estuary.dev/data-migration-solution/) thường là một quá trình một lần trong đó dữ liệu được di chuyển từ MySQL sang PostgreSQL với mục đích chuyển hoàn toàn sang PostgreSQL.

  * [Sao chép cơ sở dữ liệu](https://estuary.dev/database-replication/) bao gồm việc sao chép dữ liệu liên tục giữa MySQL và PostgreSQL, cho phép bạn duy trì đồng bộ cả hai cơ sở dữ liệu.


Tùy thuộc vào nhu cầu, bạn có thể chọn giải pháp này hay giải pháp kia. Ví dụ, nếu ứng dụng của bạn phụ thuộc nhiều vào các truy vấn phức tạp, việc chuyển đổi hoàn toàn sang PostgreSQL có thể mang lại lợi ích. Tuy nhiên, nếu bạn cần sự đơn giản của MySQL cho một số tác vụ nhất định, thì sao chép liên tục có thể là giải pháp tốt hơn.

# Phương pháp Di chuyển dữ liệu từ MySQL sang PostgreSQL

## Phương pháp 1: Kết nối MySQL với PostgreSQL bằng Estuary

Estuary Flow là một nền tảng tích hợp dữ liệu thời gian thực mạnh mẽ được thiết kế để đơn giản hóa và tối ưu hóa quy trình sao chép giữa MySQL và PostgreSQL. Với Estuary, bạn có thể dễ dàng thiết lập nhiều tích hợp dữ liệu khác nhau, bao gồm [MySQL với BigQuery](https://estuary.dev/connect-mysql-to-bigquery/) và [MySQL với Snowflake](https://estuary.dev/connect-mysql-to-snowflake/) , cùng nhiều kết nối khác. 

Tại sao nên chọn Estuary Flow để di chuyển từ MySQL sang PostgreSQL?

  * Giao diện thân thiện với người dùng: Ứng dụng web trực quan của Flow chỉ yêu cầu chuyên môn kỹ thuật tối thiểu, giúp thiết lập và quản lý đường ống dữ liệu dễ dàng hơn so với các công cụ dòng lệnh hoặc công cụ có tập lệnh.

  * Đồng bộ hóa dữ liệu theo thời gian thực: Estuary Flow thực hiện việc sao lưu toàn bộ dữ liệu MySQL của bạn vào PostgreSQL, sau đó truyền dữ liệu theo thời gian thực. Điều này đảm bảo cả hai cơ sở dữ liệu luôn đồng bộ trong vòng vài mili giây, giảm thiểu độ trễ dữ liệu.

  * Sao chép hiệu quả về chi phí: Sử dụng tính năng ghi lại dữ liệu thay đổi (CDC) cho MySQL, Flow chỉ ghi lại và chuyển những thay đổi được thực hiện trên dữ liệu của bạn. Phương pháp này ít tốn tài nguyên tính toán hơn và giảm chi phí vận hành so với các công cụ di chuyển dữ liệu truyền thống.

  * Độ tin cậy cao: Flow đảm bảo khả năng phục hồi dữ liệu bằng cách lưu trữ dữ liệu MySQL đã thu thập trong các bộ sưu tập được hỗ trợ bởi đám mây trước khi ghi vào PostgreSQL. Cơ chế này đảm bảo tính toàn vẹn của dữ liệu và cung cấp khả năng lưu trữ ngữ nghĩa chính xác một lần, bảo vệ dữ liệu khỏi nguy cơ mất mát.


Hướng dẫn từng bước: Di chuyển MySQL sang PostgreSQL bằng Estuary Flow:

  * Bước 1: Đăng ký miễn phí trên Estuary: Bắt đầu bằng cách [đăng ký](https://dashboard.estuary.dev/) tài khoản miễn phí trên nền tảng Estuary. Đối với nhu cầu sản xuất quy mô lớn, bạn có thể [liên hệ với](https://estuary.dev/contact-us) Estuary để đăng ký tài khoản tổ chức.

  * Bước 2: Chuẩn bị cơ sở dữ liệu MySQL của bạn


Đăng nhập vào [ứng dụng web](https://dashboard.estuary.dev/) Estuary và đảm bảo rằng cơ sở dữ liệu MySQL của bạn đáp ứng [các điều kiện tiên quyết](https://docs.estuary.dev/reference/Connectors/capture-connectors/MySQL/#prerequisites) .

  * Bước 3: Thu thập dữ liệu MySQL theo thời gian thực


Điều hướng đến tab Ảnh chụp và chọn Ảnh chụp mới.

Chọn ô MySQL và điền các thông tin bắt buộc, bao gồm địa chỉ máy chủ MySQL, tên người dùng cơ sở dữ liệu và mật khẩu.

Chọn các bảng bạn muốn ghi lại và xuất bản cài đặt của mình.

|<image_3>|

  * Bước 4: Chuyển sang Postgres


Chọn ô PostgreSQL trong phần Materialize.

Cung cấp thông tin đăng nhập cơ sở dữ liệu PostgreSQL cần thiết, bao gồm địa chỉ cơ sở dữ liệu, tên người dùng và mật khẩu.

Ánh xạ dữ liệu MySQL đã thu thập vào các bảng mới trong PostgreSQL và xuất bản dữ liệu.

Estuary Flow hiện sẽ xử lý việc sao chép dữ liệu theo thời gian thực, đảm bảo rằng mọi dữ liệu mới trong MySQL đều được tự động thu thập và sao chép sang PostgreSQL.

|<image_4>|

Để biết thêm trợ giúp về phương pháp này, hãy xem tài liệu Estuary Flow trên:

[Cách tạo luồng dữ liệu](https://docs.estuary.dev/guides/create-dataflow/)

[Trình kết nối MySQL](https://docs.estuary.dev/reference/Connectors/capture-connectors/MySQL/)

[Trình kết nối PostgreSQL](https://docs.estuary.dev/reference/Connectors/capture-connectors/PostgreSQL/)

## Phương pháp 2: Sử dụng pg-chameleon cho MySQL để sao chép liên tục từ PostgreSQL

|<image_5>|

[pg-chameleon](https://pypi.org/project/pg-chameleon/) là một công cụ Python tận dụng tính năng sao chép gốc của MySQL, chuyển đổi dữ liệu sang PostgreSQL. Phương pháp này lý tưởng cho việc sao chép liên tục, đảm bảo dữ liệu của bạn được đồng bộ hóa liên tục giữa MySQL và PostgreSQL. Tuy nhiên, lưu ý rằng quá trình này có thể gây ra một chút chậm trễ do bản chất của việc sao chép.

## Phương pháp 3: Sử dụng pgloader làm công cụ di chuyển MySQL sang PostgreSQL

[pgloader](https://pgloader.readthedocs.io/en/latest/) là một công cụ dòng lệnh mạnh mẽ giúp đơn giản hóa quá trình di chuyển dữ liệu từ MySQL sang PostgreSQL. Công cụ này đặc biệt phù hợp cho việc di chuyển một lần và hỗ trợ nhiều nguồn dữ liệu khác nhau. Cách thiết lập như sau:

  * Bước 1: Cài đặt pgloader: Thiết lập dễ dàng cho quá trình di chuyển của bạn


pgloader có sẵn thuận tiện thông qua hầu hết các trình quản lý gói. Hãy sử dụng các lệnh sau dựa trên hệ điều hành của bạn:

Debian/Ubuntu:apt-get install pgloader

macOS:brew install pgloader

Đối với các hệ thống khác, hãy tải xuống tệp nhị phân trực tiếp từ trang web pgloader chính thức.

  * Bước 2: Thu thập thông tin xác thực cơ sở dữ liệu


Xác định vị trí thông tin kết nối MySQL và PostgreSQL của bạn trong các tệp cấu hình tương ứng:

MySQL: Thường được tìm thấy trong my.cnf(hoặc tương tự).

PostgreSQL: Thường được tìm thấy trong postgresql.conf.

Những thông tin chi tiết này thường bao gồm:

Tên máy chủ/Địa chỉ IP: Máy chủ nơi cơ sở dữ liệu đang chạy.

Cổng: Số cổng được sử dụng để kết nối cơ sở dữ liệu.

Tên người dùng: Tên người dùng có quyền truy cập vào cơ sở dữ liệu.

Mật khẩu: Mật khẩu được liên kết với tên người dùng.

Tên cơ sở dữ liệu: Tên của cơ sở dữ liệu cụ thể mà bạn muốn di chuyển.

Ngoài ra, bạn có thể thấy các thông tin xác thực này được đặt dưới dạng biến môi trường.

  * Bước 3: Tinh chỉnh quá trình di chuyển của bạn bằng Tệp cấu hình (Tùy chọn)


Để kiểm soát và tùy chỉnh chi tiết hơn, hãy tạo một .loadtệp. Tệp này cho phép bạn xác định cách thức xử lý các khía cạnh khác nhau của quá trình di chuyển:

Ánh xạ kiểu dữ liệu: Chỉ định cách chuyển đổi kiểu dữ liệu MySQL sang kiểu dữ liệu PostgreSQL tương đương.

Chọn bảng: Chọn các bảng cụ thể để di chuyển hoặc loại trừ một số bảng nhất định.

Thao tác lược đồ: Kiểm soát việc tạo và sửa đổi lược đồ.

Lập chỉ mục: Quản lý việc tạo chỉ mục trong quá trình di chuyển.

|<image_6>|

  * Bước 4: Thực thi pgloader: Khởi chạy quá trình di chuyển MySQL sang PostgreSQL


Sau khi đã chuẩn bị xong thông tin kết nối và tệp cấu hình (tùy chọn), hãy bắt đầu di chuyển bằng lệnh sau:

|<image_7>|

Thay thế chỗ giữ chỗ bằng thông tin xác thực của bạn.

Nếu bạn đã tạo .loadtệp cấu hình, hãy đưa tệp đó vào lệnh:

|<image_8>|

Để biết danh sách đầy đủ các tùy chọn và thông tin chi tiết về cấu hình, hãy tham khảo tài liệu pgloader chính thức.

# Chọn công cụ đường ống dữ liệu phù hợp

Khi lựa chọn công cụ di chuyển MySQL sang PostgreSQL , điều quan trọng là phải hiểu rõ cả cơ chế tích hợp và chi phí liên quan. Các công cụ như Estuary Flow vượt trội nhờ sử dụng [đồng bộ hóa dữ liệu theo thời gian thực](https://estuary.dev/real-time-data-replication/) thay vì xử lý hàng loạt truyền thống, giúp tránh tình trạng chậm trễ và nhu cầu quét cơ sở dữ liệu nhiều lần. Phương pháp này không chỉ hiệu quả hơn mà còn tiết kiệm chi phí, đặc biệt là cho nhu cầu sao chép liên tục.

Trước khi đưa ra quyết định, hãy đảm bảo rằng công cụ di chuyển bạn chọn phù hợp với các yêu cầu cụ thể và nằm trong phạm vi ngân sách của bạn.

# Phần Kết luận

Di chuyển và sao chép cơ sở dữ liệu là một khía cạnh quan trọng trong chiến lược và kiến ​​trúc dữ liệu của mọi doanh nghiệp. Khi các yêu cầu và trường hợp sử dụng thay đổi, việc sở hữu đúng loại cơ sở dữ liệu trở nên quan trọng hơn bao giờ hết.

MySQL và PostgreSQL đều có vị trí và trường hợp sử dụng tối ưu riêng. Cho dù mục tiêu của bạn là chuyển đổi vĩnh viễn từ cái này sang cái kia hay duy trì cả hai song song, chúng tôi hy vọng hướng dẫn này sẽ giúp bạn đơn giản hóa quy trình.

# Public_187

Khi điện thoại thông minh ngày càng trở nên phổ biến hơn và trở thành một phương tiện không thể tách rời với đời sống của con người, các doanh nghiệp cũng đã và đang dần chú trọng hơn vào việc phát triển ứng dụng di động. Trong lĩnh vực công nghệ, Flutter là một khái niệm còn khá mới mẻ, và hẳn nhiều người còn chưa nắm bắt rõ hết về thuật ngữ này. Vậy để biết được Flutter là gì, hãy tiếp tục khám phá ở phần bên dưới.

|<image_1>|

# Tổng quan về Flutter

## Flutter là gì?

Giải đáp cho câu hỏi “Flutter là gì” thì nó là một [framework](https://fptshop.com.vn/tin-tuc/danh-gia/framework-la-gi-tuyen-tap-nhung-dieu-ban-can-biet-ve-nen-tang-lap-trinh-framework-167288) mã nguồn mở dùng để phát triển ứng dụng di động và web đa nền tảng, được tạo ra và phát triển bởi Google. Flutter là công cụ cho phép các nhà phát triển tạo ra giao diện người dùng (UI) cho ứng dụng trên nhiều hệ điều hành và nền tảng chỉ bằng một mã nguồn duy nhất.

|<image_2>|

Ban đầu khi vừa mới ra mắt vào năm 2018, Flutter chủ yếu hỗ trợ phát triển ứng dụng di động. Tuy nhiên, từ đó đến nay, Flutter đã mở rộng phát triển ứng dụng trên sáu nền tảng khác nhau, bao gồm: iOS, Android, web, Windows, MacOS và Linux.

## Ngôn ngữ lập trình của Flutter

Sau khi đã biết Flutter là gì, liệu bạn có thắc mắc Flutter sử dụng ngôn ngữ lập trình nào không? Ngôn ngữ lập trình Dart chính là ngôn ngữ được Flutter sử dụng để phát triển ứng dụng. Dart là một ngôn ngữ hiện đại, hướng đối tượng, được phát triển bởi Google, nổi bật với khả năng phát triển các ứng dụng web, di động một cách nhanh chóng và linh hoạt. Dart không chỉ là ngôn ngữ cơ sở mà còn là công cụ chính trong việc xây dựng framework Flutter.

|<image_3>|

Khi sử dụng Dart trong Flutter, các nhà phát triển có thể tạo ra các ứng dụng di động đa nền tảng với giao diện đẹp, khả năng tùy chỉnh cao và hiệu suất ổn định. Điều này giúp tối ưu hóa quá trình phát triển, mang lại trải nghiệm người dùng tốt hơn trên nhiều loại thiết bị và hệ điều hành khác nhau.

# Các thành phần chính của Flutter

Tiếp nối phần giải đáp "Flutter là gì" và ngôn ngữ mà công cụ này sử dụng sẽ là các thành phần chính của Flutter. Flutter có hai thành phần chính quan trọng như sau:

  * Framework (Thư viện giao diện người dùng dựa trên widgets): Framework trong Flutter cung cấp một tập hợp các thành phần giao diện, cho phép người dùng tái sử dụng những mã code giữa các module và dự án khác nhau trên framework một cách dễ dàng, thuận tiện hơn. Điều này giúp tối ưu hóa quá trình phát triển ứng dụng, tiết kiệm thời gian và giúp tạo ra các ứng dụng có thể tùy chỉnh linh hoạt theo nhu cầu cụ thể của người dùng.

  * SDK (Bộ kit phát triển phần mềm): SDK là bộ công cụ quan trọng hỗ trợ người dùng trong việc phát triển ứng dụng, bao gồm một loạt các công cụ như trình biên dịch, thư viện, và các tiện ích hỗ trợ khác. Nhờ vào SDK, các nhà phát triển có thể tạo ra ứng dụng trên nhiều nền tảng khác nhau như iOS, Android, web, Windows, MacOS và Linux. SDK cung cấp các công cụ để biên dịch mã nguồn thành mã gốc (native code) tương ứng với từng hệ điều hành, giúp ứng dụng hoạt động mượt mà và hiệu quả.


|<image_4>|

# Các widget trong Flutter

Trong Flutter, các widget là những thành phần cơ bản giúp xây dựng giao diện người dùng. Dưới đây là một số widget phổ biến và ví dụ minh họa cách chúng hoạt động:

  * Text


Đây là widget cơ bản hỗ trợ hiển thị văn bản trong ứng dụng của bản, và thuộc tính quan trọng nhất của widget này là style.

|<image_5>|

  * Column và Row


Column và Row là các widget sắp xếp các thành phần con theo chiều dọc (Column) hoặc chiều ngang (Row).

  * Ví dụ sử dụng Column:


|<image_6>|

Ví dụ sử dụng Row:

|<image_7>|

  * Stack: Stack là một tập hợp các widget, các widget con trong stack có thể xếp chồng lên nhau.


|<image_8>|

  * Container


Container widget định nghĩa một phần tử giao diện với các thuộc tính như màu sắc, kích thước, padding, margin,…

|<image_9>|

  * SizedBox


Widget này dùng để thiết lập một hộp có kích thước cố định.

|<image_10>|

  * SingleChildScrollView


Khi bạn có một row hay column mà heigh hoặc width của nó vượt quá độ lớn của màn hình điện thoại, bạn có thể sử dụng SingleChildScrollView widget để cuộn nội dung trong một không gian nhất định.

|<image_11>|

  * Expanded


Expanded widget cho phép mở rộng một widget con theo không gian còn trống trong một row, column hoặc flex.

|<image_12>|

# Những tính năng của Flutter

  * Dễ sử dụng: Flutter sử dụng ngôn ngữ lập trình Dart, một ngôn ngữ đơn giản, linh hoạt và dễ tiếp cận. Các nhà phát triển rất dễ dàng để học và sử dụng Dart để xây dựng ứng dụng.

  * Tính năng Hot Reload: Hot Reload trong Flutter cho phép nhà phát triển xem kết quả ngay lập tức sau khi thực hiện các thay đổi trong mã nguồn, giúp tối ưu hóa quá trình phát triển bằng cách cung cấp khả năng chỉnh sửa, thử nghiệm và sửa lỗi nhanh chóng.

  * Các widget tích hợp sẵn: Flutter cung cấp các widget tích hợp sẵn với thiết kế đẹp mắt và phong phú, giúp tạo ra giao diện người dùng mượt mà, tự nhiên. Những widget này hỗ trợ việc xây dựng giao diện đa dạng và tương thích trên nhiều nền tảng.


|<image_13>|

  * Hiệu năng cao: Flutter tập trung vào việc cải thiện hiệu năng của ứng dụng, giúp ứng dụng không bị lag lúc sử dụng, ngay cả trên các thiết bị có cấu hình thấp.

  * Thể hiện cùng một UI trên nhiều nền tảng: Với Flutter, bạn có thể xây dựng một giao diện người dùng đồng nhất và triển khai nó trên nhiều nền tảng khác nhau như iOS, Android, web hay desktop. Điều này giúp tiết kiệm thời gian và tài nguyên phát triển.

  * Giải quyết thách thức trong giao diện người dùng: Flutter cung cấp cách tiếp cận linh hoạt để giải quyết các thách thức trong việc thiết kế giao diện người dùng, thông qua việc sử dụng các layout, platform và widget phong phú.


# Tại sao nên dùng Flutter phát triển ứng dụng?

Với tốc độ phát triển nhanh chóng của Flutter như hiện tại, đây xứng đáng là một framework hàng đầu mà bạn có thể lựa chọn khi nó sở hữu các ưu điểm vượt trội sau:

  * Tiết kiệm thời gian, công sức: Với single code-base, Flutter cho phép chỉ cần viết mã một lần và có thể triển khai trên nhiều hệ điều hành khác nhau, giúp tiết kiệm thời gian, công sức và giảm chi phí phát triển ứng dụng.

  * Kiến trúc phân lớp linh hoạt: Flutter sử dụng kiến trúc phân lớp, cho phép tùy chỉnh và kiểm soát toàn bộ giao diện người dùng một cách linh hoạt, không cần phải phân tách thành phần UI cho từng nền tảng riêng.

  * Xem kết quả ngay lập tức: Tính năng Hot Reload của Flutter giúp xem kết quả ngay lập tức sau khi thay đổi mã code mà không cần phải biên dịch lại từng lần, hỗ trợ tăng tốc độ phát triển, cho phép sửa lỗi và thử nghiệm nhanh chóng với nhiều phiên bản UI khác nhau.


|<image_14>|

  * Tùy chỉnh toàn bộ giao diện người dùng: Flutter cung cấp quyền kiểm soát mọi pixel trên màn hình, từ việc tạo hoạt ảnh cho đến điều khiển các phần tử đồ họa, video và văn bản.

  * Hỗ trợ đa nền tảng, đồng nhất: Flutter không chỉ áp dụng cho di động mà còn cho web, cung cấp tài liệu rõ ràng cho việc kiểm tra chức năng trên các điều khiển gốc. Nó còn loại bỏ lỗi không tương thích giữa các phiên bản hệ thống, đảm bảo giao diện người dùng đồng nhất trên tất cả các nền tảng.

  * Hiệu suất cao và trải nghiệm người dùng tốt: Ứng dụng Flutter có thể hoạt động tốt trong các tình huống giao diện người dùng phức tạp, loại bỏ các lỗi hiệu suất có thể xảy ra do không sử dụng cầu nối JavaScript hay code trung gian.

  * Cộng đồng rộng lớn: Flutter có nhiều ưu điểm nổi bật hơn so với các framework khác, do đó đã thu hút một lượng lớn các lập trình viên, tạo nên một cộng đồng tích cực, sẵn sàng cung cấp và hỗ trợ lẫn nhau.


# Hạn chế còn tồn đọng

Thế nhưng, bên cạnh các lí do để bạn lựa chọn sử dụng Flutter, thì framework này vẫn còn một số nhược điểm chưa được khắc phục hoàn toàn:

  * Chưa ổn định: Là một framework đang trong quá trình phát triển, Flutter đôi khi không ổn định và một số thư viện cần được kiểm tra kỹ trước khi sử dụng.

  * Kích thước tệp lớn: Ứng dụng sử dụng Flutter thường có kích thước tệp lớn, dẫn đến thời gian khởi động và tải ứng dụng lâu hơn, có thể gây ra hiệu suất kém, ảnh hưởng đến trải nghiệm người dùng.

  * Thường xuyên thay đổi: Flutter thường xuyên có các thay đổi và cập nhật, đôi khi sẽ ảnh hưởng đến quá trình phát triển khi mã nguồn cần được duy trì liên tục.

  * Thiếu hướng dẫn phát triển chuẩn: So với các framework ổn định khác, Flutter còn thiếu các hướng dẫn và nguyên tắc phát triển chuẩn hóa, dẫn đến việc xây dựng các ứng dụng phức tạp trở nên khó khăn hơn.


|<image_15>|

Tuy nhiên nếu đã cân nhắc kỹ lưỡng, và bạn cảm thấy rằng các nhược điểm này không ảnh hưởng quá lớn đến mục tiêu và yêu cầu cụ thể của dự án phát triển, Flutter vẫn là một lựa chọn đáng xem xét cho phát triển ứng dụng di động.

# Flutter phù hợp với đối tượng doanh nghiệp nào?

Để biết được Flutter có phù hợp với doanh nghiệp của mình hay không, bạn có thể tham khảo các đối tượng doanh nghiệp nên sử dụng Flutter sau:

  * **Các Start-up:** Flutter là lựa chọn lý tưởng cho các start-up vì tính linh hoạt và chi phí thấp. Công cụ miễn phí này cung cấp đủ các yêu cầu trong phát triển ứng dụng chất lượng cao mà không đòi hỏi nhiều nguồn lực.

  * **Doanh nghiệp có nguồn lực hạn chế:** Những doanh nghiệp có nguồn lực hạn chế về thời gian hoặc ngân sách sẽ tận dụng được các ưu điểm vượt trội của Flutter, giúp doanh nghiệp tiết kiệm nguồn lực mà vẫn tạo ra ứng dụng chất lượng.

  * **Doanh nghiệp cần tạo Minimum Viable Product (MVP):** Flutter là lựa chọn tốt để phát triển MVP. Với khả năng linh hoạt, dễ sử dụng, nó hỗ trợ tạo ra sản phẩm khả thi tối thiểu để kiểm tra thị trường và thu hút người dùng một cách hiệu quả.


|<image_16>|

Ngược lại, có một số đối tượng doanh nghiệp không phù hợp với Flutter:

  * **Doanh nghiệp lớn:** Flutter có thể không phải là một lựa chọn phù hợp với những doanh nghiệp có đội ngũ nhân viên và các lập trình viên đông đảo. Việc tìm kiếm những người sử dụng ngôn ngữ Dart có thể gây khó khăn, và công cụ này vẫn còn hạn chế so với các nền tảng khác.

  * **Doanh nghiệp cần ứng dụng tùy chỉnh cao:** Nếu doanh nghiệp cần một ứng dụng với tính tùy chỉnh cao hoặc yêu cầu nhiều tính năng phức tạp, Flutter có thể không phải là lựa chọn tốt nhất. Sự hạn chế trong việc kết nối với các thư viện bên thứ ba có thể làm giảm tính linh hoạt trong việc tùy chỉnh ứng dụng.


|<image_17>|

# Kết luận

Bài viết vừa giải đáp xong cho bạn câu trả lời “Flutter là gì”, ngôn ngữ lập trình mà framework này sử dụng cũng như các widget, tính năng, ưu, nhược điểm của Flutter, và gợi ý các đối tượng doanh nghiệp nào sẽ phù hợp để sử dụng công cụ này nhất, hy vọng rằng bạn sẽ có thêm một thông tin bổ ích!

# Public_188

Git hoạt động bằng cách lưu trữ, theo dõi và quản lý sự thay đổi của mã nguồn trong dự án phần mềm. Nền tảng cung cấp các công cụ để làm việc song song, quản lý nhánh và hợp nhất các thay đổi một cách linh hoạt và hiệu quả. Người học lập trình nên nắm bắt các thuật ngữ quan trọng trong Git.

# Một số khái niệm cơ bản cần biết

## Git là gì

Git là một hệ thống quản lý phiên bản phân tán được sử dụng rộng rãi trong phát triển phần mềm. Nền tảng cho phép các nhà phát triển lưu trữ mã nguồn và theo dõi lịch sử thay đổi của mã nguồn đó theo thời gian.

Ở mức cơ bản, Git hoạt động bằng cách lưu trữ các phiên bản khác nhau của dự án phần mềm trong một kho lưu trữ. Hệ thống cho phép người dùng theo dõi sự thay đổi giữa các phiên bản, khôi phục lại các phiên bản trước đó và làm việc song song trên cùng một tệp tin.

|<image_1>|

Git có tính phân tán mạnh mẽ hơn những công cụ khác. Điều này có nghĩa là mỗi người dùng đều nhận bản sao đầy đủ của toàn bộ kho lưu trữ, không phụ thuộc vào kết nối mạng hoặc máy chủ tập trung. Hệ thống cho phép các nhà phát triển làm việc nhanh chóng va phòng tránh mất dữ liệu do mất kết nối với máy chủ.

Hệ thống Git được sử dụng rộng rãi trong cộng đồng phát triển phần mềm vì tính linh hoạt, mạnh mẽ. Đặc biệt, công cụ có khả năng tương tác tốt với nhiều dịch vụ lưu trữ mã nguồn trực tuyến khác nhau như GitHub, Bitbucket và GitLab.

## Version Control System – VCS là gì?

Hệ thống quản lý phiên bản (VCS) hay còn gọi là hệ thống quản lý mã nguồn. Đây là một hệ thống có tác quản lý, theo dõi và kiểm soát sự thay đổi của mã nguồn phần mềm. Mục tiêu chính của VCS là theo dõi lịch sử thay đổi của tất cả các tập tin và cấu trúc thư mục trong dự án phần mềm.

VCS cho phép các nhà phát triển làm việc song song trên cùng một dự án mà không gặp xung đột. Công nghệ hỗ trợ lưu trữ phiên bản của mã nguồn tại mọi thời điểm và khôi phục lại các phiên bản trước đó nếu cần. 

|<image_2>|

Ngoài ra, VCS cũng giúp quản lý việc tích hợp mã nguồn từ nhiều nguồn khác nhau và tạo ra các nhánh (branch) của mã nguồn. Mục đích nhằm phát triển song song các tính năng hay chế độ sửa lỗi mà không ảnh hưởng đến nhau.

Có hai loại chính của VCS là hệ thống quản lý phiên bản cục bộ (Local Version Control System) và hệ thống quản lý phiên bản phân tán (Distributed Version Control System). Git là một ví dụ điển hình của hệ thống quản lý phiên bản phân tán. Trong khi đó, Subversion (SVN) chính là một hệ thống quản lý phiên bản cục bộ phổ biến khác.

# Những tác dụng phổ biến của VCS

Hệ thống quản lý phiên bản (VCS) có tác dụng quản lý và theo dõi sự thay đổi của mã nguồn trong dự án phần mềm. Cụ thể, VCS thực hiện các chức năng sau:

|<image_3>|

  * Lưu trữ phiên bản của mã nguồn: VCS lưu trữ tất cả các phiên bản khác nhau của mã nguồn, cho phép nhà phát triển quay lại các phiên bản trước đó nếu cần.

  * Theo dõi lịch sử thay đổi: Nền tảng tự động ghi lại tất cả các thay đổi được thực hiện trên mã nguồn, cung cấp lịch sử rõ ràng về sự phát triển của dự án.

  * Quản lý tích hợp từ nhiều nguồn: VCS cho phép tích hợp mã nguồn từ nhiều nguồn khác nhau, giúp tăng tính linh hoạt và hiệu quả trong quá trình phát triển.

  * Phát triển song song: Hệ thống hỗ trợ nhà phát triển làm việc song song trên cùng một dự án mà không gặp xung đột, thông qua việc tạo và quản lý các nhánh (branch) riêng biệt.

  * Hỗ trợ hợp nhất mã nguồn: VCS áp dụng chế độ hợp nhất (merge) mã nguồn từ các nhánh khác nhau, giúp nhà phát triển kết hợp các tính năng và sửa lỗi một cách hiệu quả.


# Nguyên lý hoạt động chung của Git

Git hoạt động bằng cách lưu trữ dự án phần mềm trong một kho lưu trữ (repository) và theo dõi lịch sử các thay đổi của mã nguồn trong dự án. Quá trình hoạt động chính của Git được giới thiệu như sau:

|<image_4>|

## Khởi tạo kho lưu trữ (Repository)

Người dùng sẽ khởi tạo một kho lưu trữ (Repository) để lưu trữ mã nguồn của dự án. Kho lưu trữ có thể ở địa phương trên máy tính hoặc trên các dịch vụ lưu trữ mã nguồn trực tuyến như GitHub, Bitbucket, GitLab.

## Làm việc trên mã nguồn

Người dùng thực hiện các thay đổi trên mã nguồn một cách trực tiếp. Trong đó bao gồm việc thêm, sửa đổi và xóa tập tin trong dự án phần mềm.

## Theo dõi thay đổi

Sau khi thực hiện các thay đổi, người dùng sẽ sử dụng lệnh "Git Add" để chấp nhận những thay đổi cụ thể và chuẩn bị chúng để được Commit vào lịch sử.

## Commit thay đổi

Người dùng sẽ sử dụng lệnh "Git Commit" để lưu trữ các thay đổi đã được chấp nhận vào lịch sử của dự án. Mỗi lần Commit sẽ tạo ra một Checkpoint để lưu trữ các tập tin và thay đổi tương ứng.

|<image_5>|

## Công việc với nhánh (Branch)

Git cho phép người dùng tạo và quản lý các nhánh (Branch) để phát triển tính năng, sửa lỗi mà không ảnh hưởng đến nhau. Việc làm việc trên các nhánh riêng biệt giúp tăng tính linh hoạt và an toàn trong quá trình phát triển.

## Hợp nhất (Merge) và xung đột

Git cho phép người dùng hợp nhất các thay đổi từ các nhánh khác nhau lại với nhau. Trong trường hợp có xung đột (Conflict), Git sẽ cung cấp cách giải quyết xung đột thông qua việc so sánh và hợp nhất sự khác biệt giữa các phiên bản.

# Lợi ích đặc biệt khi sử dụng Git

Khi sử dụng phần mềm Git, người dùng có thể hưởng lợi ích từ các tính năng cơ bản, bao gồm:

|<image_6>|

  * Hệ thống cho phép người dùng theo dõi lịch sử thay đổi của mã nguồn, bao gồm việc xem thông tin về ai đã thực hiện thay đổi, khi nào và thay đổi gì. Điều này giúp trong việc xác định nguyên nhân sự cố và theo dõi tiến độ công việc.

  * Công cụ hỗ trợ làm việc song song và độc lập trên cùng một dự án thông qua việc tạo và quản lý các nhánh (branch). Điều này tạo ra tính linh hoạt và an toàn khi thực hiện phát triển các tính năng và sửa lỗi.

  * Git cung cấp cách thức hợp nhất các thay đổi từ các nhánh khác nhau về một nhánh chính một cách hiệu quả, giúp người dùng kết hợp các tính năng và sửa lỗi một cách dễ dàng.

  * Người dùng có thể sao lưu mã nguồn và lịch sử thay đổi trên các máy chủ từ xa hoặc dịch vụ lưu trữ mã nguồn trực tuyến. Điều này giúp bảo vệ mã nguồn khỏi mất mát dữ liệu.

  * Git cung cấp cơ chế để phối hợp làm việc trong nhóm, cho phép các nhà phát triển cùng làm việc trên các phiên bản khác nhau của dự án một cách hiệu quả.


# Tổng hợp các thuật ngữ quan trọng

|<image_7>|

  * **Branch**


Branch trong Git là một phiên bản song song của dự án phần mềm. Khi người dùng tạo một nhánh, họ đang tạo ra một bản sao của toàn bộ lịch sử và tập tin trong dự án.

Việc sử dụng nhánh cho phép người dùng phát triển tính năng mới, sửa lỗi hoặc thực hiện các thay đổi mà không ảnh hưởng đến phiên bản chính của dự án. Khi một tính năng hoặc sửa lỗi được hoàn thành trong nhánh, người dùng có thể hợp nhất (Merge) nhánh đó với nhánh chính của dự án để tích hợp các thay đổi mới vào phiên bản chính.

  * **Commit**


Trong Git, thuật ngữ "Commit" được sử dụng để mô tả hành động lưu trữ một bản sao mới của lịch sử thay đổi và tập tin của dự án. Khi người dùng thực hiện Commit, họ chấp nhận các thay đổi đã được "Staged" (chuẩn bị) và lưu trữ chúng vào lịch sử của dự án.

  * **Checkout**


Thuật ngữ được sử dụng để mô tả hành động chuyển đổi giữa các nhánh hoặc thay đổi "HEAD" (trạng thái hiện tại của repository). Khi thực hiện Checkout nghĩa là bạn đang chuyển đổi trạng thái làm việc của bạn từ một nhánh hoặc Commit sang một nhánh hoặc Commit khác.

|<image_8>|

  * **Fetch**


"Fetch" trong Git được sử dụng để tải về mọi thay đổi mới từ Repository từ xa mà không thực hiện hợp nhất (Merge) với bất kỳ nhánh nào. 

Quá trình Fetch giúp cập nhật thông tin về các nhánh và Commit từ Repository từ xa, nhưng không thay đổi trạng thái làm việc hiện tại của bạn. Điều này cho phép bạn xem xét các thay đổi từ Repository từ xa trước khi quyết định hợp nhất với nhánh hiện tại của bạn.

  * **Fork**


Fork không phải là một thuật ngữ trực tiếp trong Git mà thường được sử dụng trong ngữ cảnh của dịch vụ lưu trữ mã nguồn trực tuyến như GitHub. 

Khi Fork một Repository trên GitHub nghĩa là bạn đang tạo ra một bản sao độc lập của Repository đó trong tài khoản GitHub. Bản Fork có thể được sử dụng để đề xuất các thay đổi cho Repository gốc thông qua các Pull Request mà không ảnh hưởng trực tiếp đến Repository gốc.

  * **Head**


Head là một tham chiếu tới phiên bản hiện tại của mã nguồn trong Repository. Công cụ thường trỏ tới Commit cuối cùng của nhánh hiện tại mà bạn đang làm việc. Khi bạn chuyển đổi nhánh hoặc thực hiện Checkout tới một Commit cụ thể, Head sẽ thay đổi để phản ánh trạng thái hiện tại của bạn trong Repository.

|<image_9>|

  * **Index**


Index cũng được gọi là "Staging Area" và đây là nơi mà các thay đổi được chuẩn bị sẵn sàng để được Commit. Khi thay đổi các tập tin trong Repository thì bạn cần thêm các thay đổi đó vào "Index" trước khi Commit để chúng được lưu trữ vào lịch sử của Repository.

  * **Merge**


Merge là quá trình kết hợp các thay đổi từ một nhánh Git vào nhánh hiện tại của bạn. Khi muốn tích hợp công việc đã thực hiện từ một nhánh phụ (ví dụ nhánh đang phát triển một tính năng mới) vào nhánh chính (thường là "Master" hoặc "Main"), bạn có thể sử dụng thao tác "Merge" để thực hiện việc này.

  * **Origin**


Trong Git, Origin là tên được sử dụng mặc định cho Repository từ xa, thường là Repository gốc mà bạn đã sao chép (cCone) dự án từ đó. 

Khi bạn sao chép một repository từ xa, Git tự động thiết lập một Remote (Repository từ xa) mặc định và đặt tên là "Origin". Khi bạn Push (đẩy) hoặc pull (kéo) các thay đổi đến Repository từ xa, bạn sẽ sử dụng tên "Origin" để định danh đến Repository đó.

  * **Master**


Master là tên chuẩn của nhánh chính trong Git. Thường thì nhánh chính này được gọi là "Master" nhằm đại diện cho phiên bản ổn định nhất của dự án. Tuy nhiên, sau các thay đổi gần đây, nhiều người đang chuyển sang sử dụng thuật ngữ khác như "Main" để thay thế cho "Master" để tránh các từ ngữ mang theo ý nghĩa không tốt về mặt xã hội.

|<image_10>|

# Tạm kết

Những chia sẻ trong bài viết trên giới thiệu hàng loạt kiến thức cơ bản về Gif. Đặc biệt hơn, người học lập trình có thể cập nhật rất nhiều thuật ngữ liên quan đến Gif.

# Public_189

# CƠ SỞ LÝ THUYẾT

## Tổng quan SQL Server

### SQL Server là gì?

SQL Server là gì? SQL Server hay Microsoft SQL Server là một hệ thống quản trị cơ sở dữ liệu quan hệ (Relational Database Management System – RDBMS) được phát triển bởi Microsoft vào năm 1988. Nó được sử dụng để tạo, duy trì, quản lý và triển khai hệ thống RDBMS. 

Được thiết kế để quản lý và lưu trữ dữ liệu, SQL Server cho phép người dùng truy vấn, thao tác và quản lý dữ liệu một cách hiệu quả và an toàn. SQL Server là một trong những hệ quản trị cơ sở dữ liệu phổ biến nhất trên thế giới và được sử dụng rộng rãi trong các doanh nghiệp.

Phần mềm SQL Server được sử dụng khá rộng rãi vì nó được tối ưu để có thể chạy trên môi trường cơ sở dữ liệu rất lớn lên đến Tera – Byte cùng lúc phục vụ cho hàng ngàn user. Bên cạnh đó, ứng dụng này cung cấp đa dạng kiểu lập trình SQL từ ANSI SQL (SQL truyền thống) đến [SQL](https://topdev.vn/blog/sql-la-gi/) và cả T-SQL (Transaction-SQL) được sử dụng cho cơ sở dữ liệu quan hệ nâng cao.

T-SQL là một ngôn ngữ mở rộng của SQL với các tính năng bổ sung như biến, điều kiện, vòng lặp và xử lý ngoại lệ, giúp người dùng viết các đoạn mã SQL mạnh mẽ và linh hoạt hơn.

### Cấu trúc của SQL Server 

Sơ đồ dưới đây minh họa cấu trúc của SQL Server:

|<image_1>|

SQL Server là một hệ quản trị cơ sở dữ liệu phức tạp với nhiều thành phần cấu thành giúp nó hoạt động hiệu quả và đáng tin cậy. Trong đó, SQL Server gồm ba thành phần quan là **Database Engine, External Protocols** và **SQLOS**.

#### Database Engine

Database Engine là thành phần chính của MS SQL Server, chịu trách nhiệm quản lý và xử lý dữ liệu. Nó bao gồm các thành phần con quan trọng sau:

#### Storage Engine

  * File Storage: Quản lý các tệp dữ liệu và tệp nhật ký giao dịch. Dữ liệu được lưu trữ trong các tệp dữ liệu (.mdf và .ndf), trong khi các giao dịch được ghi lại trong tệp nhật ký giao dịch (.ldf).

  * Buffer Manager: Quản lý bộ nhớ đệm (buffer pool), lưu trữ các trang dữ liệu được truy cập gần đây để tăng tốc độ truy vấn.

  * Transaction Log: Ghi lại mọi thay đổi dữ liệu để đảm bảo tính toàn vẹn và khả năng phục hồi của cơ sở dữ liệu.


#### Query Processor

  * Parser: Phân tích cú pháp các câu lệnh SQL và chuyển chúng thành các cây cú pháp (syntax tree) để xử lý tiếp theo.

  * Optimizer: Tối ưu hóa các kế hoạch thực hiện truy vấn để đảm bảo hiệu suất cao nhất. Nó chọn lựa các kế hoạch truy vấn tối ưu dựa trên thống kê và chi phí ước tính.

  * Executor: Thực hiện các kế hoạch truy vấn đã được tối ưu hóa, xử lý các câu lệnh SQL và trả về kết quả.


#### Relational Engine

  * Metadata Manager: Quản lý thông tin về cấu trúc cơ sở dữ liệu như bảng, chỉ mục, ràng buộc và các đối tượng khác.

  * Transaction Manager: Quản lý các giao dịch, đảm bảo tính nhất quán, cách ly và độ bền của các giao dịch thông qua các nguyên tắc ACID.

  * Concurrency Control: Điều khiển đồng thời, sử dụng các kỹ thuật như khóa (locking) và phiên bản (versioning) để quản lý các truy cập đồng thời đến dữ liệu.


#### SQLOS (SQL Server Operating System)

SQLOS là lớp trừu tượng phần cứng và hệ điều hành của SQL Server, cung cấp các dịch vụ cơ bản cho Database Engine. SQLOS chịu trách nhiệm quản lý tài nguyên hệ thống như bộ nhớ, CPU và I/O. Dưới đây là các thành phần chính của SQLOS:

#### Memory Management

  * Memory Allocation: Quản lý phân bổ và giải phóng bộ nhớ cho các hoạt động của SQL Server.

  * Buffer Pool: Điều khiển bộ nhớ đệm, lưu trữ các trang dữ liệu được truy cập gần đây để giảm thiểu truy cập đĩa.


#### Scheduler

  * Task Management: Quản lý các tác vụ và luồng, đảm bảo rằng các tác vụ được thực hiện hiệu quả và không có tác vụ nào bị bỏ lỡ.

  * Worker Threads: Quản lý các luồng công việc (worker threads), thực hiện các yêu cầu truy vấn và các hoạt động khác của SQL Server.


#### I/O Management

  * I/O Requests: Quản lý các yêu cầu I/O, bao gồm đọc và ghi dữ liệu từ đĩa.

  * Async I/O: Hỗ trợ I/O không đồng bộ để cải thiện hiệu suất bằng cách cho phép các yêu cầu I/O được xử lý đồng thời.


#### Synchronization

  * Lock Manager: Quản lý các khóa để điều khiển truy cập đồng thời đến dữ liệu, đảm bảo tính nhất quán và tránh xung đột.

  * Latches and Spinlocks: Sử dụng các cơ chế khóa nhẹ hơn như latches và spinlocks để bảo vệ các cấu trúc dữ liệu nội bộ của SQL Server.


#### External Protocol

External Protocol bao gồm các giao thức và công nghệ cho phép SQL Server tương tác với các hệ thống và ứng dụng bên ngoài. Các giao thức chính bao gồm:

  * TDS (Tabular Data Stream): Giao thức chính được sử dụng để trao đổi dữ liệu giữa SQL Server và các ứng dụng khách như SQL Server Management Studio (SSMS), ứng dụng web và các ứng dụng tùy chỉnh. TDS xử lý việc truyền dữ liệu truy vấn, kết quả và các thông báo giữa máy chủ và khách.

  * ODBC (Open Database Connectivity) và OLE DB: Các giao thức tiêu chuẩn cho phép các ứng dụng kết nối và tương tác với SQL Server. ODBC và OLE DB cung cấp các API để thực hiện các truy vấn, cập nhật và thao tác dữ liệu khác.

  * JDBC (Java Database Connectivity): Giao thức tiêu chuẩn cho phép các ứng dụng Java kết nối và tương tác với SQL Server. JDBC cung cấp các API để thực hiện các truy vấn và thao tác dữ liệu từ các ứng dụng Java.

  * HTTP/HTTPS: SQL Server hỗ trợ các giao thức HTTP/HTTPS để cung cấp các dịch vụ web, chẳng hạn như SQL Server Reporting Services (SSRS) và SQL Server Integration Services (SSIS). Điều này cho phép SQL Server cung cấp các dịch vụ dữ liệu qua web và tích hợp với các ứng dụng web.


## SQL Server dùng để làm gì?

SQL Server là một hệ quản trị cơ sở dữ liệu mạnh mẽ và linh hoạt do Microsoft phát triển, được sử dụng rộng rãi trong nhiều lĩnh vực khác nhau. Các chức năng chính của SQL Server bao gồm tạo và duy trì cơ sở dữ liệu, phân tích dữ liệu và tạo báo cáo. Dưới đây là các ứng dụng cụ thể của SQL Server:

### Tạo và duy trì cơ sở dữ liệu

SQL Server được sử dụng để tạo và duy trì các cơ sở dữ liệu quan hệ, cung cấp nền tảng vững chắc cho việc lưu trữ và quản lý dữ liệu. Các chức năng chính bao gồm:

  * Quản lý dữ liệu: SQL Server cho phép người dùng tạo, sửa đổi và xóa các bảng dữ liệu, chỉ mục, và các mối quan hệ giữa các bảng. Hệ thống quản lý dữ liệu của SQL Server hỗ trợ các thao tác CRUD (Create, Read, Update, Delete), giúp quản lý dữ liệu một cách hiệu quả.

  * Bảo mật dữ liệu: SQL Server cung cấp các tính năng bảo mật mạnh mẽ như mã hóa dữ liệu, kiểm soát truy cập dựa trên vai trò và xác thực người dùng. Các biện pháp bảo mật này đảm bảo rằng dữ liệu được bảo vệ khỏi các mối đe dọa và truy cập trái phép.

  * Quản lý giao dịch: SQL Server hỗ trợ các tính năng quản lý giao dịch như Atomicity, Consistency, Isolation và Durability (ACID), đảm bảo rằng các thay đổi trong cơ sở dữ liệu được thực hiện một cách nhất quán và an toàn. Điều này rất quan trọng đối với các ứng dụng yêu cầu độ tin cậy cao như tài chính, ngân hàng và thương mại điện tử.

  * Sao lưu và phục hồi: SQL Server cung cấp các tính năng sao lưu và phục hồi dữ liệu, cho phép người dùng tạo các bản sao lưu toàn bộ, gia tăng và khác biệt. Các tính năng này giúp bảo vệ dữ liệu khỏi mất mát do lỗi phần cứng, phần mềm hoặc lỗi con người và đảm bảo rằng dữ liệu có thể được phục hồi nhanh chóng trong trường hợp xảy ra sự cố.


### Phân tích dữ liệu và tạo báo cáo

SQL Server không chỉ là công cụ quản lý dữ liệu mà còn cung cấp các tính năng phân tích dữ liệu mạnh mẽ và tạo báo cáo chi tiết, giúp các tổ chức ra quyết định dựa trên dữ liệu một cách hiệu quả. Các chức năng chính bao gồm:

  * Phân tích dữ liệu: SQL Server tích hợp sẵn các công cụ phân tích dữ liệu như SQL Server Analysis Services (SSAS), cho phép người dùng xây dựng các mô hình dữ liệu phức tạp và thực hiện các phân tích sâu. Các công cụ này hỗ trợ việc tạo ra các báo cáo phân tích, biểu đồ và bảng điều khiển (dashboards) giúp người dùng hiểu rõ hơn về dữ liệu và xu hướng.

  * Tạo báo cáo: SQL Server Reporting Services (SSRS) là một công cụ mạnh mẽ cho phép người dùng tạo, quản lý và triển khai các báo cáo. SSRS hỗ trợ nhiều định dạng báo cáo khác nhau như PDF, Excel và HTML, giúp người dùng dễ dàng chia sẻ và trình bày thông tin. Các báo cáo có thể được tùy chỉnh để đáp ứng nhu cầu cụ thể của doanh nghiệp, từ báo cáo tài chính đến báo cáo hiệu suất kinh doanh.

  * Khai thác dữ liệu: SQL Server hỗ trợ các tính năng khai thác dữ liệu (data mining) giúp phát hiện các mẫu và xu hướng ẩn trong dữ liệu lớn. Các công cụ khai thác dữ liệu này giúp doanh nghiệp đưa ra các dự đoán và quyết định dựa trên dữ liệu, cải thiện hiệu suất và tăng cường khả năng cạnh tranh.

  * Tích hợp dữ liệu: SQL Server Integration Services (SSIS) là một công cụ mạnh mẽ cho phép người dùng tích hợp dữ liệu từ nhiều nguồn khác nhau vào một cơ sở dữ liệu duy nhất. SSIS hỗ trợ các hoạt động ETL (Extract, Transform, Load), giúp làm sạch, chuyển đổi và tải dữ liệu từ các hệ thống khác nhau vào SQL Server. Điều này giúp đảm bảo rằng dữ liệu luôn được cập nhật và nhất quán.


# HƯỚNG DẪN CÀI ĐẶT SQL SERVER 2022

## **_Bước 1:_** Truy cập vào đường link: [https://www.microsoft.com/en-us/sql-server/sql-server-downloads](https://www.microsoft.com/en-us/sql-server/sql-server-downloads?_ga=2.77687380.1361511729.1690361222-1340992660.1690361222)

|<image_2>|

**_Bước 2:_** Tìm đến **Express edition** of SQL Server 2022 và chọn **Download now** , chọn **Open file.**

|<image_3>|

**_Bước 3:_** Chọn **Basic** -> **Accept** -> Chọn **Browser** lưu trữ -> **Install**. 

|<image_4>|

|<image_5>|

|<image_6>|

**_Bước 4:_ **Sau khi tải về thành công, ấn **Install SSMS**. 

|<image_7>|

**_Bước 5:_** Sau khi cửa sổ **Download SSMS** hiện ra, ấn vào link **Download SSMS**.

|<image_8>|

**_Bước 6:_** Sau khi **Download thành công** , ấn **Install**. 

|<image_9>|

|<image_10>|

**_Bước 7:_** Sau khi cài đặt, mở **Microsoft SQL Server Management Studio 19** , chọn **Connect**.

|<image_11>|

|<image_12>|

  * Để mở câu query mới, nhấn vào New Query trên thanh công cụ bên trên. 

  * Để chạy câu lệnh, nhấn Ctrl + Enter hoặc nút Execute trên thanh công cụ bên trên. 

  * Để xem bộ dữ liệu, nhấn mở mục Database ở thanh điều hướng bên trái màn hình. 


Vậy là chúng ta đã hoàn tất việc cài đặt SQL Server 2022.

# Public_190

# CƠ SỞ LÝ THUYẾT

## Tổng quan về cơ sở dữ liệu Oracle

Oracle Database là một trong những hệ thống quản lý cơ sở dữ liệu quan hệ (RDBMS – Relational Database Management System) hàng đầu trên thị trường. Theo [xếp hạng của DB-Engines](https://db-engines.com/en/ranking/relational+dbms), Oracle Database đứng đầu trong số 380 hệ thống cơ sở dữ liệu phổ biến nhất, ngay sau đó là MySQL và Microsoft SQL Server. 

Oracle Database là sản phẩm độc quyền của Oracle – nhà cung cấp các sản phẩm và dịch vụ công nghệ đa dạng hàng đầu thế giới. Phiên bản Oracle Database đầu tiên được tung ra thị trường vào năm 1979. Hiện tại, phiên bản dài hạn Oracle Database 19c và phiên bản phát triển Oracle Database 21c là 2 phiên bản phổ biến, có sẵn cho người dùng cài đặt và vẫn tiếp tục được hỗ trợ bởi Oracle.

Oracle Database được sử dụng phổ biến nhờ cách tổ chức và trình bày dữ liệu một cách trực quan và hiệu quả. Ngoài ra, các công ty có thể sử dụng Oracle Database trong môi trường trên nền tảng cục bộ (on-premise) hoặc điện toán đám mây (cloud computing).

## Các tính năng của Oracle 

### **Quản lý**

Oracle Database cung cấp các công cụ mạnh mẽ để quản lý dữ liệu, bao gồm lưu trữ, chỉnh sửa, truy xuất và phân quyền. Phần mềm cũng hỗ trợ các loại dữ liệu khác nhau, bao gồm dữ liệu có cấu trúc và phi cấu trúc, đồng thời cung cấp các công cụ để quản lý lượng dữ liệu lớn.

### **Tối ưu hiệu suất**

Oracle Database bao gồm các kỹ thuật hỗ trợ gia tăng hiệu suất và xử lý dữ liệu nhanh chóng như: Thuật toán tối ưu truy vấn, tạo chỉ mục, phân vùng bảng và xử lý song song.

### **Khả năng mở rộng**

Oracle Database có thể xử lý các khối lượng dữ liệu lớn và mở rộng khi nhu cầu sử dụng của người dùng phát triển. Phần mềm hỗ trợ mở rộng theo chiều ngang (thêm máy tính vào mạng) và theo chiều dọc (thêm công suất vào máy tính hiện có).

### **Bảo mật**

Oracle Database cung cấp các tính năng bảo mật mạnh mẽ để bảo vệ dữ liệu của người dùng khỏi bị truy cập trái phép và các mối đe dọa số khác. Các tính năng này bao gồm mã hóa dữ liệu, xác thực người dùng, kiểm soát truy cập và dễ dàng truy nguồn.

### **Duy trì hoạt động ổn định**

Oracle Database cung cấp các tính năng để đảm bảo rằng cơ sở dữ liệu luôn có thể truy cập và vận hành ổn định bao gồm: sao lưu trên nhiều máy và phục hồi dữ liệu khi cần, khả năng chuyển đổi hệ thống khi gặp sự cố.

### **Tích hợp**

Oracle Database có thể tích hợp với các sản phẩm Oracle khác và các ứng dụng của bên thứ ba, cung cấp một giải pháp quản lý dữ liệu toàn diện mạnh mẽ và thống nhất.

## Các phiên bản khác của Oracle

  1. Oracle Database Standard Edition: Phiên bản này cung cấp các tính năng cơ bản để quản lý dữ liệu dành cho doanh nghiệp SMEs vừa và nhỏ. Oracle Database Standard Edition sở hữu các tính năng quản lý dữ liệu, cùng tính sẵn có và khả năng bảo mật cao.

  2. Oracle Database Enterprise Edition: Phiên bản này cung cấp các tính năng tiên tiến để quản lý dữ liệu trong các doanh nghiệp lớn. Oracle Database Enterprise Edition bao gồm tất cả các tính năng của phiên bản Standard Edition, cộng thêm các tính năng bổ sung dành cho việc tối ưu hóa hiệu suất, cùng khả năng mở rộng, quản lý dữ liệu (data warehousing) và phân tích.

  3. Oracle Database Express Edition (XE): Đây là một phiên bản miễn phí của Oracle Database dành cho mục đích học và luyện tập phát triển phần mềm. Oracle Database Express Edition có những hạn chế về chức năng và dung lượng lưu trữ.

  4. Oracle Database Personal Edition: Phiên bản này được thiết kế cho môi trường sử dụng đơn người dùng. Oracle Database Personal Edition bao gồm tất cả các tính năng của phiên bản Enterprise Edition nhưng được cấp phép cho duy nhất 1 người sử dụng.


## Những điểm nổi bật của hệ điều hành Ubuntu

Ưu điểm và hạn chế của Oracle Database phụ thuộc chủ yếu vào nhu cầu sử dụng của người dùng cũng như chi phí, năng lực kỹ thuật và kỹ năng lập trình. 

**Ưu điểm của Oracle Database**

  1. Tính tương thích cao với tất cả các nền tảng và ứng dụng

  2. Oracle Database là mô hình Database-as-a-Service tùy chọn, cho phép các cơ sở dữ liệu quan hệ được lưu trữ và quản lý trong Oracle Cloud, giúp đảm bảo sử dụng tối ưu CPU, phần cứng và dung lượng lưu trữ, cũng như việc outsourcing các nhiệm vụ quản lý cơ sở dữ liệu quản trị.

  3. Được hỗ trợ bởi tất cả các nhà cung cấp phần mềm và phần cứng lớn trên thế giới

  4. Cung cấp các phiên bản khác nhau đa dạng, từ miễn phí cho nhu cầu cá nhân đến trả phí cho nhu cầu doanh nghiệp

  5. Cộng đồng Oracle khá lớn và sẵn sàng hỗ trợ lẫn nhau

  6. Cung cấp các tính năng bảo mật và quyền riêng tư mạnh mẽ (Ví dụ: tính năng xác thực và phê duyệt quyền truy cập, tính năng mã hóa dữ liệu và mạng,…)


**Hạn chế của Oracle Database**

  1. Kiến thức SQL và kinh nghiệm quản lý cơ sở dữ liệu là điều kiện tiên quyết để lập trình viên có thể sử dụng phiên bản trên máy chủ cục bộ của Oracle

  2. Giấy phép Oracle có chi phí khá đắt đỏ (phiên bản Standard Edition yêu cầu chi phí khoảng 17.000 USD, phiên bản Enterprise Edition yêu cầu chi phí khoảng 40.000 USD)

  3. Oracle Database có yêu cầu về tiêu chuẩn phần cứng cao cho phiên bản trên máy chủ cục bộ vận hành tại chỗ (on-premise)


## Các công cụ cơ bản của Oracle Database

### **SQL*Plus**

Phần mềm editor dành cho việc quản lý cơ sở dữ liệu, cho phép nhập lệnh, truy vấn dữ liệu và thực hiện thay đổi hoặc xóa các tập tin trong cơ sở dữ liệu. 

### **Oracle SQL Developer**

Phần mềm Java miễn phí có giao diện đồ họa giúp tạo hoặc chỉnh sửa code, quản lý SQL scripts, phân tích dữ liệu, tạo hoặc sửa lỗi các procedure (Procedure – thủ tục trong SQL là một tập hợp các câu lệnh SQL được gán tên và lưu trữ trong hệ thống quản lý cơ sở dữ liệu quan hệ, giúp giảm thời gian thực thi bằng cách cho phép gọi lại lệnh nhiều lần, đồng thời không bị ràng buộc với bất kì ứng dụng cụ thể nào).

### **Oracle Data Modeler**

Phần mềm miễn phí để thiết kế cơ sở dữ liệu, bao gồm các công cụ thiết kế các mô hình quan hệ, tạo các khóa ngoại và khoá chính. Phần mềm giúp trực quan hoá các quan hệ phức tạp trong bộ dữ liệu, tương tác bằng kéo và thả dễ dàng, tương thích với Oracle SQL Developer để xuất dữ liệu.

### **Oracle Enterprise Manager Database Control**

Phần mềm quản lý cơ sở dữ liệu trên web cung cấp giao diện người dùng.

### **Oracle Enterprise Manager Grid Control**

Phần mềm quản lý môi trường và hệ thống trên web, với giao diện người dùng có thể được sử dụng để quản lý nhiều cơ sở dữ liệu, các cụm máy chủ, cũng như các hệ thống dự phòng.

### **Oracle JDeveloper**

Phần mềm phát triển sản phẩm tích hợp Oracle và Java giúp phát triển các ứng dụng cơ sở dữ liệu.

Vậy Oracle SQL là gì?

Oracle SQL là một hệ thống quản lý cơ sở dữ liệu cho phép người dùng lưu trữ và quản lý dữ liệu theo khối lượng lớn

Người dùng tương tác với cơ sở dữ liệu Oracle thông qua các lệnh Ngôn ngữ truy vấn có cấu trúc (SQL) để tạo, sửa đổi và xóa bảng, cũng như truy xuất dữ liệu. Oracle SQL cung cấp một bộ công cụ toàn diện để quản lý cơ sở dữ liệu, bao gồm các tính năng giúp quản lý người dùng, gán quyền hạn và tạo sao lưu của cơ sở dữ liệu.

Hệ thống cũng bao gồm các tính năng tiên tiến như phân vùng, nhóm và nén để tối ưu hóa lưu trữ và truy xuất dữ liệu, cũng như các công cụ để tạo báo cáo, biểu đồ và đồ thị tùy chỉnh.

## Các thành phần chính của Oracle SQL

Những yếu tố cơ bản trong Oracle SQL là những khối hộp cấu thành nên nền tảng của các câu lệnh SQL. Do đó, trước khi sử dụng các câu lệnh SQL trong cơ sở dữ liệu Oracle, lập trình viên nên làm quen với các khái niệm sau đây:

  1. Kiểu dữ liệu (Data Types): Định nghĩa loại dữ liệu của mỗi cột trong bảng, bao gồm số nguyên, số thực, ký tự, ngày tháng, và các loại dữ liệu đặc biệt khác.

  2. Quy tắc so sánh kiểu dữ liệu (Data Type Comparison Rules): Quy định cách so sánh các kiểu dữ liệu khác nhau trong câu lệnh SQL.

  3. Hằng số (Literals): Các giá trị cố định được sử dụng trong các câu lệnh SQL, như chuỗi ký tự, số nguyên, số thực, ngày tháng,…

  4. Mô hình định dạng (Format Models): Xác định cách hiển thị dữ liệu khi truy vấn từ cơ sở dữ liệu, ví dụ như định dạng ngày tháng hoặc số tiền.

  5. Giá trị rỗng (Nulls): Đại diện cho giá trị không tồn tại hoặc không xác định trong cơ sở dữ liệu.

  6. Chú thích (Comments): Ghi chú để giải thích ý nghĩa của các phần trong câu lệnh SQL.

  7. Đối tượng cơ sở dữ liệu (Database Objects): Bao gồm các thành phần như bảng, chỉ mục, khóa ngoại, thủ tục lưu trữ, hàm, trigger,…

  8. Tên đối tượng cơ sở dữ liệu và bộ lọc (Database Object Names and Qualifiers): Cách định danh và phân loại các đối tượng trong cơ sở dữ liệu, bao gồm cả tên bảng, tên cột, tên hàm,…

  9. Cú pháp cho các đối tượng schema và các phần trong câu lệnh SQL: Quy định cách sử dụng cú pháp để tham chiếu và thao tác trên các đối tượng trong cơ sở dữ liệu, đồng thời phân biệt rõ ràng giữa các phần của câu lệnh SQL.


# 11 CÂU LỆNH ORACLE SQL THÔNG DỤNG

Cú pháp cơ bản của một câu lệnh Oracle SQL bao gồm các từ khóa, các định danh, các hằng số và các toán tử.

  * Từ khóa là các từ được xác định trước có ý nghĩa đặc biệt trong Oracle SQL, như SELECT, INSERT, hoặc UPDATE.

  * Định danh là các tên do người dùng tự xác định cho các đối tượng cơ sở dữ liệu như bảng và cột.

  * Hằng số đại diện cho các giá trị hằng số.

  * Toán tử là các ký hiệu được sử dụng để thực hiện các phép toán trên dữ liệu.

  * 3 phân loại và 11 lệnh Oracle SQL thông dụng mà lập trình viên có thể áp dụng ngay bao gồm:


## Data Definition Language (DDL) – Ngôn ngữ định nghĩa dữ liệu

### Lệnh Create table (DDL)

Câu lệnh CREATE TABLE được sử dụng để tạo một bảng mới trong cơ sở dữ liệu. Cú pháp để tạo bảng như sau:

|<image_1>|

Đây là ví dụ về cách tạo một bảng nhân viên đơn giản:

|<image_2>|

### Lệnh Alter table (DDL)

Câu lệnh ALTER TABLE được sử dụng để sửa đổi một bảng hiện có, chẳng hạn như thêm, sửa hoặc xóa các cột. Cú pháp để thay đổi bảng như sau:

|<image_3>|

Ví dụ: để thêm một cột mới có tên là ‘bộ phận’ vào bảng nhân viên:

|<image_4>|

### Lệnh Drop Table (DDL)

Câu lệnh DROP TABLE được sử dụng để xóa một bảng hiện có và tất cả dữ liệu của bảng đó. Cú pháp xóa bảng như sau:

|<image_5>|

Ví dụ: để xóa bảng nhân viên:

|<image_6>|

## Data Manipultation Language (DML) – Ngôn ngữ thao tác dữ liệu

### Lênh Insert into (DML)

Câu lệnh INSERT INTO được sử dụng để chèn thêm các hàng trong một bảng. Cú pháp chèn dữ liệu như sau:

|<image_7>|

Ví dụ, để chèn một thông tin nhân viên mới vào bảng nhân viên:

|<image_8>|

### Lệnh Update (DML)

Câu lệnh UPDATE được sử dụng để cập nhật các hàng hiện có trong bảng. Câu lệnh để cập nhật dữ liệu như sau:

|<image_9>|

Ví dụ: để cập nhật mức lương của nhân viên có id bằng 1:

|<image_10>|

### Lệnh Delete (DML)

Câu lệnh DELETE được sử dụng để xóa các hàng khỏi bảng. Cú pháp xóa dữ liệu như sau:

|<image_11>|

Ví dụ: để xóa thông tin một nhân viên có id bằng 1:

|<image_12>|

## Data Query Language (DQL) – Ngôn ngữ truy vấn dữ liệu

### Lệnh Select

Câu lệnh SELECT được sử dụng để lấy dữ liệu từ một hoặc nhiều bảng. Cú pháp cơ bản để chọn dữ liệu như sau:

|<image_13>|

### Mệnh đề Select Distinct (DQL)

Để truy xuất các giá trị duy nhất từ một cột cụ thể, hãy sử dụng mệnh đề SELECT DISTINCT:

|<image_14>|

### Mệnh đề WHERE và AND/OR

Mệnh đề WHERE được sử dụng để lọc dữ liệu được trả về bởi câu lệnh SELECT. Bạn có thể kết hợp nhiều điều kiện bằng toán tử AND và OR:

|<image_15>|

### Mệnh đề Group BY và HAVING

Mệnh đề GROUP BY được sử dụng để nhóm các hàng có cùng giá trị trong các cột được chỉ định. Mệnh đề HAVING được sử dụng để lọc kết quả của GROUP BY:

|<image_16>|

# Public_191

# CƠ SỞ LÝ THUYẾT

## Hệ điều hành Ubuntu

### Tổng quan về hệ điều hành Ubuntu

Ubuntu là một hệ điều hành máy tính mã nguồn mở dựa trên nền tảng [Linux](https://topdev.vn/blog/linux-la-gi/). Được phát triển và duy trì bởi Canonical Ltd. và cộng đồng người dùng toàn cầu, Ubuntu được thiết kế để cung cấp một trải nghiệm máy tính dễ sử dụng, ổn định và an toàn cho mọi người, từ người dùng cá nhân đến doanh nghiệp và tổ chức.

Ubuntu đi kèm với các tính năng như giao diện người dùng đồ họa (GUI) thân thiện, hỗ trợ cho nhiều loại phần cứng và phần mềm, cũng như khả năng tùy chỉnh linh hoạt để phù hợp với nhu cầu cụ thể của người dùng. Đặc biệt, Ubuntu được cung cấp hoàn toàn miễn phí và đồng thời được hỗ trợ bởi một cộng đồng lớn các nhà phát triển và người dùng trên toàn thế giới.

### Các phiên bản khác của Ubuntu

  * **Ubuntu LTS (Long Term Support)** là phiên bản Ubuntu được hỗ trợ dài hạn. Cụ thể, các phiên bản LTS của Ubuntu nhận được bảo trì và cập nhật bảo mật trong khoảng thời gian kéo dài hàng năm (ví dụ: 5 năm cho phiên bản LTS phổ biến nhất). Điều này làm cho Ubuntu LTS trở thành lựa chọn ổn định và lâu dài cho các doanh nghiệp và người dùng muốn tránh việc nâng cấp thường xuyên.

  * **Ubuntu Server** là một phiên bản Ubuntu được tối ưu hóa để sử dụng làm hệ điều hành cho các máy chủ. Nó cung cấp các tính năng và công cụ cần thiết để triển khai, quản lý và vận hành các dịch vụ và ứng dụng máy chủ, bao gồm các dịch vụ như web server, email server, database server và nhiều hơn nữa.

  * **Ubuntu MATE** là một biến thể của Ubuntu được thiết kế với một giao diện người dùng truyền thống và dễ sử dụng. Giao diện của Ubuntu MATE nhắm đến sự đơn giản và sự dễ dàng sử dụng cho người dùng, đồng thời vẫn cung cấp đầy đủ các tính năng và công cụ của hệ điều hành Ubuntu.

  * **Ubuntu Kylin** là một phiên bản Ubuntu được tối ưu hóa cho người dùng ở Trung Quốc. Nó được phát triển bởi một tổ chức Trung Quốc với mục tiêu làm cho Ubuntu trở nên thân thiện và dễ sử dụng hơn đối với người dùng Trung Quốc thông qua việc cung cấp các tính năng và ứng dụng phù hợp với nhu cầu và thói quen của địa phương.


### Những điểm nổi bật của hệ điều hành Ubuntu

|<image_1>|

Hệ điều hành Ubuntu có nhiều điểm nổi bật mà người dùng thường đánh giá cao:

  * **Miễn phí và mã nguồn mở:** Ubuntu là hệ điều hành hoàn toàn miễn phí. Bạn có thể tải xuống, cài đặt và sử dụng mà không phải trả bất kỳ khoản phí nào.

  * **Dễ sử dụng:** Giao diện đồ họa trực quan, các ứng dụng được cài đặt sẵn và cộng đồng hỗ trợ nhiệt tình giúp cho việc sử dụng Ubuntu trở nên dễ dàng hơn bao giờ hết.

  * **Ổn định và bảo mật:** Ubuntu được coi là một trong những phiên bản Linux ổn định nhất, với việc cập nhật bảo mật thường xuyên để bảo vệ người dùng khỏi các lỗ hổng tiềm ẩn.

  * **Tính tùy chỉnh:** Ubuntu có thể tùy chỉnh cao. Người dùng có thể thay đổi giao diện, cài đặt thêm phần mềm và cấu hình hệ điều hành theo nhu cầu của mình.

  * **Kho phần mềm phong phú:** Bạn có thể tìm thấy hầu hết các ứng dụng phổ biến cho Ubuntu, bao gồm trình duyệt web, trình soạn thảo văn bản, bảng tính, trình phát đa phương tiện và nhiều loại ứng dụng khác.

  * **Đa dạng phiên bản:** Ubuntu cung cấp nhiều biến thể như Ubuntu Desktop, Ubuntu Server, Ubuntu MATE, Ubuntu Kylin, v.v., phù hợp với nhu cầu sử dụng khác nhau của người dùng.

  * **Cộng đồng lớn mạnh:** Ubuntu có một cộng đồng người dùng và nhà phát triển rộng lớn trên toàn thế giới, với sự hỗ trợ, chia sẻ kiến thức và giải đáp thắc mắc qua các diễn đàn, blog và trang web.


### So sánh hệ điều hành Ubuntu với Windows

Dưới đây là một bảng so sánh giữa Ubuntu và Windows dựa trên một số tiêu chí phổ biến:

|<image_2>|

## Quy trình cài đặt Driver Nvidia sử dụng Repository chuẩn của Ubuntu

Phương pháp đầu tiên là dễ thực hiện nhất và trong hầu hết các trường hợp, đây là cách được khuyến nghị.

### Phương pháp cài đặt qua dòng lệnh

**_Bước 1:_** Đầu tiên, hãy xác định model card đồ họa Nvidia của bạn và driver được khuyến nghị. Để thực hiện, hãy chạy lệnh sau. Lưu ý rằng kết quả đầu ra và driver được khuyến nghị có thể khác nhau:|<image_3>|

Từ kết quả trên, chúng ta có thể kết luận rằng hệ thống hiện tại đã cài đặt card đồ họa **NVIDIA GeForce RTX 3080** và driver được khuyến nghị để cài đặt là **nvidia-driver-470**.

**_Bước 2:_** Cài đặt driver  
Nếu bạn đồng ý với đề xuất, hãy sử dụng lệnh ubuntu-drivers một lần nữa để tự động cài đặt tất cả các driver được khuyến nghị:

|<image_4>|

Ngoài ra, bạn có thể cài đặt driver mong muốn một cách chọn lọc sử dụng lệnh apt. Ví dụ:
|<image_5>|
**_Bước 3:_** Sau khi cài đặt hoàn tất, hãy khởi động lại hệ thống của bạn:
|<image_6>|

### Phương pháp cài đặt tự động reposity PPA để cài đặt driver Nvidia Beta

**_Bước 1:_** Việc sử dụng repository PPA graphics-drivers cho phép chúng ta cài đặt các driver Nvidia beta tiên tiến nhất, mặc dù có thể đi kèm với rủi ro hệ thống không ổn định. Để tiến hành, trước tiên hãy thêm repository ppa:graphics-drivers/ppa vào hệ thống của bạn:

|<image_7>|

**_Bước 2:_** Tiếp theo, hãy xác định model card đồ họa của bạn và driver được khuyến nghị:

|<image_8>|

**_Bước 3:_** Cài đặt Driver Nvidia:  
Tương tự như ví dụ với repository chuẩn của Ubuntu ở trên, bạn có thể tự động cài đặt tất cả các driver được khuyến nghị:

|<image_9>|

Hoặc, cài đặt một cách chọn lọc sử dụng lệnh apt. Ví dụ:

|<image_10>|

**_Bước 4:_** Sau khi cài đặt xong, khởi động lại máy tính của bạn:

|<image_11>|

### Phương pháp cài đặt thủ công sử dụng driver chính thức từ Nvidia.com theo hướng dẫn các bước 

**_Bước 1:_** Xác định card VGA của NVIDIA

Các lệnh dưới đây sẽ giúp bạn xác định model card Nvidia:

|<image_12>|

hoặc

|<image_13>|

hoặc

|<image_14>|

**_Bước 2:_** Tải Driver chính thức của Nvidia

Sử dụng trình duyệt web của bạn, hãy truy cập trang web chính thức của Nvidia và tải xuống driver phù hợp cho card đồ họa Nvidia của bạn. Ngoài ra, nếu bạn đã nắm rõ quy trình, bạn có thể tải driver trực tiếp từ danh sách driver Nvidia Linux. Khi hoàn tất, bạn sẽ có một file tương tự như file được hiển thị dưới đây:

|<image_15>|

**_Bước 3:_** Cài đặt các gói cần thiết

Các gói phụ thuộc sau đây cần được cài đặt để biên dịch và cài đặt driver Nvidia:

|<image_16>|

### Vô hiệu hóa driver Nouveau của Nvidia 

**_Bước 1:_** Bước tiếp theo là vô hiệu hóa driver Nouveau mặc định. Hãy làm theo hướng dẫn để vô hiệu hóa driver Nouveau mặc định.

|<image_17>|

Hãy chắc chắn rằng bạn đã khởi động lại hệ thống trước khi tiến hành bước tiếp theo.

**_Bước 2:_** Dừng Trình Quản Lý Desktop

Để cài đặt driver Nvidia mới, chúng ta cần dừng server hiển thị hiện tại. Cách đơn giản nhất là chuyển sang runlevel 3 sử dụng lệnh telinit. Sau khi thực thi lệnh dưới đây, server hiển thị sẽ dừng lại, vì vậy hãy chắc chắn lưu lại tất cả công việc hiện tại (nếu có) trước khi tiến hành:

|<image_18>|

Nhấn **CTRL+ALT+F1** và đăng nhập với tên người dùng cùng mật khẩu của bạn để mở phiên TTY1 mới hoặc đăng nhập qua SSH.

**_Bước 3:_** Cài đặt Driver Nvidia

Để bắt đầu cài đặt driver Nvidia, thực hiện lệnh dưới đây và làm theo hướng dẫn:

|<image_19>|

**_Bước 4:_** Driver Nvidia đã được cài đặt. Khởi động lại hệ thống của bạn:

|<image_20>|

**_Bước 5:_** Cấu hình cài đặt NVIDIA X Server. Sau khi khởi động lại, bạn sẽ có thể mở ứng dụng **NVIDIA X Server Settings** từ menu **Activities**.

Sau khi cài driver NVIDIA, bạn có thể nâng cấp trải nghiệm với một [**VPS server**](https://dataonline.vn/cloud-vps-gia-re/) mạnh mẽ

# Public_192

# CƠ SỞ LÝ THUYẾT

## Tổng quan Kubernetes

Kubernetes là một nền tảng nguồn mở, khả chuyển, có thể mở rộng để quản lý các ứng dụng được đóng gói và các service, giúp thuận lợi trong việc cấu hình và tự động hoá việc triển khai ứng dụng. Kubernetes là một hệ sinh thái lớn và phát triển nhanh chóng. Các dịch vụ, sự hỗ trợ và công cụ có sẵn rộng rãi.

Tên gọi Kubernetes có nguồn gốc từ tiếng Hy Lạp, có ý nghĩa là người lái tàu hoặc hoa tiêu. Google mở mã nguồn Kubernetes từ năm 2014. Kubernetes xây dựng dựa trên [một thập kỷ rưỡi kinh nghiệm mà Google có được với việc vận hành một khối lượng lớn workload trong thực tế](https://research.google/pubs/pub43438), kết hợp với các ý tưởng và thực tiễn tốt nhất từ cộng đồng.

## Lý do ra đời của Kubernetes

Chúng ta hãy xem tại sao Kubernetes rất hữu ích bằng cách quay ngược thời gian.

|<image_1>|

**Thời đại triển khai theo cách truyền thống:** Ban đầu, các ứng dụng được chạy trên các máy chủ vật lý. Không có cách nào để xác định ranh giới tài nguyên cho các ứng dụng trong máy chủ vật lý và điều này gây ra sự cố phân bổ tài nguyên. Ví dụ, nếu nhiều ứng dụng cùng chạy trên một máy chủ vật lý, có thể có những trường hợp một ứng dụng sẽ chiếm phần lớn tài nguyên hơn và kết quả là các ứng dụng khác sẽ hoạt động kém đi. Một giải pháp cho điều này sẽ là chạy từng ứng dụng trên một máy chủ vật lý khác nhau. Nhưng giải pháp này không tối ưu vì tài nguyên không được sử dụng đúng mức và rất tốn kém cho các tổ chức để có thể duy trì nhiều máy chủ vật lý như vậy.

**Thời đại triển khai ảo hóa:** Như một giải pháp, ảo hóa đã được giới thiệu. Nó cho phép bạn chạy nhiều Máy ảo (VM) trên CPU của một máy chủ vật lý. Ảo hóa cho phép các ứng dụng được cô lập giữa các VM và cung cấp mức độ bảo mật vì thông tin của một ứng dụng không thể được truy cập tự do bởi một ứng dụng khác.

Ảo hóa cho phép sử dụng tốt hơn các tài nguyên trong một máy chủ vật lý và cho phép khả năng mở rộng tốt hơn vì một ứng dụng có thể được thêm hoặc cập nhật dễ dàng, giảm chi phí phần cứng và hơn thế nữa. Với ảo hóa, bạn có thể có một tập hợp các tài nguyên vật lý dưới dạng một cụm các máy ảo sẵn dùng.

Mỗi VM là một máy tính chạy tất cả các thành phần, bao gồm cả hệ điều hành riêng của nó, bên trên phần cứng được ảo hóa.

**Thời đại triển khai Container:** Các container tương tự như VM, nhưng chúng có tính cô lập để chia sẻ Hệ điều hành (HĐH) giữa các ứng dụng. Do đó, container được coi là nhẹ (lightweight). Tương tự như VM, một container có hệ thống tệp (filesystem), CPU, bộ nhớ, process space, v.v. Khi chúng được tách rời khỏi cơ sở hạ tầng bên dưới, chúng có thể khả chuyển (portable) trên cloud hoặc các bản phân phối Hệ điều hành.

Các container đã trở nên phổ biến vì chúng có thêm nhiều lợi ích, chẳng hạn như:

  * Tạo mới và triển khai ứng dụng Agile: gia tăng tính dễ dàng và hiệu quả của việc tạo các container image so với việc sử dụng VM image.

  * Phát triển, tích hợp và triển khai liên tục: cung cấp khả năng build và triển khai container image thường xuyên và đáng tin cậy với việc rollbacks dễ dàng, nhanh chóng.

  * Phân biệt giữa Dev và Ops: tạo các images của các application container tại thời điểm build/release thay vì thời gian triển khai, do đó phân tách các ứng dụng khỏi hạ tầng.

  * Khả năng quan sát không chỉ hiển thị thông tin và các metric ở mức Hệ điều hành, mà còn cả application health và các tín hiệu khác.

  * Tính nhất quán về môi trường trong suốt quá trình phát triển, testing và trong production: Chạy tương tự trên laptop như trên cloud.

  * Tính khả chuyển trên cloud và các bản phân phối HĐH: Chạy trên Ubuntu, RHEL, CoreOS, on-premises, Google Kubernetes Engine và bất kì nơi nào khác.

  * Quản lý tập trung ứng dụng: Tăng mức độ trừu tượng từ việc chạy một Hệ điều hành trên phần cứng ảo hóa sang chạy một ứng dụng trên một HĐH bằng logical resources.

  * Các micro-services phân tán, elastic: ứng dụng được phân tách thành các phần nhỏ hơn, độc lập và thể được triển khai và quản lý một cách linh hoạt - chứ không phải một app nguyên khối (monolithic).

  * Cô lập các tài nguyên: dự đoán hiệu năng ứng dụng

  * Sử dụng tài nguyên: hiệu quả


## Tại sao lại cần đến Kubernetes

Các container là một cách tốt để đóng gói và chạy các ứng dụng của bạn. Trong môi trường production, bạn cần quản lý các container chạy các ứng dụng và đảm bảo rằng không có khoảng thời gian downtime. Ví dụ, nếu một container bị tắt đi, một container khác cần phải khởi động lên. Điều này sẽ dễ dàng hơn nếu được xử lý bởi một hệ thống.

Đó là cách Kubernetes đến với chúng ta. Kubernetes cung cấp cho bạn một framework để chạy các hệ phân tán một cách mạnh mẽ. Nó đảm nhiệm việc nhân rộng và chuyển đổi dự phòng cho ứng dụng của bạn, cung cấp các mẫu deployment và hơn thế nữa. Ví dụ, Kubernetes có thể dễ dàng quản lý một triển khai canary cho hệ thống của bạn.

Kubernetes cung cấp cho bạn:

  * **Service discovery và cân bằng tải**  
Kubernetes có thể expose một container sử dụng DNS hoặc địa chỉ IP của riêng nó. Nếu lượng traffic truy cập đến một container cao, Kubernetes có thể cân bằng tải và phân phối lưu lượng mạng (network traffic) để việc triển khai được ổn định.

  * **Điều phối bộ nhớ**  
Kubernetes cho phép bạn tự động mount một hệ thống lưu trữ mà bạn chọn, như local storages, public cloud providers, v.v.

  * **Tự động rollouts và rollbacks**  
Bạn có thể mô tả trạng thái mong muốn cho các container được triển khai dùng Kubernetes và nó có thể thay đổi trạng thái thực tế sang trạng thái mong muốn với tần suất được kiểm soát. Ví dụ, bạn có thể tự động hoá Kubernetes để tạo mới các container cho việc triển khai của bạn, xoá các container hiện có và áp dụng tất cả các resource của chúng vào container mới.

  * **Đóng gói tự động**  
Bạn cung cấp cho Kubernetes một cluster gồm các node mà nó có thể sử dụng để chạy các tác vụ được đóng gói (containerized task). Bạn cho Kubernetes biết mỗi container cần bao nhiêu CPU và bộ nhớ (RAM). Kubernetes có thể điều phối các container đến các node để tận dụng tốt nhất các resource của bạn.

  * **Tự phục hồi**  
Kubernetes khởi động lại các containers bị lỗi, thay thế các container, xoá các container không phản hồi lại cấu hình health check do người dùng xác định và không cho các client biết đến chúng cho đến khi chúng sẵn sàng hoạt động.

  * **Quản lý cấu hình và bảo mật**  
Kubernetes cho phép bạn lưu trữ và quản lý các thông tin nhạy cảm như: password, OAuth token và SSH key. Bạn có thể triển khai và cập nhật lại secret và cấu hình ứng dụng mà không cần build lại các container image và không để lộ secret trong cấu hình stack của bạn


# CÀI ĐẶT CÔNG CỤ KUBECTL TRÊN WINDOWS

Trước khi bắt đầu:

Bạn phải sử dụng phiên bản Kubectl có sự khác biệt ít so với cụm của bạn. Ví dụ: máy khách v1.34 có thể giao tiếp với các control planes v1.33, v1.34 và v1.35. Sử dụng phiên bản Kubectl tương thích mới nhất sẽ giúp tránh các sự cố không lường trước được.

### Cài đặt Kubectl binary trên Windows (thông qua tải xuống trực tiếp hoặc curl)

Bạn có hai tùy chọn để cài đặt kubectl trên thiết bị Windows của mình.

#### Tải xuống trực tiếp:

Tải xuống bản phát hành bản vá 1.34 mới nhất trực tiếp cho kiến ​​trúc cụ thể của bạn bằng cách truy cập trang phát hành Kubernetes. Hãy đảm bảo chọn đúng bản nhị phân cho kiến ​​trúc của bạn (ví dụ: amd64, arm64, v.v.).

#### Sử dụng curl:

Nếu bạn đã cài đặt curl, hãy sử dụng lệnh này:

curl.exe -LO <https://dl.k8s.io/release/v1.34.0/bin/windows/amd64/kubectl.exe>

### Xác thực tệp nhị phân (tùy chọn)

Tải xuống tệp tổng kiểm tra kubectl:

curl.exe -LO <https://dl.k8s.io/v1.34.0/bin/windows/amd64/kubectl.exe.sha256>

Xác thực tệp nhị phân kubectl với tệp tổng kiểm tra:

Sử dụng Dấu nhắc Lệnh để so sánh thủ công đầu ra của CertUtil với tệp tổng kiểm tra đã tải xuống:

|<image_2>|

Sử dụng PowerShell để tự động xác minh bằng toán tử -eq để có kết quả Đúng hoặc Sai:

$(Get-FileHash -Algorithm SHA256 .\kubectl.exe).Hash -eq $(Get-Content .\kubectl.exe.sha256)

### Thêm hoặc thêm thư mục nhị phân kubectl vào biến môi trường PATH của bạn

### Kiểm tra để đảm bảo phiên bản kubectl giống với phiên bản đã tải xuống

|<image_3>|

Hoặc sử dụng lệnh này để xem chi tiết phiên bản:

|<image_4>|

# Public_193

# TỔNG QUAN VỀ VỊ TRÍ DEVOPS

## Devops là gì?

**DevOps** là một sự kết hợp của các nguyên lý, thực hành, quy trình và các tool giúp tự động hóa quá trình lập trình và chuyển giao phần mềm. Với DevOps, các công ty có thể “release” các tính năng nhỏ rất nhanh và kết hợp các phản hồi mà họ nhận được một cách nhanh chóng. DevOps là kết hợp của các cụm từ tiếng Anh software development và information technology operations.

  * Giai đoạn phát triển (development) bao gồm phần việc của UI designer, developer, [QA/QC](https://topdev.vn/blog/qa-la-gi-qc-la-gi/)…

  * Giai đoạn vận hành (operations) có sự tham gia của system engineer, system administrator, operation executive, release engineer, DBA, network engineer,…


Hai giai đoạn này tương đối tách rời nhau. Đặc biệt là ở những công ty có quy mô từ trung bình trở lên. Chính vì thế, khái niêm **devops** ra đời nhằm tối ưu hóa chu trình phát triển phần mềm. Giúp sản phẩm phần mềm được release nhanh và thường xuyên hơn.

|<image_1>|

## Devops Engineer là vị trí gì?

Các công việc chính của **DevOps Engineer** gần giống với công việc của Sysadmin, bao gồm: deploy, optimizing, monitoring, analysis… Điểm khác biệt là:

  * DevOps Engineer đòi hỏi nhiều kĩ năng mềm hơn như phải có coding skill, scripting để automation hệ thống.

  * DevOps Engineer cần tìm hiểu về tech stack mà sản phẩm công ty đang sử dụng. Ngoài ra họ cũng có thể cùng review bug hay viết những unit test thông thường.


**DevOps Engineer** nay thường phải tham gia ngay vào giai đoạn phát triển nhằm:

  * Chuẩn hóa môi trường làm việc từ local cho đến production.

  * Hiểu sản phẩm hơn, để tối ưu hóa sản phẩm tốt hơn.

  * Nắm được cơ bản logic code, nắm được tiến trình của code chạy như thế nào.v.v…


## Công việc của Devops Engineer

DevOps là một thành phần cực kỳ quan trọng trong [quy trình phát triển phần mềm](https://topdev.vn/blog/quy-trinh-phat-trien-phan-mem/) cùng với phương pháp [Agile](https://topdev.vn/blog/agile-la-gi-scrum-la-gi/). Nó giúp hoàn thiện việc chuyển đổi quy trình phát triển và vận hành phần mềm từ mô hình thác nước (waterfall) sang mô hình phát triển/phát hành liên tục (CI/CD).

Tất cả đều phục vụ cho mục đích cuối cùng là cải thiện khả năng triển khai phần mềm một cách nhanh chóng. Từ đó, tăng khả năng cạnh tranh của sản phẩm/doanh nghiệp.

Một khi đã hiểu được những giá trị thực sự của DevOps và thực hiện những thay đổi nhỏ, vững vàng thì team bạn có thể bắt đầu cuộc hành trình với DevOps được rồi:

  * CI (Continuous Integration): Một hình thức trong việc phát triển phần mềm, các developer thường gộp hoặc chuyển các thay đổi trong code về một repo master, và các build và test sau đó sẽ tự động chạy. Mục tiêu của CI đó là tìm bug nhanh hơn từ sớm, cải thiện chất lượng phần mềm, và giản thiểu thời gian để xác thực và ra mắt các update mới.

  * CD (Continuous Deployment) : Mọi thay đổi được duyệt qua test sẽ tự động được triển khai trên production. Nghĩa là bạn pull bản build mới nhất ngay hoặc tìm repo mới nhất đã được test và tiến hành deploy trên production. CD là một cách tuyệt vời để tăng tốc quá trình deploy sản phẩm liên tục để đáp ứng các yêu cầu liên tục của khách hàng.

  * Xây dựng kiến trúc (Infrastructure as code) hệ thống như là code: Định nghĩa này hơi khó hiểu, có thể hiểu như là một phương pháp để đảm bảo rằng bạn có thể maintain chất lượng version control trong khi sử dụng CI. Infrastructure cần được cấu hình tự động hoàn toàn để các server được chuẩn hóa các bản patch và version mới nhất.

  * Communication và Collaboration: Collaboration và communication là các nhân tố bí ẩn giúp doanh nghiệp phát triển và đánh giá DevOps. Nó đẩy nhanh quá trình phát triển, vận hành và cả các team khác như marketing, sales, cho phép các bộ phận của tổ chức tiến gần hơn với việc đạt được mục tiêu.


|<image_2>|

## Tại sao Doanh nghiệp cần Devops

  * **Tốc độ** : DevOps giúp các developers và team operations đạt được mục tiêu ở một tốc độ khác giúp cải tiến sản phẩm nhanh chóng phục vụ người dùng, thích nghi với thị trường tốt hơn và điểu chỉnh hiểu quả kinh doanh hiệu quả hơn.

  * **Chuyển giao nhanh chóng** : Tăng tốc độ release thường xuyên để chúng ta cải thiện sản phẩm nhanh hơn và cho ra mắt các feature nhanh hơn cũng như fix bug, giúp phản hồi cho khách hàng nhanh chóng và xây dựng nên lợi thế cạnh tranh tốt hơn.

  * **Độ tin cậy** : DevOps đảm bảo chất lượng bằng cách áp dụng CI /CD, Monitoring và logging process. Bằng cách update mà team infrastructure cấp quyền cho team development để chuyển giao nhanh hơn mà vẫn duy trì được trải nghiệm người dùng tốt.

  * **Mở rộng** : Team vận hành, quản lý infra và các quy trình. Lên kế hoạch về quy mô và nâng cấp môi trường giúp quản trị các hệ thống phức tạp hoặc hay thay đổi hiệu quả cũng như giảm thiểu rủi ro.

  * **Bảo mật** : DevOps giúp di chuyển mà không chịu tổn thất về bảo mật bằng các chính sách, kiểm soát và phương pháp quản lý configuration. Thậm chí các team có thể kêu gọi bạn theo các tiêu chuẩn từ sớm bằng cách cung cấp các setup các tool theo dõi.


# Lộ trình phát triển nghề Devops

## Devops cần học gì?

Để làm được devops bạn phải biết khá nhiều thứ về system cũng như coding và nhiều kỹ năng sau đây:

  * Biết và sử dụng thành thạo linux, window, macOS. Biết dùng thành thạo lệnh Terminal trong linux, CMD và powercell trong window và lệnh trong Linux hoặc Macos. Có kiến thức cơ bản về: Process Management, Threads and Concurrency, Sockets, I/O Management, Virtualization, Memory storage and File systems.

  * Nên có kiến thức cơ bản về: DNS, HTTP, HTTPS, FTP, SSL. Hoặc tìm hiểu thêm về các lỗ hổng bảo mật thường gặp.

  * Biết cài đặt và sử dụng vài Web Server phổ biến như: Apache và Nginx. Tìm hiểu một số khái niệm và chức năng thường được sử dụng: Caching Server, Load balancer, Reverse Proxy, and Firewall. Có thể bắt đầu với một vài practice với Docker đơn giản như:

* Setup thử một vài cache server

* Giả lập có nhiều servers dưới local bằng cách dùng các Docker container. Sử dụng chức năng Load balancer của Web server để cân bằng tải cho server.

  * Biết và sử dụng một số dịnh vụ cloud như AWS của amazon, google cloud, và azure của microsoft.

  * Biết code một số ngôn ngữ hệ thống như bashscript, java, javascipt , python, Php…

  * Biết dùng 1 số tool để truyển khai CI&CD như jenkins, jira , git (Gitlab, Bitbucket…)… Một DevOps Engineer nên biết Infrastructure as code):

* Containers: Docker, Kubernetes

* Các công cụ quản lý cấu hình: Ansible, Pupet, Chef,..

  * Biết sử dụng các tool monitoring server như: Nagios, Zabbix, Icing, Datadog…


## Devops Roadmap

|<image_3>|

# Public_194

# MONGODB là gì?

MongoDB là một phần mềm mã nguồn mở dùng để quản trị cơ sở dữ liệu NoSQL.

|<image_1>|

Hiện nay, có nhiều công ty toàn cầu sử dụng MongoDB để lưu trữ lượng dữ liệu “khổng lồ” của họ như Facebook, Nokia, eBay, Adobe, Google,…

# CÔNG DỤNG CỦA MONGODB

MongoDB giúp các tổ chức lưu trữ lượng lớn dữ liệu trong khi vẫn hoạt động nhanh chóng. Ngoài lưu trữ dữ liệu, MongoDB còn được sử dụng trong các trường hợp sau:

  * Tích hợp một lượng lớn dữ liệu đa dạng

  * Mô tả các cấu trúc dữ liệu phức tạp, biến hoá

  * Cung cấp dữ liệu cho các ứng dụng hiệu suất cao

  * Hỗ trợ các ứng dụng [đám mây lai](https://itviec.com/blog/dien-toan-dam-may/) và đa đám mây

  * Hỗ trợ phương pháp phát triển [Agile](https://itviec.com/blog/agile-la-gi-scrum-la-gi/)


Thay vì sử dụng các table và row như trong cơ sở dữ liệu quan hệ, vì là cơ sở dữ liệu NoSQL, MongoDB được tạo thành từ collection và document.

Document được tạo thành từ các cặp khóa-giá trị (là đơn vị dữ liệu cơ bản của MongoDB). Còn collection, tương đương với table trong SQL, là nơi chứa các bộ document.

# CÁC THUẬT NGỮ MONGODB THƯỜNG DÙNG

## _ID

_id là một trường bắt buộc trong mọi document của MongoDB. _id được sử dụng để đại diện cho tính duy nhất của một document trong một collection.

Trường _id hoạt động giống như khóa chính (primary key) của document.

_id là một số thập lục phân 12 byte đảm bảo tính duy nhất của mọi document.

Bạn có thể cung cấp _id trong khi chèn document. Trong 12 byte này:

  * 4 byte đầu tiên đại diện cho thời điểm hiện tại (dựa trên hệ giây của Unix Epoch);

  * 3 byte tiếp theo cho id máy;

  * 2 byte tiếp theo cho process id của máy chủ MongoDB;

  * 3 byte cuối cùng là giá trị gia tăng đơn giản.


Nếu bạn không cung cấp được số id thì MongoDB sẽ tự động cung cấp một id duy nhất cho document của bạn.

## Document

Document là đơn vị lưu trữ dữ liệu cơ bản trong cơ sở dữ liệu MongoDB. Document mang vai trò tương tự như row trong các hệ thống cơ sở dữ liệu quan hệ truyền thống.

Document là một cách để sắp xếp và lưu trữ dữ liệu dưới dạng một tập hợp các cặp field-value. Document trong MongoDB không cần phải có cùng một bộ field hoặc cấu trúc với các document khác trong cùng một collection.

Đồng thời, các field chung trong document của một collection có thể chứa các loại dữ liệu khác nhau.

## Collection

Collection là một tập hợp các document MongoDB. Collection tương tự như table trong hệ thống cơ sở dữ liệu quan hệ. Các collection có tính chất schema less, do đó các document trong cùng một collection có thể có các trường khác nhau.

Thông thường, một collection chứa các document có mục đích tương tự hoặc liên quan với nhau.

## Database

Trong MongoDB, database là một container vật lý chứa tập hợp các collection. Một database có thể chứa 0 collection hoặc nhiều collection.

Một phiên bản máy chủ MongoDB có thể lưu trữ nhiều database và không có giới hạn về số lượng database có thể được lưu trữ trên một phiên bản, nhưng giới hạn ở không gian bộ nhớ ảo có thể được phân bổ bởi hệ điều hành.

# MONGODB hoạt động như thế nào?

## MongoDB lưu trữ dữ liệu như thế nào?

Như chúng ta biết rằng MongoDB là một máy chủ cơ sở dữ liệu và dữ liệu được lưu trữ trong các cơ sở dữ liệu này. Hay nói cách khác, môi trường

MongoDB cung cấp cho bạn một máy chủ mà bạn có thể khởi động và sau đó tạo nhiều cơ sở dữ liệu trên đó bằng MongoDB.

Nhờ vào cơ sở dữ liệu NoSQL, dữ liệu được lưu trữ dưới dạng collection và document. Do đó, cơ sở dữ liệu, collection và document có mối liên hệ với nhau như hình dưới đây:

|<image_2>|

Trong máy chủ MongoDB, bạn có thể tạo nhiều cơ sở dữ liệu và nhiều collection.

Cách cơ sở dữ liệu MongoDB chứa các collection cũng giống như cách cơ sở dữ liệu MySQL chứa các table.

Bên trong collection, chúng ta có document. Các document này chứa dữ liệu mà bạn muốn lưu trữ trong cơ sở dữ liệu MongoDB và một collection có thể chứa nhiều document. Đồng thời, với tính chất schema-less (không cần một cấu trúc lưu trữ dữ liệu), document này không nhất thiết phải giống với document khác.

Các document được tạo bằng cách sử dụng các field (trường). Các field là các cặp khóa-giá trị trong document, giống như các column trong cơ sở dữ liệu quan hệ. Giá trị của các field có thể là bất kỳ loại dữ liệu BSON nào như double, string, boolean, v.v.

MongoDB lưu trữ dữ liệu ở định dạng BSON document. Ở đây, BSON là đại diện cho định dạng mã hoá nhị phân của các tài liệu JSON (chữ B trong BSON là viết tắt của Binary). Hay nói cách khác, trong phần backend, máy chủ MongoDB chuyển đổi dữ liệu JSON thành dạng nhị phân, được gọi là BSON, và BSON này có thể được lưu trữ và truy vấn hiệu quả hơn. Kích thước tối đa của BSON document là 16 MB.

Trong MongoDB document, bạn được phép lưu trữ dữ liệu lồng nhau. Việc lồng dữ liệu này cho phép bạn tạo các mối quan hệ phức tạp giữa dữ liệu và lưu trữ chúng trong cùng một document, giúp cho quá trình làm việc và tìm nạp dữ liệu hiệu quả hơn so với SQL.

## MongoDB hoạt động như thế nào?

|<image_3>|

MongoDB hoạt động với hai layer:

  * Layer Ứng dụng

  * Layer Dữ liệu


Layer Ứng dụng còn được gọi là Layer Trừu tượng Cuối cùng (Final Abstraction Layer), gồm hai phần, đầu tiên là Front-end (Giao diện người dùng) và thứ hai là Back-end (máy chủ):

  * Giao diện người dùng là nơi người dùng sử dụng MongoDB với sự trợ giúp của Web hoặc Di động. Web và thiết bị di động này bao gồm các trang web, ứng dụng di động, ứng dụng mặc định của Android, ứng dụng iOS, v.v.

  * Phần back-end chứa một máy chủ được sử dụng để thực hiện logic phía máy chủ và cũng chứa trình điều khiển hoặc MongoDB shell để tương tác với máy chủ MongoDB với sự trợ giúp của truy vấn.


|<image_4>|

Các truy vấn này được gửi đến máy chủ MongoDB thuộc Layer Dữ liệu. Bây giờ, máy chủ MongoDB nhận các truy vấn và chuyển các truy vấn đã nhận tới công cụ lưu trữ vì bản thân máy chủ MongoDB không trực tiếp đọc hoặc ghi dữ liệu vào tệp hoặc đĩa hoặc bộ nhớ.

Sau khi chuyển các truy vấn nhận được tới bộ máy lưu trữ, bộ máy lưu trữ chịu trách nhiệm đọc hoặc ghi dữ liệu trong tệp hoặc bộ nhớ.

# Public_195

# Đặt vấn đề

## Trí tuệ nhân tạo trong giáo dục: Xu thế không thể đảo ngược

Dù có lịch sử phát triển hơn 100 năm, từ những năm 1920 (xem Hình 1), sự có mặt của trí tuệ nhân tạo (AI) trong lĩnh vực giáo dục chỉ được biết tới mạnh mẽ nhất từ tháng 3 năm 1965, khi báo cáo UNESCO Courier giới thiệu về học máy (learning machines) - Bộ chương trình được phát triển ở Mĩ để hỗ trợ học sinh học tập [1], [2], [3], [4], [5], [6]. Trong suốt 60 năm vừa qua, quá trình phát triển vượt bậc của những công cụ AI trong giáo dục gắn liền với sự thay đổi về đặc điểm và yêu cầu kinh tế - xã hội, về nhu cầu và điều kiện giáo dục và quan trọng nhất, về quan niệm dạy và học của từng quốc gia trên thế giới.

|<image_1>|

Từ những năm 1950 đến 1990

Trong giai đoạn này, sự phát triển của AI chủ yếu xoay quanh việc sử dụng máy tính để cải thiện kết quả và trải nghiệm dạy và học. Cụ thể, từ những năm 1960, ý tưởng về việc sử dụng máy tính và công nghệ trong giáo dục bắt đầu xuất hiện với khái niệm về dạy và học máy (teaching and learning machines) được đề cập trong các trích dẫn của các nhà giáo dục có tiếng [7]. Một ví dụ điển hình của học máy kể tới PLATO (Programmed Logic for Automatic Teaching Operations) - một hệ thống dạy học hỗ trợ máy tính, tiên phong cho nền dạy học trực tuyến ngày nay. Những năm 1970 chứng kiến tính ứng dụng cao của AI trong giáo dục, trong đó xuất hiện những thử nghiệm đầu tiên về việc tích hợp công nghệ trong giáo dục (Educational technology tools) nhằm nâng cao hiệu quả học tập. Một số hệ thống AI sớm (Early artificial intelligence systems) như AutoTutor (Hệ thống hỏi đáp hỗ trợ học sinh học ngôn ngữ), LEGO Mindstorms (Sản phẩm giáo dục sử dụng chương trình và cảm biến để giúp học sinh hiểu về lập trình, kĩ thuật và cơ bản của robot) cũng được phát triển trong giai đoạn này [7].

Từ những năm 1980 đến 1990

Khi cơ sở hạ tầng công nghệ được cải thiện đáng kể, những công cụ AI trong giáo dục ra đời ngoài mục đích nâng cao thành tích còn gia tăng trải nghiệm học tập thích thú và tích cực cho học sinh đối với tất cả các môn học. Một số công cụ nổi bật kể tới là sự ra đời của những môi trường giáo dục ảo (Virtual learning environments), các phần mềm và ứng dụng học tập tự động và cá nhân hóa (Ví dụ: Cognitive Tutor dạy và học Toán, Programming by Example dạy và học Lập trình, Jupiter Learning dạy và học Điện và Kĩ thuật) [8].

Từ năm 2000 đến nay

|<image_2>|

Sự bùng nổ của các công cụ AI trong giáo dục bắt đầu trở nên mạnh mẽ từ những năm 2000 và hoàn toàn thay đổi cục diện giáo dục thế giới vào năm 2020, với sự tác động lớn của đại dịch COVID-19. Cụ thể, từ những năm 2000, các nền tảng giáo dục trực tuyến kết hợp các tính năng tự động của AI trở nên phổ biến, cho phép người học được tự tiếp cận kiến thức thông qua các nền tảng trực tuyến, tự xây dựng lộ trình học tập linh hoạt phù hợp với nhu cầu cá nhân [8]. Ví dụ, nền tảng Khan Academy thành lập năm 2006 đã xây dựng hơn 6000 video bài giảng miễn phí và hệ thống đánh giá kết quả tự động, giúp học sinh tự đánh giá năng lực bản thân và đưa ra định hướng học tập phù hợp nhất. Một nền tảng đáng chú ý khác là Knewton, xuất hiện từ năm 2008, sử dụng thuật toán và dữ liệu để tối ưu hóa trải nghiệm học tập [9].

Từ những năm 2010

Sự xuất hiện của Chatbots - công cụ AI cho phép con người giao tiếp với máy tính để tiếp cận kiến thức và giải đáp thắc mắc đã bắt đầu thay đổi quan niệm của các nhà nghiên cứu và nhà giáo dục về tiềm năng còn tiềm ẩn của các công cụ AI trong lĩnh vực giáo dục [7]. Cùng với đó, công nghệ thực tế ảo (VR - Virtual Reality) và thực tế ảo tăng cường (AR \- Augmented Reality) cũng được tích hợp trong giảng dạy, mang lại trải nghiệm học tập hoàn toàn khác biệt so với giáo dục truyền thống. Ví dụ, Google Expeditions sử dụng thực tế ảo tăng cường để đưa học sinh vào các hành trình thực tế ảo, mở rộng không gian giáo dục đến những nơi học sinh chưa từng đặt chân.

Hình 1: Cột mốc phát triển của AI dựa trên khả năng giải quyết vấn đề [10]

Từ Hình 1 ta thấy được rằng, khả năng giải quyết vấn đề và xử lý thông tin của AI phát triển một cách đáng chú ý từ năm 2010, đánh dấu giai đoạn vàng của kỉ nguyên AI. Nếu năm 2015, AI có thể thực hiện những thao tác mang tính nhận diện và thông hiểu như nhận diện khuôn mặt và thông hiểu văn bản, thì năm 2023, với sự ra đời của AI tạo sinh, các công cụ AI có thể vận dụng kiến thức từ dữ liệu, phân tích hiện tượng như một con người và đưa ra những đánh giá hiện trạng nhằm sáng tạo ra những ý tưởng mới [10]. Nhìn từ góc độ phát triển tư duy, AI đã đạt tới được cấp độ sáng tạo - cấp độ cao nhất trong thang đo tư duy Bloom.

Tác động của đại dịch COVID-19

Ngoài quá trình phát triển vốn có của AI, tác động của đại dịch COVID-19 tới quá trình dạy và học tạo ra một cú hích lớn cho nhận thức toàn cầu về tầm quan trọng của công nghệ trong giáo dục. Theo World Bank, chỉ trong hai năm đại dịch, việc học tập của hơn 1.6 tỉ học sinh bị gián đoạn ở nhiều mức độ khác nhau, từ học trực tuyến tới nghỉ học hoàn toàn (2023). Trong hai năm này, các nền tảng học tập trực tuyến, các ứng dụng công nghệ giáo dục và các ứng dụng AI thông minh trở thành giải pháp tối ưu để cải thiện việc tiếp cận giáo dục ở nhiều quốc gia trên toàn thế giới [11], đóng vai trò như cầu nối giữa người học và tri thức, không chỉ cung cấp nền tảng để trao đổi tri thức mà còn cung cấp trải nghiệm học tập hấp dẫn [12].

Vì vậy, UNESCO (2021) nhấn mạnh rằng, việc sử dụng công nghệ không chỉ giúp duy trì quá trình giảng dạy và học tập trong tình huống khẩn cấp như đại dịch mà còn tạo ra cơ hội cho sự sáng tạo trong giáo dục, hướng tới một nền giáo dục tiên tiến và chất lượng hơn [13]. Hơn nữa, các giải pháp công nghệ có thể được phát triển dựa trên cơ sở hạ tầng và tài nguyên hiện có. Do đó, việc thúc đẩy tính bền vững giáo dục có tiềm năng đạt được bằng cách trang bị cho học sinh các kĩ năng cần thiết, bao gồm kĩ năng số để điều hướng và định vị bản thân trong một thế giới đang tiến triển không ngừng. Từ đó trở đi, nhận thức và thói quen sử dụng công nghệ của nhà trường, giáo viên và học sinh toàn cầu cũng có sự chuyển biến rõ rệt. Xu hướng sử dụng AI để giải quyết các thách thức hiện nay trong giáo dục trở nên phổ biến - một bình thường mới, một xu thế không thể đảo ngược [1], [2], [3], [4], [5], [6]. Ví dụ, có thể kể đến những ứng dụng trò chơi tích hợp AI nhằm tăng tương tác học tập (Quizlet, Quizziz, Padlet…), những nền tảng học tập như Coursera sử dụng AI để cung cấp trải nghiệm học tập cá nhân hóa hiện nay đã trở thành một phần không thể thiếu trong giáo dục chính quy và trong suốt hành trình học tập suốt đời.

## Từ vô địch cờ vua tới vô địch Olympics: Cuộc đua AI chưa có hồi kết

Nhìn từ góc độ kĩ thuật, trong lịch sử gần 100 năm hình thành và phát triển, có thể nói rằng, cuộc đua về trí thông minh của AI vẫn chưa có hồi kết. Bắt đầu với một sự kiện chấn động thế giới vào năm 1997 khi Deep Blue - một siêu máy tính sử dụng trí tuệ nhân tạo phát triển bởi IBM đánh bại kì thủ cờ vua thế giới nổi tiếng Garry Kasparov, thể hiện khả năng tư duy chiến lược vượt qua trí tuệ con người [14]. Chiến thắng này được coi là một bước ngoặt mang tính cách mạng trong quá trình phát triển của AI, chỉ ra tiềm năng vượt bậc của công cụ này trong việc giải quyết các nhiệm vụ phức tạp yêu cầu nhiều bước thực hiện phân tích dữ liệu tức thì. Trong ba thập kỉ tiếp theo, sự tiến bộ của AI trong việc giải quyết các vấn đề đa lĩnh vực diễn ra theo ba giai đoạn chính, tạm thời dừng chân với một phát minh mới nhất của các nhà khoa học về một công cụ AI vượt qua những học sinh ưu tú nhất, giành giải vô địch Olympics Toán học thế giới.

Dù hành trình từ chiến thắng cờ vua tới chiến thắng Olympics chứng minh được tiềm năng của các công cụ AI trong việc không ngừng đẩy lùi ranh giới của những gì trước đây được coi là không thể, cuộc đua AI vẫn rất quyết liệt và chưa có hồi kết. Đối mặt với hiện tượng này, các quốc gia trên thế giới dần đón nhận tiềm năng của AI, đồng thời đối mặt với những thách thức liên quan đến quyền riêng tư, các yếu tố về đạo đức nhằm đảm bảo rằng, những lợi ích của AI trong giáo dục được khai thác công bằng và hướng tới tiến bộ chung của xã hội. Các quốc gia cũng nhận thức rõ hơn về sự cần thiết để chuẩn bị công dân đáp ứng yêu cầu của thời đại số, bắt đầu tích hợp AI vào chiến lược giáo dục quốc gia của mình. Báo cáo Giám sát Giáo dục toàn cầu của UNESCO (2021) là một minh chứng cho xu hướng toàn cầu này với sự tập trung vào việc nâng cao tính tiện ích, tính bao quát và chất lượng của giáo dục thông qua công nghệ mới.

# Nội dung nghiên cứu

## Nghiên cứu về tác động của AI trong hệ thống giáo dục toàn cầu

### AI tạo sinh và sự tái định nghĩa quá trình dạy và học

Trong số các cột mốc phát triển của AI đã kể trên, giai đoạn hai với sự ra đời của AI tạo sinh (Generative AI), cụ thể là công cụ AI ChatGPT, được cho là sẽ cách mạng hóa phương pháp giảng dạy và học tập truyền thống. Báo cáo UNESCO Courier (2023) đã chỉ ra rằng, AI tạo sinh đã mở ra một chương mới trong lĩnh vực giáo dục toàn cầu, trong đó Trợ lí Tổng Giám đốc UNESCO về Giáo dục Stefania Giannini bày tỏ sự quan ngại sâu sắc về tốc độ tích hợp “khủng khiếp” các công nghệ AI tạo sinh vào hệ thống giáo dục mà chưa có sự kiểm soát và quy định cụ thể của từng quốc gia. Số liệu cho thấy, đến tháng 12 năm 2023, ứng dụng ChatGPT của OpenAI có 180.5 triệu người dùng hàng tháng với 1.6 tỉ lượt sử dụng, chưa kể các công cụ tạo sinh khác như Bard/Gemini phát triển bởi Google, Bing/Copilot phát triển bởi Microsoft [17].

Báo cáo Giám sát Giáo dục toàn cầu của UNESCO (2023) cũng nêu rõ rằng, các công cụ trí tuệ nhân tạo mới hoàn toàn có khả năng tái định nghĩa về dạy và học. Với việc các công cụ AI trở nên ngày một thông minh và được sử dụng mọi lúc mọi nơi để giải đáp thắc mắc, giáo viên không còn là người truyền đạt kiến thức duy nhất mà học sinh có thể chủ động tìm hiểu kiến thức và xây dựng trải nghiệm học tập với sự trợ giúp từ công cụ trợ lí thông minh như ChatGPT [18]. Sự gia tăng tiếp cận tới kiến thức này đang đánh dấu một thời kì mới về học tập suốt đời, cho phép cá nhân tiếp thu kiến thức và phát triển kĩ năng mà không phụ thuộc vào lớp học truyền thống hoặc giáo viên [19].

### Lợi ích và nguy cơ của AI đối với hệ thống giáo dục toàn cầu

#### Lợi ích của AI đối với hệ thống giáo dục toàn cầu

**Trao cơ hội tiếp cận giáo dục:**

Lợi ích lớn nhất mà công nghệ giáo dục nói chung và công cụ AI nói riêng mang lại cho giáo dục phải kể tới việc trao cơ hội tiếp cận giáo dục [11], [20]. Điều này đặc biệt quan trọng đối với học sinh có nhu cầu học tập chuyên biệt (giáo dục đặc biệt), học sinh ở vùng sâu vùng xa gặp khó khăn trong tiếp cận kiến thức. Cụ thể, AI được sử dụng để tạo ra các khóa học trực tuyến hoặc các chương trình giáo dục từ xa phù hợp với từng nhóm trình độ và cấp học khác nhau. Điều này giúp thu hẹp khoảng cách giáo dục, đặc biệt là ở các nước đang phát triển, hướng tới Mục tiêu Phát triển bền vững 04 (SDG4) của Liên Hợp Quốc, trong đó bảo đảm phổ cập tiếp cận giáo dục chất lượng vào năm 2030 [21]. Theo báo cáo của UNESCO (2021), khoảng 250 triệu trẻ em trên thế giới không được tiếp cận với giáo dục và dự đoán tới năm 2030, con số này sẽ là 84 triệu trẻ em. AI có thể đóng một vai trò quan trọng trong việc cung cấp giáo dục cho những trẻ em này, giúp các em có cơ hội tiếp cận với giáo dục và phát triển bản thân một cách chủ động chỉ với một thiết bị máy tính.

**Thúc đẩy giáo dục cá nhân hóa:**

Trong nhiều năm qua, việc cá nhân hóa trải nghiệm và lộ trình học tập của học sinh vẫn luôn là một chủ đề thảo luận nóng giữa các cộng đồng giáo dục. Câu hỏi được đặt ra xoay quanh những giải pháp dạy học giúp phát huy kiến thức nền tảng, năng lực, sở thích, kĩ năng và tính cách của từng học sinh trong lớp [18], [22]. Vai trò của AI được thể hiện mạnh mẽ trong quá trình này, thông qua khả năng sáng tạo các nội dung học tập cá nhân hóa theo dữ liệu được cung cấp của từng học sinh. Cụ thể, công cụ ChatGPT có thể hỗ trợ giáo viên trong việc soạn giáo án phân hóa, tạo các phiếu bài tập cá nhân hóa cho học sinh trong lớp theo phân luồng năng lực, phân tích và đánh giá năng lực học sinh dựa trên điểm số được chấm tự động, từ đó đưa ra gợi ý thực hành giúp học sinh phát huy điểm mạnh và cải thiện điểm yếu [23], [24].

**Xây dựng thói quen học tập suốt đời:**

Với sự cá nhân hóa trải nghiệm học tập, sự tiện ích và thân thiện với người dùng như một gia sư, người bạn đồng hành, các công cụ AI, đặc biệt là công cụ AI hội thoại (conversational AI), cho phép người học được liên tục tương tác và học hỏi, giúp người học xây dựng thói quen học tập và trau dồi kiến thức mọi lúc mọi nơi, hướng tới việc học tập suốt đời [25]. Ngoài ra, các công cụ AI khác, ngoài AI tạo sinh, giúp người học nâng cao trải nghiệm học tập, rút ngắn quy trình công việc, đặc biệt là những việc lặp, từ đó tạo cảm hứng và môi trường thân thiện để người học trau dồi kiến thức mới [26].

**Thúc đẩy đổi mới và tăng cường hiệu quả giảng dạy:**

Một trong những lợi ích lớn của các công cụ AI phải kể tới việc thúc đẩy sự đổi mới sáng tạo, từ đó tăng cường hiệu quả dạy và học cho cả giáo viên và học sinh. Nói cách khác, các ứng dụng AI tạo sinh với khả năng sáng tạo nội dung dựa trên bộ dữ liệu sẵn có, sẽ trở thành một công cụ vô cùng hữu ích trong quá trình đưa ra những ý tưởng mới trong giảng dạy và trong quá trình học tập, nghiên cứu [27]. Cụ thể, ChatGPT đã đóng vai trò như đồng tác giả trong quá trình thực hiện nghiên cứu khoa học giáo dục, trong đó ChatGPT thực hiện phần lớn giai đoạn xây dựng khung nghiên cứu và ý tưởng, phân tích và thảo luận [28]; tác giả chính sửa và sắp xếp lại ý tưởng một cách phù hợp hơn [29], [30]. Đối với giáo viên, các ứng dụng AI hỗ trợ soạn bài, tài liệu và đánh giá học sinh, từ đó tiết kiệm thời gian, giải phóng năng lượng, tạo động lực cho giáo viên dành nhiều thời gian hơn vào việc tối ưu hóa nội dung, hoạt động và phương pháp để nâng cao chất lượng giảng dạy. Tuy nhiên, những cơ hội này luôn đi kèm với thách thức. Nhiều nghiên cứu đã chỉ ra rằng, để xây dựng được hệ thống giáo dục thúc đẩy bằng công nghệ một cách bền vững, các vấn đề liên quan đến khoảng cách số, đạo đức trong môi trường số, bảo mật dữ liệu, tính chính xác và trung thực của nội dung cần được xem xét một cách cẩn trọng.

#### Thách thức từ AI mà hệ thống giáo dục toàn cầu đang đối mặt

**Khoảng cách số:**

Một số ý kiến đã chỉ ra rằng, chính sự xuất hiện của AI đã gia tăng khoảng cách số trong giáo dục [31]. Cụ thể, những công cụ AI tăng cường khoảng cách kinh tế - xã hội giữa các quốc gia phát triển và đang phát triển, giữa khu vực thành thị và nông thôn, giữa những người có đặc quyền và những người thiếu đặc quyền trong xã hội. Nói cách khác, những người có đủ nguồn lực và điều kiện kinh tế thường có ưu thế cạnh tranh, bộ kĩ năng và tốc độ tăng trưởng kinh tế, trình độ cao hơn do sở hữu các công cụ AI tiên tiến bậc nhất, trong khi nhóm người yếu thế, dù có thể tiếp cận, hiện trạng chỉ ra rằng, họ thường không có khả năng chi trả cho những công cụ này [1], [2], [3], [4], [5], [6], [31], [32]. Khoảng cách số được định nghĩa ở bốn cấp độ, từ thiếu quyền truy cập vào công nghệ AI tới việc sử dụng AI một cách có ý nghĩa và hiệu quả.

**Vấn đề về đạo đức trong môi trường AI:**

Các vấn đề liên quan tới đạo đức và ứng xử từ phía người dùng và phía công nghệ trong môi trường AI cũng là những thách thức đáng lo ngại cần được đặc biệt quan tâm. Cụ thể, về phía công nghệ, hiện trạng đã chỉ ra rằng, quy trình thu thập dữ liệu, kiểm chứng, sàng lọc và cung cấp thông tin của các công cụ AI thông minh như AI tạo sinh đều bị can thiệp bởi công ty mẹ. Do đó, nguồn thông tin có thể bị chi phối cho mục đích của cá nhân và tổ chức [1], [2], [3], [4], [5], [6]. Ngoài ra, các công cụ AI tạo sinh “học” và trở nên thông minh từ chính các câu hỏi và phản hồi của người dùng, bao gồm các kiến thức chuyên sâu trong một lĩnh vực. Do đó, các nội dung được cung cấp có thể vướng vào các vấn đề về pháp lí hay vi phạm bản quyền sử dụng nội dung [27]. Đến nay, phần lớn các công cụ AI tạo sinh khi đưa ra thông tin mang tính chuyên môn cao cũng không cung cấp trích nguồn, hoặc cung cấp trích nguồn không chính xác.

**Thu thập, bảo mật và quản lí dữ liệu:**

Cơ chế hoạt động của các công cụ AI đều dựa trên quy tắc sử dụng nguồn dữ liệu khổng lồ (Big data), giúp AI có đủ thông tin để đưa ra những đánh giá và phân tích tự động một cách chính xác. Thách thức đầu tiên trong lĩnh vực dữ liệu phải kể tới quá trình thu thập dữ liệu giáo dục, khi quá trình thu thập phải đảm bảo được tính đại diện về nhân khẩu học (độ tuổi, giới tính, nền tảng xã hội) nhằm cho ra những kết quả phân tích đầy đủ về các nhóm yếu thế, dễ bị tổn thương. Thách thức thứ hai liên quan tới việc bảo mật hàng trăm triệu thông tin cá nhân và thói quen sử dụng công nghệ của người dùng. Trong Hội thảo Toàn cầu AIS2S, OECD (2023) đã chỉ ra rằng, hiện nay lượng lớn dữ liệu cá nhân, bao gồm cả “dữ liệu nhạy cảm”, đã được sử dụng để huấn luyện và phát triển các ứng dụng AI [33]. Nguồn dữ liệu này đến từ các trang web công khai, thông qua những người buôn bán dữ liệu và bản thân cá nhân, trong đó nhiều cá nhân chưa hiểu rõ về hậu quả của việc chia sẻ những thông tin này. Thách thức thứ ba liên quan đến dữ liệu là những nguy cơ trong quá trình quản lí nguồn dữ liệu. UNESCO (2023) đã đưa ra khuyến cáo về việc các nguồn dữ liệu có thể bị tấn công và xâm nhập, hoặc được sử dụng trái phép để tạo ra các phần mềm độc hại, cho phép kẻ tấn công tự động hóa các hành vi phá hoại xã hội.

**Tính chính xác và trung thực của nội dung:**

Thách thức đáng lo ngại cuối cùng cũng là quan trọng nhất, liên quan tới việc sử dụng AI trong môi trường giáo dục tập trung vào tính đáng tin cậy và chính xác của những nội dung do AI cung cấp. Nhiều nghiên cứu đã chỉ ra rằng, các ứng dụng AI tạo sinh như ChatGPT (Open AI), Bard (Google), Copilot (Microsoft) được đào tạo trên một lượng lớn dữ liệu từ tài liệu, văn bản, trang web mà trong đó có thể chứa các nội dung, quan điểm không chính thức, còn thiếu chính xác hoặc đang được thảo luận. Do đó, thực tế đã đưa ra các nội dung không chính xác trong các vấn đề mang tính khoa học và các quan điểm có phần thiên vị trong các vấn đề xã hội [34]. Hậu quả của việc liên tục nhận các thông tin sai lệch có thể gây “ô nhiễm” cho các tư liệu giáo dục, đòi hỏi sự nỗ lực và thời gian đáng kể để cải thiện, kiểm chứng những thông tin này.

### Chính sách về quản lí AI trong giáo dục

Với những lợi ích và nguy cơ mà AI mang lại cho giáo dục toàn cầu, trước khi đại dịch COVID-19 và cơn bão AI tạo sinh xuất hiện, nhiều tổ chức trên thế giới, bao gồm UNESCO và các nhà nghiên cứu cũng đã sớm nhận ra tầm quan trọng của việc xây dựng chính sách về quản lí AI trong giáo dục, từ đó chuẩn bị hành trang về kĩ năng cho giáo viên và học sinh trong viễn cảnh công nghệ đang thay đổi nhanh chóng [18]. Với sự ra đời của AI tạo sinh, UNESCO đặc biệt xây dựng Báo cáo hướng dẫn sử dụng AI tạo sinh trong giáo dục (2023) để đưa ra những khuyến nghị khẩn cấp cho các chính phủ, nhà hoạch định chính sách, trường đại học và các cơ sở giáo dục toàn cầu nhằm quản lí việc sử dụng AI tạo sinh một cách hiệu quả. UNESCO (2023) cho rằng, đến thời điểm này, việc xây dựng các biện pháp bảo vệ và quy định chặt chẽ đối với những rủi ro của việc sử dụng AI trong giáo dục rất quan trọng để định hình tương lai của giáo dục toàn cầu dưới sự ảnh hưởng ngày càng lớn của trí tuệ nhân tạo. Chỉ thông qua những bước tiến cẩn thận và có trách nhiệm, giáo dục toàn cầu mới hòa nhập và tận dụng được những cơ hội mà trí tuệ nhân tạo mang lại.

# Public_196

# Mở đầu

TNN vốn gắn liền với phát triển kinh tế và xóa đói giảm nghèo, sự sẵn có của các nguồn nước và việc quản lý chúng là những yếu tố quyết định chiến lược tăng trưởng của một quốc gia [1]. Trong số 17 Mục tiêu Phát triển bền vững của Liên hợp quốc, Mục tiêu Phát triển bền vững 6 (SDG 6) nhằm đảm bảo sự sẵn có của nước, quản lý hiệu quả TNN và vệ sinh an toàn cho tất cả mọi người vào năm 2030 được coi là một trong những mục tiêu cốt lõi, có quan hệ mật thiết và ảnh hưởng đến nhiều mục tiêu khác. Tuy nhiên, theo báo cáo Cập nhật tiến độ năm 2017 về Nước uống, Công trình vệ sinh và Vệ sinh cá nhân của WHO và UNICEF [2], dự báo đến năm 2030, tình trạng khan hiếm nước sẽ khiến 700 triệu người phải di dời, thay đổi nơi sống.

|<image_1>|

Báo cáo Cập nhật tiến độ 2021 về SDG 6 của UN-Water [3] đã chỉ ra, cần tăng cường hơn nữa các nỗ lực để đạt được mục tiêu đưa ra vào năm 2030 như: (i) Về dịch vụ nước uống, để đạt được mục tiêu phổ cập tiếp cận với nguồn nước “được quản lý an toàn” sẽ đòi hỏi tốc độ tiến độ gấp bốn lần so với tốc độ hiện tại; (ii) Về công trình vệ sinh, để đạt được mục tiêu tiếp cận toàn diện với hệ thống vệ sinh “cơ bản”, yêu cầu tốc độ tăng gấp đôi so với tốc độ tiến độ hiện tại và để đạt được mục tiêu tiếp cận phổ biến đối với hệ thống vệ sinh “được quản lý an toàn”, yêu cầu tốc độ tăng gấp bốn lần so với tốc độ tiến độ hiện tại; và (iii) Về vệ sinh cá nhân, để đạt được mục tiêu tiếp cận toàn diện với hệ thống vệ sinh cơ bản, yêu cầu tốc độ tăng gấp bốn so với tốc độ tiến độ hiện tại. Để tăng tốc độ tiến độ đòi hỏi phải tăng đáng kể mức đầu tư hiện tại vào các dịch vụ nước uống và dịch vụ vệ sinh. Các giải pháp và công nghệ tài chính truyền thống đã được chứng minh là không đủ trong việc giải quyết những thách thức này, nếu không có giải pháp, hành động nào phù hợp và mạnh mẽ hơn thì chắc chắn không thể đạt được SDG 6 theo đúng tiến độ [4]. Để đảm bảo tiến trình đạt được mục tiêu này cần đổi mới và phát triển các phương pháp tiếp cận theo hướng sáng tạo để giải quyết vấn đề chất lượng nước, khan hiếm nước.

Sáng kiến Thế giới năm 2050 (TWI2050) do Viện Quốc tế về Phân tích hệ thống ứng dụng (IIASA) thực hiện nhằm mục đích cung cấp cơ sở khoa học cho Chương trình Nghị sự 2030 đã đưa ra 6 chuyển đổi quan trọng để đảm bảo tiến trình đạt được các Mục tiêu Phát triển bền vững, trong đó có Cách mạng kỹ thuật số [5]. Theo đó, Cách mạng kỹ thuật số là tập hợp của nhiều công nghệ tiên tiến có thể hỗ trợ đạt được các mục tiêu phát triển bền vững. Tuy nhiên, việc áp dụng các công nghệ này một cách không phù hợp cũng đồng thời đe dọa và cản trở tiến trình này. Do đó, cần nghiên cứu cách kết hợp linh hoạt các công nghệ kỹ thuật số nhằm thúc đẩy quá trình thực hiện Chương trình Nghị sự 2030, vì một tương lai xanh và bền vững. Đồng thời, cần xây dựng cấu trúc quản trị và lộ trình hướng tới tương lai cụ thể, sao cho sự đánh đổi tiềm năng liên quan đến môi trường, xã hội và con người của một cuộc cách mạng khoa học, công nghệ, sáng tạo (STI) được kiểm soát.

|<image_2>|

Cuộc cách mạng công nghiệp lần thứ 4 (4IR) cung cấp các công nghệ mới, mang tính đột phá với nền tảng chuyển đổi kỹ thuật số và tự động hóa có tiềm năng cao để đẩy nhanh tiến độ nhằm đạt được các mục tiêu đặt ra trong Chương trình Nghị sự 2030 nói chung và SDG nói riêng. Các công nghệ mới đó là: Trí tuệ nhân tạo (AI); Internet vạn vật (IoT); Dữ liệu lớn (Big data); Blockchain; Drone; Thực tế ảo và tăng cường (VR/AR). Các công nghệ có thể liên kết với nhau để xóa bỏ hạn chế khi các công nghệ hoạt động riêng biệt và có thể kết nối, chuyển đổi thành một hệ thống toàn diện phức hợp gồm các yếu tố liên kết và phụ thuộc với nhau. Mục tiêu của bài báo cung cấp cách nhìn tổng quan về một số ứng dụng kỹ thuật số điển hình trong quản lý TNN, chủ yếu tập trung vào 3 công nghệ phổ biến là trí tuệ nhân tạo (AI), Internet vạn vật (IoT) và dữ liệu lớn (Big data) [4].

# Khái niệm và mối quan hệ của các công nghệ kỹ thuật số

## Trí tuệ nhân tạo (AI)

Định nghĩa về trí tuệ nhân tạo (AI) thay đổi tùy thuộc vào tổ chức và ngữ cảnh nó được sử dụng. Theo Tổ chức Hợp tác và Phát triển kinh tế (OECD), hệ thống AI là: “một hệ thống dựa trên máy móc có thể thực hiện một số mục tiêu nhất định do con người xác định, đưa ra dự đoán, đề xuất hoặc quyết định ảnh hưởng đến môi trường thực hoặc ảo. Hệ thống AI được thiết kế để hoạt động với nhiều mức độ tự chủ khác nhau” [6]. Các hệ thống AI thường xuyên có xu hướng bắt chước hành vi thông minh tự nhiên của con người và được phát triển để giải quyết các vấn đề cụ thể tốt hơn con người.

AI có khả năng ảnh hưởng đến tất cả các bộ phận của nền kinh tế và biến đổi phương thức làm việc, sinh sống của con người. AI là một công nghệ quan trọng và cơ bản trong thời kỳ công nghiệp 4.0. Số lượng những ứng dụng AI đã tăng lên trong những năm gần đây nhờ những tiến bộ về năng lực tính toán, điện toán đám mây và khả năng tiếp cận cơ sở dữ liệu ngày càng tăng cùng với các công cụ phân tích phức tạp [4]. Trong lĩnh vực TNN, các quá trình thủy văn có thể được coi là một quá trình phi tuyến tính trong tự nhiên [7], [8]. Theo đó, một số biến số như dòng chảy và lượng mưa ở các địa điểm khác nhau có các tham số khác nhau phụ thuộc vào thời gian. Do đó, cần phải mô tả, diễn giải và phân tích các quá trình phi tuyến tính này. Khi các thuật toán và thông số của AI được xây dựng một cách thích hợp để lập mô hình, mô hình được tạo ra sẽ mang lại hiệu quả kinh tế, rút ngắn thời gian và đưa ra kết quả chính xác hơn. Đây là một trong những lợi thế quan trọng nhất của AI. Hơn nữa, độ chính xác và chức năng của một mô hình có thể được kiểm soát bằng các tập dữ liệu được lưu trữ. Một trong những điểm quan trọng là người điều khiển mô hình cần có khả năng xác định mối quan hệ trong các quá trình thủy văn và ảnh hưởng của các thông số, đồng thời có thể chọn hoặc thay đổi các thông số, chức năng, số lặp, thuật toán của mô hình trong trường hợp biến đổi. Trong bối cảnh đó, các nghiên cứu sử dụng kỹ thuật AI liên quan đến TNN đã nhấn mạnh tầm quan trọng của vấn đề này [9].

## Internet vạn vật (IoT) và dữ liệu lớn (Big data)

Internet vạn vật (IoT) đề cập đến mạng lưới các thiết bị và đối tượng được kết nối với internet đang phát triển nhanh chóng [4]. Các thiết bị, đối tượng này được đưa vào hộ gia đình, nơi làm việc hàng ngày của chúng ta và chúng có thể cùng nhau thực hiện các tác vụ cụ thể trên môi trường khác nhau. Các thiết bị này được kết nối với các máy tính mạnh trong “đám mây” nhằm hỗ trợ giao tiếp giữa người với vật và giữa vật thể với đối tượng. Việc áp dụng IoT trên quy mô lớn sẽ tạo ra một lượng lớn dữ liệu. Tuy nhiên, bởi kích thước, sự đa dạng và tốc độ tạo lập là hạn chế nên việc phân tích lượng lớn dữ liệu trên bằng các công nghệ truyền thống sẽ không thực tế. Do đó, sự ra đời của công nghệ dữ liệu lớn (Big data) sẽ hỗ trợ đưa ra những kết quả có độ tin cậy cao và những thông tin đa dạng hơn từ dữ liệu cơ bản, dần dần giúp thay thế các kỹ thuật thu thập, xử lý dữ liệu truyền thống.

Việc triển khai IoT và dữ liệu lớn có khả năng tác động sâu sắc đến nhiều lĩnh vực, cũng như mở ra các cơ hội và ứng dụng hoàn toàn mới. Liên quan đến quản lý nước, IoT có thể tối đa hóa việc sử dụng nước hiệu quả thông qua các giải pháp mới để cải thiện quản lý nước. Các dự án về nước thường khá phức tạp, vì nhiều thành phố phụ thuộc vào cơ sở hạ tầng cũ. Do đó, việc sử dụng IoT có thể hỗ trợ các thành phố giảm chi phí vận hành liên quan đến xây dựng và bảo trì (ibid.).

Mục tiêu của IoT và dữ liệu lớn trong TNN là thúc đẩy tiếp cận tích hợp và toàn diện dựa trên IoT đối với số lượng, chất lượng nước và giám sát môi trường bằng cách đưa ra những phương pháp dựa trên cơ sở khoa học công nghệ và đổi mới sáng tạo hướng tới quản lý bền vững TNN [10]. Một số ứng dụng của IoT và dữ liệu lớn trong lĩnh vực TNN được đưa ra trong các mục tiếp theo.

## Mối liên hệ giữa trí tuệ nhân tạo (AI) với Internet vạn vật (IoT) và dữ liệu lớn (Big data)

Chất lượng nước mặt ở các nước đang phát triển được dự báo ngày càng trầm trọng do lượng nước thải ngày càng tăng trong khi khả năng xử lý nước thải chưa được cải thiện. Hậu quả tất yếu là sự gia tăng hiện tượng phú dưỡng, nguy cơ cao mất đa dạng sinh học và tình trạng khó kiểm soát các bệnh lây truyền qua nước. AI, cảm biến thông minh và các công nghệ IoT khác đã được ứng dụng để giám sát việc xử lý chất thải của các nhà máy, từ đó có phương án tối ưu hóa việc sử dụng tài nguyên và lên kế hoạch bảo trì thiết bị thích hợp dựa trên dữ liệu lịch sử [11]. Những điểm chưa hiệu quả của các hệ thống dịch vụ về nước hiện tại đã và đang được giải quyết thông qua việc phân tích dựa trên sự kết hợp giữa AI với các cảm biến IoT. Đây là một sự kết hợp đủ mạnh để liên tục quan trắc, dự báo và đáp ứng nhu cầu nước một cách hiệu quả, bền vững nhất [11]. Ngoài ra, sự tích hợp giữa IoT với AI có thể tạo ra một công nghệ mạnh hỗ trợ giải quyết những vấn đề của IoT. Một trong số đó là vấn đề liên quan đến khối lượng dữ liệu khổng lồ được tạo ra từ các thiết bị IoT khác nhau. Với khả năng phân tích đáng kể của AI, dữ liệu IoT có thể được phân tích hiệu quả để trích xuất thông tin có ý nghĩa, từ đó hỗ trợ phân tích để đưa ra các quyết định sáng suốt hơn [12].

Thu thập dữ liệu là một công việc quan trọng, nhưng bên cạnh đó, việc sắp xếp, phân tích và đánh giá dữ liệu là những công việc không kém phần quan trọng [13]. AI là công cụ giúp phân tích và hỗ trợ ra quyết định từ dữ liệu được thu thập bởi các thiết bị IoT qua các chương trình quan trắc bổ sung từ xa. Như vậy, việc tích hợp AI và IoT sẽ khai phá phần lớn tiềm năng của dữ liệu IoT. Tuy nhiên, vẫn còn nhiều thách thức làm cho sự kết hợp giữa IoT với AI trở nên kém hiệu quả. Những thách thức này bao gồm tính pháp lý, tính không đồng nhất, tính bảo mật và quyền riêng tư, độ chính xác, tốc độ, kiến trúc trung tâm và cả những lỗi không đáng có [12].

# Các ứng dụng công nghệ kỹ thuật số trong quản lý TNN

## Trí tuệ nhân tạo (AI)

### Ứng dụng của AI trong quản lý nước và nước thải

Các ứng dụng chính hiện có và tiềm năng của AI trong cấp nước và quản lý nước thải có thể được áp dụng để đánh giá hiệu suất; tối ưu hóa các hoạt động; phát hiện rò rỉ đường ống [6]. Một số ứng dụng chính của AI trong cấp nước và quản lý nước thải được tóm tắt trong Bảng 1. Mức độ ứng dụng của AI dao động từ các chatbot đơn giản để hỗ trợ khách hàng cho đến các hệ thống quan trọng để tư vấn hoặc hỗ trợ vận hành, duy trì việc xử lý nước và nước thải. Phạm vi cũng bao gồm từ nguồn nước đến xả nước thải. Ngoài ra, AI cũng hỗ trợ quản lý tổng hợp chu trình nước (ibid.).

Một ứng dụng cụ thể của AI trong xử lý nước thải được phát triển bởi Công ty EMAGIN của Canađa với hệ thống trí tuệ ảo thời gian thực thích ứng kết hợp [4]. Sản phẩm này có thể được tích hợp vào các hệ thống hiện có để tối ưu hóa việc quản lý mạng lưới nước và nhà máy xử lý nước thải bằng cách cung cấp các hành động kiểm soát tối ưu dựa trên việc học hỏi từ các hoạt động trong quá khứ, dữ liệu thời gian thực và các điều kiện dự báo. Nó có thể tối ưu hóa quá trình phân hủy kỵ khí và sục khí bằng cách điều chỉnh chi phí năng lượng dựa trên cấu hình tải; hỗ trợ kiểm soát chất dinh dưỡng bằng cách tối ưu hóa các điểm đặt liều lượng hóa chất hướng vào ảnh hưởng (ví dụ: clorua sắt) để tăng cường kiểm soát phốt pho; cung cấp tính năng phát hiện đóng cặn/tắc nghẽn theo thời gian thực và tính toán tuổi thọ màng; tối ưu hóa các hệ thống xử lý nước thông thường và theo hướng màng, tăng cường quá trình keo tụ, đông tụ với việc kiểm soát liều lượng hóa chất dự đoán nhiều lớp tiên tiến và tối đa hóa khả năng phục hồi màng dựa trên các dự đoán về chất lượng nước cấp. Nó cũng có thể tận dụng AI để quản lý tối ưu mạng lưới truyền tải và phân phối nước với giám sát chất lượng nước theo thời gian thực, nâng cao khả năng phát hiện vấn đề sử dụng dữ liệu áp suất không ổn định có độ phân giải cao cùng với việc tối ưu hóa thời gian thực của các điểm đặt van giảm áp trên toàn mạng.

AI có thể cho phép tiết kiệm nước nhiều hơn từ máy bơm đến vòi nước (ibid.), cũng như đánh giá và cung cấp chính xác nhu cầu nước, AI đang trở thành một công cụ thiết yếu trong cuộc chiến chống lãng phí nước. Ngăn ngừa lãng phí nước có tầm quan trọng đặc biệt ở các nước bị căng thẳng về nước hoặc khan hiếm nước. Mỗi lít lãng phí do rò rỉ, vỡ đường ống và các hiện tượng bất thường khác là một lít có thể cứu hoặc cải thiện cuộc sống. Lượng nước thất thoát trước khi đến các hộ gia đình do vỡ đường ống ước tính khoảng 15% ở các nước phát triển và lên đến 50% ở các nước đang phát triển [14].

Một trong những ứng dụng lớn nhất của AI trong ứng dụng nước và vệ sinh là cung cấp những dữ liệu có thể thúc đẩy việc ra quyết định (ibid.). Trong đó, dữ liệu người dùng và không gian địa lý có thể được sử dụng để quyết định nơi cần xây dựng các công trình vệ sinh, nước uống nhằm đáp ứng nhu cầu của hầu hết các cộng đồng dễ bị tổn thương. Thêm nữa, dữ liệu đó có thể được sử dụng để hiểu khoảng cách cung, cầu về nước và giúp cung cấp nước ở những nơi cần thiết nhất (ở cấp khu vực, cấp cộng đồng hoặc trong cơ sở của một công ty). Ngoài ra, dữ liệu đó còn có thể được sử dụng để tư vấn về quản lý nước tốt hơn và quản lý nước ở cấp lưu vực.

Ứng dụng AI trong TNN tại Việt Nam chủ yếu được ứng dụng trong các nghiên cứu về phân tích dòng chảy, đánh giá dự báo chất lượng nước. Cao Hoàng Hải và cộng sự (2019) đã ứng dụng 2 mô hình AI là Random Forest (RF) và Support Vector Machine (SVM/SVR) để dự báo thử nghiệm dòng chảy đến hồ sông Hinh trên lưu vực sông Ba [15]. Hoàng Thị An và cộng sự (2022) với nghiên cứu kết hợp mô hình thủy lực và AI trong mô phỏng chất lượng nước. Mô hình AI sử dụng thuật toán MLP - ANN xây dựng quan hệ hồi quy giữa lưu lượng nước sông và nồng độ các nguồn thải với các chỉ số chất lượng nước để dự báo chất lượng nước tại các vị trí kiểm soát theo các kịch bản kiểm soát và quản lý nguồn thải khác nhau một cách nhanh chóng [16]. Các ứng dụng AI trong cung cấp nước, xử lý nước thải… hiện chưa có nhiều nghiên cứu được thực hiện tại Việt Nam.

### Cơ hội và thách thức trong ứng dụng AI

AI là công nghệ đang thu hút được nhiều sự chú ý của các quốc gia do hướng đến những sự đổi mới sáng tạo. Mục tiêu của AI là nhằm nâng cao chất lượng công việc và cuộc sống của con người trong khi đảm bảo không làm trầm trọng hơn tình trạng bất bình đẳng xã hội, kinh tế, chính trị. Để có thể hiện thực hóa mục tiêu kép đó đòi hỏi các định hướng thay đổi mang tính hệ thống toàn diện từ sửa đổi, bổ sung chính sách có liên quan đến đổi mới phương thức hoạt động của doanh nghiệp. Do đó, bên cạnh việc tập trung nguồn lực để mở rộng quy mô, Chính phủ các nước cũng cần phải đánh giá, cân nhắc về tính bền vững trong việc phát triển, ứng dụng rộng rãi hệ thống AI [17]. Bên cạnh đó, một số thách thức lớn trong việc sử dụng AI có thể kể đến là quyền riêng tư của dữ liệu, quyền sở hữu dữ liệu, quyền truy cập dữ liệu và chất lượng của dữ liệu [4].

## Internet vạn vật (IoT) và dữ liệu lớn (Big data)

### Ứng dụng của IoT và Big data trong quản lý nước và nước thải

**Quản lý nước**

Quản lý nguồn cung cấp nước đang trở thành một nhiệm vụ quan trọng đối với các thành phố, các cơ sở cung cấp nước trên toàn thế giới, đặc biệt trong bối cảnh thực hiện cùng phát triển kinh tế - xã hội và ứng phó với biến đổi khí hậu. Cùng với đó, IoT đang được điều chỉnh rộng rãi hơn để phù hợp với nhu cầu riêng của việc giám sát mạng lưới nước [18].

Lượng nước rò rỉ và vỡ đường ống trung bình trên toàn cầu là từ 30% - 35%, thậm chí ở một số khu vực, tỷ lệ này có thể lên tới 50% - 60% [4]. Lượng nước rò rỉ lớn như vậy đã đẩy các công ty cấp nước vào khó khăn với tình trạng sản xuất và cung cấp nước không tạo ra doanh thu. Sự ra đời của đồng hồ thông minh IoT, với khả năng thu thập dữ liệu lớn, giúp giải quyết khó khăn đang tồn tại trên. Cụ thể, đồng hồ thông minh cho phép các công ty cấp nước thường xuyên đọc đồng hồ của khách hàng trong ngày, cung cấp cho khách hàng dữ liệu tiêu thụ nước theo thời gian thực, cũng như nhanh chóng phát hiện thất thoát nước trong hệ thống (ibid.). Từ đó, có thể thấy, đồng hồ thông minh vừa hỗ trợ công ty cấp nước giám sát quá trình cấp nước, quản lý rủi ro, hỗ trợ tăng doanh thu, vừa giúp người tiêu dùng sử dụng nước tiết kiệm, hiệu quả, phù hợp với nhu cầu và khả năng kinh tế.

Một ứng dụng thực tế khác của IoT là trong hệ thống cảnh báo sạt lở đất do mưa lớn Alerta Rio, Brazil [19]. Hệ thống cảnh báo này thu thập dữ liệu tích hợp theo thời gian thực từ 30 cơ quan và được điều phối bởi Trung tâm điều hành của Rio de Janeiro - Trung tâm đầu tiên trên thế giới có mạng lưới đo mưa và hệ thống radar khí tượng giúp cảnh báo thiên tai hiệu quả [20]. Ngoài ra, các công nghệ IoT đã được triển khai để hỗ trợ giám sát môi trường cũng như quản lý dịch vụ. Cụ thể, IoT cho phép giám sát từ xa các đám cháy rừng, các trận động đất cũng như các trận lũ lụt và các nguy cơ ô nhiễm tiềm ẩn.

Tại Việt Nam, Công ty TNHH MTV Thoát nước Hà Nội đã triển khai Trung tâm giám sát hệ thống thoát nước, với chức năng theo dõi diễn biến mưa, quản lý lượng mưa, mực nước, giám sát tình hình hoạt động của các trạm bơm, cửa điều tiết, camera giám sát điểm ngập úng trên hệ thống thoát nước… Ứng dụng bản đồ cảnh báo ngập úng và tìm chỉ đường qua điện thoại (HSDC maps) trên các thiết bị di động thông minh có thể hỗ trợ người dân biết được các thông tin như: Bản đồ các điểm đo lượng mưa, vị trí các điểm ngập, hình ảnh theo thời gian thực tại điểm ngập, tìm đường đi tránh ngập, cảnh báo mưa giông, gửi thông tin trực tiếp về sự cố, điểm ngập úng về Trung tâm điều hành [21].

**Giám sát nước thải**

TP. Holon, nằm ở trung tâm của Israel, có hệ thống nước thải đang gặp nhiều vấn đề liên quan đến việc tắc nghẽn hệ thống [4]. Để khắc phục, thành phố hướng tới lắp đặt các thiết bị đo không tiếp xúc SmartScan 50 với nhiều loại cảm biến của công nghệ ứng dụng Solid (SolidAT). Với khả năng chống chịu cao trong môi trường mêtan của thiết bị cùng tốc độ thu thập và truyền tải dữ liệu nhanh chóng và tin cậy bằng IoT, thành phố có thể kiểm soát, quản lý hệ thống cống rãnh tốt hơn nhờ giám sát mực nước, nước thải từ xa và giải pháp gửi cảnh báo qua dịch vụ tin nhắn SMS khi mực nước đạt giới hạn cao hoặc thấp.

TP. Murcia, Tây Ban Nha, đã và đang triển khai hệ thống cảm biến mạng không dây trong khuôn khổ Dự án Ecosens Aquamonitrix [22]. Hệ thống này cung cấp tính năng quan trắc, giám sát, quản lý các thông số chất lượng nước thải trực tuyến và gần thời gian thực. Cụ thể, hệ thống đã và đang được sử dụng để quan trắc hàm lượng nitrit và nitrat trong nước thải đầu ra của một nhà máy xử lý với kết quả có độ tin cậy cao và được cập nhật gần như tức thời. Nhờ IoT, hệ thống có thể tăng thêm số lượng nút cảm biến, mở rộng khả năng lưu trữ và nâng cao tốc độ xử lý. Ngoài ra, IoT có thể giúp hệ thống phát triển thêm các tính năng khác.

### Cơ hội và thách thức trong ứng dụng IoT và Big data

Việc triển khai IoT trên quy mô lớn sẽ có tác động sâu sắc đến ngành nước, vì nó sẽ thúc đẩy việc sử dụng nước hiệu quả, cải thiện quản lý nước, giảm thiểu ô nhiễm nguồn nước, từ đó giảm chi phí vận hành của các công ty cấp và thoát nước [4]. IoT có thể đảm bảo chất lượng nước và tăng cường khả năng chống chịu với biến đổi khí hậu, cả hai vấn đề đang gây nhức nhối trong khu vực trong những năm gần đây. Liên quan đến đảm bảo chất lượng nước, hệ thống cảm biến có thể được lắp đặt tại các vùng nước để thu thập dữ liệu liên quan đến lưu lượng, số lượng và chất lượng nước. Các dữ liệu thu thập đó có thể được truyền tải đến hệ thống qua các thiết bị IoT. Các cảm biến hỗ trợ IoT cho phép những người ra quyết định phát hiện các vấn đề như vị trí đường nước bị ô nhiễm từ các nhà máy xử lý nước thải hay vùng nước bị phú dưỡng do sản xuất nông nghiệp, trên cơ sở đó để đưa ra các biện pháp khắc phục phù hợp [4].

Tuy nhiên, việc thu thập và lưu trữ các bộ dữ liệu khổng lồ có thể tạo ra các lỗ hổng và rủi ro mới, cũng như làm gia tăng tình trạng bất bình đẳng, làm sai lệch nhận thức, dẫn đến phụ thuộc vào cơ sở hạ tầng tập trung (ibid.). Ví dụ, những người có trình độ học vấn, mức thu nhập thấp hơn sẽ gặp khó khăn trong việc truy cập hoặc tiếp cận các nội dung trực tuyến hơn so với những người có mức thu nhập cao hơn. Điều đó sẽ nới rộng “khoảng cách kỹ thuật số”.

# Kết luận

Nhu cầu về lương thực và năng lượng ngày càng tăng cao, các ngành công nghiệp phát triển nhanh và điều kiện tất yếu về vệ sinh cơ bản của con người làm nhu cầu nước ngày càng tăng. Vì vậy, việc nghiên cứu và thực hiện những giải pháp quản lý nước một cách toàn diện, bền vững hơn trong tương lai đang trở nên hết sức cấp bách [23]. Một trong những giải pháp rất thiết thực là ứng dụng các công nghệ 4.0. Các công nghệ 4.0 giúp tiết kiệm năng lượng, TNN để phục vụ cho các mục tiêu của SDG 6. Ứng dụng các công nghệ mới, chẳng hạn như AI, IoT và Big data, có thể cung cấp các giải pháp cho hệ thống phân phối để chuyển nước một cách linh hoạt đến các khu vực có nhu cầu cao hơn tại bất kỳ thời điểm nào; phát hiện rò rỉ nước ở giai đoạn đầu, nhờ đó giảm đáng kể khả năng thất thoát nước; giám sát các nhà máy xử lý chất thải để tối ưu hóa việc sử dụng tài nguyên và lên lịch bảo trì thiết bị dựa trên dữ liệu lịch sử.

Các cuộc khủng hoảng nước thường liên quan đến việc quản lý nước kém và có thể khẳng định rằng không một công nghệ đơn lẻ nào có đủ khả năng giải quyết tất cả các vấn đề. Vì vậy, việc lựa chọn công nghệ tích hợp và các hệ thống quản lý nước, nước thải cần phải giữ một cách nhìn tổng thể, liên ngành.

Trong bối cảnh phát triển khoa học công nghệ trên thế giới, để phát triển theo kịp các tiến bộ và khoa học kỹ thuật, Việt Nam cũng đã và đang thực hiện nhiều chính sách nhằm ứng dụng công nghệ 4.0 như: chính sách phát triển hạ tầng phục vụ dữ liệu lớn theo Quyết định số 677/QĐ-TTg ngày 18/5/2017 về việc phê duyệt Đề án “Phát triển Hệ tri thức Việt số hóa” [24]; Hỗ trợ nghiên cứu, phát triển và ứng dụng công nghệ của công nghiệp 4.0 theo Quyết định số 2813/QĐ-BKHCN ngày 27/9/2018 phê duyệt Chương trình khoa học và công nghệ trọng điểm cấp quốc gia giai đoạn đến năm 2025: “Hỗ trợ nghiên cứu, phát triển và ứng dụng công nghệ của công nghiệp 4.0” [25]...

# Public_197

# ĐẶT VẤN ĐỀ

Trong thời đại công nghệ số phát triển mạnh mẽ như hiện nay, việc ứng dụng trí tuệ nhân tạo (AI) vào giáo dục đang trở thành xu hướng tất yếu. Đặc biệt, trong lĩnh vực giáo dục kỹ năng sống cho học sinh phổ thông, AI mở ra những tiềm năng to lớn, giúp thiết kế học liệu điện tử một cách sáng tạo, hiệu quả và phù hợp với từng đối tượng học sinh. Nghiên cứu này sẽ đi sâu phân tích những lợi ích, thách thức của việc sử dụng AI trong giáo dục kỹ năng sống và đề xuất quy trình sử dụng công cụ AI thiết kế học liệu điện tử để khai thác tối đa tiềm năng của AI trong việc nâng cao chất lượng dạy học kỹ năng sống cho học sinh phổ thông.

# CƠ SỞ LÝ LUẬN

|<image_1>|

## Học liệu là gì?

Học liệu được hiểu là những tài liệu phục vụ cho mục đích dạy học và các hoạt động học tập của người học và người dạy. Học liệu có thể được thiết kế dưới nhiều hình thức khác nhau như: văn bản, video bài giảng, sơ đồ...

Hiện nay, có khá nhiều định nghĩa về học liệu điện tử (HLĐT). HLĐT được hiểu là tài liệu học tập được cung cấp dưới dạng điện tử, tích hợp của các dạng thức đa phương tiện được số hóa khác nhau như văn bản, âm thanh, hoạt hình... HLĐT là các tài liệu học tập (dạng tài liệu điện tử) được số hóa theo một cấu trúc nhất định, lưu trữ trên máy tính, nhằm phục vụ mục đích dạy học (Nguyễn Thị Huệ & Quách Thùy Nga, 2017). “Học liệu điện tử là các tài liệu học tập được số hóa theo một cấu trúc, định dạng và kịch bản nhất định được lưu trữ trên máy tính nhằm phục vụ cho việc dạy và học” (Trịnh Lê Hồng Phương, 2012).

Bắt kịp xu hướng chuyển đổi số hiện nay, HLĐT đang được phát triển vô cùng đa dạng dưới nhiều hình thức: video dạy học, sách điện tử, bài giảng điện tử, các ứng dụng học tập.... HLĐT giúp cho người học có thể học tập mọi lúc mọi nơi, giúp tăng tính linh hoạt và tiện lợi trong học tập; hỗ trợ học sinh có cái nhìn trực quan, tổng quát hơn về bài học. Từ đó, học sinh sẽ được tạo cảm hứng học tập, tiếp thu bài học dễ dàng hơn.

Những năm cuối của thế kỉ XX, có nhiều nghiên cứu về các phần mềm dạy học, đào tạo dựa trên công nghệ web, khóa đào tạo trực tuyến... đã được thực hiện. Một số hệ thống E-learning điển hình của các trường đại học trên thế giới như: Hệ thống E-learning của Trường Đại học Western Governors của Mĩ; Hệ thống E-learning của Đại học Glasgow của nước Anh; Học viện Khan của Mĩ... Các nghiên cứu về HLĐT trên thế giới đều khẳng định tính ưu việt của học liệu điện tử trong các hình thức dạy học từ xa với sự hỗ trợ của máy tính và mạng internet (Alenezi, 2020; Kazaine, 2017; Shi, 2010; Valley, 2011).

Tại Việt Nam, những nghiên cứu về học liệu điện tử đã xuất hiện từ khá lâu. Tác giả Trịnh Thùy Anh đã đề cập tới việc nghiên cứu xây dựng thử nghiệm mô hình kho học liệu điện tử cho trường Đại học Mở TP.HCM trong giai đoạn đầu, từ đó có hướng phát triển trong các giai đoạn tiếp theo (Trịnh Thùy Anh, 2010). Đặc biệt, trong bối cảnh chuyển đổi số cũng như thực hiện đổi mới Chương trình giáo dục phổ thông hiện nay thì vai trò của HLĐT và việc sử dụng HLĐT trong dạy học hiện nay càng trở nên vô cùng cần thiết. HLĐT hiện nay được xây dựng theo hướng là kho học liệu có nội dung lý thuyết, hình ảnh và hệ thống bài tập phong phú, bám sát nội dung chương trình giáo dục phổ thông hiện hành. Ðặc biệt, nhiều bài giảng được đầu tư, sử dụng nhiều phần mềm để thiết kế giáo án; bài giảng điện tử tương tác; các bài trình chiếu, đoạn video…. (Lê Thị Cẩm Tú, 2023; Trần Dương Quốc Hòa, 2015).

Ðối với học sinh, đây là nguồn tri thức để học sinh bổ sung thêm kiến thức chưa tiếp thu được. HS có thể tự học ở nhà thông qua việc tương tác với hệ thống HLĐT, tương tác với thầy cô, bạn bè. Ngoài các nội dung sẵn có, GV có thể tự tạo học liệu của mình hay học liệu cho các môn học, sau đó giao bài cho học sinh. Học liệu có thể là bài tập trắc nghiệm và tự luận, đề kiểm tra, video.... Phụ huynh dễ dàng kiểm tra việc học tập của con và giữ liên lạc với giáo viên, nhà trường qua kho học liệu này.

Vì vậy, xây dựng kho học liệu điện tử phù hợp, kịp thời đáp ứng việc dạy và học trong tình hình mới là nhu cầu cấp thiết hiện nay. Từ nguồn kho HLĐT, cán bộ quản lý cũng như giáo viên sẽ có nhiều nguồn tham khảo để thiết kế giáo án, tham khảo những bài giảng hay, tìm kiếm những tư liệu phù hợp với năng lực học sinh. Ðồng thời, GV sẽ tiếp cận được cách thiết kế bài học, tổ chức hoạt động dạy học để học hỏi, trao đổi kinh nghiệm nâng cao nghề nghiệp.

|<image_2>|

# KẾT QUẢ NGHIÊN CỨU

## Mục tiêu giáo dục kỹ năng sống cho học sinh phổ thông hiện nay

Giáo dục kỹ năng sống đóng vai trò vô cùng quan trọng đối với học sinh phổ thông hiện nay. Nó không chỉ trang bị cho học sinh những kiến thức và kỹ năng cần thiết để thích ứng với cuộc sống hiện đại, mà còn giúp các em phát triển toàn diện về nhân cách, phẩm chất và năng lực. Thông qua giáo dục kỹ năng sống, học sinh được hình thành các kỹ năng tư duy, kỹ năng giao tiếp, kỹ năng giải quyết vấn đề, kỹ năng làm việc nhóm,...

Đặc biệt, trong bối cảnh xã hội có nhiều biến động mạnh mẽ như hiện nay, việc trang bị cho HS những kỹ năng sống cần thiết để các em có thể thích nghi, thích ứng trong mọi hoàn cảnh là việc làm rất cần thiết bởi đây là những kỹ năng thiết yếu để học sinh có thể tự tin bước vào đời, hội nhập với xã hội và trở thành những công dân có ích. Tuy nhiên, việc giáo dục KNS trong các nhà trường còn một số hạn chế, như: đa phần là lồng ghép, tích hợp các môn học, chưa được xây dựng thành môn học riêng trong chương trình phổ thông nên việc thực hiện chưa thực sự mang lại hiệu quả. Cơ sở vật chất, thiết bị trong trường học mới chỉ đáp ứng nhu cầu giảng dạy kiến thức cho học sinh, chưa đáp ứng được hoạt động giáo dục KNS. Công tác đào tạo, bồi dưỡng tập huấn cho đội ngũ cán bộ, giảng viên dạy KNS gặp khó khăn; hình thức tổ chức KNS chưa phong phú linh hoạt, phương pháp hạn chế, chưa triển khai đồng đều ở các trường học, cấp học, kinh phí hạn chế....

## Vai trò, lợi ích và những thách thức khi sử dụng công cụ AI trong giáo dục kỹ năng sống cho học sinh phổ thông

Trong bối cảnh giáo dục hiện đại, việc ứng dụng trí tuệ nhân tạo (AI) vào việc dạy và học kỹ năng sống cho học sinh phổ thông mở ra một chân trời mới với nhiều tiềm năng to lớn. AI không chỉ hỗ trợ cá nhân hóa quá trình học tập, giúp học sinh tiếp cận kiến thức một cách phù hợp với năng lực và sở thích của mình, mà còn tạo ra những môi trường học tập tương tác, sinh động, giúp các em thực hành và rèn luyện kỹ năng sống trong các tình huống mô phỏng thực tế.

Việc ứng dụng trí tuệ nhân tạo (AI) trong giáo dục kỹ năng sống mang lại nhiều lợi ích thiết thực. Đầu tiên, AI cho phép cá nhân hóa quá trình học tập, điều chỉnh nội dung và phương pháp giảng dạy phù hợp với từng học sinh, giúp các em phát huy tối đa tiềm năng của mình. Thứ hai, AI tạo ra môi trường học tập tương tác, sinh động, kích thích sự tham gia và hứng thú của học sinh. Các chatbot và trợ lý ảo có thể mô phỏng các tình huống thực tế, giúp học sinh thực hành kỹ năng giao tiếp, giải quyết vấn đề và ra quyết định một cách an toàn và hiệu quả. Thứ ba, AI cung cấp phản hồi tức thì và khách quan, giúp học sinh nhận ra điểm mạnh, điểm yếu và điều chỉnh hành vi của mình kịp thời. Ngoài ra, AI giúp mở rộng phạm vi tiếp cận giáo dục, mang đến cơ hội học tập cho học sinh ở những vùng sâu, vùng xa, nơi mà điều kiện giáo dục còn hạn chế.

Tuy nhiên, bên cạnh những lợi ích không thể phủ nhận, việc ứng dụng AI trong giáo dục kỹ năng sống cũng đặt ra nhiều thách thức. Một trong những rào cản lớn nhất là yêu cầu về cơ sở vật chất và kỹ năng sử dụng công nghệ. Nhiều trường học, đặc biệt là ở vùng sâu, vùng xa, còn thiếu thốn thiết bị và kết nối internet. Hơn nữa, cả giáo viên và học sinh cần được trang bị kỹ năng sử dụng các công cụ AI một cách hiệu quả. Chi phí đầu tư ban đầu cho việc xây dựng và triển khai hệ thống AI cũng là một vấn đề đáng cân nhắc. Vấn đề bảo mật thông tin cá nhân của học sinh cũng cần được đặt lên hàng đầu, đảm bảo rằng dữ liệu được thu thập và lưu trữ một cách an toàn. Ngoài ra, cần tránh tình trạng học sinh quá phụ thuộc vào công nghệ, làm giảm khả năng tương tác xã hội và phát triển các kỹ năng mềm quan trọng. Cuối cùng, việc đảm bảo tính công bằng trong tiếp cận công nghệ là rất quan trọng, để mọi học sinh đều có cơ hội học tập và phát triển kỹ năng sống một cách bình đẳng.

## Đề xuất quy trình sử dụng công cụ AI thiết kế học liệu điện tử trong giáo dục kỹ năng sống cho học sinh phổ thông

### Phân tích mục tiêu bài học

GV cần xác định rõ ràng các kỹ năng sống cần giáo dục cho học sinh phổ thông (ví dụ: kỹ năng giao tiếp, kỹ năng giải quyết vấn đề, kỹ năng làm việc nhóm...) làm căn cứ để xác định mục tiêu sử dụng HLĐT cho phù hợp và hiệu quả. Các HLĐT được sử dụng nên đa dạng, hướng vào việc phát triển đa dạng các kỹ năng chung và các kỹ năng sống cụ thể trong bài học.

### Phân tích nội dung dạy học

Từ việc xác định mục tiêu bài học, GV cần xác định, phân tích nội dung bài học để lựa chọn việc sử dụng HLĐT sẽ tập trung vào nội dung nào. Chẳng hạn, khi dạy về kỹ năng giao tiếp, GV sẽ xác định các nội dung dạy học cụ thể như kỹ năng giao tiếp trực tiếp, kỹ năng giao tiếp trên mạng. Tất cả các phần này, GV đều có thể thiết kế HLĐT phục vụ cho việc dạy học, tùy vào mục tiêu bài học, GV nên lập kế hoạch, cân nhắc việc sử dụng HLĐT ở mỗi bài học sao cho cân đối giữa các nội dung trong bài và giữa các bài học.

### Lựa chọn loại HLĐT và công cụ AI phù hợp với bài học

Hiện nay, với sự hỗ trợ của các ứng dụng, phần mềm công nghệ, kết hợp với điều kiện cơ sở vật chất, trang thiết bị tương đối tốt, đầy đủ ở một số vùng, thành phố, trường học lớn, GV có thể xác định và lựa chọn rất nhiều loại HLĐT đa dạng để phục vụ cho việc dạy và học. Ví dụ, đối với bậc Tiểu học, HS ở lứa tuổi nhỏ, hiếu động nên thường hứng thú với các hình ảnh trực quan, sinh động, các học liệu mang hình thức trò chơi, kích thích sự tìm tòi, khám phá. Vì vậy, GV có thể lựa chọn một số loại HLĐT như: bài giảng điện tử, sách điện tử, phiếu học tập, video, trò chơi, phim...

GV có thể nghiên cứu và lựa chọn các công cụ AI có khả năng hỗ trợ thiết kế học liệu điện tử (ví dụ: các nền tảng tạo bài giảng tương tác, các công cụ tạo video hoạt hình, các công cụ tạo trò chơi giáo dục...). Để lựa chọn được các công cụ AI phù hợp nhất, GV có thể đánh giá các công cụ dựa trên các tiêu chí như: tính năng, dễ sử dụng, chi phí, khả năng tùy chỉnh,...

### Thiết kế các loại HLĐT trên các công cụ, ứng dụng công nghệ phù hợp

Đây là bước đòi hỏi GV cần có kỹ năng sử dụng công nghệ tốt. Trên cơ sở xác định các loại HLĐT sẽ sử dụng trong bài học, GV sẽ lập kế hoạch thiết kế HLĐT trên các ứng dụng công nghệ phù hợp. GV có thể sử dụng một số ứng dụng AI để thiết kế một số loại HLĐT phù hợp với mục tiêu và nội dung bài học giáo dục kỹ năng sống như sau:

\- **Bài giảng tương tác**: Sử dụng công cụ trình chiếu hỗ trợ AI: Các nền tảng như Gamma, Prezi, Beautiful.ai, SlidesAI.io có thể giúp tạo các bài thuyết trình hấp dẫn hơn với các tính năng như gợi ý thiết kế, tạo bố cục thông minh, và tự động tạo slide từ văn bản. Sử dụng nền tảng tạo bài giảng tương tác: Các công cụ như Nearpod, Edpuzzle cho phép giáo viên tích hợp các yếu tố tương tác như câu hỏi, thăm dò ý kiến và các hoạt động nhóm vào bài giảng, đồng thời theo dõi tiến trình của học sinh. Một số nền tảng có thể có các tính năng AI để gợi ý các loại tương tác phù hợp hoặc phân tích kết quả của học sinh.

\- **Trò chơi**: Sử dụng nền tảng tạo trò chơi học tập: Các công cụ như Kahoot!, Quizizz, Blooket cho phép tạo các trò chơi trắc nghiệm, trò chơi thẻ nhớ và các loại trò chơi khác một cách dễ dàng. Một số nền tảng có thể sử dụng AI để tạo ra các câu hỏi hoặc điều chỉnh độ khó của trò chơi dựa trên kết quả của học sinh. Sử dụng các công cụ phát triển trò chơi: Các công cụ như Unity, Unreal Engine, Scratch có thể được sử dụng để tạo ra các trò chơi giáo dục phức tạp hơn với các yếu tố mô phỏng và tương tác cao. Một số plugin và tài sản AI có thể được tích hợp để tạo ra các nhân vật AI, tạo ra các tình huống trò chơi đa dạng hơn, hoặc phân tích hành vi của người chơi.

\- **Video hoạt hình**: Sử dụng công cụ tạo video hoạt hình AI: Các nền tảng như Vyond, Powtoon, Animaker, VideoGen… có thể hỗ trợ GV tạo ra các video hoạt hình giải thích, video tình huống, hoặc video hướng dẫn về các kỹ năng sống cần thiết. Các tính năng AI có thể giúp tạo ra các nhân vật hoạt hình, tạo ra các cảnh quay hoặc tự động tạo ra lời thoại từ văn bản. Công cụ chỉnh sửa video AI: Các công cụ chỉnh sửa video như Adobe Premiere Pro, Final Cut Pro (với các plugin AI)… có thể giúp tự động hóa các tác vụ chỉnh sửa video như cắt ghép, thêm hiệu ứng hoặc tạo ra các phụ đề. AI cũng có thể được sử dụng để cải thiện chất lượng video hoặc tạo ra các hiệu ứng đặc biệt.

\- **Sử dụng Chatbot**: Tạo môi trường tương tác: Chatbot có thể tạo ra môi trường tương tác mô phỏng các tình huống thực tế, giúp học sinh luyện tập kỹ năng giao tiếp, giải quyết vấn đề, và ra quyết định. Học sinh có thể thoải mái trao đổi, đặt câu hỏi, và nhận phản hồi từ chatbot mà không cảm thấy e ngại. Cá nhân hóa việc học: Chatbot có thể thu thập dữ liệu về quá trình học tập của học sinh, từ đó điều chỉnh nội dung và phương pháp giảng dạy phù hợp với từng cá nhân. Điều này giúp học sinh tiếp thu kiến thức hiệu quả hơn và phát triển kỹ năng sống theo tốc độ riêng của mình. Hỗ trợ học tập mọi lúc mọi nơi: Chatbot hoạt động 24/7, giúp học sinh tiếp cận kiến thức và luyện tập kỹ năng sống bất cứ khi nào cần thiết, đặc biệt hữu ích cho những học sinh có lịch trình bận rộn hoặc sống ở khu vực khó tiếp cận giáo dục truyền thống. Cung cấp phản hồi tức thì: Chatbot có thể cung cấp phản hồi nhanh chóng và chính xác về các câu trả lời và hành động của học sinh, giúp học sinh nhận ra những điểm cần cải thiện và điều chỉnh hành vi của mình kịp thời. GV có thể sử dụng một số định hướng ứng dụng chatbot trong giáo dục kỹ năng sống cho HS: Luyện tập kỹ năng giao tiếp: Chatbot có thể đóng vai các nhân vật khác nhau trong các tình huống giao tiếp, giúp học sinh luyện tập cách lắng nghe, đặt câu hỏi, và diễn đạt ý kiến. Ví dụ, chatbot có thể mô phỏng một cuộc phỏng vấn xin việc, giúp học sinh luyện tập kỹ năng trả lời phỏng vấn. Giải quyết vấn đề và ra quyết định: Chatbot có thể đưa ra các tình huống giả định, yêu cầu học sinh phân tích vấn đề, đưa ra các phương án giải quyết và lựa chọn phương án tối ưu. Ví dụ, chatbot có thể đưa ra tình huống học sinh bị bắt nạt, yêu cầu học sinh đưa ra các cách giải quyết an toàn và hiệu quả. Quản lý cảm xúc: Chatbot có thể giúp học sinh nhận diện và quản lý cảm xúc của mình thông qua các bài tập và trò chơi tương tác. Ví dụ, chatbot có thể dạy học sinh các kỹ thuật thư giãn và giảm căng thẳng. Giáo dục về sức khỏe và an toàn: Chatbot có thể cung cấp thông tin về các vấn đề sức khỏe và an toàn, đồng thời hướng dẫn học sinh cách phòng tránh các nguy cơ. Ví dụ như các vấn đề về sức khỏe sinh sản, hay những nguy cơ trên mạng xã hội. GV có thể lựa chọn sử dụng một số công cụ AI tạo chatbot phổ biến hiện nay như: Dialogflow (Google), Microsoft Bot Framework, Chatfuel…

GV cần lưu ý một số điểm sau: Trong quá trình sử dụng công cụ AI, cần đảm bảo tính sư phạm của học liệu điện tử, tránh lạm dụng công nghệ mà bỏ qua các yếu tố giáo dục. Cần có sự phối hợp chặt chẽ giữa giáo viên, nhà trường và các chuyên gia công nghệ để đảm bảo hiệu quả của việc ứng dụng AI trong giáo dục kỹ năng sống.

### Thực nghiệm học liệu

Vì là sản phẩm công nghệ nên sau khi hoàn thành thiết kế, GV cần có thời gian thử nghiệm học liệu và đánh giá tính khả thi, hiệu quả của các HLĐT đã thiết kế. GV có thể sử dụng các phương pháp đánh giá như cho HS sử dụng thử HLĐT để kiểm tra các tính năng của học liệu có được vận hành tốt không, khảo sát phản hồi từ học sinh hoặc theo dõi kết quả học tập của học sinh để đánh giá hiệu quả của HLĐT trong quá trình sử dụng.

# KẾT LUẬN

Việc sử dụng các công cụ trí tuệ nhân tạo (AI) để thiết kế học liệu điện tử trong dạy học kỹ năng sống cho học sinh phổ thông mở ra một hướng đi đầy tiềm năng. AI giúp cá nhân hóa quá trình học tập, tạo môi trường tương tác sinh động, cung cấp phản hồi tức thì và mở rộng phạm vi tiếp cận giáo dục. Tuy nhiên, để hiện thực hóa những lợi ích này, chúng ta cần vượt qua những thách thức về cơ sở vật chất, kỹ năng công nghệ, bảo mật thông tin… Trong tương lai, việc nghiên cứu và phát triển các ứng dụng AI trong giáo dục kỹ năng sống cần được đẩy mạnh, đồng thời chú trọng đào tạo đội ngũ giáo viên có đủ năng lực sử dụng công nghệ. Bên cạnh đó, cần có sự phối hợp chặt chẽ giữa các nhà quản lý giáo dục, các nhà nghiên cứu và các nhà phát triển công nghệ để xây dựng một hệ sinh thái giáo dục AI hiệu quả và bền vững. Việc ứng dụng AI một cách sáng tạo và có trách nhiệm sẽ góp phần quan trọng vào việc nâng cao chất lượng giáo dục kỹ năng sống, giúp học sinh phát triển toàn diện và trở thành những công dân có ích cho xã hội.

# Public_199

# Tóm tắt

Máy tính lượng tử - một lĩnh vực còn rất mới và là loại máy tính chưa được sử dụng phổ biến. Bài báo này trình bày tổng quan về máy tính lượng tử và đánh giá các nghiên cứu từ khi ra đời cho đến nay bao gồm: sự ra đời, tiến trình phát triển đến những vấn đề đặt ra về triển vọng, tầm nhìn, thách thức và cơ hội. Đồng thời cũng giải thích sức mạnh của máy tính lượng tử thông qua công nghệ tính toán lượng tử dựa trên các nguyên lý của cơ học lượng tử, chẳng hạn như siêu đặc tính lượng tử, sự liên kết lượng tử, hoặc định lý không thể sao chép. Phương pháp được sử dụng trong nghiên cứu này phân tích, tổng hợp và so sánh thông tin để đánh giá và đưa ra những kết luận và nhận xét có giá trị. Bài báo hữu ích cho những người mới bắt đầu nghiên cứu về máy tính lượng tử, giúp họ có được cái nhìn tổng quan về lĩnh vực máy tính lượng tử và định hướng cho công việc nghiên cứu của họ. Nó cũng có thể giúp các nhà quản lý, chính phủ và các tổ chức khác trong việc đưa ra các quyết định và chính sách liên quan đến nền tảng máy tính lượng tử.

# Giới thiệu 

Máy tính lượng tử (MTLT) là một loại máy tính mới, được thiết kế để thực hiện các tính toán sử dụng nguyên tử và phân tử [1] – [7], thay vì sử dụng các mạch điện tử như máy tính truyền thống (MTTT). Điều này cho phép MTLT xử lý thông tin với tốc độ rất nhanh và độ chính xác cao hơn so với máy tính cổ điển [8] – [15]. Một sự khác biệt lớn giữa MTLT tử và MTTT là cách thực hiện tính toán. MTLT sử dụng các qubit (đơn vị thông tin lượng tử) để thực hiện tính toán, trong khi MTTT sử dụng các bit nhị phân thông thường [16] – [22]. Các qubit có thể tồn tại ở nhiều trạng thái khác nhau cùng một lúc, cho phép MTLT thực hiện nhiều tính toán đồng thời, trong khi MTTT chỉ có thể thực hiện một tính toán tại một thời điểm. Một số ứng dụng tiềm năng của MTLT bao gồm việc giải quyết các bài toán phức tạp trong lĩnh vực vật lý, hóa học, sinh học, tài chính và thương mại điện tử [1] – [7], [22] – [30]. Ví dụ, MTLT có thể được sử dụng để thiết kế các vật liệu mới với tính chất đặc biệt [6], giải quyết các bài toán về tối ưu hóa đầu tư tài chính [4], [25], [27], [29], hoặc giúp tạo ra các sản phẩm mới trong thương mại điện tử [1], [27]. MTLT cũng có thể được sử dụng để mô phỏng các hiện tượng vật lý phức tạp [1], [2], [16], [28], giúp các nhà khoa học hiểu rõ hơn về vũ trụ và các hiện tượng vật lý khác. Tuy nhiên, việc phát triển MTLT vẫn còn rất mới và đang gặp nhiều thách thức, bao gồm việc xử lý các lỗi lượng tử [4], [20], tăng cường độ tin cậy và độ chính xác của MTLT [31] – [35], và tạo ra các thiết bị lượng tử phù hợp với các ứng dụng thực tế [4], [5], [35]. Bài báo này cung cấp một cái nhìn tổng quan về tình hình phát triển của công nghệ MTLT trên thế giới, từ khi xuất hiện cho đến hiện tại. Bài báo cũng giải thích về khái niệm MTLT, sự khác biệt giữa MTLT và máy tính cổ điển, những tiềm năng và thách thức của công nghệ này. Đồng thời, bài báo cũng đề cập đến các dự án nghiên cứu hiện tại và tương lai về MTLT, các phương pháp mới trong việc thiết kế, phát triển và sử dụng MTLT, cũng như những tiến bộ đáng chú ý trong lĩnh vực này nhằm giúp độc giả hiểu rõ hơn về công nghệ MTLT và ứng dụng của nó trong các lĩnh vực khác nhau.

# Phương pháp nghiên cứu 

MTLT là một lĩnh vực khoa học còn rất mới trên thế giới và ở Việt Nam. Hiện tại MTLT chưa được sử dụng phổ biến mới chỉ được nghiên cứu và sử dụng trong các phòng thí nghiệm của các tập đoàn lớn trên thế giới. Vì vậy trong bài báo tổng quan này chúng tôi sử dụng các phương pháp nghiên cứu chủ yếu sau: Phân tích tài liệu: Phương pháp này bao gồm đánh giá các tài liệu trước đây đã được xuất bản về chủ đề MTLT đang đề cập. Việc này giúp đánh giá tình hình nghiên cứu hiện tại, những câu hỏi còn đang mơ hồ và những vấn đề chưa được giải quyết trong lĩnh vực này. Phân tích nội dung: Phương pháp này giúp đánh giá các tài liệu trước đây để phát hiện ra các vấn đề, xu hướng chính trong lĩnh vực MTLT. Phân tích hệ thống: đây là bài báo tổng quan đang đề cập đến một lĩnh vực phức tạp, phương pháp phân tích hệ thống được sử dụng để đưa ra cái nhìn toàn diện về các mối quan hệ giữa các yếu tố khác nhau trong lĩnh vực

# Kết quả nghiên cứu và bài luận 

## Lịch sử và tiến trình phát triển của MTLT 

### Sự ra đời của máy tính lượng tử 

MTLT là một trong những công nghệ tiên tiến nhất của thế kỷ 21. Tuy nhiên, ý tưởng về MTLT đã xuất hiện từ rất sớm, vào những năm đầu của thế kỷ 20. Những năm đầu 1900, nhà toán học người Đức Max Planck đưa ra định luật bức xạ, trong đó ông giới thiệu khái niệm "hạt" TNU Journal of Science and Technology 228(07): 108 - 118 http://jst.tnu.edu.vn 110 Email: jst@tnu.edu.vn của ánh sáng [1], [4], [5]. Điều này đánh dấu sự khởi đầu của lý thuyết về cơ học lượng tử. Sau đó, các nhà khoa học khác như Albert Einstein, Niels Bohr, Werner Heisenberg và Erwin Schrödinger đã phát triển các khái niệm và công thức toán học để mô tả cơ học lượng tử [21], [22], [24]. Trong những năm 1980, Richard Feynman đã đề xuất ý tưởng về MTLT trong bài phát biểu tại “Hội nghị Vật lý Công nghệ và Giới hạn của nó” tại MIT [1], [4]. Tuy nhiên, đến tận năm 1994, Peter Shor đã công bố một giải thuật giải mã số nguyên tố bằng MTLT [4], [28], chứng tỏ rằng MTLT có thể giải quyết các bài toán phức tạp mà MTTT không thể. Kể từ đó, nhiều nhà khoa học và các công ty công nghệ hàng đầu trên thế giới đã bắt đầu đầu tư nghiên cứu và phát triển MTLT. Trong vài thập kỷ qua, MTLT đã được phát triển nhanh chóng và trở thành một trong những công nghệ tiên tiến nhất hiện nay, các nhà nghiên cứu đang tiếp tục nghiên cứu và phát triển các thiết bị, công nghệ liên quan đến MTLT, với mục tiêu tạo ra các MTLT hoàn hảo hơn, có khả năng giải quyết các bài toán phức tạp hơn nữa.

### Tiến trình phát triển của MTLT 

Trong quá trình phát triển MTLT, đã có nhiều thành tựu đáng chú ý đã đạt được. Dưới đây là một số ví dụ:  Thiết bị đầu tiên sử dụng nguyên lý lượng tử: MTLT đầu tiên được giới thiệu vào năm 1982 bởi Richard Feynman và Paul Benioff [1], [5], [6]. Thiết bị này sử dụng nguyên lý của lượng tử để thực hiện các phép tính.  Cổng cơ bản của MTLT: Cổng Hadamard, được giới thiệu vào năm 1995 bởi Peter Shor và Leonard Grover [1], [4], là một cổng cơ bản của MTLT. Nó cho phép chuyển đổi trạng thái của một qubit từ trạng thái cơ bản sang trạng thái siêu dẫn.  Thuật toán Shor: Thuật toán Shor, được giới thiệu vào năm 1994 bởi Peter Shor, là một thuật toán quan trọng trong MTLT. Nó có thể giải quyết bài toán phân tích số nguyên tố nhanh hơn các thuật toán truyền thống [1].  Thiết bị lưu trữ thông tin lượng tử: Thiết bị lưu trữ thông tin lượng tử (quantum memory) cho phép lưu trữ thông tin ở dạng lượng tử trong thời gian dài hơn [3], [8]. Điều này rất quan trọng để tạo ra MTLT thực tế.  Sự phát triển của MTLT hiện đại: MTLT hiện đại nhất hiện nay là Google's Sycamore [5], có khả năng tính toán vượt trội so với MTTT. Đây là một bước tiến lớn trong lĩnh vực MTLT và mở ra nhiều triển vọng trong việc ứng dụng của nó. Những thành tựu đó đã đánh dấu một bước tiến lớn trong lĩnh vực MTLT, mở ra nhiều triển vọng và cơ hội cho việc phát triển và ứng dụng trong tương lai.

|<image_1>|

### Các thành tựu đáng chú ý của các công ty và tập đoàn 

Một trong những thành tựu đáng chú ý nhất của MTLT là quá trình đạt được quantum supremacy, tức là khả năng của MTLT vượt trội hơn so với MTTT trong một nhiệm vụ cụ thể [6], [9]. Thành tựu đầu tiên trong lĩnh vực này thuộc về Google vào năm 2019, khi họ đã sử dụng một MTLT 54 qubit để giải một bài toán phức tạp trong thời gian ngắn hơn so với MTTT [5]. Tuy nhiên, có những tranh cãi xung quanh việc xác định rõ ràng của khái niệm quantum supremacy [10], [11], [28]. IBM cũng đã đạt được quantum supremacy vào năm 2020 với một MTLT 65 qubit [11]. Công ty này đã sử dụng máy tính của mình để giải một bài toán liên quan đến phân tích ngôn ngữ tự nhiên với độ chính xác cao hơn so với các giải pháp truyền thống. Ngoài Google và IBM, nhiều công ty và tổ chức khác cũng đang nỗ lực để đạt được quantum supremacy và phát triển những ứng dụng thực tiễn của MTLT. Ví dụ, vào năm 2020, Honeywell đã công bố một MTLT 6 qubit với độ chính xác cao hơn so với các MTLT cùng cấp độ. Còn Alibaba và Microsoft đang phát triển các MTLT với số lượng qubit lớn hơn [12]. Các thành tựu trên đang mở ra một tương lai rực rỡ cho lĩnh vực MTLT và nhiều ứng dụng mới có thể được tạo ra trong tương lai gần.

|<image_2>|

## Nguyên lý hoạt động của MTLT 

### Các nguyên tắc hoạt động của MTLT 

MTLT hoạt động dựa trên một số nguyên tắc vật lý cơ bản, bao gồm nguyên lý siêu dẫn, nguyên lý bù trừ và nguyên lý siêu vị nhân [14] – [16]. Nguyên lý siêu dẫn (superconductivity) là nguyên tắc vật lý mô tả sự dẫn điện hoàn toàn của vật liệu khi được làm lạnh đến một nhiệt độ rất thấp. Điều này cho phép các dòng điện chạy qua vật liệu mà không gặp phải sự trở kháng. Nguyên tắc này được sử dụng trong các quantum bit (qubit) của MTLT để giữ trạng thái của qubit với độ chính xác cao. Nguyên lý bù trừ (quantum entanglement) là nguyên tắc vật lý mô tả sự liên kết giữa các hạt với nhau, dù chúng có thể ở cách xa nhau đến hàng trăm nghìn kilômét. Khi hai qubit liên kết với nhau thông qua nguyên tắc này, thì sự thay đổi của một qubit sẽ ảnh hưởng đến trạng thái của qubit kia, bất kể khoảng cách giữa hai qubit đó. Nguyên lý siêu vị nhân (quantum tunneling) là nguyên tắc vật lý mô tả sự xuyên qua của các hạt qua một vật liệu mà không gặp sự trở kháng. Điều này cho phép qubit có khả năng chuyển trạng thái một cách rất nhanh chóng, mà không cần mất thời gian để vượt qua các vật liệu giữa. Các nguyên tắc này tạo nên cơ sở cho sự hoạt động của MTLT, giúp nó có thể giải quyết các bài toán phức tạp một cách nhanh chóng hơn so với MTTT.

### Thành phần cấu tạo của MTLT 

MTLT được tạo ra để thực hiện tính toán bằng cách sử dụng các phép toán trên các trạng thái lượng tử. Các thành phần cấu tạo của MTLT bao gồm qubit, quantum gate và quantum register [1], [6], [16], [19], [20], [22].

|<image_3>|

Qubit: Qubit (quantum bit) là đơn vị cơ bản của MTLT và tương đương với bit trong máy tính cổ điển. Tuy nhiên, qubit không chỉ mang giá trị 0 hoặc 1 như bit nhị phân, mà có thể tồn tại trong một trạng thái siêu dẫn của 0 và 1 đồng thời (superposition) (xem minh họa trên hình 1). Điều này cho phép qubit thực hiện các tính toán đồng thời trên nhiều giá trị hơn là một giá trị duy nhất như trên máy tính cổ điển.

|<image_4>|

Quantum gate: là các phép toán được sử dụng để thực hiện các tính toán trên qubit. Hình 2 mô tả tên các phép toán lượng tử tương ứng với các quantum gate và ma trận toán học tương ứng. Các quantum gate có thể được sử dụng để biến đổi trạng thái của qubit hoặc để tạo ra sự tương tác giữa các qubit. Các quantum gate phổ biến bao gồm X-gate, Y-gate, Z-gate, Hadamard gate, CNOT gate, SWAP gate, Toffoli gate và một số các cổng khác.

Quantum register: là tập hợp các qubit được sử dụng để lưu trữ và thực hiện các tính toán. Quantum register có thể có từ một đến hàng trăm qubit, tùy thuộc vào ứng dụng cụ thể. Các thành phần này cùng hoạt động để tạo ra sức mạnh tính toán của MTLT. Khi các qubit được kết hợp với các quantum gate và được tổ chức trong quantum register, các tính toán lượng tử phức tạp có thể được thực hiện. Ngoài các thành phần khác biệt như trình bày trên của MTLTT, các thành phần cấu tạo cơ bản khác của một hệ thống tính toán được giới thiệu và minh họa trong [36] (xem hình 3).

|<image_5>|

**3.2.3.** So sánh giữa MTLT và MTTT

MTLT và MTTT đều là những công cụ để xử lý thông tin, tuy nhiên chúng khác nhau về cách thức hoạt động và cách tiếp cận vấn đề.

Bảng 1 trình bày sự khác nhau theo một số cách tiếp cận chính tạo ra sự khác biệt vượt trội như: cách biểu diễn thông tin, thao tác lưu trữ, phương pháp giải quyết bài toán.

Tóm lại, MTLT và MTTT đều có sức mạnh và hạn chế riêng, có thể được sử dụng để giải quyết các bài toán khác nhau. Tuy nhiên, vì tính đặc biệt của MTLT, nó có thể giải quyết các bài toán phức tạp và lớn hơn nhiều so với MTTT. Song việc phát triển và sử dụng MTLT vẫn còn rất khó khăn và đòi hỏi sự đầu tư lớn về kỹ thuật và tài chính. Hiện nay, MTLT được sử dụng trong nhiều lĩnh vực như tài chính, y học, và khoa học vật lý. Với sự phát triển của công nghệ, các ứng dụng của MTLT dự kiến sẽ tiếp tục mở rộng và đóng góp vào sự phát triển của nhiều lĩnh vực khác nhau.

## Ứng dụng của MTLT 

### Ứng dụng trong khoa học 

MTLT có tiềm năng để thực hiện các phép tính phức tạp hơn rất nhiều so với máy tính cổ điển, và điều này đã mở ra nhiều cánh cửa cho các ứng dụng mới trong nhiều lĩnh vực khoa học. Sau đây là một số ví dụ về ứng dụng của MTLT:

Nghiên cứu vật lý: MTLT có thể được sử dụng để mô phỏng các hiện tượng vật lý phức tạp, như quá trình tương tác giữa các hạt cơ bản trong vật chất [1], [14]. Nó có thể giúp các nhà khoa học hiểu sâu hơn về các hiện tượng vật lý phức tạp và phát triển các vật liệu mới.

Nghiên cứu hóa học: MTLT có thể giúp các nhà hóa học tìm ra các phân tử và chất mới với tính chất đặc biệt, bao gồm cả các vật liệu siêu dẫn và phân tử dược phẩm. Nó có thể mô phỏng các phản ứng hóa học và giúp đưa ra dự đoán về tính chất của các chất mới [13], [21], [22].  Nghiên cứu sinh học: MTLT có thể giúp giải mã các cấu trúc phức tạp của các phân tử sinh học, như protein và DNA, và dự đoán cách chúng tương tác với các phân tử khác [12]. Nó có thể giúp giải quyết các vấn đề liên quan đến thiết kế các phân tử dược phẩm, chẩn đoán bệnh và phát triển các phương pháp điều trị mới [14].

Nghiên cứu khoa học vũ trụ: MTLT có thể được sử dụng để mô phỏng các hiện tượng vũ trụ phức tạp, như tạo hình của các hành tinh và vũ trụ trong quá trình hình thành. Nó cũng có thể giúp giải quyết các vấn đề liên quan đến việc tìm kiếm sự sống ở ngoài Trái Đất [1], [6]. Tuy nhiên, việc sử dụng MTLT để giải quyết các bài toán thực tế vẫn còn rất mới và đang tiếp tục được nhiều nhà khoa học nghiên cứu.

### Ứng dụng trong kinh doanh 

MTLT là công nghệ tiên tiến có thể mang lại lợi ích lớn cho lĩnh vực kinh doanh. Dưới đây là một số ứng dụng của MTLT trong lĩnh vực này:

Bảo mật thông tin: MTLT có khả năng xử lý các thuật toán mã hóa bảo mật thông tin nhanh hơn so với máy tính cổ điển. Vì vậy, các công ty tài chính và các tổ chức đòi hỏi tính bảo mật cao như ngân hàng, chính phủ, quân đội đã sử dụng MTLT để bảo vệ thông tin của mình. Các thuật toán như thuật toán Shor có thể phá vỡ các thuật toán mã hóa bảo mật thông tin phổ biến như RSA và ECC. Tuy nhiên, các thuật toán mã hóa dựa trên nguyên lý của MTLT như Quantum Key Distribution (QKD) có thể được sử dụng để bảo mật thông tin một cách an toàn [1], [6], [25], [27], [29].

Tối ưu hóa tài chính: MTLT có khả năng tính toán nhanh hơn và hiệu quả hơn so với máy tính cổ điển. Vì vậy, nó có thể được sử dụng để giải quyết các vấn đề tối ưu hóa trong lĩnh vực tài chính, bao gồm tối ưu hóa danh mục đầu tư, phân bổ tài sản và quản lý rủi ro [11], [13], [14], [34], [35]. Các công ty tài chính lớn như JPMorgan Chase, Goldman Sachs, và Barclays đang sử dụng MTLT để cải thiện hoạt động của họ.

Phân tích dữ liệu: MTLT có khả năng xử lý các thuật toán phân tích dữ liệu lớn nhanh hơn và hiệu quả hơn so với MTTT [14], [18]. Vì vậy, nó có thể được sử dụng để phát hiện các mô hình và xu hướng trong dữ liệu, giúp các doanh nghiệp đưa ra quyết định dựa trên những thông tin chính xác hơn.

Dự đoán thị trường: là một trong những ứng dụng tiềm năng của MTLT trong lĩnh vực kinh doanh [31] – [35]. Các nhà đầu tư có thể sử dụng MTLT để phân tích dữ liệu từ thị trường tài chính và dự đoán giá cổ phiếu, ngoại tệ, hàng hóa và các loại tài sản khác. MTLT có thể giúp tăng độ chính xác và tốc độ của việc dự đoán thị trường, đồng thời giảm thiểu rủi ro và tổn thất [14]. Một trong những ứng dụng tiêu biểu của MTLT trong dự đoán thị trường là giải phương trình Black-Scholes, được sử dụng để định giá các tùy chọn tài chính. Giải phương trình này trên MTLT có thể giúp tăng độ chính xác và tốc độ tính toán, giúp các nhà đầu tư đưa ra quyết định đúng đắn về đầu tư tài chính [13]. Một số công ty đã bắt đầu sử dụng MTLT để phân tích dữ liệu và dự đoán thị trường, bao gồm JP Morgan, Goldman Sachs và Morgan Stanley [11]. Tuy nhiên, việc sử dụng MTLT trong dự đoán thị trường vẫn đang ở giai đoạn đầu, cần có thêm nhiều nghiên cứu và phát triển để phát huy tối đa tiềm năng của công nghệ này.

### Ứng dụng trong chính phủ và quân đội 

MTLT đang trở thành một công cụ quan trọng trong chính phủ và quân đội với các ứng dụng rộng rãi, từ mã hóa thông tin cho đến phát hiện gián điệp và dự báo khủng bố. Dưới đây là một số ứng dụng của MTLT trong lĩnh vực này:

Mã hóa thông tin: MTLT có thể được sử dụng để tạo ra các mã khóa mạnh hơn và an toàn hơn cho việc bảo vệ thông tin nhạy cảm [15]. Các giải thuật mã hóa dựa trên nguyên tắc của lý thuyết thông tin lượng tử có thể giúp bảo vệ thông tin khỏi các cuộc tấn công bằng cách sử dụng các thuật toán phức tạp hơn so với các giải thuật mã hóa truyền thống.

Phát hiện gián điệp: MTLT cũng có thể được sử dụng để phát hiện gián điệp trong các mạng liên lạc và hệ thống máy tính của chính phủ và quân đội [13]. Các giải thuật dựa trên thông tin lượng tử có thể giúp phát hiện các cuộc tấn công từ gián điệp một cách hiệu quả hơn.

Dự báo khủng bố: MTLT có thể được sử dụng để dự báo các hoạt động khủng bố và xác định các mối đe dọa tiềm tàng [14]. Bằng cách sử dụng MTLT, các nhà nghiên cứu có thể phân tích các dữ liệu phức tạp một cách nhanh chóng và chính xác, đưa ra các kịch bản và dự đoán về các hoạt động khủng bố trong tương lai. Các quyết định về việc triển khai các biện pháp phòng ngừa và đối phó cũng có thể được đưa ra dựa trên các dữ liệu và dự báo này.

Nghiên cứu vũ khí mới: MTLT có thể giúp giảm thời gian và chi phí để nghiên cứu và phát triển các vũ khí mới [12], [13]. Các giải thuật MTLT có thể được sử dụng để mô phỏng các phản ứng hạt nhân và các hiện tượng vật lý phức tạp khác, giúp các nhà nghiên cứu có thể đưa ra các kết quả nhanh hơn và chính xác hơn.

## Thách thức, cơ hội, tầm nhìn của MTLT 

### Thách thức của MTLT 

MTLT đã đạt được nhiều thành tựu trong những năm gần đây và tiềm năng của nó là vô tận. Tuy nhiên, vẫn còn nhiều thách thức cần được giải quyết để đưa MTLT trở thành một công nghệ quan trọng trong tương lai. Một trong những thách thức lớn nhất của MTLT là độ ổn định của qubit [12], [14], [30], [32]. Qubit rất nhạy cảm với các tác động bên ngoài như tia X, nhiệt độ và tương tác với các qubit khác, dẫn đến sự mất mát và lỗi tính toán. Điều này đặt ra một thách thức lớn trong việc thiết kế và xây dựng các thiết bị MTLT. Ngoài ra, độ chính xác của kết quả tính toán cũng là một thách thức đáng kể. Mặc dù MTLT có thể giải quyết các bài toán phức tạp nhanh hơn so với máy tính cổ điển, nhưng kết quả tính toán của nó có thể không chính xác 100%. Điều này đặc biệt quan trọng đối với các ứng dụng trong lĩnh vực tài chính và khoa học vật liệu, nơi độ chính xác là yếu tố quan trọng để đưa ra quyết định chính xác [13], [14]. Cuối cùng, khả năng mở rộng của hệ thống cũng là một thách thức. Hiện tại, MTLT chỉ có thể giải quyết một số bài toán nhất định vì số lượng qubit và quá trình đồng bộ hóa giữa chúng có giới hạn [6], [14], [34]. Để mở rộng khả năng giải quyết của MTLT, các nhà khoa học đang nghiên cứu các cách thức để kết hợp các hệ thống MTLT với nhau và tăng số lượng qubit. MTLT đang đối mặt với nhiều thách thức trong quá trình phát triển và vẫn còn nhiều công việc cần được thực hiện để đưa nó trở thành một công nghệ thực sự phát triển và mở rộng. Tuy nhiên, với tiềm năng vô tận của nó, các nhà khoa học vẫn đang nỗ lực để giải quyết các thách thức này để đưa MTLT trở thành một công cụ phổ biến trong các lĩnh vực khác nhau, từ khoa học cơ bản đến ứng dụng thực tiễn.

### Cơ hội của MTLT 

MTLT là một công nghệ đang được nghiên cứu rất nhiều trong những năm gần đây. Nó có tiềm năng rất lớn để thay đổi thế giới của chúng ta và mang lại những cơ hội đáng kể. Dưới đây là một số ví dụ về cơ hội mà MTLT có thể mang lại:

Tăng tốc các phát minh khoa học: MTLT có thể giúp tăng tốc quá trình nghiên cứu và phát triển các phát minh khoa học. Ví dụ, trong lĩnh vực vật lý, MTLT có thể giúp mô phỏng các hiện tượng tự nhiên phức tạp hơn và giải quyết các bài toán mà các MTTT không thể giải quyết được [1], [13], [33] – [35].

Cải thiện hiệu quả tài chính: MTLT có thể giúp cải thiện hiệu quả tài chính bằng cách giúp tối ưu hóa các quyết định đầu tư và quản lý rủi ro tài chính. Ví dụ, MTLT có thể giúp tính toán mô hình giá tài sản phức tạp và giúp các nhà đầu tư đưa ra quyết định đầu tư chính xác hơn [1], [14], [25] – [29].  Giải quyết các vấn đề khó khăn trong thế giới thực: MTLT có thể giúp giải quyết các vấn đề khó khăn trong thế giới thực, bao gồm nghiên cứu về sự đa dạng sinh học, phát hiện các tác nhân gây bệnh, tối ưu hóa lộ trình giao thông và quản lý nguồn nước. Ví dụ, MTLT có thể giúp phân tích dữ liệu gen để tìm ra các phương pháp điều trị bệnh ung thư hiệu quả hơn [1], [4], [6]. Như vậy, MTLT là một công nghệ đầy tiềm năng và có thể mang lại nhiều cơ hội cho hầu hết các lĩnh vực trong tương lai. Tuy nhiên, vẫn còn rất nhiều thách thức cần phải vượt qua để đạt được những tiến bộ đáng kể và tận dụng được toàn bộ tiềm năng của công nghệ này.

### Tầm nhìn 

MTLT đang trên đà phát triển mạnh mẽ và trong tương lai, có tiềm năng lớn để đưa công nghệ tính toán lên một bước phát triển mới [31] – [35]. Chúng ta có thể mong đợi các thiết bị lượng tử có độ chính xác và độ mở rộng cao hơn, cho phép xử lý các bài toán phức tạp hơn và đưa ra dự đoán chính xác hơn trong nhiều lĩnh vực khác nhau. Điều quan trọng là việc nghiên cứu và phát triển MTLT sẽ đóng vai trò quan trọng trong tương lai của khoa học và công nghệ [33] – [34]. Nó có thể giúp chúng ta giải quyết các bài toán khoa học và kỹ thuật khó khăn hơn, từ nghiên cứu vật lý và hóa học đến tối ưu hóa tài chính và dự đoán thị trường. Ngoài ra, MTLT còn có thể được sử dụng để tăng tốc quá trình phát minh và phát triển sản phẩm mới, từ thuốc chữa bệnh đến các vật liệu tiên tiến. Bằng cách sử dụng MTLT để mô phỏng các quá trình vật lý và hóa học, chúng ta có thể tìm ra các giải pháp tối ưu và giảm thiểu thời gian và chi phí cho các quá trình thử nghiệm. MTLT có tiềm năng lớn để đưa khoa học và công nghệ lên một tầm mới. Sự phát triển và tiến bộ trong lĩnh vực này sẽ đóng góp rất lớn cho việc giải quyết các vấn đề khó khăn trong thế giới thực và đưa ra những giải pháp mới cho những thách thức lớn của xã hội.

# Kết luận 

Trong bài báo này, chúng tôi đã cung cấp một cái nhìn tổng quan về MTLT bao gồm: lịch sử, nguyên lý hoạt động, cấu tạo, ứng dụng và thách thức. MTLT là một lĩnh vực đầy tiềm năng và đang phát triển rất nhanh chóng, với nhiều ứng dụng tiềm năng trong khoa học, kinh doanh và quân sự, v.v. Tuy nhiên, còn rất nhiều thách thức cần phải được giải quyết để đưa MTLT vào ứng dụng thực tế một cách hiệu quả.

# Public_200

TÓM TẮT: 

Bài viết tổng quan cơ sở lý thuyết về nguồn gốc ra đời, các khái niệm về trí tuệ nhân tạo, việc vận dụng trí tuệ nhân tạo trong công tác kế toán, kiểm toán tại các công ty trên thế giới. Từ đó, doanh nghiệp thấy được tầm quan trọng ttong việc ứng dụng trí tuệ nhân tạo vào công tác kế toán, kiểm toán. Từ khóa: trí tuệ nhân tạo, kế toán, kiểm toán, cách mạng công nghiệp 4.0.

# Đặt vân đề 

Cách mạng công nghiệp 4.0 đã mang đến nhiều cơ hội và thách thức mới trong công tác kế toán, kiểm toán hiện nay. Việc đáp ứng những yêu cầu đổi mới theo xu hướng hiện đại, như việc áp dụng kế toán máy, công nghệ điện toán đám mây, công nghệ kỹ thuật số,... đòi hỏi người làm nghề kế toán, kiểm toán phải am hiểu về công nghệ, sử dụng thành thạo công nghệ trong thực hành công việc của mình. Trong đó, công nghệ kỹ thuật số như trí tuệ nhân tạo (artificial intelligence - AI) sẽ giúp công tác kế toán, kiểm toán được thuận lợi hơn, nhanh hơn, chuyên nghiệp hơn, nhưng cũng mang nhiều thách thức hơn - được xem như là một hướng đi mới ưong cuộc cách mạng công nghiệp 4.0.

|<image_1>|

# Cơ sở lý thuyết 

## Cách mạng 4.0 và nguồn gốc ra đời của trí tuệ nhân tạo 

Cách mạng công nghiệp 4.0 (hay cách mạng công nghiệp lần thứ tư) là sự ra đời của một loạt các công nghệ mới, kết hợp tất cả các kiến thức trong lĩnh vực vật lý, kỹ thuật số, sinh học và ảnh hưởng đến tất cả các lĩnh vực, nền kinh tế, các ngành kinh tế và ngành công nghiệp. Trung tâm của cuộc cách mạng này đang nổi lên những đột phá công nghệ trong các lĩnh vực như trí tuệ nhân tạo (AI), robot, Internet vạn vật (loT), công nghệ sinh học, xe tự lái, công nghệ in 3D và công nghệ nano. Trong đó, AI là một trong những yếu tô' cốt lõi của kỹ thuật sôi Cuộc cách mạng công nghiệp 4.0 (Industrie 4.0) phát triển trên nền tảng của 3 cuộc cách mạng trước đó và được các nhà khoa học nhận định sẽ làm thay đổi các mô hình doanh nghiệp. Tuy nhiên, nguồn gốc của AI có từ năm 1956 và liên quan đến Hội nghị trí tuệ nhân tạo Dartmouth, nơi thuật ngữ “trí tuệ nhân tạo” được sử dụng lần đầu tiên. John McCarthy, Marvin Minsky, Claude Shannon và Nathaniel Rochester đã khởi xướng một nghiên cứu về trí tuệ nhân tạo dựa trên giả định rằng “mọi khía cạnh của học tập hoặc bất kỳ tính năng nào khác của trí thông minh về nguyên tắc có thể được mô tả chính xác đến mức có thể tạo ra một cỗ máy để mô phỏng nó” [18], Một bước quan trọng khác trong phát triển, đó là IA được xem là các thuật toán hoạt động trên cơ sở mạng nơ-ron nhân tạo [13], Phương pháp này đã giúp cho việc kết hợp trí tuệ nhân tạo không chỉ áp dụng vào các công ty như một phần của quá trình ra quyết định mà còn vào vô số hoạt động hàng ngày của các cá nhân, trong đó có lĩnh vực kế toán, kiểm toán. Lịch sử của các ứng dụng AI trong lĩnh vực kế toán có thể bắt nguồn từ những năm 1980 [7]. Một nghiên cứu sâu rộng đã được thực hiện bởi các học giả và các nhà thực hành về ứng dụng AI trong kiểm toán, thuế, kê toán tài chính, kế toán quản trị và lập kế hoạch tài chính cá nhân. Việc phát triển và sử dụng các hệ thống chuyên gia (ES - expert systems) trong lĩnh vực kế toán có lẽ là lĩnh vực được nghiên cứu nhiều nhất. Những đột phá công nghệ gần đây trong AI đang mở ra một trang mới trong kỷ luật kế toán, tập trung nghiên cứu từ các ứng dụng ESs sang một số quan điểm mới đốì với những người hành nghề kế toán: làm thế nào kế toán có thể hưởng lợi từ việc sử dụng các khả năng của AI, tầm nhìn dài hạn cho AI và kế toán, AI sẽ thay đổi vai trò kếtoán trong tổ chức như thế nào [8].

|<image_2>|

### Công nghệ trí tuệ nhân tạo trong kế toán, kiểm toán 

AI trong kiểm toán và kế toán thường được triển khai thông qua 1 trong 4 loại công nghệ AI [20], bao gồm: Các thuật toán/lập trình di truyền, được sử dụng chủ yếu để dự đoán phá sản hoặc các nhiệm vụ kiểm toán tương tự, giảm rủi ro liên quan đến các mô hình rủi ro phá sản truyền thống, chỉ hoạt động theo các mô hình giả định nhát định [16]. Tuy nhiên, các thuật toán có thể được sử dụng theo nghĩa rộng hơn, đảm bảo việc đánh giá của kiểm toán viên và trong các điều kiện hạn chế về thời gian và nguồn lực [9]. Logic mờ (Fuzzy logic), ưu điểm của nó là khả năng tính toán rõ ràng các yếu tố định tính. Theo logic truyền thống (ưaditional logic), một biểu thức logic chỉ nhận 1 trong 2 giá trị: True hoặc False. Khác với lý thuyết logic truyền thông, một biểu thức logic mờ có thể nhận một trong vô sô' giá trị nằm trong khoảng sô' thực từ 0 đến 1. Nói cách khác, trong logic truyền thông, một sự kiện chỉ có thể hoặc là đúng (tương đương với True -1) hoặc là sai (tương đương với False - 0); còn trong logic mờ, mức độ đúng của một sự kiện được đánh giá bằng một sô' thực có giá trị nằm giữa 0 và 1, tùy theo mức độ đúng “nhiều” hay “ít” của nó. Rosner, Comunale và Sexton (2006) chỉ ra một tiện ích chính của logic mờ nhằm mục đích đánh giá tính trọng yếu [19]. Hệ thống mờ cho phép kiểm toán viên đánh giá tính trọng yếu trên thang đo liên tục từ 0 đến 1, chứ không phải bằng quyết định nhị phân. Mạng nơron hầu hết gắn liền với việc đánh giá rủi ro, giúp kiểm toán viên thực hiện các nhiệm vụ đánh giá rủi ro một cách hệ thống và nhất quán hơn, nhờ khả năng của mạng nơron trong việc ủm hiểu, tổng quát hóa và phân loại dữ liệu, cả đầy đủ và không đầy đủ [2], Calderon và Cheh (2002) đề cập đến các tùy chọn khác về cách sử dụng mạng nơron: để đánh giá rủi ro thông tin sơ bộ, đánh giá rủi ro kiểm soát; xác định sai sót và gian lận, kiệt quệ tài chính và phá sản và hình thành ý kiến kiểm toán liên tục [17], Các hệ thống kết hợp, sự kết hợp của các công nghệ nêu trên, có thể được sử dụng khi cần trong cả phân tích định lượng và đánh giá định tính. Davis, Massey và Lovell (1997) đã xây dựng một hệ thống lai nguyên mẫu, tích hợp một hệ thống chuyên gia và một mạng nơ-ron [15], Phần hệ thống chuyên gia đảm bảo việc sử dụng hiệu quả các mối quan hệ biến điều khiển đã biết, trong khi phần mạng nơron cung cấp một cách nhận biết các mẫu trong sô' lượng lớn các mối quan hệ biến điều khiển, một sô' mối quan hệ trong sô' đó không thể diễn đạt thành một bộ quy tắc.

### Vận dụng trí tuệ nhân tạo trong công tác kế toán - kiểm toán 

Trí tuệ nhân tạo đã bắt đầu được triển khai dần vào hệ thống thông tin kê' toán và kiểm toán của các công ty. Bước đầu tiên phổ biến nhất là RPA (Robotic Process Automation), Tự động hóa quy trình bằng robot. RPA là một phần mềm chạy phần mềm ứng dụng khác và có thể được sử dụng để tự động hóa các quy trình kinh doanh được xác định trước [1], Sự khác biệt giữa RPA và trí tuệ nhân tạo là trong khi RPA hướng theo quy trình, tự động hóa SỐ23-Tháng 10/2021 395 TẠP CHÍ CÔNG THƯƠNG các tác vụ dựa trên các quy tắc, thì trí tuệ nhân tạo là hướng dữ liệu, đòi hỏi dữ liệu có chất lượng cao để học các mẫu và mô phỏng các quyết định của con người trước [1]. Hai thuật ngữ này do đó có liên quan chặt chẽ với nhau, với trí tuệ nhân tạo sẽ tiến thêm một bước nữa. Tuy nhiên, các công nghệ này không thay thế nhau mà bổ sung cho nhau (EY, 2018). Lý do chính cho việc tích hợp các công nghệ RPA ngay từ đầu là do quá nhiều công việc lặp đi lặp lại. đơn giản, dựa trên quy tắc vẫn chiếm các kiểm toán viên một cách không cần thiết. Thêm vào đó, theo Murphy và Brown (1992), phân tích rủi ro là giai đoạn quan trọng của việc đánh giá xem kế hoạch kiểm toán có hợp lý hay không và hữu ích để xác định lượng bằng chứng thích hợp cần thu thập cũng như xác định mức trọng yếu thích hợp [3]. Một nguyên tắc chung có thể được suy ra: rủi ro vốn càng cao, số lượng bằng chứng cần thiết càng cao và tỷ lệ trọng yếu cho phép càng tháp. Việc sử dụng AI trong kiểm toán sẽ làm giảm cả 3 loại rủi ro kiểm toán: rủi ro tiềm tàng, rủi ro kiểm soát và rủi ro phát hiện. Rủi ro tiềm tàng là xác suất có sai sót trọng yếu trong báo cáo tài chính trước khi thực hiện quá trình đánh giá kiểm soát nội bộ, thể hiện rủi ro phức tạp nhất để xác định. Hệ thống chuyên gia (ES - expert systems) thường dựa trên các mô hình thông kê cho phép kiểm toán viên nhận ra các rủi ro tiềm tàng vốn có và cũng có thể nêu các biến cơ bản để đưa ra phán đoán về rủi ro tiềm tàng. Một cách tiếp cận phổ biến khác là dựa trên bảng câu hỏi, với một hệ thống chuyên gia đặt câu hỏi cho kiểm toán viên và đánh giá chúng thông qua ma trận, tính điểm rủi ro tổng thể. Đối với các xu hướng và thông tin trong lĩnh vực AI trong kiểm toán, sự đổi mới đang diễn ra nhanh nhất tại các công ty kiểm toán Big4: Deloitte, EY, PwC và KPMG. Do đó, các công nghệ AI do Big4 giới thiệu rất cụ thể và có thể áp dụng: Deloitte đã thành lập một liên minh với Kira Systems vào tháng 3 năm 2016 để mang lại sự đổi mới và học máy cho nơi làm việc [4]. Dựa trên liên minh, Deloitte sau đó đã tạo ra một ứng dụng nhận thức được gọi là Argus, được thiết kế đặc biệt cho các mục đích kiểm toán, ứng dụng này “học hỏi từ các tương tác của con người và tận dụng các kỹ thuật máy học tiên tiến và xử lý ngôn ngữ tự nhiên để tự động xác định và trích xuất thông tin kế toán quan trọng từ bất kỳ loại tài liệu điện tử nào” [5]. Đối với bước này, Công ty đã giành được giải thưởng Đổi mới kiểm toán của năm của Bản tin Kế toán Quốc tế 2018, vì sự công hiến cho việc đổi mới và phát triển các công cụ để chuyển đổi nghề kiểm toán. Một ứng dụng khác do Deloitte phát ừiển là Hướng dẫn hỗ trợ cá nhân đánh giá rủi ro. gọi tắt là GRAPA. Nó hỗ trợ kiểm toán viên so sánh chiến lược đã chọn của họ với các chiến lược rủi ro khác đã sử dụng trước đó, làm việc với cơ sở dữ liệu của Deloitte gồm 10.000 trường hợp, với mỗi trường hợp bao gồm khoảng 50 rủi ro [6], Theo Deloitte, ứng dụng này nên được coi là một công cụ để lập kế hoạch và đánh giá tiêu chuẩn, vì vẫn cần đến sự sáng tạo và trí tuệ của con người, đặc biệt là việc xem xét các quy trình, sự phát triển và rủi ro. Deloitte cũng có kếhoạch giới thiệu chatbot, hướng dẫn nhân viên một cách hiệu quả thông qua các quy định, luật, chuẩn mực kiểm toán và kế toán và tài liệu chuyên môn [6], ứng dụng này sẽ dựa trên các thuật toán và cũng sẽ thu thập dữ liệu phản hồi có giá trị từ người dùng để cải thiện các tìm kiếm hơn nữa và làm cho ứng dụng hiệu quả hơn. PwC đã giành được cả 2 giải thưởng Sáng tạo Kiểm toán của Bản tin Kế toán Quốc tế năm 2017 và năm 2019. Giải thưởng năm 2017 được kết nối với công nghệ GL.ai của nó, được phát triển với sự hợp tác của H20.ai, một công ty ở Thung lũng Silicon, phát triển một hệ thống hỗ trợ trí tuệ nhân tạo có khả năng phân tích tài liệu và chuẩn bị báo cáo (D. Faggella, 2019). GL.ai có thể tái tạo tư duy và quyết định của kiểm toán viên và kiểm tta tất cả các giao dịch, người dùng, số tiền và tài khoản để phát hiện các giao dịch bất thường trên sổ cái. Giải thưởng năm 2019 đã được trao cho một công nghệ khác, Cash.ai, tự động hóa việc kiểm tra tiền mặt, bao gồm số dư tiền mặt, đôi chiếu ngân hàng, thư xác nhận ngân hàng, ngoại hối và điều kiện tài chính của ngân hàng. KMPG hợp tác với Microsoft, cung cấp sự đổi mới tích hợp cho khách hàng của họ. Các giải pháp này bao gồm Intelligent Underwriting Engine [10], công cụ để tính toán rủi ro và tính phí bảo hiểm hoặc Sales Intelligence Engine [11], công cụ tối ưu hóa chu kỳ bán hàng. Đặc biệt thú vị đốì với kiểm toán là Thông tin chi tiết về khả năng sinh lời chiến 396 SỐ23-Tháng 10/2021 KẾ TOÁN-KIỂM TOÁN lược [12], một nền tảng giúp trích xuất dữ liệu tài chính quan trọng và cung cấp thông tin chi tiết về giá trị của một giao dịch. KPMG cũng đề cập đến Digital Solution Hub, dựa trên các dịch vụ đám mây Microsoft Azure, kết nôi nó với các công cụ trí tuệ nhân tạo [14],

# Kết luận 

Mặc dù vẫn còn những vấn đề đạo đức và pháp lý gắn liền vói AI trong kiểm toán và kê toán, nhưng trong mọi trường hợp, AI đang trở thành một phần của các quy trinh kinh doanh, kiểm toán và kế toán khác nhau, với việc các công ty đầu tư ngày càng nhiều vốn hơn vào sự phát ttiển của họ. Mặc dù trong tương lai, có thể sẽ phát sinh những vấn đề mới và những nguy cơ mới, nhưng chắc chắn, AI vẫn sẽ mang lại nhiều cơ hội và những giải pháp hiệu quả. Việc ứng dụng AI có thể giải quyết những điểm yếu, kém hiệu quả và giá trị gia tăng thấp trong lĩnh vực kế toán, khiến kế toán chuyển sang làm công việc sáng tạo hơn và mang lại giá trị lớn hơn cho công ty. Tóm lại, việc ứng dụng trí tuệ nhân tạo vào ngành Kế toán có ý nghĩa rất lớn, bởi sẽ thúc đẩy sự phát triển, đổi mới của ngành và nâng cao năng lực cạnh tranh của DN

# Public_204

# Bản mạch in (PCB). 

PCB (viết tắt từ Printed Circuit Board) là một bản mạch có các đường nối dẫn điện liên kết các linh kiện với nhau theo nguyên lý. Mối hàn kim loại tạo mối liên kết điện giữa bề mặt PCB với các linh kiện gắn trên nó.
Trước khi mạch in PCB ra đời, mạch điện được đấu với nhau bằng dây điện nối điểm -điểm rất mất thời gian. Và đó cũng là nguyên nhân dẫn đến nhiều hư hỏng, ngắn mạch, đứt mạch.
Một tấm PCB được cấu thành từ nhiều lớp, mỗi lớp là một loại vật liệu khác nhau được kết dính bằng vật liệu kết dính và ép nhiệt để trở thành 1 bản mạch duy nhất.
|<image_1>|
**Vật liệu nền (Substrate)**  
Vật liệu nền, thường là sợi thủy tinh (FR4), ngoài ra còn có các vật liệu khác như nhựa Bakelit (FR1), eposi kết hợp sợi thủy tinh (CEM) ... Sợi thủy tinh có rất nhiều ưu điểm, nên hầu hết các thiết kế người ta sử dụng FR-4. Ngoài ra, đối với các loại PCB dẻo còn sử dụng loại nhựa chịu nhiệt cao để làm vật liệu nền (Kapton hoặc tương đương).
Có rất nhiều độ dày khác nhau cho PCB, chủ yếu và phổ biến là 1.6mm, ngoài ra còn có 0.16mm, 0.5mm, 0.8mm, 1.0mm, 1.2mm, 2.0mm ...
Các loại nền mạch rẻ tiền như Eposi, Phenol được sử dụng trong các sản phẩm điện tử cần giá thành thấp có độ bền kém hơn FR-4, có những đặc tính không dễ chịu như có mùi khét khi hàn, nếu đặt nhiệt độ quá cao hay hàn quá lâu bản mạch sẽ bị phân hủy, phát sinh khói.
**Đường đồng (Copper)**

|<image_2>|

Lớp tiếp theo là lớp đồng mỏng, được ép dính bằng keo kết dính và nhiệt trên vật liệu nền. Thông thường, đối với mạch 2 lớp, thì đồng được ép trên cả 2 mặt, đối với mạch 1 lớp, thì đồng chỉ được ép trên 1 mặt. Độ dày của lớp đồng khác nhau và được đo bằng trọng lượng, ounce/foot vuông. Đa số PCB có độ dày 1 ounce/foot vuông (độ dày của lớp đồng khoảng 35 micromet).

**Lớp phủ (Soldermask).**

Lớp phía trên lớp đồng là lớp phủ, hay còn gọi là mặt nạ mở phủ, phổ biến có màu xanh lá, ngoài ra có màu đỏ, đen, trắng, xanh dương. Nó được phủ lên lớp đồng để ngăn cách các đường đồng tiếp xúc ngẫu nhiên đối với kim loại, mối hàn, hoặc dây dẫn. Ngoài ra nó còn hữu ích để hàn chính xác, ngăn chặn lem hàn.
|<image_3>|
Trên hình, lớp phủ màu xanh lá được sử dụng phổ biến cho các loại PCB, phủ qua hết các đừờng mạch tuy nhiên vẫn chừa ra những chỗ màu trắng để hàn linh kiện.
**Lớp in linh kiện (Silkscreen)**

|<image_4>|

Lớp in linh kiện màu trắng là lớp trên cùng PCB, trên cả lớp phủ xanh. Ở lớp này có thể thêm những ký tự, số, ký hiệu của các linh kiện để dễ dàng nhận biết và lắp ráp linh kiện lên PCB. Thông thường lớp in linh kiện có màu trắng, tuy nhiên có những màu khác nữa như màu đen, mầu xám, nhưng tùy thuộc vào màu của lớp phủ để sử dụng màu của lớp in linh kiện sao cho nổi bật nhất. Ví dụ phủ đen thì in linh kiện trắng, còn phủ trắng thì in linh kiện đen.

# Tổ chức linh kiện trên bản mạch. 

Việc bố trí linh kiện trên bo mạch cho đúng và hợp lý phụ thuộc vào rất nhiều yếu tố. Tuy nhiên trong thiết kế mạch phải đảm bảo các nguyên tắc sau.

  * Có không gian đủ lớn cho các linh kiện công suất.

  * Hạn chế tối thiểu các đoạn dây nối chồng chéo.


# Dụng cụ, thiết bị cầm tay nghề điện tử. 

## Mỏ hàn. 

### Mỏ hàn nhiệt 

|<image_5>|

Phần chính của mỏ hàn thường là bộ phận gia nhiệt. Trên một ống sứ hình trụ rỗng, mặt ngoài tạo rãnh theo đường xoắn ốc, trên rãnh người ta đặt dây điện trở nhiệt, giữa ruột của ống sứ là mỏ hàn bằng đồng đỏ.
Đầu dây ra của điện trở nhiệt được bao phủ bởi các vòng (khoen) sứ nhỏ chịu nhiệt và cách điện tốt, xuyên qua cần hàn rồi đấu vào dây dẫn điện để dẫn điện vào mỏ hàn.
|<image_6>|
_Cấu tạo bên trong mỏ hàn thường_
Khi mỏ hàn được cấp nguồn sẽ xuất hiện dòng điện chạy qua cuộn dây điện trở nhiệt (1) cuốn trên ống sứ (3), làm cho cuộn dây (4) nóng dần lên sinh ra nhiệt. Nhiệt lượng này truyền qua ống sứ cách điện sang đầu mỏ hàn (5) (đầu mỏ hàn nằm trong ống sứ và cuộn dây). Đầu mỏ hàn được làm bằng lim loại nên hấp thụ nhiệt. Nhiệt lượng do đầu mỏ hàn toả ra nóng hơn nhiệt độ nóng chảy của thiếc nên khi ta đưa đầu mỏ hàn vào thiếc sẽ làm cho thiếc bị nóng chảy. Vậy mỏ hàn đã sinh nhiệt.

### Mỏ hàn xung 

Mỏ hàn xung thường được sử dụng ở mạng điện lưới 110V hay 220V, mỏ hàn xung được chế tạo gồm nhiều loại công suất khác nhau : 45W, 60W, 75W và 100W, 200W, tuỳ theo đối tượng hàn mà ta chọn loại mỏ hàn xung nào cho phù hợp.

|<image_7>|
_Hình dạng bên ngoài mỏ hàn xung_
Bộ phận tạo nhiệt cho mỏ hàn xung chính là phần dây dẫn làm mỏ hàn, dòng điện làm nóng mỏ hàn được lấy từ cuộn thứ cấp (cuộn thứ cấp có hai cuộn: cuộn chính cấp dòng cho mỏ hàn ; cuộn phụ cấp dòng cho đèn báo của biến áp hàn). Biến áp hàn có cuộn sơ cấp nối tiếp với nút ấn (công tắc nguồn) và dây dẫn điện cùng phích cắm để lấy điện xoay chiều vào.

# Public_253
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th rowspan="2">|<image_1>|</th>
<th><strong>VIETTEL AI RACE</strong></th>
<th>Public 253</th>
</tr>
<tr>
<th><p><strong>ĐỀ CƯƠNG CHI TIẾT HỌC PHẦN</strong></p>
<blockquote>
<p><strong>Tên học phần: An toàn mạng (Network Security)</strong></p>
</blockquote></th>
<th>Lần ban hành: 1</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table> 

# 1\. Thông tin chung về học phần
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><blockquote>
<p><strong>1) Mã học phần:</strong></p>
</blockquote></td>
<td><blockquote>
<p>INT1482</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>2) Số tín chỉ:</strong></p>
</blockquote></td>
<td><blockquote>
<p>3</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>3) Hoạt động học tập</strong></p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Lý thuyết:</p>
</blockquote></td>
<td><blockquote>
<p>30 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Bài tập:</p>
</blockquote></td>
<td><blockquote>
<p>0 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Thảo luận:</p>
</blockquote></td>
<td><blockquote>
<p>6 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Thực hành/Thí nghiệm:</p>
</blockquote></td>
<td><blockquote>
<p>12 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Thực tế/Thực tập:</p>
</blockquote></td>
<td><blockquote>
<p>0 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Đề án/Bài tập lớn…:</p>
</blockquote></td>
<td><blockquote>
<p>18 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Tự học:</p>
</blockquote></td>
<td><blockquote>
<p>90 tiết</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>4) Điều kiện tham gia học phần:</strong></p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Học phần tiên quyết:</p>
</blockquote></td>
<td><blockquote>
<p>Cơ sở An toàn thông tin</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>-</strong> Học phần học trước:</p>
</blockquote></td>
<td><blockquote>
<p>Mạng máy tính</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>5) Các giảng viên phụ trách học phần:</strong></p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>- Giảng viên phụ trách chính:</p>
</blockquote></td>
<td><blockquote>
<p>TS. Nguyễn Ngọc Điệp</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>- Danh sách giảng viên cùng giảng dạy:</p>
</blockquote></td>
<td><blockquote>
<p>TS. Phạm Hoàng Duy, PGS.TS. Hoàng Xuân Dậu</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>- Khoa/ Bộ môn phụ trách giảng dạy:</p>
</blockquote></td>
<td><blockquote>
<p>Khoa An toàn thông tin/ Bộ môn An toàn mạng</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>6) Loại học phần:</strong></p>
</blockquote></td>
<td><blockquote>
<p>☒ Bắt buộc ☐ Tự chọn tự do</p>
<p>☐ Tự chọn theo định hướng (bắt buộc)</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>7) Thuộc thành phần học tập</strong></p>
</blockquote></td>
<td><blockquote>
<p>☐ Giáo dục đại cương (chung, khoa học cơ bản, kỹ năng)</p>
<p>☐ Cơ sở khối ngành (nhóm ngành/lĩnh vực)</p>
<p>☐ Cơ sở ngành</p>
<p>☐ Ngành</p>
<p>☒ Chuyên ngành</p>
<p>☐ Bổ trợ</p>
</blockquote></td>
</tr>
<tr>
<td></td>
<td><blockquote>
<p>☐ Thực tập/ Đồ án tốt nghiệp/ Khóa luận tốt nghiệp</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>8) Ngôn ngữ giảng dạy</strong></p>
</blockquote></td>
<td><blockquote>
<p>☒ Tiếng Việt</p>
<p>☐ Tiếng Anh</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p><strong>9) Phương thức giảng dạy</strong></p>
</blockquote></td>
<td><blockquote>
<p>☒ Trực tiếp</p>
<p>☐ Trực tuyến</p>
<p>☐ Trực tiếp và trực tuyến</p>
</blockquote></td>
</tr>
</tbody>
</table> 

# 2\. Mô tả tóm tắt học phần:

Học phần An toàn mạng là học phần bắt buộc trong khối kiến thức chuyên ngành của chương trình dạy học ngành An toàn thông tin được giảng dạy ở học kỳ 7. Để có thể học tốt học phần này, người học cần nắm vững các kiến thức đã học trong học phần Mạng máy tính và Cơ sở An toàn thông tin. Học phần An toàn mạng sẽ trang bị cho người học các kiến thức cơ bản và chuyên sâu về các lỗ hổng, các dạng tấn công mạng và các giải pháp đảm bảo an toàn mạng. Nội dung chính của học phần tập trung vào các nguy cơ và lỗ hổng trong bảo mật mạng, các kỹ thuật tấn công của tin tặc và giải pháp phòng chống, các giải pháp phòng ngừa và đáp trả tấn công mạng. Bên cạnh đó, khi tham gia học phần này, người học được rèn luyện các kỹ năng cài đặt, triển khai, phân tích và đánh giá các giải pháp bảo mật, cũng như thực hành kỹ năng giao tiếp và làm việc nhóm trong khi thực hiện bài tập lớn.

# 3\. Chuẩn đầu ra của học phần (CLOs)

## 3.1. Chuẩn đầu ra của học phần và mối liên hệ với các chỉ báo thuộc PLOs 

_Danh sách các PLO và bảng CM V0.5:_ [__https://docs.google.com/spreadsheets/d/1jbfA5tnqT2ra7Vaoi7c5HhrXl8zbBslT/edit?gid=1389634614#gid=1389634614__](https://docs.google.com/spreadsheets/d/1jbfA5tnqT2ra7Vaoi7c5HhrXl8zbBslT/edit?gid=1389634614#gid=1389634614)
_PLO1: Áp dụng tri thức toán học, khoa học và công nghệ để xác định các giải pháp giải quyết các vấn đề phức hợp trong lĩnh vực an toàn thông tin._
_PLO2: Thiết kế các giải pháp đáp ứng một tập hợp các yêu cầu cụ thể trong lĩnh vực an toàn thông tin._
_PLO3: Áp dụng các kỹ thuật, công nghệ và công cụ bảo mật để giải quyết các vấn đề liên quan đến an toàn thông tin._
_PLO4: Giao tiếp và hoạt động hiệu quả trong các nhóm đa ngành liên quan đến lĩnh vực an toàn thông tin._
_PLO5: Nhận thức được vấn đề đạo đức và trách nhiệm nghề nghiệp trong lĩnh vực an toàn thông tin._
Sau khi kết thúc học phần, người học có khả năng:
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><blockquote>
<p><strong>STT</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Chuẩn đầu ra học phần (CLOs)</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Kiến thức Cognitive</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Kỹ năng Psychomotor</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Thái độ Affective</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>PLO</strong></p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>CLO1</p>
</blockquote></td>
<td><blockquote>
<p>Diễn giải được các nguy cơ và mối đe dọa trong bảo mật mạng, các kỹ
thuật tấn công mạng và các giải pháp phòng ngừa</p>
</blockquote></td>
<td><blockquote>
<p>C2</p>
</blockquote></td>
<td></td>
<td></td>
<td><blockquote>
<p>X R PLO3</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>CLO2</p>
</blockquote></td>
<td><blockquote>
<p>Đánh giá được mức độ rủi ro bảo mật của hệ thống mạng</p>
</blockquote></td>
<td><blockquote>
<p>C5</p>
</blockquote></td>
<td><blockquote>
<p>P3</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>X R PLO2</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>CLO3</p>
</blockquote></td>
<td><blockquote>
<p>Triển khai được các giải pháp an toàn mạng cơ bản</p>
</blockquote></td>
<td><blockquote>
<p>C3</p>
</blockquote></td>
<td><blockquote>
<p>P3</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>X E PLO3</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>CLO4</p>
</blockquote></td>
<td><blockquote>
<p>Tham gia tích cực hoạt động nhóm, giao tiếp và hợp tác hiệu quả để
thực hiện bài tập lớn học phần</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>P3</p>
</blockquote></td>
<td><blockquote>
<p>A2</p>
</blockquote></td>
<td><blockquote>
<p>X R PLO4</p>
</blockquote></td>
</tr>
</tbody>
</table> 

##  3.2. Hoạt động kiểm tra và hoạt động dạy học theo chuẩn đầu ra 
<table style="width:100%;">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td rowspan="2"><blockquote>
<p>CLOs</p>
</blockquote></td>
<td colspan="5"><blockquote>
<p><strong>Hình thức kiểm tra theo chuẩn đầu ra</strong></p>
</blockquote></td>
<td colspan="5"><blockquote>
<p><strong>Hình thức dạy học theo chuẩn đầu ra</strong></p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>Trắc nghiệm</p>
</blockquote></td>
<td><blockquote>
<p>Báo cáo</p>
</blockquote></td>
<td><blockquote>
<p>Bài tập thực hành</p>
</blockquote></td>
<td><blockquote>
<p>Thuyết trình</p>
</blockquote></td>
<td><blockquote>
<p>Demo/ Trình diễn</p>
</blockquote></td>
<td><blockquote>
<p>Bài giảng</p>
</blockquote></td>
<td><blockquote>
<p>Làm việc nhóm</p>
</blockquote></td>
<td><blockquote>
<p>Thảo luận nhóm</p>
</blockquote></td>
<td><blockquote>
<p>Hướng dẫn thực</p>
<p>hành</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>CLO1</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
<td></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>CLO2</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>CLO3</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>CLO4</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td><blockquote>
<p>x</p>
</blockquote></td>
<td></td>
<td></td>
</tr>
</tbody>
</table> 

# 4\. Kế hoạch kiểm tra theo chuẩn đầu ra 

● Thang điểm đánh giá: Thang điểm 10
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><blockquote>
<p><strong>Thành phần kiểm tra</strong></p>
</blockquote></td>
<td></td>
<td><blockquote>
<p><strong>Hoạt động Kiểm tra</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Hình thức kiểm tra</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Trọng số</strong></p>
<p><strong>(%)</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>Thời điểm</strong></p>
<p><strong>kiểm tra</strong></p>
<p><strong>(tuần)</strong></p>
</blockquote></td>
<td><blockquote>
<p><strong>CĐR HP (CLOs)</strong></p>
</blockquote></td>
</tr>
<tr>
<td colspan="2" rowspan="3"><blockquote>
<p>Kiểm tra quá trình (%)</p>
<p>(formative assessment)</p>
</blockquote></td>
<td><blockquote>
<p>Kiểm tra (%)</p>
</blockquote></td>
<td><blockquote>
<p>Vấn đáp</p>
</blockquote></td>
<td><blockquote>
<p>10%</p>
</blockquote></td>
<td><blockquote>
<p>Trong các buổi học</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>Thực hành (%)</p>
</blockquote></td>
<td><blockquote>
<p>Báo cáo</p>
</blockquote></td>
<td></td>
<td><blockquote>
<p>Tuần 4-14</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td><blockquote>
<p>Kiểm tra giữa kỳ (%)</p>
</blockquote></td>
<td><blockquote>
<p>Trắc nghiệm</p>
</blockquote></td>
<td><blockquote>
<p>10%</p>
</blockquote></td>
<td><blockquote>
<p>Tuần 8-10</p>
</blockquote></td>
<td></td>
</tr>
<tr>
<td colspan="2" rowspan="2"><blockquote>
<p>Kiểm tra tổng kết (%) (summative assessment)</p>
</blockquote></td>
<td><blockquote>
<p>Thi cuối kỳ 1 (%)</p>
</blockquote></td>
<td><blockquote>
<p>Trắc nghiệm</p>
</blockquote></td>
<td><blockquote>
<p>30 %</p>
</blockquote></td>
<td><blockquote>
<p>Theo kế hoạch của trường</p>
</blockquote></td>
<td><blockquote>
<p>CLO1</p>
</blockquote></td>
</tr>
<tr>
<td><blockquote>
<p>Thi cuối kỳ 2 (%)</p>
</blockquote></td>
<td><blockquote>
<p>Báo cáo, thuyết trình, demo bài tập lớn</p>
</blockquote></td>
<td><blockquote>
<p>50%</p>
</blockquote></td>
<td><blockquote>
<p>Theo kế hoạch của trường</p>
</blockquote></td>
<td><blockquote>
<p>CLO2, CLO3, CLO4</p>
</blockquote></td>
</tr>
</tbody>
</table> 

# 5\. Kế hoạch dạy và học 
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td rowspan="2"><strong>TT</strong></td>
<td rowspan="2"><p><strong>Nội dung</strong></p>
<p><strong>chi tiết</strong></p></td>
<td colspan="4"><blockquote>
<p><strong>Thời lượng<br/>
(giờ định mức)</strong></p>
</blockquote></td>
<td><strong>Hình thức và phương thức<br/>
tổ chức dạy học</strong></td>
<td rowspan="2"><strong>Kiểm tra (nếu có)</strong></td>
<td rowspan="2"><strong>Đóng góp vào CLO</strong></td>
</tr>
<tr>
<td><strong>Lý thuyết</strong></td>
<td><strong>Bài tập lớn</strong></td>
<td><strong>Thảo luận</strong></td>
<td><strong>Thực hành</strong></td>
<td></td>
</tr>
<tr>
<td rowspan="3">1</td>
<td rowspan="3"><p><strong>Chương 1: Giới thiệu về an toàn
mạng</strong></p>
<p>1.1. Các yêu cầu và phương pháp đảm bảo an toàn mạng</p>
<p>1.1.1. Các yêu cầu về đảm bảo an toàn mạng</p>
<p>1.1.2. Phương pháp đảm bảo an toàn mạng</p>
<p>1.2. Phân tích rủi ro và các mô hình phòng thủ</p>
<p>1.2.1. Xác định nguy cơ</p>
<p>1.2.2. Phân tích rủi ro</p>
<p>1.2.3. Các mô hình phòng thủ</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp:</p>
<p>+ Giảng viên giới thiệu đề cương và chuẩn đầu ra của môn học</p>
<p>+ Giảng viên giới thiệu các vấn đề về an toàn mạng, các phương pháp
đảm bảo an toàn mạng và đưa ra yêu cầu về bài tập lớn theo nhóm</p>
<p>+ Giảng viên giới thiệu về phân tích rủi ro và các mô hình phòng
thủ</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học và yêu cầu bài tập lớn theo nhóm</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> Người học tìm hiểu thêm
về các chủ đề bài tập lớn theo nhóm</td>
<td></td>
</tr>
<tr>
<td rowspan="3">2</td>
<td rowspan="3"><p>1.3. Tổ chức, quản lý an toàn</p>
<p>1.3.1. Vai trò và trách nhiệm</p>
<p>1.3.2. Quản lý hoạt động an toàn</p>
<p>1.3.3. Đào tạo nhận thức an toàn mạng</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung của Tổ chức và quản lý an toàn.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học tìm hiểu thông
tin về các khái niệm trong chương 1.</td>
<td></td>
</tr>
<tr>
<td rowspan="3">3</td>
<td rowspan="3"><p><strong>Chương 2: Các nguy cơ và lỗ hổng trong bảo
mật mạng</strong></p>
<p>2.1. Các nguy cơ và lỗ hổng trong bảo mật giao thức</p>
<p>2.1.1. Các giao thức phổ biến tầng ứng dụng</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các nguy cơ và lỗ hổng trong bảo mật giao thức phổ biến tầng ứng
dụng.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
</tr>
<tr>
<td rowspan="4">4</td>
<td rowspan="4"><p>2.1.2. Giao thức DNS</p>
<p>2.1.3. Giao thức TCP/UDP</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các nguy cơ và lỗ hổng trong giao thức DNS và TCP/UDP.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td>6</td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động báo cáo tiến độ về bài tập lớn của các nhóm.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
<td></td>
</tr>
<tr>
<td rowspan="3">5</td>
<td rowspan="3"><p>2.1.4. Các giao thức định tuyến</p>
<p>2.1.5. Một số giao thức khác</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các nguy cơ và lỗ hổng trong giao thức định tuyến và một số giao
thức khác.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
</tr>
<tr>
<td rowspan="4">6</td>
<td rowspan="4">2.2. Phân tích và thiết kế giao thức an toàn</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3, CLO4</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về phân tích hoạt động của giao thức và phương pháp thiết kế giao
thức an toàn.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động thực hành: người học thực hành trên lớp về phân tích giao
thức dựa trên bắt gói tin trên mạng</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học làm báo cáo
thực hành và thực hiện các bài tập về nhà.</td>
<td></td>
<td></td>
</tr>
<tr>
<td rowspan="3">7</td>
<td rowspan="3"><p>2.3. Các nguy cơ và lỗ hổng trong bảo mật thiết bị
mạng</p>
<p>2.3.1. Thiết bị chuyển mạch</p>
<p>2.3.2. Thiết bị định tuyến</p>
<p>2.3.3. Một số thiết bị khác</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về các nguy cơ và lỗ hổng trong bảo mật thiết bị mạng.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
</tr>
<tr>
<td rowspan="4">8</td>
<td rowspan="4"><p><strong>Chương 3: Các kỹ thuật tấn công
mạng</strong></p>
<p>3.1. Kỹ thuật do thám</p>
<p>3.1.1. Giới thiệu về kỹ thuật do thám</p>
<p>3.1.2. Do thám DNS</p>
<p>3.1.3. Thu thập và kiểm tra các tên miền và thông tin địa chỉ IP</p>
<p>3.1.4. Do thám sử dụng các máy tìm kiếm</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3"><p>CLO1, CLO2, CLO3</p>
<p>CLO2, CLO3, CLO4</p></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các kỹ thuật do thám.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td>6</td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động báo cáo tiến độ bài tập lớn</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
<td></td>
</tr>
<tr>
<td rowspan="4">9</td>
<td rowspan="4"><p>3.2. Kỹ thuật rà quét</p>
<p>3.2.1. Giới thiệu về kỹ thuật rà quét</p>
<p>3.2.2. Xác định các host hoạt động</p>
<p>3.2.3. Xác định các cổng và dịch vụ hoạt động</p>
<p>3.2.4. Xác định hệ điều hành</p>
<p>3.2.5. Rà quét các lỗ hổng</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3, CLO4</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các kỹ thuật rà quét trong mạng.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động thực hành: người học thực hiện thực hành các công cụ phần
mềm để rà quét mạng.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học làm báo cáo
thực hành và thực hiện các bài tập về nhà.</td>
<td></td>
<td></td>
</tr>
<tr>
<td rowspan="3">10</td>
<td rowspan="3"><p>3.3. Kỹ thuật xâm nhập</p>
<p>3.3.1. Xâm nhập hệ thống máy khách</p>
<p>3.3.2. Kỹ thuật vượt qua tường lửa và tránh bị phát hiện</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các kỹ thuật xâm nhập.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
</tr>
<tr>
<td rowspan="4">11</td>
<td rowspan="4"><p>3.4. Tấn công từ chối dịch vụ</p>
<p>3.4.1. Tấn công từ chối dịch vụ tại tầng liên kết</p>
<p>3.4.2. Tấn công từ chối dịch vụ tại tầng giao vận</p>
<p>3.4.3. Tấn công từ chối dịch vụ tại tầng ứng dụng</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3, CLO4</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về kỹ thuật tấn công từ chối dịch vụ.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>4</td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động thực hành: thử nghiệm tấn công từ chối dịch vụ và cách
phòng chống.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học làm báo cáo
thực hành và thực hiện các bài tập về nhà.</td>
<td></td>
<td></td>
</tr>
<tr>
<td rowspan="4">12</td>
<td rowspan="4"><p><strong>Chương 4: Các giải pháp phòng ngừa và đáp trả
tấn công</strong></p>
<p>4.1. Các giải pháp phòng ngừa, ngăn chặn tấn công</p>
<p>4.1.1 Đảm bảo an toàn môi trường vật lý</p>
<p>4.1.2 Cập nhật bản vá</p>
<p>4.1.3 Đảm bảo an toàn cho người dùng</p>
<p>4.1.4 Đảm bảo an toàn cho hệ thống tập tin</p>
<p>4.1.5 Xây dựng kế hoạch phòng ngừa</p>
<p><strong>Kiểm tra giữa kỳ</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="4">CLO1, CLO2, CLO3, CLO4</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các giải pháp phòng ngừa, ngăn chặn tấn công.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td>6</td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p><strong>- Hoạt động kiểm tra giữa kỳ</strong>: báo cáo giữa kỳ bài
tập lớn theo nhóm</p></td>
<td>X</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td>X</td>
</tr>
<tr>
<td rowspan="4">13</td>
<td rowspan="4"><p>4.2. Các phương pháp đáp trả tấn công</p>
<p>4.2.1 Lập kế hoạch đáp trả tấn công</p>
<p>4.2.2 Điều tra</p>
<p>4.2.3 Công cụ pháp luật</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Các phương pháp đáp trả tấn công.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>4</td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động thảo luận: sinh viên thảo luận theo nhóm về các cách thức
hiệu quả để đáp trả tấn công trong thực tế.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
<td></td>
</tr>
<tr>
<td rowspan="3">14</td>
<td rowspan="3"><p>4.3. Khôi phục sau sự cố và tiếp tục hoạt động</p>
<p>4.3.1 Khôi phục sau sự cố</p>
<p>4.3.2 Kế hoạch đảm bảo tiếp tục hoạt động</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="3">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên giới thiệu, giải thích các nội
dung về Khôi phục sau sự cố và tiếp tục hoạt động.</p>
<p>- Hoạt động Học trên lớp: người học lắng nghe và hiểu được các nội
dung của bài học.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học thực hiện các
bài tập về nhà được giao trên lớp.</td>
<td></td>
</tr>
<tr>
<td rowspan="4">15</td>
<td rowspan="4">Ôn tập và trả lời câu hỏi</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Chuẩn bị (Pre-class):</strong> người học chuẩn bị trước nội
dung của bài học thông qua tài liệu được cung cấp.</td>
<td></td>
<td rowspan="4">CLO1, CLO2, CLO3</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động Dạy trên lớp: Giảng viên đưa ra các câu hỏi ôn tập và trả
lời câu hỏi của người học.</p>
<p>- Hoạt động Học trên lớp: Người học nghiên cứu các câu hỏi ôn tập,
trao đổi và hỏi giảng viên.</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>2</td>
<td></td>
<td><p><strong>Trên lớp (In-class)</strong></p>
<p>- Hoạt động tự học: sinh viên trao đổi thêm về các câu hỏi ôn
tập</p></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><strong>Sau giờ học (Post-Class):</strong> người học tìm hiểu và trả
lời các câu hỏi ôn tập.</td>
<td></td>
</tr>
<tr>
<td></td>
<td><strong>Tổng số giờ</strong></td>
<td><strong>30</strong></td>
<td><strong>18</strong></td>
<td><strong>6</strong></td>
<td><strong>12</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table> 

# 6\. Nhiệm vụ của người học:

Người học phải thực hiện các nhiệm vụ sau đây:
\- Tham gia nghe giảng và tương tác theo quy định của lớp học phần;
\- Tham gia các hoạt động làm việc nhóm theo quy định của lớp học phần;
\- Tự tìm hiểu các vấn đề do giảng viên giao để thực hiện ngoài giờ học trên lớp;
\- Hoàn thành tất cả bài đánh giá của học phần.
\- Người học phải tôn trọng giảng viên và người học khác, phải thực hiện quy định liêm chính học thuật của Nhà trường, phải chấp hành các quy định, nội quy của Nhà trường.

# 7\. Tài liệu học tập

## 7.1. Tài liệu chính 

1\. Roberta Bragg, Mark Rhodes-Ousley and Keith Strassberg, Network Security: The Complete Reference, McGraw-Hill Osborne Media, 2013.

## 7.2. Tài liệu tham khảo

1\. John Chirillo, Hack attacks revealed: A complete reference with custom security hacking toolkit, John Wiley & Sons, 2001.
2\. Jie Wang, Computer Network Security: Theory and Practice, Springer, 2009.
3\. Michael T. Simpson, Kent Backman, Hands-On Ethical Hacking and Network Defense, Delmar Cengage Learning, 2010.
4\. Stuart McClure, Joel Scambray and George Kurtz, Hacking Exposed 7: Network Security Secrets & Solutions, McGraw-Hill Osborne Media, 2012.
5\. William Stallings, Cryptography and Network Security Principles And Practice, 7th edition, Pearson Education Limited, 2017.
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table> 

**  
**

**Phụ lục 01 - ĐCCT**

**BẢNG MA TRẬN VÀ THANG ĐO**
**Bảng 1** \- **Quan hệ giữa chuẩn đầu ra học phần và chuẩn đầu ra chương trình đào tạo**
<table style="width:100%;">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td></td>
<td colspan="5">PLOs</td>
</tr>
<tr>
<td></td>
<td>PLO1</td>
<td>PLO2</td>
<td>PLO3</td>
<td>PLO4</td>
<td>PLO5</td>
</tr>
<tr>
<td>CLO 1</td>
<td></td>
<td></td>
<td><blockquote>
<p>X R</p>
</blockquote></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CLO 2</td>
<td></td>
<td><blockquote>
<p>X R</p>
</blockquote></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CLO 3</td>
<td></td>
<td></td>
<td><blockquote>
<p>X E</p>
</blockquote></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CLO 4</td>
<td></td>
<td></td>
<td></td>
<td><blockquote>
<p>X R</p>
</blockquote></td>
<td></td>
</tr>
</tbody>
</table> 

**Bảng 2 - Thang đánh giá chuẩn đầu ra (CLO)**
CLO1: Diễn giải được các nguy cơ và mối đe dọa trong bảo mật mạng, các kỹ thuật tấn công mạng và các giải pháp phòng ngừa (C2)
<table style="width:100%;">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><p><strong>Thang</strong></p>
<p><strong>đánh giá</strong></p></td>
<td><p>Fail -<br/>
Below</p>
<p>Expectation</p>
<p>&lt; 40%</p></td>
<td><p>Beginning -</p>
<p>Needs</p>
<p>Improvement</p>
<p>40%-54%</p></td>
<td>Developing - Marginally Adequate <strong><br/>
</strong>55%-69%</td>
<td><p>Sufficient - Meet Expectation</p>
<p>70%-84%</p></td>
<td>Exemplary- Exceeds Expectation<br/>
85% - 100%</td>
</tr>
<tr>
<td><strong>Tiêu chí</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1.1. Giải thích được các nguy cơ, lỗ hổng trong bảo mật mạng và các
kỹ thuật tấn công của tin tặc</td>
<td>Trả lời đúng &lt;40% số câu hỏi (đã phân bổ đều theo nội dung)</td>
<td>Trả lời đúng từ 40% đến &lt;55% số câu hỏi (đã phân bổ đều theo nội
dung)</td>
<td>Trả lời đúng từ 55% đến &lt;70% số câu hỏi (đã phân bổ đều theo nội
dung)</td>
<td>Trả lời đúng từ 70% đến &lt;85% số câu hỏi (đã phân bổ đều theo nội
dung)</td>
<td>Trả lời đúng từ 85% số câu hỏi (đã phân bổ đều theo nội dung) trở
lên</td>
</tr>
<tr>
<td>1.2. Giải thích được các giải pháp phòng chống, các giải pháp phòng
ngừa và đáp trả tấn công mạng</td>
<td>Trả lời đúng &lt;40% số câu hỏi (đã phân bổ đều theo nội dung)</td>
<td>Trả lời đúng từ 40% đến &lt;55% số câu hỏi (đã phân bổ đều theo nội
dung)</td>
<td>Trả lời đúng từ 55% đến &lt;70% số câu hỏi (đã phân bổ đều theo nội
dung)</td>
<td>Trả lời đúng từ 70% đến &lt;85% số câu hỏi (đã phân bổ đều theo nội
dung)</td>
<td>Trả lời đúng từ 85% số câu hỏi (đã phân bổ đều theo nội dung) trở
lên</td>
</tr>
</tbody>
</table> 

CLO2: Đánh giá được mức độ rủi ro bảo mật của hệ thống mạng (C5-P3; PLO2-XR)
<table style="width:100%;">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><p><strong>Thang</strong></p>
<p><strong>đánh giá</strong></p></td>
<td><p>Fail -<br/>
Below</p>
<p>Expectation</p>
<p>&lt; 40%</p></td>
<td><p>Beginning -</p>
<p>Needs</p>
<p>Improvement</p>
<p>40%-54%</p></td>
<td>Developing - Marginally Adequate <strong><br/>
</strong>55%-69%</td>
<td><p>Sufficient - Meet Expectation</p>
<p>70%-84%</p></td>
<td>Exemplary- Exceeds Expectation<br/>
85% - 100%</td>
</tr>
<tr>
<td><strong>Tiêu chí</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2.1. Xác định các rủi ro bảo mật đối với một hệ thống mạng cụ
thể</td>
<td>Không thể xác định được các rủi ro bảo mật</td>
<td>Chỉ xác định được một số rủi ro bảo mật, còn thiếu nhiều rủi ro bảo
mật</td>
<td>Xác định đa số rủi ro bảo mật, nhưng còn thiếu một số rủi ro bảo
mật</td>
<td>Xác định đầy đủ các rủi ro bảo mật</td>
<td>Xác định đầy đủ và chi tiết các rủi ro bảo mật</td>
</tr>
<tr>
<td>2.2. Phân tích, đánh giá mức độ rủi ro bảo mật đối với hệ thống
mạng</td>
<td>Không thể phân tích và đánh giá được mức độ rủi ro bảo mật</td>
<td>Chỉ phân tích và đánh giá được mức độ rủi ro một cách sơ sài</td>
<td>Phân tích và đánh giá tương đối đầy đủ mức độ rủi ro bảo mật, nhưng
còn thiếu một số rủi ro bảo mật</td>
<td>Phân tích và đánh giá đầy đủ mức độ rủi ro bảo mật</td>
<td>Phân tích và đánh giá đầy đủ và chi tiết mức độ rủi ro bảo mật</td>
</tr>
</tbody>
</table> 

CLO3: Triển khai được các giải pháp an toàn mạng cơ bản (C3-P3)
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><strong>Thang Đánh giá</strong></td>
<td><p>Fail -<br/>
Below</p>
<p>Expectation</p>
<p>&lt; 40%</p></td>
<td><p>Beginning -</p>
<p>Needs</p>
<p>Improvement</p>
<p>40%-54%</p></td>
<td>Developing - Marginally Adequate <strong><br/>
</strong>55%-69%</td>
<td><p>Sufficient - Meet Expectation</p>
<p>70%-84%</p></td>
<td>Exemplary-<br/>
Exceeds<br/>
Expectation<br/>
85% - 100%</td>
</tr>
<tr>
<td><strong>Tiêu chí</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3.1. Lựa chọn giải pháp</td>
<td>Không thể lựa chọn giải pháp an toàn mạng phù hợp cho tình huống cụ
thể.</td>
<td>Lựa chọn giải pháp chưa phù hợp với yêu cầu bảo mật hoặc khả năng
triển khai thực tế.</td>
<td>Lựa chọn được giải pháp an toàn mạng phù hợp cho tình huống cụ thể,
nhưng chưa tối ưu.</td>
<td>Lựa chọn được giải pháp an toàn mạng phù hợp và tối ưu cho tình
huống cụ thể.</td>
<td>Lựa chọn được giải pháp an toàn mạng phù hợp và tối ưu, đồng thời
đưa ra được lý do lựa chọn trên cơ sở so sánh với các giải pháp
khác.</td>
</tr>
<tr>
<td>3.2. Triển khai giải pháp</td>
<td>Không thể triển khai giải pháp an toàn mạng đã chọn.</td>
<td>Triển khai giải pháp gặp nhiều lỗi, chưa hoàn thiện, hoặc không đúng
quy trình.</td>
<td>Triển khai được giải pháp an toàn mạng đã chọn, nhưng còn một số lỗi
nhỏ.</td>
<td>Triển khai giải pháp an toàn mạng đã chọn một cách chính xác và hiệu
quả.</td>
<td>Triển khai giải pháp an toàn mạng đã chọn một cách chính xác, hiệu
quả, và tối ưu hóa hiệu năng hoạt động.</td>
</tr>
</tbody>
</table> 

CLO4: Tham gia tích cực hoạt động nhóm, giao tiếp và hợp tác hiệu quả để thực hiện bài tập lớn học phần (P3-A2)
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><strong>Thang đánh giá</strong></td>
<td><p>Fail -<br/>
Below</p>
<p>Expectation</p>
<p>&lt; 40%</p></td>
<td><p>Beginning -</p>
<p>Needs</p>
<p>Improvement</p>
<p>40%-54%</p></td>
<td>Developing - Marginally Adequate <strong><br/>
</strong>55%-69%</td>
<td><p>Sufficient - Meet Expectation</p>
<p>70%-84%</p></td>
<td>Exemplary- Exceeds Expectation<br/>
85% - 100%</td>
</tr>
<tr>
<td><strong>Tiêu chí</strong></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4.1. Mức độ tham gia và đóng góp vào hoạt động nhóm</td>
<td>Không tham gia các hoạt động nhóm; không hoàn thành đúng hạn, hoặc
chất lượng hầu hết phần việc được giao không đạt</td>
<td>Tham gia một số hoạt động nhóm, nhưng rất thụ động; hoàn thành và
đảm bảo chất lượng một số phần việc được giao, nhưng nhiều việc chưa đạt
chất lượng, hoặc chưa đúng hạn</td>
<td>Tham gia đa số hoạt động nhóm, nhưng còn thụ động; hoàn thành và đảm
bảo chất lượng đa số phần việc được giao, nhưng một số việc chưa đạt
chất lượng, hoặc chưa đúng hạn</td>
<td>Sẵn sàng tham gia đầy đủ các hoạt động nhóm; hoàn thành đúng hạn và
đảm bảo chất lượng các phần việc được giao</td>
<td>Chủ động, sẵn sàng tham gia các hoạt động nhóm; hoàn thành đúng hạn
và đạt chất lượng xuất sắc các phần việc được giao</td>
</tr>
<tr>
<td>4.2. Khả năng giao tiếp và hợp tác</td>
<td>Chỉ có khả năng giao tiếp và hợp tác ở mức rất yếu</td>
<td>Giao tiếp cơ bản, hỗ trợ các thành viên khác để hoàn thành công việc
chung hạn chế</td>
<td>Giao tiếp cơ bản, hỗ trợ các thành viên khác để hoàn thành công việc
chung, nhưng chưa chủ động</td>
<td>Giao tiếp hiệu quả, sẵn sàng hỗ trợ các thành viên khác để hoàn
thành công việc chung</td>
<td>Giao tiếp chủ động, tích cực hỗ trợ các thành viên khác để hoàn
thành công việc chung</td>
</tr>
<tr>
<td>4.3. Yêu cầu với báo cáo, thuyết trình và demo</td>
<td><p>- Báo cáo chưa đúng định dạng, nội dung thiếu mục</p>
<p>- Thuyết trình yếu: không trình bày rõ nội dung</p>
<p>- Demo (nếu có) không hoạt động, hoặc rất nhiều lỗi</p></td>
<td><p>- Báo cáo cơ bản đúng định dạng, bố cục chưa hợp lý, nội dung cơ
bản đủ các mục chính</p>
<p>- Thuyết trình: chỉ trình bày được một số</p>
<p>- Demo (nếu có): một số các tính năng hoạt động, còn nhiều
lỗi</p></td>
<td><p>- Báo cáo cơ bản đúng định dạng, bố cục tương đối hợp lý, nội
dung đủ các mục chính</p>
<p>- Thuyết trình: trình bày được các ý chính</p>
<p>- Demo (nếu có): đa số các tính năng hoạt động, còn một số
lỗi</p></td>
<td><p>- Báo cáo đúng định dạng, bố cục hợp lý, nội dung đủ các mục</p>
<p>- Thuyết trình mạch lạc, trình bày được các ý chính</p>
<p>- Demo (nếu có): đủ các tính năng hoạt động</p></td>
<td><p>- Báo cáo đúng định dạng, bố cục hợp lý, nội dung đủ các mục</p>
<p>- Thuyết trình xuất sắc, trình bày đầy đủ nội dung</p>
<p>- Demo (nếu có): đầy đủ các tính năng, đúng yêu cầu hoạt
động</p></td>
</tr>
</tbody>
</table>

# Public_254
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th rowspan="2">|<image_1>|</th>
<th><strong>VIETTEL AI RACE</strong></th>
<th>Public 254</th>
</tr>
<tr>
<th><strong>Giấu tin trong ảnh</strong></th>
<th>Lần ban hành: 1</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

# Giới thiệu về giấu tin trong ảnh

## 1 Khái niệm về giấu tin trong ảnh

Giấu tin trong ảnh là kỹ thuật giấu tin mà trong đó thông tin sẽ được giấu trong dữ liệu ảnh. Các kỹ thuật giấu tin trong ảnh được thực hiện sao cho chất lượng ảnh ít bị thay đổi nhất để bằng mắt thường con người không thể phát hiện ra sự thay đổi đó. Cụ thể, các thuật toán giấu tin sẽ tìm cách khai thác và lợi dụng sự hạn chế về cảm nhận hình ảnh của con người để giấu thông tin. Tùy theo từng ứng dụng mà các kỹ thuật giấu tin có những tính chất và yêu cầu khác nhau. Nhưng tựu chung lại, các kỹ thuật giấu tin trong ảnh không chỉ phải đảm bảo tất cả các tính chất của kỹ thuật giấu tin yêu cầu mà còn phải đảm bảo một số tính chất riêng đối với môi trường ảnh. Ngày nay, kỹ thuật giấu tin trong ảnh thường được sử dụng để truyền thông tin mật giữa người dùng mà người khác không thể biết được. Chính từ những lợi ích mà các kỹ thuật giấu tin trong ảnh mang lại nên hiện nay lĩnh vực giấu tin trong ảnh đang được phát triển nhanh chóng và mạnh mẽ. Ví dụ như đối với các nước phát triển, chữ kí tay đã được số hóa và lưu trữ sử dụng như là hồ sơ cá nhân của các dịch vụ ngân hàng và tài chính, nó được dùng để xác thực trong các thẻ tín dụng của người tiêu dùng. Ngoài ra phần mềm Microsoft Word cũng cho phép người dùng lưu trữ chữ kí trong ảnh nhị phân rồi gắn vào vị trí nào đó trong file văn bản để đảm bảo tính toàn vẹn của thông tin.

##  1.2 Một số định dạng ảnh và công cụ xử lý ảnh

  1. Một số định dạng ảnh


Hiện nay có nhiều loại định dạng ảnh khác nhau có thể được lựa chọn để giấu tin. Mỗi định dạng ảnh sẽ có tiêu chuẩn và tính chất khác nhau. Do đó, để tối ưu hóa quá trình giấu tin thì trước khi tiến hành giấu tin người giấu tin cần phải xem xét và đánh giá các định dạng, tiêu chuẩn ảnh. Tiếp theo, giáo trình sẽ cung cấp một số mô tả về một số định dạng ảnh đang được sử dụng phổ biến hiện nay.
\- **Định dạng ảnh BMP** : BMP được biết đến với tên tiếng Anh khác là Windows bitmap, là một định dạng ảnh phổ biến. Định dạng ảnh BMP được sử dụng để lưu trữ hình ảnh kỹ thuật số bitmap, độc lập với thiết bị hiển thị và có khả năng lưu trữ hình ảnh kỹ thuật số hai chiều cả đơn màu, đa màu, ở các độ sâu màu khác nhau tùy vào dữ liệu nén, các kênh alpha và các cấu hình màu. Một tập tin Bitmap bao gồm các cấu trúc theo thứ tự như biểu trên bảng sau.
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><strong>Tên cấu trúc</strong></td>
<td><strong>Kích thước</strong></td>
<td><strong>Mục đích</strong></td>
</tr>
<tr>
<td>Tiêu đề tệp Bitmap</td>
<td>14 byte</td>
<td>Lưu trữ thông tin tổng quát về tệp hình ảnh bitmap</td>
</tr>
<tr>
<td>Mặt nạ thêm bit</td>
<td>12 hoặc 16 byte</td>
<td>Xác định định dạng điểm ảnh.</td>
</tr>
<tr>
<td>Tiêu đề DIB</td>
<td rowspan="6">Tùy theo các phiên bản</td>
<td>Lưu trữ thông tin chi tiết về ảnh bitmap và xác định định dạng điểm
ảnh</td>
</tr>
<tr>
<td>Bảng màu</td>
<td>Xác định màu sắc được sử dụng bởi dữ liệu hình ảnh bitmap</td>
</tr>
<tr>
<td>Gap1</td>
<td>Cân chỉnh cấu trúc</td>
</tr>
<tr>
<td>Mảng điểm ảnh</td>
<td>Xác định giá trị các điểm ảnh</td>
</tr>
<tr>
<td>Gap2</td>
<td>Cân chỉnh cấu trúc</td>
</tr>
<tr>
<td>Màu ICC</td>
<td>Xác định cấu hình màu để quản lý màu sắc</td>
</tr>
</tbody>
</table> 

Từ bảng trên có thể thấy được định dạng BMP có cấu trúc tương đối đơn giản. Ngoài ra, khi ảnh BMP không nén thì các ảnh này chỉ là một ma trận các điểm ảnh. Trong đó, mỗi một phần tử của ma trận biểu diễn một điểm ảnh, bao gồm các thành phần đỏ (kí hiệu R), xanh lục (kí hiệu G), xanh lam (kí hiệu B), alpha (kí hiệu A), các thành phần bổ sung (kí hiệu X). Ngày này các kỹ thuật giấu tin trong ảnh sử dụng ảnh theo chuẩn BMP không được sử dụng phổ biến. Bởi vì các ảnh này có cấu trúc đơn giản, do đó giấu được ít thông tin cũng như thông tin sau khi giấu dễ bị phát hiện.
\- **Định dạng ảnh PNG** : PNG (Portable Network Graphics) là một dạng ảnh sử dụng phương pháp nén dữ liệu không làm mất đi dữ liệu gốc. PNG hỗ trợ các ảnh dựa trên bảng màu (với bảng màu RGB 24 bit hoặc RGBA 32 bit), ảnh xám (có hoặc không có kênh alpha) và ảnh RGB/RGBA không có bảng màu đầy đủ. Các giá trị trong phần tiêu đề của định dạng ảnh PNG được liệt kê trong bảng sau.
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><strong>Giá trị</strong></td>
<td><strong>Mục đích</strong></td>
</tr>
<tr>
<td>89</td>
<td>Có các bit cao thiết lập để phát hiện các hệ thống truyền dẫn không
hỗ trợ dữ liệu 8 bit, giảm nguy cơ mà một tập tin văn bản bị hiểu nhầm
là một tập PNG, hoặc ngược lại.</td>
</tr>
<tr>
<td>50 4E 47</td>
<td>Là chữ cái PNG trong bảng mã ASCII, cho phép xác định định dạng
PNG</td>
</tr>
<tr>
<td>0D 0A</td>
<td>Là một kiểu kết thúc của DOS giúp phát hiện dòng kết thúc chuyển đổi
dữ liệu</td>
</tr>
<tr>
<td>1A</td>
<td>Một byte thông báo dừng hiển thị của tập tin</td>
</tr>
</tbody>
</table> 

Ngoài các thành phần tiêu đề tập tin PNG được mô tả trong bảng trên thì chuẩn PNG còn có các đoạn mã lưu trữ dữ liệu (chunk). Đoạn mã lưu trữ dữ liệu này là một đoạn thông tin được sử dụng trong nhiều định dạng đa phương tiện. Mỗi một đoạn mã lưu trữ dữ liệu truyền tải thông tin nhất định về hình ảnh. Có hai loại đoạn mã lưu trữ dữ liệu: một là đoạn mã chính, hai là đoạn mã phụ trợ. Một bộ giải mã có khả năng đọc các đoạn mã lưu trữ dữ liệu quan trọng và hiển thị tệp PNG. Các đoạn mã lưu trữ dữ liệu phụ trợ là các thuộc tính hình ảnh khác có thể được lưu trữ trong các tệp PNG bao gồm các giá trị gamma, màu nền... Các đoạn mã lưu trữ dữ liệu quan trọng bao gồm IHDR, PLTE, IDAT, IEND. Giá trị của các IHDR, PLTE, IDAT, IEND được mô tả trong tài liệu.
\- **Định dạng ảnh JPEG** : JPEG (Joint Photographic Experts Group) một nhóm các nhà nghiên cứu đã phát minh ra định dạng này để hiển thị các hình ảnh đầy đủ màu hơn mà kích thước file lại nhỏ hơn. Chuẩn JPEG có thể hiển thị các hình ảnh với các màu chính xác lên đến 16 triệu màu. Cấu trúc ảnh JPEG bao gồm nhiều phân đoạn (segment), ở mỗi đoạn là 1 cờ (marker), mỗi cờ bắt đầu bằng byte 0xFF và theo sau đó là 1 byte chỉ ra mã của loại cờ. Một số cờ chỉ gồm 2 byte; sau 2 byte cờ là 2 byte chỉ ra độ dài của đoạn không tính 2 byte của cờ. Với những đoạn chứa dữ liệu nén (entropy-coded data), 2 byte xác định độ dài của đoạn không tính độ dài của dữ liệu nén. Ảnh JPEG không yêu cầu các đoạn phải nằm theo đúng thứ tự nhưng đoạn đầu tiên của ảnh phải là đoạn SOI; đoạn cuối cùng là đoạn EOI. Một số thuộc tính của những cờ thường gặp trong ảnh JPEG được mô tả trong bảng sau.
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td><strong>Tên rút gọn</strong></td>
<td><strong>Giá trị cờ</strong></td>
<td><strong>Mô tả tóm tắt</strong></td>
</tr>
<tr>
<td>SOI</td>
<td>0xFF, 0xD8</td>
<td>Đánh dấu bắt đầu ảnh JPEG</td>
</tr>
<tr>
<td>SOFn</td>
<td>0xFF, 0xC4</td>
<td>Bắt đầu của khung, mô tả các thông số của ảnh: chiều cao, chiều
rộng, số lượng thành phần màu, tỉ lệ số lượng thành phần màu.</td>
</tr>
<tr>
<td>DHT</td>
<td>0xFF, 0xC4</td>
<td>Xác định bảng Huffman. Trong ảnh JPEG có thể xuất hiện nhiều đoạn
DHT</td>
</tr>
<tr>
<td>DQT</td>
<td>0xFF, 0xDB</td>
<td>Xác định bảng lượng tử hóa. Trong ảnh JPEG có thể xuất hiện nhiều
đoạn DQT</td>
</tr>
<tr>
<td>SOS</td>
<td>0xFF, 0xDA</td>
<td>Đánh dấu bắt đầu quét ảnh từ trên xuống dưới.</td>
</tr>
<tr>
<td>APPn</td>
<td>0xFF, 0xEn</td>
<td>Dành riêng cho đoạn ứng dụng, đánh dấu bắt đầu của đoạn dữ liệu ứng
dụng.</td>
</tr>
<tr>
<td>COM</td>
<td>0xFF, 0xEE</td>
<td>Cờ bắt đầu chứa lời bình (chú thích).</td>
</tr>
<tr>
<td>EOI</td>
<td>0xFF, 0xD9</td>
<td>Đánh dấu kết thúc ảnh</td>
</tr>
</tbody>
</table> 

Từ bảng trên có thể thấy được ảnh JPEG có cấu trúc phức tạp bao gồm nhiều thành phần khác nhau. Dựa trên đặc điểm của các thành phần này, các phương pháp giấu tin trong ảnh sẽ khai thác để thực hiện giấu tin.

  2. Một số công cụ xử lý ảnh phổ biến


Các công cụ xử lý ảnh hiện nay đóng vai trò quan trọng trong việc triển khai các phương pháp giấu tin trong ảnh và xử lý ảnh chuyên sâu. Sau đây là một số công cụ thường để xử lý ảnh phổ biến: Corel PaintShop Pro, GIMP, Adobe Photoshop Elements, Paint.NET, Photo Pos Pro, Zoner Photo Studio, PhotoScape, Xara Photo & Graphic Designer.

# Public_257
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th rowspan="2">|<image_1>|</th>
<th><strong>VIETTEL AI RACE</strong></th>
<th>Public 257</th>
</tr>
<tr>
<th><strong>Quy định yêu cầu kỹ thuật đối với phần mềm ký số, phần mềm
kiểm tra chữ ký số và Cổng kết nối dịch vụ chứng thực chữ ký số công
cộng</strong></th>
<th>Lần ban hành: 1</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

_Căn cứ Luật giao dịch điện tử ngày 22 tháng 06 năm 2023;_

_Căn cứ Nghị định số 23/2025/NĐ-CP ngày 21 tháng 02 năm 2025 của Chính phủ quy định về chữ ký điện tử và dịch vụ tin cậy;_

_Căn cứ Nghị định số 55/2025/NĐ-CP ngày 02 tháng 3 năm 2025 của Chính phủ quy định chức năng, nhiệm vụ và cơ cấu tổ chức của Bộ Khoa học và Công nghệ;_

_Theo đề nghị của Vụ trưởng Vụ Pháp chế và Giám đốc Trung tâm Chứng thực điện tử quốc gia;_

_Bộ trưởng Bộ Khoa học và Công nghệ ban hành Thông tư quy định yêu cầu kỹ thuật đối với phần mềm ký số, phần mềm kiểm tra chữ ký số và Cổng kết nối dịch vụ chứng thực chữ ký số công cộng._

# 1\. QUY ĐỊNH CHUNG

## 1.1. Phạm vi điều chỉnh

Thông tư này quy định yêu cầu kỹ thuật đối với phần mềm ký số, phần mềm kiểm tra chữ ký số và Cổng kết nối dịch vụ chứng thực chữ ký số công cộng.

## 1.2 . Đối tượng áp dụng

Thông tư này áp dụng đối với tổ chức, cá nhân sử dụng phần mềm ký số, phần mềm kiểm tra chữ ký số; các tổ chức, cá nhân phát triển phần mềm ký số, phần mềm kiểm tra chữ ký số; các tổ chức cung cấp dịch vụ chứng thực chữ ký số; các tổ chức cung cấp dịch vụ chứng thực chữ ký điện tử chuyên dùng đảm bảo an toàn; các tổ chức cung cấp dịch vụ chứng thực chữ ký điện tử nước ngoài được công nhận tại Việt Nam; chủ quản các hệ thống thông tin phục vụ giao dịch điện tử có sử dụng chữ ký số và các tổ chức, cá nhân có liên quan khác.

## 1.3. Giải thích từ ngữ

Trong Thông tư này, các từ ngữ dưới đây được hiểu như sau:

\- “Cặp khóa bất đối xứng” là khóa công khai và khóa bí mật tương ứng.

\- “Khóa bí mật” là thành phần của cặp khóa bất đối xứng được sử dụng để ký thông điệp dữ liệu.

\- “Khóa công khai” là thành phần của cặp khóa bất đối xứng được sử dụng để xác thực chữ ký số trên thông điệp dữ liệu.

\- “Chủ thể ký” là cá nhân hoặc tổ chức sở hữu chứng thư chữ ký số và sử dụng khóa bí mật tương ứng để thực hiện ký số trên thông điệp dữ liệu.

\- “Chứng thư chữ ký số” là một dạng chứng thư điện tử do tổ chức cung cấp dịch vụ chứng thực chữ ký số cấp nhằm cung cấp thông tin về khóa công khai của một cá nhân, tổ chức từ đó xác nhận cá nhân, tổ chức là chủ thể ký thông qua việc sử dụng khóa bí mật tương ứng.

\- “Phần mềm ký số” là chương trình độc lập hoặc một thành phần (module) phần mềm hoặc giải pháp có chức năng ký số vào thông điệp dữ liệu.

\- "Phần mềm kiểm tra chữ ký số" là chương trình độc lập hoặc một thành phần (module) phần mềm hoặc giải pháp có chức năng kiểm tra tính hợp lệ của chữ ký số trên thông điệp dữ liệu đã ký.

\- "Đường dẫn tin cậy của chứng thư chữ ký số" là thông tin đường dẫn trên chứng thư chữ ký số xác thực tổ chức cung cấp dịch vụ chứng thực chữ ký số đã cấp phát ra chứng thư chữ ký số đó.

# 2\. Yêu cầu kỹ thuật đối với chức năng phần mềm ký số, phần mềm kiểm tra chữ ký số

## 2.1 Yêu cầu chung

Tuân thủ các yêu cầu và tiêu chuẩn kỹ thuật về chữ ký số trên thông điệp dữ liệu tại Phụ lục I ban hành kèm theo Thông tư này.

## 2.2 Yêu cầu về chức năng

\- Chức năng xác thực chủ thể ký và ký số:

\+ Kiểm tra được thông tin chủ thể ký trên chứng thư chữ ký số;

\+ Cho phép chủ thể ký sử dụng khóa bí mật để thực hiện việc ký số vào thông điệp dữ liệu. Khoá bí mật lưu trong thiết bị được chủ thể ký sử dụng để ký số phải tuân thủ các yêu cầu và tiêu chuẩn kỹ thuật tại Phụ lục I ban hành kèm theo Thông tư này;

\+ Cho phép chuyển đổi định dạng thông điệp dữ liệu thành các định dạng được nêu tại Phụ lục I ban hành kèm theo Thông tư này;

\+ Gắn kèm chữ ký số và chứng thư chữ ký số vào thông điệp dữ liệu sau khi ký số;

\+ Hỗ trợ cài đặt, tích hợp chứng thư chữ ký số của Tổ chức cung cấp dịch vụ chứng thực chữ ký số quốc gia và chứng thư chữ ký số thuộc Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

\+ Đáp ứng các giao thức gửi nhận thông điệp dữ liệu của phần mềm ký số theo các yêu cầu và tiêu chuẩn tại Phụ lục I ban hành kèm theo Thông tư này.

\- Chức năng kiểm tra hiệu lực của chứng thư chữ ký số:

\+ Thông tin trong chứng thư chữ ký số được định danh theo quy định pháp luật về định danh và xác thực điện tử;

\+ Chứng thư chữ ký số của chủ thể ký phải được kiểm tra theo đường dẫn tin cậy của chứng thư chữ ký số đó và phải liên kết đến chứng thư chữ ký số gốc của Tổ chức cung cấp dịch vụ chứng thực chữ ký số quốc gia hoặc thuộc Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

\+ Chứng thư chữ ký số phải có hiệu lực tại thời điểm ký số và đáp ứng các tiêu chí tại Phụ lục II ban hành kèm theo Thông tư này.

\- Chức năng kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng: Hướng dẫn kết nối được quy định tại Chương III Thông tư này.

\- Chức năng lưu trữ và hủy bỏ các thông tin kèm theo thông điệp dữ liệu ký số, bao gồm:

\+ Chứng thư chữ ký số tương ứng với khóa bí mật mà chủ thể ký sử dụng để ký thông điệp dữ liệu tại thời điểm ký số;

\+ Danh sách chứng thư chữ ký số thu hồi tại thời điểm ký trong chứng thư chữ ký số của chủ thể ký;

\+ Quy chế chứng thực của tổ chức cung cấp dịch vụ chứng thực chữ ký số đã cấp chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu;

\+ Kết quả kiểm tra trạng thái chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu đã ký.

\- Chức năng thay đổi (thêm, bớt) chứng thư chữ ký số của cơ quan, tổ chức tạo lập cấp, phát hành chứng thư chữ ký số:

Cho phép tích hợp và hiển thị đầy đủ các tổ chức cung cấp dịch vụ chứng thực chữ ký số và Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam.

\- Chức năng thông báo bằng chữ hoặc ký hiệu cho chủ thể ký biết việc ký số vào thông điệp dữ liệu thành công hay không thành công, bao gồm việc:

\+ Hiển thị thông báo ký số thành công hoặc không thành công;

\+ Xem được thông điệp dữ liệu đã ký sau khi hoàn thành ký số;

\+ Tải được thông điệp dữ liệu đã ký về thiết bị.

## 2.3 Yêu cầu chung

Tuân thủ các yêu cầu và tiêu chuẩn kỹ thuật về chữ ký số trên thông điệp dữ liệu tại Phụ lục I ban hành kèm theo Thông tư này.

## 2.4 Yêu cầu về chức năng

\- Chức năng kiểm tra tính hợp lệ của chữ ký số trên thông điệp dữ liệu:

\+ Cho phép xác thực chữ ký số trên thông điệp dữ liệu theo nguyên tắc chữ ký số được tạo ra đúng với khóa bí mật tương ứng với khóa công khai trên chứng thư chữ ký số;

\+ Cho phép kiểm tra chứng thư chữ ký số của chủ thể ký theo đường dẫn tin cậy của chứng thư chữ ký số đó và phải liên kết đến Tổ chức cung cấp dịch vụ chứng thực chữ ký số quốc gia hoặc thuộc Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

\+ Bảo đảm chứng thư chữ ký số phải có hiệu lực tại thời điểm ký số và đáp ứng các tiêu chí tại Phụ lục II ban hành kèm theo Thông tư này;

\+ Cho phép kiểm tra tính toàn vẹn của thông điệp dữ liệu ký số theo các bước sau:

\- Giải mã chữ ký số trên thông điệp dữ liệu để có thông tin về mã băm của thông điệp dữ liệu;

\- Sử dụng thuật toán hàm băm an toàn đã tạo ra mã băm trên chữ ký số để thực hiện tạo mã băm cho thông điệp dữ liệu;

\- So sánh sự trùng khớp của hai mã băm để kiểm tra tính toàn vẹn của thông điệp dữ liệu ký số.

\+ Đảm bảo tính hợp lệ của chữ ký số trên thông điệp dữ liệu đã ký theo các tiêu chí tại Phụ lục II ban hành kèm theo Thông tư này;

\+ Hỗ trợ cài đặt, tích hợp chứng thư chữ ký số của Tổ chức cung cấp dịch vụ chứng thực chữ ký số quốc gia và chứng thư chữ ký số thuộc danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

\+ Đáp ứng các giao thức gửi nhận thông điệp dữ liệu của phần mềm ký số theo tiêu chuẩn tại Phụ lục I ban hành kèm theo Thông tư này.

\- Chức năng lưu trữ và hủy bỏ các thông tin kèm theo thông điệp dữ liệu ký số:

\+ Chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu đã ký;

\+ Danh sách chứng thư chữ ký số thu hồi tại thời điểm ký được thể hiện trong chứng thư chữ ký số đính kèm thông điệp dữ liệu đã ký;

\+ Quy chế chứng thực của các tổ chức cung cấp dịch vụ chứng thực chữ ký số cấp phát chứng thư chữ ký số tương ứng với các chữ ký số trên thông điệp dữ liệu đã ký;

\+ Kết quả kiểm tra trạng thái chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu đã ký.

\- Chức năng thay đổi (thêm, bớt) chứng thư chữ ký số của cơ quan, tổ chức tạo lập, cấp, phát hành chứng thư chữ ký số.

\- Chức năng thông báo bằng chữ hoặc ký hiệu việc kiểm tra tính hợp lệ của chữ ký số là hợp lệ hay không hợp lệ:

\+ Hiển thị thông báo chữ ký số trên thông điệp dữ liệu đã ký hợp lệ hay không hợp lệ;

\+ Hiển thị các thông tin về chữ ký số và chứng thư chữ ký số trên thông điệp dữ liệu đã ký, với tối thiểu các trường thông tin sau: thông tin về cơ quan, tổ chức tạo lập, cấp, phát hành chứng thư chữ ký số; thông tin về chủ thể ký; thông tin về thời điểm ký số hoặc dấu thời gian (nếu có); tính toàn vẹn của thông điệp dữ liệu đã ký; tính hợp lệ của chữ ký số tại thời điểm ký.

# 3\. CỔNG KẾT NỐI DỊCH VỤ CHỨNG THỰC CHỮ KÝ SỐ CÔNG CỘNG

## 3.1 Cổng kết nối dịch vụ chứng thực chữ ký số công cộng

Cổng kết nối dịch vụ chứng thực chữ ký số công cộng là hệ thống thông tin phục vụ kết nối dịch vụ chứng thực chữ ký số công cộng với các hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số để bảo đảm tính xác thực, tính toàn vẹn và tính chống chối bỏ của thông điệp dữ liệu.

## 3.2 Kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng

\- Các tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng, cụ thể:

\+ Thực hiện theo Hướng dẫn kết nối tại Phụ lục III ban hành kèm theo Thông tư này;

\+ Cung cấp các đặc tả, thông số kỹ thuật và thông tin phục vụ kết nối cho Tổ chức cung cấp dịch vụ chứng thực điện tử quốc gia;

\+ Cập nhật các thông số kỹ thuật hoặc thông tin phục vụ kết nối khi có thay đổi cho Tổ chức cung cấp dịch vụ chứng thực điện tử quốc gia.

\- Các hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số tích hợp với Cổng kết nối dịch vụ chứng thực chữ ký số công cộng để bảo đảm tính xác thực, tính toàn vẹn và tính chống chối bỏ của thông điệp dữ liệu, cụ thể:

\+ Thực hiện theo Hướng dẫn kết nối tại Phụ lục III ban hành kèm theo Thông tư này;

\+ Bảo đảm chức năng ký số của hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số đáp ứng các quy định tại Điều 5 Thông tư này;

\+ Tổ chức cung cấp dịch vụ chứng thực điện tử quốc gia cung cấp các đặc tả, thông số kỹ thuật và thông tin phục vụ việc kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng.

\- Đầu mối hỗ trợ, hướng dẫn kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng: Trung tâm Chứng thực điện tử quốc gia, Bộ Khoa học và Công nghệ.

# 4\. ĐIỀU KHOẢN THI HÀNH

## 4.1 Tổ chức thực hiện

\- Trung tâm Chứng thực điện tử quốc gia có trách nhiệm hướng dẫn thực hiện các nội dung của Thông tư này và công bố thông tin theo quy định tại điểm c khoản 2 Điều 9 Thông tư này.

\- Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng, tổ chức cung cấp dịch vụ chứng thực chữ ký điện tử chuyên dùng đảm bảo an toàn, Tổ chức cung cấp dịch vụ chứng thực chữ ký điện tử nước ngoài được công nhận tại Việt Nam có trách nhiệm công bố các đặc tả kỹ thuật (tài liệu và bộ công cụ), chứng thư chữ ký số liên quan đến tổ chức cung cấp dịch vụ chứng thực chữ ký số và các tiêu chuẩn chữ ký số trên trang tin điện tử của tổ chức cung cấp dịch vụ chứng thực chữ ký số đó.

\- Tổ chức, cá nhân phát triển, sử dụng phần mềm ký số, phần mềm kiểm tra chữ ký số có trách nhiệm tuân thủ các quy định về yêu cầu kỹ thuật, hướng dẫn sử dụng đối với phần mềm ký số, phần mềm kiểm tra chữ ký số.

## 4.2 Hiệu lực thi hành

\- Thông tư này có hiệu lực thi hành kể từ ngày tháng năm .

\- Chánh Văn phòng, Giám đốc Trung tâm Chứng thực điện tử quốc gia, Thủ trưởng các cơ quan, đơn vị thuộc Bộ, Giám đốc Sở Khoa học và Công nghệ các tỉnh, thành phố trực thuộc Trung ương, tổ chức, cá nhân có liên quan chịu trách nhiệm thi hành Thông tư này.

\- Trong quá trình thực hiện, nếu có khó khăn, vướng mắc, cơ quan, tổ chức, cá nhân phản ánh kịp thời về Bộ Khoa học và Công nghệ (Trung tâm Chứng thực điện tử quốc gia) để xem xét, giải quyết./.
<table>
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
</tbody>
</table> 

**Phụ lục I**

**DANH MỤC TIÊU CHUẨN KỸ THUẬT VỀ CHỮ KÝ SỐ  
TRÊN THÔNG ĐIỆP DỮ LIỆU DÙNG CHO PHẦN MỀM KÝ SỐ VÀ PHẦN MỀM KIỂM TRA CHỮ KÝ SỐ**

_(Ban hành kèm theo Thông tư số /2025/TT-BKHCN ngày tháng năm 2025 của Bộ trưởng Bộ Khoa học và Công nghệ)_
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><em><strong>Số TT</strong></em></th>
<th><em><strong>Loại tiêu chuẩn</strong></em></th>
<th><em><strong>Ký hiệu tiêu chuẩn</strong></em></th>
<th><em><strong>Tên đầy đủ của tiêu chuẩn</strong></em></th>
<th><em><strong>Quy định áp dụng</strong></em></th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="5"><em><strong>Tiêu chuẩn về định dạng thông điệp dữ
liệu</strong></em></td>
</tr>
<tr>
<td><em>11</em></td>
<td><em>Bộ ký tự và mã hóa</em></td>
<td><em>ASCII</em></td>
<td><em>American Standard Code for Information Interchange</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>12</em></td>
<td><em>Bộ ký tự và mã hóa cho tiếng Việt</em></td>
<td><p><em>TCVN</em></p>
<p><em>6909:2001</em></p></td>
<td><em>TCVN 6909:2001 “ Công nghệ thông tin-Bộ mã ký tự tiếng Việt
16-bit”</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>13</em></td>
<td><em>Trình diễn bộ ký tự</em></td>
<td><em>UTF-8</em></td>
<td><em>8-bit Universal Character Set (UCS)/ Unicode Transformation
Format</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td rowspan="2"><em>14</em></td>
<td rowspan="2"><em>Ngôn ngữ định dạng thông điệp dữ liệu</em></td>
<td><p><em>XML v1.0</em></p>
<p><em>(5th Edition)</em></p></td>
<td><em>Extensible Markup Language version 1.0 (5th Edition)</em></td>
<td rowspan="2"><em>Khuyến nghị áp dụng một trong hai tiêu
chuẩn</em></td>
</tr>
<tr>
<td><em>XML v1.1 (2nd Edition)</em></td>
<td><em>Extensible Markup Language version 1.1</em></td>
</tr>
<tr>
<td><em>15</em></td>
<td><em>Định nghĩa các lược đồ trong tài liệu XML</em></td>
<td><em>XML Schema version 1.1</em></td>
<td><em>XML Schema version 1.1</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>16</em></td>
<td><em>Trao đổi dữ liệu đặc tả tài liệu XML</em></td>
<td><em>XML v2.4.2</em></td>
<td><em>XML Metadata Interchange version 2.4.2</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>77</em></td>
<td><em>Quản lý tài liệu - Định dạng tài liệu di động</em></td>
<td><em>ISO 32000-1:2008</em></td>
<td><em>Document management - Portable document format</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>88</em></td>
<td><em>Định dạng trao đổi dữ liệu theo ký hiệu đối tượng
Javascript</em></td>
<td><em>RFC7159</em></td>
<td><em>The JavaScript Object Notation (JSON) Data Interchange
Format</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td colspan="5"><em><strong>Tiêu chuẩn về ký số, kiểm tra chữ ký
số</strong></em></td>
</tr>
<tr>
<td><em><strong>21</strong></em></td>
<td colspan="4"><em><strong>Tiêu chuẩn về ký số trên thiết bị quản lý
khóa bí mật, phần mềm ký số, tạo chữ ký số, chứng thư số, phần mềm kiểm
tra chữ ký số.</strong></em></td>
</tr>
<tr>
<td rowspan="4"><em>21.1</em></td>
<td rowspan="4"><em>Thuật toán mã hóa</em></td>
<td><em>TCVN 7816:2007</em></td>
<td><em>Công nghệ thông tin. Kỹ thuật mật mã - thuật toán mã dữ liệu
AES</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>NIST 800-67</em></td>
<td><em>Recommendation for the Triple Data Encryption Algorithm (TDEA)
Block Cipher</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>PKCS#1</em></td>
<td><p><em>RSA Cryptography Standard (Phiên bản 2.1 trở lên)</em></p>
<p><em>Áp dụng, sử dụng lược đồ RSAES-OAEP để mã hoá</em></p>
<p><em>Độ dài khóa tối thiểu là 2048 bit</em></p></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em>ECC</em></td>
<td><em>Elliptic Curve Crytography</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td rowspan="3"><em>21.2</em></td>
<td rowspan="3"><em>Thuật toán chữ ký số</em></td>
<td><em>TCVN 7635:2007</em></td>
<td><em>Các kỹ thuật mật mã - Chữ ký số</em></td>
<td rowspan="3"><p><em>- Áp dụng một trong ba tiêu chuẩn.</em></p>
<p><em>- Đối với tiêu chuẩn TCVN 7635:2007 và PKCS#1:</em></p>
<p><em>+ Phiên bản 2.1</em></p>
<p><em>+ Áp dụng lược đồ RSAES-OAEP để mã hoá và RSASSA-PSS để
ký.</em></p>
<p><em>+ Độ dài khóa tối thiểu là 2048 bit</em></p>
<p><em>- Đối với tiêu chuẩn ECDSA: độ dài khóa tối thiểu là 256
bit</em></p></td>
</tr>
<tr>
<td><em>PKCS#1</em></td>
<td><em>RSA Cryptography Standard</em></td>
</tr>
<tr>
<td><em>ANSI X9.62-2005</em></td>
<td><em>Public Key Cryptography for the Financial Services Industry: The
Elliptic Curve Digital Signature Algorithm (ECDSA)</em></td>
</tr>
<tr>
<td rowspan="2"><em>21.3</em></td>
<td rowspan="2"><em>Hàm băm an toàn</em></td>
<td><em>FIPS PUB 180-4</em></td>
<td><em>Secure Hash Algorithms</em></td>
<td rowspan="2"><em>Áp dụng một trong các hàm băm sau:<br/>
SHA-224,<br/>
SHA-256,<br/>
SHA-384,<br/>
SHA-512,<br/>
SHA-512/224,<br/>
SHA-512/256,<br/>
SHA3-224,<br/>
SHA3-256,<br/>
SHA3-384,<br/>
SHA3-512, SHAKE128, SHAKE256</em></td>
</tr>
<tr>
<td><em>FIPS PUB 202</em></td>
<td><em>SHA-3 Standard: Permutation-Based Hash and Extendable-Output
Functions</em></td>
</tr>
<tr>
<td rowspan="2"><em>21.4</em></td>
<td rowspan="2"><em>Cú pháp mã hóa và cách xử lý thông điệp dữ liệu định
dạng XML</em></td>
<td><em>XML Encryption Syntax and Processing</em></td>
<td><em>XML Encryption Syntax and Processing</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>XML Signature Syntax and Processing</em></td>
<td><em>XML Signature Syntax and Processing</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>21.5</em></td>
<td><em>Quản lý khóa công khai thông điệp dữ liệu định dạng
XML</em></td>
<td><em>XKMS v2.0</em></td>
<td><em>XML Key Management Specification version 2.0</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>21.6</em></td>
<td><em>Cú pháp thông điệp mật mã cho ký, mã hóa</em></td>
<td><em>PKCS#7 v1.5 (RFC 2315)</em></td>
<td><em>Cryptographic message syntax for file-based signing and
encrypting version 1.5</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>11.7</em></td>
<td><em>Tiêu chuẩn về chữ ký điện tử nâng cao dành cho thông điệp dữ
liệu định dạng PDF</em></td>
<td><em>ETSI EN 319 142-1</em></td>
<td><em>Electronic Signatures and Infrastructures (ESI) - PAdES digital
signatures</em></td>
<td><em>Áp dụng một trong hai tiêu chuẩn PAdES hoặc CAdES</em></td>
</tr>
<tr>
<td><em>11.8</em></td>
<td><em>Tiêu chuẩn về chữ ký điện tử nâng cao dành cho thông điệp dữ
liệu định dạng XML</em></td>
<td><em>ETSI TS 101 903</em></td>
<td><em>Electronic Signatures and Infrastructures (ESI) - XML Advanced
Electronic Signatures (XAdES)</em></td>
<td><em>Áp dụng một trong hai tiêu chuẩn XAdES hoặc CAdES</em></td>
</tr>
<tr>
<td><em>11.9</em></td>
<td><em>Tiêu chuẩn về chữ ký điện tử nâng cao dành cho thông điệp dữ
liệu định dạng JSON</em></td>
<td><em>RFC 7515</em></td>
<td><em>JSON Web Signature (JWS)</em></td>
<td><em>Bắt buộc áp dụng cho thông điệp dữ liệu định dạng JSON</em></td>
</tr>
<tr>
<td><em>11.10</em></td>
<td><em>Tiêu chuẩn về chữ ký điện tử nâng cao dành cho cú pháp tin nhắn
mật mã</em></td>
<td><em> ETSI TS 101 733</em></td>
<td><em>Electronic Signatures and Infrastructures (ESI) - CMS Advanced
Electronic Signatures (CAdES)</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em><strong>.2</strong></em></td>
<td colspan="4"><em><strong>Tiêu chuẩn về hệ thống, thiết bị lưu trữ và
sử dụng khóa bí mật</strong></em></td>
</tr>
<tr>
<td><em>22.1</em></td>
<td><em>Yêu cầu an toàn dành cho mô đun bảo mật phần cứng</em></td>
<td><em>FIPS PUB 140-2</em></td>
<td><em>Security Requirements for Cryptographic Modules</em></td>
<td><em>- Yêu cầu tối thiểu mức 3 (level 3)</em></td>
</tr>
<tr>
<td><em>22.2</em></td>
<td><em>Yêu cầu an toàn đối với thẻ Token và Smart card</em></td>
<td><em>FIPS PUB 140-2</em></td>
<td><em>Security Requirements for Cryptographic Modules</em></td>
<td><em>- Yêu cầu tối thiểu mức 2 (level 2)</em></td>
</tr>
<tr>
<td rowspan="2"><em>.2.3</em></td>
<td rowspan="2"><em>Yêu cầu về chính sách và an toàn cho các tổ chức
cung cấp dịch vụ tin cậy: Các thành phần dịch vụ vận hành thiết bị tạo
chữ ký số và hỗ trợ tạo chữ ký số AdES</em></td>
<td><em>ETSI TS 119 431-1</em></td>
<td><em>Electronic Signatures and Infrastructures (ESI); Policy and
security requirements for trust service providers; Part 1: TSP service
components operating a remote QSCD/SCDev</em></td>
<td rowspan="2"><p><em>Áp dụng cả bộ tiêu chuẩn 2 phần;</em></p>
<p><em>Phiên bản V1.1.1 (12/2018)</em></p></td>
</tr>
<tr>
<td><em>ETSI TS 119 431-2</em></td>
<td><em>Electronic Signatures and Infrastructures (ESI); Policy and
security requirements for trust service providers; Part 2: TSP service
components supporting AdES digital signature creation</em></td>
</tr>
<tr>
<td><em>.2.4</em></td>
<td><em>Giao thức tạo chữ ký số từ xa</em></td>
<td><em>ETSI TS 119 432</em></td>
<td><em>Electronic Signatures and Infrastructures (ESI); Protocols for
remote digital signature creation</em></td>
<td><em>Phiên bản V1.1.1 (03/2019)</em></td>
</tr>
<tr>
<td><em>.2.5</em></td>
<td><em>Hệ thống tin cậy hỗ trợ ký số từ xa - Các yêu cầu
chung</em></td>
<td><em>EN 419241-1:2018</em></td>
<td><em>Trustworthy Systems Supporting Server Signing - Part 1: General
system security requirements</em></td>
<td></td>
</tr>
<tr>
<td><em>.2.6</em></td>
<td><em>Hệ thống tin cậy hỗ trợ ký số từ xa – Yêu cầu và mục tiêu (hồ sơ
bảo vệ) của thiết bị tạo chữ ký số dành cho ký số từ xa</em></td>
<td><em>EN 419241-2:2019</em></td>
<td><em>Trustworthy Systems Supporting Server Signing - Part 2:
Protection Profile for QSCD for Server Signing</em></td>
<td></td>
</tr>
<tr>
<td><em>.2.7</em></td>
<td><em>Yêu cầu và mục tiêu (hồ sơ bảo vệ) dành cho mô đun bảo mật phần
cứng của tổ chức cung cấp dịch vụ tin cậy – mô đun mã hóa dành cho các
dịch vụ tin cậy</em></td>
<td><em>EN 419221-5:2018</em></td>
<td><em>Protection Profiles for TSP Cryptographic modules - Part 5:
Cryptographic Module for Trust Services</em></td>
<td></td>
</tr>
<tr>
<td><em><strong>33</strong></em></td>
<td colspan="4"><em><strong>Tiêu chuẩn kiểm tra trạng thái chứng thư
số</strong></em></td>
</tr>
<tr>
<td><em>33.1</em></td>
<td><em>Giao thức truyền, nhận chứng thư chữ ký số và danh sách chứng
thư chữ ký số bị thu hồi</em></td>
<td><em>RFC 2585</em></td>
<td><em>Internet X.509 Public Key Infrastructure - Operational
Protocols: FTP and HTTP</em></td>
<td><em>Áp dụng một hoặc cả hai giao thức FTP và HTTP</em></td>
</tr>
<tr>
<td><em>33.2</em></td>
<td><em>Giao thức bảo mật tầng giao vận</em></td>
<td><em>RFC 8446</em></td>
<td><em>The Transport Layer Security (TLS) Protocol Version
1.3</em></td>
<td><em>Bắt buộc áp dụng <del>tối thiểu</del></em></td>
</tr>
<tr>
<td><em>33.3</em></td>
<td><em>Giao thức cho kiểm tra trạng thái chứng thư chữ ký sốtrực
tuyến</em></td>
<td><em>RFC 2560</em></td>
<td><em>X.509 Internet Public Key Infrastructure - On-line Certificate
status protocol</em></td>
<td></td>
</tr>
</tbody>
</table> 

**  
Phụ lục II**

**DANH MỤC TIÊU CHÍ ĐÁNH GIÁ HIỆU LỰC CỦA CHỨNG THƯ CHỮ KÝ SỐ VÀ CHỮ KÝ SỐ HỢP LỆ TRONG PHẦN MỀM KÝ SỐ, PHẦN MỀM KIỂM TRA CHỮ KÝ SỐ**

_(Ban hành kèm theo Thông tư số /2025/TT-BKHCN ngày tháng năm 2025 của Bộ trưởng Bộ Khoa học và Công nghệ)_
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><em><strong>Số TT</strong></em></th>
<th><em><strong>Tiêu chí đánh giá</strong></em></th>
<th><em><strong>Hiệu lực/hợp lệ</strong></em></th>
<th><em><strong>Quy định áp dụng</strong></em></th>
</tr>
</thead>
<tbody>
<tr>
<td><em><strong>1</strong></em></td>
<td colspan="3"><em><strong>Tính hiệu lực của chứng thư chữ ký
số</strong></em></td>
</tr>
<tr>
<td><em>1.1</em></td>
<td><em>Thời gian có hiệu lực của chứng thư số</em></td>
<td><em>Thời gian trên chứng thư chữ ký số còn hiệu lực tại thời điểm ký
số</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>1.2</em></td>
<td><em>Trạng thái chứng thư số qua danh sách chứng thư chữ ký số thu
hồi (CRL) được công bố tại thời điểm ký số hoặc bằng phương pháp kiểm
tra trạng thái chứng thư chữ ký số trực tuyến (OCSP) ở chế độ trực tuyến
trong trường hợp tổ chức cung cấp dịch vụ chứng thực chữ ký số có cung
cấp dịch vụ OCSP</em></td>
<td><em>Trạng thái của chứng thư chữ ký số còn hoạt động tại thời điểm
ký số</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>1.3</em></td>
<td><em>Thuật toán mật mã trên chứng thư chữ ký số</em></td>
<td><em>Các thuật toán mật mã trên chứng thư chữ ký số tuân thủ theo quy
định về quy chuẩn, tiêu chuẩn kỹ thuật bắt buộc áp dụng về chữ ký số và
dịch vụ chứng thực chữ ký số đang có hiệu lực</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>1.4</em></td>
<td><em>Mục đích, phạm vi sử dụng của chứng thư chữ ký số</em></td>
<td><em>Chứng thư chữ ký số được sử dụng đúng mục đích, phạm vi sử
dụng</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>1.5</em></td>
<td><em>Các tuyên bố khác của Tổ chức cung cấp dịch vụ chứng thực chữ ký
số</em></td>
<td><em>Các tuyên bố khác không nằm ngoài phạm vi Quy chế chứng thực của
Tổ chức cung cấp dịch vụ chứng thực chữ ký số</em></td>
<td><em>Khuyến nghị áp dụng</em></td>
</tr>
<tr>
<td><em><strong>2</strong></em></td>
<td colspan="3"><em><strong>Tính hợp lệ của chữ ký số</strong></em></td>
</tr>
<tr>
<td><em>2.1</em></td>
<td><em>Thông tin về chủ thể ký</em></td>
<td><em>Kiểm tra, xác thực được đúng thông tin chủ thể ký số</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>2.2</em></td>
<td><em>Cách thức tạo chữ ký số</em></td>
<td><em>Chữ ký số được tạo ra đúng bởi khóa bí mật tương ứng với khóa
công khai trên chứng thư chữ ký số</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>2.3</em></td>
<td><em>Chứng thư chữ ký số kèm theo thông điệp dữ liệu</em></td>
<td><em>Chứng thư chữ ký số có hiệu lực tại thời điểm ký</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
<tr>
<td><em>2.4</em></td>
<td><em>Tính toàn vẹn của thông điệp dữ liệu</em></td>
<td><em>Mã băm có được từ việc băm thông điệp dữ liệu và mã băm có được
khi giải mã chữ ký số trùng nhau</em></td>
<td><em>Bắt buộc áp dụng</em></td>
</tr>
</tbody>
</table> 

**Phụ lục III**

**HƯỚNG DẪN KẾT NỐI ĐẾN CỔNG KẾT NỐI DỊCH VỤ CHỨNG THỰC CHỮ KÝ SỐ CÔNG CỘNG**

_(Ban hành kèm theo Thông tư số /2025/TT-BKHCN ngày tháng năm 2025 của Bộ trưởng Bộ Khoa học và Công nghệ)_

**1\. Mô hình kết nối**

Mô hình kết nối với Cổng kết nối dịch vụ chứng thực chữ ký số công cộng (sau đây gọi là Cổng eSign) được mô tả tại sơ đồ như sau:

|<image_2>| _  
_ Chú thích:

\- HTTT: Hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số.
\- CA: Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng.

**2\. Các thông tin hướng dẫn kết nối**

a) Giao thức sử dụng để kết nối là API, phương thức kết nối là POST.

b) Đường dẫn kết nối các API: <https://esign.neac.gov.vn>

c) Thông tin Cổng eSign cung cấp cho các HTTT gồm: sp_id và sp_password hoặc token, trong đó:

\- sp_id: Mã xác thực được cấp cho HTTT.

\- sp_password: Mật khẩu kết nối được cấp cho HTTT tương ứng với sp_id.

\- token: Thông tin xác thực được cấp cho HTTT.

# Public_263
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th rowspan="2">|<image_1>|</th>
<th><strong>VIETTEL AI RACE</strong></th>
<th>Public 263</th>
</tr>
<tr>
<th><strong>Thu thập yêu cầu</strong></th>
<th>Lần ban hành: 1</th>
</tr>
</thead>
<tbody>
</tbody>
</table> 

# 1.Tìm hiểu lĩnh vực chuyên môn

Tóm tắt các bước thực hiện:

  * Bước 1: Làm việc nhóm (có thể dùng brainstorming) để liệt kê tất cả các từ khóa chuyên

  * môn trong lĩnh vực của ứng dụng

  * Bước 2: Phân các từ tìm ra thành nhóm cho dễ theo dõi

  * Bước 3: Giải thích nghĩa của từng từ khóa và lập bảng kết quả các từ khóa (glosary list).


Áp dụng các bước trên vào bài toán quản lí đăng kí học tín chỉ của một trường đại học, gộp bước 1 và 2, có thể gom các từ khóa trong lĩnh vực quản lí đăng kí tín chỉ thành ba nhóm như sau:

  * 
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td>Con người</td>
<td>Hoạt động của con người</td>
<td>Vật, đối tượng</td>
</tr>
<tr>
<td><p>Thành viên</p>
<p>Nhân viên</p>
<p>Sinh viên</p>
<p>Nhân viên quản lí</p>
<p>Nhân viên khảo thí</p>
<p>Nhân viên giáo vụ</p>
<p>Giảng viên</p>
<p>Người dùng</p>
<p>…………..</p></td>
<td><p>Đăng nhập</p>
<p>Đăng xuất</p>
<p>Đổi mật khẩu</p>
<p>Cập nhật thông tin cá nhân</p>
<p>Sinh viên đăng kí học</p>
<p>Sinh viên xem lịch học</p>
<p>Sinh viên sửa đăng kí</p>
<p>Sinh viên xem điểm</p>
<p>Giảng viên đăng kí dạy</p>
<p>Giảng viên nhập điểm</p>
<p>Giảng viên xem lịch dạy</p>
<p>Giảng viên xem điểm</p>
<p>Giáo vụ quản lí môn học</p>
<p>Giáo vụ quản lí lớp học phần</p>
<p>Giáo vụ quản lí thông tin sinh</p>
<p>viên</p>
<p>Giáo vụ quản lí thông tin học kì</p>
<p>Quản lí thông tin trường</p>
<p>Quản lí thông tin Khoa</p>
<p>Quản lí thông tin bô môn</p>
<p>Quản lí thông tin giảng viên</p>
<p>Xem thống kê giảng viên</p>
<p>Xem thống kê sinh viên</p>
<p>Xem thống kê học lực</p>
<p>Xem thống kê phòng học</p>
<p>…………..</p></td>
<td><p>Khoa</p>
<p>Ngành học</p>
<p>Bộ môn</p>
<p>Năm học</p>
<p>Khóa học</p>
<p>Học kì</p>
<p>Môn học</p>
<p>Lớp học phần</p>
<p>Tuần học</p>
<p>Ngày học trong tuần</p>
<p>Kíp/ca học trong ngày</p>
<p>Phòng học</p>
<p>Tòa nhà</p>
<p>Đầu điểm thành phần</p>
<p>Điểm thi</p>
<p>Điểm trung bình môn</p>
<p>Điểm chữ</p>
<p>Tín chỉ</p>
<p>Tổng tín chỉ tích lũy</p>
<p>Điểm trung bình tích lũy</p>
<p>Học lực</p>
<p>Loại học lực</p>
<p>…………..</p></td>
</tr>
</tbody>
</table> 

Bước 3, lập bảng giải thích ngữ nghĩa chi tiết cho từng khái niệm trong lĩnh vực của ứng dụng:
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr>
<td>TT</td>
<td>Tên tiếng việt</td>
<td>Tiếng anh</td>
<td>Giải thích</td>
</tr>
<tr>
<td colspan="4">Nhóm các khái niệm liên quan đến con người</td>
</tr>
<tr>
<td>1</td>
<td>Thành viên</td>
<td>Member</td>
<td><p>Người có tài khoản và thầm quyền để đăng nhập</p>
<p>vào hệ thống, thực hiện các chức năng được cho</p>
<p>phép. Ví dụ sinh viên có thể đăng nhập vào hệ</p>
<p>thống để đăng kí học, xem lịch học, xem điểm.</p>
<p>Thông tin sinh viên được quản lí trong hệ thống.</p>
<p>Nên sinh viên là một thành viên của hệ thống</p></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td colspan="4">Nhóm các khái niệm liên quan đến hoạt động của
người</td>
</tr>
<tr>
<td>22</td>
<td>Đăng kí học</td>
<td>Registration</td>
<td><p>Là hoạt động của sinh viên trước mỗi kì học.</p>
<p>Theo đó, trước mỗi kì học, trường sẽ mở chế độ</p>
<p>đăng kí cho sinh viên vào đăng kí trong một thời</p>
<p>gian nhất định. Trong thời gian đó, sinh viên phải</p>
<p>đăng nhập vào hệ thống, thực hiện chức năng</p>
<p>đăng kí học. Chức năng này cho phép sinh viên</p>
<p>chọn môn học được phép đăng kí trong kì học,</p>
<p>chọn lớp học phần phù hợp với bản thân. Thường</p>
<p>có quy định mỗi học kì phải học tối thiểu bao</p>
<p>nhiêu tín chỉ, tối đa bao nhiêu tín chỉ. Sinh viên</p>
<p>phải chọn đủ số tín chỉ trong ngưỡng này mới hợp</p>
<p>lệ. Trong thời gian trường còn mở đăng kí, sinh</p>
<p>viên có quyền vào lại hệ thống thay đổi thông tin</p>
<p>đăng kí của mình.</p></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td colspan="4">Nhóm các khái niệm liên quan đến vật, đối tượng xử
lí</td>
</tr>
<tr>
<td>33</td>
<td><p>Điểm trung bình</p>
<p>môn</p></td>
<td>Final grade</td>
<td><p>Điểm tổng kết môn học. Tính trung bình theo các</p>
<p>đầu điểm thành phần của môn học.</p>
<p>Ví dụ, môn Toán có 3 đầu điểm thành phần:</p>
<p>chuyên cần 10%, trung bình kiểm tra 10%, trung</p>
<p>bình bài tập lớn 20%. Và điểm bài thi cuối kì</p>
<p>60%. Nếu sinh viên A đạt các đầu điểm lần lượt</p>
<p>là 5, 6, 7, 8 thì điểm trung bình môn được tính là</p>
<p>57</p>
<p>Chương 3. Thu thập và phân tích yêu cầu</p>
<p>5*0.1 + 6*0.1 + 7*0.2 + 8*0.6 = 7.3 hệ 10.</p>
<p>Tương ứng điểm chữ B.</p>
<p>Tương ứng điểm hệ 4 là 3.0</p></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table> 

# 2\. Mô tả hệ thống bằng ngôn ngữ tự nhiên

Tóm tắt các bước thực hiện:

  * Bước 1: Giới thiệu mục đích hệ thống

  * Bước 2: Phạm vi hệ thống: ai được dùng phần mềm/hệ thống? Mỗi người vào vào hệ thống được phép thực hiện các chức năng nào?

  * Bước 3: Với mỗi chức năng mà người dùng được phép thực hiện ở bước 2, mô tả chi tiết hoạt động nghiệp vụ của chức năng đấy diễn ra như thế nào?

  * Bước 4: Các đối tượng nào được quản lí, xử lí trong hệ thống? Mỗi đối tượng cần dùng/quản lí các thuộc tính nào?

  * Bước 5: Quan hệ (số lượng) giữa các đối tượng đã nêu ở bước 4?


Áp dụng vào hệ thống quản lí đăng kí tín chỉ, các bước được tiến hành như sau:
**Bước 1: Mục đích của hệ thống** : Hệ thống trang web phục vụ công tác quản lí đăng kí tín chỉ của sinh viên, đăng kí giảng dạy của giảng viên, quản lí điểm các môn học của một trường đại học.
**Bước 2: Phạm vi hệ thống** : Những người được vào hệ thống và chức năng mỗi người được thực hiện khi vào hệ thống này được quy định như sau:

  * Thành viên hệ thống:

* Đăng nhập

* Đăng xuất

* Đổi mật khẩu cá nhân

  * Sinh viên:

* Được thực hiện các chức năng như thành viên

* Đăng kí học, sửa thông tin đăng kí của mình

* Xem lịch học của mình

* Xem điểm của mình

  * Giảng viên:

* Đăng kí dạy, sửa thông tin đăng kí dạy

* Nhập, sửa điểm các lớp mình dạy

* Xem lịch dạy của mình

* Xem thống kê liên quan đến các lớp mình dạy

  * Nhân viên giáo vụ:

* Quản lí thông tin sinh viên: thêm, xóa, sửa theo yêu cầu từ sinh viên

* Quản lí thông tin môn học

* Quản lí thông tin lớp học phần

  * Nhân viên quản lí:

* Quản lí thông tin chung: thông tin trường, thông tin khoa, thông tin bộ môn, thông tin

* các toàn nhà, phòng học, thông tin năm học, kì học.

* Quản lí thông tin giảng viên theo yêu cầu từ giảng viên

* Xem các loại thống kê

  * Nhân viên khảo thí:

* Xuất bảng điểm theo yêu cầu của sinh viên


Những chức năng không đề cập đến thì mặc định là không thuộc phạm vi của hệ thống.
**Bước 3: Hoạt động nghiệp vụ của các chức năng** : Theo nguyên tắc, mỗi chức năng liệt kê trong bước 2 đều phải mô tả chi tiết. Tuy nhiên, trong phạm vi tài liệu này, chỉ có ba chức năng đượcmô tả chi tiết vì đây là các chức năng được dùng để minh họa cho các bước phân tích, thiết kế từ đầu đến cuối. Các chức năng còn lại coi như bài tập cho người học.

  * Sinh viên đăng kí học: Sinh viên đăng nhập vào hệ thống -> chọn chức năng đăng kí tín chỉ (đang trong thời gian mở đăng kí mới được chọn) -> chọn kì đăng kí + ngành học (có thể có sinh viên học đồng thời hai chuyên ngành) -> hệ thống hiện danh sách các môn học có thể đăng kí (mã, tên môn học, số tín chỉ, mô tả), các lớp học phần đã đăng kí rồi, nếu có -> Sinh viên chọn môn học -> hệ thống hiện danh sách các lớp học phần của môn học đấy (mã, tên, sĩ số tối đa, sĩ số hiện tại, phòng học, giảng viên, lịch học hàng tuần vào các ngày nào trong tuần, kíp nào trong ngày): chỉ active các nhóm mà không bị trùng lịch học với các môn đã chon trước, các nhóm bị trùng lịch thì chỉ xem, không chọn được -> Sinh viên chọn lớp học phần mình thích -> hệ thống quay lại trang bắt đầu đăng kí với lớp học phần vừa chọn được bổ sung vào danh sách các lớp học phần đã chọn. Sinh viên lặp lại các bước trên cho đến khi chọn đủ số tín chỉ trong ngưỡng cho phép -> nút lưu được active -> Sinh viên click lưu thì thông tin đăng kí mới chính thức được lưu vào hệ thống, hệ thống quay về giao diện chính của sinh viên.

  * Giảng viên nhập điểm: Giảng viên đăng nhập vào hệ thống -> chọn chức năng nhập điểm -> Chọn học kì đang active -> hệ thống hiện danh sách các môn học do giảng viên dạy của kì đã chọn (mã, tên, số tín chỉ, mô tả) -> Giảng viên click chọn môn học muốn nhập điểm -> Hệ thống hiện danh sách các lớp học phần do giảng viên dạy (mã, tên, sĩ số thực, phòng học, ngày học, kíp học) -> Giảng viên chọn 1 lớp học phần muốn nhập -> Hệ thống hiện danh sách các sinh viên đăng kí lớp học phần được chọn với điểm thành phần, nếu có: thứ tự, mã sinh viên, họ tên, các đầu điểm thành phần, điểm thi, cột trung bình môn và điểm chữ được tự tính sau khi nhập -> Giảng viên nhập đầu điểm muốn nhập cho tất cả sinh viên trong danh sách và click lưu -> hệ thống lưu điểm vào và quay về giao diện chính của giảng viên.

  * Quản lí xem thống kê theo loại học lực: Nhân viên quản lí đăng nhập vào hệ thống -> chọn chức năng xem thống kê -> hệ thống hiện giao diện chọn thông tin thống kê -> chọn thống kê loại học lực -> Hệ thống hiện giao diện thống kê loại học lực -> Quản lí chọn học kì muốn thống kê -> Kết quả thống kê hiện lên, mỗi loại học lực trên một dòng, xếp theo thứ tự cao nhất đến thấp nhất của loại học lực trong bảng đánh giá (Ưu tú, xuất sắc, giỏi, khá, trung bình, yếu kém): thứ tự, loại học lực, tổng số sinh viên đạt loại đó, điểm trung bình sinh viên trong nhóm đạt loại đó trong học kì đã chọn -> Quản lí click vào một loại học lực -> Hệ thống hiện danh sách các sinh viên đạt loại học lực đấy lên, xếp theo thứ tự các ngành học, đến thứ tự abc của tên sinh viên: thứ tự, mã sinh viên, họ và tên, ngành học, khóa học, tổng số tín chỉ của học kì, điểm trung bình của học kì -> Quản lí click vào một sinh viên danh sách -> Hệ thống hiện lên danh sách các môn và kết quả của sinh viên đã học trong học kì đó, xếp theo thứ tự abc của tên môn học: thứ tự, tên môn học, số tín chỉ, điểm trung bình môn đó của sinh viên. Dòng cuối là tổng số tín chỉ, điểm trung bình cả học kì của sinh viên -> Quản lí click vào một môn học trong danh sách ->Hệ thống hiện lên điểm chi tiết của môn học của sinh viên: mã môn, tên môn, tổng tín chỉ, các đầu điểm thành phần dạng bảng: tên đầu điểm thành phần, tỉ lệ % tính của đầu điểm thành phần, điểm của sinh viên. Dòng cuối là điểm trung bình môn của sinh viên trong môn học đó.


**Bước 4: Thông tin các đối tượng cần xử lí, quản lí** :
Nhóm các thông tin liên quan đến con người:

  * Thành viên: tên đăng nhập, mật khẩu, họ tên, địa chỉ, ngày sinh, email, số điện thoại

  * Sinh viên: giống thành viên, có thêm: mã sinh viên. Theo mỗi ngành học còn có khóa học, ngành học

  * Nhân viên: giống thành viên, có thêm: vị trí công việc.

  * Nhân viên quản lí: giống nhân viên

  * Nhân viên giáo vụ: giống nhân viên

  * Nhân viên khảo thí: giống nhân viên

  * Giảng viên: giống nhân viên


Nhóm các thông tin liên quan đến cơ sở vật chất:

  * Tòa nhà: tên, mô tả

  * Phòng học: tên, sức chứa tối đa, mô tả

  * Nhóm các thông tin liên quan đến đơn vị, tổ chức:

  * Trường: tên, địa chỉ, mô tả

  * Khoa: tên, mô tả

  * Ngành học: tên, mô tả

  * Bộ môn: tên, mô tả


Nhóm các thông tin liên quan đến chuyên môn, vận hành:

  * Năm học: tên, mô tả

  * Kì học: tên, mô tả

  * Tuần học: tên, mô tả

  * Ngày trong tuần: tên, mô tả

  * Kíp học trong ngày: tên, mô tả

  * Môn học: tên, số tín chỉ, mô tả

  * Lớp học phần: tên, mô tả, sĩ số tối đa, sĩ số hiện tại, giảng viên dạy, phòng học, tuần nào học ngày nào, kíp nào.


Nhóm thông tin liên quan đến thống kê:

  * Thống kê theo loại học lực

  * Thống kê sinh viên theo kết quả học

  * Thống kê các môn học theo kết quả học

  * Thống kê giảng viên theo: số giờ dạy, kết quả học

  * Thống kê học kì theo số sinh viên


**Bước 5: Quan hệ giữa các đối tượng, thông tin** :

  * Một trường có nhiều khoa

  * Một khoa có nhiều bộ môn

  * Một khoa có nhiều ngành học

  * Một bộ môn quản lí chuyên môn nhiều môn học

  * Một bộ môn có nhiều giảng viên

  * Một năm học có nhiều học kì

  * Một học kì liên quan đến nhiều năm học. Một năm học + một học kì tạo ra một kì học (kìhọc # học kì).

  * Một kì học có nhiều môn học

  * Một môn học, vào một kì học, có nhiều lớp học phần

  * Một lớp học phần có thể học vào nhiều buổi, mỗi buổi có thể liên quan đến 1 tuần khác nhau, 1 ngày khác nhau, 1 kíp khác nhau, 1 phòng học khác nhau, 1 giảng viên khác nhau.

  * Một giảng viên có thể dạy nhiều môn học trong mỗi kì học

  * Một môn học, trong một kì học, giảng viên có thể dạy nhiều lớp học phần khác nhau, miễn sao không trùng lịch buổi nào.

  * Một lớp học phần, có thể có nhiều giảng viên dạy. Nhưng mỗi buổi học chỉ có một giảng viên dạy.

  * Một môn học có nhiều đầu điểm thành phần.

  * Mỗi đầu điểm thành phần, đối với mỗi môn học, có tỉ lệ % tính điểm nhất định.

  * Một tuần có thể có nhiều buổi dạy/học

  * Một ngày có thể có nhiều buổi học/dạy

  * Một kíp có thể có nhiều buổi học/dạy của nhiều lớp học phần khác nhau

  * Một phòng học có thể có nhiều lớp học phần vào học ở những buổi khác nhau.

  * Một sinh viên có thể đăng kí học nhiều ngành khác nhau (tối đa 2 ngành đồng thời).

  * Với mỗi ngành, sinh viên phải học một số môn nhất định, và điểm tính theo từng ngành.

  * Các môn trùng nhau giữa các ngành thì sinh viên chỉ phải học 1 lần, qua là được.

  * Mỗi sinh viên, mỗi môn học, có một diểm trung bình môn.

# Public_278

# Tổng quan

## Mục đích

Tài liệu trình bày tổng quan giải pháp và quy trình nghiệp vụ đáp ứng cho bài toán tích hợp đối tác kinh doanh tại Tổng công ty cổ phần Bưu chính Viettel.

Thiết kế, mô tả các quy trình nghiệp vụ của Hệ thống đảm bảo cung cấp giải pháp hoàn chỉnh, xuyên suốt quá trình khai báo và phê duyệt mã KH chi COD

## Phạm vi
<table>
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><em><strong>STT</strong></em></th>
<th><em><strong>Nghiệp vụ</strong></em></th>
<th><em><strong>Phạm vi áp dụng</strong></em></th>
</tr>
</thead>
<tbody>
<tr>
<td><ol>
<li></li>
</ol></td>
<td><em>Khai báo cấu hình</em></td>
<td><p><em>- Khai báo cấu hình sản lượng doanh thu theo địa bàn</em></p>
<p><em>- Khai báo mã KH cấu hình chi COD</em></p></td>
</tr>
<tr>
<td><ol>
<li></li>
</ol></td>
<td><em>Phê duyệt mã KH</em></td>
<td><p><em>Thực hiện phê duyệt mã KH đã khai báo theo sản lượng/doanh
thu cam kết</em></p>
<ul>
<li><p><em>Hệ thống tự động phê duyệt nếu đạt sản lượng hoặc doanh thu
theo địa bàn</em></p></li>
<li><p><em>Hệ thống thự hiện trình ký phê duyệt Voffice với các trường
hợp không đạt doanh thu sản lượng theo địa bàn</em></p></li>
</ul></td>
</tr>
<tr>
<td><ol>
<li></li>
</ol></td>
<td><em>Báo cáo sản lượng doanh thu theo mã KH</em></td>
<td><p><em>Báo cáo cấu hình chi của mã KH</em></p>
<p><em>Báo cáo sản lượng/doanh thu</em></p></td>
</tr>
</tbody>
</table> 

#  Quy trình tổng quan

|<image_5>|

**Mô tả quy trình:**
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Bước</th>
<th><strong>Nội dung</strong></th>
<th><strong>Đối tượng thực hiện</strong></th>
<th><strong>Hệ thống thực hiện</strong></th>
<th><blockquote>
<p><strong>Mô tả</strong></p>
</blockquote></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Chức năng khai báo mã KH cusID</td>
<td>User được phân quyền</td>
<td>FICO</td>
<td><p>User được phân quyền truy cập vào chức năng khai báo mã KH cusID
trên hệ thống FICO.</p>
<p>Chuyển bước 2.</p></td>
</tr>
<tr>
<td>2</td>
<td>Chọn mã KH hoặc Import file</td>
<td>User được phân quyền</td>
<td>FICO</td>
<td><p>Người dùng nhập mã KH hoặc import danh sách KH cần khai báo chi
COD hàng ngày.</p>
<p>Hệ thống kiếm tra:</p>
<ul>
<li><p>Nếu KH đang có kỳ thanh toán COD hàng ngày Thông báo lỗi</p></li>
<li><p>Nếu KH đang không có kỳ thanh toán COD hàng ngày chuyển bước
3.</p></li>
</ul></td>
</tr>
<tr>
<td>3</td>
<td>Hiển thị thông tin thanh toán của KH</td>
<td>Hệ thống</td>
<td>FICO</td>
<td><p>Hiển thị thông tin thanh toán hiện tại của cus tìm kiếm.</p>
<p>Chuyển bước 4.</p></td>
</tr>
<tr>
<td>4</td>
<td>Chọn Thanh toán COD hàng ngày</td>
<td>User được phân quyền</td>
<td>FICO</td>
<td><p>Chọn loại kỳ thanh toán Hàng ngày cho các mã KH khai báo.</p>
<p>Chuyển bước 5.</p></td>
</tr>
<tr>
<td>5</td>
<td>Xác nhận đẩy yêu cầu xác thực OTP trên app KH</td>
<td>User được phân quyền</td>
<td>FICO</td>
<td><p>Người dùng xác nhận khai báo các mã KH về hình thức thanh toán
COD hàng ngày. Hệ thống tự động đẩy yêu cầu xác thực OTP lên app KH.</p>
<p>Chuyển bước 6.</p></td>
</tr>
<tr>
<td>6</td>
<td>Hiển thị yêu cầu xác thực lên app KH</td>
<td>Hệ thống</td>
<td>App KH</td>
<td><p>KH thực hiện xác thực OTP trên App KH.</p>
<ul>
<li><p>Xác thực thành công chuyển bước 7</p></li>
<li><p>Không xác thực Chuyển bước 9</p></li>
</ul></td>
</tr>
<tr>
<td>7</td>
<td>Lưu thông tin kỳ thanh toán cusID</td>
<td>Hệ thống</td>
<td>FICO</td>
<td><p>KH xác thực thành công hệ thống tự động cập nhật thông tin thanh
toán mới của KH.</p>
<ul>
<li><p>Hiển thị Ngày thanh toán mới và lịch sử cập nhật trên app
KH</p></li>
<li><p>Cập nhật thông tin kỳ thanh toán trên hệ thống FICO, HR Chuyển
bước 8.</p></li>
</ul></td>
</tr>
<tr>
<td>8</td>
<td>Đồng bộ kỳ thanh toán sang mã EVTP</td>
<td>Hệ thống</td>
<td>FICO</td>
<td><p>Đồng bộ kỳ thanh toán từ mã Cus sang toàn bộ mã EVTP thuộc
cus.</p>
<p>Chuyển bước 10.</p></td>
</tr>
<tr>
<td>9</td>
<td>Tự động hủy yêu cầu sau 72h</td>
<td>Hệ thống</td>
<td>FICO</td>
<td><p>Với yêu cầu xác thực quá 72h không có phản hồi từ KH hệ thống tự
động cập nhật về trạng thái Xác thực thất bại.</p>
<ul>
<li><p>Khi KH click vào yêu cầu trên app hệ thống thông báo Yêu cầu
không tồn tại hoặc đã quá hạn xử lý</p></li>
<li><p>Hệ thống cập nhật trạng thái Xác thực thất bại.</p></li>
</ul>
<p>Chuyển bước 10.</p></td>
</tr>
<tr>
<td>10</td>
<td>Cập nhật trạng thái xác thực</td>
<td>Hệ thống</td>
<td>FICO</td>
<td><p>Hệ thống cập nhật chính xác trạng thái xác thực.</p>
<p>Kết thúc luồng.</p></td>
</tr>
</tbody>
</table> 

# Chi tiết chức năng Quản lý CusID và khai báo KH thanh toán hàng ngày trên FICO

## SCR1: Màn hình Quản lý khách hàng CusID

### Màn hình

|<image_6>|Phân quyền: User được phân quyền theo quy định của TTDVCP

### Mô tả màn hình
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><strong>No</strong></th>
<th><strong>Field Name</strong></th>
<th><strong>Control Type</strong></th>
<th><p><strong>Mandatory</strong></p>
<p><strong>(Yes/No)</strong></p></th>
<th><strong>Editable/ Read-only</strong></th>
<th><strong>Description/Note</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="6"><strong>Chức năng tra cứu</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>Khách hàng cus</td>
<td>Textbox</td>
<td>No</td>
<td>Editable</td>
<td><h6>Cho phép user nhập thông tin KH để tìm kiếm.</h6>
<p>Cho phép nhập các giá trị sau:</p>
<ul>
<li><p>Mã CusID</p></li>
<li><p>Số điện thoại (sđt đăng nhập hệ thống app/web)</p></li>
<li><p>Email (Email đăng nhập hệ thống app/web)</p></li>
</ul>
<p>Hệ thống tìm kiếm mã cus theo điều kiện nhập.</p></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Khách hàng EVTP</td>
<td>Textbox</td>
<td>No</td>
<td>Editable</td>
<td><h6>Cho phép KH nhập mã EVTP để tìm kiếm mã KH
CusID</h6></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>Tìm kiếm</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><h6>Click
button thực hiện tra cứu.</h6>
<h6>Hiển thị toàn bộ dữ liệu theo điều kiện tìm
kiếm</h6></td>
</tr>
<tr>
<td colspan="6"><strong>Chi tiết thông tin KH</strong></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>STT</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số thứ tự</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Mã cusid</td>
<td>Text</td>
<td>No</td>
<td>Editable</td>
<td>Hiển thị mã Cusid</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>Số điện thoại</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số điện thoại KH</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>Tên KH</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị Tên KH</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>Loại kỳ thanh toán</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị loại kỳ thanh toán theo HDDT</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>Email</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị email KH</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>Hình thức thanh toán</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiện thị hình thức thanh toán của KH</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>Ngân hàng</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị ngân hàng nhận COD theo HDDT</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>Chi nhánh</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td><p>Hiển thị chi nhánh của ngân hàng</p>
<p>Không có để trống</p></td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>Số tài khoản</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số tài khoản theo HDDT</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td>Người thụ hưởng</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị tên người thụ hưởng theo HDDT</td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>Thao tác</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Cho phép thao tác sửa và xóa cấu hình theo từng địa bàn.</p>
<p>- Click Button Xem cho phép xem chi tiết danh sách KH EVTP của mã
cus</p>
<p>- Click Xem lịch sử Hiển thị lịch sử cập nhật của cusid.</p>
<p>Hiển thị tooltip khi Hower chuột “Xem” và “Lịch sử cập nhật”</p></td>
</tr>
<tr>
<td colspan="6"><p><strong>Chi tiết thông tin KH EVTP</strong></p>
<p><strong>Hiển thị danh sách mã KH EVTP thuộc mã
CusID</strong></p></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>STT</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số thứ tự</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Chi nhánh</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị tên chi nhánh</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>Bưu cục</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị tên bưu cục</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Mã KH EVTP</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị mã KH EVTP</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Tên KH</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị tên KH EVTP</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>Hình thức cấn trừ</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td><p>Hiển thị hình thức cấn trừ của mã EVTP</p>
<p>Không có để trống.</p></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>Kỳ cấn trừ</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td><p>Hiển thị kỳ cấn trừ.</p>
<p>Không có để trống.</p></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>Ngày lấy cấn trừ</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td><p>Hiển thị ngày lấy cấn trừ</p>
<p>Không có để trống.</p></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>Kết xuất excel</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Khi click thì thực hiện kết xuất danh sách excel trên grid.</p>
<blockquote>
<p><strong><u>Quy Tắc Kết Xuất:</u></strong></p>
</blockquote>
<ul>
<li><p>Nếu kết quả tìm kiếm không có dữ liệu thì hệ thống hiển thị thông
báo “Không tồn tại kết quả”.</p></li>
<li><p>Nếu kết quả tìm kiếm có dữ liệu thì hệ thống thực hiện kết xuất
toán bộ dữ liệu trên grid.</p></li>
</ul>
<p>Tên file: Danh sách KH EVTP mã cusID {Mã cusid}</p></td>
</tr>
</tbody>
</table> 

## SCR2: Màn hình Khai báo mã khách hàng

### Màn hình

|<image_7>|

### Mô tả Màn hình
<table style="width:100%;">
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><blockquote>
<p><strong>No</strong></p>
</blockquote></th>
<th><strong>Field Name</strong></th>
<th><strong>Control Type</strong></th>
<th><p><strong>Mandatory</strong></p>
<p><strong>(Yes/No)</strong></p></th>
<th><strong>Editable/ Read-only</strong></th>
<th><strong>Description/Note</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="6"><strong>Chức năng tra cứu</strong></td>
</tr>
<tr>
<td><strong>1</strong></td>
<td>Khách hàng cus</td>
<td>Textbox</td>
<td>No</td>
<td>Editable</td>
<td><h6>Cho phép user nhập thông tin KH để tìm kiếm.</h6>
<p>Cho phép nhập các giá trị sau:</p>
<ul>
<li><p>Mã CusID</p></li>
<li><p>Số điện thoại (sđt đăng nhập hệ thống app/web)</p></li>
<li><p>Email (Email đăng nhập hệ thống app/web)</p></li>
</ul>
<p>Hệ thống tìm kiếm mã cus theo điều kiện nhập.</p></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Khách hàng EVTP</td>
<td>Textbox</td>
<td>No</td>
<td>Editable</td>
<td>Cho phép KH nhập mã EVTP để tìm kiếm mã KH CusID</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>Tìm kiếm</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><h6>Click
button thực hiện tra cứu.</h6>
<p>Hiển thị toàn bộ dữ liệu theo điều kiện tìm kiếm</p></td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Kết xuất excel</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Khi click thì thực hiện kết xuất danh sách excel trên grid.</p>
<blockquote>
<p><strong><u>Quy Tắc Kết Xuất:</u></strong></p>
</blockquote>
<ul>
<li><p>Nếu kết quả tìm kiếm không có dữ liệu thì hệ thống hiển thị thông
báo “Không tồn tại kết quả”.</p></li>
<li><p>Nếu kết quả tìm kiếm có dữ liệu thì hệ thống thực hiện kết xuất
toán bộ dữ liệu trên grid.</p></li>
</ul>
<ul>
<li><p>Tên file: Danh sách KH khai báo thanh toán hàng ngày</p></li>
</ul></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Khai báo mã KH</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td>Hiển thị button Khai báo mã KH. Click button hiển thị popup Khai báo
mã KH chi tiết tại màn hình SCR 3. Màn hình Khai báo thông tin mã
KH</td>
</tr>
<tr>
<td colspan="6"><strong>Chi tiết thông tin cấu hình</strong></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>STT</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số thứ tự</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>STT</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số thứ tự</td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>Mã cusid</td>
<td>Text</td>
<td>No</td>
<td>Editable</td>
<td>Hiển thị mã Cusid</td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>Số điện thoại</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị số điện thoại KH</td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>Tên KH</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị Tên KH</td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>Loại kỳ thanh toán</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị loại kỳ thanh toán theo HDDT</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>Email</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị email KH</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>Hình thức thanh toán</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td>Hiện thị hình thức thanh toán của KH</td>
</tr>
<tr>
<td><strong>14</strong></td>
<td>Trạng thái</td>
<td>Text</td>
<td>No</td>
<td>Read-only</td>
<td><p>Hiển thị trạng thái tương ứng của yêu cầu:</p>
<ul>
<li><p>Chờ xác thực – Đã gửi yêu cầu xác thực nhưng KH chưa xác
thực</p></li>
<li><p>Đã xác thực – KH đã xác thực OTP thành công</p></li>
<li><p>Xác thực thất bại – KH từ chối xác thực hoặc xác thực tự động hủy
sau 72h</p></li>
<li><p>Không hoạt động – khi có cập nhật kỳ thanh toán mới (KH ký PL HĐ
có thay đổi kỳ thanh toán hoặc thay đổi kỳ thanh toán)</p></li>
</ul></td>
</tr>
<tr>
<td><strong>15</strong></td>
<td>Người khai báo</td>
<td>Datetime</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị tên người thực hiện khai báo</td>
</tr>
<tr>
<td><strong>16</strong></td>
<td>Thời gian khai báo</td>
<td>Datetime</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị thời gian thực hiện khai báo</td>
</tr>
<tr>
<td><strong>17</strong></td>
<td>Thời gian cập nhật</td>
<td>Datetime</td>
<td>No</td>
<td>Read-only</td>
<td>Hiển thị thời gian cập nhật (thời gian xác thực, hủy)</td>
</tr>
<tr>
<td><strong>18</strong></td>
<td>Thao tác</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Cho phép thao tác gửi lại yêu cầu xác thực và xóa cấu hình.</p>
<p>- Click Button Gửi yêu cầu xác thực chỉ hiển thị với trạng thái Xác
thực thất bại và Không hoạt động.</p>
<p>- Click Xóa Chỉ hiển thị với trạng thái Chờ xác thực và Xác thực thất
bại Hiển thị thông báo Xác nhận xóa khai báo cấu hình.</p>
<p>Hiển thị tooltip khi Hower chuột “Gửi yêu cầu xác thực” và
“Xóa”</p></td>
</tr>
</tbody>
</table> 

### SCR3. Màn hình Khai báo thông tin mã KH

|<image_8>|
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th><blockquote>
<p><strong>No</strong></p>
</blockquote></th>
<th><strong>Field Name</strong></th>
<th><strong>Control Type</strong></th>
<th><p><strong>Mandatory</strong></p>
<p><strong>(Yes/No)</strong></p></th>
<th><strong>Editable/ Read-only</strong></th>
<th><strong>Description/Note</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Import file</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Cho phép user import file KH theo template.</p>
<p>Nguyên tắc import:</p>
<ul>
<li><p>Nếu KH đang có khai báo kỳ thanh toán COD hàng ngày không cho
phép import</p></li>
<li><p>Nếu KH đang không phải kỳ thanh toán hàng ngày cho phép
import</p></li>
<li><p>Dữ liệu import lên phải là mã cusid</p></li>
</ul></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Tải xuống file biểu mẫu</td>
<td>Button</td>
<td>No</td>
<td>Editable</td>
<td><p>Cho phép user tải xuống file biểu mẫu</p>
<p>Template file:</p></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>STT</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td>Hiển thị STT</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Mã CusID</td>
<td>Texbox</td>
<td>Yes</td>
<td>Editable</td>
<td><h6>Cho phép user nhập thông tin KH để tìm kiếm.</h6>
<p>Cho phép nhập các giá trị sau:</p>
<ul>
<li><p>Mã CusID</p></li>
<li><p>Số điện thoại (sđt đăng nhập hệ thống app/web)</p></li>
<li><p>Email (Email đăng nhập hệ thống app/web)</p></li>
</ul>
<p>Click enter hoặc click chuột Hệ thống tìm kiếm mã cus theo điều kiện
nhập.</p>
<p>Kiểm tra mã cus nhập vào hệ thống:</p>
<ul>
<li><p>Nếu KH đang có khai báo kỳ thanh toán COD hàng ngày Thông báo lỗi
“KH đang có kỳ thanh toán hàng ngày”</p></li>
<li><p>Nếu KH đang không phải kỳ thanh toán hàng ngày Hiển thị thông tin
KH tìm kiếm</p></li>
<li><p>Mã KH nhập bị trùng với mã KH đã nhập báo lỗi “Mã KH đã được
nhập”</p></li>
</ul></td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Tên KH</td>
<td>Text</td>
<td>N/A</td>
<td>Readonly</td>
<td><p>Hiển thị tên KH theo cus đã tìm kiếm</p>
<p>Không có để trống</p></td>
</tr>
<tr>
<td><strong>6</strong></td>
<td>Số điện thoại</td>
<td>Text</td>
<td>N/A</td>
<td>Readonly</td>
<td><p>Hiển thị SĐT KH theo cus đã tìm kiếm</p>
<p>Không có để trống</p></td>
</tr>
<tr>
<td><strong>7</strong></td>
<td>Email</td>
<td>Text</td>
<td>N/A</td>
<td>Readonly</td>
<td><p>Hiển thị Email KH theo cus đã tìm kiếm</p>
<p>Không có để trống</p></td>
</tr>
<tr>
<td><strong>8</strong></td>
<td>Loại kỳ thanh toán</td>
<td>Text</td>
<td>N/A</td>
<td>Readonly</td>
<td><p>Hiển thị loại kỳ thanh toán đang áp dụng theo cus đã tìm kiếm</p>
<p>Không có để trống</p></td>
</tr>
<tr>
<td><strong>9</strong></td>
<td>Loại kỳ thanh toán khai báo</td>
<td>Dropdownlist</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Cho phép chọn loại kỳ thanh toán</p>
<p>Mặc định chọn: Hàng ngày</p></td>
</tr>
<tr>
<td><strong>10</strong></td>
<td>Thao tác</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td><p>Cho phép thao tác xóa mã KH đã nhập.</p>
<p>- Click Xóa Hiển thị thông báo Xác nhận xóa mã KH.</p>
<p>Hiển thị tooltip khi Hower chuột “Xóa”</p></td>
</tr>
<tr>
<td><strong>11</strong></td>
<td>Xác nhận</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td>Click Cập nhật để gửi yêu cầu xác thực đẩy yêu cầu xác thực sang hệ
thống App KH</td>
</tr>
<tr>
<td><strong>12</strong></td>
<td>Đóng</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td>Click “Đóng” để tắt nội dung thay đổi</td>
</tr>
<tr>
<td><strong>13</strong></td>
<td>Thêm dòng</td>
<td>Button</td>
<td>Yes</td>
<td>Editable</td>
<td>Cho phép user thêm dòng để nhập mã KH khai báo</td>
</tr>
</tbody>
</table> 

## Yêu cầu nghiệp vụ chi tiết

KH được xác thực thanh công sẽ có Kỳ thanh toán hàng ngày hệ thống tự động cập nhật toàn bộ mã KH EVTP của mã CusID về kỳ thanh toán của cus

Kỳ thanh toán sẽ thay đổi nếu KH thực hiện Ký PL thay đổi hình thức thanh toán hoặc thực hiện yêu cầu xác thực lại Kỳ thanh toán Kỳ thanh toán đã được khai báo sẽ được cập nhật về trạng thái Không hoạt động.

Ảnh hưởng:

\- Màn hình quản lý KH chi nhánh trên HR thêm type "Thanh toán COD hàng ngày"

\- Màn hình quản lý KH FICO thêm type "Thanh toán COD hàng ngày"

\- Chức năng chi: hệ thống gom chi tự động theo đúng hình thức thanh toán của KH

# Chi tiết chức năng Xác thực OTP trên app KH

## SCR1: Màn hình yêu cầu xác thực

### Màn hình
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>|<image_1>|</th>
<th>|<image_2>|</th>
<th>|<image_3>|</th>
<th>|<image_4>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH01</td>
<td>MH02</td>
<td>MH03</td>
<td>MH04</td>
</tr>
</tbody>
</table> 

### Mô tả màn hình

  * Hiển thị thông báo “Khách hàng có 1 yêu cầu xác thực thay đổi ngày thanh toán COD. Xác thực ngay.” click thông báo hiển thị màn hình MH02: Xác nhận cập nhật ngày thanh toán click Xác nhận hiển thị màn hình MH03: nhập mã xác thực OTP Xác thực thành công hiển thị màn hình MH04: thông báo cập nhật thành công,

  * MH01: Chi tiết tài khoản Hiển thị cảnh báo “Khách hàng có 1 yêu cầu xác thực thay đổi ngày thanh toán COD. Xác thực ngay.” Click Xác thực ngay Chuyển sang màn MH02.

  * MH02: Xác nhận cập nhật ngày thanh toán.


  * Hiển thị thông tin cập nhật

  * Click Xác nhận chuyển màn hình MH03

  * Click Bỏ qua để từ chối cập nhật Cập nhật trạng thái “Xác nhận thất bại” với lý do “KH từ chối xác nhận.”


  * MH03: Xác thực OTP


  * KH nhập mã xác thực qua tin nhắn gửi về.

  * Xác thực thành công chuyển màn hình MH04

  * Xác thực không thành công quay về màn hình MH01.


MH04: Thông báo thành công Hiển thị thông báo “Cập nhật thông tin thanh toán thành công” nếu KH xác thực OTP thành công

# Public_282

# Giới thiệu

## Mục đích

  * Giới thiệu về dự án: Mục đích và ý nghĩa của dự án

  * Lập kế hoạch cho toàn bộ dự án

  * Ước lượng thời gian của dự án


Mô tả về dự án: Bối cảnh phát triển của dự án, các yêu cầu về môi trường vận hành và các ràng buộc dự án

  * Phân tích các yêu cầu nghiệp vụ của hệ thống thông tin quản lý và phân bố giảng đường

  * Tài liệu được xây dựng dựa trên quá trình khảo sát, phỏng vấn các đối tượng có liên quan và nghiên cứu các tài liệu có liên quan tới nghiệp vụ của hệ thống

  * \- Các chức năng của hệ thống được sửa đổi và bổ sung so với phiên bản trước


## Các tiêu chuẩn

Tài liệu được viết theo font chữ Time New Roman, cỡ chữ 13, khổ giấy A4

## Đối tượng độc giả

Các đối tượng tham gia vào dự án, có thể đọc và sử dụng tài liệu này như: Ngườiquản lý dự án, lập trình viên, tester,...

## Phạm vi dự án

  * Phần mềm thuộc quyền quản lý của khoa Công nghệ thông tin trường Đại học Sư phạm Hà Nội

  * Quản lý trang thiết bị

  * Quản lý giảng đường

  * Quản lý quá trình mượn và trả trang thiết bị phục vụ cho việc giảng dạy và các côngviệc khác

  * Quản lý các sự cố và tình huống rủi ro xảy ra trong giảng đường


## Tài liệu tham khảo 
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th></th>
<th><strong>Tiêu đề</strong></th>
<th><strong>Tác giả</strong></th>
<th><strong>Số phiên bản</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Hướng dẫn thiết kế giao diện</td>
<td>Principles of User Interface Design</td>
<td>Ben Shneiderman</td>
<td>2nd Edition</td>
</tr>
<tr>
<td>Hợp đồng</td>
<td>Software Development Contract Template</td>
<td colspan="2">N/a</td>
</tr>
<tr>
<td>Các tiêu chuẩn về phát triển phần mềm</td>
<td>IEEE Standard for Software and System Test Documentation</td>
<td>IEEE Standards Association</td>
<td>IEEE Std 829-2008</td>
</tr>
<tr>
<td>Tài liệu yêu cầu</td>
<td>Software Requirements Specification (SRS)</td>
<td>Karl Wiegers và Joy Beatty</td>
<td>3rd Edition</td>
</tr>
<tr>
<td>Tài liệu đặc tả use case</td>
<td>Writing Effective Use Cases</td>
<td>Alistair Cockburn</td>
<td>1st Edition</td>
</tr>
</tbody>
</table> 

# Mô tả chung

## Tổng quan về sản phẩm

Hiện nay, sự tiến bộ trong công nghệ và phương tiện truyền thông đã tác động lớnđến hệ thống thông tin quản lý và phân bố giảng đường của các trường đại học. Công nghệthông tin và Internet đã mở ra cơ hội cho việc tạo ra môi trường học tập trực tuyến và cảithiện quản lý học phần, khóa học và thông tin sinh viên.Sự phổ biến của học tập từ xa và học trực tuyến đã thúc đẩy các trường đại học phải xâydựng hệ thống thông tin quản lý và phân bố giảng đường linh hoạt, cho phép sinh viên vàgiảng viên tương tác và tiếp cận nội dung giảng dạy từ xa.Sự tăng số lượng sinh viên và khó khăn trong việc quản lý thông tin đã thúc đẩy các trường đại học phải xây dựng các hệ thống thông tin quản lý và phân bố giảng đường. Điều này giúp tăng cường khả năng quản lý thông tin học phần, khóa học, sinh viên và giảng viênmột cách hiệu quả.Việc quản lý giảng đường, phân bổ giảng đường theo lịch học là một việc làm khá vất vảđối với nhà trường. Ngoài thời gian được bố trí theo thời khóa biểu, các giảng đường cũngcó thể được sinh viên, giáo viên đăng ký sử dụng cho các công việc đột xuất. Người quản lýcũng cần kiểm soát được các thiết bị, đồ dùng của từng giảng đường.

## Các chức năng chính của sản phẩm (Product Functions)

Các chức năng chính của hệ thống thông tin quản lý và phân bố giảng đường:

  * Lịch sử dụng giảng đường: Hệ thống cho phép Phòng đào tạo nhập thông tin về thời khóa biểu và thay đổi lịch sử dụng giảng đường. Giảng viên và sinh viên có thể truy cập vào hệ thống để xem lịch trình sử dụng giảng đường của mình.

  * Quản lý mượn giảng đường: Hệ thống cung cấp cơ chế đặt lịch và đăng ký mượn giảng đường cho các công việc đột xuất. Giáo viên hoặc sinh viên có thể yêu cầu mượn giảng đường trong trường hợp cần sử dụng ngoài lịch trình đã thiết lập. Quá trình đăng ký và xác nhận mượn giảng đường được thực hiện thông qua hệ thống.

  * Quản lý trang thiết bị của giảng đường: Hệ thống cho phép quản lý thông tin về trang thiết bị có sẵn trong từng giảng đường. Các thông tin này bao gồm danh sách trang thiết bị, tình trạng, ngày mua và thông tin bảo trì. Người dùng có thể tra cứu thông tin trang thiết bị và kiểm tra tình trạng sẵn có trước khi sử dụng giảng đường.

  * Báo cáo sự cố và thống kê tình trạng giảng đường: Hệ thống cung cấp chức năng cho phép người dùng báo cáo các sự cố mất, hỏng liên quan đến giảng đường; thống kê và báo cáo về tình hình sử dụng giảng đường và trang thiết bị. Người dùng có thể ghi lại thông tin chi tiết về sự cố và gửi báo cáo từ hệ thống. Quản lý có thể xem và xử lý những sự cố này để đảm bảo giảng đường hoạt động trơn tru.


## Phân loại người dùng 

Người dùng hệ thống được chia làm 4 loại:

  * Quản lý hệ thống: Bao gồm các quản lý hệ thống, nhân viên phòng đào tạo hoặc nhân viên quản lý tài sản. Họ có quyền truy cập và quản lý toàn bộ hệ thống, bao gồm thiết lập lịch trình sử dụng giảng đường, quản lý trang thiết bị, xử lý báo cáo sự cố và tạo báo cáo thống kê.

  * Giảng viên: Sử dụng hệ thống để xem lịch trình sử dụng giảng đường của mình, đặt lịch và xác nhận mượn giảng đường cho các công việc đột xuất, và báo cáo sự cố liên quan đến giảng đường.

  * Sinh viên: Sử dụng hệ thống để xem lịch trình sử dụng giảng đường, đặt lịch và xác nhận mượn giảng đường cho các công việc đột xuất. Họ cũng có thể báo cáo sự cố liên quan đến giảng đường.

  * Quản lý sự kiện: Nhóm này bao gồm các nhân viên quản lý sự kiện, tổ chức hội thảo hoặc các hoạt động ngoại khóa. Họ sử dụng hệ thống để đặt lịch và quản lý sự kiện diễn ra trong giảng đường.


## Môi trường hoạt động 

Hệ thống hoạt động trên nền tảng các Web hoặc ứng dụng trên máy tính cá nhân.

## Các ràng buộc thiết kế và cài đặt 

  * Hệ thống sử dụng các công cụ công nghệ:


  * Ngôn ngữ lập trình backend: Java

  * Framework: Spring để giảm thời gian phát triển và tăng tính bảo mật.

  * Cơ sở dữ liệu: Sử dụng hệ quản trị cơ sở dữ liệu PostgreSQL để lưu trữ dữ liệu liên quan đến lịch trình, trang thiết bị, sự cố và người dùng.

  * UI/UX: Sử dụng React kết hợp cùng Ant design


  * Hệ thống chạy trên môi trường website.


## Tài liệu người dùng (User Documentation)

### Hướng dẫn sử dụng:

Tài liệu hướng dẫn sử dụng cung cấp hướng dẫn chi tiết về cách sử dụng các tính năng và chức năng của hệ thống. Nó có thể bao gồm hướng dẫn đăng nhập, đặt lịch sử dụng giảng đường, quản lý thông tin giảng đường, tạo báo cáo, vv.

### Tài liệu hỗ trợ kỹ thuật:

Tài liệu hỗ trợ kỹ thuật cung cấp thông tin về cách cài đặt, cấu hình, và bảo trì hệ thống. Nó có thể bao gồm hướng dẫn về cách triển khai hệ thống, cách sao lưu và khôi phục dữ liệu, và các vấn đề kỹ thuật phổ biến khác.

### Tài liệu API:

Nếu hệ thống cung cấp API cho việc tích hợp với các ứng dụng hoặc dịch vụ khác, tài liệu API sẽ cung cấp thông tin về cách sử dụng API, các yêu cầu và phản hồi được hỗ trợ, và các ví dụ về cách tích hợp.

### Tài liệu quản trị hệ thống:

Tài liệu quản trị hệ thống cung cấp thông tin về cách quản lý người dùng, quyền truy cập, và cấu hình hệ thống. Nó có thể bao gồm hướng dẫn về cách tạo và quản lý tài khoản người dùng, quản lý nhóm người dùng, và cấu hình cài đặt hệ thống.

### Hỗ trợ trực tuyến:

Cung cấp một kênh để người dùng có thể tìm kiếm trợ giúp hoặc yêu cầu hỗ trợ trực tuyến từ nhóm hỗ trợ kỹ thuật. Điều này có thể bao gồm diễn đàn hỗ trợ trực tuyến, trang web hỗ trợ, hoặc hệ thống ticket hỗ trợ.

### Tài liệu đào tạo:

Tài liệu đào tạo cung cấp tài liệu hoặc tài nguyên giáo trình để đào tạo người dùng về cách sử dụng hệ thống một cách hiệu quả. Điều này có thể bao gồm tài liệu học trực tuyến, video hướng dẫn, hoặc các tài liệu đào tạo in ấn.

## Các mặc định và phụ thuộc khác (Assumptions and Dependencies)

  * Danh sách sinh viên đang học tại trường và được cập nhật theo mỗi kỳ học từ phòng Quản lý sinh viên


  * Danh sách cán bộ, giảng viên đang làm việc tại trường

  * Hệ thống phải tuân thủ các quy định về bảo vệ dữ liệu cá nhân và quyền riêng tư theo các


quy định pháp luật hiện hành.

# Yêu cầu về giao tiếp

## Giao tiếp với người dùng (User Interfaces)

Mô tả các đặc tính của mỗi giao diện sử dụng trong hệ thống quản lý và phân bổ giảng

đường bao gồm:

### Hình ảnh màn hình:

  * Cung cấp các hình ảnh minh họa chi tiết về các giao diện người dùng, bao gồm các trang, các màn hình và các thành phần giao diện khác nhau.

  * Đảm bảo rằng hình ảnh màn hình được hiển thị rõ ràng và có thể giải thích được các chức năng và tính năng của hệ thống.


### Chuẩn thiết kế giao diện:

  * Áp dụng các chuẩn thiết kế giao diện như Material Design, Bootstrap, hoặc các chuẩn thiết kế nội bộ của tổ chức để đảm bảo tính nhất quán và trải nghiệm người dùng tốt.

  * Đảm bảo rằng giao diện sử dụng các yếu tố thiết kế như màu sắc, font chữ, kích thước và bố trí phù hợp để tạo ra giao diện hấp dẫn và dễ sử dụng.


### Hướng dẫn thiết kế sản phẩm:

  * Cung cấp hướng dẫn chi tiết về cách sử dụng giao diện người dùng, bao gồm các hướng dẫn sử dụng các tính năng, thực hiện các thao tác và truy cập vào các chức năng khác nhau của hệ thống.

  * Đảm bảo rằng hướng dẫn thiết kế sản phẩm là dễ hiểu và dễ truy cập để người dùng có thể tận dụng tối đa các tính năng của hệ thống.


### Tiêu chuẩn về giao diện:

  * Tuân thủ các tiêu chuẩn về giao diện của hệ thống như độ phản hồi, tương thích với các thiết bị di động, trình duyệt web, và các chuẩn định dạng dữ liệu như JSON hoặc XML

  * Đảm bảo rằng giao diện người dùng đáp ứng đúng các tiêu chuẩn và chuẩn mực về giao diện để tối ưu hóa trải nghiệm người dùng.


### Vào ra dữ liệu:

  * Cung cấp các giao diện dễ sử dụng để nhập liệu từ người dùng, bao gồm các biểu mẫu, trường dữ liệu, và các điều khiển nhập liệu khác nhau.

  * Đảm bảo rằng các giao diện nhập liệu hỗ trợ kiểm tra lỗi và cung cấp thông báo rõ ràng khi người dùng nhập liệu không hợp lệ.


### Thông báo lỗi:

  * Hiển thị thông báo lỗi một cách rõ ràng và dễ hiểu khi xảy ra lỗi trong quá trình sử dụng hệ thống.

  * Cung cấp các thông báo lỗi đầy đủ thông tin và hướng dẫn để người dùng có thể sửa lỗi hoặc liên hệ với hỗ trợ kỹ thuật nếu cần


## Giao tiếp với phần cứng (Hardware Interfaces)

Mô tả các đặc điểm logic và vật lý của giao diện giao tiếp giữa phần mềm và các thiết bị phần cứng của hệ thống quản lý và phân bổ giảng đường bao gồm:

### Kiểu thiết bị:

  * Máy tính cá nhân và thiết bị di động: Hệ thống quản lý và phân bổ giảng đường thường tương tác với máy tính cá nhân, laptop, tablet và điện thoại di động thông qua giao diện người dùng web hoặc ứng dụng di động.

  * Máy chủ: Hệ thống cũng có thể tương tác với các máy chủ để lưu trữ dữ liệu, xử lý yêu cầu và cung cấp dịch vụ.


### Loại tương tác dữ liệu và điều khiển:

  * Người dùng nhập liệu: Người dùng có thể tương tác với hệ thống bằng cách sử dụng chuột và bàn phím để nhập liệu thông qua các biểu mẫu trên giao diệnngười dùng, chẳng hạn như điền thông tin đặt lịch sử dụng giảng đường.

  * Truy vấn và cập nhật dữ liệu: Hệ thống cũng có thể tương tác với cơ sở dữ liệu để truy vấn và cập nhật thông tin về giảng đường, lịch sử đặt lịch, người dùng, vv.

  * Giao diện với thiết bị ngoại vi: Hệ thống có thể giao tiếp với các thiết bị ngoại vi khác như máy in, máy quét mã vạch hoặc thiết bị đo lường thông qua các giao diện tương thích.


### Giao thức truyền thông:

  * HTTP/HTTPS: Giao thức HTTP/HTTPS thường được sử dụng cho việc truyền tải dữ liệu giữa máy tính cá nhân và máy chủ thông qua giao diện người dùng web.

  * SQL: Giao thức SQL thường được sử dụng cho việc truy vấn và cập nhật cơ sở dữ liệu.

  * APIs: Giao thức RESTful hoặc SOAP thường được sử dụng cho việc tương tác giữa hệ thống và các ứng dụng hoặc dịch vụ bên ngoài.


### Đặc điểm vật lý:

  * Kết nối mạng: Hệ thống cần kết nối mạng Internet LAN hoặc WLAN để tương tác với người dùng và dịch vụ trên mạng.

  * Thiết bị lưu trữ: Các dữ liệu cần được lưu trữ trên máy chủ hoặc hệ thống lưu trữ đám mây.

  * Thiết bị người dùng: Người dùng cần sử dụng các thiết bị như máy tính, điện thoại di động hoặc máy tính bảng để truy cập và tương tác với hệ thống

# Public_283

# Quy định chung

## Phạm vi điều chỉnh

Thông tư này quy định các nội dung sau:

1\. Yêu cầu kỹ thuật đối với phần mềm ký số, phần mềm kiểm tra chữ ký số theo quy định tại Điều 17, Nghị định số 23/2025/NĐ-CP ngày 21 tháng 02 năm 2025 của Chính phủ quy định về chữ ký điện tử và dịch vụ tin cậy.

2\. Hướng dẫn kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng theo quy định tại Điều 44, Nghị định số 23/2025/NĐ-CP ngày 21 tháng 02 năm 2025 của Chính phủ quy định về chữ ký điện tử và dịch vụ tin cậy.

## Đối tượng áp dụng

Thông tư này áp dụng:

1\. Tổ chức, cá nhân sử dụng phần mềm ký số, phần mềm kiểm tra chữ ký số; các tổ chức, cá nhân phát triển phần mềm ký số, phần mềm kiểm tra chữ ký số; các Tổ chức cung cấp dịch vụ chứng thực chữ ký số khi phát triển, sử dụng phần mềm ký số, phần mềm kiểm tra chữ ký số.

2\. Các Tổ chức cung cấp dịch vụ chứng thực chữ ký số; các Tổ chức cung cấp dịch vụ chứng thực chữ ký điện tử nước ngoài được công nhận tại Việt Nam; chủ quản các hệ thống thông tin phục vụ giao dịch điện tử có sử dụng chữ ký số khi kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng.

3\. Các tổ chức, cá nhân có liên quan khác.

## Giải thích từ ngữ

Trong Thông tư này, các từ ngữ dưới đây được hiểu như sau:

1\. “Cặp khóa không đối xứng” là khóa công khai và khóa bí mật tương ứng.

2\. “Khóa bí mật” là thành phần của cặp khóa không đối xứng được sử dụng để ký thông điệp dữ liệu.

3\. “Khóa công khai” là thành phần của cặp khóa không đối xứng được sử dụng để xác thực chữ ký số trên thông điệp dữ liệu.

4\. “Hàm băm” là một thuật toán chuyển đổi thông điệp dữ liệu đầu vào thành một chuỗi có độ dài cố định, gọi là mã băm. Hàm băm được sử dụng để kiểm tra tính toàn vẹn của thông điệp dữ liệu và tạo chữ ký số.

5\. “Chủ thể ký” là cá nhân hoặc tổ chức sở hữu chứng thư chữ ký số và sử dụng khóa bí mật tương ứng để thực hiện ký số trên thông điệp dữ liệu.

6\. “Chứng thư chữ ký số” là một dạng chứng thư chữ ký điện tử do Tổ chức cung cấp dịch vụ chứng thực chữ ký số cấp nhằm cung cấp thông tin về khóa công khai của một cá nhân, tổ chức từ đó xác nhận cá nhân, tổ chức là chủ thể ký thông qua việc sử dụng khóa bí mật tương ứng.

7\. “Phần mềm ký số” là chương trình độc lập hoặc một thành phần (module) phần mềm hoặc giải pháp có chức năng ký số vào thông điệp dữ liệu.

8\. “Phần mềm kiểm tra chữ ký số” là chương trình độc lập hoặc một thành phần (module) phần mềm hoặc giải pháp có chức năng kiểm tra tính hợp lệ của chữ ký số trên thông điệp dữ liệu đã ký. 10. “Đường dẫn tin cậy của chứng thư chữ ký số” là danh sách có thứ tự các chứng thư chữ ký số, bao gồm chứng thư chữ ký số của thuê bao, chứng thư chữ ký số của các Tổ chức cung cấp dịch vụ chứng thực chữ ký số và chứng thư chữ ký số gốc tin cậy nhằm xác minh nguồn gốc của chứng thư chữ ký số.

# Yêu cầu kỹ thuật đối với chức năng phần mềm ký số, phần mềm kiểm tra chữ ký số

## Yêu cầu chung

Tuân thủ các yêu cầu và tiêu chuẩn kỹ thuật về chữ ký số trên thông điệp dữ liệu dùng cho phần mềm ký số và phần mềm kiểm tra chữ ký số tại Phụ lục I ban hành kèm theo Thông tư này.

## Yêu cầu về chức năng đối với phần mềm ký số

### Chức năng xác thực chủ thể ký và ký số

a) Kiểm tra được thông tin chủ thể ký trên chứng thư chữ ký số và kiểm tra hiệu lực chứng thư chữ ký số theo quy định tại khoản 2 Điều này trước khi cho phép thực hiện ký số;

b) Cho phép chủ thể ký sử dụng khóa bí mật để thực hiện việc ký số vào thông điệp dữ liệu. Khoá bí mật lưu trong phương tiện lưu khóa bí mật được chủ thể ký sử dụng hoặc ủy quyền sử dụng để ký số phải tuân thủ các tiêu chuẩn bắt buộc áp dụng cho chữ ký số, chứng thư chữ ký số trên thông điệp dữ liệu dùng cho phần mềm ký số và phần mềm kiểm tra chữ ký số tại Phụ lục I ban hành kèm theo Thông tư này;

c) Cho phép chuyển đổi định dạng thông điệp dữ liệu thành các định dạng theo tiêu chuẩn khuyến nghị áp dụng cho phần mềm ký số, phần mềm kiểm tra chữ ký số tại Phụ lục I ban hành kèm theo Thông tư này;

d) Cho phép gắn kèm chữ ký số, chứng thư chữ ký số và thời điểm ký số vào thông điệp dữ liệu sau khi ký số;

đ) Hỗ trợ cài đặt, tích hợp, cập nhật chứng thư chữ ký số của Trung tâm Chứng thực điện tử quốc gia, các Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng và chứng thư chữ ký số thuộc Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

e) Cho phép gắn dấu thời gian tương ứng với chữ ký số trên thông điệp dữ liệu trong trường hợp pháp luật quy định thông điệp dữ liệu cần có dấu thời gian;

g) Đảm bảo tính toàn vẹn của thông điệp dữ liệu đã ký.

### Chức năng kiểm tra hiệu lực của chứng thư chữ ký số

a) Xác thực được thông tin trong chứng thư chữ ký số theo quy định pháp luật về định danh và xác thực điện tử;

b) Kiểm tra được chứng thư chữ ký số của chủ thể ký theo đường dẫn tin cậy của chứng thư chữ ký số đó hoặc theo Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam. Đường dẫn tin cậy phải có liên kết đến chứng thư chữ ký số gốc của Trung tâm Chứng thực điện tử quốc gia;

c) Đáp ứng các yêu cầu về tính hiệu lực của chứng thư chữ ký số tại Phụ lục II ban hành kèm theo Thông tư này.

### Chức năng kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng

a) Phát triển các thành phần, chương trình hoặc giải pháp phục vụ kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng;

b) Tuân thủ Hướng dẫn kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng được quy định tại Điều 8 Thông tư này.

### Chức năng lưu trữ và hủy bỏ các thông tin kèm theo thông điệp dữ liệu ký số, bao gồm:

a) Chứng thư chữ ký số tương ứng với khóa bí mật mà chủ thể ký sử dụng để ký thông điệp dữ liệu tại thời điểm ký số;

b) Danh sách chứng thư chữ ký số thu hồi tại thời điểm ký trong chứng thư chữ ký số của chủ thể ký;

c) Kết quả kiểm tra trạng thái chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu đã ký.

### Chức năng thay đổi (thêm, bớt) chứng thư chữ ký số của cơ quan, tổ chức tạo lập cấp, phát hành chứng thư chữ ký số:

Cho phép tích hợp và hiển thị đầy đủ các Tổ chức cung cấp dịch vụ chứng thực chữ ký số và Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam.

### Chức năng thông báo bằng chữ hoặc ký hiệu cho chủ thể ký biết việc ký số vào thông điệp dữ liệu thành công hay không thành công, bao gồm việc:

a) Hiển thị thông báo về kết quả kiểm tra hiệu lực chứng thư chữ ký số;

b) Hiển thị thông báo ký số thành công hoặc không thành công bằng tiếng Việt;

c) Tải được thông điệp dữ liệu đã ký về thiết bị.

## Yêu cầu về chức năng đối với phần mềm kiểm tra chữ ký số

### Chức năng kiểm tra tính hợp lệ của chữ ký số trên thông điệp dữ liệu:

a) Cho phép xác thực chữ ký số trên thông điệp dữ liệu theo nguyên tắc chữ ký số được tạo ra đúng với khóa bí mật tương ứng với khóa công khai trên chứng thư chữ ký số gắn kèm chữ ký số;

b) Cho phép kiểm tra chứng thư chữ ký số của chủ thể ký theo đường dẫn tin cậy của chứng thư chữ ký số đó và phải liên kết đến Trung tâm Chứng thực điện tử quốc gia hoặc thuộc Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

c) Bảo đảm chứng thư chữ ký số phải đáp ứng các yêu cầu về tính hiệu lực của chứng thư chữ ký số và tính hợp lệ của chữ ký số tại Phụ lục II ban hành kèm theo Thông tư này;

d) Cho phép kiểm tra tính toàn vẹn của thông điệp dữ liệu ký số theo các bước sau: giải mã chữ ký số trên thông điệp dữ liệu bằng khóa công khai trên chứng thư chữ ký số để có thông tin về mã băm của thông điệp dữ liệu; sử dụng hàm băm đã tạo ra mã băm trên chữ ký số để thực hiện tạo mã băm cho thông điệp dữ liệu nhận được; so sánh sự trùng khớp của hai mã băm để kiểm tra tính toàn vẹn của thông điệp dữ liệu ký số;

đ) Đảm bảo kiểm tra được tính hợp lệ của chữ ký số trên thông điệp dữ liệu đã ký theo các yêu cầu về tính hợp lệ của chữ ký số tại Phụ lục II ban hành kèm theo Thông tư này;

e) Hỗ trợ cài đặt, tích hợp, cập nhật chứng thư chữ ký số của Trung tâm Chứng thực điện tử quốc gia, các Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng và chứng thư chữ ký số thuộc Danh sách tin cậy chứng thư chữ ký điện tử nước ngoài được công nhận tại Việt Nam;

g) Đảm bảo tính hợp lệ của dấu thời gian gắn kèm với chữ ký số trong trường hợp chữ ký số được gắn dấu thời gian;

h) Đảm bảo tính toàn vẹn của thông điệp dữ liệu đã ký.

### Chức năng lưu trữ và hủy bỏ các thông tin kèm theo thông điệp dữ liệu ký số:

a) Chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu đã ký;

b) Danh sách chứng thư chữ ký số thu hồi tại thời điểm ký được thể hiện trong chứng thư chữ ký số đính kèm thông điệp dữ liệu đã ký;

c) Kết quả kiểm tra trạng thái chứng thư chữ ký số tương ứng với chữ ký số trên thông điệp dữ liệu đã ký.

### Chức năng thay đổi (thêm, bớt) chứng thư chữ ký số của cơ quan, tổ chức tạo lập, cấp, phát hành chứng thư chữ ký số.

### Chức năng thông báo bằng chữ hoặc ký hiệu việc kiểm tra tính hợp lệ của chữ ký số là hợp lệ hay không hợp lệ:

a) Hiển thị thông báo chữ ký số trên thông điệp dữ liệu đã ký hợp lệ hay không hợp lệ bằng tiếng Việt;

b) Hiển thị các thông tin về chữ ký số và chứng thư chữ ký số trên thông điệp dữ liệu đã ký, với tối thiểu các trường thông tin sau: thông tin về cơ quan, tổ chức tạo lập, cấp, phát hành chứng thư chữ ký số; thông tin về chủ thể ký; thông tin về đơn vị quản lý chứng thư chữ ký số; thông tin về thời điểm ký số hoặc dấu thời gian (nếu có); tính toàn vẹn của thông điệp dữ liệu đã ký; tính hợp lệ của chữ ký số tại thời điểm ký; thời hạn có hiệu lực của chứng thư chữ ký số.

# Cổng kết nói dịch vụ chứng thực chữ ký só công cộng

## Cổng kết nối dịch vụ chứng thực chữ ký số công cộng

1\. Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng được quy định tại Nghị định số 42/2022/NĐ-CP.

2\. Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng phục vụ kết nối dịch vụ chứng thực chữ ký số công cộng với các hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số để bảo đảm tính xác thực, tính toàn vẹn và tính chống chối bỏ của thông điệp dữ liệu.

## Kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng

### Các Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng, cụ thể:

a) Thực hiện theo Hướng dẫn kết nối tại Phụ lục III ban hành kèm theo Thông tư này;

b) Cung cấp các đặc tả, thông số kỹ thuật và thông tin phục vụ kết nối cho Trung tâm Chứng thực điện tử quốc gia;

c) Cập nhật các thông số kỹ thuật hoặc thông tin phục vụ kết nối khi có thay đổi cho Trung tâm Chứng thực điện tử quốc gia.

### Các hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số tích hợp với Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng để bảo đảm tính xác thực, tính toàn vẹn và tính chống chối bỏ của thông điệp dữ liệu, cụ thể:

a) Thực hiện theo Hướng dẫn kết nối tại Phụ lục III ban hành kèm theo Thông tư này;

b) Bảo đảm chức năng ký số của hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số đáp ứng các quy định tại Điều 5 Thông tư này;

### Trung tâm Chứng thực điện tử quốc gia cung cấp, cập nhật các đặc tả, thông số kỹ thuật và thông tin phục vụ việc kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng.

### Đầu mối hỗ trợ, hướng dẫn kết nối đến Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng: Trung tâm Chứng thực điện tử quốc gia, Bộ Khoa học và Công nghệ.

# Điều khoản thi hành

## Tổ chức thực hiện

\- Trung tâm Chứng thực điện tử quốc gia có trách nhiệm hướng dẫn thực hiện các nội dung của Thông tư này và công bố thông tin theo quy định tại khoản 3 Điều 8 Thông tư này.

\- Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng, Tổ chức cung cấp dịch vụ chứng thực chữ ký điện tử nước ngoài được công nhận tại Việt Nam có trách nhiệm công bố chứng thư chữ ký số liên quan đến Tổ chức cung cấp dịch vụ chứng thực chữ ký số và các tiêu chuẩn chữ ký số trên trang tin điện tử của Tổ chức cung cấp dịch vụ chứng thực chữ ký số đó.

## Hiệu lực thi hành

  * Thông tư này có hiệu lực thi hành kể từ ngày ký ban hành.

  * Thông tư số 22/2020/TT-BTTTT ngày 07 tháng 9 năm 2020 của Bộ Thông tin và Truyền thông quy định về yêu cầu kỹ thuật đối với phần mềm ký số, phần mềm kiểm tra chữ ký số hết hiệu lực kể từ ngày Thông tư này có hiệu lực thi hành.

  * Các hệ thống thông tin khi tiến hành phát triển, tích hợp phần mềm, ứng dụng sử dụng chữ ký số thực hiện theo các quy định tại Thông tư này.

  * Chánh Văn phòng, Giám đốc Trung tâm Chứng thực điện tử quốc gia, Thủ trưởng các cơ quan, đơn vị thuộc Bộ, Giám đốc Sở Khoa học và Công nghệ các tỉnh, thành phố trực thuộc Trung ương, cơ quan quản lý nhà nước về giao dịch điện tử theo quy định của pháp luật, tổ chức, cá nhân có liên quan chịu trách nhiệm thi hành Thông tư này.

  * Trong quá trình thực hiện, nếu có khó khăn, vướng mắc, cơ quan, tổ chức, cá nhân phản ánh kịp thời về Bộ Khoa học và Công nghệ (Trung tâm Chứng thực điện tử quốc gia) để xem xét, giải quyết.


PHẦN 1: DANH MỤC TIỂU CHUẢN KỸ THUẬT VỀ CHỮ KÝ SÓ TRÊN THÔNG ĐIỆP DỮ LIỆU DUNG CHO PHẦN MỀM KÝ SÓ VÀ PHẦN MỀM KIỂM TRA CHỮ KÝ SỐ
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Số TT</th>
<th>Loại tiêu chuẩn</th>
<th>Ký hiệu tiêu chuẩn</th>
<th>Tên đầy đủ của tiêu chuẩn</th>
<th>Quy định áp dụng</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="5"><em>1. Tiêu chuẩn bắt buộc áp dụng cho chữ ký số, chứng
thư chữ ký số trên thông điệp dữ liệu dùng cho phần mềm ký số và phần
mềm kiểm tra chữ ký số</em></td>
</tr>
<tr>
<td rowspan="2">1.1</td>
<td rowspan="2">Mật mã đối xứng</td>
<td>TCVN 7816:2007</td>
<td>Công nghệ thông tin - Kỹ thuật mật mã thuật toản mã dũ liệu AES</td>
<td rowspan="2">Áp dụng một trong hai tiêu chuẩn</td>
</tr>
<tr>
<td>FIPS PUB 197</td>
<td>Advanced Encryption Standard</td>
</tr>
<tr>
<td rowspan="2">1.2</td>
<td rowspan="2">Mật mã phi đối xứng và chữ ký số</td>
<td>PKCS #1 (RFC 3447)</td>
<td>RSA Cryptography Standard</td>
<td rowspan="2"><p>- Áp dụng một trong hai tiêu chuẩn</p>
<p>-Đối với tiêu chuẩn RSA:</p>
<p>+ Tối thiểu phiên bản 2.1:</p>
<p>+ Áp dụng lược đồ RSAES-OAEP để mã hoá và RSASSA-PSS để ký.</p>
<p>+ Độ dài khóa tối thiểu là 2048 bit</p>
<p>- Đối với tiêu chuẩn ECDSA: độ dài khóa tối thiểu là 256
bit.</p></td>
</tr>
<tr>
<td>ANSI X9.62-2005</td>
<td>Public Key Cryptography for the Financial Services Industry: The
Elliptic Curve Digital Signature Algorithm (ECDSA)</td>
</tr>
<tr>
<td rowspan="2">1.3</td>
<td rowspan="2">Yêu cầu cho hàm băm</td>
<td>FIPS PUB 180-4</td>
<td>Secure Hash Standard</td>
<td rowspan="2">Áp dụng một trong các hàm băm sau: SHA-256, SHA-384,
SHA-512, SHA-512/224, SHA-512/256, SHA3-224, SHA3-256, SHA3-384,
SHA3-512, SHAKE128, SHAKE256</td>
</tr>
<tr>
<td>FIPS PUB 202</td>
<td>SHA-3 Standard: Permutation-Based Hash and Extendable-Output
Functions</td>
</tr>
<tr>
<td>1.4</td>
<td>Cú pháp thông điệp mật mã</td>
<td><p>PKCS #7</p>
<p>(RFC 2630)</p></td>
<td>Cryptographic Message Syntax Standard</td>
<td>Phiên bản 1.5</td>
</tr>
<tr>
<td rowspan="5">1.5</td>
<td rowspan="5">Chứ ký số cho PDF</td>
<td>ETSI EN 319 142-1</td>
<td><p>Electronic Signatures and Infrastructures</p>
<p>(ESI);</p>
<p>PAdES digital signatures; Part 1: Building blocks and PAdES baseline
signatures</p></td>
<td rowspan="5"><p>Áp dụng một trong hai bộ tiêu chuẩn: ETSI EN 319
142-1 Phiên bản V1.2.1</p>
<p>ETSI EN 319 142-2 Phiên bản V1.1.1 Hoặc</p>
<p>ISO 14533-3:2017</p>
<p>ISO 32000-1:2008</p>
<p>ISO 32000-2:2020</p></td>
</tr>
<tr>
<td>ETSI EN 319 142-2</td>
<td>Electronic Signatures and Infrastructures (ESI); PAdES digital
signatures; Part 2: Additional PAdES signatures profiles</td>
</tr>
<tr>
<td>ISO 32000- 1:2008</td>
<td>Document management - Portable document format - Part 1: PDF
1.7</td>
</tr>
<tr>
<td>ISO 14533- 3:2017</td>
<td>Processes, data elements and documents in commerce, industry and
administration — Longterm signature formats — Part 3: Long-term
signature profiles for PDF Advanced Electronic Signatures (PAdES)</td>
</tr>
<tr>
<td>ISO 32000- 2:2020</td>
<td>Document management - Portable document format - Part 2: PDF
2.0</td>
</tr>
<tr>
<td rowspan="2">1.6</td>
<td rowspan="2">Chữ ký số cho XML</td>
<td>ETSI EN 319 132-1</td>
<td>Electronic Signatures and Infrastructures (ESI); XAdES digital
signatures; Part 1: Building blocks and XAdES baseline signatures</td>
<td>Phiên bản V1.2.1</td>
</tr>
<tr>
<td>ETSI EN 319 132-2</td>
<td>Electronic Signatures and Infrastructures (ESI); XAdES digital
signatures; Part 2: Extended XAdES signatures</td>
<td>Phiên bản V1.1.1</td>
</tr>
<tr>
<td rowspan="3">1.7</td>
<td rowspan="3">Chữ ký số cho CMS</td>
<td>ETSI EN 319 122-1</td>
<td>lectronic Signatures and Infrastructures (ESI); CAdES digital
signatures; Part 1: Building blocks and CAdES baseline signatures</td>
<td>Phiên bån V1.3.1</td>
</tr>
<tr>
<td>ETSI EN 319 122-2</td>
<td>Electronic Signatures and Infrastructures (ESI); CAdES digital
signatures; Part 2: Extended CAdES signatures</td>
<td>Phiên bản V1.1.1</td>
</tr>
<tr>
<td>ETSI TS 119 122-3</td>
<td>Electronic Signatures and Infrastructures (ESI); CAdES digital
signatures; Part 3: Incorporation of Evidence Record Syntax (ERS)
mechanisms in CAdES</td>
<td>Phiên bản V1.1.1</td>
</tr>
<tr>
<td rowspan="3">1.8</td>
<td rowspan="3">Yêu cầu đối với phần cứng HSM</td>
<td>FIPS PUB 140-2</td>
<td>Security Requirements for Cryptographic Modules</td>
<td rowspan="3"><p>- Áp dụng một trong ba tiêu chuẩn.</p>
<p>- Đối với các tiêu chuẩn FIPS PUB 140-2/ FIPS PUB</p>
<p>140-3: Yêu cầu tối thiểu mức 3 (level 3)</p></td>
</tr>
<tr>
<td>FIPS PUB 140-3</td>
<td>Security Requirements for Cryptographic Modules</td>
</tr>
<tr>
<td>EN 419221- 5:2018</td>
<td>Protection Profiles for TSP Cryptographic modules - Part 5:
Cryptographic Module for Trust Services</td>
</tr>
<tr>
<td rowspan="2">1.9</td>
<td rowspan="2">Yêu cầu đối với thẻ Token và Smart card</td>
<td>FIPS PUB 140-2</td>
<td>Security Requirements for Cryptographic Modules</td>
<td rowspan="2"><p>- Áp dụng một trong hai tiêu chuân.</p>
<p>- Yêu cầu tối thiều mức 2 (level 2)</p></td>
</tr>
<tr>
<td>FIPS PUB 140-3</td>
<td>Security Requirements for Cryptographic Modules</td>
</tr>
<tr>
<td rowspan="3">1.10</td>
<td rowspan="3">Yêu cầu đối với thẻ SIM</td>
<td>FIPS PUB 140-2</td>
<td>Security Requirements for Cryptographic Modules</td>
<td rowspan="3"><p>- Áp dụng một trong ba tiêu chuẩn.</p>
<p>- Đối với các tiêu chuẩn FIPS PUB 140-2/ FIPS PUB 140-3: Yêu cầu tối
thiểu mức 2 (level 2);</p>
<p>- Đối với tiêu chuẩn TCVN 8709 (ISO/IEC 15408): Yêu cầu tối thiểu EAL
mức 4 (level 4)</p></td>
</tr>
<tr>
<td>FIPS PUB 140-3</td>
<td>Security Requirements for Cryptographic Modules</td>
</tr>
<tr>
<td>TCVN 8709 (ISO/IEC 15408)</td>
<td><p>Công nghệ thông tin – Các kỹ thuật an toàn – Các tiêu chí đánh
giá an toàn công nghệ thông tin</p>
<p>(Common Criteria for Information Technology Security
Evaluation)</p></td>
</tr>
<tr>
<td rowspan="2">1.11</td>
<td rowspan="2">Yêu cầu chính sách cho Tổ chức cung cấp dịch vụ tạo chữ
|ký số của khách hàng</td>
<td>ETSI TS 119 431-1</td>
<td>Electronic Signatures and Infrastructures (ESI); Policy and security
requirements for trust service providers; Part 1: TSP service components
operating a remote QSCD/SCDev</td>
<td>Phiên bản V1.2.1</td>
</tr>
<tr>
<td>ETSI TS 119 431-2</td>
<td>Electronic Signatures and Infrastructures (ESI); Policy and security
requirements for trust service providers; Part 2: TSP service components
supporting AdES digital signature creation</td>
<td>Phiên bản V1.2.1</td>
</tr>
<tr>
<td>1.12</td>
<td>Giao thức tạo chữ ký số</td>
<td>ETSI TS 119 432</td>
<td>Electronic Signatures and Infrastructures (ESI); Protocols for
remote digital signature creation</td>
<td>Phiên bản V1.2.1</td>
</tr>
<tr>
<td>1.13</td>
<td>Ứng dụng ký trên máy chủ ký số</td>
<td>EN 419241- 1:2018</td>
<td>Trustworthy Systems Supporting Server Signing - Part 1: General
system security requirements</td>
<td></td>
</tr>
<tr>
<td>1.14</td>
<td>Yêu cầu cho mô đun ký số</td>
<td>EN 419241- 2:2019</td>
<td>Trustworthy Systems Supporting Server Signing - Part 2: Protection
Profile for QSCD for Server Signing</td>
<td></td>
</tr>
<tr>
<td>1.15</td>
<td>Yêu cầu đối với phần cứng HSM</td>
<td>EN 419221- 5:2018</td>
<td>Protection Profiles for TSP Cryptographic modules - Part 5:
Cryptographic Module for Trust Services</td>
<td></td>
</tr>
<tr>
<td>1.16</td>
<td>Giao thức truyền, nhận chứng thư chữ ký số và danh sách chứng thư
chữ ký số bị thu hồi</td>
<td>RFC 2585</td>
<td>Internet X.509 Public Key Infrastructure - Operational Protocols:
FTP and HTTP</td>
<td>Áp dụng một hoặc cả hai giao thức FTP và HTTP</td>
</tr>
<tr>
<td>1.17</td>
<td>Giao thức cho kiểm tra trạng thái chứng thu chữ ký số trực
tuyến</td>
<td>RFC 6960</td>
<td>X.509 Internet Public Key Infrastructure Online Certificate Status
Protocol - OCSP</td>
<td></td>
</tr>
<tr>
<td>1.18</td>
<td>Định dạng chứng thư chữ ký số và danh sách thu hồi chứng thư chữ ký
số</td>
<td>RFC 5280</td>
<td>Internet X.509 Public Key Infrastructure Certificate and Certificate
Revocation List (CRL) Profile</td>
<td></td>
</tr>
<tr>
<td colspan="5"><em>2. Tiêu chuần bắt buộc áp dụng cho phần mềm ký số,
phần mềm kiểm tra chữ ký số</em></td>
</tr>
<tr>
<td>2.1</td>
<td>Bộ ký tự và mã hóa cho tiếng Việt</td>
<td>TCVN 6909:2001</td>
<td>TCVN 6909:2001 “ Công nghệ thông tin-Bộ mã ký tự tiếng Việt
16-bit"</td>
<td>Bắt buộc áp dụng</td>
</tr>
<tr>
<td>2.2</td>
<td>Giao thức đường truyền</td>
<td>RFC 9110</td>
<td>HTTP Semantics</td>
<td>HTTP/1.1</td>
</tr>
<tr>
<td>2.3</td>
<td>Giao thức bảo mật tầng giao vận</td>
<td>RFC 5246</td>
<td>The Transport Layer Security (TLS) Protocol Version 1.2</td>
<td>Áp dụng tối thiểu TLS 1.2</td>
</tr>
<tr>
<td colspan="5"><em>3. Tiêu chuần khuyến nghị áp dụng cho phần mềm ký
số, phần mềm kiểm tra chứ ký số</em></td>
</tr>
<tr>
<td>3.1</td>
<td>Bộ ký tự và mã hóa</td>
<td>ASCII</td>
<td>American Standard Code for Information Interchange</td>
<td></td>
</tr>
<tr>
<td>3.2</td>
<td>Trình diễn bộ ký tự</td>
<td>UTF-8</td>
<td>8-bit Universal Character Set (UCS)/ Unicode Transformation
Format</td>
<td></td>
</tr>
<tr>
<td rowspan="2">3.3</td>
<td rowspan="2">Ngôn ngữ định dạng thông điệp dữ liệu</td>
<td>XML v1.0 (5th Edition)</td>
<td>Extensible Markup Language version 1.0 (5th Edition)</td>
<td rowspan="2">Áp dụng tối thiểu XML v1.0</td>
</tr>
<tr>
<td>XML v1.1 (2nd Edition)</td>
<td>Extensible Markup Language version 1.1</td>
</tr>
<tr>
<td>3.4</td>
<td>Định nghĩa các lược đồ trong tài liệu XML</td>
<td>XML Schema version 1.1</td>
<td>XML Schema version 1.1</td>
<td></td>
</tr>
<tr>
<td>3.5</td>
<td>Trao đổi dũ liệu đặc tả tài liệu XML</td>
<td>XML v2.4.2</td>
<td>XML Metadata Interchange version 2.4.2</td>
<td></td>
</tr>
<tr>
<td rowspan="2">3.6</td>
<td rowspan="2">Định dạng PDF</td>
<td>ISO 32000- 1:2008</td>
<td>Document management - Portable document format - Part 1: PDF
1.7</td>
<td rowspan="2">Áp dụng tối thiểu PDF 1.7</td>
</tr>
<tr>
<td>ISO 32000- 2:2020</td>
<td>Document management - Portable document format - Part 2: PDF
2.0</td>
</tr>
<tr>
<td>3.7</td>
<td>Định dạng JSON</td>
<td>RFC 7159</td>
<td>The JavaScript Object Notation (JSON) Data Interchange Format</td>
<td></td>
</tr>
<tr>
<td rowspan="2">3.8</td>
<td rowspan="2">Cú pháp mã hóa và cách xử lý thông điệp dữ liệu định
dạng XML</td>
<td>XML Encryption Syntax and Processing</td>
<td>XML Encryption Syntax and Processing</td>
<td rowspan="2"></td>
</tr>
<tr>
<td>XML Signature Syntax and Processing</td>
<td>XML Signature Syntax and Processing</td>
</tr>
<tr>
<td>3.9</td>
<td>Quản lý khóa công khai thông điệp dũ liệu định dạng XML</td>
<td>XKMS v2.0</td>
<td>XML Key Management Specification version 2.0</td>
<td></td>
</tr>
<tr>
<td>3.10</td>
<td>Chũ ký số cho JSON</td>
<td>RFC 7515</td>
<td>JSON Web Signature (JWS)</td>
<td></td>
</tr>
</tbody>
</table> 

PHẦN 2: DANH MỤC YÊU CẦU ĐÁNH GIÁ TÍNH HIỆU LỰC CỦA CHỨNG THƯ CHỮ KÝ SỐ VÀ TÍNH HỢP LỆ CỦA CHỮ KÝ SỐ TRONG PHẦN MỀM KÝ SỐ, PHẦN MÈM KIỂM TRA CHỮ KÝ SỐ
<table>
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr>
<th>Số TT</th>
<th>Yêu cầu đánh giá</th>
<th>Hiệu lực/hợp lệ</th>
<th>Quy định áp dụng</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td colspan="3">Tính hiệu lực của chứng thư chữ ký số</td>
</tr>
<tr>
<td>1.1</td>
<td>Thời gian có hiệu lực của chứng thư chữ ký số</td>
<td><p>- Thời điểm ký số nằm trong thời gian có hiệu lực của chứng thư
chữ ký số.</p>
<p>- Thời gian có hiệu lực của chứng thư chữ ký số tính từ thời điểm
Valid from đến thời điểm Valid to. - Chứng thư chữ ký số không bị tạm
dừng |hoặc thu hổi tại thời điểm ký số.</p></td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>1.2</td>
<td><p>- Trạng thái chứng thư chũ ký số qua danh sách chứng thư chữ ký
số thu hồi (CRL) được công bố tại thời điểm ký số;</p>
<p>- Trạng thái chứng thư chữ ký số trực tuyến (OCSP) ở chế độ trực
tuyến trong trường hợp Tổ chức cung cấp dịch vụ chứng thực chữ ký số có
cung cấp dịch vụ OCSP.</p></td>
<td>OCSP và CRL tuân theo tiêu chuẩn nêu tại Phụ lục I. Trường hợp sử
dụng OCSP, phần mềm phải được s dụng ở chế độ trực tuyến. - Trường hợp
sử dụng CRL, CRL phải là CRL mới nhất tại thời điểm ký số. - Trường hợp
không thể kiểm tra trạng thái chứng thư chữ ký số thông qua OCSP/CRL,
phần mềm phải hiển thị cảnh báo tương ứng cho chủ thể ký.</td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>1.3</td>
<td>Thuật toán mật mã trên chứng thư chữ ký số</td>
<td>Các thuật toản mật mã trên chứng thư chữ ký số tuân thủ theo quy
định về quy chuẩn, tiêu chuẩn kỹ thuật bắt buộc áp dụng về chữ ký số và
dịch vụ chứng thực chữ ký số đang có hiệu lực.</td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>1.4</td>
<td>Phạm vi sử dụng của chứng thư chữ ký số</td>
<td>Chúng thư chữ ký số được sử dụng đúng phạm vi trong các quy định về
chữ ký điện tử và dịch vụ tin cậy.</td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>1.5</td>
<td>Mục đích sử dụng của chứng thư chữ ký số</td>
<td>Mục đích sử dụng chứng thư chữ ký số tại các trường thông tin Key
Usage, Extended Key Usage.</td>
<td>Chức năng tùy chọn</td>
</tr>
<tr>
<td>1.6</td>
<td>Các tuyên bố khác của Tổ chức cung cấp dịch vụ chứng thực chữ ký
số</td>
<td>Các tuyên bố khác không nằm ngoài phạm vi Quy chế chứng thực của Tổ
chức cung cấp dịch vụ chứng thực chữ ký số tại mục Issuer
Statement.</td>
<td>Chức năng tùy chọn</td>
</tr>
<tr>
<td>2</td>
<td colspan="3">Tính hợp lệ của chữ ký số</td>
</tr>
<tr>
<td>2.1</td>
<td>Thông tin về chủ thể ký</td>
<td>Kiểm tra, xác thực được đúng thông tin chủ thể ký số trên thông điệp
dữ liệu</td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>2.2</td>
<td>Cách thức tạo chữ ký số</td>
<td>hữ ký số được tạo ra đúng bởi khóa bí mật tương ứng với khóa công
khai trên chứng thư chữ ký số theo các bước tại điểm d, khoản 1, Điều 6
Thông tư này.</td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>2.3</td>
<td>Chứng thư chữ ký số kèm theo thông điệp dữ liệu</td>
<td>Chứng thư chữ ký số có hiệu lực tại thời điểm ký số.</td>
<td>Chức năng bắt buộc</td>
</tr>
<tr>
<td>2.4</td>
<td>Tính toàn vẹn của thông điệp dữ liệu</td>
<td>Mã băm có được từ việc băm thông điệp dữ liệu và mã băm có được khi
giải mã chữ ký số trùng nhau</td>
<td>Chức năng bắt buộc</td>
</tr>
</tbody>
</table> 

PHẦN 3: HƯỚNG DẦN KẾT NỐI ĐẾN CÔNG KẾT NỐI DỊCH VỤ CHỨNG THỰC CHỮ KÝ SỐ CÔNG CỘNG DO BỘ KHOA HỌC VÀ CÔNG NGHỆ XÂY DỰNG

1\. Mô hình kết nối

Mô hình kết nối với Cổng kết nối dịch vụ chứng thực chữ ký số công cộng do Bộ Khoa học và Công nghệ xây dựng (sau đây gọi là Cồng eSign) được mô tả tại sơ đồ nhu sau:

|<image_1>|

Chú thích:

\- HTTT: Hệ thống thông tin phục vụ giao dịch điện tử sử dụng chữ ký số.

\- CA: Tổ chức cung cấp dịch vụ chứng thực chữ ký số công cộng.

2\. Các thông tin phục vụ kết nối

a) Giao thức sử dụng để kết nối là API, phương thức kết nối là POST.

b) Đường dẫn kết nối các API: <https://esign.neac.gov.vn>

c) Thông tin Cổng eSign cung cấp cho các HTTT gồm: sp_id và sp_password hoặc token, trong đó:

\- sp_id: Mã xác thực được cấp cho HTTT.

\- sp_password: Mật khẩu kết nối được cấp cho HTTT tương ứng với sp_id.

\- token: Thông tin xác thực được cấp cho HTTT.

d) Giao thức bảo mật đường truyền khi kết nối tối thiểu là TLS 1.2.

### TASK QA
num_correct,answers
1,B
1,B
1,C
1,C
1,B
1,A
1,D
2,"A,B"
1,B
1,A
1,C
1,B
2,"B,C"
1,B
1,D
1,C
1,B
1,B
1,B
1,A
1,A
1,B
1,B
1,B
1,C
1,B
1,A
1,B
1,B
1,D
1,B
1,C
1,B
1,B
1,A
1,B
1,C
1,A
1,B
1,A
1,A
1,C
1,C
1,B
1,C
1,C
1,A
1,B
1,C
1,B
1,C
1,B
1,A
1,B
1,A
1,B
1,C
1,A
1,B
1,C
1,A
1,B
1,A
1,B
1,C
1,A
1,C
1,B
1,B
1,C
1,B
1,A
1,B
1,B
1,C
1,B
1,A
1,B
1,C
1,B
1,B
1,D
1,A
1,B
1,C
1,A
1,C
1,A
1,B
1,C
1,C
1,A
1,B
1,B
1,D
1,B
1,C
1,C
1,B
1,C
1,B
1,C
1,C
1,B
1,C
1,B
1,C
1,C
1,B
1,C
1,B
1,C
1,A
1,B
1,C
1,B
1,C
1,B
1,A
1,C
1,B
1,C
1,A
1,A
1,C
1,B
1,C
1,B
1,B
1,C
1,B
1,C
1,A
1,B
1,C
1,C
1,B
1,A
1,B
1,C
1,A
1,B
1,A
1,B
1,C
1,A
1,B
1,A
1,B
1,D
1,A
1,B
1,B
1,B
1,C
1,A
1,B
1,B
1,B
1,A
1,B
1,C
1,B
1,B
1,C
1,A
1,C
1,B
1,B
1,D
1,A
1,C
1,B
1,A
1,D
1,D
1,B
1,C
1,A
1,C
1,D
1,A
1,C
1,B
1,B
1,B
1,A
1,D
1,D
1,C
1,D
1,A
1,C
1,B
1,A
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,D
1,A
1,C
1,B
1,A
1,D
1,C
1,B
1,A
1,C
1,C
1,B
1,A
1,D
1,B
1,C
1,A
1,C
1,B
1,D
1,A
1,D
1,A
1,A
1,C
1,C
1,D
1,B
1,B
1,C
1,A
1,B
1,D
1,A
1,D
1,B
1,A
1,C
1,A
1,A
1,C
1,C
1,A
1,B
1,A
1,C
1,C
1,B
1,D
1,D
1,A
1,C
1,B
1,D
1,D
1,C
1,A
1,B
1,A
1,B
1,A
1,C
1,C
1,B
1,B
1,C
1,A
1,D
1,C
1,D
1,C
1,B
1,A
1,C
1,A
1,D
1,A
1,B
1,C
1,A
1,B
1,B
1,C
1,B
1,A
1,D
1,C
1,A
1,B
1,B
1,C
1,D
1,A
1,C
1,B
1,C
1,D
1,C
1,A
1,D
1,C
2,"B,C"
1,C
1,C
1,D
1,B
1,A
1,C
1,A
1,B
1,A
1,C
1,B
1,A
1,B
1,B
1,C
1,A
1,D
1,A
1,B
1,B
1,B
1,A
1,D
1,B
1,B
1,C
1,D
1,C
1,B
1,D
1,C
1,C
1,B
1,A
1,A
1,B
1,C
1,B
1,A
1,D
1,A
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,B
1,A
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,C
1,B
1,C
1,A
1,A
1,C
1,B
1,C
1,A
1,A
1,B
1,A
1,C
1,A
1,D
1,A
1,B
1,C
1,A
1,D
1,C
1,C
1,B
1,A
1,A
1,C
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,D
1,A
1,C
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,A
1,A
1,B
1,C
1,A
1,D
1,A
1,B
1,C
1,A
1,D
1,A
1,B
1,D
1,A
1,A
1,A
1,B
1,C
1,A
1,A
1,A
1,B
1,D
1,A
1,A
1,A
1,B
1,A
1,A
1,D
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,A
1,B
1,C
1,A
1,A
1,A
1,A
1,A
1,A
1,B
1,B
1,C
1,C
1,A
1,B
1,A
1,C
1,B
1,B
1,B
1,B
1,B
1,A
1,C
1,C
1,A
1,C
1,B
1,B
1,B
1,C
1,B
1,A
1,B
1,C
1,B
1,B
1,B
1,A
1,A
1,A
1,B
1,B
1,A
1,B
1,A
1,B
1,C
1,B
1,C
1,B
1,D
1,A
1,B
1,C
1,A
1,A
1,A
1,B
1,C
1,A
1,A
1,A
1,D
1,C
1,A
1,C
1,B
1,B
1,D
1,D
1,B
1,D
1,B
1,C
1,B
1,B
1,B
1,D
1,B
1,C
1,B
1,A
1,B
1,D
1,D
1,C
1,C
1,A
1,C
1,A
1,A
1,B
1,D
1,A
1,B
1,D
1,B
1,B
1,A
1,C
1,C
1,B
1,A
1,B
1,B
1,A
1,A
1,B
1,B
1,A
1,C
1,C
1,B
1,A
1,D
1,A
1,A
1,C
1,C
1,D
1,D
1,A
1,B
1,C
1,A
1,C
1,B
1,B
1,B
1,C
1,B
1,A
1,B
1,B
1,C
1,B
1,B
1,B
1,C
1,B
1,C
1,C
1,C
1,A
1,A
1,C
1,A
1,B
1,B
1,A
1,B
1,C
1,D
1,C
1,C
1,A
1,A
1,B
1,D
1,B
1,B
1,A
1,A
1,D
1,A
1,C
1,D
1,C
1,B
1,A
1,B
1,B
1,B
1,C
1,C
1,A
1,B
1,A
1,A
1,B
1,B
1,C
1,B
1,A
1,C
1,A
1,B
1,B
1,A
1,C
1,D
1,B
1,C
1,B
1,D
1,B
1,B
1,C
1,D
1,A
1,B
1,B
1,A
1,B
1,B
1,A
1,A
1,C
1,A
1,B
1,C
1,A
1,D
1,C
1,C
1,A
1,C
1,A
1,C
1,A
1,C
1,B
1,C
1,B
1,C
1,B
1,B
1,B
1,A
1,A
1,A
1,C
1,D
1,B
1,A
1,B
1,B
1,A
1,A
1,C
1,B
1,C
1,B
1,C
1,C
1,D
1,A
1,C
1,B
1,C
1,C
1,A
1,B
1,B
1,B
1,B
1,A
1,A
1,B
1,C
1,B
1,A
1,A
1,B
1,B
1,A
1,B
1,B
1,B
1,A
1,B
1,B
1,B
1,B
1,B
1,B
1,A
1,B
1,B
1,A
1,A
1,B
1,A
1,C
1,B
1,B
1,A
3,"A,B,C"
1,A
2,"A,C"
1,B
1,B
1,D
1,B
1,B
1,A
1,A
1,B
1,C
1,C
1,C
1,B
1,B
1,A
1,B
1,A
1,B
1,A
1,C
2,"A,C"
1,B
1,B
1,B
1,D
1,A
1,A
1,D
1,B
1,C
1,C
1,B
1,B
1,A
1,B
1,B
1,C
1,B
3,"A,B,D"
1,B
1,A
1,C
1,A
1,B
1,B
1,B
1,A
2,"A,B"
1,C
1,C
1,D
1,B
1,A
1,A
1,A
1,A
1,B
1,A
1,A
1,B
1,B
1,A
1,A
2,"A,C"
1,C
1,A
1,A
1,B
1,B
1,B
1,B
1,B
1,C
1,C
1,D
1,B
1,B
1,B
1,C
1,B
1,A
1,C
1,B
1,A
1,D
1,B
1,B
1,A
1,A
2,"C,D"
1,B
1,C
1,A
2,"A,B"
1,C
1,B
1,B
1,A
1,A
1,A
1,B
1,C
1,C
1,B
1,D
1,B
1,B
1,D
1,B
1,D
1,B
1,A
2,"A,B"
1,D
1,A
1,A
1,B
1,C
1,B
1,B
1,B
1,A
3,"A,B,D"
1,C
1,A
1,D
1,B
1,B
1,B
1,B
1,B
1,A
1,C
1,B
1,B
2,"A,B"
1,B
1,B
1,C
1,C
1,C
1,C
1,A
1,A
1,A
1,C
1,C
1,B
1,A
1,C
1,C
1,C
1,B
2,"A,D"
1,B
1,B
1,D
1,C
1,B
1,B
1,B
1,A
1,C
3,"A,B,C"
2,"B,C"
1,D
2,"A,C"
1,C
1,B
1,A
1,C
1,A
1,B
1,D
1,C
1,A
1,C
1,A
1,D
1,B
1,A
1,C
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,C
1,C
1,B
1,A
1,A
2,"A,D"
1,B
1,C
1,C
1,B
1,B
1,A
1,A
1,B
2,"A,B"
2,"C,D"
1,A
1,A
1,A
1,A
1,A
1,B
1,C
1,D
1,B
1,B
1,B
1,A
1,B
1,B
