### TASK EXTRACT
# Public_001

_Công nghệ ứng dụng vào mô hình nhà thông minh dựa trên Internet vạn vật (IoT - Internet of Things) phần lớn bị hạn chế và phân tán. Các đánh giá trong bài viết được thực hiện để phân loại bối cảnh nghiên cứu về ứng dụng IoT xây dựng mô hình nhà thông minh, nhằm cung cấp những hiểu biết có giá trị về công nghệ và hỗ trợ các nhà nghiên cứu hiểu các nền tảng có sẵn và các lỗ hổng trong lĩnh vực này. Chúng tôi tiến hành tìm kiếm các bài viết liên quan đến (1) nhà thông minh, (2) ứng dụng và (3) IoT trong ba cơ sở dữ liệu chính, cụ thể là: Web of Science, ScienceDirect và IEEE Explore. Các cơ sở dữ liệu này chứa tài liệu về các ứng dụng nhà thông minh sử dụng IoT. Tập dữ liệu thu được bao gồm 229 bài báo được chia thành bốn lớp. Lớp đầu tiên bao gồm các bài viết đánh giá và khảo sát liên quan đến IoT trong mô hình xây dựng nhà thông minh, lớp thứ hai bao gồm các tài liệu ứng dụng IoT và việc sử dụng chúng, lớp thứ ba chứa các đề xuất để phát triển và vận hành các ứng dụng IoT, lớp cuối cùng bao gồm các nghiên cứu thực tế để phát triển IoT ứng dụng nhà thông minh. Sau đó xác định các đặc điểm cơ bản của lĩnh vực mới này theo các khía cạnh: sử dụng IoT vào nhà thông minh cùng những thách thức và các đề xuất để cải tiến._

# Nội dung chính

## Giới thiệu

Nhà thông minh cổ điển, IOT, điện toán đám mây (Cloud Computing) và xử lý sự kiện dựa trên quy tắc, là những nền tảng của nhà thông minh tiên tiến. Mỗi nền tảng đóng góp các thuộc tính và công nghệ cốt lõi của nó. IoT thì kết nối internet và quản lý từ xa các thiết bị di động, được tích hợp với nhiều loại cảm biến. Cảm biến có thể được gắn vào các thiết bị gia đình chẳng hạn như máy lạnh, đèn và các thiết bị khác. Điện toán đám mây cung cấp khả năng tính toán, không gian lưu trữ, phát triển các ứng dụng, duy trì, thực thi các dịch vụ và truy cập các thiết bị gia đình ở bất kỳ đâu vào bất kỳ thời điểm nào. (D. Halabi, S. Hamdan và S. Almajali, 2018).

Phần này giải thích sự tích hợp các nền tảng nhà thông minh cổ điển, IoT và điện toán đám mây. Các phần còn lại sẽ trình bày chi tiết về các nền tảng. Phần 2 sẽ mô tả ngôi nhà thông minh cổ điển, phần 3 giới thiệu IOT, phần 4 trình bày điện toán đám mây, phần 5 sẽ trình bày mô-đun xử lý sự kiện, phần ó mô tả nhà thông minh tiên tiến kết hợp các nền tảng này, cuối cùng phần 7 cung cấp một số thông tin thực tế và các lựa chọn liên quan xây dựng, triển khai nhà thông minh tiên tiến thực tế. Mô tả thử nghiệm qua ba ví dụ cho thấy bản chất sự tích hợp sẽ được trình bày trong phần 8. Cuối cùng, xác định các vấn đề mở và hướng đi trong tương lai của các nền tảng ứng dụng vào nhà thông minh tiên tiến. (Q. Lyu, N. Zheng, H. Liu, C. Gao, S. Chen và J. Liu, 2019).

## Nhà thông minh trước năm 2010

Năm 2008, nhà thông minh là một ý tưởng tự động hóa ngôi nhà, liên quan đến việc kiểm soát, tự động hóa tất cả công nghệ tích hợp trong nó. Nó xác định nơi có các thiết bị, ánh sáng, hệ thống sưởi, điều hòa không khí, TV, máy tính, hệ thống giải trí, thiết bị gia dụng lớn như máy giặt/ máy sấy và tủ lạnh/ tủ đông, hệ thống an ninh và camera có khả năng giao tiếp với nhau và được điều khiển từ xa bằng thời gian biểu, điện thoại, di động hoặc internet. Các hệ thống này bao gồm các công tắc và cảm biến được kết nối tới trung tâm được điều khiển bởi con người bằng thiết bị đầu cuối hoặc thiết bị di động được kết nối với các dịch vụ đám mây. (Funk, M., Chen, L.-L, Yang, S.-W.., & Chen, Y.-K., 2018).

Vào năm 2009, nhà thông minh được cung cấp nhằm mục đích an ninh, sử dụng năng lượng hiệu quả, chi phí vận hành thấp và tiện lợi. Việc lắp đặt các sản phẩm thông minh mang lại sự tiện lợi và tiết kiệm thời gian, tiền bạc và năng lượng. Các hệ thống như vậy có thể thích ứng và điều chỉnh để đáp ứng nhu cầu thay đổi liên tục của chủ nhà. Trong hầu hết các trường hợp, cơ sở hạ tầng của nó đủ linh hoạt để tích hợp với nhiều loại thiết bị từ các nhà cung cấp với nhiều tiêu chuẩn khác nhau. (Ghajargar, M., Wiberg, M., & Stolterman, E., 2018).

Năm 2010, sự phổ biến của nhà thông minh phát triển với tốc độ cao, nó đã trở thành một phần của xu hướng hiện đại hóa và giảm các chi phí bằng cách tích hợp khả năng duy trì nhật ký các sự kiện, thực hiện các quy trình học máy để cung cấp. (AC Jose và R. Malekian, 2018).

### Dịch vụ nhà thông minh

#### Đo điều kiện nhà

Năm 2010, nhà thông minh được trang bị một bộ cảm biến để đo các điều kiện trong nhà, chẳng hạn như: nhiệt độ, độ ẩm, ánh sáng và khoảng cách. Mỗi cảm biến thực hiện một chức năng riêng nhằm ghi lại một hoặc nhiều phép đo. Nhiệt độ và độ ẩm có thể được đo bởi một cảm biến hoặc các cảm biến khác tính toán tỷ lệ ánh sáng cho một khu vực nhất định và khoảng cách từ nó đến mỗi đối tượng tiếp xúc với nó. Tất cả các cảm biến đều cho phép lưu trữ dữ liệu và hiển thị trực quan để người dùng có thể xem ở bất kỳ đâu và bất kỳ lúc nào. Để làm như vậy, cần có một bộ xử lý tín hiệu, một giao thức truyền thông và một máy chủ lưu trữ trên cơ sở hạ tầng đám mây. (N. Ghosh, S. Chandra, V. Sachidananda và Y. Elovici, 2019).

#### Quản lý thiết bị gia dụng

Năm 2010, các dịch vụ đám mây được tạo ra để quản lý và lưu trữ dữ liệu các thiết bị gia dụng. Việc quản lý cho phép người dùng kiểm soát đầu ra của thiết bị truyền động thông minh liên quan đến các thiết bị gia dụng, chẳng hạn như đèn và quạt. Thiết bị truyền động thông minh là các thiết bị, chẳng hạn như van và công tắc, thực hiện các hành động như bật hoặc tắt hoặc điều chỉnh hệ thống hoạt động. Bộ truyền động cung cấp nhiều chức năng khác nhau, chẳng hạn như dịch vụ van bật/ tắt, định vị tỷ lệ phần trăm mở, điều chỉnh để kiểm soát các thay đổi về điều kiện dòng chảy, tắt khẩn cấp (ESD). Để kích hoạt thiết bị truyền động, lệnh ghi kỹ thuật số được cấp cho thiết bị truyền động. (Jenkins, T., 2015).

#### Kiểm soát việc ra vào nhà

Năm 2010, công nghệ truy cập vào ngôi nhà thông minh thường được sử dụng cho các cửa ra vào công cộng. Hệ thống này thường sử dụng cơ sở dữ liệu với các thuộc tính nhận dạng những người có quyền truy cập. Khi một người đang tiếp cận hệ thống kiểm soát truy cập, các thuộc tính nhận dạng của người đó được thu thập ngay lập tức và so sánh với cơ sở dữ liệu. Nếu nó khớp với dữ liệu cơ sở dữ liệu, quyền truy cập được cho phép, nếu không, quyền truy cập bị từ chối. Đối với một hệ thống phân tán rộng, sẽ sử dụng các dịch vụ đám mây để thu thập và xử lý dữ liệu của người muốn truy cập. Một số sử dụng thẻ từ hoặc thẻ nhận dạng, số khác sử dụng hệ thống nhận dạng khuôn mặt, vân tay và RFID. (A. Yang, C. Zhang, Y. Chen, Y. Zhuansun và H. Liu, 2020)

Ví dụ trong một triển khai, thẻ RFID và đầu đọc RFID đã được sử dụng. Những người được ủy quyền đều có thẻ RFID. Người này quét thẻ qua đầu đọc RFID đặt gần cửa. ID được quét và gửi qua internet đến hệ thống đám mây. Hệ thống đã đăng ID lên dịch vụ kiểm soát để so sánh ID đã quét với các ID được ủy quyền trong cơ sở dữ liệu. (Manzini, E., & Vezzoli, C., 2GG3).

### Các thành phần chính

Cảm biến để thu thập dữ liệu bên trong và bên ngoài ngôi nhà và đo các điều kiện trong nhà. Các cảm biến này được kết nối với chính ngôi nhà và với các thiết bị gắn liền trong nhà. Những cảm biến này không phải là cảm biến IoT, được gắn vào các thiết bị gia dụng. Dữ liệu của cảm biến được thu thập và liên tục chuyển qua mạng cục bộ đến máy chủ của nhà thông minh. (Pandey, S., 2GiS).

Bộ xử lý để thực hiện các hành động cục bộ và tích hợp. Nó cũng có thể được kết nối với đám mây cho các ứng dụng yêu cầu tài nguyên mở rộng. Dữ liệu của cảm biến sau đó được xử lý bởi các quy trình của máy chủ cục bộ. (Roos, G., 2Gi6).

Một tập hợp các phần mềm được đóng gói dưới dạng API, cho phép các ứng dụng bên ngoài thực thi nó và truyền các tham số đã được xác định trước. Một API như vậy có thể xử lý dữ liệu cảm biến hoặc quản lý các hành động cần thiết.

Bộ truyền động cung cấp và thực hiện các lệnh trong máy chủ hoặc các thiết bị điều khiển khác. Nó chuyển hoạt động bắt buộc sang cú pháp lệnh mà thiết bị có thể thực thi. Trong quá trình xử lý dữ liệu của cảm biến đã nhận, nó có nhiệm vụ kiểm tra xem các quy tắc đúng hoặc sai và khởi chạy một lệnh tới bộ xử lý thiết bị thích hợp. (Ryan, A., 2Gi4).

Cơ sở dữ liệu lưu trữ các thông tin thu thập từ các cảm biến và các dịch vụ đám mây, nó được sử dụng để phân tích, trình bày và hiển thị dữ liệu. Dữ liệu đã xử lý được lưu trong cơ sở dữ liệu để sử dụng trong tương lai. (Ryan, W., Stolterman, E., Jung, H., Siegel, M., Thompson, T., & Hazlewood,WR., 2GG9).

## Tổng quan về Internet vạn vật

Mô hình Internet of things (IoT) đề cập đến các đối tượng thiết bị được kết nối với internet. Các thiết bị như cảm biến và thiết bị truyền động được trang bị giao diện, bộ xử lý, bộ nhớ và các phần mềm. Nó cho phép tích hợp các đối tượng vào internet, thiết lập sự tương tác giữa con người và thiết bị, giữa các thiết bị với nhau. Công nghệ quan trọng của IoT bao gồm nhận dạng tần số vô tuyến (RFID), công nghệ cảm biến và công nghệ thông minh. RFID là nền tảng và cốt lõi của việc xây dựng IoT. Khả năng xử lý và giao tiếp cùng với các thuật toán của nó cho phép tích hợp nhiều thành phần khác nhau để hoạt động như một thể thống nhất, đồng thời cũng cho phép dễ dàng bổ sung và loại bỏ các thành phần, việc này làm cho IoT trở nên mạnh mẽ và linh hoạt để tiếp nhận các thay đổi. Để giảm thiểu việc sử dụng băng thông, nó đang sử dụng JSON, một phiên bản nhẹ gọn của XML, cho các thành phần và tin nhắn ngoài hệ thống. (Sayar, D. & Er, Ö., 2GiS).

## Điện toán đám mây và đóng góp của nó cho IoT và nhà thông minh

Điện toán đám mây là một nhóm tài nguyên máy tính được chia sẻ sẵn sàng cung cấp nhiều loại dịch vụ điện toán ở các cấp độ khác nhau, từ cơ sở hạ tầng đến các dịch vụ ứng dụng phức tạp nhất, dễ dàng phân bổ và phát hành hoặc tương tác với nhà cung cấp dịch vụ. Trên thực tế, nó quản lý tài nguyên máy tính, lưu trữ và truyền thông được nhiều người dùng chia sẻ trong một môi trường ảo hóa và cô lập. (MR Alam, MBI Reaz và MAM Ali, 2018).

IoT và nhà thông minh có thể tận dụng được các lợi ích từ các tài nguyên và chức năng rộng lớn của đám mây để bù đắp hạn chế của nó trong lưu trữ, xử lý, giao tiếp, hỗ trợ theo nhu cầu, sao lưu và phục hồi. Ví dụ: đám mây có thể hỗ trợ quản lý, dịch vụ IoT và thực thi các ứng dụng bổ sung bằng cách sử dụng dữ liệu do nó tạo ra. Nhà thông minh có thể được cô đọng, chỉ tập trung vào các chức năng cơ bản và quan trọng, do đó, giảm thiểu tài nguyên cục bộ do dựa vào các khả năng tài nguyên đám mây. Nhà thông minh và IoT sẽ tập trung vào thu thập dữ liệu, xử lý cơ bản và truyền thông tin lên đám mây để xử lý tiếp. Với các thách thức bảo mật, đám mây bảo mật cao với dữ liệu riêng tư và các dữ liệu khác sẽ công khai. (A. Bassi và G. Horn, Internet of things năm 2020).

IoT, nhà thông minh và điện toán đám mây không chỉ là sự hợp nhất của các công nghệ. Đúng hơn, là sự cân bằng giữa tính toán cục bộ và tập trung cùng với việc tối ưu hóa việc sử dụng tài nguyên. Một tác vụ điện toán có thể được thực hiện trên IoT và các thiết bị gia đình thông minh hoặc được thuê ngoài trên đám mây. Việc tính toán phụ thuộc vào sự cân bằng tổng chi phí, tính khả dụng của dữ liệu, mức độ phụ thuộc của dữ liệu, lưu lượng vận chuyển dữ liệu, mức độ phụ thuộc vào truyền thông và các bảo mật. Một mặt, mô hình điện toán liên quan đến ba thành phần là đám mây, IoT và nhà thông minh sẽ giảm thiểu chi phí của toàn bộ hệ thống, thường tập trung hơn vào việc giảm tài nguyên trong ngôi nhà. (Verbeek, P.-P., 2015).

Một số ví dụ về các dịch vụ chăm sóc sức khỏe được cung cấp bởi tích hợp đám mây và IoT: quản lý thông tin đúng cách, chia sẻ hồ sơ chăm sóc sức khỏe điện tử cho phép các dịch vụ y tế chất lượng cao; quản lý dữ liệu cảm biến chăm sóc sức khỏe, làm cho thiết bị di động phù hợp để cung cấp dữ liệu y tế, bảo mật quyền riêng tư và độ tin cậy bằng cách nâng cao bảo mật dữ liệu y tế, tính khả dụng của dịch vụ và dự phòng, các dịch vụ hỗ trợ sinh hoạt thời gian thực và thực thi trên đám mây các dịch vụ y tế dựa trên truyền thông đa phương tiện. (Verbeek,P., 2016).

Xử lý sự kiện tập trung, một hệ thống dựa trên quy tắc

Nhà thông minh và IoT rất phong phú với các cảm biến, tạo ra luồng dữ liệu lớn dưới dạng tin nhắn hoặc sự kiện. Xử lý dữ liệu này vượt quá khả năng của con người. Do đó, các hệ thống xử lý sự kiện đã được phát triển và sử dụng để phản hồi nhanh hơn với các sự kiện đã phân loại. Trong phần này, tập trung vào các hệ thống quản lý quy tắc gắn liền với các sự kiện để thực hiện những thay đổi hệ thống khi sự kiện xảy ra. Người dùng có thể xác định quy tắc kích hoạt sự kiện và kiểm soát việc cung cấp dịch vụ thích hợp không. Quy tắc bao gồm các điều kiện của sự kiện, mẫu sự kiện và thông tin liên quan đến tương quan có thể được kết hợp để tạo mô hình cho các tình huống phức tạp. Nó đã được thực hiện trong một ngôi nhà thông minh điển hình và đã chứng minh sự phù hợp của nó đối với một hệ thống hướng đến dịch vụ. (I. Androutsopoulos, J. Koutsias, KV Chandrinos, G. Paliouras và CD Spyropoulos, 2019).

Hệ thống có thể xử lý một lượng lớn sự kiện, thực thi các chức năng giám sát, điều hướng và tối ưu hóa các quy trình với thời gian thực. Nó phát hiện và phân tích các điểm bất thường hoặc ngoại lệ và tạo ra các phản ứng chủ động/ thích ứng, chẳng hạn như cảnh báo và ngăn chặn các hành động thiệt hại. Các tình huống được mô hình hóa bởi giao diện thân thiện với người dùng cho các quy tắc do sự kiện kích hoạt. Khi cần thiết, nó sẽ chia chúng thành các yếu tố đơn giản, dễ hiểu. Mô hình đề xuất có thể được tích hợp liền mạch vào nền tảng xử lý sự kiện phân tán và hướng dịch vụ. (Apple, 2018).

Quá trình đánh giá được kích hoạt bởi các sự kiện cung cấp trạng thái mới nhất và thông tin từ môi trường liên quan. Kết quả là một biểu đồ quyết định đại diện cho các quy tắc. Nó có thể chia nhỏ các tình huống phức tạp thành các điều kiện đơn giản và kết hợp chúng với nhau, tạo ra các điều kiện phức tạp. Đầu ra là một sự kiện phản hồi được đưa ra khi một quy tắc được kích hoạt. Các sự kiện đã kích hoạt có thể được sử dụng làm đầu vào cho các quy tắc khác để đánh giá thêm.

Hành động tạo ra các sự kiện phản hồi, kích hoạt các hoạt động phản hồi. Các mẫu sự kiện có thể khớp với chuỗi sự kiện theo thời gian, cho phép mô tả các tình huống có liên quan đến sự xuất hiện của các sự kiện. Ví dụ, khi cửa mở quá lâu. (R. Petrolo, V. Loscrì và N. Mitton, 2017).

Những thách thức được biết đến với mô hình này: cấu trúc cho các sự kiện và dữ liệu đã xử lý, cấu hình dịch vụ và bộ điều hợp cho các bước xử lý, bao gồm các thông số đầu vào và đầu ra của chúng, giao diện với hệ thống bên ngoài để cảm nhận dữ liệu và phản hồi bằng cách thực hiện các giao dịch, cấu trúc cho các sự kiện và dữ liệu đã xử lý, biến đổi dữ liệu, phân tích dữ liệu và tính bền bỉ. Nó cho phép mô hình hóa các sự kiện nào sẽ được xử lý bởi dịch vụ quy tắc và cách các sự kiện phản hồi sẽ được chuyển tiếp đến các dịch vụ sự kiện khác. Quá trình này rất đơn giản: dữ liệu được thu thập và nhận từ các bộ điều hợp chuyển tiếp các sự kiện tới các dịch vụ sự kiện sử dụng chúng. (ZB Celik, E. Fernandes, E. Pauley, G. Tan và P. McDaniel, 2019).

### Ngôn ngữ xử lý sự kiện

Xử lý sự kiện liên quan đến việc nắm bắt và quản lý các sự kiện được xác định trước theo thời gian thực. Nó bắt đầu từ việc quản lý các thực thể của các sự kiện ngay từ khi sự kiện xảy ra, thậm chí xác định, thu thập dữ liệu, liên kết quy trình và kích hoạt hành động phản hồi. Để cho phép xử lý sự kiện nhanh chóng và linh hoạt, một ngôn ngữ xử lý sự kiện được sử dụng, cho phép cấu hình nhanh các tài nguyên cần thiết để xử lý chuỗi hoạt động dự kiến cho mỗi loại sự kiện. Nó bao gồm hai mô-đun, ESP và CEP. ESP xử lý hiệu quả sự kiện, phân tích nó và chọn sự kiện thích hợp. CEP xử lý các sự kiện tổng hợp. Ngôn ngữ sự kiện mô tả các kiểu sự kiện phức tạp được áp dụng trên bản ghi sự kiện. (N. Panwar, S. Sharma, S. Mehrotra, L. Krzywiecki và N. Venkatasubramanian, 2019).

### Khám phá lại quy trình làm việc từ các sự kiện

Trong một số trường hợp, các quy tắc liên quan đến sự khác biệt trong chuỗi sự kiện trong quy trình làm việc. Trong những trường hợp như vậy, bắt buộc phải hiểu chính xác quy trình làm việc và các sự kiện liên quan. Để khắc phục điều này, đề xuất quy trình thiết kế ngược để tự động xem lại quy trình công việc từ nhật ký sự kiện được thu thập theo thời gian, giả sử các sự kiện này được sắp xếp theo thứ tự và mỗi sự kiện đề cập đến một tác vụ đang được thực thi cho một trường hợp. Quá trình xem lại có thể được sử dụng để xác nhận trình tự quy trình làm việc bằng cách đo lường sự khác biệt giữa các mô hình mô tả và các lần thực thi quy trình thực tế. Quá trình xem lại bao gồm ba bước sau: (1) xây dựng bảng phụ thuộc/ tần suất. (2) Quy nạp đồ thị phụ thuộc/ tần số. (3) Tạo lưới WF từ đồ thị D/ F. (S. Zhihua, 2016).

## Nhà thông minh từ sau năm 2010

Trong phần này sẽ tập trung vào sự tích hợp của nhà thông minh, IoT và điện toán đám mây để xác định một mô hình điện toán mới. Có thể tìm thấy trong phần tài liệu các cuộc khảo sát và nghiên cứu về nhà thông minh, IoT và điện toán đám mây, các thuộc tính, tính năng, công nghệ và nhược điểm của chúng. (KR Sollins, 2019).

Vào năm 2011, mô tả các thành phần chính của ngôi nhà thông minh tiên tiến và khả năng kết nối giữa chúng. Ở khối bên trái, môi trường nhà thông minh, có thể thấy các thiết bị điển hình được kết nối với mạng cục bộ (LAN). Điều này cho phép giao tiếp giữa các thiết bị và môi trường bên ngoài. Kết nối với mạng LAN là một máy chủ và cơ sở dữ liệu của nó. Máy chủ kiểm soát các thiết bị, ghi nhật ký hoạt động của nó, cung cấp báo cáo, trả lời các truy vấn và thực hiện các lệnh thích hợp. Đối với các tác vụ toàn diện hoặc phổ biến hơn, máy chủ nhà thông minh, chuyển dữ liệu lên đám mây và kích hoạt từ xa các tác vụ bằng cách sử dụng API, quy trình giao diện lập trình ứng dụng. (Y. Meng, W. Zhang, H. Zhu và XS Shen, 2018).

Năm 2012, để chứng minh những lợi ích của ngôi nhà thông minh tiên tiến, sử dụng RSA, một thuật toán mật mã bất đối xứng mạnh mẽ, tạo ra một khóa công khai và riêng tư để mã hóa/ giải mã các tin nhắn. Sử dụng khóa công khai, mọi người đều có thể mã hóa một tin nhắn, nhưng chỉ những người giữ khóa riêng tư mới có thể giải mã tin nhắn đã gửi. Việc tạo ra các khóa và mã hóa/ giải mã các thông điệp, bao gồm các tính toán mở rộng, đòi hỏi không gian bộ nhớ và sức mạnh xử lý đáng kể. Do đó, nó thường được xử lý trên các máy tính mạnh được xây dựng để đáp ứng các tài nguyên cần thiết. Tuy nhiên, do tài nguyên có hạn, việc chạy RSA trong một thiết bị IoT gần như là không thể, và do đó, tạo ra một lỗ hổng về bảo mật trên Internet. Giải quyết vấn đề bảo mật bằng cách kết hợp sức mạnh của các bộ xử lý nhà thông minh cục bộ để tính toán một số phép tính RSA và chuyển tiếp các tác vụ điện toán phức tạp hơn lên trên đám mây xử lý. Sau đó, kết quả sẽ được chuyển trở lại cảm biến IoT để được biên dịch và lắp ráp lại với nhau, nhằm tạo ra mã giải mã/mã hóa RSA. Ví dụ minh họa luồng dữ liệu giữa các thành phần nhà thông minh tiên tiến. Trong đó, mỗi thành phần thực hiện ngăn xếp hoạt động của riêng mình để tạo ra đầu ra duy nhất của nó. Tuy nhiên, trong trường hợp các nhiệm vụ phức tạp và diễn ra trong thời gian dài, nó sẽ chia nhiệm vụ thành các tác vụ con để thực thi bởi các thành phần mạnh hơn. Đề cập đến ví dụ RSA, thiết bị IoT bắt đầu yêu cầu tạo khóa mã hóa và gửi một thông báo yêu cầu đến ứng dụng RSA chạy trong máy tính trong ngôi nhà thông minh với p và q là các số nguyên tố, khi p và q được chấp nhận, mã mã hóa được tạo. Trong giai đoạn sau, thiết bị IoT đưa ra yêu cầu mã hóa tin nhắn cho máy tính, sử dụng khóa mã hóa RSA được tạo gần đây. Sau đó, thông điệp được mã hóa sẽ được chuyển trở lại thiết bị IoT để thực hiện thêm. Một kịch bản tương tự có thể xảy ra theo hướng ngược lại, khi một thiết bị IoT nhận được thông báo, nó có thể yêu cầu nhà thông minh giải mã nó. (P. Rajiv, R. Raj, và M. Chandra, 2016).

Năm 2014, các kịch bản RSA mô tả việc sử dụng sức mạnh của điện toán đám mây, khả năng tính toán bảo mật của ngôi nhà thông minh và cuối cùng là sức mạnh của thiết bị IoT. Nó chứng minh rằng nếu không có sự hợp tác tự động này, RSA sẽ không thể được thực thi ở cấp độ IoT. (E. Fernandes, J. Jung và A. Prakash, 2016), (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

Vào năm 2015, một ví dụ thực tế là một số thiết bị tách rời, chẳng hạn như lò nướng, nồi nấu và chảo trên bếp ga đang hoạt động. Người dùng rời khỏi nhà mà không tắt các thiết bị này. Trong trường hợp này các IoT có liên quan đã được điều chỉnh để tự động tắt dựa trên các quy tắc được xác định trước. Nếu không, ngôi nhà thông minh nhận ra nhà không có ai ở nhà bằng cách xác định (cửa nhà được mở và sau đó khóa, nhà để xe được mở, ô tô rời đi, cổng chính được mở và sau đó đóng lại) và sẽ tắt tất cả các thiết bị đang hoạt động được phân loại là rủi ro trong trường hợp vắng mặt và nó sẽ gửi một tin nhắn đến danh sách gửi thư được xác định trong trường này. (A. Jacobsson, M. Boldt và B. Carlsson, 2016), (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

## Các khía cạnh thực tế và cân nhắc triển khai cho IoT và nhà thông minh

Nhà thông minh có ba thành phần: phần cứng, phần mềm và giao thức truyền thông. Nó có nhiều ứng dụng kỹ thuật số cho người dùng. Một số lĩnh vực tự động hóa ngôi nhà đã kích hoạt kết nối IoT, chẳng hạn như: điều khiển ánh sáng, làm vườn, an toàn và an ninh, chất lượng không khí, giám sát chất lượng nước, trợ lý giọng nói, công tắc, khóa, đồng hồ đo năng lượng và nước. (S. Madakam và H. Date, 2016).

Các thành phần nhà thông minh tiên tiến bao gồm: cảm biến IoT, cổng, giao thức, phần sụn, điện toán đám mây, cơ sở dữ liệu, phần mềm trung gian và cổng. Đám mây IoT có thể được chia thành nền tảng dưới dạng dịch vụ (PaaS) và cơ sở hạ tầng dưới dạng dịch vụ (IaaS). Trình bày các thành phần chính của ngôi nhà thông minh tiên tiến được đề xuất và kết nối với luồng dữ liệu giữa các thành phần của nó. (S. Madakam và H. Date, (2016)), (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

Ứng dụng nhà thông minh cập nhật cơ sở dữ liệu ngôi nhà trên đám mây để cho phép những người ở xa truy cập và nhận được trạng thái mới nhất của ngôi nhà. Một nền tảng IoT điển hình bao gồm: bảo mật và xác thực thiết bị, quản trị thiết bị, giao thức, thu thập dữ liệu, trực quan hóa, khả năng phân tích, tích hợp với các dịch vụ web khác, khả năng mở rộng, API cho luồng thông tin thời gian thực và thư viện nguồn mở. Cảm biến IoT cho tự động hóa ngôi nhà được biết đến với khả năng cảm biến của chúng, chẳng hạn như: nhiệt độ, độ sáng, mực nước, thành phần không khí, camera giám sát video, giọng nói/ âm thanh, áp suất, độ ẩm, gia tốc kế, hồng ngoại, rung động và siêu âm. Một số cảm biến nhà thông minh được sử dụng phổ biến nhất là cảm biến nhiệt độ, hầu hết là cảm biến kỹ thuật số kết quả cực kỳ chính xác. Ví dụ như cảm biến Lux đo độ sáng. (K. Markantonakis, RN Akram và MG Msgna, 2015).

Cảm biến thành phần không khí được các nhà phát triển sử dụng để đo các thành phần cụ thể trong không khí: giám sát CO, đo mức khí hydro, đo nitơ oxit, mức khí nguy hiểm. Hầu hết chúng đều cần một thời gian nhất định trước khi đưa ra các giá trị chính xác. Máy quay video được sử dụng để giám sát và phân tích, được kết nối tốc độ cao. Nên sử dụng bộ xử lý Raspberry Pi vì mô-đun máy ảnh của nó rất hiệu quả do có đầu nối linh hoạt, được kết nối trực tiếp với bo mạch. (P. Kumar, A. Gurtov, J. Iinatti, M. Ylianttila, và M. Sain, 2016).

Máy dò âm thanh được sử dụng rộng rãi cho mục đích giám sát, phát hiện âm thanh và hành động phù hợp. Một số thậm chí có thể phát hiện mức độ tiếng ồn cực thấp và tinh chỉnh giữa các mức độ tiếng ồn khác nhau.

Cảm biến độ ẩm cảm nhận mức độ ẩm trong không khí cho nhà thông minh. Độ chính xác của nó phụ thuộc vào thiết kế và vị trí cảm biến. Một số cảm biến nhất định như DHT22, được chế tạo để tạo mẫu nhanh, sẽ luôn hoạt động kém hơn khi so sánh với các cảm biến chất lượng cao như HIH6100. (H. Lee, CR Ahn, N. Choi, T. Kim và H. Lee, 2019).

Giao thức giao tiếp thông minh trong nhà như: bluetooth, Wi-Fi hoặc GSM. Bluetooth thông minh hoặc giao thức không dây năng lượng thấp với khả năng phân phối lưới và các thuật toán mã hóa dữ liệu. Zigbee là giao thức dựa trên tần số vô tuyến tuần suất thấp được nối mạng cho IoT. Giao thức X10 sử dụng hệ thống dây điện để truyền tín hiệu và điều khiển. Giao tiếp Insteon, không dây và có dây. Z-wave chuyên về tự động hóa ngôi nhà an toàn. UPB, sử dụng đường dây điện hiện có. ANT là một giao thức năng lượng cực thấp để xây dựng các cảm biến công suất thấp với khả năng phân phối lưới cao. Các giao thức được ưu tiên là bluetooth năng lượng thấp, sóng Z, Zigbee và luồng. Việc kết nối cổng bao gồm: kết nối đám mây, các giao thức được hỗ trợ, độ phức tạp tùy chỉnh và hỗ trợ tạo mẫu. (M. Bassoli, V. Bianchi, và I. De Munari, 2018).

Mô-đun: các gói phần mềm, được quản lý trong lúc chạy, định hướng dịch vụ, quản lý sự phụ thuộc giữa các gói, lớp; kiểm soát vòng đời của các gói, lớp dịch vụ; xác định mô hình giao tiếp động giữa các mô-đun khác nhau, các dịch vụ thực tế - đây là lớp ứng dụng. Lớp bảo mật: tùy chọn, tận dụng kiến trúc bảo mật của Java 2 và quản lý quyền từ các mô-đun khác nhau. (GV Vivek và MP Sunil, 2015).

OpenHAB là một khuôn khổ, kết hợp tự động hóa các thiết bị gia đình và cổng kết nối IoT cho ngôi nhà thông minh. Các tính năng của nó: công cụ quy tắc, cơ chế ghi nhật ký và trừu tượng hóa giao diện người dùng.

Việc triển khai blockchain vào mạng gia đình có thể dễ dàng thực hiện với Raspberry Pi. Một lớp bảo mật blockchain giữa các thiết bị và cổng có thể được thực hiện mà không cần phải cải tiến lớn với mã hiện có.

## Ví dụ về nhà thông minh và IoT

Có thể tìm thấy trong các tài liệu và báo cáo thực tế, nhiều triển khai tích hợp khác nhau giữa ba phần chính: nhà thông minh, IoT và điện toán đám mây.

### Phát hiện rò rỉ nước và cách phòng ngừa

Bước đầu tiên là triển khai cảm biến nước dưới mọi nguồn rò rỉ tiềm ẩn hợp lý và cảm biến van nước chính tự động cho toàn bộ ngôi nhà, điều này có nghĩa là ngôi nhà được coi như một IoT.

Trong trường hợp cảm biến nước phát hiện rò rỉ nước, nó sẽ gửi một sự kiện đến trung tâm, sự kiện này sẽ kích hoạt ứng dụng “tắt van”. Sau đó, ứng dụng điều khiển gia đình sẽ gửi lệnh “tắt” đến tất cả các thiết bị IoT được xác định với việc ngừng nước và sau đó gửi lệnh “tắt” đến van nước chính. Thông báo cập nhật được gửi qua hệ thống nhắn tin. Thiết lập này giúp bảo vệ khỏi các trường hợp nguồn nước là từ hệ thống ống nước trong nhà. Cấu hình cơ bản giả định tích hợp thông qua tin nhắn và lệnh giữa nhà thông minh và hệ thống điều khiển IoT. Nó thể hiện sự phụ thuộc và những kết quả có lợi của việc kết hợp nhà thông minh và IoT. (YAN Wenbo, WANG Quanyu, và GAO Zhenwei, 2015).

### Đầu báo khói

Giả sử các ngôi nhà đã có các đầu báo khói nhưng không có cầu nối để gửi dữ liệu từ cảm biến đến trung tâm điều khiển nhà thông minh. Việc kết nối các cảm biến này với ứng dụng nhà thông minh cho phép hệ thống phát hiện khói toàn diện. Mở rộng hơn là để thông báo cho cảm biến thang máy chặn việc sử dụng do tình trạng cháy, thậm chí cho bất kỳ cảm biến IoT nào có thể được kích hoạt do cảnh báo khói được phát hiện. (C Y. Chang, C.-H. Kuo, J.-C. Chen và T.-C. Wang, 2015).

### Quản lý sự cố để kiểm soát các thiết bị gia dụng

Hãy xem xét tình huống rời khỏi nhà trong khi một số thiết bị vẫn đang hoạt động. Trong trường hợp vắng mặt đủ lâu, một số thiết bị có thể quá nóng và sắp bị xì. Để tránh những trường hợp như vậy kết nối tất cả các cảm biến của thiết bị IoT với ứng dụng gia đình, để khi tất cả rời khỏi nhà, nó sẽ tự động điều chỉnh tất cả các cảm biến của thiết bị cho phù hợp, để tránh hư hỏng. Lưu ý rằng chỉ báo nhà trống được tạo bởi ứng dụng Nhà thông minh, trong khi chỉ báo “bật” của thiết bị do IoT tạo ra. Do đó, kịch bản này có thể xảy ra do sự tích hợp giữa nhà thông minh và các hệ thống IoT. (U. Guin, A. Singh, M. Alam, J. Canedo và A. Skjellum, 2018), (C. Lachner và S. Dustdar, 2019).

## Kết luận

Nhiều kỹ thuật IoT đã được cài đặt trong các ngôi nhà thông minh để cải thiện chất lượng cuộc sống. Để thiết kế và triển khai một hệ thống kiểm soát ngôi nhà, bao gồm ba phần: phần cứng, máy chủ có độ bảo mật cao và ứng dụng web. Phần cứng nút IoT được thiết kế để thử nghiệm trong đời thực và nhận thông tin IoT từ bất kỳ thiết bị nào. Một máy chủ được thiết kế và triển khai để kiểm soát các nút IoT trong hệ thống. Cuối cùng, một ứng dụng sử dụng mọi lúc mọi nơi trên điện thoại thông minh hoặc trình duyệt web thông qua liên kết kết nối giao tiếp Wi-Fi đã được xây dựng để điều khiển hệ thống thông minh IoT theo thời gian thực. Ứng dụng này cho phép điều khiển chức năng cả tự động và thủ công, điều này rất linh hoạt cho người dùng. Hệ thống IoT tiên tiến được lắp đặt tại Đại học Tôn Đức Thắng, Việt Nam. Kết quả cho thấy những lợi ích tiềm năng rõ ràng cho một ngôi nhà thông minh, bao gồm bảo mật mạnh mẽ và chi phí thấp. Trên hết, nghiên cứu này nhằm chứng minh tiềm năng to lớn mà tất cả công nghệ kỹ thuật số mang lại cho ngôi nhà thông minh.

# Public_002

# Học phần

## Bộ Môn Hệ Thống Thông Tin

### Cơ sở dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần: Học phần này trang bị cho người học những kiến thức cơ bản về cơ sở dữ liệu và kiến thức chuyên sâu về mô hình dữ liệu quan hệ: quan hệ, phụ thuộc hàm, các ràng buộc trên quan hệ, siêu khóa, khóa chính, khóa dự tuyển, khóa ngoại, bao đóng của tập phụ thuộc hàm, bao đóng của tập thuộc tính, phủ tối tiểu của tập phụ thuộc hàm, thuật toán tìm bao đóng của tập thuộc tính, thuật toán xác định khóa, các dạng chuẩn và tính chất tương ứng. Trang bị cho người học kiến thức về mô hình thực thể kết hợp để thiết kế CSDL.

### Hệ quản trị cơ sở dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học về nguyên lý của DBMS. Cách sử dụng ngôn ngữ lập trình PL/SQL, các định nghĩa và ứng dụng của thủ tục nội tại, bẫy lỗi, chỉ mục, lập trình CSDL, các quản lý truy cập trong DBMS, các nguyên lý quản lý giao tác, quản lý truy xuất cạnh tranh, phục hồi sau sự cố.

### Phân tích thiết kế HTTT

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học các kiến thức cơ bản về hệ thống thông tin, các thành phần của một hệ thống thông tin. Học phần cung cấp cho người học các kỹ thuật thu thập thông tin, phân tích hoạt động của hệ thống thông tin; các khái niệm có liên quan, ý nghĩa và tầm quan trọng của chúng. Về hoạt động thiết kế, học phần cung cấp cho người học kiến thức và kỹ năng trong việc xác định cấu trúc, các thành phần cần thiết để xây dựng và triển khai một hệ thống thông tin.

### Khai phá dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học những kiến thức cơ bản về các khái niệm, thuật toán và ứng dụng của khai phá dữ liệu. Ngoài ra, người học còn có cơ hội trải nghiệm các thư viện, công cụ mã nguồn mở để cài đặt và thử nghiệm thuật toán khai phá dữ liệu. Các chủ đề được đề cập đến trong học phần bao gồm: các khái niệm cơ bản, các ứng dụng và quá trình khai phá dữ liệu, các vấn đề liên quan đến quá trình tiền xử lý dữ liệu, các thuật toán khai phá luật kết hợp (Apriori, FP-Growth, …), các thuật toán phân loại (k-NN, cây quyết định, Naive Bayes, ...), các thuật toán gom cụm (gom cụm phân hoạch k-means, gom cụm phân cấp gộp AGNES, gom cụm dựa trên mật độ DBSCAN, …), các thuật toán phân tích ngoại biên (dựa trên thống kê, dựa trên xấp xỉ, dựa trên gom cụm, dựa trên phân loại), và các độ đo và phương pháp đánh giá các thuật toán khai phá dữ liệu.

### Cơ sở dữ liệu nâng cao

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này giới thiệu những kiến thức tổng quát về một số loại cơ sở dữ liệu (CSDL) mở rộng: CSDL hướng đối tượng, CSDL bán cấu trúc XML, CSDL NoSQL, CSDL phân cấp (blockchain)... Học phần tập trung vào Big Data và CSDL NoSQL, so sánh CSDL quan hệ truyền thống với CSDL NoSQL, phân loại các loại CSDL NoSQL (key-value, document-based, column-based, graph), cài đặt một CSDL NoSQL cụ thể (VD: MongoDB, Cassandra, CouchDB...), thực hiện tạo lập, lưu trữ, quản lý và thao tác dữ liệu trên cơ sở dữ liệu này.

### Phân tích dữ liệu lớn

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp cho sinh viên kiến thức về kiến trúc của các hệ thống và các công cụ phục vụ cho hoạt động phân tích dữ liệu lớn. Với mỗi công cụ, môn học giới thiệu các kiến thức cơ bản và nâng cao cũng như phương thức tối ưu hóa hiệu suất hệ thống sử dụng công cụ này. Cùng với các bài tập lập trình, môn học hướng đến mục tiêu giúp người học có thể hình thành ý tưởng, thiết kế và hiện thực hóa hoạt động phân tích dữ liệu trong các hệ thống dữ liệu lớn.

### Bảo mật cơ sở dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học những kiến thức nền tảng về cả lý thuyết lẫn thực hành để có thể hiểu được những cơ chế, mô hình và kỹ thuật bảo mật cơ sở dữ liệu, cụ thể: các kiểu tấn công, các cấp độ bảo mật và các phương pháp bảo vệ tương ứng; bảo mật cơ sở dữ liệu bằng phương pháp kiểm soát truy cập (Access Control) với các mô hình DAC, MAC, RBAC; bảo mật bằng phương pháp mã hóa dữ liệu; vấn đề kiểm định (Audit); cách thức hiện thực các mô hình và các công nghệ hỗ trợ bảo mật trong các hệ quản trị cơ sở dữ liệu; nguyên lý thiết kế và cài đặt các cơ chế bảo mật; các mô hình bảo vệ tính toàn vẹn dữ liệu

### Thương mại điện tử

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần giới thiệu về thương mại điện tử và cung cấp cho người học ba mảng kiến thức chủ đạo: các mô hình kinh doanh thương mại điện tử, các hoạt động marketing cho thương mại điện tử, và các vấn đề chủ đạo khi thiết kế, xây dựng, và vận hành nền tảng thương mại điện tử.

### Học máy

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học giới thiệu cho sinh viên về lĩnh vực học máy và các giải thuật học máy phổ biến. Sinh viên sẽ thực hiện các bài tập lập trình bằng ngôn ngữ lập trình Python, và phân tích, đánh giá các giải thuật này. Sinh viên cũng sẽ thực tập hình thành ý tưởng, thiết kế và hiện thực hóa một hệ thống học máy đơn giản trong đồ án môn học xuyên suốt học kỳ.

### Chuyên đề 2 (Hệ hỗ trợ ra quyết định)

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp cho sinh viên các kiến thức về tiến trình ra quyết định, cấu trúc và các thành phần của hệ hỗ trợ ra quyết định, cách quản lý và khai thác dữ liệu, các mô hình được sử dụng trong hệ hỗ trợ ra quyết định… Ngoài ra, sinh viên được trang bị kỹ năng sử dụng các công cụ để giải quyết các bài toán ra quyết định, lưu trữ và khai thác dữ liệu hiệu quả. Sau khi học xong học phần này, sinh viên có khả năng phân tích, thiết kế và xây dựng các hệ hỗ trợ ra quyết định trên nền tảng các hệ thống thông tin quản lý.

### Kho dữ liệu

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên những kiến thức cơ bản về kho dữ liệu. Trong khóa học này, người học sẽ học các khái niệm cơ bản về kho dữ liệu, kiến trúc kho dữ liệu và các mô hình đa chiều. Họ sẽ được thực hành về thiết kế kho dữ liệu và sử dụng các công cụ phổ biến tạo các luồng công việc tích hợp dữ liệu (data integration workflows). Bên cạnh đó, những người học cũng sẽ học cách sử dụng các phần mở rộng của SQL được hỗ trợ bởi các hệ quản trị cơ sở dữ liệu quan hệ để trả lời các câu hỏi phân tích trong kinh doanh.

### Truy tìm thông tin

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp kiến thức nền tảng giúp người học hiểu được cách làm việc cũng như cách xây dựng một hệ thống truy tìm (tìm kiếm) thông tin, đặc biệt là thông tin ở dạng văn bản. Cụ thể, sau khi hoàn thành học phần, người học sẽ trình bày được kiến trúc tổng quát của một hệ thống truy tìm thông tin, quá trình tiền xử lý và xây dựng chỉ mục tài liệu. Đặt biệt, người học sẽ có cơ hội được cài đặt các mô hình truy tìm thông tin quan trọng (như mô hình không gian vector, mô hình xác suất, mô hình ngôn ngữ) và các kỹ thuật phản hồi và mở rộng truy vấn. Người học cũng sẽ được trang bị kiến thức về phương pháp đánh giá thực nghiệm một hệ thống truy tìm thông tin để có thể đánh giá và so sánh các thuật toán, mô hình. Ngoài ra, cách hoạt động của một hệ thống tìm kiếm thông tin trên web (web search engine) cũng sẽ được trình bày.

### Nhập môn dữ liệu lớn

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này thuộc nhóm môn học cơ sở ngành, nhằm cung cấp cho người học các kiến thức tổng quan về cơ sở dữ liệu lớn, những ứng dụng của cở sở dữ liệu lớn. Ngoài ra, người học còn được cung cấp những kiến thức về các kỹ thuật cơ bản trong lưu trữ và xử lý, phân tích cơ sở dữ liệu lớn. Về mặt kỹ năng, người học được trang bị khả năng sử dụng một số công cụ phân tích cơ sở dữ liệu lớn thông dụng. Bên cạnh đó, người học cũng được trang bị một số kỹ năng mềm bao gồm: kỹ năng tìm kiếm, chọn lọc và tổng hợp tài liệu, kỹ năng viết và trình bày báo cáo, kỹ năng làm việc nhóm.

## Bộ Môn Mạng Máy Tính

### Kiến trúc máy tính và hợp ngữ

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp cho người học những kiến thức liên quan tới kiến trúc của máy tính cũng như tập lệnh của vi xử lý và lập trình hợp ngữ cho vi xử lý, cụ thể:

### Cung cấp kiến thức về các hệ số đếm dùng trong máy tính

Kiến trúc tổng quát của bộ xử lý, hiệu suất máy tính, các loại bộ nhớ, các loại xuất nhập, ngắt

Cung cấp kiến thức về các cách biểu diễn dữ liệu trong máy tính

Giới thiệu kiến trúc một số họ vi xử lý của Intel : thanh ghi của họ x86, x86-64

Cung cấp các kiến thức về việc sử dụng tập lệnh x86, x86-64

Cung cấp kiến thức về lập trình hợp ngữ trên linux x64, các lời gọi hệ thống, gọi hợp ngữ từ ngôn ngữ cấp cao.

### Hệ điều hành

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này trang bị cho người học những kiến thức cơ bản về Hệ điều hành, bao gồm: Mô hình tổng quát, cấu trúc, chức năng, các thành phần cơ bản của hệ điều hành. Các nguyên lý cơ bản để xây dựng Hệ điều hành. Tìm hiểu cấu trúc và việc ứng dụng các nguyên lý cơ bản trong các hệ điều hành cụ thể. Tìm hiểu và mô phỏng điều khiển thiết bị của Hệ điều hành thông qua lập trình hệ thống.

### Mạng máy tính căn bản

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung các các khái niệm cơ bản trong mạng máy tính, đặc điểm cơ bản của các loại mạng; kiến thức về nguyên lý hoạt động của các thiết bị mạng, các kỹ thuật phổ biến triển khai trên hạ tầng mạng, các giao thức phổ biến hoạt động trong hệ thống mạng; các kiến thức về thiết kế, cấu hình và vận hành hệ thống mạng đơn giản.

### Mật mã học

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp các khái niệm cơ bản về mã hóa thông tin, giới thiệu các phương pháp mã hóa, giải mã và ứng dụng của chúng trong bảo mật thông tin, các cơ chế và nghi thức bảo mật: Xác thực, chữ ký số. Ngoài ra, học phần này cũng cung cấp khả năng vận dụng kiến thức về mã hóa thông tin đã học để giải quyết một số bài toán bảo mật trong thực tế. Bên cạnh đó, sinh viên được làm việc trong các nhóm và thuyết trình các vấn đề nâng cao sử dụng các phương tiện trình chiếu.

### Mạng máy tính nâng cao

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về công nghệ định tuyến, phân loại và đặc điểm của các giao thức định tuyến; cung cấp kiến thức về cấu hình một số giao thức phổ biến; cung cấp kiến thức về VLAN, ACL, NAT, các công nghệ WAN.

### An toàn thông tin

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên chuyên ngành Công nghệ Thông tin kiến thức cơ bản về An toàn thông tin trên máy tính như CIA, An toàn trên phần mềm, An toàn trên HĐH, An toàn trên Cơ sở dữ liệu; các vấn đề về An toàn trên mạng máy tính như Malware, Firewall, IDS/IPS; các vấn đề về mã hoá thông tin, các thuật toán hash, MAC, RSA, quản lý khóa trong các giao thức truyền trên mạng.

### Tấn công mạng và phòng thủ

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên chuyên ngành Công nghệ Thông tin kiến thức cơ bản về kỹ thuật Tấn công Mạng và Bảo vệ hệ thống mạng trước các loại tấn công; các vấn đề về mã hoá thông tin, các thuật toán hash, MAC, RSA, quản lý khóa trong các giao thức truyền trên mạng.

### Thiết kế mạng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về những đặc điểm cơ bản khi thiết kế một hệ thống mạng;kiến thức về quy trình các giai đoạn thiết kế mạng, phương pháp thiết kế theo mô hình phân lớp; kiến thức về thiết kế mạng LAN, WLAN, WAN; và thiết kế mạng đảm bảo tính bảo mật, tính sẵn sàng của hệ thống.

### An ninh mạng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về các kỹ thuật an ninh mạng; kiến thức về các kỹ thuật và công cụ phân tích các lỗ hổng trong hệ thống mạng; các kỹ thuật tấn công mạng; các giao thức bảo mật và kỹ thuật bảo mật ứng dụng mạng; các kỹ thuật bảo mật hạ tầng mạng như Firewall, IDS/IPS.

### Hệ thống nhúng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp cho người học những kiến thức liên quan tới hệ thống nhúng, bao gồm: Những khái niệm tổng quan về mô hình hệ thống nhúng, tính chất, các ứng dụng của hệ thống nhúng; Các thành phần cơ bản của một hệ thống nhúng; Các phương pháp thiết kế hệ thống nhúng; Vi điều khiển ARM; Tập lệnh của vi điều khiển ARM; Kiến thức về nguyên tắc lập trình nhúng, các công cụ lập trình phần mềm nhúng.

### Lý thuyết thông tin

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần cung cấp cho người học những kiến thức cơ bản của lý thuyết thông tin, bao gồm: Độ đo lượng tin (Measure of Information); Sinh mã tách được (Decypherable Coding); Kênh truyền tin rời rạc không nhớ (Discrete Memoryless Channel); Sửa lỗi kênh truyền (Error Correcting Coding).

### Hệ thống giám sát an toàn mạng

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về các thành phần trong hệ thống giám sát mạng; kiến thức về phương pháp tổ chức triển khai một hệ thống giám sát, các giao thức dùng trong giám sát mạng; kiến thức về các công cụ trong giám sát, các hình thức cảnh báo khi hệ thống mạng có sự cố xảy ra.

### An toàn mạng không dây và di động

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Học phần này cung cấp cho người học những kiến thức liên quan tới: kênh truyền thông không dây, kiến trúc và các giao thức mạng không dây, tấn công trên mạng không dây, các kỹ thuật bảo vệ.

### Quản trị trên môi trường cloud

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp kiến thức về công nghệ cloud và triển khai cài đặt, cấu hình, quản trị trên môi trường cloud. Trong đó bao gồm việc triển khai các máy ảo, cài đặt các ứng dụng và dịch vụ trên cloud, quản trị tài nguyên, giám sát các hoạt động của hệ thống trên môi trường cloud.

### Pháp lý kỹ thuật số

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học cung cấp cho sinh viên những nguyên lý và kỹ thuật trong lĩnh vực pháp lý số. Sinh viên sẽ được cung cấp những kiến thức và qui trình thu thập chứng cứ trên Linux và Windows; kiến thức xây dựng và phân tích được các báo cáo pháp lý số.

### Chuyên đề 3 (Internet kết nối vạn vật - IoT)

Cấu trúc học phần: 3(2:1:6)

Mô tả học phần:

Môn học này cung cấp cho người học những kiến thức liên quan tới Hệ thống IoT, cụ thể là: các khái niệm liên quan và kiến trúc hệ thống IoT, kiến trúc hệ thống IoT, chồng giao thức cho IoT, các thành phần hardware, software, một số platform cho hệ thống IoT, công nghệ RFID, sensor...

### Chuyên đề doanh nghiệp (CNTT)

Cấu trúc học phần: 2(2:0:4)

Mô tả học phần:

Môn học này trang bị cho sinh viên các kiến thức cập nhật thực tế về các công nghệ mới trong lĩnh vực công nghệ thông tin, cũng như một số kiến thức về kỹ năng mềm, kỹ năng làm việc trong môi trường doanh nghiệp, dưới hình thức chuyên đề khách mời – là những chuyên gia có kinh nghiệm làm việc trong các doanh nghiệp.

### Thực tập tốt nghiệp (CNTT)

Cấu trúc học phần: 2(2:0:4)

Mô tả học phần:

Môn học này trang bị cho sinh viên các kiến thức thực tế liên quan tới môi trường làm việc tại doanh nghiệp, sử dụng kiến thức đã học trong việc tham gia các dự án thực tế tại doanh nghiệp, hoặc tiếp thu một số công nghệ mới và vận dụng chúng trong việc triển khai, vận hành hệ thống công nghệ thông tin. Đồng thời qua việc thực tập sinh viên có thể phát triển tư duy trong tương lai với vai trò quản lý.

### Lãnh đạo và kinh doanh trong kỹ thuật (CNTT)

Cấu trúc học phần: 0(0:0:0)

Mô tả học phần:

Học phần giúp sinh viên hình thành tư duy sáng tạo và truyền đạt, trang bị kỹ năng xây dựng, lãnh đạo tổ chức, quản lý dự án. Trang bị cho sinh viên kỹ năng làm việc nhóm, kỹ năng phát triển ý tưởng mới. Cung cấp các kiến thức về việc thành lập, quản lý doanh nghiệp và tiếp thị sản phẩm, quản lý sở hữu trí tuệ.

# Public_003

_Dịch máy là một trong những hướng nghiên cứu quan trọng trong xử lý ngôn ngữ tự nhiên. Trong những năm gần đây, dịch máy nơ ron đã và đang được nghiên cứu phổ biến hơn trong cộng đồng dịch máy vì hiện tại nó cho chất lượng dịch tốt hơn so với phương pháp dịch máy thống kê truyền thống. Tuy nhiên, dịch máy nơ ron lại cần lượng lớn dữ liệu song ngữ để huấn luyện. Hệ dịch sẽ cho chất lượng bản dịch tốt hơn khi nó được thử nghiệm trong cùng miền với miền dữ liệu mà nó được huấn luyện, ngược lại thì chất lượng bản dịch sẽ bị sụt giảm, mức độ sụt giảm phụ thuộc vào mức độ khác biệt giữa dữ liệu miền huấn luyện và dữ liệu miền thử nghiệm. Hiện nay, các kĩ thuật thích ứng miền cho dịch máy nơ ron đã được công bố chủ yếu được thực hiện trên một số cặp ngôn ngữ phổ biến giàu tài nguyên, và chưa có nhiều nghiên cứu đã được công bố về thích ứng miền trong dịch máy nơ ron cho cặp ngôn ngữ Anh - Việt._

_Trong bài báo này, chúng tôi đề xuất một phương pháp thích ứng miền mới cho dịch máy nơ ron, áp dụng cho cặp ngôn ngữ Anh - Việt. Ý tưởng chính của bài báo là kết hợp dữ liệu đơn ngữ ngoài miền ở ngôn ngữ nguồn (tiếng Anh) với bản dịch của nó ở ngôn ngữ đích (tiếng Việt) để làm dữ liệu huấn luyện hệ dịch. Các thực nghiệm đã chứng minh rằng phương pháp chúng tôi đề xuất dễ thực hiện, khai thác được những ưu điểm của dữ liệu đơn ngữ như luôn có sẵn, chi phí xây dựng thấp và đặc biệt là chất lượng của hệ dịch được và tăng 2,21 điểm BLEU trong thử nghiệm của chúng tôi._

# Nội dung chính

## GIỚI THIỆU

Mục tiêu của dịch máy là nghiên cứu các phương pháp, kĩ thuật để xây dựng được một hệ thống có thể dịch tự động các câu từ một ngôn ngữ tự nhiên này sang ngôn ngữ khác, đây là một trong những hướng nghiên cứu quan trọng trong trí tuệ nhân tạo, đặc biệt trong xử lý ngôn ngữ tự nhiên. Dịch máy là một nhánh nhỏ của xử lý ngôn ngữ tự nhiên, và vì xử lý ngôn ngữ tự nhiên là lĩnh vực liên ngành giữa khoa học máy tính và ngôn ngữ học, chính đặc điểm đó nên các nghiên cứu về dịch máy có thể chia thành hai nhóm phương pháp chính là các phương pháp dựa trên luật và các phương pháp dựa trên ngữ liệu. Trong số đó, các phương pháp dựa trên ngữ liệu có thể được chia thành các phương pháp dựa trên thống kê và các phương pháp dựa trên ví dụ. Trong những năm gần đây, với sự phát triển của internet, dịch máy đã đạt được những kết quả tốt cả về học thuật và trong công nghiệp.

Gần đây, các nghiên cứu về dịch máy đã dịch chuyển dần từ các phương pháp dịch thống kê _(Statistical Machine Translation)_ sang dịch máy nơ ron _(Neural Machine Translation)_ , hiện tại đây được coi là một hệ dịch cho chất lượng dịch vượt trội so với các phương pháp truyền thống trước đây. Tuy nhiên, các hệ dịch nơ ron lại yêu cầu nhiều dữ liệu song ngữ hơn để huấn luyện hệ dịch, điều này ít ảnh hưởng tới chất lượng bản dịch của hệ dịch dành cho các cặp ngôn ngữ phổ biến và giàu tài nguyên nhưng nó lại là thách thức lớn đối với các cặp ngôn ngữ có ít tài nguyên.

Thông thường, hệ dịch được huấn luyện trên lượng lớn dữ liệu song ngữ và dữ liệu đơn ngữ của ngôn ngữ đích đối với dịch máy thống kê và dữ liệu song ngữ đối với dịch máy nơ ron, trong bản thân những dữ liệu huấn luyện này có thể bao gồm các chủ đề đồng nhất hoặc không đồng nhất và thường thì mỗi chủ đề đó sẽ có tập các từ thuật ngữ riêng biệt. Chất lượng của bản dịch phụ thuộc rất lớn vào dữ liệu huấn luyện, nếu miền dữ liệu huấn luyện và miền thử nghiệm giống nhau hoặc có sự tương đồng càng lớn thì chất lượng bản dịch thu được sẽ càng tốt so với việc miền dữ liệu dùng để huấn luyện và miền thử nghiệm dặc biệt khác nhau hoặc có ít sự tương đồng hơn. Ví dụ, nếu hệ dịch được huấn luyện với dữ liệu thuộc miền tin tức thì khi dịch các văn bản cũng thuộc miền tin tức sẽ cho chất lượng bản dịch tốt, nhưng nếu đem hệ dịch đó để dịch các văn bản thuộc miền khác với miền tin tức như miền y tế, tin học, luật, v.v... thì chất lượng của bản dịch sẽ bị giảm đột ngột, mức độ giảm tùy thuộc vào mức độ tương đồng của miền dữ liệu dùng để huấn luyện hệ dịch so với miền dữ liệu dùng để thử nghiệm.

Các miền dữ liệu song ngữ trong thực tế thường rất hiếm hoặc bị giới hạn về số lượng, đặc biệt đối với các cặp ngôn ngữ ít phổ biến như ngôn ngữ Anh - Việt, nhất là các miền dữ liệu đặc thù. Để đạt được chất lượng bản dịch tốt nhất thì dữ liệu huấn luyện phải thuộc cùng một miền, cùng một thể loại và cùng một phong cách với miền mà hệ dịch được áp dụng nhưng tế để có được lượng dữ liệu huấn luyện đủ lớn trong mỗi miền mà thỏa mãn những đặc điểm trên là rất khó, hoặc cần phải trả một chi phí rất lớn để xây dựng dữ liệu huấn luyện. Vì vậy, trong bài báo này chúng tôi trình bày một phương pháp thích ứng miền mới cho dịch máy nơ ron, áp dụng cho cặp ngôn ngữ Anh - Việt với chiều dịch từ tiếng Anh sang tiếng Việt. Các thử nghiệm được tiến hành trên hai miền dữ liệu là miền tổng quan và miền pháp lý, chất lượng dịch trên miền tổng quan làm cơ sở để so sánh, đánh giá chất lượng hệ dịch khi được áp dụng trong miền pháp lý cũng như đánh giá hiệu quả của phương pháp được đề xuất. Qua thử nghiệm cho thấy, phương pháp này dễ thực hiện, tận dụng được lượng lớn dữ liệu đơn ngữ luôn có sẵn với chi phí thấp và khả quan khi đã cải tiến được chất lượng bản dịch tăng 2,21 điểm BLEU [6] _(từ 22,17 điểm lên 24,38 điểm)._

Bài báo này được trình bày cấu trúc như sau: Tiếp theo, phần 2 sẽ giới thiệu các nghiên cứu trước đây có liên quan; phần 3 trình bày tổng quan phương pháp chúng tôi đề xuất; phần 4 trình bày các thử nghiệm và các kết quả; phần 5 là kết luận và hướng phát triển; và cuối cùng phần 6 là một số tài liệu tham khảo.

## CÁC NGHIÊN CỨU LIÊN QUAN

Những năm gần đây, thích ứng miền là một trong những chủ đề đã giành được rất nhiều sự quan tâm của các nhà khoa học trên thế giới. Hiện nay, đã có nhiều phương pháp được đề xuất để thích ứng cho dịch máy thống kê cũng như dịch máy nơ ron, nhưng các đề xuất đó chủ yếu áp dụng cho một số cặp ngôn ngữ phổ biến trên thế giới như Anh - Pháp, Anh - Nhật, Anh - Tây Ban Nha,... Các phương pháp đã đề xuất được công bố đều thuộc một trong ba hướng chính, đó là: (1) bổ sung thêm nhiều dữ liệu hơn; (2) các kĩ thuật để có dữ liệu chất lượng hơn và (3) các kĩ thuật để có mô hình chất lượng hơn. Với hướng tiếp cận (1) và (2), đã có nhiều công bố đề xuất sử dụng dữ liệu đơn ngữ để cải tiến chất lượng hệ dịch khi dịch trong miền mới, các đề xuất này chủ yếu đã được chứng minh bằng thực nghiệm trong dịch máy thống kê, và chưa có nhiều đề xuất đối với dịch máy nơ ron.

Trong [2], kỹ thuật thích ứng giữa các miền được đề xuất để áp dụng cho dịch máy thống kê dựa vào cụm từ về nhiệm vụ Europarl1 [3], để dịch các bình luận tin tức từ tiếng Pháp sang tiếng Anh. Cụ thể, một phần nhỏ dữ liệu song ngữ miền được khai thác để thích ứng mô hình ngôn ngữ và mô hình dịch bằng kỹ thuật nội suy tuyến tính. Việc thích ứng các mô hình dịch, mô hình đảo trật tự từ được thực hiện qua việc sinh thêm dữ liệu song ngữ từ dữ liệu đơn ngữ.

Công bố [9] đã đề xuất một số phương pháp thích ứng khá phức tạp dựa trên việc bổ sung thêm dữ liệu song ngữ được tổng hợp từ các tập dữ liệu dùng để tối ưu tham số và thử nghiệm. Ngoài ra, trong [10], đề xuất một phương pháp nhằm khai thác nguồn tài nguyên dữ liệu đơn ngữ miền bằng cách tổng hợp dữ liệu song ngữ từ việc dịch dữ liệu đơn ngữ miền sang ngôn ngữ đích. Phương pháp này chủ yếu liên quan đến kĩ thuật được đề xuất trong [2] nhưng khác nhau ở dữ liệu dùng để thích ứng miền, cụ thể ở [10] chỉ sử dụng dữ liệu đơn ngữ miền.

Các đề xuất trên được công bố cho dịch máy thống kê. Tuy nhiên, năm 2016 có công bố [11] đã đề xuất thích ứng miền cho dịch máy nơ ron dựa vào sinh dữ liệu song ngữ cho hệ dịch bằng việc dịch ngược các dữ liệu đơn ngữ trong miền đích. Trong bài báo này, phương pháp chúng tôi đề xuất có phần giống với phương pháp [9] vì chúng tôi có sử dụng thêm một tập dữ liệu miền pháp lý để tối ưu tham số của hệ dịch cơ sở theo định hướng miền đích, nhưng cũng liên quan nhiều đến phương pháp được đề xuất trong [10] và [11].

Nhìn chung, các phương pháp về thích ứng miền nói chung cho dịch máy đã được công bố khá phức tạp, thử nghiệm công phu và sử dụng nhiều mô hình toán học. Tuy nhiên, các thử nghiệm mới chỉ áp dụng cho một số cặp ngôn ngữ phổ biến như Anh - Pháp, Anh - Nhật, Anh - Tây Ban Nha,... Hiện vẫn chưa có công bố nào áp dụng cho cặp ngôn ngữ Anh - Việt.

## PHƯƠNG PHÁP ĐỀ XUẤT

### Tổng quan về dịch máy nơ ron

Đối với phương pháp dịch máy truyền thống như dịch máy thống kê dựa vào cụm thì hệ dịch thực hiện phân tách câu nguồn thành nhiều từ hoặc cụm từ riêng biệt, sau đó dịch tuần tự từng từ hoặc cụm từ một rồi sắp xếp lại trật tự các từ theo đúng trật tự trong ngôn ngữ đích. Vì thế, nên bản dịch không được trôi chảy và các dịch này không giống như cách con người dịch, để dịch, chúng ta sẽ đọc trọn vẹn một câu nguồn, hiểu ý nghĩa của nó rồi mới tiến hành dịch câu đó sang ngôn ngữ đích. Dịch máy nơ ron thực hiện dịch tương tự như cách của con người.

![](images/image1.jpg)

_**Hình 1.** Kiến trúc Encoder - Decoder_

Cụ thể, đầu tiên hệ dịch nơ ron sử dụng bộ mã hóa _(Encoder)_ để đọc toàn bộ câu nguồn và mã hóa nó dưới dạng một vectơ biểu diễn ý nghĩa. Sau đó, bộ giải mã _(Decoder)_ sẽ đọc và giải mã vec tơ biểu diễn câu nguồn này để sinh ra bản dịch tương ứng sang ngôn ngữ đích, quá trình mã hóa - giải mã được minh họa như ở hình 1 và hình 2 [5]. Theo cách dịch này, hệ dịch nơ ron có thể giải quyết được vấn đề dịch cục bộ trong phương pháp dịch dựa vào cụm truyền thống, đó là: nó có thể nắm bắt được các phụ thuộc xa hơn trong các ngôn ngữ và tạo ra các bản dịch trôi chảy hơn nhiều so với hệ dịch thống kê dựa vào cụm truyền thống.

**Bộ mã hóa -** Bộ mã hóa đọc câu nguồn _X = (x1, x2, …,xT)_ và chuyển đổi nó thành một chuỗi các trạng thái ẩn _h = (h1, h2,…,hT)_ sử dụng mạng nơ ron hồi quy hai chiều _(bi-directional RNN)_. Tại mỗi thời điểm t, trạng thái ẩn ht được xác định như là một kết hợp các trạng thái ẩn của mạng nơ ron hồi quy theo chiều xuôi _(forward RNN)_ và theo chiều ngược

![](images/image2.jpg)

_(backward RNN)_ ![](images/image3.jpg) với điều kiện
**Bộ giải mã -** Bộ giải mã sử dụng mạng nơ ron hồi quy khác để sinh ra bản dịch _Y = (y1, y2, …,yT’)_ dựa trên các trạng thái ẩn h được sinh bởi bộ mã hóa. Tại mỗi thời điểm i, xác suất có điều kiện của mỗi từ yi trong tập từ vựng _Vy_ của ngôn ngữ đích được tính bởi công thức:

_P(yi|y <i, h)=g(yi-1, zi, ci),_

_v_ ới điều kiện zi là trạng thái ẩn ith của bộ giải mã, và được tính dựa vào trạng thái ẩn trước zi-1, từ trước yi-1 và vectơ ngữ cảnh nguồn ci: _Zi= RNN(zi-1, yi-1, ci)._

### Phương pháp đề xuất

Trong thực tế, dữ liệu song ngữ thường không có sẵn, đặc biệt đối với các miền dữ liệu thuộc các lĩnh vực, chuyên ngành đặc thù, còn nếu muốn xây dựng dữ liệu song ngữ cho từng miền thì chi phí phải trả sẽ rất cao nhưng dữ liệu đơn ngữ thì lại luôn có sẵn với bất cứ miền dữ liệu nào. Trong dịch máy, dữ liệu đơn ngữ thường được dùng để làm mịn câu, khiến bản dịch của câu trôi chảy hơn và đọc lên thấy tự nhiên nhất. Dữ liệu đơn ngữ cũng đã được chứng minh có nhiều lợi ích trong việc cải tiến chất lượng dịch của cả hệ dịch máy thống kê và dịch máy nơ ron, đặc biệt trong nhiệm vụ thích ứng trong trường hợp nguồn tài nguyên bị hạn chế, nguồn dữ liệu song ngữ không đủ lớn. Hiện nay, cũng đã có một số đề xuất sử dụng dữ liệu đơn ngữ cho việc cải tiến chất lượng dịch, trong đó có đề xuất sinh dữ liệu song ngữ từ dữ liệu đơn ngữ cho dịch máy nhưng chưa có đề xuất, thử nghiệm hay khảo sát nào được công bố về sử dụng dữ liệu đơn ngữ để thích ứng miền áp dụng cho cặp ngôn ngữ Anh – Việt.
Như đã trình ở phần 2, phương pháp chúng tôi đề xuất có liên quan tới các công bố [9]; [10] và [11]. Theo [11], để sinh dữ liệu song ngữ thì việc dịch theo chiều ngược là cũng một giải pháp để có thể tận dụng được nguồn dữ liệu đơn ngữ miền. Để dịch theo chiều ngược hay theo chiều xuôi thì khá đơn giản và dễ áp dụng vì nó không yêu cầu phải thay đổi các thuật toán huấn luyện của hệ dịch.
Xuất phát từ ý tưởng trên, chúng tôi đề xuất một phương pháp mới để sinh dữ liệu song ngữ cho nhiệm vụ thích ứng miền áp dụng cho cặp ngôn ngữ Anh - Việt với chiều dịch từ Anh sang Việt, phương pháp của chúng tôi chỉ sử dụng dữ liệu đơn ngữ trong miền đích của ngôn ngữ đích. Phương pháp của chúng tôi khác với công bố trong [9]; [10] vì các công bố này chỉ thực nghiệm, áp dụng cho dịch máy thống kê dựa vào cụm còn phương pháp của chúng tôi là áp dụng cho dịch máy nơ ron. Ngoài ra, công bố [11] cũng khá liên quan tới phương pháp của chúng tôi khi cũng áp dụng cho dịch máy nơ ron, nhưng sử dụng kĩ thuật dịch ngược. Còn phương pháp của chúng tôi, cùng với các thử nghiệm, đánh giá hệ dịch dựa trên cách dịch xuôi dữ liệu đơn ngữ trong miền đích của ngôn ngữ đích. Phương pháp chúng tôi đề xuất được mô tả như hình 3, gồm 3 giai đoạn:

  * **Giai đoạn 1** : Giai đoạn này chúng tôi sử dụng dữ liệu song ngữ Anh – Việt thuộc miền tổng quan để huấn luyện một hệ dịch nơ ron làm cơ sở để so sánh, đánh giá hiệu quả của phương pháp chúng tôi đề xuất _(đặt tên là **Baseline NMT** như mô tả trong Hình 3 **,** trong các thử nghiệm gồm các hệ dịch Baseline_L và Baseline_G)_;


  * **Giai đoạn 2** : Sau khi đã có hệ dịch Baseline NMT ở giai đoạn 1, chúng tôi sử dụng hệ dịch này để dịch các văn bản đơn ngữ thuộc miền pháp lý trong tiếng Anh sang ngôn ngữ đích là tiếng Việt;

  * **Giai đoạn 3** : Sau khi có kết quả dịch ở giai đoạn 2, chúng tôi sử dụng kết quả dịch này kết hợp với các văn bản đơn ngữ bằng tiếng Anh ở giai đoạn 2 để huấn luyện một hệ dịch nơ ron khác _(đặt tên là **Adaptation NMT** như mô tả trong Hình 3, trong các thử nghiệm là hệ dịch **Adapt_System** )_, hệ dịch này được sử dụng để cải tiến chất lượng dịch của các văn bản thuộc miền pháp lý.


Bằng thực nghiệm, các kết quả so sánh thông qua cách đánh giá bằng điểm BLEU [6] đã chỉ ra rằng phương pháp chúng tôi đề xuất là cách tiếp cận khả quan, dễ thực hiện và đã cho kết quả dịch cải tiến hơn so với hệ dịch cơ sở ban đầu.

## THỰC NGHIỆM VÀ KẾT QUẢ

Để so sánh, đánh giá phương pháp đề xuất, chúng tôi tiến hành huấn luyện ba hệ dịch nơ ron, lần lượt _là **(1) Baseline_G**_ \- là hệ dịch cơ sở được huấn luyện với tập dữ liệu huấn luyện và tập tối ưu tham số _(tập dữ liệu G_train và tập dữ liệu G_val)_ cùng thuộc miền tổng quan; _**(2) Baseline_L**_ \- là hệ dịch được huấn luyện với tập dữ liệu huấn luyện thuộc miền tổng quan _(G_train)_ , còn tập tối ưu tham số thuộc miền luật _(L_val)_ ; _**(3) Adapt_System**_ \- là hệ dịch được huấn luyện với dữ liệu song ngữ được tổng hợp ở giai đoạn 2 của hình 3 và dữ liệu tối ưu tham số thuộc miền luật _(L_val)_.

Tiếp theo, chúng tôi sẽ mô tả về các tập dữ liệu, các bước tiền xử lý đối với dữ liệu huấn luyện của từng hệ dịch trên, đồng thời chúng tôi cũng trình bày cụ thể các bước thực nghiệm và kết quả tương ứng.

### Dữ liệu

Để huấn luyện hệ dịch, trong các thử nghiệm của chúng tôi có hai loại dữ liệu miền khác nhau, ở góc độ bài toán mà chúng tôi giải quyết đó là tận dụng dữ liệu đơn ngữ thuộc miền cần dịch và một hệ dịch có sẵn thuộc miền tổng quan để nâng cao chất lượng dịch theo miền _(miền pháp lý trong các thực nghiệm của chúng tôi)_. Để thống nhất, chúng tôi gọi dữ liệu thuộc miền tổng quan để huấn luyện hệ dịch là dữ liệu trong miền và dữ liệu không thuộc miền huấn luyện là dữ liệu ngoài miền.

### Thống kê dữ liệu

  1. _Dữ liệu trong miền:_ Chúng tôi sử dụng tập dữ liệu được cung cấp bởi hội nghị IWSLT 20152, tập dữ liệu này thuộc miền tổng quan gồm 131.000 cặp câu song ngữ tiếng Anh - tiếng Việt dành cho nhiệm vụ về dịch máy, tập dữ liệu này


được gọi là tập _**G_train**_ và được sử dụng để huấn luyện các hệ dịch cơ sở _(Baseline_G và Baseline_L)_. Để tối ưu các tham số của hệ dịch trong miền tổng quan, chúng tôi sử dụng tập dữ liệu gồm 745 cặp câu song ngữ thuộc miền tổng quan và gọi là tập _**G_val**_. Để đánh giá chất lượng của các hệ dịch khi dịch trong miền tổng quan, chúng tôi sử dụng 1.046 cặp câu song ngữ Anh – Việt thuộc miền tổng quan.

  2. _Dữ liệu ngoài miền:_ Chúng tôi sử dụng 100.000 câu đơn ngữ tiếng Anh thuộc miền pháp lý và dùng hệ dịch cơ sở Basline_NMT theo mô tả ở giai đoạn 2 của hình 3 để dịch nhằm tạo ra bản dịch gồm 100.000 câu tiếng Việt tương ứng. Để đánh giá chất lượng của các hệ dịch trong miền pháp lý, chúng tôi sử dụng 2.000 cặp câu song ngữ Anh - Việt cùng thuộc miền pháp lý.


### Tiền xử lý dữ liệu

Tiền xử lý dữ liệu là bước xử lý không thể thiếu trong các bài toán dịch. Sau khi thu thập được đầy đủ các tập dữ liệu, chúng tôi tiến hành chuẩn hóa. Đầu tiên, chúng tôi thực hiện tách từ trong văn bản, đối với văn bản tiếng Anh thì cần quan tâm tới việc tách các dấu ". , ’ ; ? " và các kí tự đặc biệt khác ra khỏi các từ trong văn bản. Để thực hiện việc này, chúng tôi sử dụng công cụ tách từ Tokenizer có sẵn trong hệ dịch mã nguồn mở Moses [4] do Koehn và cộng sự phát triển (2007). Đối với tiếng Việt, vì dấu cách không phải là dấu hiệu để phân biệt các từ, mà một từ trong tiếng Việt được cấu tạo bởi một hoặc nhiều âm tiết. Chính vì vậy, để tiến hành tách từ cho văn bản tiếng Việt, chúng tôi sử dụng công cụ tách từ dành riêng cho tiếng Việt khá phổ biến là VnTokenizer [1].

Sau đó, chúng tôi thực hiện chuyển tất cả các kí tự hoa trong các tập dữ liệu về dạng kí tự thường và loại bỏ những cặp câu có độ dài quá lớn trong dữ liệu, trong các thực nghiệm này chúng tôi chỉ chọn những câu có độ dài nhỏ hơn 80.

### Các thực nghiệm

Để huấn luyện các hệ dịch nơ ron, chúng tôi sử dụng công cụ OpenNMT3 [7], đây là hệ dịch mã nguồn mở hoàn thiện, nổi tiếng, được công bố năm 2017 của nhóm [Harvard NLP](https://nlp.seas.harvard.edu/) và SYSTRAN, công cụ này được nhiều người nghiên cứu trong cộng đồng dịch máy sử dụng. Các hệ dịch được huấn luyện với cùng các tham số mặc định, bao gồm hai tầng mạng LSTM với 500 nút ẩn và có sử dụng mô hình attention theo kiến trúc của Thang Luong [8]. Để so sánh, đánh giá chất lượng của các hệ dịch với nhau, chúng tôi sử dụng cách đánh giá tự động dựa vào điểm BLEU [6], đây cũng là cách đánh giá phổ biến trong bài toán dịch máy. Như mô tả ở hình 3:
**_Giai đoạn 1:_** Chúng tôi huấn luyện các hệ dịch cơ sở Baseline NMT, các hệ dịch này được huấn luyện với dữ liệu song ngữ thuộc miền tổng quan, nhưng được tối ưu tham số trong các miền dữ liệu khác nhau, cụ thể:

  * Hệ dịch **Baseline_G:** Sử dụng tập dữ liệu G_train và G_val _(mô tả trong bảng 1)_ để huấn luyện, hệ dịch cơ sở này được huấn luyện với dữ liệu song ngữ và tối ưu các tham số trong cùng một miền tổng quan.

  * Hệ dịch **Baseline_L:** Sử dụng tập dữ liệu G_train và L_val _(mô tả trong bảng 1_ ) để huấn luyện, hệ dịch cơ sở này được huấn luyện với dữ liệu song ngữ thuộc miền tổng quan nhưng các tham số của hệ dịch được tối ưu trong miền pháp lý.


Việc lựa chọn hệ dịch có chất lượng bản dịch tốt, để từ đó tiến hành dịch xuôi và tổng hợp được dữ liệu song ngữ có chất lượng tốt. Chúng tôi tiến hành đánh giá, so sánh chất lượng bản dịch của hai hệ dịch cơ sở này khi dịch trong cùng một miền dữ liệu tổng quan và miền dữ liệu pháp lý. Kết quả thử nghiệm được đánh giá thông qua điểm BLEU được thể hiện như bảng 2. Ở bảng 2, ta thấy:

  * Khi dịch với cùng tập dữ liệu là G_test thuộc miền tổng quan, hệ dịch Baseline_G cho điểm BLEU = 29,34 trong khi Baseline_L có điểm BLEU = 29,56.

  * Khi dịch với cùng tập dữ liệu L_test thuộc miền pháp lý thì hệ dịch Baseline_G cho điểm BLEU = 22,17 và hệ dịch Baseline_L cho điểm BLEU = 23,01.


Như vậy, khi hệ dịch cơ sở Baseline_L được tối ưu tham số trong miền pháp lý đã cải tiến được chất lượng của bản dịch khi dịch trong miền pháp lý, cụ thể đã tăng 0.84 điểm BLEU _(điểm BLEU = 23,01 so với 22,17 của hệ dịch Baseline_G)_. Căn cứ vào kết quả so sánh này, chúng tôi lựa chọn hệ dịch cơ sở Baseline_L để thực hiện các bước trong giai đoạn 2.
**_Giai đoạn 2:_** Chúng tôi dùng hệ dịch Baseline_L ở trên để dịch tập dữ liệu đơn ngữ gồm 100.000 câu tiếng Anh thuộc miền pháp lý sinh ra bản dịch tương ứng gồm 100.000 câu tiếng Việt.

**_Giai đoạn 3:_** Chúng tôi sử dụng cặp dữ liệu đơn ngữ ở giai đoạn 2 _(gồm 100.000 tiếng Anh và bản dịch của nó gồm 100.000 tiếng Việt)_ để huấn luyện hệ dịch Adapt_System, hệ dịch này được tối ưu tham số với tập dữ liệu L_val thuộc miền pháp lý. Các thử nghiệm cho kết quả điểm BLEU = 26,56 khi dịch tập dữ liệu G_test thuộc miền tổng quan, và điểm BLEU = 24,38 khi dịch tập dữ liệu L_test thuộc miền pháp lý.

Như vậy, hệ dịch Adapt_System cho chất lượng dịch trong miền pháp lý cao hơn so với các hệ dịch cơ sở Baseline_G và Baseline_L. Cụ thể, điểm BLEU cao hơn 2,21 điểm so với Baseline_G _(cải tiến từ 22,17 điểm tăng lên 24,38 điểm)_ và cao hơn 1,37 điểm so với Baseline_L _(cải tiến từ 23,01 điểm tăng lên 24,38 điểm)._ Các kết quả thử nghiệm được thể hiện trong bảng 2 và sự biến đổi về chất lượng của bản dịch được thể hiện như biểu đồ trong hình 4.

Các kết quả thử nghiệm đã cho thấy phương pháp mà chúng tôi đề xuất là cách tiếp cận khả quan, dễ thực hiện và đã cho kết quả dịch khi dịch trong miền pháp lý cải tiến hơn so với hệ dịch cơ sở ban đầu.

## KẾT LUẬN

Trong bài báo này, chúng tôi đã đề xuất một phương pháp thích ứng miền mới cho dịch máy nơ ron, phương pháp này đặc biệt hiệu quả đối với các miền dữ liệu có ít tài nguyên của cặp ngôn ngữ Anh - Việt, trong các thử nghiệm của chúng tôi, chúng tôi sử dụng dữ liệu thuộc miền pháp lý. Qua thực nghiệm cho thấy, cách tiếp cận này là khả quan, dễ thực hiện và đã cho kết quả dịch có điểm BLEU tăng 2,21 điểm _(từ 22,17 điểm lên 24,38 điểm)._ Như vậy, chất lượng dịch sau khi thích ứng đã có cải tiến hơn so với hệ dịch cơ sở ban đầu.

Trong tương lai, chúng tôi sẽ tiến hành thử nghiệm mở rộng thêm trên cả hai chiều dịch đối với một số miền dữ liệu khác, và khảo sát với các tình huống khi dữ liệu đơn ngữ theo miền có sự thay đổi về lượng thì chất lượng dịch của hệ thống lúc này sẽ thay đổi như thế nào, và lượng dữ liệu đơn ngữ này thay đổi như thế nào là vừa đủ đối với từng miền dữ liệu.

# TÀI LIỆU THAM KHẢO

  1. Phuong-Le Hong, Huyen-Nguyen Thi Minh, Azim Roussanaly and Vinh-Ho Tuong (2008). A Hybrid Approach to Word Segmentation of Vietnamese Texts.In Proceedings of the 2nd International Conference on Language and Automata Theory and Applications, Springer, LNCS 5196.

  2. Philipp Koehn and Josh Schroeder. 2007. Experiments in domain adaptation for statistical machine translation. In Proceedings of the Second Workshop on Statistical Machine Translation, pages 224–227, Prague, Czech Republic.


  3. Philipp Koehn. 2002. Europarl: A multilingual corpus for evaluation of machine translation. Unpublished, http://www.isi.edu/∼koehn/europarl.

  4. P. Koehn, H. Hoang, A. Birch, C. Callison-Burch, M. Federico, N. Bertoldi, B. Cowan, W. Shen, C. Moran, R. Zens, C. Dyer, O. Bojar, A. Constantin, and E. Herbst. 2007. Moses: Open source toolkit for statistical machine translation. In Proceedings of the 45th Annual Meeting of the Association for Computational Linguistics Companion Volume Proceedings of the Demo and Poster Sessions, pages 177– 180, Prague, Czech Republic.

  5. Philipp Koehn. 2017. Neural machine translation. CoRR, abs/1709.07809.

  6. Kishore Papineni, Salim Roukos, Todd Ward, and WeiJing Zhu. 2002. BLEU: a method for automatic evaluation of machine translation. In Proceedings of the 40th Annual Meeting of the Association of Computational Linguistics (ACL), pages 311–318, Philadelphia, PA.

  7. Guillaume Klein, Yoon Kim, Yuntian Deng, Jean Senellart, Alexander M. Rush. 2017. OpenNMT: Open-Source


Toolkit for Neural Machine Translation. Proceedings of AMTA 2018, vol. 1: MT Research Track.

  8. Minh-Thang Luong, Hieu Pham, and Christopher D Manning. 2015. [Effective approaches to attention-based neural](https://arxiv.org/pdf/1508.04025.pdf) [machine translation.](https://arxiv.org/pdf/1508.04025.pdf) EMNLP.

  9. Nicola Ueffing, Gholamreza Haffari, and Anoop Sarkar. 2007. Semi-supervised model adaptation for statistical machine translation. Machine Translation, 21(2):77–94.

  10. Nicola Bertoldi, Marcello Federico. 2009. Domain Adaptation for Statistical Machine Translation with Monolingual Resources. Proceedings of the 4th EACL Workshop on Statistical Machine Translation , pages 182–189.

  11. Rico Sennrich, Barry Haddow, and Alexandra Birch. 2016. Improving neural machine translation models with monolingual data. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 86–96, Berlin, Germany, August. Association for Computational Linguistics.


##

# Public_004

_Ngành xây dựng không ngừng tìm kiếm những cách thức mới để nâng cao hiệu quả, nhiều công nghệ mới đã và đang được ứng dụng. Tuy nhiên, phương pháp xây dựng truyền thống vẫn không thay đổi trong nhiều thập kỷ qua, làm cho quá trình xây dựng kéo dài, không tối ưu nguồn lực dẫn đến giảm hiệu quả đầu tư xây dựng. Công nghệ in 3D là một công nghệ mới đầy hứa hẹn góp phần nâng cao hiệu quả đầu tư xây dựng và hạn chế tác động tiêu cực đến môi trường. Công nghệ in 3D sử dụng vật liệu bê tông là công nghệ có thể cho phép sản xuất cấu kiện kiến trúc, xây dựng mà không cần sử dụng ván khuôn, giúp mang lại nhiều lợi ích hơn so với phương pháp truyền thống. Trong khi công nghệ in 3D đã được áp dụng thành công trong một loạt các lĩnh vực như y tế, giáo dục, hàng không vũ trụ, ô tô v.v., thì ứng dụng của công nghệ này trong ngành xây dựng vẫn còn ở giai đoạn đầu. Trong vài năm qua, nhiều loại công nghệ in bê tông 3D khác nhau đã được phát triển và ứng dụng._

# Nội dung chính

## GIỚI THIỆU

Những thách thức trong ngành xây dựng hiện nay như tốc độ xây dựng chậm, quá trình thi công xây dựng gồm nhiều bước, mỗi bước đều tốn nhiều thời gian và công sức, công nghệ thi công hiện nay đang sử dụng nhiều nhân công lao động và tình trạng mất an toàn lao động là rất đáng quan ngại, ngoài ra các phương pháp thi công xây dựng và vật liệu xây dựng hiện tại không thân thiện với môi trường. Toàn bộ quá trình xây dựng, bao gồm sản xuất chế tạo sẵn, vận chuyển vật liệu, thi công xây dựng trên công trường đã thải ra một lượng lớn khí nhà kính và tiêu thụ một lượng lớn năng lượng, gây ô nhiễm môi trường. Do đó vấn đề đặt ra là phải áp dụng những công nghệ tiên tiến trong ngành xây dựng, trong đó công nghệ in bê tông 3D đang cho thấy những ưu điểm rõ rệt.

Kể từ khi phát hiện ra bê tông hiện đại vào thế kỷ 19, nhiều nhà nghiên cứu đã tìm cách tự động hóa việc xây dựng sử dụng vật liệu bê tông. Nhiều công nghệ xây dựng sử dụng vật liệu bê tông đã được phát triển, như công nghệ bơm bê tông và công nghệ phụ gia. Một nỗ lực lớn gần đây đối với ngành xây dựng dựa trên ý tưởng mới là các kỹ thuật sản xuất bồi đắp. Sản xuất bồi đắp được định nghĩa là quy trình ghép các lớp vật liệu để tạo các vật thể từ dữ liệu mô hình số 3D, trái ngược với các phương pháp sản xuất trừ (như điêu khắc). Trong đó nổi bật là công nghệ in 3D sử dụng vật liệu bê tông.

Công nghệ in bê tông 3D đề cập đến một quy trình sản xuất bồi đắp tự động, trong đó các đối tượng in được tạo ra bằng cách liên kết các lớp vật liệu kế tiếp chồng lên nhau. Quá trình bắt đầu với việc tạo ra một mô hình 3D bằng phần mềm CAD (Computer Aided Design). Mô hình sau đó được nhập vào máy in bê tông 3D bằng định dạng tệp .STL (Stereolithography Language) là định dạng tệp phổ biến hiện nay, từ đây mô hình được chia thành các lớp có thể liên kết với nhau để tạo thành đối tượng in 3D. Trong những năm gần đây, công nghệ in bê tông 3D đã nhận được rất nhiều sự chú ý từ ngành xây dựng như một phương pháp thi công xây dựng đầy triển vọng. Công nghệ in bê tông 3D giúp tiết kiệm thời gian, vật liệu, nhân công bằng cách giảm hao hụt vật liệu, hạn chế hoặc không sử dụng ván khuôn từ đó giúp giảm chi phí. Ngoài ra, công nghệ này cũng hạn chế việc sao chép, giúp các nhà thiết kế có thể làm cho công trình trở có tính chất riêng so với các công trình khác.

Hiện nay việc áp dụng công nghệ in bê tông 3D trong ngành xây dựng vẫn gặp nhiều rào cản nhất định như còn nhiều hạn chế về mặt công nghệ, chi phí đầu tư cũng như chất lượng của các sản phẩm được chế tạo bằng công nghệ này.

Tuy nhiên, với sự phát triển của khoa học công nghệ, việc áp dụng các tiến bộ khoa học công nghệ trong ngành xây dựng là tất yếu. Trong đó, việc áp dụng công nghệ in bê tông 3D trong xây dựng có thể giải quyết những vấn đề nan giải hiện nay của ngành xây dựng. Bài báo giới thiệu các công nghệ in bê tông 3D và so sánh tính khả thi của các công nghệ này ứng dụng trong ngành xây dựng Việt Nam.

## TỔNG QUAN

Ứng dụng của công nghệ in bê tông 3D trong ngành xây dựng là để chế tạo các cấu kiện kiến trúc, xây dựng. Mặc dù việc ứng dụng công nghệ in bê tông 3D vẫn còn ở giai đoạn đầu, tuy nhiên những nỗ lực nhằm đưa công nghệ này ứng dụng có hiệu quả hơn trong ngành xây dựng đã và đang được thực hiện trên toàn thế giới. Công nghệ in bê tông 3D là một công nghệ mới, nhằm mục đích giảm thiểu thời gian của quá trình xây dựng bằng cách loại bỏ một số quy trình tốn thời gian của phương pháp truyền thống, giảm các chi phí thông qua việc giảm thiểu khối lượng phát sinh, giảm nhân công lao động, đồng thời dễ dàng tạo ra những cấu kiện có hình dạng phức tạp với độ chính xác cao mà khó có thể thực hiện được bằng phương pháp truyền thống, cải thiện tác động tiêu cực của ngành xây dựng lên môi trường. Công nghệ in bê tông 3D có khả năng chế tạo cấu kiện kiến trúc, xây dựng được thiết kế trước bằng cách liên kết các lớp vật liệu chồng lên nhau theo một quy tắc nhất định.

Hiện nay, việc ứng dụng công nghệ in bê tông 3D trong ngành xây dựng còn nhiều vấn đề nan giải. Các nghiên cứu trên thế giới đã chỉ ra một số rào cản về vấn đề này như khả năng làm việc của cấu kiện được sản xuất bằng công nghệ in bê tông 3D hiện nay còn nhiều hạn chế về khả năng chịu lực so với các phương pháp sản xuất cấu kiện bê tông truyền thống tính đến thời điểm hiện tại. Những thách thức hiện tại trong thương mại hóa công nghệ in bê tông 3D như thiếu tiêu chuẩn, chi phí đầu tư lớn, các cấu kiện được chế tạo chưa đảm bảo chất lượng. Tuy nhiên lợi ích của công nghệ này đối với ngành xây dựng là rất to lớn như hạn chế hao hụt vật liệu, giảm đáng kể nhân công, đồng thời giảm thời gian thi công xây dựng. Nhiều nghiên cứu cũng đề cập đến khả năng áp dụng của các công nghệ in bê tông 3D trong xây dựng như việc áp dụng công nghệ Contour Crafting trong thi công xây dựng và khẳng định công nghệ Contour Crafting là một trong số rất ít các công nghệ khả thi có thể áp dụng trong ngành xây dựng [1]. S. Lim và cộng sự đã sử dụng công nghệ in bê tông 3D trong việc sản xuất các cấu kiện xây dựng quy mô lớn và đánh giá lợi ích của công nghệ này so với công nghệ xây dựng truyền thống [2].

Các nghiên cứu về việc chế tạo, kiểm định vật liệu in và cấu kiện in đã được thực hiện trong nhiều năm qua, như đánh giá và sửa đổi chất lượng in, độ ổn định hình dạng của hỗn hợp vật liệu in [3], sử dụng các vật liệu in khác nhau để chế tạo và kiểm tra khả năng tạo ra các cấu kiện có cấu trúc phức tạp cũng như cường độ của sản phẩm được chế tạo bằng công nghệ in bê tông 3D [4], nghiên cứu tối ưu hóa vật liệu và máy in chế tạo các cấu kiện phù hợp để ứng dụng trong quy mô nhỏ, qua đó chứng minh công nghệ in bê tông 3D này không chỉ là một công cụ đầy hứa hẹn cho thiết kế kết cấu, mà còn là một công cụ tiềm năng cho thiết kế kiến trúc [5]. Phát triển phương pháp để tạo ra các cấu kiện dựa trên geopolyme được sử dụng trong các máy in 3D sử dụng kỹ thuật lắng đọng bột có bán trên thị trường cho các ứng dụng xây dựng [6].

Nhìn chung, các nghiên cứu trên đã chỉ ra một số phạm vi áp dụng, lợi ích, khả năng áp dụng cũng như rào cản của công nghệ in bê tông 3D trong ngành xây dựng trên thế giới.

## CÁC CÔNG NGHỆ IN BÊ TÔNG 3D

Trong những năm qua, nhiều công nghệ in bê tông 3D khác nhau đã được phát triển để ứng dụng trong ngành xây dựng. Những công nghệ in bê tông 3D này chủ yếu dựa trên hai kỹ thuật chính, đó là kỹ thuật ép đùn (Extrusion-Based Technique) và kỹ thuật lắng đọng bột (Powder-Based Technique).

### Công nghệ in bê tông 3D dựa trên kỹ thuật ép đùn

Công nghệ in bê tông 3D dựa trên kỹ thuật ép đùn tương tự như phương pháp nóng chảy lắng đọng FDM (Fused Deposition Modelling). Theo đó, vật liệu in sẽ đi qua từ một đầu in được gắn trên cần trục hoặc cánh tay robot để in một đối tượng theo từng lớp vật liệu. Các công nghệ in bê tông 3D dựa trên kỹ thuật này tiêu biểu như:

#### * Công nghệ Contour Crafting

Contour Crafting là một phương pháp của quy trình sản xuất nhiều lớp sử dụng polymer, bùn gốm, bê tông, và một loạt các vật liệu và hỗn hợp khác để xây dựng các vật thể quy mô lớn với bề mặt mịn. Những ưu điểm chính của công nghệ này là tốc độ chế tạo nhanh hơn và khả năng tích hợp với các phương pháp khác để lắp đặt các bộ phận như đường ống, dây điện và cốt thép. Công nghệ Contour Crafting cho ra sản phẩm có bề mặt hoàn thiện vượt trội và tốc độ sản xuất được tăng cường đáng kể.

#### * Công nghệ Concrete Printing

Công nghệ Concrete Printing đã được nghiên cứu và phát triển tại Đại học Loughborough ở Vương quốc Anh. Công nghệ này cũng sử dụng kỹ thuật dựa trên ép đùn và ở một mức độ nào đó tương tự như công nghệ Contour Crafting. Tuy nhiên, công nghệ Concrete Printing đã được phát triển cho phép kiểm soát tốt hơn cấu trúc của sản phẩm in. Ngoài ra, vật liệu được sử dụng trong in bê tông là bê tông cốt liệu sợi tổng hợp cường độ cao nên tính chất của vật liệu vượt trội so với các vật liệu được sử dụng trong công nghệ Contour Crafting [2].

#### * Công nghệ Concrete On-Site 3D Printing

Công nghệ Contour Crafting và Concrete Printing ngoài những ưu điểm so với các công nghệ truyền thống thì vẫn tồn tại một số hạn chế như sự cần thiết phải sử dụng máy móc mới và tiên tiến, kích thước cốt liệu nhỏ (thường sử dụng vữa tổng hợp thay vì bê tông thông thường) và kích thước hạn chế của sản phẩm in (tức là kích thước của máy in 3D phải lớn hơn kích thước của phần tử được in). Để khắc phục những hạn chế này, một công nghệ mới là công nghệ Concrete On-Site 3D Printing, được phát triển tại TU Dresden, Đức. Ưu điểm chính của công nghệ này là tính linh hoạt hình học cao và ít phụ thuộc vào nhân công lành nghề [7].

Một trong những ưu điểm của công nghệ in bê tông 3D tại chỗ không chỉ là phát triển quy trình xây dựng tiên tiến hiệu quả về thời gian, lao động và tài nguyên mà còn làm cho quy trình mới có hiệu quả kinh tế trong khi đạt được sự chấp nhận rộng rãi hơn trong ngành xây dựng. Điều này đạt được bằng cách sử dụng các kỹ thuật sản xuất và xây dựng hiện có càng nhiều càng tốt và bằng cách điều chỉnh quy trình mới với các hạn chế của công trường xây dựng [7].

#### * Công nghệ in bê tông 3D quy mô lớn sử dụng bê tông cường độ cao (Large-Scale 3DCP using Ultra-High Performance Concrete)

Qua việc nghiên cứu những hạn chế của các công nghệ Contour Crafting và công nghệ Concrete Printing đã đề cập ở trên, một công nghệ mới đã được một nhóm nghiên cứu ở Pháp giới thiệu với quy mô áp dụng lớn, sử dụng bê tông cường độ cao (UHPC). Công nghệ này được phát triển dựa trên kỹ thuật ép đùn để in bê tông cường độ cao theo từng lớp thông qua một đầu in đùn được gắn trên cánh tay robot. Ưu điểm chính của công nghệ này là cho phép sản xuất cấu kiện với hình dạng phức tạp với quy mô lớn mà không cần ván khuôn [8].

### Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột (Powder-based Technique)

Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột là một quy trình chế tạo cộng điển hình khác tạo ra các cấu kiện với hình học phức tạp bằng cách lắng đọng chất lỏng kết dính một cách chọn lọc. Kỹ thuật này là một quy trình ngoài công trường được thiết kế để sản xuất các cấu kiện đúc sẵn. Một số công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột được liệt kê dưới đây.

#### * Công nghệ in ba chiều (D-Shape)

Công nghệ D-Shape được phát triển bởi Enrico Dini sử dụng kỹ thuật dựa trên kỹ thuật lắng đọng bột để làm cứng một lớp vật liệu quy mô lớn. Xi măng cát và magiê oxychloride (còn được gọi là xi măng Sorel) được sử dụng làm vật liệu xây dựng và chất kết dính tương ứng [9].

#### * Công nghệ đối tượng mới (Emerging Objects)

Công nghệ đối tượng mới (Emerging Objects) được phát triển ở Hoa Kỳ sử dụng kỹ thuật lắng đọng bột để làm cứng có chọn lọc một công thức hỗn hợp xi măng bằng cách lắng đọng một tác nhân liên kết.

#### * Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột sử dụng Geopolymer (Powder-based 3DCP using Geopolymer)

Công nghệ in bê tông 3D dựa trên kỹ thuật lắng đọng bột sử dụng Geopolymer có khả năng sản xuất các cấu kiện xây dựng với chi tiết và hình dạng phức tạp. Công nghệ dựa trên lắng đọng bột có tiềm năng để sản xuất các cấu kiện xây dựng với độ bền cao và tốc độ hợp lý để đáp ứng nhu cầu sản xuất quy mô công nghiệp [10].

## KẾT LUẬN

Ưu điểm chính của công nghệ in ba chiều là sản phẩm tạo ra có kết cấu chắc chắn nhưng có nhược điểm là công nghệ này tốn nhiều công sức và rắc rối. Công nghệ Contour Crafting và Concrete Printing đều dựa trên kỹ thuật ép đùn, điều này làm cho chúng rất giống nhau, lợi thế của công nghệ Contour Crafting so với công nghệ Concrete Printing là độ mịn của bề mặt sản phẩm, tuy nhiên sản phẩm được sản xuất bằng công nghệ Concrete Printing có kết cấu chắc chắn hơn so với công nghệ Contour Crafting, nhưng sản phẩm sản xuất bằng công nghệ Concrete Printing lại có kích thước hạn chế hơn.

Dựa trên các phân tích ở trên, mặc dù công nghệ in bê tông 3D vẫn là một công nghệ mới nổi, khả năng ứng dụng trong xây dựng còn hạn chế, đặc biệt là đối với quy mô sản xuất tại chỗ trên công trường, nhưng với phát triển nhanh chóng của công nghệ này, việc in các cấu kiện bê tông ở quy mô lớn sẽ thành hiện thực trong tương lai gần.

# TÀI LIỆU TRÍCH DẪN

[1]. P. Sharma, "Automated Construction by Contour Crafting," Journal of advance research in mechanical & civil engineering, 2015.

[2]. S. Lim, R. A. Buswell, T. T. Le, S. A. Austin, A. G. .. F. Gibb and T. Thorpe, "Developments in construction-scale additive manufacturing processes," Automation in construction, vol. 21, pp. 262-268, 2012.

[3]. A. Kazemian, X. Yuan, R. Meier and B. Khoshnevis, "Performance-based testing of Portland cement concrete for construction-scale 3D printing," 3D Concrete Printing Technology, pp. 13-35.

[4]. B. P, J. Scott Z, B. Isaiah R and P. Max A, "Towards the formulation of robust and sustainable cementitious binders for 3D additive construction by extrusion," 3D Concrete Printing Technology, pp. 307-331, 2019.

[5]. Z. Malaeb, F. AlSakka and F. Hamzeh, "3D concrete printing: machine design, mix proportioning, and mix comparison between different machine setups," 3D concrete printing technology, pp. 115-136, 2019.

[6]. B. Nematollahi, M. Xia, P. Vijay and J. G. Sanjayan, "Properties of extrusion-based 3D printable geopolymers for digital construction applications," 3D Concrete Printing Technology, pp. 371-388, 2019.

[7]. N. V.N, K. M, N. M and M. V, CONPrint3D - 3D printing technology for onsite construction, Concrete in Australia, 2016.

[8]. Y. JunNam, Y. Kwang, H. Woon and P. MookLim, "Fiber-reinforced cementitious composite design with controlled distribution and orientation of fibers using three-dimensional printing technology," 3D Concrete Printing Technology, pp. 59-72, 2019.

[9]. G. Cesaretti, E. Dini, X. Kestelier, V. Colla and L. Pambaguian, "Building components for an outpost on the Lunar soil by means of a novel 3D printing technology," Acta Astronautica, vol. 93, pp. 430-450, 2014.

[10]. M. Xia and J. Sanjayan, "Method of formulating geopolymer for 3D printing for construction applications," Materials & Design, vol. 110, pp. 382-390, 2016

# Public_005

_Chuyển đổi số các cơ sở giáo dục đào tạo đang là một nhiệm vụ cấp bách và Học viện Ngân hàng cũng không nằm ngoài guồng quay của cuộc cách mạng công nghệ này. Để quá trình chuyển đổi số được thuận lợi thì quá trình số hóa dữ liệu cần được ưu tiên đẩy mạnh. Trong bài báo này, tác giả nghiên cứu những giải pháp phù hợp cho việc số hóa dữ liệu văn bản đã và đang lưu hành trong Học viện Ngân hàng. Cụ thể, tác giả giới thiệu các công nghệ cốt lõi trong số hóa tài liệu như Nhận dạng ký tự quang học, Xử lý văn bản thông minh, khảo sát các giải pháp tiêu biểu trên thị trường ở Việt Nam để lựa chọn giải pháp khả thi và tiến hành cài đặt thử nghiệm giải pháp FPT. AI Reader với bộ dữ liệu tự thu thập từ một số phòng ban tại Học viện. Kết quả thực nghiệm cho thấy tỷ lệ sai số ở mức từ đạt 27% và chỉ 16% từ bị sai ở các tiêu đề, đơn vị ban hành, loại văn bản. Giải pháp hoàn toàn có thể được nghiên_

# Nội dung chính

## Đặt vấn đề

Thực hiện chuyển đổi số (CĐS) trong lĩnh vực giáo dục đào tạo là một trong những hoạt động nhận được nhiều sự quan tâm và ưu tiên của nhiều nước trên thế giới. Hoạt động CĐS trong lĩnh vực giáo dục không chỉ tập trung vào hoạt động dạy và học trong thay đổi phương pháp dạy và học mà còn diễn ra ở rất nhiều nghiệp vụ khác như phát triển hệ thống hỗ trợ hoạt động quản lý điều hành, quản lý hoạt động khoa học công nghệ. Trên cơ sở Quyết định số 131/ QĐ-TTg năm 2022 của Thủ tướng Chính phủ phê duyệt Đề án “Tăng cường ứng dụng công nghệ thông tin và chuyển đổi số trong giáo dục và đào tạo giai đoạn 2022-2025, định hướng đến năm 2030” (Thủ tướng Chính phủ, 2022), Học viện Ngân hàng cũng đã có những hành động thiết thực để thích ứng với bối cảnh phát triển chung của giáo dục đại học.

Liên quan đến chuyển đổi số, khá nhiều thuật ngữ với hậu tố “số” có thể gây nhầm lẫn, như “công nghệ số”, “kinh tế số”, “kỹ thuật số”. Đặc biệt thuật ngữ tiếng Anh cũng có những thuật ngữ gần giống nhau như Digitization, Digitalization, vậy vai trò của chúng đối với CĐS như thế nào? Theo Phạm Huy Giao (2020) quá trình CĐS bao gồm ba giai đoạn như Hình 1.

Theo đó, một tổ chức muốn thực hiện CĐS, trước hết cần trải qua giai đoạn đầu tiên: Số hóa (Digitization). Đây là quá trình chuyển đổi các thực thể trong quy trình hoạt động từ dạng vật lý sang dạng số, có thể lưu trữ và xử lý trên máy tính điện tử. Chẳng hạn hồ sơ của một nhân viên từ bản sơ yếu lý lịch trên giấy được lưu trữ thành các trường thông tin trong cơ sở dữ liệu như Họ tên, Ngày sinh, Quê quán. Các số liệu kinh doanh từ việc lưu cả tập hóa đơn, chứng từ và kiểm kê lại khi cần thì được tổ chức thành các bảng số liệu trong Microsoft Excel. Hay chỉ đơn giản là lưu trữ các tệp tin (file) trong máy tính chứa các dữ liệu hoạt động của tổ chức cũng có thể phần nào được coi là số hóa.

Tại Học viện Ngân hàng, một số phòng ban đã có phần mềm quản lý và vận hành khá ổn định. Chẳng hạn Phòng Đào tạo có phần mềm Quản lý đào tạo, phòng Quản lý người học thực hiện quản lý trên Cổng thông tin sinh viên, Phòng Quản trị có phần mềm MISA, Tạp chí Khoa học và Đào tạo Ngân hàng cũng sử dụng phần mềm quản lý bài viết trực tuyến. Điều này giúp một lượng lớn dữ liệu tác nghiệp của Học viện được chuyển hóa vào các cơ sở dữ liệu tương ứng. Tuy nhiên, theo quan sát thực tế vẫn còn không ít dữ liệu vẫn đang lưu hành bản cứng, như các quyết định, tờ trình cũ khi chưa áp dụng phần mềm quản lý, hoặc các đơn từ, đặc biệt là đơn từ của sinh viên thì chưa có hình thức lưu trữ điện tử phù hợp. Khi cần phải tra cứu chỉ có thể đến tận nơi và tìm theo các tủ hồ sơ vật lý hoặc tra cứu trong máy tính cục bộ của chuyên viên phụ trách. Một số tài liệu được đăng tải trên website của đơn vị, nhưng chỉ có thể tra cứu theo tiêu đề văn bản (nếu được đặt tiêu đề chính xác) chứ các nội dung thường được đóng gói trong mã nhúng file PDF chỉ cho phép đọc chứ không thể truy cập chi tiết. Đây là một thách thức trong quá trình số hóa nói riêng và chuyển đổi số nói chung tại Học viện, thôi thúc các nghiên cứu tìm kiếm giải pháp thích hợp nhằm biến đổi các văn bản thô còn tồn đọng thành những tài liệu định dạng kỹ thuật số.

Từ thực trạng trên, tác giả đặt ra ba câu hỏi nghiên cứu chính:

  * Những công nghệ cần thiết cho việc số hóa dữ liệu văn bản là gì?

  * Có những giải pháp nào trên nền tảng những công nghệ đó thích hợp với số hóa dữ liệu văn bản tại Việt Nam?

  * Những văn bản đã và đang lưu hành tại Học viện khi áp dụng thử nghiệm các giải pháp này cho kết quả như thế nào?


Để tìm kiếm lời giải cho các câu hỏi trên, tác giả đề xuất nghiên cứu và đánh giá các giải pháp và công nghệ hiện đại liên quan đến việc số hóa tài liệu, văn bản. Cụ thể tác giả đặt ra một số mục tiêu nghiên cứu sau:

Nghiên cứu tổng quan các công nghệ số hóa dữ liệu văn bản như nhận dạng ký tự quang học (OCR) hay xử lý văn bản thông minh (IDP). Đây đều là những công nghệ đóng vai trò rất quan trọng trong công cuộc chuyển đổi số.

Khảo sát các giải pháp sẵn có trên thị trường ở Việt Nam, lựa chọn giải pháp khả thi cũng như cài đặt thử nghiệm với dữ liệu thực tế tại Học viện.

Thu thập dữ liệu thực tế từ các phòng ban chức năng và khoa chuyên ngành của Học viện. Dữ liệu được thu thập đảm bảo sự đa dạng về thể loại (các loại văn bản khác nhau lưu hành ở Học viện như nghị quyết, quyết định, thông báo), nguồn gốc (đơn vị phụ trách biên soạn hoặc ban hành văn bản), định dạng tài liệu (hình ảnh chụp từ điện thoại, ảnh quét từ máy scan, file pdf được chuyển từ văn bản MS Word).

Đánh giá mức độ hiệu quả về khả năng bóc tách tài liệu và nhận dạng ký tự của giải pháp đề xuất trên bộ dữ liệu đã thu thập.

Để đạt mục tiêu nghiên cứu, tác giả thực hiện tổng quan nhằm làm rõ cơ sở lý thuyết về công nghệ nhận dạng ký tự quang học; quan sát và trải nghiệm thực tế nhằm hệ thống các giải pháp nhận dạng ký tự quang học tại Việt Nam; và thực hiện thử nghiệm với tài liệu tại Học viện Ngân hàng.

## Cơ sở lý thuyết về công nghệ nhận dạng ký tự quang học

Công nghệ Nhận dạng ký tự quang học-Optical Character Recognition (OCR) là một loại công nghệ cho phép máy tính điện tử tự động nhận biết các ký tự (chữ cái, số, dấu câu, ký tự đặc biệt) trên những hình ảnh được cung cấp (Ravina Mithe, 2013). Không giống như bộ não con người, thứ có thể dễ dàng đọc được các ký tự, câu chữ từ hình ảnh, máy tính không đủ thông minh và khả năng trừu tượng để nhận biết được loại thông tin này. Máy tính chỉ hiểu hình ảnh là các điểm ảnh (pixel) đại diện bởi các con số chỉ mã màu sắc ở pixel đó. Bởi vậy, nghiên cứu về công nghệ OCR vẫn đang là một chủ đề rất được quan tâm trong cộng đồng nghiên cứu Trí tuệ nhân tạo.

Cách thức hoạt động chung của OCR được mô tả ở Hình 2. Theo đó máy quét sẽ quét biểu mẫu chứa hình ảnh ký tự, sau đó công cụ nhận dạng tiến hành đọc hiểu các hình ảnh và chuyển chúng thành dữ liệu ASCII (các ký tự máy có thể đọc được). Có nhiều yếu tố ảnh hưởng đến chất lượng văn bản đầu ra của hệ thống OCR như chất lượng hình ảnh đầu vào (độ phân giải cao/thấp, góc chụp nghiêng/thẳng, độ sáng, độ bóng...), mật độ văn bản trên hình ảnh đầu vào (ví dụ giấy tờ cá nhân thì mật độ văn bản ít hơn so với các quy định pháp luật), phông chữ của tài liệu gốc (chữ viết tay, chữ in hoa, loại phông chữ) hay ngôn ngữ của tài liệu gốc (tiếng Việt, tiếng Anh hay nhiều ngôn ngữ cùng trong một văn bản).

Quá trình xử lý của hệ thống OCR thường được chia thành 3 giai đoạn: phát hiện văn bản (text detection), nhận dạng văn bản (text recognition) và trích xuất thông tin (information extraction). Các giai đoạn này lại áp dụng nhiều kỹ thuật, thuật toán phức tạp của thị giác máy tính (Computer Vision) và xử lý ngôn ngữ tự nhiên (Natural Language Processing). Chẳng hạn với riêng bài toán trích xuất thông tin từ hóa đơn bán hàng tiếng Việt trong cuộc thi MC-OCR Challenge tổ chức năm 2021, mô hình nhận dạng ký tự tốt nhất được xây dựng dựa trên mạng nơ ron Faster R-CNN kết hợp với mạng nơ ron TransformerOCR (Vu Xuan-Son, 2021).

Cùng với OCR, gần đây, thuật ngữ Nhận dạng ký tự thông minh (Intelligent Character Recognition- ICR) (Raymond Ptucha, 2019) được sử dụng để mô tả quá trình đọc hiểu dữ liệu hình ảnh, cụ thể là văn bản chữ và số. ICR là một mô-đun của OCR, có khả năng biến hình ảnh viết tay hoặc các ký tự in thành dữ liệu ASCII.

OMR (Optical Mark Reader- Nhận dạng dấu quang học) (Krisana Chinnasarn, 1999) là một phương pháp điện tử thu thập dữ liệu do con người xử lý bằng cách xác định một số dấu hiệu nhất định trên tài liệu. Thông thường, quá trình nhận dạng dấu quang học được thực hiện với sự hỗ trợ của máy quét kiểm tra truyền tải hoặc phản xạ ánh sáng qua giấy; những nơi có đánh dấu sẽ phản xạ ít ánh sáng hơn phần giấy trắng, dẫn đến độ tương phản kém hơn. OMR thường được ứng dụng để xử lý dữ liệu từ phiếu điều tra hay chấm các bài thi trắc nghiệm. Ngoài ra, nhiều doanh nghiệp công nghệ cũng đưa ra thuật ngữ Xử lý văn bản thông minh (Intelligent Document Processing-IDP) là một công cụ tự động thu thập, trích xuất dữ liệu từ các tài liệu bán cấu trích xuất nội dung từ ảnh chụp mẫu văn bản có sẵn (giấy chứng minh nhân dân, bằng lái xe, thẻ bảo hiểm y tế, hóa đơn), hoặc theo bất kì định dạng văn bản tùy biến (hợp đồng, chứng từ, quy định...), nhằm số hóa tài liệu một cách nhanh chóng và thuận tiện. FPT.AI Reader được các chuyên gia trong lĩnh vực trí tuệ nhân tạo của FPT Smart Cloud nghiên cứu và phát triển. Giải pháp này áp dụng công nghệ nhận dạng ký tự quang học (OCR) và Xử lý văn bản thông minh (IDP), kết hợp kỹ thuật xử lý ảnh nâng cao và Xử lý ngôn ngữ tự nhiên (NLP), cho phép người dùng số hóa văn bản chính xác trong thời gian ngắn (chỉ tới vài giây) (FPT.AI, 2022). Hình 3 dưới đây là một ví dụ về trích xuất các thông tin cần thiết như họ tên, số căn cước công dân, giới tính, quốc tịch, quê quán, địa chỉ từ ảnh chụp mặt trước của một căn cước công dân theo mẫu hiện tại ở Việt Nam.

Đặc biệt, FPT.AI Reader cho phép người dùng tự định nghĩa mẫu văn bản mới, chưa có trong các mẫu có sẵn của hệ thống để tự tạo mô hình OCR của riêng mình. Chẳng hạn ta cần số hóa thẻ sinh viên, có thể tạo một dự án mới trong bảng điều khiển của FPT.AI (https://console.fpt.ai/), tải lên một trúc (semi-structured data) và phi cấu trúc (unstructured data) và chuyển chúng thành tài liệu có cấu trúc (structured data) để sử dụng (Akabot, 2022). IDP là sự kết hợp giữa nhiều công nghệ bao gồm Xử lý ngôn ngữ tự nhiên (Natural Language Processing-NLP), Thị giác máy tính (Computer Vision), Học máy (Machine Learning- ML) và OCR nhằm tăng cường việc nhận diện, phân loại, phân tích, trích xuất dữ liệu và đánh giá dữ liệu để nâng cao độ chính xác và hiệu quả. Ở Việt Nam, nhiều nghiên cứu đã được thực hiện nhằm áp dụng các công nghệ này cho từng loại nghiệp vụ khác nhau, chẳng hạn trích xuất và nhận dạng thông tin trên chứng minh nhân dân của người Việt (Duc Phan, 2021), trích xuất thông tin trên hóa đơn bán hàng (Vu Xuan-Son, 2021), nhận dạng biển số xe (Trần Thị Hương, 2021), trích xuất văn bản từ bìa sách (Phan Thi Thanh Nga, 2017). Tuy nhiên đến nay chưa có nghiên cứu nào áp dụng các công nghệ trên với các tài liệu ở cơ sở giáo dục đại học. Đây cũng là nội dung trọng tâm mà bài báo này hướng đến khi áp dụng thử nghiệm tại Học viện Ngân hàng.

## Kết quả thử nghiệm công nghệ nhận dạng ký tự quang học cho số hóa tài liệu tại Học viện Ngân hàng

### Các giải pháp nhận dạng ký tự quang học tại Việt Nam

####  FPT.AI Reader

FPT.AI Reader là ứng dụng nhận dạng và số ảnh mẫu và nhập vào một số trường thông tin quan trọng muốn trích xuất từ ảnh để huấn luyện mô hình OCR (minh họa ở Hình 4).

FPT.AI Reader cũng cho phép tích hợp ứng dụng OCR vào hệ thống của doanh nghiệp thông qua việc đăng ký tài khoản và nhận “API key” từ bảng điều khiển của FPT.AI (Console.fpt.ai). Mỗi API key này cho phép gửi và nhận kết quả đến 50 lần và có thể được mở rộng tùy vào quy mô xử lý dữ liệu của hệ thống.

####  Viettel OCR

Viettel OCR là giải pháp được phát triển bởi bộ phận Trí tuệ nhân tạo của Tập đoàn Viettel, cho phép chuyển đổi tài liệu dạng ảnh (máy quét, máy ảnh, file PDF được chuyển hóa từ file ảnh) thành văn bản như file text (.txt), file Word (.docx). Theo báo cáo trên trang web chính thức, Viettel OCR có khả năng nhận diện văn bản ở dạng bố cục tự do (free layout), có thể tùy chỉnh một cách nhanh chóng để phù hợp với từng bài toán cụ thể của doanh nghiệp. Giải pháp này có thể nhận file đầu vào ở nhiều định dạng khác nhau như PNG, JPEG, cho phép phân tích và trả về kết quả cho nhiều hình ảnh cùng 1 lúc (tối đa 10 ảnh) với độ chính xác tương đối cao (trong báo cáo không ghi rõ độ chính xác). Tuy nhiên trên website chính thức của giải pháp này chưa cho phép người dùng thử nghiệm mà phải liên hệ với tổng đài để đặt lịch tư vấn trực tiếp (Viettel AI, 2021).

#### Google Vision AI

Google Vision AI là dịch vụ đám mây của Google cho phép người dùng khởi tạo các ứng dụng phân tích hình ảnh và video trong thời gian ngắn, huấn luyện các mô hình máy học phân loại hình ảnh bằng AutoML hoặc các mô hình tùy chỉnh. Google Vision AI có khả năng phát hiện đối tượng, đọc chữ viết tay và tạo siêu dữ liệu hình ảnh có giá trị bằng các API được đào tạo trước. Một ưu điểm của giải pháp này là dễ dàng tích hợp với BigQuery, Cloud Function và máy ảnh để kích hoạt hành trình từ đầu đến cuối. Google Vision AI là một giải pháp khá linh hoạt, không tạo sẵn các mẫu tài liệu như FPT.AI Reader và Viettel OCR. Tốc độ xử lý của Google Vision AI khá nhanh. Tuy nhiên, quá trình thử nghiệm tính năng OCR của Google Vision AI với một vài tài liệu tiếng Việt cho kết quả chưa tốt (Hình 5).

#### Lựa chọn giải pháp

Ngoài 3 giải pháp thương mại kể trên, một số doanh nghiệp công nghệ ở Việt Nam cũng cung cấp các gói dịch vụ số hóa tài liệu với giải pháp riêng mà họ xây dựng. Tuy nhiên qua quá trình tìm hiểu và trải nghiệm, tác giả quyết định lựa chọn FPT. AI Reader làm giải pháp thử nghiệm trong bài báo này với các nguyên nhân:

FPT.AI Reader cung cấp nền tảng sử dụng miễn phí với tất cả người dùng cuối (end-user), chỉ hạn chế số lượng tài liệu xử lý mỗi ngày (50 requests) và có thể mở rộng linh hoạt tùy vào quy mô của doanh nghiệp.

Mô hình OCR huấn luyện sẵn của FPT. AI Reader có khả năng xử lý dữ liệu tiếng Việt tốt (theo báo cáo của FPT.AI đạt trên 96% cho các loại giấy tờ như chứng minh nhân dân, hộ chiếu (FPT.AI, 2022).

Giải pháp FPT.AI Reader đã được rất nhiều khách hàng sử dụng, đa dạng về ngành nghề lĩnh vực như TP Bank, Home Credit, Tiki, EVN, Sendo (FPT.AI, 2022).

### Thử nghiệm với tài liệu tại Học viện Ngân hàng

#### Thu thập tài liệu

Tác giả chọn lọc từ 150 email cá nhân gần nhất có địa chỉ gửi đến từ các đơn vị của Học viện, trích chọn ra những email có tệp đính kèm là các file pdf. Những file này được chọn lọc để đảm bảo đa dạng về nguồn gốc (Học viện ban hành, cơ quan khác ban hành), về định dạng (scan từ máy quét ra hình ảnh, chuyển đổi từ văn bản MS Word), về thể loại (quyết định, phiếu trình, nghị định, thông báo...). Chi tiết số liệu thống kê về bộ tài liệu thử nghiệm được trình bày trong Bảng 1.

#### Cài đặt giải pháp

Giải pháp OCR của FPT.AI được truy cập trên nền tảng điện toán đám mây tại địa https:// reader.fpt.ai/. Để tạo ứng dụng mới, FPT.AI Reader cho phép ta chọn trong thư viện những mẫu văn bản có sẵn hoặc tạo ứng dụng tùy chỉnh. Trong thư viện các văn bản có sẵn đã bao gồm:

  * Giấy tờ tài chính ngân hàng (như Báo cáo tài chính, Đăng ký kinh doanh...);

  * Giấy tờ bảo hiểm và bệnh viện (Giấy ra viện, Phiếu khám, Bảng kê viện phí...);

  * Giấy tờ quốc tế (Giấy đăng ký xe, Bằng lái xe của một số nước);

  * Giấy tờ tùy thân Việt Nam;

  * Giấy tờ khác (Sơ yếu lý lịch, Giấy tờ vận tải, Giấy chứng nhận, Vé máy bay).


Nhận thấy các mẫu văn bản có sẵn trong thư viện không phù hợp với các văn bản trong bộ dữ liệu thử nghiệm, tác giả lựa chọn cài đặt ứng dụng tùy chỉnh. Có 3 mô hình có thể lựa chọn là Bóc tách dữ liệu (từ văn bản có cấu trúc), Mô hình Crop (phát hiện vùng ảnh cần quan tâm) và Phân loại (Gán nhãn phù hợp cho văn bản), tác giả chọn mô hình Bóc tách dữ liệu và sử dụng mô hình Bóc tách dữ liệu OCR có sẵn của FPT.AI chứ không huấn luyện mô hình mới, công việc này sẽ dành cho nghiên cứu trong tương lai với lượng dữ liệu chuẩn bị nhiều và đa dạng hơn.

Trong phần sử dụng mô hình, ta chọn Tải lên để tải văn bản muốn bóc tách, có thể chọn nhiều văn bản cùng lúc, đợi đến khi trạng thái của tất cả văn bản hiện “Thành công” để xem kết quả (minh họa ở Hình 6). Để xem kết quả chi tiết của mỗi tài liệu, ta chọn View ở phần OCR. Một cửa sổ khác sẽ hiện lên hiển thị toàn bộ các trường dữ liệu bóc tách được từ văn bản đầu vào (Hình 7). Trong cửa sổ này ta có thể xem được chi tiết mô hình đã phát hiện được bao nhiêu “box” (vùng ảnh) chứa chuỗi ký tự có thể là văn bản. Click vào chi tiết mỗi box, ta có thể đánh dấu giá trị văn bản phát hiện được trong đó là sai hay đúng, thuộc loại nào (trong trường hợp này chưa định nghĩa loại box nên không hiển thị).

####  Phương pháp đánh giá

Với kết quả nhận được từ ứng dụng vừa xây dựng, tác giả đánh giá bằng cả phương pháp định lượng và định tính theo các tiêu chí sau:

Số box phát hiện được có đúng không (có bỏ sót hay phát hiện thừa vùng ảnh nào hay không).

Tỷ lệ sai số theo đơn vị từng từ ở mỗi box (chẳng hạn mô hình dự đoán “Học viện Ngan hàng” so với kết quả đúng là “Học viện Ngân hàng” thì sai số là 25%). Do số lượng từ là quá lớn nên tác giả chỉ thống kê trên trang đầu của mỗi văn bản để kiểm tra những thông tin quan trọng nhất.

Phân tích các trường hợp sai thường gặp theo từng loại văn bản.

#### Kết quả thực nghiệm

Với các tiêu chí kể trên, mô hình của FPT.

AI Reader cho kết quả rất tốt. Cụ thể:

Số box phát hiện được có độ chính xác 98%, không bỏ sót box nào trên các tài liệu. Tuy nhiên một số box bị thừa, đặc biệt là các box ở vùng ảnh chứa con dấu đỏ.

Tỷ lệ sai số khá ấn tượng: 27% với 210 từ bị sai trên tổng số 781 từ (chỉ tính những trang đầu của 20 tài liệu).

Các lỗi sai thường gặp chủ yếu là lỗi dấu câu (“Hoc”- “Học”, “Xã hồi”- “Xã hội”...), viết hoa (“đơn VI”- “đơn vị”), và các số quyết định trên phần đầu của văn bản (do là số viết tay).

Các văn bản được chuyển đổi từ file MS Word có tỷ lệ sai số thấp hơn hẳn (trong thực tế những file này có thể chuyển đổi trực tiếp về lại dạng văn bản với các thư viện lập trình phù hợp).

Các trường thông tin quan trọng như đơn vị ban hành văn bản, loại văn bản (thông báo, nghị định, quyết định...), chủ đề phụ của văn bản (về việc điều động, về việc tổ chức...) và đối tượng nhận văn bản có tỷ lệ sai số thấp hơn trung bình chỉ 16%.

Thời gian xử lý của mô hình FPT.AI Reader cũng tương đối nhanh, theo quan sát thực tế, mỗi văn bản 3 trang tốn khoảng trên dưới 5 giây để hoàn thành. Trong thực tế, số trang và dung lượng của văn bản có thể đa dạng và lớn hơn, nhưng để đáp ứng nhu cầu số hóa cơ bản, tức là bóc tách được các trường thông tin quan trọng (thường nằm ở trang đầu văn bản) thì có thể có biện pháp tiền xử lý trước khi đưa vào mô hình.

##  Kết luận và hướng phát triển

### Kết luận

Trong bài báo này, tác giả đã nêu tầm quan trọng của việc số hóa dữ liệu, khảo sát sơ bộ thực trạng số hóa tài liệu văn bản tại Học viện Ngân hàng. Qua đó tác giả đặt ra 4 mục tiêu nghiên cứu và đã giải quyết lần lượt từng mục tiêu. Có thể tóm tắt một số đóng góp chính của bài báo như sau:

Giới thiệu các công nghệ cốt lõi như nhận dạng ký tự quang học (OCR), nhận dạng dấu quang học (OMR), xử lý văn bản thông minh (IDP) và những ứng dụng trên nhiều lĩnh vực của các công nghệ này.

Tìm hiểu và khảo sát một số giải pháp thương mại cho số hóa tài liệu phổ biến ở Việt Nam như FPT.AI Reader, ViettelOCR, Google Vision AI. Trên cơ sở đó tác giả so sánh đánh giá và lựa chọn FPT.AI Reader để cài đặt ứng dụng thử nghiệm tại Học viện Ngân hàng.

Thu thập dữ liệu văn bản từ 150 email nội bộ của Học viện, chọn lọc 20 file pdf đính kèm trong các email đó sao cho đảm bảo có các loại văn bản khác nhau, các định dạng khác nhau và các phòng ban phụ trách khác nhau.

Cài đặt thử nghiệm hệ thống OCR trên nền tảng FPT.AI Reader để áp dụng với bộ dữ liệu văn bản vừa thu thập. Kết quả thử nghiệm cho thấy mô hình nhận dạng ký tự của FPT.AI hoạt động khá tốt với 27% sai số ở mức từ và thời gian xử lý chỉ khoảng 5 giây cho mỗi văn bản 3 trang, chỉ tồn tại một vài sai số ở những ký tự viết tay hoặc bị mờ do chất lượng scan tài liệu.

### Hướng phát triển

Với kết quả thử nghiệm trình bày như trên, tác giả đề xuất Học viện Ngân hàng đẩy mạnh áp dụng các công nghệ mới cho quá trình số hóa dữ liệu, đặc biệt là dữ liệu văn bản. Giải pháp của FPT.AI tuy còn một số tồn tại, sai số, nhưng có thể được cải thiện bằng cách huấn luyện hoặc tinh chỉnh mô hình OCR với bộ dữ liệu đầy đủ và đa dạng hơn của Học viện. Điều này sẽ cần các nghiên cứu chuyên sâu về công nghệ OCR trong tương lai. ■

# TÀI LIỆU THAM KHẢO

Akabot (2022), Sự khác biệt giữa OCR và IDP, Truy cập ngày 20 tháng 4 năm 2023, từ https://akabot.com/vi/tai-nguyen/ blog/su-khac-biet-giua-ocr-va-idp/

ALS (2021), Quy trình các bước số hóa tài liệu lưu trữ doanh nghiệp, Truy cập ngày 20 tháng 4 năm 2023, từ https://als. com.vn/quy-trinh-cac-buoc-so-hoa-tai-lieu-luu-tru-doanh-nghiep

Duc Phan Van Hoai, Huu-Thanh Duong, Vinh Truong Hoang (2021), “Text recognition for Vietnamese identity card based on deep features network”, International Journal on Document Analysis and Recognition (IJDAR), số 24, trang 123–131.

FPT.AI (2022), FPT.AI Reader - Vietnamese Passport Recognition, Truy cập ngày 20 tháng 4 năm 2023, từ https://docs. fpt.ai/docs/en/vision/documentation/license-recognition

FPT.AI (2022), “FPT AI Read - Trích xuất dữ liệu vượt mọi giới hạn”, Truy cập ngày 20 tháng 4 năm 2023, từ https:// fpt.ai/vi/reader

FPT.AI (2022), Hướng dẫn sử dụng FPT.AI Reader - phần mềm ocr trích xuất thông tin từ ảnh chụp, Truy cập ngày 20 tháng 4 năm 2023, từ https://fpt.ai/vi/huong-dan-su-dung-fptai-reader-phan-mem-ocr-trich-xuat-thong-tin-tu-anh-chup

Geewook Kim, Teakgyu Hong, Moonbin Yim, JeongYeon Nam, Jinyoung Park, Jinyeong Yim, Wonseok Hwang, Sangdoo Yun, Dongyoon Han, Seunghyun Park (2022), “OCR-Free Document Understanding Transformer”, Computer Vision – ECCV, số 13688, trang 498–517.

Học viện Ngân hàng (2023), Tờ trình số 694/TTr-HVNH ngày 28/3/2023 Kế hoạch Chuyển đổi số tại Học viện Ngân hàng. Krisana Chinnasarn, Yuttapong Rangsanseri (1999), “Image-processing-oriented optical mark reader”. Applications of Digital Image Processing XXII, số 3808.

Noman Islam, Zeeshan Islam,Nazia Noor (2016), “A Survey on Optical Character Recognition System”, Journal of Information & Communication Technology-JICT, số 10, trang 1-4

Phạm Huy Giao (2020), “Chuyển đổi số: Bản chất, thực tiễn và ứng dụng”, Tạp chí Dầu khí, số 12, trang 12-16. Phan Thi Thanh Nga, Nguyễn Thị Huyền Trang, Nguyễn Văn Phúc, Thái Duy Quý, Võ Phương Bình (2017), “Vietnamese

text extraction from book covers”. Tạp chí Khoa học Đại học Đà Lạt”, số 7, trang 142–152.

Ravina Mithe, Supriya Indalkar, Nilam Divekar (2013), “Optical Character Recognition”, International Journal of Recent Technology and Engineering (IJRTE), số 2, trang 72-75.

Raymond Ptucha, Felipe Petroski Such, Suhas Pillai, Frank Brockler, Vatsala Singh, Paul Hutkowski (2019), “Intelligent character recognition using fully convolutional neural networks”, Pattern Recognition, số 88, trang 604-613.

Thủ tướng Chính phủ (2022), Quyết định số 131/QĐ-TTg ngày 25/01/2022 của Thủ tướng Chính phủ: Phê duyệt Đề án “Tăng cường ứng dụng công nghệ thông tin và chuyển đổi số trong giáo dục và đào tạo giai đoạn 2022-2025, định hướng đến năm 2030”

Trần Thị Hương, Ngô Thị Kiều Hằng (2021), “Kỹ thuật nhận dạng biển số xe và ứng dụng vào bài toán quản lý bãi giữ xe tại trường đại học Hà Tĩnh”. Tạp chí Khoa học Đại học Đồng Tháp, số 3, trang 115-120.

Viettel AI (2021), “Nhận dạng ký tự quang học”, Truy cập ngày 20 tháng 4 năm 2023, từ https://viettelgroup.ai/service/ocr

Vu Xuan-Son, Bui Quang-Anh, Nguyen Nhu-Van, Hai Nguyen Thi Tuyet, Vu Thanh (2021), “MC-OCR Challenge:

Mobile-Captured Image Document Recognition for Vietnamese Receipts”, RIVF International Conference on Computing and Communication Technologies, IEEE, trang 1-6.

# Public_006

# Nội dung chính

## Giới thiệu

“Trong bối cảnh cách mạng công nghệp 4.0, các trường đại học trên thế giới đã nắm bắt và chuyển đổi số” [1] các hoạt động của mình. Điều đó “đặt ra yêu cầu… phải thay đổi theo mô hình quản trị đại học tiên tiến” [2]. “Mô hình này phù hợp với xu hướng tự chủ cao trong tổ chức bộ máy và điều hành”. Theo đó, các trường đại học Việt Nam “cần phát huy tinh thần chủ động, đổi mới, sáng tạo” [3]. Đổi mới cấu trúc, bộ máy quản trị [4], ứng dụng công nghệ trong quản trị để tối đa hoá hiệu quả hoạt động nhà trường [5]. Tăng cường ứng dụng công nghệ thông tin nâng cao chất lượng dạy, học, chuyển giao khoa học - công nghệ [6]; chuyển đổi số trong quản lý, điều hành, hỗ trợ ra quyết định nhanh, chính xác [7]. Nhờ đó, các trường đại học Việt Nam đã chuyển từ thế bị động sang thế chủ động ứng dụng công nghệ trong nhà trường và đạt nhiều thành tựu trong các mặt công tác [8]-[11]. Như vậy, hiện có nhiều công trình đề cập đến một khía cạnh nào đó của vấn đề nghiên cứu. Bài báo này tập trung làm rõ nội dung, thực trạng, giải pháp ứng dụng công nghệ số trong quản trị đại học nhằm tận dụng tối đa cơ hội thời đại số, nâng cao vị thế, vai trò đại học Việt Nam hiện nay.

## Phương pháp nghiên cứu

Để hoàn thành mục tiêu nghiên cứu, tác giả sử dụng các phương pháp nghiên cứu chủ yếu như: phương pháp tổng hợp, phân tích và xử lý số liệu thông qua các tư liệu, số liệu thứ cấp để hệ thống hoá những nội dung lý luận liên quan, phân tích thực trạng và đề xuất các giải pháp ứng dụng công nghệ số trong công tác quản trị đại học nhằm thúc đẩy quá trình xây dựng đại học số ở Việt Nam hiện nay.

## Kết quả và bàn luận

### Một số vấn đề về ứng dụng công nghệ số trong quản trị đại học ở Việt Nam

#### Quan niệm về quản trị đại học và công nghệ số

Công tác quản trị có vai trò quan trọng, quyết định sự thành công của cơ quan, tổ chức. Quản trị tốt sẽ tạo ra hệ thống các thiết chế, nguyên tắc quản lý, điều hành tốt bộ máy, sự phối hợp hiệu quả các nguồn lực tổ chức để đạt mục tiêu phát triển. Ở trường đại học, nơi nguồn vốn đặc trưng là con người, với sản phẩm quan trọng là nhân lực, tri thức khoa học, công nghệ... thì công tác quản trị càng trở nên quan trọng. Quản trị khoa học, hiệu quả sẽ khơi dậy tiềm năng, khuyến khích các chủ thể phát triển, tạo ra và phát huy hiệu quả các nguồn lực của nhà trường. Đó là bí quyết, là lợi thế cạnh tranh của các trường đại học trong bối cảnh hiện nay. Quản trị yếu kém sẽ hủy hoại giá trị, môi trường làm việc, kìm hãm sự phát triển của nhà trường.

Trên cơ sở kế thừa các quan niệm về quản trị đại học, có thể khái quát: Công tác quản trị đại học là một hệ thống được thiết lập và thực hiện trong các nhà trường phù hợp với sự phát triển kinh tế - xã hội. Đó là quá trình “hoạch định, tổ chức, điều khiển và kiểm soát cũng như những nỗ lực khai thác mọi tài nguyên để hoàn thành các mục tiêu đã định của nhà trường một cách có hiệu quả” [2, tr.68]. Nó dựa trên nguyên lý đảm bảo các trường đại học thực hiện thành công sứ mệnh đã cam kết, đảm bảo hiệu quả các hoạt động, đáp ứng tốt nhất yêu cầu của các chủ thể liên quan. Trong đó, các nguyên lý quản trị thực hiện theo quy trình hoặc dựa vào kết quả đầu ra với tiêu chí cụ thể để các bên liên quan giám sát hoạt động của nhà trường. Bên cạnh đó, công tác này cũng phải tuân theo các nguyên tắc mang tính bắt buộc do cơ quan quản lý nhà nước, cơ quan chủ sở hữu ban hành, đảm bảo sự minh bạch, công bằng trong công tác lãnh đạo, quản lý, điều hành hoạt động của trường đại học.

Tại Việt Nam, Luật số 34/2018 - Luật Giáo dục đại học sửa đổi và bổ sung; Nghị định số 99/2019 đã quy định rõ nhiệm vụ, quyền hạn của các thiết chế quản trị, quản lý cơ sở giáo dục đại học. Theo đó, Hội đồng trường là cơ quan có thẩm quyền cao nhất, có quyền quyết định các vấn đề lớn, các quy định nội bộ chủ yếu, các vị trí quan trọng của cơ sở giáo dục đại học. Chủ tịch Hội đồng trường là người đứng đầu cơ quan có thẩm quyền cao nhất. Hiệu trưởng là người đứng đầu bộ máy hành chính, có trọng trách rất lớn của nhà trường, đại diện lãnh đạo, quản lý, điều hành cấp trường, cùng Ban Giám hiệu với các đơn vị chức năng tham mưu giúp việc thực hiện chức trách, nhiệm vụ dưới sự lãnh đạo của Đảng ủy, Hội đồng trường. Đây là lĩnh vực hành chính chủ yếu và chiếm tỉ trọng khối lượng công việc nhiều nhất trong nhà trường.

Trong bối cảnh cách mạng công nghiệp 4.0, để công tác quản trị tại các trường đại học hiệu quả cao thì một trong những vấn đề quan trọng là tìm ra phương thức quản trị phù hợp. Chuyển đổi số, ứng dụng công nghệ số trong quản trị đại học được coi là phương thức hữu hiệu. Công nghệ số là quá trình thay đổi tổng thể và toàn diện trong cách thức vận hành, tổ chức của một cơ quan, đơn vị dựa trên những thành tựu công nghệ mới như Internet vạn vật, trí tuệ nhân tạo, thực tế ảo, tương tác thực tại ảo, điện toán đám mây, phân tích dữ liệu lớn… Đó là quá trình chuyển đổi toàn diện các hoạt động của con người từ không gian thực lên không gian số để tạo ra phương thức hoạt động mới, cơ hội mới và giá trị mới, tối ưu hóa quy trình, hoạt động của tổ chức cơ quan, đơn vị. Ứng dụng công nghệ số trong công tác quản trị đại học hiệu quả sẽ góp phần nâng cao chất lượng, hiệu quả công tác quản lý, điều hành, nâng cao vị thế, vai trò của trường đại học trong bối cảnh mới.

#### Ứng dụng công nghệ số trong quản trị đại học ở Việt Nam hiện nay

Trong lĩnh vực giáo dục - đào tạo, công nghệ số được ứng dụng mạnh mẽ và có nhiều tác động tích cực. Tận dụng cơ hội chuyển đổi số mang lại, các đại học Việt Nam phải thực hiện rất khẩn trương việc ứng dụng công nghệ số, nhất là trong công tác quản trị. Đó là việc sử dụng thành tựu công nghệ số vào quá trình hoạch định, tổ chức, điều khiển và kiểm soát cũng như những nỗ lực khai thác mọi tài nguyên, nâng cao chất lượng và hiệu quả việc tổ chức phối hợp giữa các đơn vị, các hoạt động của nhà trường để hoàn thành các mục tiêu đã định.

Ứng dụng công nghệ số vào hoạt động quản trị đại học cho phép các nhà quản trị bao quát toàn bộ hoạt động của nhà trường kịp thời, nắm bắt đầy đủ, chính xác, chi tiết thông tin đối tượng quản lý ở mọi thời điểm; tiết kiệm thời gian, nhân lực, vật lực, giảm thiểu phiền hà, hỗ trợ tối đa hoạt động quản trị nhà trường; giúp quản lý, khai thác, phân tích dữ liệu thuận tiện, chính xác. Từ đó, giúp lãnh đạo, quản lý ra quyết sách lãnh đạo, điều hành phù hợp, hiệu quả.

Xuất phát từ yêu cầu hiện đại hóa, tối ưu hoá tổ chức và hoạt động, các trường đại học chú trọng việc ứng dụng công nghệ số vào quản lý, điều hành. Việc ứng dụng này tập trung vào những nội dung cơ bản sau:

  * Ứng dụng công nghệ số trong quản lý, điều hành công tác hành chính như: Số hóa văn bản, hồ sơ, điểm học tập, rèn luyện của sinh viên; chương trình đào tạo; học liệu;...

  * Ứng dụng công nghệ số trong quản lý, khai thác và sử dụng hiệu quả các nguồn lực: Cơ sở vật chất, con người (cán bộ, giảng viên, học viên, sinh viên) và các nguồn lực khác.

  * Ứng dụng công nghệ số trong quản lý đánh giá chất lượng công việc của cán bộ, giảng viên, người lao động trong nhà trường.

  * Ứng dụng công nghệ số trong công tác tuyển sinh, xây dựng hệ thống tuyển sinh số.

  * Ứng dụng công nghệ số trong quản lý, điều hành hoạt động giảng dạy; quản lý, khai thác các thông tin phục vụ hoạt động giảng dạy; đánh giá chất lượng giảng dạy của giảng viên.

  * Ứng dụng công nghệ số trong quản lý, điều hành hoạt động học tập của học viên, sinh viên.

  * Ứng dụng công nghệ số trong quản lý, điều hành nghiên cứu, chuyển giao khoa học - công nghệ; đăng ký, cấp mã số các đề tài nghiên cứu; quản lý đầu ra sản phẩm nghiên cứu khoa học và bảo vệ quyền sở hữu trí tuệ...

  * Ứng dụng công nghệ số trong quản lý, hỗ trợ sinh viên tìm kiếm việc làm; quản lý, đánh giá chất lượng sản phẩm đầu ra của quá trình đào tạo, giúp nhà quản lý điều chỉnh hoạt động, tạo sự liên kết giữa nhà trường - doanh nghiệp - sinh viên; đổi mới chương trình đào tạo, cập nhật công nghệ hiện đại, đào tạo, cung ứng nguồn nhân lực chất lượng theo thị trường.


Như vậy, ứng dụng công nghệ số trong công tác quản trị đại học là xu thế tất yếu và có nội dung bao trùm các hoạt động của nhà trường. Thực hiện tốt giải pháp này giúp các trường đại học

Việt Nam tổ chức, phối hợp giữa các đơn vị thuộc nhà trường hiệu quả hơn, triển khai các hoạt động trên nền tảng số hướng tới xây dựng đại học số, phù hợp với xu thế phát triển đại học.

### Thực trạng ứng dụng công nghệ số trong công tác quản trị tại các trường đại học ở Việt Nam hiện nay

#### Những kết quả đạt được

Thực hiện sự lãnh đạo của Đảng, Nhà nước, việc ứng dụng công nghệ số trong ngành giáo dục đào tạo đã có những thành tựu bước đầu. Đến nay, “toàn ngành đã triển khai số hóa, xây dựng cơ sở dữ liệu dùng chung từ Trung ương đến 63 sở Giáo dục và Đào tạo, 710 phòng và khoảng 53.000 cơ sở giáo dục. Hiện nay đã số hóa và định danh dữ liệu của khoảng 53.000 trường học, 1,4 triệu giáo viên, 23 triệu học sinh. Cơ sở dữ liệu này đã hỗ trợ đắc lực công tác tuyển sinh, thống kê, báo cáo trong toàn ngành; giúp các cấp quản lý ban hành chính sách quản lý hiệu quả, vừa qua đã góp phần giải quyết vấn đề thừa thiếu giáo viên ở các nhà trường theo từng địa phương, môn học… Hệ thống quản lý hành chính điện tử kết nối 63 sở Giáo dục và Đào tạo và hơn 300 trường đại học, cao đẳng trên cả nước với Bộ Giáo dục và Đào tạo hoạt động thông suốt, ổn định, phát huy hiệu quả tích cực” [7].

Trong công tác quản trị đại học, ứng dụng công nghệ số thể hiện ngày càng rõ với việc thực hiện các giải pháp tổ chức, quản lý, điều hành giáo dục trực tuyến; đầu tư phát triển chương trình ứng dụng công nghệ số trong quản lý, giảng dạy, thực hành cho sinh viên, nghiên cứu chuyển giao công nghệ phần mềm… Nhiều trường đã chủ động ứng dụng công nghệ số hiệu quả như: Tại các trường Đại học thành viên của Đại học Thái Nguyên hiện nay đã số hóa khoảng 90% giáo trình giảng dạy, 100% các luận văn, luận án, 40% tài liệu tham khảo; toàn đại học cũng đã xây dựng được hơn 110 bài giảng điện tử. Nhiều hình thức học tập hiện đại như học trực tuyến, từ xa... được thực hiện [8]; Đại học Bách khoa Hà Nội chính thức ra mắt và đưa vào sử dụng Hệ thống quản trị đại học trực tuyến https://e.hust.edu.vn (1 cổng) và app eHUST từ ngày 22/9/2021. Sinh viên và giảng viên có thể truy cập, thực hiện các tác vụ giúp cho công việc, nghiệp vụ giảng dạy; hoạt động học tập, các thủ tục hành chính thuận tiện và hiệu quả hơn [9]. Học viện Công nghệ Bưu chính Viễn thông, 1 trong 5 trường được lựa chọn thực hiện Đề án thí điểm triển khai mô hình đại học số đã đề xuất và vận hành Dịch vụ số, Quản trị số và Xã hội số “make in Việt Nam” [10]... Như vậy, ứng dụng công nghệ số là giải pháp hiệu quả tăng cường nội lực, tính chủ động và góp phần hiện đại hóa giáo dục đại học.

Về hạ tầng công nghệ, phần lớn các trường đại học ở Việt Nam được đầu tư trang bị, nhất là khi phải chuyển sang ứng phó với đại dịch Covid-19 bùng phát. “Đến nay, khoảng 110/240 cơ sở giáo dục đại học đã triển khai đào tạo trực tuyến, với các cấp độ khác nhau. Do đặc thù, nhiều trường thuộc khối văn hóa nghệ thuật chưa tổ chức đào tạo trực tuyến và 33 trường thuộc nhóm quốc phòng - an ninh đang đào tạo tập trung” [11]. Như vậy, các trường đại học đã chủ động về hạ tầng công nghệ, đồng thời còn có sự đồng hành của 11 tập đoàn ICT tham gia hỗ trợ về hạ tầng, giải pháp phần mềm và cước truy cập Internet…

Về mức độ ứng dụng công nghệ số trong quản trị tại các trường đại học ở Việt Nam hiện nay chủ yếu ở các phương diện sau:

Một là, các trường đại học đã triển khai hệ thống thông tin quản lý giáo dục - đào tạo đáp ứng yêu cầu kết nối, liên thông tích hợp, chia sẻ thông tin đối với các đơn vị trực thuộc. Việc này thực hiện chủ yếu trên trang thông tin điện tử, Website của nhà trường. Các văn bản “không mật” được điện tử hóa, công khai trên không gian mạng, giúp các đơn vị trong nhà trường cập nhật thường xuyên, kịp thời, có hệ thống, rút ngắn thời gian xử lý, nâng cao chất lượng chuyên môn, đảm bảo công việc thông suốt, hiệu quả, cung cấp dịch vụ hành chính văn phòng không giấy mọi lúc, mọi nơi tạo sự thuận tiện và hướng tới minh bạch trong công tác quản lý, điều hành.

Hai là, triển khai hệ thống quản lý hành chính điện tử. Trong công tác quản trị văn phòng, từ việc đăng ký văn phòng phẩm, lịch công tác, lên lịch các cuộc họp... đến các tiện ích văn phòng khác được ứng dụng công nghệ thông tin để quản lý. Nhờ đó, công tác hành chính thực hiện kịp thời, hiệu quả. Trong công tác tài chính, các nhà trường đã phối hợp với các đối tác xây dựng hệ thống thanh toán điện tử đã giúp cán bộ, học viên, sinh viên tiết kiệm thời gian, công sức, đảm bảo độ chính xác; trong công tác hội, họp, hội thảo, tập huấn chuyên môn được tổ chức qua mạng, sử dụng ứng dụng trực tuyến, kết nối đa điểm với các giải pháp đảm bảo an toàn thông tin, mã hoá bảo mật. Đây là những giải pháp quan trọng giúp cấp quản lý, điều hành, xử lý công việc mọi lúc, mọi nơi; thông tin nhanh chóng, kịp thời, ra quyết định chính xác. Cán bộ, giảng viên, người học dễ tiếp cận văn bản, tài liệu số hóa phục vụ công việc đảm bảo chất lượng, tiến độ.

Ba là, ứng dụng công nghệ số trong công tác quản lý, điều hành công tác tuyển sinh - tuyển sinh số là phương thức chủ đạo của các trường đại học hiện nay. Nhiều trường đại học hiện có cổng thông tin tuyển sinh, trang thông tin tuyển sinh, hệ thống tuyển sinh tự động… cung cấp đầy đủ thông tin về công tác tuyển sinh, chế độ chính sách, giới thiệu về môi trường, điều kiện học tập và rèn luyện, cơ hội việc làm, cơ hội phát triển năng lực bản thân, liên kết doanh nghiệp, phương thức nộp hồ sơ… giúp học sinh, phụ huynh dễ dàng tra cứu, tìm hiểu, lựa chọn, đăng ký ngành nghề phù hợp năng lực, sở trường, điều kiện kinh tế. Công tác kế hoạch, tuyển sinh, mở lớp, thi cử, hồ sơ tuyển sinh… được giải quyết trực tuyến nhanh, tiện lợi, chính xác.

Bốn là, thực hiện quản lý giảng viên, người học; quản lý thi, thời khóa biểu, sổ quản lý điện tử; tích hợp với trang tin điện tử của nhà trường trên môi trường mạng. Chương trình phục vụ hoạt động quản lý đào tạo đã được xây dựng thành những sản phẩm phần mềm đóng gói, cài trên từng máy tính riêng lẻ hoặc được thiết kế, xây dựng theo mô hình quản lý dữ liệu phân tán có sự phân cấp. Với mô hình này, dữ liệu quản lý được xử lý trên máy chủ nên thông tin về công tác quản lý sinh viên công khai, minh bạch, cụ thể, được chia sẻ trên mạng nội bộ của trường.

Như vậy, nhiều trường đại học đã bước đầu hiện thực hóa mục tiêu đề ra trong Đề án “Tăng cường ứng dụng công nghệ thông tin trong quản lý và hỗ trợ các hoạt động dạy - học, nghiên cứu khoa học góp phần nâng cao chất lượng giáo dục và đào tạo giai đoạn 2016-2020, định hướng đến năm 2025” là: 100% các cơ quan quản lý nhà nước về giáo dục và đào tạo, các cơ sở giáo dục và đào tạo thực hiện quản lý hành chính xử lý hồ sơ công việc trên môi trường mạng; 70% cuộc họp giữa các cơ quan quản lý nhà nước và cơ sở giáo dục và đào tạo được áp dụng hình thức trực tuyến; 70% lớp bồi dưỡng chuyên môn cho giáo viên và cán bộ quản lý giáo dục được thực hiện qua mạng theo phương thức học tập kết hợp; 50% hồ sơ thủ tục hành chính được xử lý trực tuyến tối thiểu mức độ 3, trong đó 30% được xử lý trực tuyến ở mức độ 4.

#### Một số hạn chế

Bên cạnh những kết quả đạt được, việc ứng dụng công nghệ số trong công tác quản trị tại các trường đại học còn nhiều hạn chế. Nghiên cứu thực trạng ứng dụng công nghệ số trong công tác quản trị các trường đại học ở Việt Nam hiện nay, có thể nhận thấy những hạn chế cơ bản như sau:

Một là, về thủ tục hành chính, một số khâu vẫn còn thực hiện bằng phương pháp thủ công, việc số hóa chưa đồng bộ. Việc quản lý văn bản, tiếp nhận, chuyển phát thông tin, báo cáo; quản lý cán bộ giảng viên, cập nhật cơ sở dữ liệu; kiểm soát, theo dõi việc thực hiện các quyết định quản lý, điều hành của cấp trên thực hiện chủ yếu bằng tập hợp và lưu trữ bằng văn bản giấy. Điều này làm mất nhiều thời gian, công sức của lực lượng làm công tác hành chính.

Hai là, vấn đề an toàn thông tin đảm bảo thông tin nhân thân và bản quyền thông tin chưa được coi trọng đúng mức. Thu thập, chia sẻ, khai thác dữ liệu quản lý giáo dục và học liệu số cần hành lang pháp lý chung phù hợp với các quy định về bản quyền tác giả, sở hữu trí tuệ, an ninh thông tin, giao dịch điện tử và luật chia sẻ cung cấp thông tin.

Ba là, chất lượng công tác dự báo còn hạn chế bởi ứng dụng công nghệ như: Big data, AI, Blockchain trong các trường đại học chưa thực sự hiệu quả.

Bốn là, kỹ năng ứng dụng công nghệ số của đội ngũ cán bộ quản lý, hành chính chưa cao và không đồng đều. Mặc dù, trong những năm qua, đội ngũ cán bộ quản lý, hành chính, giảng viên đã tích cực triển khai, ứng dụng công nghệ số trong các hoạt động.

### Một số giải pháp ứng dụng công nghệ số trong công tác quản trị tại các trường đại học ở Việt Nam hiện nay

Đẩy mạnh ứng dụng công nghệ số trong công tác quản trị, hỗ trợ công tác quản trị trở nên toàn diện hơn, khoa học hơn, minh bạch trong bối cảnh cuộc cách mạng công nghiệp 4.0 là tất yếu. Trong đó, tăng cường ứng dụng công nghệ số trong công tác quản trị đại học sẽ góp phần nâng cao năng lực cạnh tranh, uy tín của các trường trên thị trường giáo dục, giúp sinh viên có tăng cơ hội tìm kiếm việc làm, doanh nghiệp có thêm nguồn nhân lực chất lượng cao. Để thực hiện tốt nhiệm vụ này, các trường đại học cần làm tốt các giải pháp sau:

Một là, nâng cao nhận thức của các chủ thể quản trị, nhất là lãnh đạo các trường đại học về tầm quan trọng và quyết tâm ứng dụng công nghệ số trong công tác quản trị đại học. Đó là nhân tố quyết định việc ứng dụng công nghệ số, thúc đẩy chuyển đổi số trong công tác quản trị tại các trường đại học hướng tới xây dựng đại học số đáp ứng yêu cầu phát triển của xã hội. Từ nhận thức đúng đắn, các chủ thể lãnh đạo, quản lý đại học sẽ đề ra các chủ trương và giải pháp tận dụng tối đa hiệu quả thành tựu công nghệ số, tận dụng cơ hội, đồng thời vượt qua các thách thức của thời đại số trong việc thực hiện sứ mệnh của trường đại học.

Hai là, các trường đại học cần chủ động huy động và sử dụng hiệu quả nguồn ngân sách trong và ngoài nhà trường, tập trung xây dựng hệ thống thông tin kết nối liên thông giữa trường đại học với các tổ chức chính trị - xã hội trong, ngoài nước và với doanh nghiệp. Bởi, triển khai ứng dụng công nghệ số trong quản trị tại các trường đại học đòi hỏi nguồn lực đầu tư lớn nên ngoài việc chủ động, các trường cần phải phát huy năng lực hợp tác với các tổ chức, doanh nghiệp để huy động tối đa nguồn lực nhất là nguồn lực tài chính và hạ tầng công nghệ. Triển khai các hoạt động trong môi trường số thành công, các trường đại học phải dựa trên nền tảng cơ sở hạ tầng hiện đại, có khả năng mở rộng và cập nhật công nghệ mới, công nghệ thông minh cần được tích hợp… Các nền tảng này được kết nối, liên thông với nhau dựa trên công nghệ truyền thông điện toán đám mây hiện đại với những giao thức như: Wifi, viễn thông (5G/4G), mạng Internet nội bộ để hướng tới xây dựng môi trường IoT và tính toán đám mây hiện đại. Khi đó, nó sẽ tạo điều kiện cho việc chia sẻ, thống nhất các cơ sở dữ liệu phục vụ công tác quản trị trong nhà trường, tạo điều kiện cho việc phân tích dữ liệu lớn hỗ trợ Ban Lãnh đạo nhà trường có cái nhìn tổng quát. Thực hiện tốt giải pháp này cần phải có cơ chế, chính sách cho sự hợp tác giữa các trường đại học và các tổ chức, doanh nghiệp.

Ba là, xây dựng chế độ, chính sách đối với nhân lực công nghệ số để thu hút được nhân lực có chất lượng làm việc cho các trường đại học, khuyến khích họ gắn bó, làm việc lâu dài. Nhà nước và các trường đại học cần có chính sách, chế độ ưu đãi về thu nhập, các ưu đãi khác như: học tập, hội nghị, hội thảo trong và ngoài nước, tham gia các đề tài, dự án…

Bốn là, tăng cường hợp tác quốc tế, tranh thủ sự giúp đỡ của các nước trong việc củng cố hạ tầng công nghệ số, nguồn lực công nghệ số cũng như công tác đào tạo, bồi dưỡng nhân lực công nghệ số chất lượng cao.

Năm là, xây dựng, triển khai hiệu quả các dịch vụ số trong công tác quản lý, điều hành nhà trường. Trên nền tảng liên thông toàn bộ dữ liệu, các dịch vụ lõi hỗ trợ hiệu quả công tác quản lý, điều hành cơ bản trong nhà trường phải được xây dựng, triển khai như: Hệ thống quản lý nhân sự: quản lý thông tin hồ sơ nhân lực hỗ trợ Lãnh đạo các cấp ra quyết định, bố trí, sắp xếp công tác nhân sự; hệ thống quản lý tài chính: quản lý công tác tài chính kế toán, hỗ trợ Ban lãnh đạo các cấp ra quyết định, phê duyệt kinh phí hoạt động; hệ thống quản lý cơ sở vật chất: quản lý cơ sở vật chất góp phần xác định hiện trạng sử dụng và nhu cầu trang cấp cho các nhu cầu sử dụng cơ sở vật chất trong nhà trường; hệ thống quản lý nghiên cứu khoa học: quản lý công tác đăng ký, thực hiện các nhiệm vụ nghiên cứu khoa học; Các hệ thống quản lý đào tạo và đào tạo trực tuyến: quản lý thời khóa biểu, văn bằng, chứng chỉ, công tác giáo vụ, khảo thí và đảm bảo chất lượng đào tạo, giờ giảng, LMS/CMS,…; hệ thống tuyển sinh số: hỗ trợ công tác tuyển sinh, thống kê, đưa ra khuyến nghị phù hợp để lãnh đạo ra quyết định, phê duyệt chỉ tiêu, ngành nghề theo xu hướng xã hội; hệ thống quản lý công việc: quản lý thông tin giao việc, tiến độ, kết quả công việc, nhiệm vụ được giao cho cán bộ, giảng viên; hệ thống quản lý công tác đối ngoại: quản lý thông tin các đối tác của nhà trường, hỗ trợ đưa ra quyết sách đối ngoại cho sự phát triển mở rộng của nhà trường; hệ thống tổng hợp/hỗ trợ ra quyết định cho lãnh đạo: Kết hợp khả năng liên thông dữ liệu toàn trường và công nghệ phân tích dữ liệu lớn sẽ hỗ trợ cho các cấp lãnh đạo nhà trường ra quyết định dựa trên chức năng khuyến nghị, gợi ý của trợ lý ảo. Ngoài ra còn có các phần mềm hỗ trợ đắc lực cho các chức năng như nhắc việc, tính KPI, thi đua khen thưởng,…

Như vậy, ứng dụng công nghệ số sẽ giúp tối ưu hóa các hoạt động của nhà trường trên môi trường số khi công nghệ hóa toàn bộ tiến trình dạy và học, tự động hóa quy trình nghiệp vụ, quản lý, mở rộng đối tượng, năng lực, phạm vi giảng dạy, nâng cao chất lượng, hiệu quả đào tạo… Đây là cách thức hiệu quả để đại học phát huy vai trò phát triển kinh tế số bền vững ở Việt Nam. Tuy nhiên, ứng dụng công nghệ số trong công tác quản trị đại học đòi hỏi nguồn lực rất lớn khi tiến hành triển khai và phải thực hiện đồng bộ các giải pháp nêu trên.

## Kết luận

Trong kỷ nguyên số, ứng dụng công nghệ số trong công tác quản trị đại học là yêu cầu cấp thiết nhằm nâng cao hơn nữa chất lượng và hiệu quả công tác quản trị trong bối cảnh mới và phù hợp với quá trình chuyển đổi số hiện nay. Ứng dụng công nghệ số hiệu quả là một trong những giải pháp tăng cường nội lực, tính chủ động, góp phần hiện đại hóa giáo dục đại học, xây dựng thành công đại học số - mô hình Đại học mà toàn bộ nội dung và hoạt động của nhà trường được đưa lên môi trường số thông qua các nền tảng số và các phương tiện kỹ thuật số. Để đạt được mục tiêu này, cần sự quan tâm, chỉ đạo sát sao từ lãnh đạo cấp chiến lược và sự vào cuộc mạnh mẽ của Ban Lãnh đạo các trường đại học, của đội ngũ giảng viên, cán bộ quản lý và đội ngũ sinh viên, chủ thể của quá trình xây dựng và phát triển của các trường đại học.

# TÀI LIỆU THAM KHẢO/ REFERENCES

V. T. Phung, “Digital transformation in university governance: International and Vietnamese

experience,” In Smart Governance in a Global Complex Environment: Theory and Practice: Publishing company Ha Noi national university, 2021, pp. 451-474.

T. V. Dinh, “The change in governance approach of universities in the context of innovation start-up,”

Industry and Trade Magazine, no. 1, pp. 207-212, January 2020.

T. V. Dinh, “Research on the Model of Entrepreneurial University and Advanced University

Governance: Policy Recommendations for Public Universities in Vietnam,” VNU Journal of Science: Policy and Management Studies, vol. 37, no. 1, pp. 62-73, 2021.

H. T. T. Pham, G. H. T. Nguyen, A. M. T. Vu, and Q. N. Hoang, "Higher Education Governance - International Experience and Lessons for Vietnam," VNU Journal of Science: Education Research, vol. 35, no. 3, pp. 32-45, 2019.

S. M. Hoang, H. T. T. Bui, and G. H. T. Nguyen, “University model in the context of the industrial revolution 4.0,” Proceedings of International conference New issues in educational sciences: Inter-disciplinary and cross-disciplinary approaches, Hanoi, June 2019, pp. 37-46.

T. D. Do, “Implementing information technology in university management and scientific research to meet new requirements of the market economy,” 2020. [Online]. Available: http://hvcsnd.edu.vn/nghien-cuu-trao-doi/dai-hoc-40/ung-dung-cong-nghe-thong-tin-trong-quan-tri-dai-hoc-nham-dap-ung-yeu-cau-doi-moi-cua-nen-kinh-te-thi-truong-6231. [Accessed Dec. 28, 2022].

H. N. To, “Digital transformation in education and training: Current situation and solutions | People's Police

Academy,” 2020. [Online]. Available: http://hvcsnd.edu.vn/nghien-cuu-trao-doi/dai-hoc-40/chuyen-doi-so-trong-linh-vuc-giao-duc-va-dao-tao-thuc-trang-va-giai-phap-6886. [Accessed Dec. 29, 2022].

P. Hung and D. Son, “Digital Transformation in Universities in Thai Nguyen,” 2020. [Online]. Available: https://thainguyentv.vn/chuyen-doi-so-trong-cac-truong-dai-hoc-o-thai-nguyen-82638.html. [Accessed Feb. 17, 2023].

Hanoi university of science and Technology, “Hanoi Polytechnic promotes digital transformation,”

2022\. [Online]. Available: https://www.hust.edu.vn/tin-tuc/-/asset_publisher/AKFI5qRls1e8/content/ bach-khoa-ha-noi-day-manh-chuyen-soi-so-coi-sinh-vien-la-trung-tam. [Accessed Feb. 17, 2023].

Posts and telecommunicasions institule of Technology, “The first digital university in Vietnam: A miniature digital country,” 2020. [Online]. Available: https://portal.ptit.edu.vn/dai-hoc-so-dau-tien-tai-viet-nam-quoc- gia-so-thu-nho/. [Accessed Feb. 16, 2023].

Ministry of Education and Training, “Pioneer university to promote digital transformation of education,” 2020. [Online]. Available: https://moet.gov.vn/tintuc/Pages/phong-chong-nCoV.aspx?ItemID=6615. [Accessed Dec. 29, 2022].

# Public_007

# Nội dung tiêu chuẩn

## Phạm vi

Tài liệu này quy định các yêu cầu về chất lượng và năng lực của các phòng xét nghiệm y tế.
Tài liệu này được áp dụng cho các phòng xét nghiệm y tế trong việc phát triển hệ thống quản lý và đánh giá năng lực của họ. Tài liệu này cũng được áp dụng để xác nhận hoặc công nhận năng lực của các phòng xét nghiệm y tế bởi người sử dụng phòng xét nghiệm, cơ quan quản lý và cơ quan công nhận.
Tài liệu này cũng có thể áp dụng cho xét nghiệm tại chỗ (POCT).
CHÚ THÍCH: Các quy định hoặc yêu cầu quốc tế, quốc gia hoặc khu vực cũng có thể áp dụng cho các chủ đề cụ thể được đề cập trong tài liệu này.

## Tài liệu tham khảo

Các tài liệu sau đây được đề cập trong văn bản theo cách mà một số hoặc tất cả nội dung của chúng cấu thành các yêu cầu của tài liệu này. Đối với tài liệu ghi năm công bố thì áp dụng bản được nêu. Đối với các tài liệu tham khảo không ghi năm công bố, ấn bản mới nhất (bao gồm mọi sửa đổi) sẽ được áp dụng.
ISO / IEC Guide 99: 2007, _Từ vựng quốc tế về đo lường - Các khái niệm cơ bản và chung và các thuật ngữ liên quan (VIM)_
CHÚ THÍCH: ISO/IEC Guide 99 còn được gọi là Ủy ban hỗn hợp về hướng dẫn đo lường (JCGM) 200.
ISO/IEC 17000:2020, _Đánh giá sự phù hợp — Từ vựng và nguyên tắc chung_
ISO / IEC 17025: 2017, _Yêu cầu chung về năng lực của các phòng thử nghiệm và hiệu chuẩn_

## Thuật ngữ và định nghĩa

Đối với mục đích của tài liệu này, các thuật ngữ và định nghĩa được đưa ra trong ISO/IEC Guide 99 và ISO/IEC 17000 và những điều sau đây sẽ được áp dụng.
ISO và IEC duy trì cơ sở dữ liệu thuật ngữ để sử dụng trong tiêu chuẩn hóa tại các địa chỉ sau:

  * Nền tảng ISO trực tuyến: có sẵn tại [_https://www.iso.org/obp_](https://www.iso.org/obp)

  * IEC Electropedia: có sẵn tại [_https://wwwelectropedia.org/_](https://wwwelectropedia.org/)


### Độ chệch (bias) - ước lượng độ chệch

ước lượng sai số của hệ thống đo lường

### Khoảng tham chiếu sinh học - khoảng tham chiếu

phân bố các giá trị được lấy từ quần thể tham chiếu sinh học

CHÚ THÍCH 1: Khoảng tham chiếu thường được định nghĩa là khoảng tập trung 95%. Độ rộng hoặc giá trị trung bình của khoảng tham chiếu có thể có thể khác nhau trong các trường hợp cụ thể.

CHÚ THÍCH 2: Khoảng tham chiếu có thể phụ thuộc vào loại mẫu ban đầu (3.25) và quy trình xét nghiệm (3.9) được sử dụng.

CHÚ THÍCH 3: Trong một số trường hợp, chỉ một giới hạn quy tham sinh học là quan trọng, thường là giới hạn trên, “x”, sao cho khoảng tham chiếu sinh học tương ứng sẽ nhỏ hơn hoặc bằng “x”.

CHÚ THÍCH 4: Các thuật ngữ như: “phạm vi bình thường”, “giá trị bình thường” và “phạm vi lâm sàng” là không rõ ràng và do đó không được khuyến khích.

[NGUỒN: ISO 18113-1: 2022, 3.1.9, sửa đổi - VÍ DỤ đã bị xóa.]

### Giới hạn quyết định lâm sàng

_Kết quả xét nghiệm_ cho thấy rủi ro cao hơn về kết quả lâm sàng bất lợi hoặc được chẩn đoán cho sự hiện diện của một bệnh cụ thể.

CHÚ THÍCH 1: Giới hạn quyết định lâm sàng đối với thuốc điều trị được gọi là "phạm vi điều trị".

CHÚ THÍCH 2: Nó được sử dụng để xác định nguy cơ mắc bệnh, để chẩn đoán hoặc điều trị.

### Tính chất có thế thay đổi của vật liệu tham chiếu - Tính chất có thể thay đổi

Vật liệu tham chiếu có thể được thể hiện bằng mức độ gần giống nhau giữa các kết quả đo đối v ới một đại lượng đã nêu trong vật liệu này, thu được theo hai quy trình đo đã cho và thu được giữa các kết quả đo đối với các vật liệu được chỉ định khác

CHÚ THÍCH 1: Vật liệu chuẩn được đề cập thường là chất hiệu chuẩn và các vật liệu quy định khác thường là các mẫu thông thường.

CHÚ THÍCH 2: Thông thường có nhiều hơn hai thủ tục đo sẵn có và việc so sánh giữa tất cả các thủ tục đo có thể áp dụng là điều nên làm.

CHÚ THÍCH 3: Độ gần giống nhau của các kết quả đo được xác định theo tính phù hợp với mục đích phù hợp với mục đích sử dụng dự kiến của mẫu chuẩn.

CHÚ THÍCH 4: Tuyên bố về tính có thể hoán đổi được giới hạn trong các quy trình đo như được quy định trong một so sánh cụ thể.

[NGUỒN: ISO 17511: 2020 3.10, được sửa đổi - Chú thích 2 cho mục nhập đã được thay thế bằng Chú thích 2 mới cho mục nhập.]

### Năng lực

thể hiện khả năng áp dụng kiến thức và kỹ năng để đạt được kết quả như mong muốn

[NGUỒN: ISO / IEC 17021-1: 2015, 3.7, được sửa đổi - "đã được chứng minh" được thêm vào đầu định nghĩa.]

###  Khiếu nại

thể hiện hiện sự không hài lòng của bất kỳ cá nhân hoặc tổ chức nào đối với phòng xét nghiệm (3.20), liên quan đến các hoạt động hoặc kết quả của phòng xét nghiệm đó, nơi dự kiến sẽ có phản hồi

[NGUỒN: ISO/IEC 17000:2020, 8.7, được sửa đổi — Cụm từ “khác với khiếu nại” đã bị xóa và cụm từ “tổ chức đánh giá sự phù hợp hoặc tổ chức công nhận, liên quan đến các hoạt động của tổ chức đó” đã được thay thế bằng “ một phòng xét nghiệm, liên quan đến các hoạt động hoặc kết quả của phòng xét nghiệm đó”.

### Tư vấn viên

người cung cấp lời khuyên chuyên môn một cách chuyên nghiệp

### Xét nghiệm

Tập hợp các thao tác để xác định giá trị, hoặc đặc trưng của một thuộc tính

CHÚ THÍCH 1: Việc kiểm tra có thể là tổng số các hoạt động, quan sát hoặc phép đo được yêu cầu để xác định một giá trị hoặc đặc tính.

CHÚ THÍCH 2: Các xét nghiệm trong phòng xét nghiệm để xác định giá trị bằng số được gọi là "xét nghiệm định lượng"; những xét nghiệm để xác định đặc tính được gọi là "xét nghiệm định tính".

CHÚ THÍCH 3: Xét nghiệm trong phòng xét nghiệm còn được gọi là "phân tích" hoặc "kiểm tra".

### Quy trình xét nghiệm

CHÚ THÍCH 1: Trong ngành thiết bị y tế IVD và trong nhiều phòng xét nghiệm sử dụng thiết bị y tế IVD, quy trình xét nghiệm chất phân tích trong mẫu sinh học thường được gọi là phương pháp phân tích, quy trình phân tích hoặc quy trình xét nghiệm.

[NGUỒN: ISO 15198:2004, 3.7, được sửa đổi - “tập hợp các thao tác được mô tả cụ thể” được thay đổi thành “tập hợp các thao tác được mô tả cụ thể”.]

### Đánh giá chất lượng bên ngoài - EQA

CHÚ THÍCH 1: Còn được gọi là thử nghiệm thành thạo (PT)

[NGUỒN: ISO/IEC 17043:2010, 3.7 được sửa đổi - Thuật ngữ “đánh giá chất lượng bên ngoài”, được đưa ra trong Chú thích 2 của mục, được sử dụng làm thuật ngữ chính. Chú thích cho mục 1 và 2 đã được bỏ qua và chú thích 1 mới cho mục được thêm vào.]

### Tính khách quan

Tính khách quan đối với các kết quả xét nghiệm do phòng xét nghiệm y tế thực hiện

CHÚ THÍCH 1: Tính khách quan có thể được hiểu là không thiên vị hoặc không xung đột lợi ích.

CHÚ THÍCH 2: Các thuật ngữ khác hữu ích trong việc truyền tải yếu tố không thiên vị bao gồm “độc lập”, “không thành kiến”, “trung lập”, “công bằng”, “cởi mở”, “công bằng”, “không phụ thuộc” , "cân bằng".

[NGUỒN: ISO/IEC 17000:2020 5.3 được sửa đổi - “kết quả của hoạt động đánh giá sự phù hợp” đã được thay đổi thành “các nhiệm vụ được thực hiện bởi phòng xét nghiệm y tế”. Lưu ý 2 vào mục đã được thêm vào.]

### So sánh liên phòng

thực hiện và đánh giá các phép đo hoặc xét nghiệm (3.8) trên cùng một vật liệu hoặc vật liệu tương tự do hai hoặc nhiều phòng xét nghiệm độc lập thực hiện theo các điều kiện xác định trước

[NGUỒN: ISO/IEC 17043:2010 3.4, được sửa đổi — "kiểm tra" đã được thay thế bằng "xét nghiệm". "vật phẩm" đã được thay thế bằng "vật liệu". "các phòng xét nghiệm" đã được thay thế bằng "các phòng xét nghiệm độc lập".]

### Kiểm soát chất lượng nội bộ (IQC) - kiểm soát chất lượng (QC)

Quy trình nội bộ giám sát quá trình xét nghiệm để xác minh hệ thống đang hoạt động chính xác và đảm bảo rằng kết quả đủ tin cậy để công bố

[NGUỒN: ISO/TS 22583:2019 3.9, được sửa đổi — “quyết định” đã được thay thế bằng “xác minh”. Lưu ý 1 cho mục nhập đã bị xóa.]

### Thiết bị y tế chẩn đoán in vitro - Thiết bị y tế IVD

Thiết bị, dù được sử dụng riêng lẻ hay kết hợp, được nhà sản xuất dự kiến dùng để kiểm tra trong ống nghiệm các mẫu lấy từ cơ thể người chỉ hoặc chủ yếu để cung cấp thông tin cho mục đích chẩn đoán, theo dõi hoặc tương thích và bao gồm cả thuốc thử , bộ hiệu chuẩn, vật liệu kiểm soát, hộp đựng mẫu, phần mềm và các dụng cụ hoặc thiết bị liên quan hoặc các vật phẩm khác

[NGUỒN: ISO 18113-1:2022, 3.1.33, được sửa đổi — "y tế" đã bị xóa khỏi phần đầu của định nghĩa. "và bao gồm thuốc thử, chất hiệu chuẩn, vật liệu kiểm soát, hộp đựng mẫu, phần mềm và các dụng cụ hoặc thiết bị liên quan hoặc các sản phẩm khác" đã được thêm vào phần cuối của định nghĩa. Ghi chú 1 và 2 cho mục nhập đã bị xóa.]

### Quản lý phòng xét nghiệm

(Những) người có trách nhiệm và quyền hạn đối với phòng xét nghiệm (3.20)

CHÚ THÍCH 1: Lãnh đạo phòng xét nghiệm có quyền ủy quyền và cung cấp các nguồn lực trong phòng xét nghiệm.

CHÚ THÍCH 2: Lãnh đạo phòng xét nghiệm bao gồm (các) giám đốc phòng xét nghiệm và những người được ủy quyền cùng với các cá nhân được phân công cụ thể để đảm bảo chất lượng các hoạt động của phòng xét nghiệm.

### Người sử dụng phòng xét nghiệm

Cá nhân hoặc tổ chức người sử dụng dịch vụ của phòng xét nghiệm y tế (3.20)

CHÚ THÍCH 1: Người sử dụng có thể bao gồm bệnh nhân, bác sĩ lâm sàng và các phòng xét nghiệm hoặc tổ chức khác gửi mẫu để kiểm tra.

### Hệ thống quản lý

tập hợp các yếu tố liên quan hoặc tương tác với nhau của một tổ chức để thiết lập các chính sách và mục tiêu cũng như các quá trình để đạt được các mục tiêu đó

CHÚ THÍCH 1: Điều này trước đây được đề cập và đồng nghĩa với “hệ thống quản lý chất lượng”.

CHÚ THÍCH 2: Các yếu tố của hệ thống quản lý thiết lập cơ cấu, vai trò và trách nhiệm, hoạch định, vận hành, chính sách, thực hành, quy tắc, niềm tin, mục tiêu và quá trình của tổ chức để đạt được các mục tiêu đó.

[NGUỒN: ISO 9000:2015, 3.5.3 được sửa đổi - Chú thích cho mục 1, 3 và 4 đã được loại bỏ và Chú thích 1 mới cho mục đã được thêm vào.]

### Độ chính xác phép đo - độ chính xác của phép đo - độ chính xác độ gần nhau giữa giá trị đo được và giá trị thực của đại lượng đo

CHÚ THÍCH 1: Khái niệm 'độ chính xác của phép đo' không phải là một đại lượng và không được đưa ra một giá trị đại lượng bằng số. Một phép đo được cho là chính xác hơn khi nó có sai số đo nhỏ hơn.

CHÚ THÍCH 2: Không nên sử dụng thuật ngữ “độ chính xác của phép đo” cho độ đúng của phép đo và thuật ngữ độ chụm của phép đo không được sử dụng cho 'độ chính xác của phép đo', tuy nhiên, thuật ngữ này có liên quan đến cả hai khái niệm này.

CHÚ THÍCH 3: 'Độ chính xác của phép đo' đôi khi được hiểu là mức độ gần giống nhau giữa các giá trị đại lượng đo được quy cho đại lượng đo.

[NGUỒN: ISO / IEC Guide 99:2007, 2.13]

### Độ không đảm bảo đo MU

tham số không âm đặc trưng cho sự phân tán của các giá trị đại lượng được quy cho một phép đo, dựa trên thông tin được sử dụng

CHÚ THÍCH 1: MU bao gồm các thành phần phát sinh từ các hiệu ứng hệ thống, như trong trường hợp hiệu chỉnh các giá trị đại lượng ấn định của chuẩn đo lường. Đôi khi các hiệu ứng hệ thống ước tính không được hiệu chỉnh mà thay vào đó, các thành phần MU liên quan được kết hợp.

CHÚ THÍCH 2: Tham số có thể là, ví dụ, độ lệch chuẩn (SD) được gọi là MU chuẩn (hoặc bội số xác định của nó), hoặc nửa độ rộng của một khoảng, có xác suất bao phủ đã nêu.

CHÚ THÍCH 3: MU nói chung bao gồm nhiều thành phần. Một số trong số này có thể được đánh giá bằng cách đánh giá. Loại A của MU từ phân bố thống kê của các giá trị đại lượng từ các chuỗi phép đo và có thể được đặc trưng bởi SD. Các thành phần khác, có thể được đánh giá bằng đánh giá Loại B của MU, cũng có thể được đặc trưng bởi SD hoặc được đánh giá từ các hàm mật độ xác suất dựa trên kinh nghiệm hoặc thông tin khác.

CHÚ THÍCH 4: Nói chung, đối với một tập hợp thông tin nhất định, người ta hiểu rằng MU được liên kết với một giá trị đại lượng đã nêu được gán cho đại lượng đo. Việc sửa đổi giá trị này có thể dẫn đến việc sửa đổi độ không đảm bảo liên quan.

CHÚ THÍCH 5: Tất cả các phép đo đều có độ chệch (3.1) và độ không chính xác. Ví dụ, các phép đo lặp lại của một mẫu được thực hiện trong các điều kiện lặp lại thường tạo ra các giá trị khác nhau cho cùng một đại lượng đo.

Bởi vì tất cả các giá trị khác nhau đều có thể được quy một cách hợp lý cho cùng một lượng đại lượng đo, nên có sự không chắc chắn về việc giá trị nào sẽ được báo cáo là giá trị của đại lượng đo”.

CHÚ THÍCH 6: Dựa trên dữ liệu sẵn có về hiệu suất phân tích của một quy trình đo nhất định, ước tính MU cung cấp một khoảng các giá trị được cho là bao gồm giá trị thực của đại lượng đo, với mức độ tin cậy đã nêu.

CHÚ THÍCH 7: Dữ liệu sẵn có về hiệu suất phân tích của một quy trình đo nhất định thường bao gồm độ không đảm bảo của các giá trị ấn định cho bộ hiệu chuẩn và độ không chính xác lâu dài của vật liệu IQC.

CHÚ THÍCH 8: Trong các phòng xét nghiệm y tế, hầu hết các phép đo được thực hiện đơn lẻ và được coi là ước lượng có thể chấp nhận được về giá trị của đại lượng đo, trong khi khoảng MU biểu thị các kết quả khác cũng có thể thực hiện được.

[NGUỒN: ISO/IEC Guide 99:2007 2.26, được sửa đổi - Chú thích cho mục 5 đến 8 đã được thêm vào từ ISO/TS 20914:2019 3.26.]

### Phòng xét nghiệm Y tế \- Phòng xét nghiệm

để kiểm tra (3.8) các vật liệu có nguồn gốc từ cơ thể người nhằm mục đích cung cấp thông tin cho việc chẩn đoán, theo dõi, quản lý, phòng ngừa và điều trị bệnh hoặc đánh giá sức khỏe

CHÚ THÍCH 1: Phòng xét nghiệm cũng có thể đưa ra lời khuyên về tất cả các khía cạnh của xét nghiệm bao gồm lựa chọn thích hợp, giải thích kết quả và tư vấn về các xét nghiệm tiếp theo.

CHÚ THÍCH 2: Các hoạt động của phòng xét nghiệm bao gồm các quá trình trước xét nghiệm (3.24), xét nghiệm (3.8) và sau xét nghiệm (3.23).

CHÚ THÍCH 3: Vật liệu để kiểm tra (3.8) bao gồm nhưng không giới hạn ở vi sinh vật, miễn dịch học, sinh hóa, miễn dịch huyết học, huyết học, lý sinh, tế bào học, mô và tế bào, và vật liệu di truyền..

### Quá trình sau xét nghiệm

Các quy trình sau xét nghiệm (3.8) bao gồm xem xét kết quả, định dạng, phát hành, báo cáo và lưu giữ kết quả xét nghiệm, lưu giữ và bảo quản vật liệu lâm sàng, mẫu (3.28) và xử lý chất thải

### Quá trình trước xét nghiệm

Các quá trình bắt đầu, theo trình tự thời gian, từ yêu cầu của người sử dụng và bao gồm yêu cầu xét nghiệm (3.8), chuẩn bị và nhận dạng bệnh nhân (3.21), thu thập (các) mẫu ban đầu (3.25), vận chuyển đến và trong phòng xét nghiệm (3.20), kết thúc khi bắt đầu kiểm tra (3.8)

### Mẫu ban đầu - Mẫu xét nghiệm

phần riêng biệt của dịch cơ thể hoặc mô hoặc mẫu khác liên quan đến cơ thể người được dùng để kiểm tra (3.8), nghiên cứu hoặc phân tích một hoặc nhiều đại lượng hoặc đặc điểm để xác định đặc tính của toàn bộ mẫu.

CHÚ THÍCH 1: Diễn đàn các cơ quan quản lý thiết bị y tế quốc tế (IMDRF) sử dụng thuật ngữ mẫu vật trong các tài liệu hướng dẫn hài hòa của mình để chỉ mẫu có nguồn gốc sinh học dành cho xét nghiệm bởi phòng xét nghiệm y tế (3.20).

[NGUỒN: ISO 18113-1:2022, 3.1.65, được sửa đổi - Chú thích 1 cho mục nhập đã được sửa đổi. Lưu ý 2 cho mục nhập đã bị xóa.]

### Chỉ số chất lượng

Thước đo mức độ mà một số lượng lớn các đặc tính của một đối tượng đáp ứng các yêu cầu

CHÚ THÍCH 1: Phép đo có thể được biểu thị, ví dụ, như % năng suất (% trong các yêu cầu quy định), % lỗi (% ngoài các yêu cầu quy định), lỗi trên một triệu lần (DPMO) hoặc trên thang đo Six Sigma.

CHÚ THÍCH 2: Các chỉ số chất lượng có thể đo lường mức độ tổ chức đáp ứng các nhu cầu và yêu cầu của người sử dụng cũng như chất lượng của tất cả các quá trình hoạt động.

### phòng xét nghiệm bên ngoài

Phòng xét nghiệm bên ngoài (3.20) nơi gửi mẫu hoặc dữ liệu để kiểm tra (3.8)

CHÚ THÍCH 1: Phòng xét nghiệm giới thiệu là phòng mà ban giám đốc phòng xét nghiệm chọn để gửi mẫu hoặc mẫu phụ để kiểm tra, dữ liệu để phân tích hoặc giải thích hoặc khi không thể thực hiện kiểm tra thường xuyên.

CHÚ THÍCH 2: Điều này khác với phòng xét nghiệm yêu cầu gửi mẫu theo quy định hoặc phòng xét nghiệm được gọi là phòng xét nghiệm tham chiếu, ví dụ như dịch vụ y tế công cộng, pháp y, sàng lọc ung thư hoặc cơ sở trung ương (đầu não) mà việc gửi mẫu là theo yêu cầu về cơ cấu hoặc theo quy định.

### Độ đúng - Đo lường độ đúng

Mức độ gần nhau giữa giá trị trung bình của vô số giá trị đại lượng đo lặp lại và giá trị đại lượng tham chiếu

CHÚ THÍCH 1: Độ đúng của phép đo không phải là đại lượng và do đó không thể biểu thị bằng số, nhưng các thước đo về mức độ gần giống nhau được nêu trong ISO 5725-1.

CHÚ THÍCH 2: Độ đúng của phép đo tỷ lệ nghịch với sai số hệ thống, nhưng không liên quan đến sai số ngẫu nhiên.

CHÚ THÍCH 3: 'Độ chính xác của phép đo' không được sử dụng cho 'độ đúng của phép đo'.

CHÚ THÍCH 4: Đối với các xét nghiệm định tính, độ đúng của phép đo (độ gần phù hợp) có thể được thể hiện dưới dạng độ phù hợp (nghĩa là tỷ lệ phần trăm phù hợp với xét nghiệm quy chiếu).

CHÚ THÍCH 5: Độ đúng là thuộc tính của quy trình kiểm tra (3.9) phản ánh độ chệch (3.1) của phép đo so với giá trị mong đợi hoặc giá trị mục tiêu. Nó được mô tả một cách định tính là tốt hay xấu. Quy trình kiểm tra (3.9) có độ đúng tốt nếu độ chệch (3.1) của phép đo được chấp nhận.

[NGUỒN: ISO/IEC Guide 99:2007, 2.14, được sửa đổi - Chú thích cho mục 4 và 5 đã được thêm vào.]

### Thời gian trả kết quả

thời gian đã trôi qua giữa hai điểm xác định thông qua các quy trình trước xét nghiệm (3.24), xét nghiệm (3.8) và sau xét nghiệm (3.23).

### Xác nhận giá trị sử dụng

xác nhận tính hợp lý cho mục đích sử dụng hoặc ứng dụng cụ thể thông qua việc cung cấp bằng chứng khách quan rằng các yêu cầu quy định đã được đáp ứng

CHÚ THÍCH 1: Bằng chứng khách quan có thể thu được thông qua quan sát, đo lường, kiểm tra hoặc bằng cách khác có nghĩa.

CHÚ THÍCH 2: Từ “đã xác nhận giá trị sử dụng” được sử dụng để chỉ trạng thái tương ứng.

CHÚ THÍCH 3: Các yêu cầu cụ thể của một phương pháp kiểm tra có thể bao gồm các thông số kỹ thuật thực hiện sau: độ đúng của phép đo, độ chính xác của phép đo bao gồm độ lặp lại của phép đo và độ chính xác trung gian của phép đo, tính đặc hiệu của phân tích, bao gồm các chất gây nhiễu, giới hạn phát hiện và giới hạn định lượng, khoảng thời gian đo, mức độ phù hợp về mặt lâm sàng , độ đặc hiệu chẩn đoán và độ nhạy chẩn đoán.

[NGUỒN: ISO/IEC 17000:2020, 6.5, được sửa đổi - Chú thích 1 đến 3 cho mục nhập đã được thêm vào.]

### Kiểm tra xác nhận

xác nhận tính trung thực, thông qua việc cung cấp bằng chứng khách quan rằng các yêu cầu cụ thể đã được đáp ứng

VÍ DỤ 1 Xác nhận rằng các đặc tính kỹ thuật hiệu suất của một hệ thống đo lường đã đạt được.

VÍ DỤ 2 Xác nhận rằng có thể đáp ứng độ không đảm bảo đo mục tiêu.

CHÚ THÍCH 1: Kiểm tra xác nhận là quá trình mà phòng xét nghiệm xác nhận rằng các tuyên bố về hiệu suất đã thiết lập của một hệ thống đo lường, ví dụ như độ đúng, độ chụm, phạm vi có thể báo cáo, có thể được lặp lại trong phòng xét nghiệm trước khi thực hiện xét nghiệm trên mẫu bệnh nhân.

CHÚ THÍCH 2: Bằng chứng khách quan cần thiết cho việc kiểm tra xác nhận có thể là kết quả kiểm tra hoặc các hình thức xác định khác, chẳng hạn như thực hiện các phép tính thay thế hoặc xem xét tài liệu.

CHÚ THÍCH 3: Việc kiểm tra xác nhận có thể đủ để triển khai thiết bị IVD mới trong các trường hợp khi việc xét nghiệm (3.8) được thực hiện và sử dụng theo cách như được chỉ dẫn trong tờ hướng dẫn sử dụng.

CHÚ THÍCH 4: Từ "đã xác nhận" được sử dụng để chỉ trạng thái tương ứng

[NGUỒN: ISO/IEC 17000:2020, 6.6 được sửa đổi - VÍ DỤ 1 và 2 đã được thêm vào. Ghi chú cho mục 1 đến 4 đã được thêm vào.]

## Những yêu cầu chung

### Tính khách quan

  * Các hoạt động của phòng xét nghiệm phải được thực hiện một cách khách quan. Phòng xét nghiệm phải được cấu trúc và quản lý để bảo vệ sự khách quan.

  * Ban lãnh đạo phòng xét nghiệm phải cam kết duy trì sự khách quan.

  * Phòng xét nghiệm phải chịu trách nhiệm về tính khách quan trong các hoạt động xét nghiệm của mình và không được cho phép các áp lực thương mại, tài chính hoặc các áp lực khác ảnh hưởng đến tính khách quan.

  * Phòng xét nghiệm phải giám sát các hoạt động và các mối quan hệ của mình để xác định các mối đe dọa đối với tính khách quan của phòng xét nghiệm. Giám sát này sẽ bao gồm các mối quan hệ của nhân viên phòng xét nghiệm.


CHÚ THÍCH: Mối quan hệ đe dọa đến tính khách quan của phòng xét nghiệm có thể dựa trên quyền sở hữu, quản trị, quản lý, nhân sự, nguồn lực được chia sẻ, tài chính, hợp đồng, tiếp thị (bao gồm cả việc xây dựng thương hiệu) và thanh toán hoa hồng bán hàng hoặc sự xúi giục khác để giới thiệu phòng xét nghiệm mới, v.v. Những mối quan hệ như vậy không nhất thiết khiến phòng xét nghiệm bị đe dọa đến tính khách quan.

  * Nếu xác định được mối đe dọa đối với tính khách quan, ảnh hưởng đó phải được loại bỏ hoặc giảm thiểu để tính khách quan không bị tổn hại. Phòng xét nghiệm phải có khả năng chứng minh cách mà phòng xét nghiệm giảm thiểu mối đe dọa đó.

# Public_008

# Tiêu chuẩn quản trị

## Yêu cầu về cơ cấu và quản trị

### Pháp nhân

Phòng xét nghiệm hoặc tổ chức mà phòng xét nghiệm là một phần của nó phải là một pháp nhân có thể chịu trách nhiệm pháp lý về các hoạt động của mình.

CHÚ THÍCH: Với mục đích của tài liệu này, phòng xét nghiệm của chính phủ được coi là một pháp nhân trên cơ sở tư cách chính phủ của nó.

## Giám đốc phòng xét nghiệm

###  Năng lực của giám đốc phòng xét nghiệm

Phòng xét nghiệm phải được chỉ đạo bởi một người, hoặc những người được nêu tên, với trình độ, năng lực, quyền hạn được ủy quyền, trách nhiệm và nguồn lực cụ thể để đáp ứng các yêu cầu của tài liệu này.

### Trách nhiệm của Giám đốc phòng xét nghiệm

Giám đốc phòng xét nghiệm chịu trách nhiệm triển khai hệ thống quản lý, bao gồm cả việc áp dụng quản lý rủi ro cho tất cả các khía cạnh của hoạt động phòng xét nghiệm để các rủi ro đối với việc chăm sóc bệnh nhân và các cơ hội cải tiến được xác định và giải quyết một cách có hệ thống.

Nhiệm vụ và trách nhiệm của giám đốc phòng xét nghiệm phải được lập thành văn bản.

### Phân công nhiệm vụ

Giám đốc phòng xét nghiệm có thể ủy quyền các nhiệm vụ hoặc trách nhiệm, hoặc cả hai, cho nhân viên có trình độ và năng lực và việc ủy quyền đó phải được lập thành văn bản. Tuy nhiên, giám đốc phòng xét nghiệm phải duy trì trách nhiệm cuối cùng đối với hoạt động chung của phòng xét nghiệm.

## Hoạt động của phòng xét nghiệm

### Tổng quát

Phòng xét nghiệm phải chỉ định và lập thành văn bản phạm vi hoạt động của phòng xét nghiệm, bao gồm các hoạt động của phòng xét nghiệm được thực hiện tại các địa điểm khác với địa điểm chính (ví dụ: POCT, thu thập mẫu) mà nó tuân thủ với tài liệu này. Phòng xét nghiệm chỉ được công bố sự phù hợp với tài liệu này đối với phạm vi hoạt động của phòng xét nghiệm, loại trừ các hoạt động của phòng xét nghiệm do bên ngoài cung cấp.

### Tuân thủ các yêu cầu

Các hoạt động của phòng xét nghiệm phải được thực hiện đáp ứng các yêu cầu của tài liệu này, của người dùng, của cơ quan quản lý và tổ chức đánh giá công nhận. Điều này áp dụng cho toàn bộ các hoạt động phòng xét nghiệm được chỉ định và lập thành văn bản, bất kể dịch vụ được cung cấp ở đâu.

### Hoạt động tư vấn

Khoa xét nghiệm đảm bảo các tư vấn và giải thích phù hợp về dịch vụ xét nghiệm luôn sẵn có và đáp ứng nhu cầu của bệnh nhân và người sử dụng.

Phòng xét nghiệm thiết lập các thỏa thuận để liên lạc với người sử dụng phòng xét nghiệm về những điều sau đây khi áp dụng:

  * Tư vấn về lựa chọn và sử dụng các dịch vụ, bao gồm loại mẫu được yêu cầu, chỉ định lâm sàng, giới hạn của phương pháp xét nghiệm và tần suất yêu cầu xét nghiệm;

  * Đưa ra những đánh giá chuyên môn nhằm giải thích kết quả xét nghiệm;

  * Thúc đẩy việc sử dụng hiệu quả các dịch vụ của phòng xét nghiệm;

  * Tư vấn về các vấn đề khoa học và hậu cần, chẳng hạn như trường hợp (các) mẫu không đáp ứng tiêu chí chấp nhận.


Các vấn đề liên quan đến hoạt động tư vấn thực hiện theo quy trình tư vấn dịch vụ

##  Cơ cấu và quyền hạn

### Tổng quát

Phòng xét nghiệm có trách nhiệm:

  * xác định cơ cấu tổ chức và quản lý, vị trí của nó trong tổ chức mẹ và mối quan hệ giữa quản lý, hoạt động kỹ thuật và dịch vụ hỗ trợ;

  * xác định trách nhiệm, quyền hạn, thông tin liên lạc và mối quan hệ qua lại của tất cả những nhân viên, thực hiện hoặc kiểm tra xác nhận công việc ảnh hưởng đến kết quả các hoạt động của phòng xét nghiệm;

  * quy định các thủ tục trong phạm vi cần thiết để đảm bảo áp dụng nhất quán cho phòng xét nghiệm.


### Quản lý chất lượng

Phòng xét nghiệm phải có nhân viên quản lý chất lượng, ngoài các trách nhiệm khác, phải có thẩm quyền và nguồn lực cần thiết để thực hiện nhiệm vụ của họ, bao gồm:

  * việc áp dụng, duy trì và cải tiến hệ thống quản lý;

  * xác định các sự không phù hợp của hệ thống quản lý hoặc các thủ tục trong hoạt động của phòng xét nghiệm;

  * Tổ chức các hành động để phòng ngừa hoặc khắc phục những sự không phù hợp đó;

  * báo cáo cho ban lãnh đạo phòng xét nghiệm về kết quả hoạt động của hệ thống quản lý và mọi nhu cầu để cải tiến;

  * đảm bảo hiệu quả của các hoạt động trong phòng xét nghiệm.


CHÚ THÍCH: Những trách nhiệm này có thể được giao cho một hoặc nhiều người.

## Mục tiêu và chính sách

  * Lãnh đạo phòng xét nghiệm phải thiết lập và duy trì các mục tiêu và chính sách để:

* đáp ứng nhu cầu và yêu cầu của bệnh nhân và người sử dụng;

* cam kết thực hành tốt chuyên môn;

* cung cấp các dịch vụ xét nghiệm đáp ứng mục đích sử dụng;

* phù hợp với tài liệu này.

  * Các mục tiêu chất lượng phải đo lường được và nhất quán với các chính sách chất lượng. Phòng xét nghiệm phải đảm bảo rằng các mục tiêu và chính sách được thực hiện ở tất cả các cấp trong tổ chức phòng xét nghiệm.

  * Lãnh đạo phòng xét nghiệm phải đảm bảo rằng tính toàn vẹn của hệ thống quản lý được duy trì khi các thay đổi đối với hệ thống quản lý được hoạch định và thực hiện.

  * Phòng xét nghiệm phải thiết lập và theo dõi các chỉ số chất lượng để đánh giá hiệu suất các khía cạnh của quá trình trước xét nghiệm, xét nghiệm và sau xét nghiệm


CHÚ THÍCH: Các chỉ số chất lượng bao gồm số lượng mẫu bị từ chối, số lượng lỗi khi chỉ định hoặc nhận mẫu hoặc cả hai, số lượng báo cáo kết quả đã sửa, tỷ lệ thời gian trả kết quả đúng hạn.

## Quản lý rủi ro

  * Lãnh đạo phòng xét nghiệm phải thiết lập, thực hiện và duy trì các quy trình để xác định các rủi ro gây hại cho bệnh nhân và các cơ hội để cải tiến việc chăm sóc bệnh nhân liên quan đến các hoạt động và xét nghiệm của mình, đồng thời phát triển các hành động để giải quyết cả rủi ro và cơ hội cải tiến

  * Giám đốc phòng xét nghiệm phải đảm bảo rằng các quy trình này được đánh giá về tính hiệu quả và được sửa đổi, khi được xác định là không hiệu quả.


CHÚ THÍCH 1: ISO 22367 cung cấp chi tiết để quản lý rủi ro trong các phòng xét nghiệm y tế.
CHÚ THÍCH 2: ISO 35001 cung cấp thông tin chi tiết về quản lý rủi ro sinh học trong phòng thí nghiệm.

## Yêu cầu về nguồn lực

###  Tổng quát

Phòng xét nghiệm phải có sẵn nhân sự, cơ sở vật chất, thiết bị, thuốc thử, vật tư tiêu hao và các dịch vụ hỗ trợ cần thiết để quản lý và thực hiện các hoạt động của phòng xét nghiệm.

###  Nhân sự

#### Tổng quát

  * Phòng xét nghiệm phải có đủ số lượng nhân viên có năng lực để thực hiện các hoạt động của mình.

  * Tất cả nhân viên của phòng xét nghiệm, nội bộ hoặc bên ngoài, có thể ảnh hưởng đến các hoạt động của phòng xét nghiệm phải hành động một cách vô tư, có đạo đức, có năng lực và làm việc phù hợp với hệ thống quản lý của phòng xét nghiệm.


CHÚ THÍCH: ISO/TS 22583 cung cấp hướng dẫn cho người giám sát và vận hành thiết bị POCT.

  * Phòng xét nghiệm phải truyền đạt cho nhân viên phòng xét nghiệm về tầm quan trọng của việc đáp ứng nhu cầu và yêu cầu của người sử dụng cũng như các yêu cầu của tài liệu này.

  * Phòng xét nghiệm phải có chương trình giới thiệu cho nhân sự mới về tổ chức, bộ phận hoặc khu vực mà người đó sẽ làm việc, các điều khoản và điều kiện tuyển dụng, cơ sở vật chất của nhân viên, các yêu cầu về sức khỏe và an toàn cũng như các dịch vụ sức khỏe nghề nghiệp.


#### Yêu cầu về năng lực

  * Phòng xét nghiệm phải quy định cụ thể các yêu cầu về năng lực đối với từng chức năng ảnh hưởng đến kết quả hoạt động của phòng xét nghiệm, bao gồm các yêu cầu về trình độ học vấn, trình độ chuyên môn, đào tạo, đào tạo lại, kiến thức kỹ thuật, kỹ năng và kinh nghiệm.

  * Phòng xét nghiệm phải đảm bảo tất cả nhân viên có đủ năng lực thực hiện các hoạt động trong phòng xét nghiệm mà họ chịu trách nhiệm.

  * Phòng xét nghiệm phải có quy trình quản lý năng lực của nhân viên, bao gồm yêu cầu về tần suất đánh giá năng lực.

  * Phòng xét nghiệm phải có thông tin dạng văn bản chứng minh năng lực của nhân viên.


CHÚ THÍCH: Ví dụ về các phương pháp đánh giá năng lực có thể được sử dụng bất kỳ sự kết hợp nào dưới đây bao gồm:

  * quan sát trực tiếp một hoạt động,

  * giám sát việc ghi chép và báo cáo kết quả xét nghiệm,

  * xem xét hồ sơ công việc,

  * đánh giá kỹ năng giải quyết vấn đề,

  * kiểm tra bằng các mẫu được cung cấp đặc biệt, ví dụ: các mẫu đã được kiểm tra trước đó, vật liệu so sánh liên phòng hoặc các mẫu tách.


### Ủy quyền

Phòng xét nghiệm phải ủy quyền cho nhân viên thực hiện các hoạt động cụ thể của phòng xét nghiệm, bao gồm nhưng không giới hạn ở các hoạt động sau:

  * lựa chọn, phát triển, sửa đổi, xác nhận giá trị sử dụng và kiểm tra xác nhận các phương pháp;

  * xem xét, công bố và báo cáo kết quả;

  * sử dụng các hệ thống thông tin của phòng xét nghiệm, cụ thể: truy cập dữ liệu và thông tin bệnh nhân, nhập dữ liệu bệnh nhân và kết quả xét nghiệm, thay đổi dữ liệu bệnh nhân hoặc kết quả xét nghiệm.


### Đào tạo liên tục và phát triển chuyên môn

Một chương trình đào tạo liên tục sẽ có sẵn cho nhân viên tham gia vào các quá trình quản lý và kỹ thuật. Tất cả nhân viên phải tham gia vào chương trình đào tạo liên tục và phát triển chuyên môn thường xuyên, hoặc các hoạt động liên kết chuyên môn khác.
Sự phù hợp của các chương trình và hoạt động sẽ được xem xét định kỳ.

### Hồ sơ nhân sự

Phòng xét nghiệm phải có các thủ tục và lưu giữ hồ sơ về:

  * xác định các yêu cầu về năng lực quy định

  * mô tả vị trí việc làm;

  * đào tạo và đào tạo lại;

  * ủy quyền cho nhân sự;

  * giám sát năng lực của nhân viên.


### Cơ sở vật chất và điều kiện môi trường

#### Tổng quát

Cơ sở vật chất và điều kiện môi trường phải phù hợp với hoạt động của phòng xét nghiệm và không ảnh hưởng xấu đến hiệu lực của kết quả, hoặc sự an toàn của bệnh nhân, khách thăm, người sử dụng phòng xét nghiệm và nhân viên. Điều này sẽ bao gồm các cơ sở và địa điểm liên quan đến trước xét nghiệm và khi xét nghiệm mà khác với cơ sở chính của phòng xét nghiệm, cũng như POCT.
Các yêu cầu về cơ sở vật chất và điều kiện môi trường cần thiết cho việc thực hiện các hoạt động của phòng xét nghiệm phải được quy định , theo dõi và ghi lại.
CHÚ THÍCH 1: ISO 15190 cung cấp thông tin chi tiết về cơ sở vật chất và điều kiện môi trường.
CHÚ THÍCH 2: Các điều kiện môi trường có thể ảnh hưởng bất lợi đến tính hợp lệ của kết quả bao gồm, nhưng không
giới hạn ở: axit nucleic được khuếch đại ngẫu nhiên, nhiễm vi sinh vật, bụi, nhiễu điện từ, bức xạ, điều kiện ánh sáng (chiếu sáng), độ ẩm, nguồn điện, nhiệt độ, âm thanh và rung động.

#### Kiểm soát cơ sở

Các biện pháp kiểm soát cơ sở phải được thực hiện, ghi lại, giám sát, xem xét định kỳ và phải bao gồm:

  * kiểm soát truy cập, có tính đến sự an toàn, bảo mật, chất lượng và bảo vệ thông tin y tế và mẫu bệnh phẩm;

  * ngăn ngừa nhiễm bẩn, nhiễu hoặc ảnh hưởng xấu đến các hoạt động của phòng xét nghiệm có thể phát sinh từ các nguồn năng lượng, chiếu sáng, thông gió, tiếng ồn, nước và xử lý chất thải;

  * ngăn ngừa nhiễm chéo, khi quy trình xét nghiệm có rủi ro, hoặc khi công việc có thể bị ảnh hưởng hoặc ảnh hưởng do thiếu sự tách biệt;

  * cung cấp các phương tiện và thiết bị an toàn, nếu có thể áp dụng và kiểm tra xác nhận thường xuyên chức năng của chúng;

* VÍ DỤ: Hoạt động của hệ thống thoát khẩn cấp, liên lạc nội bộ và hệ thống báo động cho phòng lạnh và tủ đông không cửa ngăn, khả năng tiếp cận vòi tắm khẩn cấp, thiết bị rửa mắt và hồi sức.

  * duy trì các trang thiết bị của phòng xét nghiệm trong điều kiện hoạt động tốt và đáng tin cậy.


#### Tiện nghi lưu trữ

  * Phòng xét nghiệm phải cung cung cấp không gian lưu trữ, với các điều kiện đảm bảo tính toàn vẹn liên tục của mẫu, thiết bị, thuốc thử, vật tư tiêu hao, tài liệu và hồ sơ.

  * Các mẫu bệnh nhân và vật liệu được sử dụng trong quy trình xét nghiệm phải được bảo quản theo cách ngăn ngừa nhiễm chéo và hư hỏng.

  * Cơ sở lưu trữ, xử lý vật liệu nguy hiểm và chất thải sinh học phải phù hợp với việc phân loại vật liệu theo các yêu cầu luật định hoặc quy định.


#### Tiện nghi cho nhân viên

Phải cung cấp điều kiện về thiết bị vệ sinh và nguồn cung cấp nước uống, cũng như các phương tiện cất giữ thiết bị và quần áo bảo hộ cá nhân.
Phải cung cấp không gian cho các hoạt động của nhân viên, như các cuộc họp, khu vực yên tĩnh để học tập và khu vực nghỉ ngơi.

#### Tiện nghi lấy mẫu bệnh phẩm

Cơ sở thu thập mẫu có trách nhiệm:

  * cho phép thực hiện việc thu thập theo cách thức không làm mất hiệu lực của kết quả hoặc ảnh hưởng xấu đến chất lượng xét nghiệm;

  * xem xét sự riêng tư, thoải mái và các nhu cầu (ví dụ: lối đi dành cho người khuyết tật, nhà vệ sinh) của bệnh nhân và chỗ ở của những người đi cùng (ví dụ: người giám hộ hoặc thông dịch viên) trong quá trình thu thập;

  * cung cấp các khu vực tiếp nhận và thu thập mẫu bệnh phẩm riêng biệt;

  * duy trì vật liệu sơ cứu cho cả bệnh nhân và nhân viên.


CHÚ THÍCH: ISO 20658 cung cấp thông tin chi tiết về phương tiện lấy mẫu.

###  Trang thiết bị

####  Tổng quát

Phòng xét nghiệm phải có quy trình lựa chọn, mua sắm, lắp đặt,nghiệm thu (bao gồm các tiêu chí về khả năng chấp nhận), xử lý, vận chuyển, bảo quản, sử dụng, bảo trì và ngừng hoạt động của thiết bị, để đảm bảo thiết bị hoạt động bình thường và ngăn ngừa nhiễm bẩn hoặc hư hỏng.
CHÚ THÍCH: Thiết bị phòng xét nghiệm bao gồm phần cứng và phần mềm của thiết bị, hệ thống đo lường và hệ thống thông tin phòng xét nghiệm hoặc bất kỳ thiết bị nào có ảnh hưởng đến kết quả của các hoạt động trong phòng xét nghiệm, bao gồm cả hệ thống vận chuyển mẫu.

####  Yêu cầu về thiết bị

  * Phòng xét nghiệm phải có quyền truy cập vào các thiết bị cần thiết để thực hiện chính xác các hoạt động của phòng xét nghiệm.

  * Trong trường hợp thiết bị được sử dụng nằm ngoài tầm kiểm soát thường xuyên của phòng xét nghiệm hoặc thông số chức năng kỹ thuật của nhà sản xuất, ban lãnh đạo phòng xét nghiệm phải đảm bảo rằng các yêu cầu của tài liệu này được đáp ứng.

  * Mỗi hạng mục của thiết bị có thể ảnh hưởng đến hoạt động của phòng xét nghiệm phải được dán nhãn riêng, đánh dấu hoặc xác định duy nhất và duy trì sổ theo dõi.

  * Phòng xét nghiệm phải bảo dưỡng và thay thế thiết bị khi cần thiết để đảm bảo chất lượng kết quả xét nghiệm.


#### Thủ tục nghiệm thu thiết bị

Phòng xét nghiệm phải xác minh rằng thiết bị phù hợp với các tiêu chí chấp nhận được xác định trước khi đưa vào sử dụng hoặc khi đưa trở lại sử dụng.

Thiết bị được sử dụng để đo phải có khả năng đạt được độ chính xác của phép đo hoặc độ không đảm bảo đo, hoặc cả hai, được yêu cầu để cung cấp kết quả hợp lệ.

CHÚ THÍCH 1 Điều này bao gồm thiết bị được sử dụng trong phòng xét nghiệm, thiết bị cho mượn hoặc thiết bị được sử dụng trong các cơ sở chăm sóc tại chỗ hoặc trong các cơ sở liên quan hoặc di động, được phòng xét nghiệm uỷ quyền.

CHÚ THÍCH 2 Việc xác minh thử nghiệm chấp nhận thiết bị, nếu phù hợp, có thể dựa trên chứng nhận hiệu chuẩn của thiết bị được trả lại.

####  Hướng dẫn sử dụng thiết bị

  * Phòng xét nghiệm phải có các biện pháp bảo vệ thích hợp để ngăn chặn các điều chỉnh ngoài ý muốn của thiết bị có thể làm mất hiệu lực của kết quả xét nghiệm.

  * Thiết bị phải được vận hành bởi nhân viên được đào tạo, được ủy quyền và có năng lực.

  * Hướng dẫn sử dụng thiết bị, bao gồm cả hướng dẫn thiết bị do nhà sản xuất cung cấp, phải có sẵn.

  * Thiết bị phải được sử dụng theo quy định của nhà sản xuất, trừ khi được xác nhận bởi phòng xét nghiệm


####  Bảo dưỡng và sửa chữa thiết bị

  * Phòng xét nghiệm phải có các chương trình bảo trì phòng ngừa, dựa trên hướng dẫn của nhà sản xuất. Những sai lệch so với lịch trình hoặc hướng dẫn của nhà sản xuất phải được ghi lại.

  * Thiết bị phải được duy trì trong điều kiện làm việc an toàn và hoạt động bình thường. Điều này phải bao gồm an toàn điện, bất kỳ thiết bị dừng khẩn cấp nào và việc xử lý và tiêu hủy an toàn các vật liệu nguy hiểm bởi nhân viên được uỷ quyền.

  * Thiết bị bị lỗi hoặc không đạt yêu cầu quy định sẽ bị ngừng sử dụng. Nó phải được dán nhãn rõ ràng hoặc đánh dấu là không hoạt động, cho đến khi nó được xác minh là hoạt động chính xác. Phòng xét nghiệm phải xem xét ảnh hưởng của lỗi hoặc sai lệch so với các yêu cầu quy định và phải bắt đầu các hành động khi xảy ra sự không phù hợp

  * Khi có thể, phòng xét nghiệm phải khử nhiễm thiết bị trước khi bảo dưỡng, sửa chữa hoặc ngừng hoạt động, cung cấp không gian thích hợp để sửa chữa và cung cấp thiết bị bảo hộ cá nhân thích hợp


####  Báo cáo sự cố bất lợi của thiết bị

Các sự cố và tai nạn bất lợi có thể được quy trực tiếp cho thiết bị cụ thể sẽ được điều tra và báo cáo cho nhà sản xuất hoặc nhà cung cấp, hoặc cả hai, và các cơ quan có thẩm quyền thích hợp, theo yêu cầu.

Phòng xét nghiệm phải có các thủ tục để ứng phó với bất kỳ thông báo thu hồi hoặc thông báo nào khác của nhà sản xuất và thực hiện các hành động do nhà sản xuất khuyến nghị.

####  Hồ sơ thiết bị

Hồ sơ phải được duy trì cho từng hạng mục thiết bị ảnh hưởng đến kết quả hoạt động của phòng xét nghiệm.

Các hồ sơ này phải bao gồm những điều sau đây, nếu có liên quan:

  * chi tiết về nhà sản xuất và nhà cung cấp, và thông tin đầy đủ để xác định duy nhất từng hạng mục của thiết bị, bao gồm phần mềm và chương trình cơ sở;

  * ngày tiếp nhận, nghiệm thu và đưa vào sử dụng;

  * bằng chứng cho thấy thiết bị phù hợp với các tiêu chí chấp nhận được quy định;

  * vị trí hiện tại;

  * tình trạng khi nhận (ví dụ: mới, đã qua sử dụng hoặc đã tân trang lại);

  * hướng dẫn của nhà sản xuất;

  * chương trình bảo dưỡng phòng ngừa;

  * bất kỳ hoạt động bảo trì nào được thực hiện bởi phòng xét nghiệm hoặc nhà cung cấp dịch vụ bên ngoài đã được phê duyệt;

  * hư hỏng, trục trặc, sửa đổi hoặc sửa chữa thiết bị;

  * hồ sơ hiệu suất của thiết bị như báo cáo hoặc giấy chứng nhận hiệu chuẩn hoặc kiểm tra xác nhận, hoặc cả hai, kể cả ngày tháng, thời gian và kết quả;

  * tình trạng của thiết bị như đang hoạt động hay đang sử dụng, không hoạt động, cách ly, ngừng hoạt động hoặc lỗi thời.


Các hồ sơ này phải được lưu giữ và phải có sẵn trong suốt vòng đời của thiết bị hoặc lâu hơn, như được quy định

### Hiệu chuẩn thiết bị và liên kết chuẩn đo lường

####  Tổng quát

Phòng xét nghiệm phải quy định các yêu cầu hiệu chuẩn và liên kết chuẩn đủ để duy trì báo cáo nhất quán về kết quả kiểm tra. Đối với các phương pháp định lượng chất phân tích đo được, các thông số kỹ thuật phải bao gồm các yêu cầu về hiệu chuẩn và truy xuất nguồn gốc đo lường. Các phương pháp định tính và phương pháp định lượng đo các đặc tính chứ không phải các chất phân tích rời rạc phải quy định đặc tính được đánh giá và các yêu cầu cần thiết cho khả năng tái lập theo thời gian.

CHÚ THÍCH: Ví dụ về phương pháp định tính và phương pháp định lượng có thể không cho phép truy xuất nguồn gốc bằng đo lường bao gồm phát hiện kháng thể hồng cầu, đánh giá độ nhạy cảm với kháng sinh, xét nghiệm di truyền, tốc độ máu lắng, nhuộm chất đánh dấu tế bào học dòng chảy và nhuộm hóa mô miễn dịch HER2 của khối u.

####  Hiệu chuẩn thiết bị

Phòng xét nghiệm phải có thủ tục hiệu chuẩn thiết bị có ảnh hưởng trực tiếp hoặc gián tiếp đến kết quả xét nghiệm. Các thủ tục phải quy định:

  * điều kiện sử dụng và hướng dẫn hiệu chuẩn của nhà sản xuất;

  * ghi lại truy xuất nguồn gốc đo lường;

  * kiểm tra độ chính xác của phép đo cần thiết và hoạt động của hệ thống đo trong các khoảng thời gian quy định;

  * ghi lại tình trạng hiệu chuẩn và ngày hiệu chuẩn lại;

  * đảm bảo rằng, khi các yếu tố hiệu chỉnh được sử dụng, chúng được cập nhật và ghi lại khi hiệu chuẩn lại;

  * xử lý các tình huống khi hiệu chuẩn nằm ngoài tầm kiểm soát, để giảm thiểu rủi ro cho hoạt động dịch vụ và cho bệnh nhân.


####  Liên kết chuẩn đo lường

  * Phòng xét nghiệm phải thiết lập và duy trì liên kết chuẩn đo lường cho các kết quả đo của mình bằng một chuỗi không đứt đoạn các phép hiệu chuẩn được lập thành văn bản. Mỗi phép hiệu chuẩn đóng góp vào độ không đảm bảo đo. Liên kết các kết quả đo tới mốc quy chiếu thích hợp.


CHÚ THÍCH: Thông tin liên kết chuẩn tới vật liệu chuẩn bậc cao hoặc quy trình tham chiếu có thể được cung cấp bởi hệ thống kiểm tra của nhà sản xuất. Tài liệu như vậy chỉ được chấp nhận khi hệ thống kiểm tra và quy trình hiệu chuẩn của nhà sản xuất được sử dụng mà không sửa đổi.

  * Phòng xét nghiệm phải đảm bảo rằng kết quả đo lường có thể liên kết đến hệ đơn vị quốc tế thông qua:


Việc hiệu chuẩn được cung cấp bởi phòng thí nghiệm có năng lực; hoặc
CHÚ THÍCH 1: Các phòng thí nghiệm hiệu chuẩn đáp ứng các yêu cầu của ISO / IEC 17025 được coi là có năng lực để thực hiện hiệu chuẩn.

  * Các giá trị được chứng nhận của mẫu chuẩn được chứng nhận do nhà sản xuất có năng lực cung cấp có liên kết chuẩn đo lường tới SI được công bố: hoặc;


CHÚ THÍCH 2: Các nhà sản xuất mẫu chuẩn đáp ứng các yêu cầu của ISO 17034 được coi là có năng lực.
CHÚ THÍCH 3: Mẫu chuẩn được chứng nhận đáp ứng yêu cầu của ISO 15194 được coi là phù hợp.

  * Trường hợp không thể cung cấp liên kết chuẩn phải áp dụng các biện pháp khác để cung cấp sự tin cậy cho các kết quả sẽ được áp dụng, bao gồm nhưng không giới hạn ở các biện pháp sau đây:


kết quả của các quy trình đo quy chiếu, các phương pháp quy định hoặc các chuẩn chuẩn đồng thuận được mô tả rõ ràng và được chấp nhận là cho ra kết quả đo phù hợp với việc sử dụng đã định và được đảm bảo bằng phép so sánh thích hợp.

CHÚ THÍCH: ISO 17511 cung cấp thêm thông tin về cách quản lý đồng thuận trong liên kết chuẩn đo lường của đại lượng đo.

  * Đối với giám định di truyền, phải thiết lập liên kết chuẩn đến các trình tự tham chiếu di truyền.

  * Đối với các phương pháp định tính, liên kết chuẩn có thể được chứng minh bằng cách thử nghiệm vật liệu đã biết hoặc các mẫu trước đó đủ để cho thấy nhận biết nhất quán và, nếu có, mức độ phản ứng.


### Thuốc thử và vật tư tiêu hao

####  Tổng quát

Phòng xét nghiệm phải có các quy trình lựa chọn, mua sắm, tiếp nhận, lưu trữ, nghiệm thu và quản lý tồn kho các thuốc thử, vật tư tiêu hao.

CHÚ THÍCH: Thuốc thử bao gồm các chất được cung cấp thương mại hoặc tự chuẩn bị, vật liệu chuẩn (chất hiệu chuẩn và vật liệu QC), môi trường nuôi cấy; vật tư tiêu hao bao gồm đầu tip pipet, phiến kính, vật tư POCT, v.v.

#### Thuốc thử và vật tư tiêu hao — Tiếp nhận và bảo quản

Phòng xét nghiệm phải lưu trữ thuốc thử và vật tư tiêu hao theo thông số kỹ thuật của nhà sản xuất và theo dõi các điều kiện môi trường nếu có liên quan.

Khi phòng xét nghiệm không phải là cơ sở tiếp nhận, nó phải xác minh rằng cơ sở tiếp nhận có đủ khả năng lưu trữ và xử lý để duy trì nguồn cung cấp theo cách ngăn ngừa hư hỏng và xuống cấp.

#### Thuốc thử và vật tư tiêu hao — Kiểm tra nghiệm thu

Mỗi thuốc thử hoặc công thức mới của bộ kít xét nghiệm có thay đổi về thuốc thử hoặc quy trình, hoặc lô hoặc lô hàng mới, phải được xác minh về hiệu suất trước khi đưa vào sử dụng hoặc trước khi công bố kết quả, nếu thích hợp.

Vật tư tiêu hao có thể ảnh hưởng đến chất lượng xét nghiệm phải được kiểm tra hiệu suất trước khi đưa vào sử dụng.

CHÚ THÍCH 1: Hiệu suất IQC so sánh của lô thuốc thử mới và của lô trước đó có thể được sử dụng làm bằng chứng để chấp nhận. Các mẫu bệnh nhân được ưu tiên sử dụng khi so sánh các lô thuốc thử khác nhau để tránh các vấn đề tính dễ thay đổi của vật liệu IQC.

CHÚ THÍCH 2: Việc kiểm tra xác nhận đôi khi có thể dựa trên giấy chứng nhận phân tích thuốc thử.

####  Thuốc thử và vật tư tiêu hao — Quản lý hàng tồn kho

Phòng xét nghiệm phải thiết lập một hệ thống quản lý hàng tồn kho cho thuốc thử và vật tư tiêu hao.

Hệ thống quản lý hàng tồn kho phải tách biệt thuốc thử và vật tư tiêu hao đã được chấp nhận sử dụng với những thuốc thử chưa được kiểm tra cũng như không được chấp nhận sử dụng.

#### Thuốc thử và vật tư tiêu hao — Hướng dẫn sử dụng

Hướng dẫn sử dụng thuốc thử và vật tư tiêu hao, bao gồm cả hướng dẫn do nhà sản xuất cung cấp, phải có sẵn. Thuốc thử và vật tư tiêu hao phải được sử dụng theo thông số kỹ thuật của nhà sản xuất.

#### Thuốc thử và vật tư tiêu hao — Báo cáo sự cố bất lợi

Các sự cố và tai nạn bất lợi có thể do các thuốc thử hoặc vật tư tiêu hao cụ thể phải được điều tra và báo cáo cho nhà sản xuất hoặc nhà cung cấp, hoặc cả hai, và các cơ quan có thẩm quyền thích hợp, theo yêu cầu.

Phòng xét nghiệm phải có các quy trình để ứng phó với bất kỳ thông báo thu hồi hoặc thông báo nào khác của nhà sản xuất và thực hiện các hành động do nhà sản xuất khuyến nghị.

#### Thuốc thử và vật tư tiêu hao — Hồ sơ

Phải lưu giữ các hồ sơ cho mỗi thuốc thử và vật tư tiêu hao góp phần vào việc thực hiện các xét nghiệm. Những hồ sơ này phải bao gồm, nhưng không giới hạn, những mục sau:

  * nhận dạng thuốc thử hoặc vật tư tiêu hao;

  * thông tin của nhà sản xuất, bao gồm hướng dẫn, tên và mã lô hoặc số lô;

  * ngày nhận và tình trạng khi nhận, ngày hết hạn, ngày sử dụng đầu tiên và, nếu có, ngày thuốc thử hoặc vật tư tiêu hao ngừng sử dụng;

  * hồ sơ xác nhận việc thuốc thử hoặc vật tư tiêu hao được chấp nhận sử dụng ban đầu và liên tục.


Trong trường hợp phòng xét nghiệm sử dụng thuốc thử tự chuẩn bị, pha chế hoặc sản xuất trong phòng xét nghiệm, ngoài các thông tin liên quan ở trên, chỉ dẫn đến người hoặc những người thực hiện việc chuẩn bị, cũng như ngày chuẩn bị và ngày hết hạn.

### Thỏa thuận dịch vụ

####  Thỏa thuận với người dùng phòng xét nghiệm

Phòng xét nghiệm phải có quy trình để thiết lập và xem xét định kỳ các thỏa thuận cung cấp các hoạt động của phòng xét nghiệm. Thủ tục phải bảo đảm:

  * các yêu cầu được quy định đầy đủ;

  * phòng xét nghiệm phải có khả năng và nguồn lực để đáp ứng các yêu cầu này;

  * Khi thích hợp, phòng xét nghiệm tư vấn cho người sử dụng các hoạt động cụ thể sẽ được thực hiện bởi các phòng xét nghiệm bên ngoài và chuyên gia tư vấn.


Người sử dụng phòng xét nghiệm phải được thông báo về mọi thay đổi đối với thỏa thuận có thể ảnh hưởng đến kết quả xét nghiệm.

Hồ sơ xem xét, bao gồm bất kỳ thay đổi quan trọng nào, phải được lưu giữ.

#### Thỏa thuận với bộ phận thực hiện POCT

Các thỏa thuận dịch vụ giữa phòng xét nghiệm và các bộ phận khác của tổ chức sử dụng POCT được phòng xét nghiệm hỗ trợ phải đảm bảo rằng các trách nhiệm và quyền hạn tương ứng được chỉ định và truyền đạt.

###  Các sản phẩm và dịch vụ do bên ngoài cung cấp

####  Tổng quát

Phòng xét nghiệm phải đảm bảo rằng các sản phẩm và dịch vụ do bên ngoài cung cấp có ảnh hưởng đến các hoạt động của phòng xét nghiệm là phù hợp khi các sản phẩm và dịch vụ đó:

  * dự định kết hợp vào các hoạt động riêng của phòng xét nghiệm;

  * được cung cấp, một phần hoặc toàn bộ, trực tiếp cho người sử dụng bởi phòng xét nghiệm, khi nhận được từ nhà cung cấp bên ngoài;

  * được sử dụng để hỗ trợ hoạt động của phòng xét nghiệm.


Có thể cần phải cộng tác với các bộ phận hoặc chức năng khác của tổ chức để đáp ứng yêu cầu này.

CHÚ THÍCH: Các dịch vụ bao gồm, ví dụ: dịch vụ lấy mẫu, pipet và các dịch vụ hiệu chuẩn khác, dịch vụ bảo trì cơ sở và thiết bị, chương trình EQA, phòng xét nghiệm bên ngoài và chuyên gia tư vấn.

#### Các phòng xét nghiệm và chuyên gia tư vấn bên ngoài

Phòng xét nghiệm phải truyền đạt các yêu cầu của mình cho các phòng xét nghiệm và các chuyên gia tư vấn bên ngoài cung cấp các giải thích và tư vấn, cho:

  * các thủ tục, kiểm tra, báo cáo và hoạt động tư vấn sẽ được cung cấp;

  * quản lý các kết quả quan trọng;

  * bất kỳ trình độ nhân sự cần thiết và chứng minh năng lực.


Trừ trường hợp được quy định trong thỏa thuận, chính phòng xét nghiệm (chứ không phải là phòng xét nghiệm bên ngoài) phải có trách nhiệm đảm bảo rằng các kết quả xét nghiệm của phòng xét nghiệm bên ngoài được cung cấp cho người yêu cầu.

Một danh sách tất cả các phòng xét nghiệm và chuyên gia tư vấn bên ngoài phải được duy trì.

#### Xem xét và phê duyệt các sản phẩm và dịch vụ do bên ngoài cung cấp

Phòng xét nghiệm phải có các thủ tục và lưu giữ hồ sơ về:

  * xác định, xem xét và phê duyệt các yêu cầu của phòng xét nghiệm đối với tất cả các sản phẩm và dịch vụ do bên ngoài cung cấp;

  * xác định tiêu chí đánh giá năng lực, lựa chọn, đánh giá kết quả thực hiện và đánh giá lại nhà cung cấp bên ngoài;

  * các mẫu tham chiếu; đảm bảo rằng các sản phẩm và dịch vụ do bên ngoài cung cấp phù hợp với các yêu cầu đã được thiết lập của phòng xét nghiệm, hoặc nếu có thể áp dụng cho các yêu cầu


| e) | thực hiện bất kỳ hành động nào phát sinh từ việc đánh giá kết quả
thực hiện của các nhà cung cấp bên ngoài. |  |
| --- | --- | --- |

 

## Yêu cầu về quá trình

### Tổng quát

Phòng xét nghiệm phải xác định các rủi ro tiềm ẩn đối với việc chăm sóc người bệnh trong các quy trình trước xét nghiệm, xét nghiệm và sau xét nghiệm. Những rủi ro này sẽ được đánh giá và giảm thiểu trong phạm vi có thể. Rủi ro còn lại sẽ được thông báo cho người dùng khi có thể.

Các rủi ro đã xác định và hiệu quả của các quy trình giảm thiểu rủi ro phải được theo dõi và đánh giá theo khả năng gây hại tiềm ẩn cho bệnh nhân.

Phòng xét nghiệm cũng phải xác định các cơ hội để cải thiện việc chăm sóc bệnh nhân và phát triển một khuôn khổ để quản lý những cơ hội này.

###  Quá trình trước xét nghiệm

#### Tổng quát

Phòng xét nghiệm phải có các thủ tục cho tất cả các hoạt động trước xét nghiệm và cung cấp sẵn có để tiếp cận được với các nhân viên có liên quan.

CHÚ THÍCH 1: Các quá trình trước xét ghiệm có thể ảnh hưởng đến kết quả của xét nghiệm dự kiến.

CHÚ THÍCH 2: ISO 20658 cung cấp thông tin chi tiết cho việc thu thập và vận chuyển mẫu.

CHÚ THÍCH 3: ISO 20186-1, ISO 20186-2, ISO 20186-3, ISO 20166 (tất cả các phần), ISO 20184 (tất cả các phần), ISO 23118 và ISO 4307 cung cấp thông tin chi tiết cho các mẫu từ các nguồn cụ thể và cho các xét nghiệm cụ thể.

#### Thông tin cho bệnh nhân và người dùng

Phòng xét nghiệm phải có sẵn thông tin thích hợp cho người dùng và bệnh nhân. Thông tin phải đủ chi tiết để cung cấp cho người sử dụng phòng xét nghiệm sự hiểu biết toàn diện về phạm vi hoạt động và yêu cầu của phòng xét nghiệm.

Thông tin phải bao gồm khi thích hợp:

  * (Các) địa điểm của phòng xét nghiệm, giờ hoạt động và thông tin liên lạc;

  * thủ tục yêu cầu và lấy mẫu;

  * phạm vi hoạt động của phòng xét nghiệm và thời gian dự kiến có kết quả;

  * sự sẵn có của các dịch vụ tư vấn;

# Public_009

# Học phần

## A – Phần bắt buộc:

### Những nguyên lý cơ bản của Chủ nghĩa Mác – Lênin

_Cấu trúc học phần:5_ (5:0:10)
_Mô tả học phần:_
Môn học Những nguyên lý cơ bản của Chủ nghĩa Mác – Lênin là môn học thuộc chương trình lý luận chính trị nhằm giới thiệu cho người học các kiến thức cơ bản về hệ thống lý luận của chủ nghĩa Mác – Lênin, bao gồm:

  * Thế giới quan và phương pháp luận triết học của Chủ nghĩa Mác – Lênin.

  * Học thuyết kinh tế của Chủ nghĩa Mác – Lênin về phương thức sản xuất tư bản chủ nghĩa.

  * Lý luận của Chủ nghĩa Mác – Lênin về chủ nghĩa xã hội.


### Tư tưởng Hồ Chí Minh

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Môn học tư tưởng Hồ Chí Minh là môn học thuộc chương trình Lý luận chính trị nhằm cung cấp cho người học những hiểu biết có tính hệ thống về:

  * Cơ sở hình thành tư tưởng Hồ Chí Minh

  * Những nội dung về tư tưởng, đạo đức, giá trị văn hoá Hồ Chí Minh.


### Đường lối cách mạng của Đảng cộng sản Việt Nam

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Nội dung chủ yếu của học phần là cung cấp, trang bị cho sinh viên những hiểu biết cơ bản có hệ thống về đường lối của Đảng, đặc biệt là đường lối trong thời kỳ đổi mới, trên một số lĩnh vực cơ bản của đời sống xã hội.

### Pháp luật đại cương

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần trang bị cho sinh viên tất cả các ngành những kiến thức cơ bản về những kiến thức lý luận cơ bản nhất về Nhà nước và pháp luật nói chung, nhà nước và pháp luật xã hội chủ nghĩa nói riêng. Từ đó giúp cho sinh viên có nhận thức, quan điểm đúng đắn về đường lối, chính sách của Đảng và pháp luật của Nhà nước ta. Đồng thời trang bị cho sinh viên những kiến thức cơ bản về hệ thống pháp luật Việt Nam và một số ngành luật cụ thể, giúp cho sinh viên hiểu biết hơn về pháp luật để vận dụng vào thực tiễn cuộc sống.

### Nhập môn ngành CNTT

_Cấu trúc học phần:_ 3(2:1:6)
_Mô tả học phần:_
Học phần Nhập Môn Ngành Công Nghệ Thông Tin được thiết kế để giúp sinh viên năm thứ nhất làm quen với môi trường học đại học, các kiến thức cơ bản của ngành, đồng thời hình thành các kỹ năng mềm và các chuẩn mực đạo đức, ứng xử cần có để sinh viên tiến bước thành công trên con trường trở thành kỹ sư công nghệ thông tin. Cụ thể, học phần này trang bị cho người học các kiến thức cơ bản của ngành về phần cứng, phần mềm, lập trình, mạng máy tính, cũng như các hiểu biết về lịch sử máy tính, các lĩnh vực nghiên cứu, xu hướng phát triển của ngành. Học phần cũng giúp người học phát triển các kỹ năng mềm hữu ích, như phương pháp học đại học, phương pháp hiểu bản thân, kỹ năng tìm kiếm thông tin, kỹ năng làm việc nhóm, kỹ năng thuyết trình; và hiểu biết về các chuẩn mực đạo đức, phẩm chất cần có, như trung thực, bền chí, kỷ luật, vị tha, khiêm tốn.

### Toán 1

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần Toán 1 cung cấp các kiến thức cơ bản về giới hạn, tính liên tục và phép tính vi tích phân của hàm một biến.

### Toán 2

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần Toán 2 cung cấp các kiến thức cơ bản về phép tính tích phân của hàm một biến, chuỗi số, chuỗi lũy thừa, véc-tơ trong mặt phẳng và trong không gian.

### Đại số và cấu trúc đại số

_Cấu trúc học phần:_ 4(4:0:8)
_Mô tả học phần:_
Môn học này bao gồm các kiến thức: Tập hợp, ánh xạ, quan hệ tương đương, quy nạp toán học; ma trận, định thức, hệ phương trình tuyến tính; không gian vectơ, không gian Euclide, ánh xạ tuyến tính, chéo hóa ma trận, dạng toàn phương; lý thuyết về một số cấu trúc đại số như nhóm, vành, trường; và một số ứng dụng như các mô hình tuyến tính, đồ họa máy tính, mã hóa, mật mã,….

### Xác suất thống kê và ứng dụng

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Môn học này bao gồm thống kê mô tả, xác suất sơ cấp, biến ngẫu nhiên và luật phân phối xác suất, các số đặc trưng của biến ngẫu nhiên, ước lượng tham số, kiểm định giả thuyết, tương quan và hồi quy tuyến tính.

### Vật lý 1

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Học phần này cung cấp cho sinh viên những nội dung cơ bản của vật lý bao gồm các phần cơ học và nhiệt học làm cơ sở cho việc tiếp cận các môn học chuyên ngành trình độ đại học các ngành khoa học, kỹ thuật và công nghệ. Sinh viên sẽ được trang bị các kiến thức về vật lý để khảo sát sự chuyển động, năng lượng và các hiện tượng vật lý liên quan đến các đối tượng trong tự nhiên có kích thước từ phân tử đến cỡ hành tinh. Sau khi học xong học phần sinh viên sẽ có khả năng ứng dụng những kiến thức đã học trong nghiên cứu khoa học cũng như trong phát triển kỹ thuật và công nghệ hiện đại.
Nội dung của học phần gồm các chương từ 1 đến 22 trong sách _Physics for Scientists and Engineers with Modern Physics_ , 9th Edition của các tác giả R.A. Serway và J.W. Jewett. Các nội dung của học phần này nhằm giúp sinh viên làm quen với phương pháp khoa học, các định luật cơ bản của vật lý, phát triển hiểu biết về khoa học vật lý nói chung và kỹ năng lập luận cũng như các chiến lược để chuẩn bị cho việc học tập các lớp khoa học chuyên ngành trong chương trình dành cho kỹ sư. Để đạt mục tiêu này, học phần sẽ chú trọng vào việc kết hợp cung cấp những hiểu biết về các khái niệm với các kỹ năng giải các bài tập dạng chuẩn (làm ở nhà) ở cuối mỗi chương.
Bên cạnh đó, học phần sẽ giúp sinh viên hiểu cách xây dựng các mô hình toán học dựa trên các kết quả thực nghiệm, biết cách ghi nhận, trình bày, phân tích số liệu và phát triển một mô hình dựa trên các dữ liệu và có thể sử dụng mô hình này để phán đoán kết quả của các thí nghiệm khác. Đồng thời, sinh viên sẽ biết được giới hạn của mô hình và có thể sử dụng chúng trong việc phán đoán.

### Thí nghiệm vật lý 1

_Cấu trúc học phần:_ 1(0:1:2)
_Mô tả học phần:_
Thí nghiệm Vật lý 1 gồm một đơn vị học phần có 9 bài thí nghiệm về động học, động lực học chất điểm và động lực học vật rắn. Đây là môn học bổ sung cho sinh viên thuộc khối ngành công nghệ hệ cao đẳng và đại học những kiến thức về bản chất các hiện tượng vật lý xảy ra trong tự nhiên, kiểm tra lại các lý thuyết vật lý đã được học trong chương trình nhằm rèn luyện cho các kỹ sư tương lai kỹ năng quan sát, tiến hành thí nghiệm, đo đạc và tính toán, phân tích, xử lý số liệu.

### Điện tử căn bản

_Cấu trúc học phần:_ 3(3:0:6)
_Mô tả học phần:_
Cung cấp cho sinh viên ngành công nghệ thông tin các kiến thức chung cơ bản và phương pháp phân tích, tính toán các mạch điện và mạch điện tử căn bản thường sử dụng trong thực tế như: mạch điện một chiều, mạch điện xoay chiều, mạch chỉnh lưu, mạch ổn áp, mạch ngắt dẫn dùng BJT, mạch khuếch đại tín hiệu, mạch dao động ...

### Thực tập điện tử căn bản

Môn học này hướng dẫn sinh viên thực hành các mạch kỹ thuật điện tử như mạch chỉnh lưu, mạch xén, mạch nguồn DC, mạch khuếch đại tín hiệu nhỏ, mạch transistor ngắt dẫn, mạch dao động, các mạch điều khiển dùng SCR, TRAC, DIAC, quang trở, op-to, các mạch đếm và thanh ghi và các mạch điện tử ứng dụng trong thực tế.

### Kinh tế học đại cương

_Cấu trúc học phần: 5_ (5:0:10)
_Mô tả học phần:_
Môn Kinh tế học đại cương cung cấp cho sinh viên không chuyên ngành kinh tế những kiến thức cơ bản về kinh tế, những hiện tượng thực tế đang diễn ra trong nền kinh tế dưới góc độ vi mô cũng như vĩ mô.

### Nhập môn quản trị chất lượng

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học những kiến thức cơ bản về chất lượng và quản trị chất lượng. Học phần giới thiệu một số chỉ tiêu và phương pháp đánh giá chất lượng trong tổ chức, đồng thời hướng dẫn sinh viên sử dụng các phương pháp, kỹ thuật và công cụ để quản lý chất lượng. Học phần cung cấp những kiến thức về cách xây dựng và áp dụng hệ thống quản lý chất lượng theo tiêu chuẩn trong các doanh nghiệp.

### Nhập môn quản trị học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học những kiến thức cơ bản về quản trị, bao gồm những yếu tố môi trường tổng quát nhất tác động đến doanh nghiệp và những chức năng cơ bản của quản trị trong tổ chức kinh doanh, bao gồm: hoạch định, tổ chức, lãnh đạo, và kiểm tra.
Bên cạnh đó, các hoạt động trên lớp được thiết kế để nâng cao kỹ năng tìm kiếm thông tin, nói chuyện trước đám đông, tư duy phản biện của sinh viên.

### Kỹ năng học tập đại học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Môn học “Kỹ năng học tập đại học” trang bị cho người học những kiến thức về phương pháp học tập để sinh viên vận dụng hình thành các kỹ năng học tập ở bậc đại học, nhằm nâng cao hiệu quả học tập và nghiên cứu của bản thân. Qua môn học này hình thành ở người học khả năng tổ chức và thực hiện học tập một cách hệ thống, logic và khoa học.

### Kỹ năng làm việc trong môi trường kỹ thuật

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_

Môn học Kỹ năng làm việc trong môi trường kỹ thuật thuộc nhóm môn học tự chọn của khối ngành kỹ thuật công nghệ. Môn học này nhằm hình thành cho sinh viên một số kỹ năng làm việc cơ bản trong môi trường kỹ thuật, đặc biệt là các kỹ năng làm việc trong môi trường đa văn hóa, hiện đại, có sự thay đổi nhanh chóng về công nghệ, như: Kỹ năng (KN) giao tiếp kỹ thuật; KN tư duy sáng 5

tạo; KN giải quyết vấn đề và ra quyết định; KN lập kế hoạch thực hiện dự án; KN làm việc nhóm; KN trình bày ý tưởng/vấn đề kỹ thuật; KN viết tài liệu/báo cáo kỹ thuật; KN sử dụng công nghệ thông tin trong công việc; KN quản lý bản thân.

### Kỹ năng xây dựng kế hoạch

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học những kiến thức cơ bản về phương pháp xây dựng kế hoạch. Hướng dẫn cho người học các kỹ năng tư duy và tìm kiếm giải pháp phù hợp với điều kiện và hoàn cảnh bản thân để từ đó người học hình thành cho mình kỹ năng xây dựng kế hoạch học tập, kế hoạch cá nhân ngắn hạn và dài hạn, kế hoạch cho công việc phù hợp và hiệu quả. Ngoài ra còn hướng dẫn người học cách thức và kỹ năng quản lí thời gian và sắp xếp công việc hiệu quả.

### Phương pháp nghiên cứu khoa học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Trong quá trình đào tạo ở trường Đại học, sinh viên không chỉ lĩnh hội tri thức từ phía giáo viên, mà học còn phải tự học và tự nghiên cứu. Từ tự giác, tích cực và sáng tạo, sinh viên sẽ tìm ra cái mới nhằm giải thích sâu sắc hay có lời giải phù hợp đó chính là sinh viên đã nghiên cứu khoa học. Học phần Phương pháp nghiên cứu khoa học bao gồm những nội dung về các khái niệm, qui trình và cấu trúc... Để từ đó sinh viên định hướng được việc lựa chọn đề tài nghiên cứu, soạn được đề cương và áp dụng được các phương pháp nghiên cứu trong khi thu thập và xử lý thông tin hợp lý trong khi tiến hành công trình nghiên cứu khoa học. Sinh viên sẽ chủ động trong việc đang ký thực hiện đề tài nghiên cứu cấp trường cũng như tiến hành luận văn tốt nghiệp hay đồ án tốt nghiệp một cách khoa học và thành công.

### Tâm lý học kỹ sư

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Để tạo nên sự tương tác giữa công nghệ và con người, sinh viên các ngành kỹ thuật công nghệ cần hiểu được đặc điểm tâm lý cơ bản của con người. Học phần Tâm lý học kỹ sư sẽ cung cấp cho sinh viên các ngành kỹ thuật công nghệ các kiến thức về tâm lý con người và ứng dụng các kiến thức này vào thiết kế hệ thống kỹ thuật phù hợp với con người.

### Tư duy hệ thống

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_ Học phần Tư duy hệ thống trang bị cho sinh viên những kiến thức cơ bản về hệ thống, phương pháp luận tư duy hệ thống, các phương pháp tư duy sáng tạo; hình thành ở sinh viên khả năng lập luận và giải quyết vấn đề một cách hệ thống, logic và sáng tạo.

### Nhập môn logic học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này trang bị cho người học kiến thức về quá trình nhận thức của con người nhận thức và bản chất của hoạt động tư duy. Người học được cung cấp kiến thức về các quy luật cơ bản của tư duy và các hình thức của tư duy qua đó rèn luyện tư duy logic, có thể sử dụng chính xác từ, câu trong diễn đạt tư tưởng, có kỹ năng lập luận, diễn giải cũng như chứng minh, bác bỏ vấn đề có sức thuyết phục, suy nghĩ chín chắn, nhất quán, khắc phục những sai phạm trong tư duy, trong giao tiếp.

### Nhập môn xã hội học

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần trang bị cho sinh viên không chuyên ngành xã hội học, trường Đại học Sư phạm Kỹ thuật TP.HCM những kiến thức cơ bản về hệ thống lý luận Xã hội học, lịch sử hình thành và phát triển của ngành khoa học xã hội trong tiến trình phát triển của nhận thức, tiến bộ xã hội và khoa học kỹ thuật; các khái niệm, phạm trù và các lĩnh vực nghiên cứu chính của khoa học xã hội học trong đời sống con người thông qua các phương pháp và kỹ thuật nghiên cứu, học tập môn học xã hội học.

### Cơ sở văn hoá Việt Nam

_Cấu trúc học phần:_ 2(2:0:4)
_Mô tả học phần:_
Học phần này được thiết kế cho sinh viên năm thứ hai ở bậc đại học nhằm cung cấp cho sinh viên những kiến thức cơ bản về văn hoá nói chung, văn hoá Việt Nam nói riêng; giúp sinh viên nắm bắt những đặc trưng cơ bản của văn hoá Việt Nam từ truyền thống đến hiện đại; biết tự định hướng trong thế giới thông tin đa dạng, đa chiều hiện nay, tiếp thu có chọn lọc những tinh hoa văn hoá của nhân loại trên nền tảng bảo tồn và phát triển những giá trị truyền thống tốt đẹp của dân tộc và con người Việt Nam một cách chủ động, tích cực. Bên cạnh đó, học phần này còn giúp hỗ trợ cho sinh viên hình thành và rèn luyện một số kỹ năng học tập tích cực như: kỹ năng tìm kiếm tài liệu tham khảo, kỹ năng thuyết trình trước đám đông, kỹ năng làm việc nhóm.

# Public_010

# Tiêu chuẩn phòng xét nghiệm

## Lập kế hoạch liên tục và chuẩn bị cho tình huống khẩn cấp

Phòng xét nghiệm phải đảm bảo rằng các rủi ro liên quan đến các tình huống khẩn cấp hoặc các điều kiện khác khi các hoạt động của phòng xét nghiệm bị hạn chế hoặc không khả dụng, đã được xác định và tồn tại một chiến lược phối hợp bao gồm các kế hoạch, các quy trình, và biện pháp kỹ thuật để cho phép tiếp tục hoạt động sau khi bị gián đoạn.
Các kế hoạch phải được kiểm tra định kỳ và khả năng ứng phó theo kế hoạch được thực hiện, nếu có thể.
Phòng xét nghiệm có trách nhiệm:

  * thiết lập một kế hoạch ứng phó với các tình huống khẩn cấp, có tính đến nhu cầu và khả năng của tất cả các nhân viên phòng xét nghiệm có liên quan;

  * cung cấp thông tin và đào tạo thích hợp cho nhân viên phòng xét nghiệm có liên quan;

  * ứng phó với các tình huống khẩn cấp trong thực tế;

  * hành động để ngăn chặn hoặc giảm thiểu hậu quả của các tình huống khẩn cấp, phù hợp với mức độ khẩn cấp và tác động tiềm tàng.


CHÚ THÍCH: CLSI GP36-A [35] cung cấp thêm chi tiết.

## Yêu cầu hệ thống quản lý

### Yêu cầu chung

#### Tổng quát

Phòng xét nghiệm phải thiết lập, lập thành văn bản, thực hiện và duy trì một hệ thống quản lý để hỗ trợ và chứng minh việc đáp ứng nhất quán các yêu cầu của tiêu chuẩn này.
Tối thiểu, hệ thống quản lý của phòng xét nghiệm phải bao gồm những nội dung sau đây:

  * Trách nhiệm

  * Mục tiêu và chính sách

  * Thông tin tài liệu

  * Hành động để giải quyết rủi ro và cơ hội cải tiến

  * Cải tiến liên tục

  * Hành động khắc phục

  * Đánh giá và đánh giá nội bộ

  * Xem xét của lãnh đạo


#### Đáp ứng các yêu cầu của hệ thống quản lý

Phòng xét nghiệm có thể đáp ứng 8.1.1 bằng cách thiết lập, thực hiện và duy trì hệ thống quản lý chất lượng (ví dụ: phù hợp với các yêu cầu của ISO 9001) (xem Bảng B.1). Hệ thống quản lý chất lượng này phải hỗ trợ và chứng minh sự đáp ứng nhất quán các yêu cầu từ điều 4 đến điều 7 và các yêu cầu được quy định trong 8.2 đến 8.9.

#### Nhận thức về hệ thống quản lý

Phòng xét nghiệm phải bảo đảm rằng những người làm công việc dưới sự kiểm soát của phòng xét nghiệm nhận thức được:

  * các mục tiêu và chính sách có liên quan;

  * đóng góp của họ vào hiệu quả của hệ thống quản lý, bao gồm cả lợi ích của việc cải thiện hiệu suất;

  * hậu quả của việc không phù hợp với các yêu cầu của hệ thống quản lý.


### Tài liệu hệ thống quản lý

####  Tổng quát

Ban lãnh đạo phòng xét nghiệm phải thiết lập, lập thành văn bản và duy trì các mục tiêu và chính sách để thực hiện các mục đích của tài liệu này và phải đảm bảo rằng các mục tiêu và chính sách được thừa nhận và thực hiện ở tất cả các cấp của tổ chức phòng xét nghiệm.
CHÚ THÍCH: Các tài liệu của hệ thống quản lý có thể, nhưng không bắt buộc, được đưa vào sổ tay chất lượng.

#### Năng lực và chất lượng

Các mục tiêu và chính sách phải đề cập đến năng lực, chất lượng và hoạt động nhất quán của phòng xét nghiệm.

#### Bằng chứng cam kết

Lãnh đạo phòng xét nghiệm phải cung cấp bằng chứng về cam kết xây dựng, thực hiện và cải tiến liên tục hiệu lực của hệ thống quản lý.

####  Tài liệu

Tất cả tài liệu, quy trình, hệ thống và hồ sơ liên quan đến việc đáp ứng các yêu cầu của tiêu chuẩn này phải được đưa vào, tham chiếu từ hoặc liên kết với hệ thống quản lý.

####  Tiếp cận của nhân viên

Tất cả nhân viên tham gia vào các hoạt động của phòng xét nghiệm phải có quyền truy cập vào các phần của tài liệu hệ thống quản lý và thông tin liên quan áp dụng cho trách nhiệm của họ.

### Kiểm soát tài liệu hệ thống quản lý

#### Tổng quát

Phòng xét nghiệm phải kiểm soát các tài liệu (nội bộ và bên ngoài) liên quan đến việc thực hiện tiêu chuẩn này.
CHÚ THÍCH: Trong ngữ cảnh này, "tài liệu" có thể là tuyên bố chính sách, quy trình và hướng dẫn công việc liên quan,
lưu đồ, hướng dẫn sử dụng, thông số kỹ thuật, hướng dẫn của nhà sản xuất, bảng hiệu chuẩn, khoảng tham chiếu sinh
học và nguồn gốc của chúng, biểu đồ, áp phích, thông báo, bản ghi nhớ, tài liệu phần mềm, bản vẽ, kế hoạch, thỏa thuận
và các tài liệu có nguồn gốc bên ngoài như luật, quy định, tiêu chuẩn và sách giáo khoa để lấy phương pháp xét nghiệm,
tài liệu mô tả trình độ nhân sự (như mô tả công việc), v.v. Những tài liệu này có thể ở bất kỳ dạng hoặc loại nào của phương tiện, chẳng hạn như bản cứng hoặc kỹ thuật số.

####  Kiểm soát tài liệu

Phòng xét nghiệm phải đảm bảo rằng:

  * các tài liệu được xác định là duy nhất;

  * các tài liệu được phê duyệt về tính phù hợp trước khi ban hành bởi nhân viên có chuyên môn, và năng lực, đủ thẩm quyền để xác định tính phù hợp của tài liệu;

  * tài liệu được xem xét định kỳ và cập nhật khi cần thiết;

  * các phiên bản liên quan của các tài liệu áp dụng có sẵn tại nơi sử dụng và, khi cần thiết, việc phân phối chúng được kiểm soát;

  * những thay đổi và trạng thái sửa đổi hiện tại của các tài liệu được nhận biết;

  * các tài liệu được bảo vệ khỏi những thay đổi trái phép và bất kỳ việc việc xóa hoặc loại bỏ nào;

  * các tài liệu được bảo vệ khỏi truy cập trái phép;

  * ngăn ngừa việc sử dụng ngoài ý muốn các tài liệu lỗi thời và áp dụng cách nhận dạng phù hợp cho chúng nếu chúng được giữ lại cho bất kỳ mục đích nào;

  * Ít nhất một bản sao giấy hoặc điện tử của tài liệu lỗi thời được kiểm soát phải được giữ lại trong một khoảng thời gian quy định hoặc theo yêu cầu quy định thích hợp.


### Kiểm soát hồ sơ

#### Tạo hồ sơ

Phòng xét nghiệm phải thiết lập và lưu giữ các hồ sơ rõ ràng để chứng minh việc đáp ứng các yêu cầu của tài liệu này.
Hồ sơ phải được lập vào thời điểm mỗi hoạt động có ảnh hưởng đến chất lượng của xét nghiệm được thực hiện.
CHÚ THÍCH: Hồ sơ có thể ở bất kỳ hình thức hoặc loại phương tiện nào.

#### Sửa đổi hồ sơ

Phòng xét nghiệm phải đảm bảo rằng các sửa đổi đối với hồ sơ có thể được truy nguyên tới các phiên bản trước đó hoặc các quan sát ban đầu. Cả các tệp và dữ liệu gốc và dữ liệu sửa đổi đều phải được lưu giữ, bao gồm ngày và nếu có liên quan, thời gian, thay đổi, chỉ dẫn về các khía cạnh đã thay đổi và nhân viên thực hiện các thay đổi.

#### Lưu giữ hồ sơ

  * Phòng xét nghiệm phải thực hiện các thủ tục cần thiết để xác định, lưu trữ, bảo vệ khỏi truy cập và thay đổi trái phép, sao lưu, lưu trữ, truy xuất, thời gian lưu giữ và hủy bỏ hồ sơ của mình.

  * Thời gian lưu giữ hồ sơ phải được xác định cụ thể.


CHÚ THÍCH 1: Ngoài các yêu cầu, thời gian lưu giữ có thể được chọn dựa trên các rủi ro đã xác định.

  * Các kết quả xét nghiệm đã báo cáo phải truy xuất được trong khoảng thời gian cần thiết hoặc theo quy định.

  * Tất cả các hồ sơ phải truy cập được trong toàn bộ thời gian lưu giữ, có thể đọc được trong bất kỳ phương tiện nào mà phòng xét nghiệm lưu giữ hồ sơ và sẵn có để lãnh đạo phòng xét nghiệm xem xét


CHÚ THÍCH 2: Vấn đề trách nhiệm pháp lý liên quan đến một số loại thủ tục nhất định (ví dụ như các xét nghiệm mô học, các xét nghiệm di truyền, các xét nghiệm nhi khoa) có thể yêu cầu việc lưu giữ một số hồ sơ trong khoảng thời gian dài hơn rất nhiều so với các hồ sơ khác.

### Các hành động để giải quyết rủi ro và cơ hội cải tiến

####  Xác định rủi ro và cơ hội cải tiến

Phòng xét nghiệm phải xác định các rủi ro và cơ hội cải tiến liên quan đến các hoạt động của phòng xét nghiệm để:

  * ngăn ngừa hoặc giảm thiểu các tác động không mong muốn và các sai sót tiềm ẩn trong các hoạt động của phòng xét nghiệm;

  * đạt được sự cải tiến, bằng cách hành động dựa trên các cơ hội;

  * đảm bảo rằng hệ thống quản lý đạt được các kết quả dự kiến;

  * giảm thiểu rủi ro đối với việc chăm sóc bệnh nhân;

  * giúp đạt được mục đích và mục tiêu của phòng xét nghiệm.


####  Hành động dựa trên rủi ro và cơ hội cải tiến

Phòng xét nghiệm phải ưu tiên và hành động đối với các rủi ro đã xác định. Các hành động được thực hiện để giải quyết rủi ro phải tỷ lệ thuận với tác động tiềm ẩn đối với các kết quả xét nghiệm trong phòng xét nghiệm, cũng như sự an toàn của bệnh nhân và nhân viên.
Phòng xét nghiệm phải ghi lại các quyết định đã đưa ra và các hành động được thực hiện đối với các rủi ro và cơ hội.
Phòng xét nghiệm phải tích hợp và thực hiện các hành động đối với các rủi ro đã xác định và các cơ hội cải tiến vào hệ thống quản lý của mình và đánh giá hiệu quả của chúng.
CHÚ THÍCH 1: Các lựa chọn để giải quyết rủi ro có thể bao gồm xác định và tránh các mối đe dọa, loại bỏ nguồn rủi ro, giảm khả năng xảy ra hoặc hậu quả của rủi ro, chuyển giao rủi ro, chấp nhận rủi ro để theo đuổi cơ hội cải tiến hoặc chấp nhận rủi ro bằng quyết định sáng suốt.
CHÚ THÍCH 2: Mặc dù tài liệu này yêu cầu phòng xét nghiệm xác định và giải quyết các rủi ro nhưng không có yêu cầu đối với bất kỳ phương pháp quản lý rủi ro cụ thể nào. Các phòng xét nghiệm có thể sử dụng ISO 22367 và ISO 35001 để được hướng dẫn.
CHÚ THÍCH 3: Cơ hội cải tiến có thể dẫn đến việc mở rộng phạm vi hoạt động của phòng xét nghiệm, áp dụng công nghệ mới hoặc tạo ra các khả năng khác để đáp ứng nhu cầu của bệnh nhân và người dùng.

### Cải tiến

####  Cải tiến liên tục

  * Phòng xét nghiệm phải cải tiến liên tục hiệu quả của hệ thống quản lý, bao gồm các quy trình trước xét nghiệm, xét nghiệm và sau xét nghiệm như đã nêu trong các mục tiêu và chính sách.

  * Phòng xét nghiệm phải xác định và lựa chọn các cơ hội để cải tiến và phát triển, lập thành văn bản và thực hiện mọi hành động cần thiết. Các hoạt động cải tiến phải được hướng vào các lĩnh vực có mức độ ưu tiên cao nhất dựa trên đánh giá rủi ro và các cơ hội đã được xác định


CHÚ THÍCH: Các cơ hội để cải tiến có thể được xác định thông qua đánh giá rủi ro, sử dụng các chính sách, xem xét các quy trình vận hành, mục tiêu tổng thể, báo cáo đánh giá bên ngoài, kết quả đánh giá nội bộ, khiếu nại, hành động khắc phục, xem xét của lãnh đạo, đề xuất từ nhân viên, đề xuất hoặc phản hồi từ bệnh nhân và người dùng, phân tích dữ liệu và kết quả EQA.

  * Phòng xét nghiệm phải đánh giá hiệu quả của các hành động được thực hiện.

  * Lãnh đạo phòng xét nghiệm phải đảm bảo rằng phòng xét nghiệm tham gia vào các hoạt động cải tiến liên tục bao gồm các lĩnh vực và kết quả chăm sóc bệnh nhân có liên quan.


  * Lãnh đạo phòng xét nghiệm phải trao đổi với nhân viên về kế hoạch cải tiến của mình và các mục tiêu liên quan.


####  Phản hồi của bệnh nhân, người dùng và nhân viên phòng xét nghiệm

Phòng xét nghiệm phải tìm kiếm phản hồi từ bệnh nhân, người dùng và nhân viên của mình. Phản hồi phải được phân tích và sử dụng để cải thiện hệ thống quản lý, các hoạt động của phòng xét nghiệm và dịch vụ cho người dùng. Hồ sơ phản hồi phải được duy trì bao gồm cả các hành động được thực hiện. Phải thông báo cho nhân viên về các hành động được thực hiện phát sinh từ phản hồi của họ.

### Sự không phù hợp và hành động khắc phục

#### Các hành động khi xảy ra sự không phù hợp

Khi xảy ra sự không phù hợp, phòng xét nghiệm phải:

  * Phản hồi về sự không phù hợp và, khi thích hợp:

* có hành động ngay lập tức để kiểm soát và khắc phục sự không phù hợp;

* giải quyết các hậu quả, đặc biệt tập trung vào sự an toàn của bệnh nhân bao gồm cả việc cáo cáo cho người thích hợp.

  * Xác định (các) nguyên nhân của sự không phù hợp.

  * Đánh giá sự cần thiết của hành động khắc phục để loại bỏ (các) nguyên nhân của sự không phù hợp, nhằm giảm khả năng tái diễn hoặc xảy ra ở nơi khác, bằng cách:

* xem xét và phân tích sự không phù hợp;

* xác định xem có tồn tại hoặc có khả năng xảy ra sự không phù hợp tương tự hay không;

* đánh giá (các) rủi ro tiềm ẩn và (các) ảnh hưởng nếu sự không phù hợp tái diễn.

  * Thực hiện mọi hành động cần thiết.

  * Xem xét và đánh giá hiệu quả của mọi hành động khắc phục đã được thực hiện.

  * Cập nhật rủi ro và cơ hội để cải tiến, khi cần.

  * Thực hiện các thay đổi đối với hệ thống quản lý, nếu cần thiết.


####  Hiệu quả của hành động khắc phục

Các hành động khắc phục phải phù hợp với tác động của sự không phù hợp gặp phải và phải giảm thiểu (các) nguyên nhân đã xác định.

#### Hồ sơ về sự không phù hợp và hành động khắc phục

Phòng xét nghiệm phải lưu giữ hồ sơ làm bằng chứng về

  * bản chất của sự không phù hợp, (các) nguyên nhân và mọi hành động tiếp theo được thực hiện, và

  * đánh giá hiệu quả của mọi hành động khắc phục.


###  Đánh giá

#### Tổng quát

Phòng xét nghiệm phải tiến hành đánh giá theo các khoảng thời gian theo kế hoạch để chứng minh rằng việc quản lý, hỗ trợ và các quy trình trước xét nghiệm, xét nghiệm và sau xét nghiệm đáp ứng nhu cầu và yêu cầu của bệnh nhân và người sử dụng phòng xét nghiệm, đồng thời đảm bảo tuân thủ với các yêu cầu của tài liệu này.

#### Chỉ tiêu chất lượng

Quá trình giám sát các chỉ số chất lượng [xem 5.5 d)] phải được lập kế hoạch, bao gồm thiết lập các mục tiêu, phương pháp luận, diễn giải, giới hạn, kế hoạch hành động và thời gian giám sát. Các chỉ số phải được xem xét định kỳ, để đảm bảo tính phù hợp liên tục.

####  Đánh giá nội bộ

##### Phòng xét nghiệm phải tiến hành đánh giá nội bộ theo các khoảng thời gian dự kiến để cung cấp thông tin về việc hệ thống quản lý có

  * phù hợp với các yêu cầu riêng của phòng xét nghiệm đối với hệ thống quản lý, bao gồm tất cả các hoạt động của phòng xét nghiệm,

  * phù hợp với các yêu cầu của tài liệu này, và

  * được thực hiện và duy trì hiệu quả.


Phòng xét nghiệm phải lập kế hoạch, thiết lập, thực hiện và duy trì một chương trình đánh giá nội bộ bao gồm:

  * ưu tiên đối với rủi ro cho bệnh nhân từ các hoạt động của phòng xét nghiệm;

  * lịch trình có tính đến các rủi ro đã xác định; kết quả của cả đánh giá bên ngoài và đánh giá nội bộ trước đó; sự xuất hiện của những sự không phù hợp, sự cố và khiếu nại; và những thay đổi ảnh hưởng đến hoạt động của phòng xét nghiệm;

  * quy định cụ thể mục tiêu, chuẩn mực và phạm vi đánh giá cho từng cuộc đánh giá;

  * lựa chọn các chuyên gia đánh giá được đào tạo, có năng lực và được ủy quyền để đánh giá kết quả hoạt động của hệ thống quản lý của phòng xét nghiệm, và khi các nguồn lực cho phép, độc lập với hoạt động được đánh giá;

  * bảo đảm tính khách quan và công bằng của quá trình đánh giá;

  * đảm bảo rằng các kết quả đánh giá được báo cáo cho những người có liên quan;

  * thực hiện ngay các hành động thích hợp khi xác định được sự không phù hợp;

  * lưu giữ hồ sơ làm bằng chứng về việc thực hiện chương trình đánh giá và kết quả đánh giá.


CHÚ THÍCH: ISO 19011 cung cấp hướng dẫn cho đánh giá hệ thống quản lý.

### Xem xét của lãnh đạo

#### Tổng quát

Lãnh đạo phòng xét nghiệm phải xem xét hệ thống quản lý của mình theo các khoảng thời gian đã hoạch định để đảm bảo tính phù hợp, đầy đủ và hiệu quả liên tục của hệ thống, bao gồm các chính sách và mục tiêu đã nêu liên quan đến việc thực hiện tài liệu này.

#### Đầu vào của xem xét

Đầu vào của việc xem xét của lãnh đạo phải được ghi lại và phải bao gồm các xem xét về ít nhất những nội dung sau:

  * tình trạng của các hành động từ các cuộc xem xét của lãnh đạo trước đó, những thay đổi bên trong và bên ngoài đối với hệ thống quản lý, những thay đổi về khối lượng và loại hình hoạt

  * động của phòng xét nghiệm và sự đầy đủ của các nguồn lực;

  * hoàn thành các mục tiêu và sự phù hợp của các chính sách và thủ tục;

  * kết quả của các đánh giá gần đây, giám sát quá trình sử dụng các chỉ số chất lượng, đánh giá nội bộ, phân tích sự không phù hợp, hành động khắc phục, đánh giá của các cơ quan bên ngoài;

  * phản hồi và khiếu nại của bệnh nhân, người sử dụng và nhân viên;

  * đảm bảo chất lượng về hiệu lực của kết quả;

  * hiệu quả của mọi cải tiến và các hành động được thực hiện để giải quyết các rủi ro và cơ hội cải tiến;

  * hiệu quả của các nhà cung cấp bên ngoài;

  * kết quả tham gia các chương trình so sánh liên phòng;

  * đánh giá các hoạt động POCT;

  * các yếu tố liên quan khác, chẳng hạn như các hoạt động giám sát và đào tạo.


####  Đầu ra của xem xét

Đầu ra của hoạt động xem xét của lãnh đạo phải là hồ sơ về các quyết định và hành động liên quan đến ít nhất:

  * hiệu lực của hệ thống quản lý và các quá trình của nó;

  * cải tiến các hoạt động của phòng xét nghiệm liên quan đến việc đáp ứng các yêu cầu của tài liệu này;

  * cung cấp các nguồn lực cần thiết;

  * cải thiện dịch vụ cho bệnh nhân và người dùng;

  * mọi nhu cầu thay đổi.


Lãnh đạo phòng xét nghiệm phải đảm bảo rằng các hành động phát sinh từ việc xem xét của lãnh đạo phải được hoàn thành trong một khung thời gian xác định.
Các kết luận và hành động phát sinh từ cuộc họp xem xét của lãnh đạo phải được thông báo cho nhân viên phòng xét nghiệm.

# Public_011

# Lịch sử phát triển của mạng máy tính

_Khái niệm mạng máy tính:_

_**Mạng máy tính**_ hay _**mạng**_ ( _computer network, network_ ) là một tập hợp gồm nhiều máy tính hoặc thiết bị xử lý thông tin được kết nối với nhau qua các đường truyền và có sự trao đổi dữ liệu với nhau.

Nhờ có mạng máy tính, thông tin từ một máy tính có thể được truyền sang máy tính khác. Có thể ví mạng máy tính như một hệ thống giao thông vận tải mà hàng hoá trên mạng là dữ liệu, máy tính là nhà máy lưu trữ xử lý dữ liệu, hệ thống đường truyền như là hệ thống đường sá giao thông.

_Ví dụ về mạng_ :

  * Mạng tại Trung tâm Máy tính, Khoa CNTT, Trường ĐHBK Hà Nội

  * Mạng của Tổng cục thuế

  * Mạng Internet


_Lịch sử phát triển của mạng:_

  * Máy tính ra đời từ những năm 1950. Đến đầu những năm 1960 mạng máy tính bắt đầu xuất hiện. Lúc đầu mạng có dạng là một máy tính lớn nối với nhiều trạm cuối ( _terminal_ ). Đến đầu những năm 1970 mạng máy tính là các máy tính độc lập được nối với nhau. Qui mô và mức độ phức tạp của mạng ngày càng tăng.

  * Hiện nay mạng máy tính phát triển rất mạnh ở mọi lĩnh vực mọi nơi. Ngày càng hiếm các máy tính đơn lẻ, không nối mạng. Ngay các máy tính cá nhân ở gia đình cũng được kết nối Internet qua đường điện thoại. Mạng trở thành một yếu tố không thể thiếu của công nghệ thông tin nói riêng, cũng như đời sống nói chung.


# Phân loại mạng máy tính

Có nhiều cách phân loại mạng máy tính. Sau đây là một số cách phân loại thông dụng.

_Cách 1._ Theo mối quan hệ giữa các máy trong mạng

  * _Mạng bình đẳng (peer-to-peer)_ các máy có quan hệ ngang hàng, một máy có thể yêu cầu một máy khác phục vụ.

  * _Mạng khách/chủ_ ( _client/server_ ). Một số máy là server (máy chủ) chuyên phục vụ các máy khác gọi là máy khách (client) hay máy trạm (workstation) khi có yêu cầu. Các dịch vụ có thể là cung cấp thông tin, tính toán hay các dịch vụ Internet.


_Cách 2._ Theo qui mô địa lý. Tuỳ theo qui mô địa lý, có thể phân ra ba loại chính là:

  * _LAN_ ( _Local Area Network)_ mạng cục bộ ở trong phạm vi nhỏ, ví dụ bán kính 500m, số lượng máy tính không quá nhiều, mạng không quá phức tạp.

  * _WAN (Wide Area Network)_ mạng diện rộng, các máy tính có thể ở các thành phố khác nhau. Bán kính có thể 100-200 km. Ví dụ mạng của Tổng cục thuế.

  * _GAN (Global Area Network)_ mạng toàn cầu, máy tính ở nhiều nước khác nhau. Thường mạng toàn cầu là kết hợp của nhiều mạng con. Ví dụ mạng Internet.


# Các thành phần cơ bản của một mạng máy tính

Một mạng máy tính có thể có các thành phần sau:

  * _Các máy tính_

* Để xử lý, lưu trữ và trao đổi thông tin. Ta cũng thường gọi mỗi máy tính trong mạng máy tính là một _nút_ của mạng.

  * _Vỉ mạng_

* Vỉ mạng (Network Interface Card, NIC) cho mỗi máy tính có chức năng giao tiếp giữa máy tính và đường truyền.

  * _Đường truyền_

* Đường truyền, chính xác hơn còn gọi là đường truyền vật lý, là phương tiện (media) truyền tải thông tin dữ liệu, là nơi trên đó thông tin dữ liệu được truyền đi. Ta có thể chia đường truyền thành hai loại là _hữu tuyến_ và _vô tuyến_.

  * _Các thiết bị kết nối mạng_

* Để liên kết các máy tính và các mạng với nhau như HUB, SWITCH, ROUTER, …

  * _Các thiết bị đầu cuối (terminal). Ví dụ:…?_

  * _Các phụ kiện mạng_

* Các phụ kiện mạng khác gồm giắc cắm, ổ cắm, ….

  * _Hệ điều hành mạng_

* Hệ điều hành mạng là một phần mềm điều khiển sự hoạt động của mạng.


  * C _ác phần mềm mạng cho máy tính_

* Hiện nay nói chung các hệ điều hành đều sẵn có khả năng kết nối mạng. Trong trường hợp hệ điều hành của máy tính không có sẵn khả năng kết nối mạng thì các phần mềm này là cần thiết.


  * _Các ứng dụng trên mạng._

* Ví dụ như Email, hệ quản trị cơ sở dữ liệu.


  * _Kiến trúc mạng máy tính_

* _Kiến trúc mạng máy tính_ (network architecture) thể hiện cách kết nối máy tính với nhau và qui ước truyền dữ liệu giữa các máy tính như thế nào. Cách nối các máy tính với nhau gọi là _hình_ _trạng_ ( _topology_ ) của mạng. Tập các qui ước truyền thông gọi là _giao thức_ ( _protocol)._


  * Có hai kiểu nối mạng chủ yếu là _điểm-điểm_ (point to point) và _quảng bá_ (broadcast).

  * Trong kiểu điểm-điểm các đường truyền nối các nút thành từng cặp. Như vậy một nút sẽ gửi dữ liệu đến nút lân cận nó (nút được nối trực tiếp với nó). Nút lân cận sẽ chuyển tiếp dữ liệu như vậy cho đến khi dữ liệu đến đích.


Kiểu nối mạng điểm- điểm có ba dạng chính là : hình sao ( _star_ ), chu trình ( _loop_ ), cây ( _tree_ ) và đầy đủ ( _complete_ ).

![](images/image1.png)

Star Loop Tree complete

Trong kiểu quảng bá các nút nối vào đường truyền chung. Như vậy khi một nút gửi dữ liệu các nút còn lại đều nhận được. Do đó dữ liệu gửi đi cần có địa chỉ đích. Khi một nút nhận được dữ liệu nó sẽ kiểm tra địa chỉ đích xem có phải gửi cho mình không.

![](images/image2.png)

Ring Bus

![](images/image3.png)

# Mạng Internet

_Khái niệm về Internet_

_Internet_ là một mạng máy tính có qui mô toàn cầu (GAN), gồm rất nhiều mạng con và máy tính nối với nhau bằng nhiều loại phương tiện truyền. Internet không thuộc sở hữu của ai cả. Chỉ có các uỷ ban điều phối và kỹ thuật giúp điều hành Internet.

Ban đầu là mạng của Bộ Quốc phòng Mỹ (DoD) dùng để đảm bảo liên lạc giữa các đơn vị quân đội. Sau đó phát triển thành mạng cho các trường đại học và viện nghiên cứu. Cuối cùng mạng có qui mô toàn cầu và trở thành mạng Internet.

_Các dịch vụ chính của Internet_

Ta có thể dùng Internet để thực hiện nhiều dịch vụ mạng. Các dịch vụ thông dụng nhất trên

Internet hiện nay là:

  * Truyền thông tin (FTP, File Transfer Protocol)

  * Truy nhập máy tính từ xa (telnet)

  * Web (WWW) để tìm kiếm và khai thác thông tin trên mạng

  * Thư điện tử (E-mail)

  * Tán gẫu (Chat) trên mạng…


_Lợi ích của Internet_

Trong thời đại của công nghệ thông tin hiện nay Internet có nhiều lợi ích như truyền tin, phổ biến tin, thu thập tin, trao đổi tin một cách nhanh chóng thuận tiện rẻ tiền hơn so với các phương tiện khác như điện thoại, fax. Internet ảnh hưởng đến toàn bộ thế giới đến mọi ngành, mọi lĩnh vực xã hội. Hiện nay Internet thành một yếu tố quan trọng không thiếu được trong thời đại hiện nay, có mặt ở mọi nơi, mọi lĩnh vực, mọi ngành.

_Làm sao để có được các dịch vụ Internet_

Để kết nối được Internet ta cần :

  * Máy tính có Modem (Dial-up, ADSL) hoặc card mạng.

  * Có thuê bao kết nối với Internet: qua mạng, qua đường điện thoại, đường thuê riêng của bưu điện. Thông thường hiện nay kết nối qua điện thoại hoặc qua ADSL

  * Có tài khoản Internet ở trên mạng hay ở một nhà cung cấp dịch vụ Internet (Internet Service Provider, ISP), ví dụ như VNN, FPT.

  * Có phần mềm Internet thông dụng như Web browser để xem trang web, ví dụ IE, FireFox , phần mềm để xem thư hay chat như Outlook, Messenger.

# Public_012

# Các khái niệm cơ bản

## Khái niệm hệ điều hành

Hệ điều hành là một trong các phần mềm hệ thống có tính phổ dụng. Có nhiều cách diễn đạt khác nhau về hệ điều hành xuất phát từ góc độ của người sử dụng khác nhau. Tuy vậy có thể diễn đạt như sau:

_**Hệ điều hành là hệ thống chương trình đảm bảo quản lý tài nguyên của hệ thống tính toán và cung cấp các dịch vụ cho người sử dụng.**_

Thông thường trong các hệ máy tính hiện nay, hệ điều hành được cài đặt trên đĩa.

Nhiệm vụ cụ thể hơn của hệ điều hành là:

  * Khởi động máy tính, tạo môi trường giao tiếp cho người sử dụng.

  * Tự động điều khiển và kiểm soát hoạt động của các thiết bị (ổ đĩa, bàn phím, màn hình, máy in,…).

  * Quản lý việc cấp phát tài nguyên của máy tính như bộ xử lý trung ương, bộ nhớ, các thiết bị vào ra…

  * Quản lý các chương trình đang thực hiện trên máy tính.

  * Thực hiện giao tiếp với người sử dụng để nhận lệnh và thực hiện lệnh.


Hệ điều hành là phần mềm hệ thống, nên phụ thuộc vào cấu trúc của máy tính. Mỗi loại máy tính có hệ điều hành khác nhau. Ví dụ:

  * Máy tính lớn IBM360 có hệ điều hành là DOS, TOS.

  * Máy tính lớn EC-1022 có hệ điều hành là OC-EC.

  * Máy tính cá nhân PC-IBM có hệ điều hành MS-DOS.

  * Mạng máy tính có các hệ điều hành mạng NETWARE, UNIX, WINDOWS-NT…


## Tệp (File)

Tệp là tập hợp các dữ liệu có liên quan với nhau và được tổ chức theo 1 cấu trúc nào đó, thường được lưu trữ bên ngoài máy tính.

Nội dung của tệp có thể là chương trình, dữ liệu, văn bản,... Mỗi tập tin được lưu lên đĩa với một tên riêng phân biệt. Mỗi hệ điều hành có qui ước đặt tên khác nhau, tên tập tin thường có 2 phần: phần tên (name) và phần mở rộng (extension). Phần tên là phần bắt buộc phải có của một tập tin, còn phần mở rộng thì có thể có hoặc không.

  * Phần tên: Bao gồm các ký tự chữ từ A đến Z, các chữ số từ 0 đến 9, các ký tự khác như #, $, %, ~, ^, @, (, ), !, _, khoảng trắng. Phần tên do người tạo ra tập tin đặt. Với MS-DOS phần tên có tối đa là 8 ký tự, với Windows phần tên có thể đặt tối đa 128 ký tự.

  * Phần mở rộng: thường dùng 3 ký tự trong các ký tự nêu trên. Thông thường phần mở rộng do chương trình ứng dụng tạo ra tập tin tự đặt.

  * Giữa phần tên và phần mở rộng có một dấu chấm (.) ngăn cách.


Ta có thể căn cứ vào phần mở rộng để xác định kiểu của file:

  * COM, EXE : Các file khả thi chạy trực tiếp được trên hệ điều hành.

  * TXT, DOC, ... : Các file văn bản.

  * PAS, BAS, ... : Các file chương trình PASCAL, DELPHI, BASIC, ...

  * WK1, XLS, ... : Các file chương trình bảng tính LOTUS, EXCEL ...

  * BMP, GIF, JPG, ... : Các file hình ảnh.

  * MP3, DAT, WMA, … : Các file âm thanh, video.


_Ký hiệu đại diện (Wildcard)_

Để chỉ một nhóm các tập tin, ta có thể sử dụng hai ký hiệu đại diện:

  * Dấu ? dùng để đại diện cho một ký tự bất kỳ trong tên tập tin tại vị trí nó xuất hiện.

  * Dấu * dùng để đại diện cho một chuỗi ký tự bất kỳ trong tên tập tin từ vị trí nó xuất hiện.


Ví dụ:

Bai?.doc

Bai1.doc, Bai6.doc, Baiq.doc, …

Bai*.doc

Bai.doc, Bai6.doc, Bai12.doc, Bai Tap.doc, …

BaiTap.*

BaiTap.doc, BaiTap.xls, BaiTap.ppt, BaiTap.dbf, …

_Lưu ý_ : _Nên đặt tên mang tính gợi nhớ._

## Quản lý tệp của hệ điều hành

_Cấu trúc đĩa từ_

Hệ thống đĩa từ gồm nhiều mặt (side) gắn số hiệu là 0, 1,… Về mặt logic mỗi mặt đãi có một đầu ghi/ đọc (header), đôi khi người ta còn đồng nhất 2 khái niệm này. Mỗi mặt chia thành các rãnh (track - các đường tròn đồng tâm). Các rãnh được đánh số từ ngoài vào trong bắt đầu từ 0. Mỗi rãnh chia thành các cung (Sector), mỗi sector thông thường có dung lượng 512 byte. Một từ trụ (cylinder) gồm các rãnh có cùng bán kính nằm trên các mặt đĩa khác nhau.

_Tổ chức ghi thông tin trên đĩa_

Thông tin lưu trữ trên đĩa dưới dạng các tệp. Mỗi tệp chiếm 1 hoặc nhiều sectors tuỳ dung lượng tệp.

Để thuận lợi cho việc quản lý tệp, hệ điều hành cho phép chia đĩa thành các vùng, mỗi vùng chia thành các vùng con,.... Mỗi vùng có 1 vùng con riêng để lưu trữ thông tin về vùng đó, vùng con này được gọi là thư mục (Directory). Tệp được lưu trữ ở các vùng, vì vậy ta có thể thấy tổ chức lưu trữ này có dạng cây (Tree).

Thư mục là nơi lưu giữ các tập tin theo một chủ đề nào đó theo ý người sử dụng. Đây là biện pháp giúp ta quản lý được tập tin, dễ dàng tìm kiếm chúng khi cần truy xuất. Các tập tin có liên quan với nhau có thể được xếp trong cùng một thư mục. Sau đây là biểu tượng của thư mục hay còn gọi là Folder trong Windows

![](images/image2.jpeg)

Trên mỗi đĩa có một thư mục chung gọi là thư mục gốc. Thư mục gốc không có tên riêng và được ký hiệu là \ (dấu xổ phải: backslash). Dưới mỗi thư mục gốc có các tập tin trực thuộc và các thư mục con. Trong các thư mục con cũng có các tập tin trực thuộc và thư mục con của nó. Thư mục chứa thư mục con gọi là thư mục cha.

Thư mục đang làm việc gọi là thư mục hiện hành.
Tên của thư mục tuân thủ theo cách đặt tên của tập tin.

_Cách xác định tên đầy đủ của tệp_

Tên tệp đầy đủ gồm nơi lưu trữ tệp - đường dẫn từ gốc đến tệp (Path) và tên tệp. Đường dẫn được chỉ ra nhánh cây thư mục chứa tệp, trong đó sử dụng ký hiệu “\” ngăn cách tên các thư mục .

Ví dụ :

C:\TC\BIN\B1.C
…

Hệ điều hành được phân chia thành các phần, phù hợp với các chức năng riêng của công việc.

Những phần này được lưu trên đĩa dưới dạng các tệp (File). Ví dụ:

Hệ điều hành MS-DOS gồm tập các tệp, trong đó có 3 tệp cơ bản:

  * MSDOS.SYS - tệp.

  * IO.SYS - tệp điều khiển vào ra.

  * COMMAND.COM - tệp lệnh.


# Hệ lệnh của hệ điều hành

  * Thao tác với tệp: Sao chép, di chuyển, xoá, đổi tên , xem nội dung tệp

  * Thao tác với thư mục: tạo, xoá, sao chép

  * Thao tác với đĩa: tạo khuôn ( Format), sao chép đĩa


# Hệ điều hành Windows

## Sự ra đời và phát triển

Windows là một bộ chương trình do hãng Microsoft sản xuất. Từ version 3.0 ra đời vào tháng 5 năm 1990 đến nay, Microsoft đã không ngừng cải tiến làm cho môi trường này ngày càng được hoàn thiện.

**Windows 95** : vào cuối năm 1995, ở Việt nam đã xuất hiện một phiên bản mới của Windows mà chúng ta quen gọi là Windows 95. Những cải tiến mới của Windows 95 được liệt kê tóm tắt như sau:

  * Giao diện với người sử dụng được thiết kế lại hoàn toàn nên việc khởi động các chương trình ứng dụng cùng các công việc như mở và lưu cất các tư liệu, tổ chức các tài nguyên trên đĩa và nối kết với các hệ phục vụ trên mạng - tất cả đều trở nên đơn giản và dễ dàng hơn.

  * Cho phép đặt tên cho các tập tin dài đến 255 ký tự. Điều này rất quan trọng vì những tên dài sẽ giúp ta gợi nhớ đến nội dung của tập tin.

  * Hỗ trợ Plug and Play, cho phép tự động nhận diện các thiết bị ngoại vi nên việc cài đặt và quản lý chúng trở nên đơn giản hơn.

  * Hỗ trợ tốt hơn cho các ứng dụng Multimedia. Với sự tích hợp Audio và Video của Windows 95, máy tính cá nhân trở thành phương tiện giải trí không thể thiếu được.

  * Windows 95 là hệ điều hành 32 bit, vì vậy nó tăng cường sức mạnh và khả năng vận hành lên rất nhiều.

  * Trong Windows 95 có các công cụ đã được cải tiến nhằm chuẩn hoá, tối ưu hoá và điều chỉnh các sự cố. Điều này giúp bạn yên tâm hơn khi làm việc với máy vi tính trong môi trường của Windows 95.


Tóm lại, với những tính năng mới ưu việt và tích hợp cao, Windows 95 đã trở thành môi trường làm việc được người sử dụng ưa chuộng và tin dùng.

**Windows 98, Windows Me:** là những phiên bản tiếp theo của Windows 95, những phiên bản này tiếp tục phát huy và hoàn thiện những tính năng ưu việt của Windows 95 và tích hợp thêm những tính năng mới về Internet và Multimedia.

**Windows NT 4.0, Windows 2000, Windows XP, Windows 2003:** là những hệ điều hành được phát triển cao hơn, được dùng cho các cơ quan và doanh nghiệp. Giao diện của những hệ điều hành này tương tự như Windows 98/ Windows Me. Điểm khác biệt là những hệ điều hành này có tính năng bảo mật cao, vì vậy nó được sử dụng cho môi trường có nhiều người dùng.

**Windows VISTA,** đây là sản phẩm mới của MicroSoft hỗ trợ tốt cho các dịch vụ mạng, trò chơi, văn phòng,..

Giáo trình này sẽ trình bày dựa vào hệ điều hành Windows XP.

## Khởi động và thoát khỏi Windows XP

_Khởi động Windows XP_

Windows XP được tự động khởi động sau khi bật máy. Sẽ có thông báo yêu cầu nhập vào tài khoản (User name) và mật khẩu (Password) của người dùng. Thao tác này gọi là đăng nhập (logging on).

Mỗi người sử dụng sẽ có một tập hợp thông tin về các lựa chọn tự thiết lập cho mình (như bố trí màn hình, các chương trình tự động chạy khi khởi động máy, tài nguyên/ chương trình được phép sử dụng, v.v...) gọi là user profile và được Windows XP lưu giữ lại để sử dụng cho những lần khởi động sau.

_Thoát khỏi Windows XP:_

Khi muốn thoát khỏi Windows XP, bạn phải đóng tất cả các cửa sổ đang mở. Tiếp theo bạn nhấn tổ hợp phím Alt + F4 hoặc chọn menu Start (nếu không nhìn thấy nút Start ở phía dưới bên góc trái màn hình thì bạn nhấn tổ hợp phím Ctrl + Esc) và chọn Turn Off Computer. Sau thao tác này một hộp thoại sẽ xuất hiện như bên dưới.

Nếu bạn chọn Turn Off, ứng dụng đang làm việc sẽ được đóng lại và máy sẽ tự động tắt. Nếu vì một lý do nào đó mà máy tính không sẵn sàng để đóng (chưa lưu dữ liệu cho một ứng dụng hoặc sự trao đổi thông tin giữa hai máy nối mạng đang tiếp diễn v.v..) thì sẽ có thông báo để xử lý.

**Chú ý:** nếu không làm những thao tác đóng Windows như vừa nói ở trên mà tắt máy ngay thì có thể sẽ xảy ra việc thất lạc một phần của nội dung các tập tin dẫn đến trục trặc khi khởi động lại ở lần sử dụng tiếp theo.

## Một số thuật ngữ và thao tác thường sử dụng

_Biểu tượng_ ( _icon_ )

Biểu tượng là các hình vẽ nhỏ đặc trưng cho một đối tượng nào đó của Windows hoặc của các ứng dụng chạy trong môi trường Windows. Phía dưới biểu tượng là tên biểu tượng. Tên này mang một ý nghĩa nhất định, thông thường nó diễn giải cho chức năng được gán cho biểu tượng (ví dụ nó mang tên của 1 trình ứng dụng).

_Cửa sổ (Windows ):_

Cửa sổ là khung giao tiếp đồ họa của 1 ứng dụng hoặc 1 lệnh.

  * Bố cục của 1 cửa sổ : gồm thanh tiêu đề, thanh thực đơn, 1 số thành phần khác phụ thuộc vào loại cửa sổ,…

  * Các hộp giao tiếp

  * Các thao tác trên một cửa sổ

* Di chuyển cửa sổ: Drag thanh tiêu đề cửa sổ (Title bar) đến vị trí mới.

* Thay đổi kích thước của cửa sổ: Di chuyển con trỏ chuột đến cạnh hoặc góc cửa sổ, khi con trỏ chuột biến thành hình mũi tên hai chiều thì Drag cho đến khi đạt được kích thước mong muốn.

* Phóng to cửa sổ ra toàn màn hình: Click lên nút Maximize ![](images/image3.jpeg) .

* Phục hồi kích thước trước đó của cửa sổ: Click lên nút Restore ![](images/image4.jpeg) .

* Thu nhỏ cửa sổ thành biểu tượng trên Taskbar: Click lên nút Minimize ![](images/image5.jpeg) .

* Chuyển đổi giữa các cửa sổ của các ứng dụng đang mở: Để chuyển đổi giữa các ứng dụng nhấn tổ hợp phím Alt + Tab hoặc chọn ứng dụng tương ứng trên thanh

  * Taskbar.

* Đóng cửa sổ: Click lên nút Close ![](images/image6.jpeg) của cửa sổ hoặc nhấn tổ hợp phím Alt + F4.


_Hộp hội thoại (Dialogue box)_

Trong khi làm việc với Windows và các chương tình ứng dụng chạy dưới môi trường Windows bạn thường gặp những hộp hội thoại. Các hộp thoại này xuất hiện khi nó cần thêm những thông số để thực hiện lệnh theo yêu cầu của bạn. Hình dưới đây giới thiệu các thành phần của hộp hội thoại

Thông thường, trên một hộp hội thoại sẽ có các thành phần sau:

  * Hộp văn bản (Text box): dùng để nhập thông tin.

  * Hộp liệt kê (List box): liệt kê sẵn một danh sách có các mục có thể chọn lựa, nếu số mục trong danh sách nhiều không thể liệt kê hết thì sẽ xuất hiện thanh trượt để cuộn danh sách.

  * Hộp liệt kê thả (Drop down list box/ Combo box): khi nhắp chuột vào nút thả thì sẽ buông xuống một danh sách.

  * Hộp kiểm tra (Check box): có 2 dạng , dạng hình vuông thể hiện việc cho phép không

* chọn, chọn 1 hoặc nhiều mục không loại trừ lẫn nhau. Dạng ô tròn (Option button): bắt buộc phải chọn một trong số các mục. Đây là những lựa chọn loại trừ lẫn nhau.

  * Nút lệnh (Command Button): lệnh cần thực thi.Các loại nút lệnh thường gặp có:

* **OK( hoặc bấm phím Enter)** : thực hiện lệnh ( chấp nhận)

* **Close** : giữ lại các thông số đã chọn và đóng cửa sổ

* **Cancel** ( **hay nhấn phím Esc** ): không thực hiện lệnh ( từ chối thực hiện)

* **Apply** : áp dụng các thông số đã chọn.

* **Default** : đặt mặc định theo các thông số

# Public_013

# Thông tin- Information

Khái niệm thông tin (information) được sử dụng thường ngày.Thông tin mang lại cho con người sự hiểu biết, nhận thức tốt hơn về những đối tượng trong đời sống xã hội, trong thiên nhiên,... giúp cho họ thực hiện hợp lý công việc cần làm để đạt tới mục đích một cách tốt nhất.

Người ta quan niệm rằng, thông tin là kết quả xử lý, điều khiển và tổ chức dữ liệu theo cách mà nó sẽ bổ sung thêm tri thức cho người nhận. Nói một cách khác, thông tin là ngữ cảnh trong đó dữ liệu được xem xét

Dữ liệu - Data

Dữ liệu (data) là biểu diễn của thông tin được thể hiện bằng các tín hiệu vật lý. Thông tin chứa đựng ý nghĩa còn dữ liệu là các sự kiện không có cấu trúc và không có ý nghĩa nếu chúng không được tổ chức và xử lý.

Dữ liệu trong thực tế có thể là:

  * Các số liệu thường được mô tả bằng số như trong các bảng biểu

  * Các ký hiệu qui ước, ví dụ chữ viết

  * Các tín hiệu vật lý ví dụ như ánh sáng, âm thanh, nhiệt độ, áp suất,…


Theo quan niệm chung của những người làm công nghệ thông tin thì thông tin là những hiểu biết của chúng ta về một lĩnh vực nào đấy, còn dữ liệu là thông tin được biểu diễn và xử lý trong máy tính.

## Tri thức – Knowledge

Tri thức theo nghĩa thường là thông tin ở mức trừu tượng hơn. Tri thức khá đa dạng, nó có thể là sự kiện, là thông tin và cách mà một người thu thập được qua kinh nghiệm hoặc qua đào tạo. Nó có thể là sự hiểu biết chung hay về một lĩnh vực cụ thể nào đó. Thuật ngữ tri thức được sử dụng theo nghĩa “hiểu” về một chủ thể với một tiềm năng cho một mục đích chuyên dụng.

Hệ thống thông tin ( _information system_ ) là một hệ thống ghi nhận dữ liệu, xử lý chúng để tạo nên thông tin có ý nghĩa hoặc dữ liệu mới.

# Qui trình xử lý thông tin

Mọi quá trình xử lý thông tin bằng máy tính hay bởi con người đều được thực hiện theo một qui trình sau:

Dữ liệu (Data) được nhập ở đầu vào (Input), qua quá trình xử lý để nhận được thông tin ở đầu ra (Output). Dữ liệu trong quá trình nhập, xử lý và xuất đều có thể được lưu trữ.

_Xử lý thông tin bằng máy tính điện tử_

Thông tin được thu thập và lưu trữ, qua quá trình xử lý có thể trở thành dữ liệu mới để theo một quá trình xử lý dữ liệu khác tạo ra thông tin mới hơn theo ý đồ của con người.

Con người có nhiều cách để có dữ liệu và thông tin. Người ta có thể lưu trữ thông tin qua tranh vẽ, giấy, sách báo, hình ảnh trong phim, băng từ. Trong thời đại hiện nay, khi lượng thông tin đến với chúng ta càng lúc càng nhiều thì con người có thể dùng một công cụ hỗ trợ cho việc lưu trữ, chọn lọc và xử lý thông tin gọi là máy tính điện tử (Computer). Máy tính điện tử giúp con người tiết kiệm rất nhiều thời gian, công sức và tăng độ chính xác cao trong việc tự động hoá một phần hay toàn phần của quá trình xử lý thông tin.

# Máy tính điện tử và phân loại

## Lịch sử phát triển của máy tính điện tử

Do nhu cầu cần tăng độ chính xác tính toán và giảm thời gian tính toán, con người đã quan tâm chế tạo các công cụ tính toán từ xưa: bàn tính tay của người Trung Quốc, máy cộng cơ học của nhà toán học Pháp Blaise Pascal (1623 - 1662), máy tính cơ học có thể cộng, trừ, nhân, chia của nhà toán học Đức Gottfried Wilhelmvon Leibniz (1646 - 1716), máy sai phân để tính các đa thức toán học ...

Tuy nhiên, máy tính điện tử thực sự bắt đầu hình thành vào thập niên 1950 và đến nay đã trải qua 5 thế hệ và dựa vào sự tiến bộ về công nghệ điện tử và vi điện tử cũng như các cải tiến về nguyên lý, tính năng và loại hình của nó.

  * Thế hệ 1 (1950 - 1958): máy tính sử dụng các bóng đèn điện tử chân không, mạch riêng rẽ, vào số liệu bằng phiếu đục lỗ, điều khiển bằng tay. Máy có kích thước rất lớn, tiêu thụ năng lượng nhiều, tốc độ tính chậm khoảng 300 - 3.000 phép tính/s. Loại máy tính điển hình thế hệ 1 như EDVAC (Mỹ) hay BESEM (Liên Xô cũ),...

  * Thế hệ 2 (1958 - 1964): máy tính dùng bộ xử lý bằng đèn bán dẫn, mạch in. Máy tính đã có chương trình dịch như Cobol, Fortran và hệ điều hành đơn giản. Kích thước máy còn lớn, tốc độ tính khoảng 10.000 -100.000 phép tính/s. Điển hình như loại IBM-1070 (Mỹ) hay MINSK (Liên Xô cũ),...

  * Thế hệ 3 (1965 - 1974): máy tính được gắn các bộ vi xử lý bằng vi mạch điện tử cỡ nhỏ có thể có được tốc độ tính khoảng 100.000 - 1 triệu phép tính/s. Máy đã có các hệ điều hành đa chương trình, nhiều người đồng thời hoặc theo kiểu phân chia thời gian. Kết quả từ máy tính có thể in ra trực tiếp ở máy in. Điển hình như loại IBM-360 (Mỹ) hay EC (Liên Xô cũ),...

  * Thế hệ 4 (1974 - nay): máy tính bắt đầu có các vi mạch đa xử lý có tốc độ tính hàng chục


triệu đến hàng tỷ phép tính/s. Giai đoạn này hình thành 2 loại máy tính chính: máy tính cá nhân để bàn (Personal Computer - PC) hoặc xách tay (Laptop hoặc Notebook computer) và các loại máy tính chuyên nghiệp thực hiện đa chương trình, đa xử lý,...
hình thành các hệ thống mạng máy tính (Computer Networks), và các ứng dụng phong phú đa phương tiện.

  * Thế hệ 5 (1990 - nay): bắt đầu các nghiên cứu tạo ra các máy tính mô phỏng các hoạt động của não bộ và hành vi con người, có trí khôn nhân tạo với khả năng tự suy diễn phát triển các tình huống nhận được và hệ quản lý kiến thức cơ bản để giải quyết các bài toán đa dạng.

  * Máy tính lượng tử


## Phân loại máy tính điện tử

Trên thực tế tồn tại nhiều cách phân loại máy tính khác nhau và chúng ta có thể phân loại máy tính theo hiệu năng tính toán như sau:

  * **Máy Vi tính (Microcomputer or PC)** : Loại này thường được thiết kế cho một người dùng, do đó giá thành rẻ. Hiện nay, máy vi tính khá phổ dụng và xuất hiện dưới khá nhiều dạng: máy để bàn (Destop), máy trạm (Workstation), máy xách tay (Notebook) và máy tính bỏ túi.

  * **Máy tính tầm trung (Mini Computer)** : Là loại máy tính có tốc độ và hiệu năng tính toán mạnh hơn các máy vi tính. Chúng thường được thiết kế để sử dụng cho các ứng dụng phức tạp. Giá của các máy này cũng cỡ hàng vài chục nghìn USD.

  * **Máy tính lớn (Mainframe Computer)** và **Siêu máy tính** (SuperComputer) là những máy tính có tổ chức bên trong rất phức tạp, có tốc độ siêu nhanh và hiệu năng tính toán cao, cỡ hàng tỷ phép tính/giây. Các máy tính này cho phép nhiều người dùng đồng thời và được sử dụng tại các Trung tâm tính toán/ Viện nghiên cứu để giải quyết các bài toán cực kỳ phức tạp, yêu cầu cao về tốc độ. Chúng có giá thành rất đắt, cỡ hàng trăm ngàn, thậm chí hàng triệu USD.


# Tin học và các ngành công nghệ liên quan

##  Tin học

Thuật ngữ Tin học có nguồn gốc từ tiếng Đức vào năm 1957 **do** [_Karl Steinbuch_](http://en.wikipedia.org/wiki/Karl_Steinbuch) đề xướng trong 1 bài báo _Informatik: Automatische Informationsverarbeitung_ (i.e. "Informatics: automatic information processing"). Sau đó vào năm 1962, [_Philippe Dreyfus_](http://en.wikipedia.org/wiki/Philippe_Dreyfus) người Pháp gọi là “informatique”, tiếp theo là [_Walter F.Bauer_](http://www.softwarehistory.org/history/Bauer1.html) cũng sử dụng tên này. Phần lớn các nước Tây Âu, trừ Anh đều chấp nhận. Ở Anh người ta sử dụng thuật ngữ „computer science‟, hay „computing science‟ là thuật ngữ dịch, Nga cũng chấp nhận tên _informatika_ (1966).

Tin học được xem là ngành khoa học nghiên cứu các phương pháp, công nghệ và kỹ thuật xử lý thông tin một cách tự động. Công cụ chủ yếu sử dụng trong tin học là máy tính điện tử và các thiết bị truyền tin khác. Nội dung nghiên cứu của tin học chủ yếu gồm 2 phần:

  * **Kỹ thuật phần cứng** (Hardware engineering): nghiên cứu chế tạo các thiết bị, linh kiện điện tử, công nghệ vật liệu mới... hỗ trợ cho việc thiết kế chế tạo máy tính và mạng máy tính, đẩy mạnh khả năng xử lý và truyền thông.

  * **Kỹ thuật phần mềm** (Software engineering): nghiên cứu phát triển các hệ điều hành, các tiện ích chung cho máy tính và mạng máy tính, các phần mềm ứng dụng phục vụ các mục đích xử lý và khai thác thông tin khác nhau của con người.


## Công nghệ thông tin (Information Technology - IT)

Thuật ngữ Công nghệ thông tin xuất hiện ở Việt nam vào những năm 90 của thế kỷ 20. Theo [_Information Technology Association of America_](http://en.wikipedia.org/wiki/Information_Technology_Association_of_America) (ITAA): “ _Công nghệ thông tin là ngành nghiên cứu các hệ thống thông tin dựa vào máy tính, đặc biệt là các phần mềm ứng dụng và phần cứng máy tính. Nói một cách ngắn gọn, IT xử lý với các máy tính điện tử và các phần mềm máy tính nhằm chuyển đổi, lưu trữ, bảo vệ, truyền tin và trích rút thông tin một cách an toàn_ ”.

Theo NQ49 CP thì “Công nghệ thông tin là…”

Các ứng dụng ngày nay của IT:

  * Quản trị dữ liệu

  * Thiết kế hệ thống cơ sở dữ liệu

  * Quản lý hệ thống thông tin

  * Quản lý hệ thống

  * ….


## Công nghệ thông tin và truyền thông

Ngày nay, khuynh hướng sử dụng "[ _information_](http://en.wikipedia.org/wiki/Information)" thay thế cho "[ _data_](httpkhuynh://en.wikipedia.org/wiki/Data)" và có xu thế mở rộng cho lĩnh vực truyền thông và trở thành **ICT** ( _Information and Communication Technology_ ). Thuần tuý theo cách nói thì hai thuật ngữ này là như nhau.

Truyền thông máy tính, nói đơn giản là sự kết nối một số lượng máy tính với nhau trong một phạm vi địa lý nhỏ. Tuy nhiên, nhiều máy tính có thể kết nối với nhau theo một phạm vi rộng hơn và việc trao đổi thực hiện qua một mạng viễn thông nào đó. **Internet** _\- Mạng máy tính toàn cầu_ là một phát minh vĩ đại của nhân loại trong thế kỷ 20, đó cũng chính là sản phẩm của ngành Công nghệ thông tin và Truyền thông.

# Public_014

# Biểu diễn dữ liệu trong máy tính 

## Biểu diễn số trong các hệ đếm

Hệ đếm là tập hợp các ký hiệu và qui tắc sử dụng tập ký hiệu đó để biểu diễn và xác định các giá trị các số. Mỗi hệ đếm có một số ký số (digits) hữu hạn. Tổng số ký số của mỗi hệ đếm được gọi là **cơ số** (base hay radix), ký hiệu là b.

### Hệ đếm cơ số b

Hệ đếm cơ số b (b ≥ 2 và nguyên dương) mang tính chất sau :

  * Có b ký số để thể hiện giá trị số. Ký số nhỏ nhất là **0** và lớn nhất là **b-1**.

  * Giá trị vị trí thứ n trong một số của hệ đếm bằng cơ số b lũy thừa n

  * Số N(b) trong hệ đếm cơ số (b) được biểu diễn bởi:


![](images/image1.jpeg)

trong đó, số N(b) có **n+1** ký số biểu diễn cho phần nguyên và **m** ký số lẻ biểu diễn cho phần b_phân, và có giá trị là:

![](images/image2.jpeg)

Trong ngành toán - tin học hiện nay phổ biến 4 hệ đếm là hệ thập phân, hệ nhị phân, hệ bát phân và hệ thập lục phân.

### Hệ đếm thập phân (Decimal system, b=10)

Hệ đếm thập phân hay hệ đếm cơ số 10 là một trong các phát minh của người Ả rập cổ, bao gồm 10 ký số theo ký hiệu sau:

**0,1,2,3,4,5,6,7,8,9**

Qui tắc tính giá trị của hệ đếm này là mỗi đơn vị ở một hàng bất kỳ có giá trị bằng 10 đơn vị của hàng kế cận bên phải. Ở đây b=10. Bất kỳ số nguyên dương trong hệ thập phân có thể biểu diễn như là một tổng các số hạng, mỗi số hạng là tích của một số với 10 lũy thừa, trong đó số mũ lũy thừa được tăng thêm 1 đơn vị kể từ số mũ lũy thừa phía bên phải nó. Số mũ lũy thừa của hàng đơn vị trong hệ thập phân là 0.

Ví dụ: Số 5246 có thể được biểu diễn như sau:

3 2 1 0
5246 = 5 x 10 + 2 x 10 + 4 x 10 + 6 x 10
= 5 x 1000 + 2 x 100 + 4 x 10 + 6 x 1

Thể hiện như trên gọi là ký hiệu mở rộng của số nguyên vì

5246 = 5000 + 200 + 40 + 6

Như vậy, trong số 5246 : ký số 6 trong số nguyên đại diện cho giá trị 6 đơn vị (1s), ký số 4 đại diện cho giá trị 4 chục (10s), ký số 2 đại diện cho giá trị 2 trăm (100s) và ký số 5 đại diện cho giá trị 5 ngàn (1000s). Nghĩa là, số lũy thừa của 10 tăng dần 1 đơn vị từ trái sang phải tương ứng với vị trí ký hiệu số,

0 1 2 3 4
10 = 1 10 = 10 10 = 100 10 = 1000 10 = 10000 ...

Mỗi ký số ở thứ tự khác nhau trong số sẽ có giá trị khác nhau, ta gọi là giá trị vị trí (place value).

Phần thập phân trong hệ thập phân sau dấu chấm phân cách thập phân (theo qui ước của Mỹ) thể hiện trong ký hiệu mở rộng bởi 10 lũy thừa âm tính từ phải sang trái kể từ dấu chấm phân cách:

101101−= 1011002−= 10110003−= ...


| 2 | 1 | 0 | -1 | -2 |
| --- | --- | --- | --- | --- |

 

### Hệ đếm nhị phân (Binary system, b=2)

Với cơ số b=2, chúng ta có hệ đếm nhị phân. Đây là hệ đếm đơn giản nhất với 2 chữ số là 0 và 1, mỗi chữ số nhị phân gọi là BIT (viết tắt từ chữ BInary digiT). Vì hệ nhị phân chỉ có 2 trị số là 0 và 1, nên khi muốn diễn tả một số lớn hơn, hoặc các ký tự phức tạp hơn thì cần kết hợp nhiều bit với nhau. Ta có thể chuyển đổi số trong hệ nhị phân sang số trong hệ thập phân quen thuộc.

Ví dụ: Số 11101.11(2) sẽ tương đương với giá trị thập phân là :

![](images/image3.jpeg)

### Hệ đếm bát phân (Octal system, b=8)

Nếu dùng 1 tập hợp 3 bit thì có thể biểu diễn 8 trị khác nhau : 000, 001, 010, 011, 100, 101, 110, 111. Các trị này tương đương với 8 trị trong hệ thập phân là 0, 1, 2, 3, 4, 5, 7. Tập hợp các chữ

3

số này gọi là hệ bát phân, là hệ đếm với b = 8 = 2 . Trong hệ bát phân, trị vị trí là lũy thừa của 8.

Ví dụ:


| 2 | 1 | 0 | -1 | -2 |
| --- | --- | --- | --- | --- |

 

### Hệ đếm thập lục phân (Hexa-decimal system, b=16)

4

Hệ đếm thập lục phân là hệ cơ số b=16 = 2 , tương đương với tập hợp 4 chữ số nhị phân (4 bit). Khi thể hiện ở dạng hexa-decimal, ta có 16 ký tự gồm 10 chữ số từ 0 đến 9, và 6 chữ in A, B, C, D, E, F để biểu diễn các giá trị số tương ứng là 10, 11, 12, 13, 14, 15. Với hệ thập lục phân, trị vị trí là lũy thừa của 16.

Ví dụ:

4 3 2 1 0
34F5C(16) = 3x16 + 4x16 + 15x16 + 5x16 + 12x16 = 216294(10)
_Ghi chú_ : Một số ngôn ngữ lập trình qui định viết số hexa phải có chữ H ở cuối chữ số. Ví dụ: Số 15 viết là FH.

### Chuyển đổi một số từ hệ thập phân sang hệ đếm cơ số b

#### Đổi phần nguyên từ hệ thập phân sang hệ b

Tổng quát: Lấy số nguyên thập phân N(10) lần lượt chia cho b cho đến khi thương số bằng 0. Kết

quả số chuyển đổi N(b) là các dư số trong phép chia viết ra theo thứ tự ngược lại.. Ví dụ: Số 12(10)

  * ?(2). Dùng phép chia cho 2 liên tiếp, ta có một loạt các số dư như sau:


![](images/image4.jpeg)

#### Đổi phần thập phân từ hệ thập phân sang hệ cơ số b

![](images/image5.jpeg)Tổng quát: Lấy phần thập phân N(10) lần lượt nhân với b cho đến khi phần thập phân của tích số bằng 0. Kết quả số chuyển đổi N(b) là các số phần nguyên trong phép nhân viết ra theo thứ tự

tính toán.

## Biểu diễn dữ liệu trong máy tính và đơn vị thông tin

###  Nguyên tắc chung

Thông tin và dữ liệu mà con người hiểu được tồn tại dưới nhiều dạng khác nhau, ví dụ như các số liệu, các ký tự văn bản, âm thanh, hình ảnh,… nhưng trong máy tính mọi thông tin và dữ liệu đều được biểu diễn bằng số nhị phân (chuỗi bit).

Để đưa dữ liệu vào cho máy tính, cần phải mã hoá nó về dạng nhị phân. Với các kiểu dữ liệu khác nhau cần có cách mã hoá khác nhau. Cụ thể:

  * Các dữ liệu dạng số (số nguyên hay số thực) sẽ được chuyển đổi trực tiếp thành các chuỗi số nhị phân theo các chuẩn xác định.

  * Các ký tự được mã hoá theo một bộ mã cụ thể, có nghĩa là mỗi ký tự sẽ tương ứng với một chuỗi số nhị phân.

  * Các dữ liệu phi số khác như âm thanh, hình ảnh và nhiều đại lượng vật lý khác muốn đưa vào máy phải **số hoá** ( _digitalizing_ ). Có thể hiểu một cách đơn giản khái niệm số hoá như sau: các dữ liệu tự nhiên thường là quá trình biến đổi liên tục, vì vậy để đưa vào máy tính, nó cần được biến đổi sang một dãy hữu hạn các giá trị số (nguyên hay thực) và được biểu diễn dưới dạng nhị phân.


Tuy rằng mọi dữ liệu trong máy tính đều ở dạng nhị phân, song do bản chất của dữ liệu, người ta thường phân dữ liệu thành 2 dạng:

  * **Dạng cơ bản** : gồm dạng số (nguyên hay thực) và dạng ký tự. Số nguyên không dấu được biểu diễn theo dạng nhị phân thông thường, số nguyên có dấu theo mã bù hai, còn số thực theo dạng dấu phảy động. Để biểu diễn một dữ liệu cơ bản, người ta sử dụng 1 số bit. Các bit này ghép lại với nhau để tạo thành từ: từ 8 bít, từ 16 bít,…

  * **Dạng có cấu trúc** : Trên cơ sở dữ liệu cơ bản, trong máy tính, người ta xây dựng nên các dữ liệu có cấu trúc phục vụ cho các mục đích sử dụng khác nhau. Tuỳ theo cách “ghép” chúng ta có mảng, tập hợp,xâu, bản ghi,…


### Đơn vị thông tin

Đơn vị nhỏ nhất để biểu diễn thông tin gọi là **bit**. Một bit tương ứng với một sự kiện có 1 trong 2 trạng thái.

Ví dụ: Một mạch đèn có 2 trạng thái là:

  * Tắt (Off) khi mạch điện qua công tắc là hở

  * Mở (On) khi mạch điện qua công tắc là đóng


Số học nhị phân sử dụng hai ký số 0 và 1 để biểu diễn các số. Vì khả năng sử dụng hai số 0 và 1 là như nhau nên một chỉ thị chỉ gồm một chữ số nhị phân có thể xem như là đơn vị chứa thông tin nhỏ nhất.

Bit là chữ viết tắt của **BI** nary digi **T**. Trong tin học, người ta thường sử dụng các đơn vị đo thông tin lớn hơn như sau:

## Biểu diễn số nguyên

Số nguyên gồm số nguyên không dấu và số nguyên có dấu. Về nguyên tắc đều dùng 1 chuỗi bit để biểu diễn. Đối với số nguyên có dấu, người ta sử dụng bit đầu tiên để biểu diễn dấu „-„ và bit này gọi là bit dấu.

### Số nguyên không dấu

Trong biểu diễn số nguyên không dấu, mọi bit đều được sử dụng để biểu diễn giá trị số. Ví dụ 1 dãy 8 bit biểu diễn số nguyên không dấu có giá trị:

8

  2. = 256 số nguyên dương, cho giá trị từ 0 (0000 0000) đến 255 (1111 1111).


Với n bits ta có thể biểu diễn 1 số nguyên có giá trị lớn nhất là 2n-1 và dải giá trị biểu diễn được từ 0 đến 2n-1.


| Thí dụ: 00000000 | = | 0 |
| --- | --- | --- |
| 00000010 | = | 2 |
| 00000100 | = | 4 |
| …………. |  |  |
| 11111111 | = | 255 |

 

### Số nguyên có dấu

Trong biểu diễn số nguyên có dấu, bit đầu làm bít dấu: 0 là số dương và 1 cho số âm. Số nguyên có dấu thể hiện trong máy tính ở dạng nhị phân là số dùng 1 bit làm bít dấu, người ta qui ước dùng bit ở hàng đầu tiên bên trái làm bit dấu (S): 0 là số dương và 1 cho số âm. Cách phổ biến biểu diễn số âm có dấu là dùng mã bù hai:

Số bù hai được tính như sau:

  * Biểu diễn số nguyên không dấu

  * Nghịch đảo tất cả các bit (số bù một)

  * Cộng thêm một. (số bù hai)


_Chú ý: Thử biểu diễn mã bù hai của -37 để thu được số +35_

### Tính toán số học với số nguyên

#### Cộng/ trừ số nguyên

_Cộng/ trừ số nguyên không dấu_

Khi cộng hai số nguyên không dấu n bits ta thu được một số nguyên không dấu cũng n bits. Vì vậy,

  * Nếu tổng của hai số đó nhỏ hơn hoặc bằng 2n-1 thì kết quả nhận được là đúng.

  * Nếu tổng của hai số đó lớn hơn 2n-1 thì khi đó sẽ tràn số và kết quả sẽ là sai. Thí dụ với trường hợp 8 bits, tổng nhỏ hơn 255 thì ta sẽ có kết quả đúng:

* 57 = 00111001


34 = 00100010
91 = 01011011
209 = 11010001

  * 73 = 01001001


282 = **1** 00011010

![](images/image6.png)

Bit tràn ra ngoài => kết quả = 26 là sai.

  * Để tránh hiện tượng tràn số này ta phải sử dụng nhiều bit hơn để biểu diễn.


_Cộng/trừ số nguyên có dấu_

Số nguyên có dấu được biểu diễn theo mã bù hai, vậy qui tắc chung như sau:

  * Cộng hai số nguyên có dấu n-bit sẽ bỏ qua giá trị nhớ ra khỏi bit có ý nghĩa cao nhất, tổng nhận được sẽ có giá trị đúng và cũng được biểu diễn theo mã bù hai, nếu kết quả nhận được nằm trong dải -2n-1 đến + 2n-1 -1.

  * Để trừ hai số nguyên có dấu X và Y (X – Y) , cần lấy bù hai của Y tức –Y, sau đó cộng X với –Y theo nguyên tắc trên.


Như vậy, khi thực hiện phép tính trên sẽ thừa ra 1 bit bên trái cùng, bit này sẽ không được lưu trong kết quả và sẽ được bỏ qua.

#### Nhân/ chia số nguyên

So với phép cộng và phép trừ, phép nhân và phép chia phức tạp hơn nhiều. Dưới đây, chỉ giới thiệu phép nhân/phép chia với số nhị phân. Ví dụ sau mô tả phép nhân hai số nhị phân:

1011 (11 cơ số 10)
x
1101 (13 cơ số 10)

![](images/image7.png)

1011
0000
1011
1011
**10001111** **kết quả 143 trong cơ số 10**

Chúng ta có một số nhận xét sau:

  * Phép nhân tạo ra các tích riêng, mỗi tích thu được là kết quả của việc nhân từng bit.

  * Các tích riêng dễ dàng xác định theo qui tắc:

* Bit tương ứng số nhân là 1 thì tích riêng bằng số bị nhân

* Bit tương ứng số nhân bằng 0 thì tích riêng bằng 0

  * Tích được tính bằng tổng các tích riêng.


Phép chia phức tạp hơn phép nhân nhưng dựa trên cùng 1 nguyên tắc.

# Public_015

# Bộ xử lý trung tâm – CPU

Bộ xử lý trung tâm (Central Proccesor Unit- CPU) điều khiển các thành phần của máy tính, xử lý dữ liệu. CPU hoạt động theo chương trình nằm trong bộ nhớ chính, nhận các lệnh từ bộ nhớ chính, giải mã lệnh để phát ra các tín hiệu điều khiển thực thi lệnh. Trong quá trình thực hiện lệnh, CPU có trao đổi với bộ nhớ chính và hệ thống vào ra. CPU có 3 bộ phận chính: khối điều khiển, khối tính toán số học và logic, và tập các thanh ghi (hình 3.2).

  * **Khối điều khiển** ( _Control Unit_ – CU):

* Nhận lệnh của chương trình từ bộ nhớ trong đưa vào CPU. Nó có nhiệm vụ giải mã các lệnh, tạo ra các tín hiệu điều khiển công việc của các bộ phận khác của máy tính theo yêu cầu của người sử dụng hoặc theo chương trình đã cài đặt..

  * **Khối tính toán số học và logic** ( _Arithmetic_ – _Logic Unit_ \- ALU)

* Bao gồm các thiết bị thực hiện các phép tính số học (cộng, trừ, nhân, chia, ...), các phép tính logic (AND, OR, NOT, XOR) và các phép tính quan hệ (so sánh lớn hơn, nhỏ hơn, bằng nhau, ...)

* Dữ liệu từ bộ nhớ hay các thiết bị vào-ra sẽ được chuyển vào các thanh ghi của CPU, rồi chuyển đến ALU. Tại đây, dữ liệu được tính toán rồi trả lại các thanh ghi và chuyển về bộ nhớ hay các thiết bị vào-ra.

* Độ dài từ của các toán hạng được đưa vào tính toán trực tiếp ở khối ALU. Độ dài phổ biến với các máy tính hiện nay là 32 hay 64 bit.

* Ban đầu ALU chỉ gồm khối tính toán số nguyên IU (Integer Unit). Để tăng khả năng tính toán nhất là trong dấu phẩy động. Khối tính toán hiện nay được bổ sung thêm khối tính toán dấu phẩy động FPU (Floating Point Unit)- hay còn gọi là bộ đồng xử lý (Co-proccesor Unit) .

  * **Tập các thanh ghi** ( _Registers_ )

* Được gắn chặt vào CPU bằng các mạch điện tử làm nhiệm vụ bộ nhớ trung gian cho CPU. Các thanh ghi mang các chức năng chuyên dụng giúp tăng tốc độ trao đổi thông tin

* trong máy tính. Trên các CPU hiện nay có từ vài chục đến vài trăm thanh ghi. Độ dài của các thanh ghi cũng khác nhau từ 8 đến 64 bit.

* Ngoài ra, CPU còn được gắn với một đồng hồ (clock) hay còn gọi là bộ tạo xung nhịp. Tần số đồng hồ càng cao thì tốc độ xử lý thông tin càng nhanh. Thường thì đồng hồ được gắn tương xứng với cấu hình máy và có các tần số dao động (cho các máy Pentium 4 trở lên) là 2.0 GHz, 2.2 GHz, ... hoặc cao hơn.


# Bộ vi xử lý (Microprocessor)

CPU được chế tạo trên một vi mạch và được gọi là bộ vi xử lý. Vì vậy, chúng ta có thể gọi CPU là bộ vi xử lý. Tuy nhiên, các bộ vi xử lý hiện nay có cấu trúc phức tạp hơn nhiều so với một CPU cơ bản.

# Bộ nhớ

Bộ nhớ là thiết bị lưu trữ thông tin trong quá trình máy tính xử lý. Bộ nhớ bao gồm bộ nhớ trong và bộ nhớ ngoài.

_Bộ nhớ trong_

Bộ nhớ trong ( _Internal Memory_ ) là những thành phần nhớ mà CPU có thể trao đổi trực tiếp: các lệnh mà CPU thực thi, các dữ liệu mà CPU sử dụng đều phải nằm trong bộ nhớ trong. Bộ nhớ trong có dung lượng không thật lớn song có tốc độ trao đổi thông tin cao.

_Bộ nhớ chính_

Là thành phần quan trọng nhất của bộ nhớ trong, vì vậy nhiều khi người ta đồng nhất bộ nhớ chính với bộ nhớ trong. Bộ nhớ chính tổ chức thành các ngăn theo byte và các ngăn nhớ này được đánh địa chỉ trực tiếp bởi CPU, có nghĩa là mỗi ngăn nhớ của bộ nhớ chính được gán một địa chỉ xác định. CPU muốn đọc/ghi vào ngăn nhớ nào, nó phải biết được địa chỉ của ngăn nhớ đó.

Nội dung của ngăn nhớ là giá trị được ghi trong đó. Số bit được dùng để đánh địa chỉ của ngăn nhớ sẽ quyết định dung lượng tối đa của bộ nhớ chính. Thí dụ:

  * Dùng 16 bit địa chỉ thì dung lượng tối đa của bộ nhớ là 216 = 26 x 210 = 64KB

  * Bộ xử lý Pentium III có 36 bit địa chỉ, do đó có khả năng quản lý tối đa 26 x 230=64GB . _Chú ý:_ Nội dung của ngăn nhớ có thể thay đổi còn địa chỉ ngăn nhớ thì cố định.


Bộ nhớ chính của máy tính được thiết kế bằng bộ nhớ bán dẫn với 2 loại ROM và RAM, trong đó:

  * **ROM** ( **Read Only Memory** ) là Bộ nhớ chỉ đọc thông tin, dùng để lưu trữ các chương trình hệ thống, chương trình điều khiển việc nhập xuất cơ sở (ROM-BIOS : ROM-Basic Input/Output System). Thông tin trên ROM không thể thay đổi và không bị mất ngay cả khi không có điện.

  * **RAM** ( **Random Access Memory** ) là Bộ nhớ truy xuất ngẫu nhiên, được dùng để lưu trữ dữ liệu và chương trình trong quá trình thao tác và tính toán. RAM có đặc điểm là nội dung thông tin chứa trong nó sẽ mất đi khi mất điện hoặc tắt máy. Dung lượng bộ nhớ RAM cho các máy tính hiện nay thông thường vào khoảng 128 MB, 256 MB, 512 MB và có thể hơn nữa.


Ngoài ra, trong máy tính cũng còn phần bộ nhớ khác: _**Cache Memory**_ cũng thuộc bộ nhớ trong.

Bộ nhớ cache được đặt đệm giữa CPU và bộ nhớ trong nhằm làm tăng tốc độ trao đổi thông tin. Bộ nhớ cache thuộc bộ nhớ RAM, có dung lượng nhỏ. Nó chứa một phần chương trình và dữ liệu mà CPU đang xử lý, do vậy thay vì lấy lệnh và dữ liệu từ bộ nhớ chính, CPU sẽ lấy trên cache. Hầu hết các máy tính hiện nay đều có cache tích hợp trên chip vi xử lý.

_Bộ nhớ ngoài_

Bộ nhớ ngoài ( _External Memory_ ) Là thiết bị lưu trữ thông tin với dung lượng lớn, thông tin không bị mất khi không có điện. Các thông tin này có thể là phần mềm máy tính hay dữ liệu. Bộ nhớ ngoài được kết nối với hệ thống thông qua mô-đun nối ghép vào-ra. Như vậy, _bộ nhớ ngoài về chức năng thuộc bộ nhớ, song về cấu trúc nó lại thuộc hệ thống vào ra_. Có thể cất giữ và di chuyển bộ nhớ ngoài độc lập với máy tính. Hiện nay có các loại bộ nhớ ngoài phổ biến như:

  * Đĩa mềm (Floppy disk) : là loại đĩa đường kính 3.5 inch dung lượng 1.44 MB.

  * Đĩa cứng (Hard disk) : phổ biến là đĩa cứng có dung lượng 20 GB, 30 GB, 40 GB, 60 GB, và lớn hơn nữa.

  * Đĩa quang (Compact disk): loại 4.72 inch, là thiết bị phổ biến dùng để lưu trữ các phần mềm mang nhiều thông tin, hình ảnh, âm thanh và thường được sử dụng trong các phương tiện đa truyền thông (multimedia). Có hai loại phổ biến là: đĩa CD (dung lượng khoảng 700 MB) và DVD (dung lượng khoảng 4.7 GB).

  * Các loại bộ nhớ ngoài khác như thẻ nhớ (Memory Stick, Compact Flash Card), USB Flash Drive có dung lượng phổ biến là 32 MB, 64 MB, 128 MB, ...


![](images/image1.png)

**Hình I.2.1.1.c.** **Một số loại bộ** **nhớ**

# Hệ thống vào-ra

Chức năng của hệ thống vào-ra là trao đổi thông tin giữa máy tính với thế giới bên ngoài. Hệ thống vào-ra được xây dựng dựa trên hai thành phần: các _**thiết bị vào-ra**_ (IO devices) hay còn gọi là thiết bị ngoại vi (Peripheral devices) và các _**mô-đun ghép nối vào-ra**_ (IO Interface modules)

_Mô đun ghép nối vào ra_

Các thiết bị vào ra không kết nối trực tiếp với CPU mà được kết nối thông qua các mô-đun ghép nối vào-ra. Trong các mô đun ghép nối vào-ra có các cổng vào-ra IO Port), các cổng này cũng được đánh địa chỉ bởi CPU, có nghĩa là mỗi cổng cũng có một địa chỉ xác định. Mỗi thiết bị vào-ra kết nối với CPU thông qua cổng tương ứng với địa chỉ xác định.

Mỗi thiết bị vào-ra làm nhiệm vụ chuyển đổi thông tin từ một dạng vật lý nào đó về dạng dữ liệu phù hợp với máy tính hoặc ngược lại. các thiết bị ngoại vi thông dụng như bàn phím, màn hình, máy in hay một máy tính khác. Người ta có thể phân các thiết bị ngoại vi ra nhiều loại:

  * _Thiết bị thu nhận dữ liệu_ : Bàn phím, chuột, máy quét ảnh,…

  * _Thiết bị hiển thị dữ liệu_ : màn hình, máy in,…

  * _Thiết bị nhớ_ : các loại ổ đĩa

  * _Thiết bị truyền thông_ : modem

  * _Thiết bị hỗ trợ đa phương tiện_ : hệ thống âm thanh, hình ảnh,… Các thiết bị vào:

  * **Bàn phím** (Keyboard, thiết bị nhập chuẩn): là thiết bị nhập dữ liệu và câu lệnh, bàn phím máy vi tính phổ biến hiện nay là một bảng chứa 104 phím có các tác dụng khác nhau.

  * Có thể chia làm 3 nhóm phím chính:

  * Nhóm phím đánh máy: gồm các phím chữ, phím số và phím các ký tự đặc biệt (~,

  * !, @, #, $, %, ^,&, ?, ...).

  * Nhóm phím chức năng (function keypad): gồm các phím từ F1 đến F12 và các phím như ← ↑ → ↓ (phím di chuyển từng điểm), phím PgUp (lên trang màn hình), PgDn (xuống trang màn hình), Insert (chèn), Delete (xoá), Home (về đầu), End (về cuối)

  * Nhóm phím số (numeric keypad) như NumLock (cho các ký tự số), CapsLock (tạo các chữ in), ScrollLock (chế độ cuộn màn hình) thể hiện ở các đèn chỉ thị.


  * **Chuột** (Mouse): là thiết bị cần thiết phổ biến hiện nay, nhất là các máy tính chạy trong môi trường Windows. Con chuột có kích thước vừa nắm tay di chuyển trên một tấm phẳng (mouse pad) theo hướng nào thì dấu nháy hoặc mũi tên trên màn hình sẽ di chuyển theo hướng đó tương ứng với vị trí của của viên bi hoặc tia sáng (optical mouse) nằm dưới bụng của nó. Một số máy tính có con chuột được gắn trên bàn phím.

  * **Máy quét** (Scanner): là thiết bị dùng để nhập văn bản hay hình vẽ, hình chụp vào máy tính. Thông tin nguyên thuỷ trên giấy sẽ được quét thành các tín hiệu số tạo thành các tập tin ảnh (image file).


Các thiết bị ra:

  * **Màn hình** (Screen hay Monitor, thiết bị ra chuẩn): dùng để hiển thị thông tin cho người sử dụng xem. Thông tin được thể hiện ra màn hình bằng phương pháp ánh xạ bộ nhớ (memory mapping), với cách này màn hình chỉ việc đọc liên tục bộ nhớ và hiển thị (display) bất kỳ thông tin nào hiện có trong vùng nhớ ra màn hình.

  * Màn hình phổ biến hiện nay trên thị trường là màn hình màu SVGA 15”,17”, 19” với độ phân giải có thể đạt 1280 X 1024 pixel.

  * **Máy in** (Printer): là thiết bị ra để đưa thông tin ra giấy. Máy in phổ biến hiện nay là loại máy in ma trận điểm (dot matrix) loại 24 kim, máy in phun mực, máy in laser trắng đen hoặc màu.

  * **Máy chiếu** (Projector): chức năng tương tự màn hình, thường được sử dụng thay cho màn hình trong các buổi Seminar, báo cáo, thuyết trình, …


# Liên kết hệ thống (buses)

Giữa các thành phần của một hệ thống máy tính hay ngay trong một thành phần phức tạp như CPU cũng cần trao đổi với nhau. Nhiệm vụ này được thực thi bởi hệ thống kết nối mà chúng ta quen gọi là bus. Tuỳ theo nhiệm vụ của chúng mà chúng ta phân làm 3 loại chính:

  * **Bus điều khiển** (Control bus): chuyển các thông tin/tín hiệu điều khiển từ thành phần này đến thành phần khác: CPU phát tín hiệu để điều khiển bộ nhớ hay hệ thống vào-ra hoặc từ hệ thống vào-ra gửi tín hiệu yêu cầu đến CPU.

  * **Bus dữ liệu** (Data bus): làm nhiệm vụ chuyển tải dữ liệu (nội dung ngăn nhớ, kết quả xử lý) từ CPU đến bộ nhớ hay ngược lại hoặc từ bộ nhớ/CPU ra các thiết bị ngoại vi. Đây là loại bus 2 chiều. Các máy tính hiện nay thường có đường bit dữ liệu 32 hay 64 bit.

  * **Bus địa chỉ** (Address bus): chuyển tải địa chỉ của các ngăn nhớ khi muốn truy nhập (đọc/ghi) nội dung của ngăn nhớ đó hoặc là địa chỉ cổng của các thiết bị mà CPU cần trao đổi. Độ rộng (số bit) của bus địa chỉ cho biết dung lượng cực đại của bộ nhớ mà CPU có thể quản lý được. Với độ rộng là n thì dung lượng bộ nhớ tối đa sẽ là 2n.

# Public_016

# Lời nói đầu

TCVN 9395:2012 được chuyển đổi từ TCXDVN 326:2004 theo quy định tại khoản 1 Điều 69 của Luật Tiêu chuẩn và Quy chuẩn kỹ thuật và điểm a khoản 1 Điều 7 Nghị định số 127/2007/NĐ-CP ngày 01/8/2007 của Chính phủ quy định chi tiết thi hành một số điều của Luật Tiêu chuẩn và Quy chuẩn kỹ thuật.
TCVN 9395:2012 do Viện Khoa học Công nghệ Xây dựng - Bộ Xây dựng biên soạn, Bộ Xây dựng đề nghị, Tổng cục Tiêu chuẩn Đo lường Chất lượng thẩm định, Bộ Khoa học và Công nghệ công bố.

# Phạm vi áp dụng

Tiêu chuẩn này áp dụng cho thi công và nghiệm thu cọc khoan nhồi bê tông cốt thép đường kính lớn hơn hoặc bằng 60 cm trừ những công trình có điều kiện địa chất đặc biệt như vùng có hang các-tơ, mái đá nghiêng.

## Tài liệu viện dẫn

Các tài liệu viện dẫn sau cần thiết cho việc áp dụng tiêu chuẩn này. Đối với các tài liệu viện dẫn ghi năm công bố thì áp dụng phiên bản được nêu. Đối với các tài liệu viện dẫn không ghi năm công bố thì áp dụng phiên bản mới nhất, bao gồm cả các sửa đổi, bổ sung (nếu có).
TCVN 5308:1991, Quy phạm kỹ thuật an toàn trong xây dựng.
TCVN 9393:2012, Cọc-Phương pháp thí nghiệm bằng tải trọng tĩnh ép dọc trục.
TCVN 9396:2012, Cọc khoan nhồi - Phương pháp xung siêu âm xác định tính đồng nhất của bê tông.
TCVN 9397:2012, Cọc - Thí nghiệm kiểm tra khuyết tật bằng phương pháp động biến dạng nhỏ.

# Thuật ngữ và định nghĩa

## Cọc khoan nhồi (Bored pile)

Loại cọc tiết diện tròn được thi công bằng cách khoan tạo lỗ trong đất sau đó lấp đầy bằng bê tông cốt thép.

## Dung dịch khoan (Stabilizing fluids)

Dung dịch gồm nước sạch và các hoá chất khác như bentonite, polime ... có khả năng tạo màng cách nước giữa thành hố khoan và đất xung quanh đồng thời giữ ổn định thành hố khoan.

## Thép gia cường (Stiffening rings)

Vòng thép tròn đặt phía trong cốt thép chủ của lồng thép để tăng độ cứng của lồng khi vận chuyển và lắp dựng.

## Con kê (Spacers)

Phụ kiện bằng thép bản hoặc xi măng-cát (hình tròn) dùng định vị lồng thép trong lỗ khoan.

# Quy định chung

  * Khi thi công gần các công trình hiện có phải có biện pháp quan trắc các công trình này và lựa chọn giải pháp thi công thích hợp để đảm bảo an toàn ổn định cho chúng. Nhà thầu được đưa các giải pháp đảm bảo an toàn công trình lân cận vào giá chào thầu.

  * Người chịu trách nhiệm thiết kế tổ chức thi công, chọn biện pháp, thiết bị phải có trình độ và kinh nghiệm thi công cọc nhồi qua ít nhất 1 công trình tương tự, cán bộ và công nhân tham gia thi công phải được huấn luyện và đào tạo tay nghề.

  * Nhà thầu cần lập biện pháp thi công đầy đủ bản vẽ và thuyết minh chi tiết trình chủ đầu tư phê duyệt trước khi tiến hành thi công. Trong khi thi công phải tiến hành kiểm tra từng công đoạn, khi đạt yêu cầu mới được thi công công đoạn tiếp theo.

  * Nghiệm thu móng cọc khoan nhồi dựa theo các quy định hiện hành.


# Công tác chuẩn bị

  * Để có đầy đủ số liệu cho thi công cọc đại trà, nhất là trong điều kiện địa chất phức tạp, các công trình quan trọng, cọc chịu tải trọng lớn, thời gian lắp dựng cốt thép, ống siêu âm và đổ bê tông một cọc kéo dài, Nhà thầu phải tiến hành thí nghiệm việc giữ thành hố khoan, thi công các cọc thử và tiến hành thí nghiệm cọc bằng tải trọng tĩnh, kiểm tra độ toàn khối của bê tông cọc theo quy định của Thiết kế.

  * Trước khi thi công cọc cần tiến hành kiểm tra các công tác chuẩn bị để thi công cọc theo biện pháp thi công được duyệt, có thể gồm:

  * Hiểu biết rõ điều kiện địa chất công trình và địa chất thuỷ văn, chiều dày, thế nằm và đặc trưng cơ lý của các lớp đất, kết quả quan trắc mực nước ngầm; áp lực nước lỗ rỗng, tốc độ dòng chảy của nước trong đất, khí độc hoặc khí dễ gây cháy nổ ...;

  * Tìm hiểu khả năng có các chướng ngại dưới đất để có biện pháp loại bỏ chúng, đề xuất biện pháp phòng ngừa ảnh hưởng xấu đến công trình lân cận và công trình ngầm; nếu chưa có hồ sơ hiện trạng các công trình lân cận và công trình ngầm, Nhà thầu phải yêu cầu Chủ đầu tư tiến hành công tác khảo sát, đo vẽ lập hồ sơ; biên bản lập với các chủ sở hữu các công trình liền kề phải được cơ quan có thẩm quyền bảo lãnh;

  * Nhà thầu tham khảo hồ sơ do Chủ đầu tư cấp là chính, nếu còn thiếu thì bổ sung trong hồ sơ dự thầu.

  * Kiểm tra vật liệu chính (thép, xi măng, dung dịch khoan, phụ gia, cát, đá, nước sạch...), chứng chỉ chất lượng của nhà sản xuất, và kết quả thí nghiệm kiểm định chất lượng;

  * Thi công lưới trắc đạc định vị các trục móng và toạ độ các cọc cần thi công;

  * Thi công các công trình phụ trợ, đường cấp điện, cấp thoát nước, hố rửa xe; hệ thống tuần hoàn vữa sét (kho chứa, trạm trộn, bể lắng, đường ống, máy bơm, máy tách cát..);

  * San ủi mặt bằng và làm đường phục vụ thi công, đủ để chịu tải trọng của thiết bị thi công lớn nhất, lập phương án vận chuyển đất thải, tránh gây ô nhiễm môi trường;

  * Tập kết vật tư kỹ thuật và thiết bị, kiểm tra máy móc, thiết bị trong tình trạng sẵn sàng hoạt động tốt; dụng cụ và thiết bị kiểm tra chất lượng phải có kiểm chuẩn của cơ quan đủ thẩm quyền;

  * Chuẩn bị dung dịch khoan, cốt thép cọc, ống siêu âm, ống đặt sẵn để khoan lấy lõi bê tông (nếu cần), thùng chứa đất khoan, máy khoan và các thiết bị phụ trợ (cần cẩu, máy bơm, máy trộn dung dịch, máy lọc cát, máy nén khí, máy hàn, tổ hợp ống đổ, sàn công tác phục vụ đổ bê tông, xe chở đất khoan) cùng các thiết bị để kiểm tra dung dịch khoan, lỗ khoan, dụng cụ kiểm tra độ sụt bê tông, hộp lấy mẫu bê tông, dưỡng định vị lỗ cọc...;

  * Lập biểu kiểm tra và nghiệm thu các công đoạn thi công theo mẫu in sẵn (xem Phụ lục C).


Hệ thống mốc chuẩn và mốc định vị trục móng phải đáp ứng điều kiện độ chính xác về tọa độ và cao độ theo yêu cầu kỹ thuật của công trình. Nhà thầu có trách nhiệm nhận và bảo quản hệ thống mốc chuẩn trong suốt quá trình thi công cọc.
Lập biên bản nghiệm thu công tác chẩn bị trước khi thi công.

# Dung dịch khoan

  * Tuỳ theo điều kiện địa chất, thuỷ văn, nước ngầm, thiết bị khoan để chọn phương pháp giữ thành hố khoan và dung dịch khoan thích hợp. Cao độ dung dịch khoan được chọn dựa trên tính toán theo nguyên lý cân bằng áp lực ngang giữa cột dung dịch trong hố khoan và áp lực của đất nền và nước quanh vách lỗ. Khi khoan trong địa tầng dễ sụt lở, áp lực cột dung dịch phải luôn lớn hơn áp lực ngang của đất và nước bên ngoài.

  * Khi áp lực ngang của đất và nước bên ngoài lỗ khoan lớn (do tải trọng của thiết bị thi công hay của các công trình lân cận sẵn có...) thì phải dùng ống vách để chống sụt lở, chiều sâu ống vách tính theo nguyên lý cân bằng áp nêu trên. Khi khoan gần công trình hiện hữu nếu có nguy cơ sập thành lỗ khoan thì phải dùng ống chống suốt chiều sâu lỗ cọc.

  * Dung dịch bentonite dùng giữ thành hố khoan nơi địa tầng dễ sụt lở cho mọi loại thiết bị khoan, giữ cho mùn khoan không lắng đọng dưới đáy hố khoan và đưa mùn khoan ra ngoài phải đảm bảo được yêu cầu giữ ổn định vách hố khoan trong suốt quá trình thi công cọc. Khi mực nước ngầm cao (lên đến mặt đất) cho phép tăng tỷ trọng dung dịch bằng các chất có tỷ trọng cao như barit, cát magnetic ...

  * Kiểm tra dung dịch bentonite từ khi chế bị cho tới khi kết thúc đổ bê tông từng cọc, kể cả việc điều chỉnh để đảm bảo độ nhớt và tỷ trọng thích hợp nhằm tránh lắng đáy cọc quá giới hạn cho phép cần tuân theo các quy định nêu trong Điều 12 và các yêu cầu đặc biệt (nếu có) của Thiết kế. Dung dịch có thể tái sử dụng trong thời gian thi công công trình nếu đảm bảo được các chỉ tiêu thích hợp, nhưng không quá 6 tháng.

  * Khi dùng dung dịch polime hoặc các hoá phẩm khác ngoài các chức năng giữ ổn định thành hố khoan phải kiểm tra ảnh hưởng của nó đến môi trường đất-nước (tại khu vực công trình và nơi chôn lấp đất khoan).


# Công tác tạo lỗ khoan

  * Khoan gần cọc mới đổ xong bê tông

  * Khoan trong đất no nước khi khoảng cách mép các lỗ khoan nhỏ hơn 1,5 m nên tiến hành cách quãng 1 lỗ, khoan các lỗ nằm giữa hai cọc đã đổ bê tông nên tiến hành sau ít nhất 24 h từ khi kết thúc đổ bê tông.

  * Thiết bị khoan tạo lỗ

  * Có nhiều thiết bị khoan tương ứng với các kiểu lấy đất đá trong lòng lỗ khoan như sau: choòng đập đá; gàu ngoạm; gàu xoay, thổi rửa để hút bùn theo chu trình thuận, nghịch ...Tuỳ theo đặc điểm địa chất công trình, vị trí công trình với các công trình lân cận, khả năng của Nhà thầu, yêu cầu của thiết kế mà chọn lựa thiết bị khoan thích hợp.

  * Ống chống tạm

  * Ống chống tạm (casing) dùng bảo vệ thành lỗ khoan ở phần đầu cọc, tránh lở đất bề mặt đồng thời là ống dẫn hướng cho suốt quá trình khoan tạo lỗ. Khi hạ ống nên có dưỡng định vị để đảm bảo sai số cho phép.

  * Ống chống tạm được chế tạo thường từ 6 m đến 10 m trong các xưởng cơ khí chuyên dụng, chiều dày ống thường từ 6 mm đến 16 mm.

  * Cao độ đỉnh ống cao hơn mặt đất hoặc nước cao nhất tối thiểu 0,3 m. Cao độ chân ống đảm bảo sao cho áp lực cột dung dịch lớn hơn áp lực chủ động của đất nền và hoạt tải thi công phía bên ngoài.

  * Ống chống tạm được hạ và rút chủ yếu bằng thiết bị thuỷ lực hoặc thiết bị rung kèm theo máy khoan, khi không có thiết bị này có thể dùng búa rung đóng kết hợp lấy đất bằng gầu hoặc hạ bằng kích ép thuỷ lực.

  * Cao độ dung dịch khoan

  * Cao độ dung dịch khoan trong lỗ phải luôn giữ sao cho áp lực của dung dịch khoan luôn lớn hơn áp lực của đất và nước ngầm phía ngoài lỗ khoan để tránh hiện tượng sập thành trước khi đổ bê tông. Cao độ dung dịch khoan nên cao hơn mực nước ngầm ít nhất là 1,5 m. Khi có hiện tượng thất thoát dung dịch trong hố khoan nhanh thì phải có biện pháp xử lý kịp thời.

  * Đo đạc trong khi khoan

  * Đo đạc trong khi khoan gồm kiểm tra tim cọc bằng máy kinh vĩ và đo đạc độ sâu các lớp đất qua mùn khoan lấy ra và độ sâu hố khoan theo thiết kế. Các lớp đất theo chiều sâu khoan phải được ghi chép trong nhật ký khoan và hồ sơ nghiệm thu cọc (xem Phụ lục C). Khoảng 2,0 m lấy mẫu một lần. Khi phát hiện địa tầng khác với hồ sơ khảo sát địa chất công trình cần báo ngay cho Chủ đầu tư để có biện pháp xử lý kịp thời. Khi khoan đến cao độ thiết kế, tiến hành đo độ lắng. Độ lắng được xác định bằng chênh lệch chiều sâu giữa hai lần đo lúc khoan xong và sau 30 min. Nếu độ lắng vượt quá quy định cần xử lý kịp thời.


  * 


# Công tác gia công và hạ cốt thép

  * Cốt thép được gia công theo bản vẽ thiết kế thi công. Nhà thầu phải bố trí mặt bằng gia công, nắn cốt thép, đánh gỉ, uốn đai, cắt và buộc lồng thép theo đúng quy định.

  * Cốt thép được chế tạo sẵn trong xưởng hoặc tại công trường, chế tạo thành từng lồng, chiều dài lớn nhất của mỗi lồng phụ thuộc khả năng cẩu lắp và chiều dài xuất xưởng của cốt chủ. Lồng thép phải có thép gia cường ngoài cốt chủ và cốt đai theo tính toán để đảm bảo lồng thép không bị xoắn, méo. Lồng thép phải có móc treo bằng cốt thép chuyên dùng làm móc cẩu, số lượng móc treo phải tính toán đủ để treo cả lồng vào thành ống chống tạm mà không bị tuột xuống đáy hố khoan, hoặc cấu tạo guốc cho đoạn lồng dưới cùng tránh lồng thép bị lún nghiêng cũng như để đảm bảo chiều dày lớp bê tông bảo hộ dưới đáy cọc.

  * Cốt gia cường thường dùng cùng đường kính với cốt chủ, uốn thành vòng đặt phía trong cốt chủ khoảng cách từ 2,5 m đến 3,0 m, liên kết với cốt chủ bằng hàn đính và dây buộc theo yêu cầu của thiết kế. Khi chuyên chở, cẩu lắp có thể dùng cách chống tạm bên trong lồng thép để tránh hiện tượng biến hình.

  * Định tâm lồng thép bằng các con kê chế tạo từ thép trơn hàn vào cốt chủ đối xứng qua tâm cọc, hoặc bằng các viên tròn xi măng - cát, theo nguyên lý bánh xe trượt, cố định vào giữa 2 thanh cốt chủ bằng thanh thép trục. Chiều rộng hoặc bán kính con kê phụ thuộc vào chiều dày lớp bảo hộ, thông thường là 5 cm. Số lượng con kê phải đủ để hạ lồng thép chính tâm.

  * Nối các đoạn lồng thép chủ yếu bằng dây buộc, chiều dài mối nối theo quy định của thiết kế. Khi cọc có chiều dài lớn, Nhà thầu phải có thêm biện pháp gia cường mối nối để tránh tụt lồng thép khi lắp hạ.

  * Ống siêu âm (thường là ống thép đường kính 60 mm) cần được buộc chặt vào cốt thép chủ, đáy ống được bịt kín và hạ sát xuống đáy cọc, nối ống bằng hàn, có măng xông, đảm bảo kín, tránh rò rỉ nước xi măng làm tắc ống, khi lắp đặt cần đảm bảo đồng tâm. Chiều dài ống siêu âm theo chỉ định của thiết kế, thông thường được đặt cao hơn mặt đất san lấp xung quanh cọc từ 10 cm đến 20 cm. Sau khi đổ bê tông các ống được đổ đầy nước sạch và bịt kín, tránh vật lạ rơi vào làm tắc ống.

  * CHÚ THÍCH: Số lượng ống siêu âm cho 1 cọc thường quy định như sau:


  2. ống cho cọc có đường kính 60 cm;


3 ống cho cọc có đường kính từ 60 cm đến 100 cm
4 ống cho cọc có đường kính lớn hơn 100 cm.

# Xử lý cặn lắng đáy lỗ khoan trước khi đổ bê tông

  * Sau khi hạ cốt thép mà cặn lắng vẫn quá quy định phải dùng biện pháp khí nâng (air lift) hoặc bơm hút bằng máy bơm. Liên tục bổ sung dung dịch khoan để đảm bảo cao độ dung dịch theo quy định, tránh gây sập thành lỗ khoan.

  * Công nghệ khí nâng được dùng để làm sạch hố khoan. Khí nén được đưa xuống gần đáy hố khoan qua ống thép đường kính khoảng 60 mm, dày từ 3 mm đến 4 mm, cách đáy khoảng từ 50 cm đến 60 cm. Khí nén trộn với bùn nặng tạo thành loại bùn nhẹ dâng lên theo ống đổ bê tông (ống tremi) ra ngoài; bùn nặng dưới đáy ống tremi lại được trộn với khí nén thành bùn nhẹ; dung dịch khoan tươi được bổ sung liên tục bù cho bùn nặng đã trào ra; quá trình thổi rửa tiến hành cho tới khi các chỉ tiêu của dung dịch khoan và độ lắng đạt yêu cầu quy định.


# Đổ bê tông

  * Bê tông dùng thi công cọc khoan nhồi phải được thiết kế thành phần hỗn hợp và điều chỉnh bằng thí nghiệm, các loại vật liệu cấu thành hỗn hợp bê tông phải được kiểm định chất lượng theo các tiêu chuẩn Việt Nam hiện hành. Có thể dùng phụ gia bê tông để tăng độ sụt của bê tông và kéo dài thời gian ninh kết của bê tông. Ngoài việc đảm bảo yêu cầu của thiết kế về cường độ, hỗn hợp bê tông có độ sụt từ 18 cm đến 20 cm.

  * Ống đổ bê tông được chế bị trong nhà máy thường có đường kính từ 219 mm đến 273 mm theo tổ hợp 0,5; 1,0; 2,0; 3,0 và 6,0 m, ống dưới cùng được tạo vát hai bên để làm cửa xả, nối ống bằng ren hình thang hoặc khớp nối dây rút đặc biệt, đảm bảo kín khít, không lọt dung dịch khoan vào trong. Đáy ống đổ bê tông phải luôn ngập trong bê tông không ít hơn 1,5 m.

  * Dùng nút dịch chuyển tạm thời (dùng phao bằng bọt biển hoặc nút cao su, nút nhựa có vát côn), đảm bảo cho mẻ vữa bê tông đầu tiên không tiếp xúc trực tiếp với dung dịch khoan trong ống đổ bê tông và loại trừ khoảng chân không khi đổ bê tông.

  * Bê tông được đổ không gián đoạn trong thời gian dung dịch khoan có thể giữ thành hố khoan (thông thường là 4 h). Các xe bê tông đều được kiểm tra độ sụt đúng quy định để tránh tắc ống đổ do vữa bê tông quá khô. Dừng đổ bê tông khi cao độ bê tông cọc cao hơn cao độ cắt cọc khoảng 1 m (để loại trừ phần bê tông lẫn dung dịch khoan khi thi công đài cọc).

  * Sau khi đổ xong mỗi xe, tiến hành đo độ dâng của bê tông trong lỗ cọc, ghi vào hồ sơ để vẽ đường đổ bê tông. Khối lượng bê tông thực tế so với kích thước lỗ cọc theo lý thuyết không được vượt quá 20 %. Khi tổn thất bê tông lớn phải kiểm tra lại biện pháp giữ thành lỗ khoan.


# Rút ống vách và vệ sinh đầu cọc

  * Sau khi kết thúc đổ bê tông từ 15 min đến 20 min cần tiến hành rút ống chống tạm (casing) bằng hệ thống day (rút + xoay) của máy khoan hoặc đầu rung theo phương thẳng đứng, đảm bảo ổn định đầu cọc và độ chính xác tâm cọc.

  * Sau khi rút ống vách từ 1 h đến 2 h cần tiến hành hoàn trả hố khoan bằng cách lấp đất hoặc cát, cắm biển báo cọc đã thi công cấm mọi phương tiện qua lại tránh hỏng đầu cọc và ống siêu âm.


# Kiểm tra và nghiệm thu

  * Chất lượng cọc được kiểm tra trong tất cả các công đoạn thi công, ghi vào mẫu biên bản được thống nhất giữa các bên tham gia nghiệm thu, tham khảo Phụ lục C.

  * Kiểm tra dung dịch khoan

  * Dung dịch khoan phải được chuẩn bị trong các bồn chứa có dung tích đủ lớn, pha với nước sạch, cấp phối tuỳ theo chủng loại bentonite, điều kiện địa chất công trình và địa chất thuỷ văn của địa điểm xây dựng, đảm bảo giữ thành hố khoan trong suốt quá trình thi công khoan lỗ, lắp dựng cốt thép, ống kiểm tra siêu âm, ống đặt sẵn để khoan lấy lõi đáy cọc (nếu có), cẩu lắp ống đổ bê tông và sàn công tác... Bề dày lớp cặn lắng đáy cọc không quá trị số sau:


  * Cọc chống: không quá 5 cm;

  * Cọc ma sát + chống: không quá 10 cm.


  * Kiểm tra dung dịch khoan bằng các thiết bị thích hợp. Dung trọng của dung dịch trộn mới được kiểm tra hàng ngày để biết chất lượng, việc đo lường dung trọng nên đạt tới độ chính xác 0,005 g/cm³. Các thí nghiệm kiểm tra dung dịch bentonite tiến hành theo quy định tại Bảng 1 cho mỗi lô bentonite trộn mới. Việc kiểm tra, nghiệm thu dung trọng, độ nhớt, hàm lượng cát và độ pH phải được kiểm tra cho từng cọc. Trước khi đổ bê tông nếu kiểm tra mẫu dung dịch tại độ sâu khoảng 0,5 m từ đáy lên có khối lượng riêng vượt quá 1,25 g/cm³, hàm lượng cát lớn hơn 8 %, độ nhớt quá 28 s thì phải có biện pháp thổi rửa đáy lỗ khoan để đảm bảo chất lượng cọc.

  * Kiểm tra lỗ khoan


CHÚ THÍCH: Kích thước lỗ khoan khuyến khích Nhà thầu tự kiểm tra để hoàn thiện công nghệ, hiện tại trong thực tế chưa bắt buộc phải đo đường kính lỗ (chỉ khống chế chiều sâu, độ lắng đáy và khối lượng bê tông).
CHÚ THÍCH 1: Giá trị âm ở sai số cho phép về đường kính cọc chỉ ở tiết diện cọc cá biệt.
CHÚ THÍCH 2: Sai số về độ nghiêng của cọc xiên không lớn hơn 15 % góc nghiêng của cọc.
CHÚ THÍCH 3: Sai số cho phép về độ sâu hố khoan ± 10 cm.
CHÚ THÍCH 4: D là đường kính thiết kế cọc, H là khoảng cách giữa cao độ mặt đất thực tế và cao độ căt cọc trong thiết kế.
Kiểm tra cốt thép
Sai số cho phép về lồng cốt thép do thiết kế quy định và tham khảo Bảng 4.
Bảng 4- Sai số cho phép chế tạo lồng thép.


|  | Hạng mục | Sai số cho phép, mm |
| --- | --- | --- |
| 1. | Khoảng cách giữa các cốt chủ | ± 10 |
| 2. | Khoảng cách cốt đai hoặc cốt lò so | ±20 |
| 3. | Đường kính lồng thép | ± 10 |
| 4. | Độ dài lồng thép | ±50 |

 

## Kiểm tra chất lượng bê tông thân cọc

### Bê tông trước khi đổ phải lấy mẫu, mỗi cọc 3 tổ mẫu lấy cho ba phần, đầu, giữa và mũi cọc, mỗi tổ 3 mẫu.

Cốt liệu, nước và xi măng được thử mẫu, kiểm tra theo quy định cho công tác bê tông. Kết quả ép mẫu kèm theo lý lịch cọc.

### Phương pháp siêu âm, tán xạ Gamma, phương pháp động biến dạng nhỏ...và các phương pháp thử không phá hoại khác được dùng để đánh giá chất lượng bê tông cọc đã thi công, tuỳ theo mức độ quan trọng của công trình, thiết kế chỉ định số lượng cọc cần kiểm tra.

Đối với các công trình dân dụng và công nghiệp thông thường, khối lượng kiểm tra chất lượng bê tông cọc tối thiểu theo Bảng 5. Cần kết hợp từ 2 phương pháp khác nhau trở lên để kiểm tra. Khi cọc có chiều sâu lớn hơn 30 lần đường kính (L/D > 30) thì phương pháp kiểm tra qua ống đặt sẵn là chủ yếu. Nếu còn nghi ngờ khuyết tật cần kiểm tra bằng khoan lấy mẫu để khẳng định khả năng chịu tải lâu dài của cọc trước khi có quyết định sửa chữa hoặc thay thế. Quyết định cuối cùng do Thiết kế kiến nghị, Chủ đầu tư chấp thuận. Thí nghiệm siêu âm tiến hành theo TCVN 9396:2012. Thí nghiệm động biến dạng nhỏ tiến hành theo TCVN 9397:2012.

### Phương pháp khoan kiểm tra tiếp xúc đáy cọc với đất tiến hành trong ống đặt sẵn, đường kính từ 102 mm đến 114 mm cao hơn mũi cọc từ 1 m đến 2 m, số lượng ống đặt sẵn để khoan lõi đáy cọc theo quy định của Thiết kế, tham khảo Bảng 5. Khi mũi cọc tựa vào cuội hòn lớn, có thể bị mất nước xi măng ở phần tiếp xúc đáy cọc - cuội sỏi, cần thận trọng khi đánh giá chất lượng bê tông cọc.

Bảng - Khối lượng kiểm tra chất lượng bê tông cọc


| Phương pháp kiểm tra | Tỷ lệ kiểm tra tối thiểu, % số cọc |
| --- | --- |

 

## Kiểm tra sức chịu tải của cọc đơn

### Sức chịu tải của cọc đơn do thiết kế xác định. 

Tuỳ theo mức độ quan trọng của công trình và tính phức tạp của điều kiện địa chất công trình mà thiết kế quy định số lượng cọc cần kiểm tra sức chịu tải.
CHÚ THÍCH 1: Thang điểm để chọn số lượng cọc cần kiểm tra tính toàn khối tham khảo Phụ lục A
CHÚ THÍCH 2: Đánh giá và xử lý cọc khoan nhồi có thể tham khảo Phụ lục B.
1 Số lượng cọc cần kiểm tra sức chịu tải được quy định dựa trên mức độ hoàn thiện công nghệ của Nhà thầu, mức độ rủi ro khi thi công, tầm quan trọng của công trình, nhưng tối thiểu là mỗi loại đường kính 1 cọc, tối đa là 2 % tổng số cọc. Kết quả thí nghiệm là căn cứ pháp lý để nghiệm thu móng cọc.

### Phương pháp kiểm tra sức chịu tải của cọc đơn chủ yếu là thử tĩnh (nén tĩnh, nhổ tĩnh, nén ngang) theo tiêu chuẩn hiện hành. 

Đối với các cọc không thể thử tĩnh được (cọc trên sông, biển...) thì dùng phương pháp thí nghiệm động biến dạng lớn (PDA), Osterberg, Statnamic ...

### Tiến hành thử tĩnh cọc có thể trước hoặc sau khi thi công cọc đại trà. Để xác định phương án thiết kế có thể tiến hành thử tĩnh cọc ngoài móng công trình đến phá hoại trước khi thi công đại trà; để chấp nhận chất lượng thi công có thể tiến hành thí nghiệm khi thi công xong. Đầu cọc thí nghiệm phải cao hơn mặt đất xung quanh từ 20 cm đến 30 cm và có ống thép dày từ 5 mm đến 6 mm, dài khoảng 1 m bao để đảm bảo không bị nứt khi thí nghiệm và phản ánh đúng chất lượng thi công. Thí nghiệm nén tĩnh tiến hành theo TCVN 9393:2012.

## Nghiệm thu cọc khoan nhồi

Nghiệm thu công tác thi công cọc tiến hành dựa trên cơ sơ các hồ sơ sau:

  * Hồ sơ thiết kế dược duyệt;

  * Biên bản nghiệm thu trắc đạc định vị trục móng cọc;

  * Kết quả kiểm định chất lượng vật liệu, chứng chỉ xuất xưởng của cốt thép và các loại vật liệu chế tạo trong nhà máy;

  * Kết quả thí nghiệm mẫu bê tông;

  * Hồ sơ nghiệm thu từng cọc, tham khảo Phụ lục C; thành phần nghiệm thu theo quy định hiện hành;

  * Hồ sơ hoàn công cọc có thuyết minh sai lệch theo mặt bằng và chiều sâu cùng các cọc bổ sung và các thay đổi thiết kế đã được chấp thuận;

  * Các kết quả thí nghiệm kiểm tra độ toàn khối của cọc (siêu âm, thí nghiệm biến dạng nhỏ (PIT)...) theo quy định của Thiết kế;

  * Các kết quả thí nghiệm kiểm tra sức chịu tải của cọc.


# Các biện pháp an toàn lao động

  * Công tác an toàn lao động cần tuân theo TCVN 5308:1991 và các quy định an toàn hiện hành liên quan.

  * Tất cả các loại máy móc, thiết bị vân hành phải tuyệt đối tuân theo quy trình thao tác và quy trình an toàn, đặc biệt là quy trình an toàn cho xe cẩu và máy khoan.

  * Lắp dựng hệ thống biển báo khu vực nguy hiểm, khu vực cọc vừa mới đổ xong bê tông, cấm di chuyển qua các khu vực này.

  * Khi bị tắc ống đổ bê tông, Nhà thầu phải có phương án xử lý được thiết kế chấp thuận và chỉ được xử lý theo lệnh của người chỉ huy chung.

# Public_017

# Yêu cầu đối với tính toán kết cấu bê tông và bê tông cốt thép

## Yêu cầu chung

### Tính toán kết cấu bê tông và bê tông cốt thép cần được tiến hành phù hợp với các yêu cầu của

TCVN 9379:2012 theo các trạng thái giới hạn, bao gồm:

  * Các trạng thái giới hạn thứ nhất, dẫn tới mất hoàn toàn khả năng sử dụng kết cấu;

  * Các trạng thái giới hạn thứ hai, làm khó khăn cho sử dụng bình thường hoặc giảm độ bền lâu của nhà và công trình so với thời hạn sử dụng đã dự định.


Các tính toán cần phải đảm bảo được độ tin cậy của nhà và công trình trong suốt thời hạn sử dụng của chúng, cũng như trong quá trình thi công phù hợp với các yêu cầu đề ra đối với chúng.

Các tính toán theo các trạng thái giới hạn thứ nhất bao gồm:

  * Tính toán độ bền;

  * Tính toán ổn định hình dạng (đối với kết cấu thành mỏng); Tính toán ổn định ví trí (lật, trượt, đẩy nổi).

  * Tính toán độ bền kết cấu bê tông và bê tông cốt thép cần được tiến hành theo điều kiện mà trong đó nội lực, ứng suất và biến dạng trong kết cấu do các tác động khác nhau có kể đến trạng thái ứng suất ban đầu (ứng suất trước, tác động nhiệt độ và tác động khác) không được vượt quá các giá trị mà kết cấu có thể chịu được.

  * Tính toán ổn định hình dạng kết cấu, cũng như ổn định vị trí (có kể đến sự làm việc đồng thời của kết cấu và nền, các tính chất biến dạng của chúng, khả năng chống trượt tại bề mặt tiếp xúc với nền và các đặc điểm riêng khác) cần được tiến hành theo các chỉ dẫn của các tiêu chuẩn áp dụng cho các loại kết cấu riêng.


Trong các trường hợp cần thiết, tùy thuộc vào loại, công năng kết cấu cần tiến hành các tính toán theo các trạng thái giới hạn liên quan đến các hiện tượng dẫn đến phải dừng sử dụng nhà và công trình (biến dạng quá mức, trượt trong các liên kết và các hiện tượng khác).

Tính toán theo các trạng thái giới hạn thứ hai bao gồm:

  * Tính toán hình thành vết nứt; Tính toán mở rộng vết nứt;


## Tính toán biến dạng.

  * Tính toán kết cấu bê tông và bê tông cốt thép theo sự hình thành vết nứt cần được tiến hành theo điều kiện mà trong đó ứng suất hoặc biến dạng trong kết cấu do các tác động khác nhau không được vượt quá các giá trị giới hạn tương ứng của chúng do kết cấu phải chịu khi hình thành vết nứt.

  * Tính toán kết cấu bê tông và bê tông cốt thép theo sự mở rộng vết nứt cần được tiến hành theo điều kiện mà trong đó chiều rộng vết nứt trong kết cấu do các tác động khác nhau không được vượt quá các giá trị giới hạn cho phép được quy định phụ thuộc vào các yêu cầu đối với kết cấu, các điều kiện sử dụng chúng, tác động của môi trường xung quanh và các đặc trưng vật liệu có kể đến các đặc điểm riêng về ứng xử ăn mòn của cốt thép.

  * Tính toán kết cấu bê tông và bê tông cốt thép theo biến dạng cần được tiến hành theo điều kiện mà trong đó độ võng, góc xoay, chuyển vị và biên độ dao động của kết cấu do các tác động khác nhau không được vượt quá các giá trị giới hạn cho phép tương ứng.


Đối với kết cấu mà trong đó không cho phép hình thành vết nứt thì cần phải đảm bảo các yêu cầu không xuất hiện vết nứt. Trong trường hợp này, không cần tính toán mở rộng vết nứt.
Đối với các kết cấu khác mà trong đó cho phép hình thành vết nứt thì tính toán theo sự hình thành vết nứt được tiến hành để xác định sự cần thiết phải tính toán theo sự mở rộng vết nứt và kể đến vết nứt trong tính toán biến dạng.

### Tính toán kết cấu bê tông và bê tông cốt thép (dạng thanh, phẳng, không gian, khối) theo các trạng thái giới hạn thứ nhất và thứ hai được tiến hành theo ứng suất, nội lực, biến dạng và chuyển vị đã tính được do các tác động ngoài trong các kết cấu và được hình thành trong các hệ được tạo ra từ các kết cấu của nhà và công trình có kể đến tính phi tuyến vật lý (biến dạng không đàn hồi của bê tông và cốt thép), khả năng hình thành vết nứt và trong các trường hợp cần thiết – tính không đẳng hướng, sự tích tụ hư hỏng và tính phi tuyến hình học (ảnh hưởng của biến dạng đến sự thay đổi nội lực trong kết cấu).

  * Tính phi tuyến vật lý và tính không đẳng hướng cần được kể đến trong các quan hệ giữa ứng suất và biến dạng (hoặc nội lực và chuyển vị), cũng như trong các điều kiện độ bền và độ chống nứt của vật liệu.

  * Trong các kết cấu siêu tĩnh cần kể đến sự phân bố lại nội lực trong các cấu kiện của hệ kết cấu do hình thành vết nứt và phát triển các biến dạng không đàn hồi trong bê tông và cốt thép đến tận khi xuất hiện trạng thái giới hạn trong cấu kiện. Khi không có các phương pháp tính toán mà có thể kể đến được các tính chất không đàn hồi của bê tông cốt thép, cũng như đối với các tính toán sơ bộ có kể đến các tính chất không đàn hồi của bê tông cốt thép thì cho phép xác định nội lực và ứng suất trong các kết cấu và các hệ siêu tĩnh với giả thiết sự làm việc đàn hồi của các cấu kiện bê tông cốt thép. Khi đó, ảnh hưởng của tính phi tuyến vật lý nên được kể đến bằng cách hiệu chỉnh các kết quả tính toán đàn hồi trên cơ sở các số liệu nghiên cứu thực nghiệm, mô hình phi tuyến, kết quả tính toán các công trình tương tự và các đánh giá chuyên gia.

  * Khi tính toán kết cấu theo độ bền, biến dạng, hình thành và mở rộng vết nứt trên cơ sở phương pháp phần tử hữu hạn thì cần phải kiểm tra các điều kiện độ bền và độ chống nứt đối với tất cả các phần tử hữu hạn tạo nên kết cấu, cũng như các điều kiện xuất hiện các chuyển vị quá mức của kết cấu. Khi đánh giá trạng thái giới hạn về độ bền thì cho phép giả thiết rằng các phần tử hữu hạn riêng lẻ bị phá hoại, nếu như điều này không dẫn đến phá hủy dây chuyền (lũy tiến) nhà hoặc công trình, và khi tác động đang xét thôi tác dụng thì khả năng sử dụng bình thường của nhà hoặc công trình được bảo toàn hoặc có thể khôi phục được.

  * Xác định các nội lực và biến dạng giới hạn trong các kết cấu bê tông và bê tông cốt thép cần được tiến hành dựa trên các sơ đồ (mô hình) tính toán phản ánh được thực chất đặc điểm vật lý về sự làm việc của các kết cấu và vật liệu ở trạng thái giới hạn đang xét.

  * Cho phép xác định khả năng chịu lực của các kết cấu bê tông cốt thép mà có thể chịu được các biến dạng dẻo (ví dụ: khi sử dụng cốt thép có giới hạn chảy thực tế) bằng phương pháp cân bằng giới hạn.


###  Khi tính toán các kết cấu bê tông và bê tông cốt thép theo các trạng thái giới hạn thì cần xét các trường hợp tính toán khác nhau phù hợp với TCVN 9379:2012, trong đó có giai đoạn chế tạo, vận chuyển, sử dụng, các trường hợp sự cố, cũng như trường hợp có cháy.

### Tính toán kết cấu bê tông và bê tông cốt thép cần được tiến hành với tất cả các loại tải trọng theo chức năng của nhà và công trình, có kể đến ảnh hưởng của môi trường xung quanh (các tác động khí hậu và nước – đối với các kết cấu nằm trong nước), còn trong các trường hợp cần thiết – có kể đến tác động của lửa, các tác động công nghệ, các tác động nhiệt độ và ẩm và các tác động của môi trường hóa học xâm thực.

### Tính toán kết cấu bê tông và bê tông cốt thép được tiến hành dưới tác dụng của mô men uốn, lực dọc, lực cắt và mô men xoắn, cũng như dưới tác dụng cục bộ của tải trọng.

### Khi tính toán các cấu kiện của các kết cấu lắp ghép chịu tác dụng của nội lực sinh ra khi nâng, vận chuyển và lắp dựng, thì tải trọng do trọng lượng các cấu kiện cần được nhân với hệ số động lực bằng 1,60 khi vận chuyển và bằng 1,40 khi nâng và lắp dựng.

Khi có cơ sở thì cho phép lấy giá trị hệ số động lực thấp hơn, nhưng không thấp hơn 1,25.

### Khi tính toán các kết cấu bê tông và bê tông cốt thép cần kể đến các đặc điểm riêng của các tính chất của các loại bê tông và cốt thép, ảnh hưởng của đặc điểm tải trọng và môi trường xung quanh đến chúng, biện pháp đặt cốt thép, sự làm việc đồng thời của cốt thép và bê tông (khi có hoặc không có bám dính giữa cốt thép và bê tông), công nghệ chế tạo các loại cấu kiện bê tông cốt thép của nhà và công trình.

### Tính toán các kết cấu ứng suất trước cần được tiến hành có kể đến ứng suất ban đầu (ứng suất trước) và biến dạng trong cốt thép và bê tông, hao tổn ứng suất trước và các đặc điểm truyền lực nén trước lên bê tông.

### Trong các kết cấu liền khối cần phải đảm bảo được độ bền của các kết cấu có kể đến các mạch ngừng thi công.

### Khi tính toán kết cấu lắp ghép cần phải đảm bảo độ bền của các liên kết nút và liên kết đối đầu của các cấu kiện lắp ghép đã được thực hiện bằng cách nối các chi tiết thép đặt sẵn, các đầu thép chờ và đổ bù bằng bê tông.

### Khi tính toán các kết cấu phẳng và kết cấu không gian chịu tác động của lực theo hai phương vuông góc nhau thì cần xét các phần tử phẳng nhỏ hoặc không gian điển hình tách từ kết cấu với các nội lực tác dụng theo các cạnh bên của phần tử. Khi có các vết nứt thì các nội lực này cần được xác định có kể đến vị trí các vết nứt, độ cứng của cốt thép (độ cứng dọc trục và tiếp tuyến), độ cứng của bê tông (nằm giữa các vết nứt và ở tại các vết nứt) và các đặc điểm riêng khác. Khi không có vết nứt thì nội lực được xác định như đối với vật thể đặc. Khi có các vết nứt thì cho phép xác định nội lực với giả thiết cấu kiện bê tông làm việc đàn hồi. Tính toán các cấu kiện cần được tiến hành theo các tiết diện nguy hiểm nhất nằm dưới một góc so với phương nội lực tác dụng lên cấu kiện, trên cơ sở các mô hình tính toán có kể đến sự làm việc của cốt thép chịu kéo ở vị trí có vết nứt và sự làm việc của bê tông giữa các vết nứt trong các điều kiện trạng thái ứng suất phẳng.

### Tính toán các kết cấu phẳng và không gian cho phép được tiến hành đối với kết cấu về tổng thể dựa trên phương pháp cân bằng giới hạn, kể cả có kể đến trạng thái biến dạng tại thời điểm gần phá hoại.

### Khi tính toán các kết cấu khối chịu tác động của lực theo ba phương trực giao thì cần xét các phần tử khối nhỏ điển hình tách từ kết cấu với các nội lực tác dụng theo các mặt của phẩn tử. Khi đó, các nội lực cần được xác định dựa trên giả thiết tương tự đã được chấp nhận đối với các phần tử phẳng 

Tính toán các cấu kiện cần được tiến hành theo các tiết diện nguy hiểm nhất nằm dưới một góc so với phương nội lực tác dụng lên cấu kiện, trên cơ sở các mô hình tính toán có kể đến sự làm việc của bê tông và cốt thép trong các điều kiện trạng thái ứng suất khối.

### Đối với các kết cấu có cấu hình phức tạp (ví dụ, kết cấu không gian) thì ngoài các phương pháp tính toán để đánh giá khả năng chịu lực, khả năng chống nứt và biến dạng, cũng có thể sử dụng các kết quả thử nghiệm mô hình kết cấu.

## Yêu cầu đối với tính toán cấu kiện bê tông và bê tông cốt thép theo độ bền

Tính toán kết cấu bê tông và bê tông cốt thép theo độ bền được tiến hành:
Theo các tiết diện thẳng góc (khi có tác dụng của mô men uốn và lực dọc) – theo mô hình biến dạng phi tuyến. Đối với các loại kết cấu bê tông cốt thép đơn giản (tiết diện chữ nhật, chữ T và chữ I với cốt thép nằm ở biên trên và biên dưới của tiết diện) thì cho phép tiến hành tính toán theo nội lực giới hạn;
Theo tiết diện nghiêng (khi có tác dụng của lực cắt), theo tiết diện không gian (khi có tác dụng của mô men xoắn), chịu tác dụng cục bộ của tải trọng (nén cục bộ, chọc thủng)
Tính toán độ bền các cấu kiện bê tông cốt thép ngắn (công xôn ngắn và các cấu kiện khác tương tự) được tiến hành theo mô hình thanh – giàn (giàn ảo).

### Tính toán độ bền cấu kiện bê tông và bê tông cốt thép theo nội lực giới hạn được tiến hành theo điều kiện mà nội lực do tải trọng và tác động ngoài _F_ trong tiết diện đang xét không vượt quá nội

lực giới hạn _Fu_ mà cấu kiện có thể chịu được trong tiết diện này:

### Các cấu kiện bê tông, tùy thuộc vào điều kiện làm việc và yêu cầu đối với chúng, cần được tính toán theo các tiết diện thẳng góc theo nội lực giới hạn không kể đến hoặc có kể đến cường độ chịu kéo của bê tông vùng chịu kéo.

### Tiến hành tính toán không kể đến cường độ chịu kéo của bê tông đối với các cấu kiện bê tông chịu nén lệch tâm với độ lệch tâm của lực dọc không vượt quá 0,9 khoảng cách từ trọng tâm tiết diện đến thớ chịu nén nhiều nhất. Khi đó, nội lực giới hạn, mà cấu kiện có thể chịu được, được xác định theo cường độ chịu nén tính toán của bê tông _Rb_ , phân bố đều trên vùng chịu nén quy ước của tiết diện có trọng tâm trùng với điểm đặt lực dọc.

Đối với kết cấu bê tông dạng khối thì sử dụng biểu đồ ứng suất trong vùng chịu nén dạng tam giác với ứng suất không vượt quá giá trị tính toán của cường độ chịu nén tính toán của bê tông _Rb_. Khi đó, độ lệch tâm của lực dọc đối với trọng tâm tiết diện không được vượt quá 0,65 khoảng cách từ trọng tâm tiết diện đến thớ bê tông chịu nén nhiều nhất.

### Tiến hành tính toán có kể đến cường độ chịu kéo của bê tông đối với các cấu kiện bê tông chịu nén lệch tâm với độ lệch tâm của lực dọc lớn hơn giá trị nêu đối với cấu kiện bê tông chịu uốn (mà được phép sử dụng), cũng như đối với cấu kiện chịu nén lệch tâm với độ lệch tâm của lực dọc bằng giá trị, nhưng trong đó không cho phép hình thành vết nứt theo các điều kiện sử dụng. Khi đó, nội lực giới hạn, mà tiết diện cấu kiện có thể chịu được, được xác định như đối với vật thể đàn hồi với ứng suất kéo lớn nhất bằng giá trị tính toán của cường độ chịu kéo dọc trục của bê tông _Rbt_.

### Khi tính toán cấu kiện bê tông chịu nén lệch tâm cần kể đến ảnh hưởng của uốn dọc và độ lệch tâm ngẫu nhiên.

## Tính toán cấu kiện bê tông cốt thép theo độ bền tiết diện thẳng góc

### Tính toán cấu kiện bê tông cốt thép theo nội lực giới hạn cần được tiến hành với các nội lực giới hạn mà bê tông và cốt thép có thể chịu được, dựa trên các giả thiết sau:

  * Cường độ chịu kéo của bê tông lấy bằng không;

  * Cường độ chịu nén của bê tông lấy bằng ứng suất có giá trị bằng cường độ chịu nén tính toán của bê tông và được phân bố đều trên vùng chịu nén quy ước của bê tông;

  * Ứng suất kéo và nén trong cốt thép lấy không lớn hơn cường độ chịu kéo tính toán và chịu nén tính toán tương ứng.


### Tính toán cấu kiện bê tông cốt thép theo mô hình biến dạng phi tuyến được tiến hành trên cơ sở các biểu đồ biến dạng của bê tông và cốt thép, xuất phát từ giả thiết tiết diện phẳng. Tiêu chí độ bền của tiết diện thẳng góc là biến dạng tương đối trong bê tông hoặc cốt thép đạt tới giá trị giới hạn.

### Khi tính toán cấu kiện bê tông cốt thép chịu nén lệch tâm cần kể đến ảnh hưởng của uốn dọc và độ lệch tâm ngẫu nhiên.

## Tính toán cấu kiện bê tông cốt thép theo độ bền tiết diện nghiêng

### Tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện nghiêng được tiến hành: theo tiết diện nghiêng chịu tác dụng của lực cắt, theo tiết diện nghiêng chịu tác dụng của mô men uốn và theo dải bê tông giữa các tiết diện nghiêng chịu tác dụng của lực cắt.

### Khi tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện nghiêng chịu tác dụng của lực cắt thì lực cắt giới hạn mà cấu kiện có thể chịu được trên tiết diện nghiêng cần được xác định bằng tổng các lực cắt giới hạn chịu bởi bê tông trong tiết diện nghiêng và bởi cốt thép ngang cắt qua tiết diện nghiêng.

### Khi tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện nghiêng chịu tác dụng của mô men uốn thì mô men uốn giới hạn mà cấu kiện có thể chịu được trên tiết diện nghiêng cần được xác định bằng tổng các mô men uốn giới hạn chịu bởi cốt thép dọc và cốt thép ngang cắt qua tiết diện nghiêng, đối với trục đi qua điểm đặt hợp lực của các nội lực trong vùng chịu nén.

### Khi tính toán cấu kiện bê tông cốt thép theo độ bền dải bê tông giữa các tiết diện nghiêng chịu tác dụng của lực cắt thì lực cắt giới hạn mà cấu kiện có thể chịu được cần được xác định theo độ bền của dải bê tông nghiêng nằm dưới tác dụng của nội lực nén dọc theo dải bê tông này và nội lực kéo do cốt thép ngang cắt qua dải bê tông nghiêng.

## Tính toán cấu kiện bê tông cốt thép theo độ bền tiết diện không gian

Khi tính toán cấu kiện bê tông cốt thép theo độ bền các tiết diện không gian thì mô men xoắn giới hạn mà cấu kiện có thể chịu được cần được xác định bằng tổng mô men xoắn giới hạn chịu bởi cốt thép dọc và cốt thép ngang nằm ở mỗi cạnh cấu kiện. Ngoài ra, cần tiến hành tính toán độ bền cấu kiện bê tông cốt thép theo dải bê tông giữa các tiết diện không gian và chịu tác dụng của lực nén dọc theo dải bê tông và lực kéo do cốt thép ngang cắt qua dải bê tông.

## Tính toán cấu kiện bê tông cốt thép chịu tác dụng cục bộ của tải trọng

### Khi tính toán cấu kiện bê tông cốt thép chịu tác dụng cục bộ thì lực nén giới hạn mà cấu kiện có thể chịu được cần được xác định xuất phát từ cường độ của bê tông ở trạng thái ứng suất khối được tạo bởi bê tông bao quanh và cốt thép hạn chế biến dạng ngang, nếu có.

### Tính toán chọc thủng được tiến hành đối với các cấu kiện bê tông cốt thép phẳng (bản sàn) khi có tác dụng của lực tập trung và mô men tập trung trong vùng chọc thủng. Nội lực giới hạn mà cấu kiện bê tông cốt thép có thể chịu được khi chọc thủng được xác định bằng tổng nội lực giới hạn chịu bởi bê tông và cốt thép ngang nằm trong vùng chọc thủng.

## Yêu cầu đối với tính toán cấu kiện bê tông cốt thép theo sự hình thành vết nứt

### Tính toán cấu kiện bê tông cốt thép theo sự hình thành vết nứt thẳng góc được tiến hành theo nội lực giới hạn hoặc theo mô hình biến dạng phi tuyến. Tính toán theo sự hình thành vết nứt xiên được tiến hành theo nội lực giới hạn.

### Tính toán theo sự hình thành các vết nứt của các cấu kiện bê tông cốt được tiến hành theo điều kiện mà nội lực do tải trọng và tác động ngoài.

### Nội lực chịu bởi cấu kiện bê tông cốt thép khi hình thành các vết nứt thẳng góc cần được xác định từ tính toán cấu kiện bê tông cốt thép như đối với vật thể đặc có kể đến các biến dạng đàn hồi trong cốt thép và biến dạng không đàn hồi trong bê tông chịu kéo và chịu nén với ứng suất pháp lớn nhất khi kéo trong bê tông bằng giá trị tính toán của cường độ chịu kéo dọc trục của bê tông _Rbt,ser._

### Tính toán theo sự hình thành các vết nứt thẳng góc của các cấu kiện bê tông cốt thép theo mô hình biến dạng phi tuyến được tiến hành dựa trên các biểu đồ biến dạng của cốt thép, của bê tông chịu kéo và bê tông chịu nén, và dựa trên giả thiết tiết diện phẳng. Tiêu chí hình thành các vết nứt là biến dạng tương đối trong bê tông chịu kéo đạt tới giá trị giới hạn.

### Nội lực mà cấu kiện bê tông cốt thép có thể chịu được khi hình thành vết nứt xiên cần được xác định từ tính toán cấu kiện bê tông cốt thép như đối với vật thể đàn hồi và theo tiêu chí độ bền của bê tông ở trạng thái ứng suất phẳng “kéo-nén”.

##  Yêu cầu đối với tính toán cấu kiện bê tông cốt thép theo sự mở rộng vết nứt

### Tính toán cấu kiện bê tông cốt thép được tiến hành theo sự mở rộng các loại vết nứt khác nhau trong các trường hợp khi mà việc kiểm tra bằng tính toán theo sự hình thành vết nứt chỉ ra rằng các vết nứt sẽ hình thành.

### Tính toán theo sự mở rộng vết nứt được tiến hành theo điều kiện mà chiều rộng vết nứt _a crc_ do ngoại lực không được vượt quá giá trị chiều rộng vết nứt giới hạn cho phép

### Chiều rộng vết nứt thẳng góc được xác định bằng tích của biến dạng tương đối trung bình của cốt thép trên đoạn giữa các vết nứt và chiều dài đoạn này. Biến dạng tương đối trung bình giữa các vết nứt được xác định có kể đến sự làm việc của bê tông chịu kéo giữa các vết nứt. Biến dạng tương đối của cốt thép tại vết nứt được xác định từ tính toán đàn hồi quy ước cấu kiện bê tông cốt thép có vết nứt với việc sử dụng mô đun biến dạng quy đổi của bê tông chịu nén được xác định có kể đến ảnh hưởng của biến dạng không đàn hồi của bê tông vùng chịu nén, hoặc theo mô hình biến dạng phi tuyến. Khoảng cách giữa các vết nứt được xác định theo các điều kiện mà hiệu số nội lực trong cốt thép dọc tại tiết diện có vết nứt và giữa các vết nứt cần phải được chịu bởi lực bám dính của cốt thép với bê tông trên chiều dài đoạn này

## Vật liệu cho kết cấu bê tông và bê tông cốt thép

### Bê tông

#### Các chỉ tiêu chất lượng của bê tông được sử dụng khi thiết kế

Đối với các kết cấu bê tông và bê tông cốt thép được thiết kế phù hợp với các yêu cầu của tiêu chuẩn này thì cần sử dụng các loại bê tông kết cấu sau:
Bê tông nặng có khối lượng thể tích trung bình từ 2 200 kg/m3 đến 2 500 kg/m3;
Bê tông hạt nhỏ có khối lượng thể tích trung bình từ 1 800 kg/m3 đến 2 200 kg/m3; Bê tông nhẹ;

  * Bê tông tổ ong;

  * Bê tông tự ứng suất.


Khi thiết kế các công trình bê tông và bê tông cốt thép phù hợp với các yêu cầu đối với các kết cấu cụ thể thì cần phải quy định loại bê tông và các chỉ tiêu chất lượng quy định của nó được kiểm soát trong thi công.
Các chỉ tiêu chất lượng quy định và cần được kiểm soát của bê tông bao gồm:
Cấp độ bền chịu nén B;

  * Cấp độ bền chịu kéo dọc trục Bt; Mác chống thấm nước W;

  * Mác khối lượng thể tích trung bình D; Mác tự ứng suất Sp.


Cấp độ bền chịu nén của bê tông B được định nghĩa trong 3.1.5 và được gọi là cường độ lập phương tiêu chuẩn.
Cấp độ bền chịu kéo dọc trục của bê tông Bt được định nghĩa trong 3.1.3 và được gọi là cường độ chịu kéo tiêu chuẩn.
Cho phép lấy giá trị xác suất đảm bảo khác của cường độ chịu nén và chịu kéo dọc trục của bê tông theo yêu cầu của các tiêu chuẩn đối với các loại công trình đặc biệt cụ thể.

# Public_018

# Phạm vi áp dụng

Tiêu chuẩn này quy định các yêu cầu thiết kế kết cấu bê tông và bê tông cốt thép của nhà và công trình với các chức năng khác nhau, chịu tác động có hệ thống của nhiệt độ không cao hơn dương 50 °С và không thấp hơn âm 70 °С, làm việc trong môi trường không xâm thực.
Tiêu chuẩn này quy định các yêu cầu về thiết kế kết cấu bê tông và bê tông cốt thép được chế tạo từ bê tông nặng, bê tông hạt nhỏ, bê tông nhẹ, bê tông tổ ong và bê tông tự ứng suất.
Tiêu chuẩn này không quy định các yêu cầu để thiết kế kết cấu liên hợp thép – bê tông, kết cấu bê tông cốt sợi, kết cấu bán lắp ghép, kết cấu bê tông và bê tông cốt thép của các công trình thủy công, cầu, lớp phủ mặt đường ô tô và đường băng sân bay và của các công trình đặc biệt khác, cũng như không quy định các yêu cầu để thiết kế kết cấu được chế tạo từ bê tông có khối lượng thể tích trung bình nhỏ hơn 500 kg/m3 và lớn hơn 2500 kg/m3, bê tông polyme và polyme bê tông, bê tông trên nền chất kết dính là vôi, xỉ và chất kết dính hỗn hợp (trừ khi sử dụng chúng trong bê tông tổ ong), trên nền thạch cao và chất kết dính đặc biệt, bê tông dùng cốt liệu đặc biệt và cốt liệu hữu cơ, bê tông có cấu trúc rỗng lớn.
Tiêu chuẩn này không quy định các yêu cầu về thiết kế các kết cấu đặc thù (bản sàn rỗng, kết cấu được giảm tiết diện ở phần đầu, mũ cột và các kết cấu tương tự).

# Tài liệu viện dẫn

Các tài liệu viện dẫn sau cần thiết cho việc áp dụng tiêu chuẩn này. Đối với các tài liệu viện dẫn ghi năm công bố thì áp dụng phiên bản được nêu. Đối với các tài liệu viện dẫn không ghi năm công bố thì áp dụng phiên bản mới nhất, bao gồm cả các sửa đổi, bổ sung (nếu có).
TCVN 1651-1:2008, _Thép cốt cho bê tông – Phần 1: Thép thanh tròn trơn_
TCVN 1651-2:2008, _Thép cốt cho bê tông – Phần 2: Thép thanh vằn_
TCVN 2737:1995, _Tải trọng và tác động – Tiêu chuẩn thiết kế_
TCVN 3108:1993, _Hỗn hợp bê tông nặng – Phương pháp xác định khối lượng thể tích_
TCVN 3116:1993, _Bê tông nặng – Phương pháp xác định độ chống thấm nước_
TCVN 5575:2012, _Kết cấu thép – Tiêu chuẩn thiết kế_
TCVN 6284-2:1997 (ISO 6394-2:1991) _, Thép cốt bê tông dự ứng lực – Phần 2: Dây kéo nguội_
TCVN 6284-4:1997 (ISO 6934-4:1991), _Thép cốt bê tông dự ứng lực – Phần 4: Dảnh_
TCVN 6284-5:1997 (ISO 6934-5:1991), _Thép cốt bê tông dự ứng lực – Phần 5: Thép thanh cán nóng có hoặc không xử lý tiếp_
TCVN 6288:1997 (ISO 10544:1992), _Dây thép vuốt nguội để làm cốt bê tông và sản xuất lưới thép hàn làm cốt_
TCVN 8163:2009, _Thép cốt bê tông – Mối nối bằng ống ren_
TCVN 8590-1:2010 (ISO 4301-1:1986), _Cần trục – Phân loại theo chế độ làm việc – Phần 1: Yêu cầu chung_
TCVN 9362:2012, _Tiêu chuẩn thiết kế nền nhà và công trình_
TCVN 9379:2012, _Kết cấu_ xây _dựng và nền – Nguyên tắc cơ bản về tính toán_
TCVN 9386:2012, _Thiết kế công trình chịu động đất_
TCVN 9390:2012, _Thép cốt bê tông – Mối nối bằng dập ép ống – Yêu cầu thiết kế, thi công và nghiệm thu_
TCVN 12251:2018, _Bảo vệ chống ăn mòn cho kết cấu xây dựng_
GOST 13015-2012 _, Concrete and reinforced concrete products for construction. General technical requirements. Rules for acceptance, marking, transportation and storage (Các sản phẩm bê tông và bê tông cốt thép cho xây dựng – Yêu cầu kỹ thuật chung – Nguyên tắc nghiệm thu, ghi nhãn, vận chuyển và bảo quản)_

# Thuật ngữ, định nghĩa và ký hiệu

## Thuật ngữ và định nghĩa

Tiêu chuẩn này sử dụng các thuật ngữ và định nghĩa sau:

### Các đặc trưng tiêu chuẩn của các tính chất vật lý của vật liệu (normative characteristics of physical properties of materials)

Các giá trị của các đặc trưng vật lý của vật liệu được quy định trong các tiêu chuẩn hoặc yêu cầu kỹ thuật và được kiểm soát trong quá trình chế tạo, thi công và khai thác sử dụng công trình xây dựng.

### Các hệ số độ tin cậy (partial factors)

Các hệ số kể đến các sai lệch bất lợi có thể có của các giá trị tải trọng, các đặc trưng vật liệu và sơ đồ tính toán công trình xây dựng do điều kiện sử dụng thực tế của nó, cũng như kể đến mức độ tầm quan trọng của các công trình xây dựng. Có 4 loại hệ số độ tin cậy: hệ số độ tin cậy về tải trọng; hệ số độ tin cậy về vật liệu, hệ số điều kiện làm việc, hệ số độ tin cậy về tầm quan trọng của công trình.

### Cấp độ bền (cấp cường độ) chịu kéo của bê tông, Bt (grade of tensile strength of concrete)

Giá trị được kiểm soát nhỏ nhất của cường độ chịu kéo tức thời, tính bằng megapascan (MPa), với xác suất đảm bảo không dưới 95 %, được xác định trên các mẫu thử kéo chuẩn đã được chế tạo, dưỡng hộ trong điều kiện tiêu chuẩn và thử kéo ở tuổi 28 ngày.

CHÚ THÍCH: Mẫu thử chuẩn để xác định cường độ chịu kéo dọc trục có kích thước tiết diện ngang (150 × 150) mm (tham khảo tiêu chuẩn liên quan).

### Cấp cường độ chịu kéo của cốt thép (grade of tensile strength of steel)

Giá trị được kiểm soát nhỏ nhất của giới hạn chảy thực tế hoặc quy ước (bằng giá trị của ứng suất ứng với độ giãn dài dư tương đối 0,1 % hoặc 0,2 %) với xác suất đảm bảo không nhỏ hơn 0,95, tính bằng megapascan (MPa).

### Cấp độ bền (cấp cường độ) chịu nén của bê tông, B (grade of compressive strength of concrete)

Giá trị được kiểm soát nhỏ nhất của cường độ chịu nén tức thời, tính bằng megapascan (MPa), với xác suất đảm bảo không dưới 95 %, được xác định trên các mẫu lập phương chuẩn đã được chế tạo, dưỡng hộ trong điều kiện tiêu chuẩn và thử nén ở tuổi 28 ngày.

CHÚ THÍCH: Mẫu lập phương chuẩn để xác định cường độ chịu nén có kích thước (150×150×150) mm.

### Chiều cao làm việc của tiết diện (effective depth of cross section)

Khoảng cách từ biên chịu nén của cấu kiện đến trọng tâm của cốt thép dọc chịu kéo.

### Cốt thép chịu lực (load-bearing reinforcement)

Cốt thép được bố trí theo tính toán.

### Cốt thép cấu tạo (constructive reinforcement)

Cốt thép được bố trí theo các yêu cầu về cấu tạo mà không cần tính toán.

### Cốt thép hạn chế biến dạng ngang (confinement reinforcement)

Cốt thép ngang dùng để gia cường các vị trí cần tăng độ bền, tăng khả năng chống nứt.

### Cốt thép ứng suất trước (prestressing steel)

Cốt thép được ứng suất trước trong quá trình chế tạo kết cấu trước khi ngoại lực tác dụng trong gian đoạn khai thác sử dụng.

### Cường độ (strength)

Tính chất cơ học của vật liệu, chỉ khả năng chịu được các tác động, thường được tính bằng đơn vị của ứng suất.

### Điểu kiện sử dụng bình thường (serviceability)

Điều kiện sử dụng các công trình xây dựng phù hợp với các điều kiện đã quy định trong các tiêu chuẩn hoặc nhiệm vụ thiết kế, bao gồm cả bảo dưỡng (bảo trì), sửa chữa lớn và sửa chữa nhỏ.

### Độ bền (resistance)

Khả năng của một cấu kiện hoặc của tiết diện ngang cấu kiện, chịu được các tác động mà không bị phá hoại về cơ học, ví dụ khả năng chịu uốn, khả năng chịu kéo, khả năng chống mất ổn định.

### Độ bền lâu (durability)

Khả năng của công trình xây dựng bảo toàn được các tính chất độ bền, vật lý và các tính chất khác đã được quy định trong thiết kế và đảm bảo cho công trình xây dựng sử dụng bình thường trong suốt thời hạn sử dụng theo thiết kế.

### Độ thấm của bê tông (penetrability of concrete)

Tính chất của bê tông cho phép khí hoặc chất lỏng thấm qua khi có gradient áp lực (được biểu thị bằng mác chống thấm nước W) hoặc đảm bảo độ thấm khuyếch tán các chất hòa tan trong nước khi không có gradient áp lực (được biểu thị bằng các đại lượng quy định về mật độ dòng điện và hiệu điện thế).

### Hàm lượng cốt thép, _μ_ (reinforcement percentage)

Tỉ số giữa diện tích tiết diện cốt thép và diện tích làm việc của tiết diện bê tông, tính bằng phần trăm.

### Kết cấu bê tông (concrete structure)

Kết cấu được làm từ bê tông không cốt thép hoặc có cốt thép đặt theo cấu tạo và không được kể đến trong tính toán; nội lực gây bởi tất cả các tác động trong kết cấu bê tông đều do bê tông chịu.

### Kết cấu bê tông cốt thép (reinforced concrete structure)

Kết cấu được làm từ bê tông với cốt thép chịu lực và cốt thép cấu tạo; nội lực gây bởi tất cả các tác động trong kết cấu bê tông cốt thép do bê tông và cốt thép chịu lực cùng chịu.

### Kết cấu dạng khối (massive structure)

Kết cấu mà có tỉ số diện tích bề mặt hở để khô, tính bằng mét vuông (m2), và thể tích của nó, tính bằng mét khối (m3), không lớn hơn 2.

### Khả năng chịu lực (load bearing capacity)

Hệ quả tác động lớn nhất xuất hiện trong công trình xây dựng mà không vượt quá các trạng thái giới

hạn.

### Khối lượng thể tích của bê tông (density of concrete)

Đặc trưng của bê tông, tính bằng tỉ số giữa khối lượng và thể tích của nó, được biểu thị bằng mác khối lượng thể tích trung bình D.

### Lớp bê tông bảo vệ (concrete cover)

Chiều dày lớp bê tông tính từ biên (mép) cấu kiện đến bề mặt gần nhất của thanh cốt thép.

### Mác chống thấm nước của bê tông, W (watertightness mark of concrete)

Chỉ tiêu thấm nước của bê tông, được xác định bằng áp lực nước lớn nhất, mà khi đó trong các điều kiện thử nghiệm tiêu chuẩn, nước không thấm qua mẫu thử bê tông, đơn vị tính bằng một trên megapascan (MPa-1).

CHÚ THÍCH: Mẫu trụ tròn để thử độ chống thấm nước nêu trong TCVN 3116:1993 có đường kính 150 mm và chiều cao 150 mm.

### Mác khối lượng thể tích trung bình, D (mark of density)

Giá trị khối lượng thể tích trung bình, tính bằng kilôgam trên mét khối (kg/m3).

### Mác tự ứng suất của bê tông Sp (self-stressing mark of concrete)

Giá trị ứng suất trước trong bê tông, tính bằng megapascan (MPa), do bê tông tự trương nở với hàm lượng cốt thép dọc _μ_ = 0,01.

CHÚ THÍCH: Mẫu thử chuẩn để xác định tự ứng suất của bê tông là mẫu lăng trụ có kích thước (100 × 100 × 400) mm hoặc (50 × 50 × 200) mm.

### Mô hình biến dạng phi tuyến (nonlinear deformation model)

Mô hình biến dạng phi tuyến của vật liệu bê tông và cốt thép.

### Mối nối chồng cốt thép (overlap connection of reinforcement)

Liên kết không hàn các thanh cốt thép theo chiều dài của chúng bằng cách kéo dài một đầu của một thanh cốt thép so với đầu kia.

### Mối nối cơ khí cốt thép (mechanical connection of reinforcement)

Mối nối các thanh thép bằng các ống nối chuyên dụng để đảm bảo truyền lực từ thanh này sang thanh kia.

### Neo cốt thép (reinforcement anchorage)

Sự đảm bảo cho cốt thép chịu được nội lực tác dụng lên nó bằng cách kéo dài nó thêm một đoạn tính từ tiết diện tính toán hoặc bằng cách bố trí chi tiết neo đặc biệt ở các đầu của nó.

### Nội lực giới hạn (ultimate internal force)

Nội lực lớn nhất mà cấu kiện, tiết diện của nó, với các đặc trưng đã chọn của vật liệu, có thể chịu được.

### Sơ đồ tính toán, mô hình tính toán (structural model)

Mô hình hệ kết cấu được sử dụng khi tính toán.

### Tiết diện nghiêng (inclined cross section)

Tiết diện của cấu kiện mà mặt phẳng của tiết diện nằm nghiêng với trục dọc cấu kiện và vuông góc với mặt phẳng thẳng đứng chứa trục dọc cấu kiện.

### Tiết diện thẳng góc (normal cross section)

Tiết diện của cấu kiện mà mặt phẳng tiết diện vuông góc với trục dọc cấu kiện.

### Trạng thái giới hạn (limit state)

Trạng thái mà khi vượt quá các thông số đặc trưng của nó thì việc sử dụng kết cấu hoặc là không được phép, hoặc bị gây khó khăn hoặc không còn phù hợp.

### Tự ứng suất của bê tông (self-stress of concrete)

Ứng suất nén xuất hiện trong bê tông của kết cấu khi đóng rắn do đá xi măng trương nở trong điều kiện bị cản trở sự trương nở này, được biểu thị bằng mác tự ứng suất Sp.

### Xác suất đảm bảo (probability)

Xác suất có lợi của một giá trị đại lượng ngẫu nhiên. Ví dụ, đối với tải trọng thì “xác suất đảm bảo” là xác suất không bị vượt của một giá trị cho trước; đối với các đặc trưng vật liệu thì “xác suất đảm bảo” là xác suất của các giá trị lớn hơn hoặc bằng giá trị cho trước.

## Ký hiệu

### Nội lực trong tiết diện ngang của cấu kiện do tải trọng và tác động ngoài _M_

M: Mô men uốn (Nm);

p: Mô men uốn có kể đến mô men của lực nén trước đối với trọng tâm tiết diện quy đổi (Nm);

R: Lực dọc (N);

Q: Lực cắt (N);

T: Mô men xoắn (Nm).

### Các đặc trưng vị trí cốt thép dọc trong tiết diện ngang của cấu kiện

Ký hiệu cốt thép dọc:

  * Nằm trong vùng chịu kéo khi trong tiết diện có vùng chịu nén và chịu kéo do ngoại lực; Nằm ở biên chịu nén ít hơn của tiết diện khi toàn bộ tiết diện chịu nén do ngoại lực;

  * Nằm ở biên chịu kéo nhiều hơn của tiết diện khi toàn bộ tiết diện chịu kéo do ngoại lực đối với cấu kiện chịu kéo lệch tâm;

  * Nằm trong tiết diện ngang của cấu kiện khi toàn bộ tiết diện chịu kéo do ngoại lực đối với cấu kiện chịu kéo đúng tâm;


Ký hiệu cốt thép dọc:

  * Nằm trong vùng chịu nén khi trong tiết diện có vùng chịu nén và chịu kéo do ngoại lực; Nằm ở biên chịu nén nhiều hơn của tiết diện khi toàn bộ tiết diện chịu nén do ngoại lực;

  * Nằm ở biên chịu kéo ít hơn của tiết diện khi toàn bộ tiết diện chịu kéo của cấu kiện chịu kéo lệch tâm do ngoại lực.


_Lan_ Chiều dài vùng neo của cốt thép (mm);
_L p_ Chiều dài vùng truyền ứng suất trước trong cốt thép ứng suất trước vào bê tông (mm);
_L_ 0 Chiều dài tính toán của cấu kiện chịu lực nén dọc trục (mm);
_sw_ Khoảng cách cốt thép đai, đo theo chiều dài cấu kiện (mm);

  24. Chiều cao vùng chịu nén của bê tông (mm);

  25. khoảng cách từ trục trung hòa đến điểm đặt lực nén trước có kể đến mô men uốn do ngoại lực (mm);


  23. Mô men kháng uốn của tiết diện cấu kiện đối với thớ chịu kéo ngoài cùng (mm3);


|  | s |  |
| --- | --- | --- |

 

_h_ 0 ;Hàm lượng cốt thép thanh, được xác định bằng tỉ số giữa diện tích tiết diện của cốt thép _S_ và diện tích tiết diện ngang của cấu kiện ( _b h_ 0 ), không kể đến phần cánh chịu nén và chịu kéo nhô ra.

# Yêu cầu chung đối với kết cấu bê tông và bê tông cốt thép

## Tất cả các loại kết cấu bê tông và bê tông cốt thép cần phải thỏa mãn:

  * Các yêu cầu về an toàn;

  * Các yêu cầu về điều kiện sử dụng bình thường; Các yêu cầu về độ bền lâu;

  * Các yêu cầu bổ sung nêu trong nhiệm vụ thiết kế.


## Để thỏa mãn các yêu cầu về an toàn thì kết cấu cần phải có các đặc trưng ban đầu sao cho dưới các tác động tính toán khác nhau trong quá trình xây dựng và sử dụng nhà và công trình loại trừ được sự phá hoại bất kỳ đặc điểm nào hoặc sự vi phạm điều kiện sử dụng bình thường làm hại cho cuộc sống hoặc sức khỏe của người, tài sản, môi trường xung quanh, cuộc sống và sức khỏe của động vật và thực vật.

## Để thỏa mãn các yêu cầu về điều kiện sử dụng bình thường thì kết cấu cần phải có các đặc trưng ban đầu sao cho dưới các tác động tính toán khác nhau không xảy ra sự hình thành hoặc mở rộng vết nứt quá mức, cũng như không xảy ra chuyển vị quá mức, dao động và các hư hỏng khác làm khó khăn cho việc sử dụng bình thường (vi phạm các yêu cầu về hình dạng bên ngoài của kết cấu, các yêu cầu công nghệ về sự làm việc bình thường của các thiết bị, cơ cấu, các yêu cầu cấu tạo về sự làm việc đồng thời của các cấu kiện và các yêu cầu khác đặt ra khi thiết kế).

Trong các trường hợp cần thiết thì kết cấu cần phải có các đặc trưng đảm bảo được các yêu cầu về cách nhiệt, cách âm, bảo vệ sinh học và các yêu cầu khác.

Các yêu cầu không được có vết nứt được đề ra đối với:

  * Các kết cấu bê tông cốt thép, mà trong đó khi toàn bộ tiết diện của chúng là chịu kéo thì độ không thấm vẫn cần được đảm bảo (các kết cấu chịu áp lực chất lỏng hoặc khí, các kết cấu chịu tác động phóng xạ và các kết cấu tương tự);

  * Các kết cấu đặc thù mà có yêu cầu nâng cao về độ bền lâu;

  * Các kết cấu làm việc trong môi trường xâm thực trong các trường hợp nêu trong [SP 28.13330.2012.](normacs://normacs.ru/10573?dob=41365.000012&dol=41410.711586)


Trong các kết cấu bê tông còn lại thì cho phép hình thành các vết nứt và đối với chúng phải có các yêu cầu hạn chế chiều rộng vết nứt.

## Để thỏa mãn các yêu cầu về độ bền lâu thì kết cấu cần phải có các đặc trưng ban đầu sao cho trong suốt khoảng thời gian dài đã được thiết lập, nó sẽ vẫn thỏa mãn các yêu cầu về an toàn và điều kiện sử dụng có kể đến ảnh hưởng của các tác động tính toán khác nhau (tác dụng dài hạn của tải trọng, các tác động bất lợi của khí hậu, công nghệ, nhiệt độ và độ ẩm, tác động xâm thực, v.v…) đến các đặc trưng hình học của kết cấu và các đặc trưng cơ học của vật liệu.

## Sự an toàn, điều kiện sử dụng, độ bền lâu của kết cấu bê tông và bê tông cốt thép và các yêu cầu khác đặt ra trong nhiệm vụ thiết kế cần được đảm bảo bởi việc thực hiện:

Các yêu cầu đối với bê tông và các thành phần của nó;

  * Các yêu cầu đối với cốt thép;

  * Các yêu cầu đối với tính toán kết cấu;

  * Các yêu cầu cấu tạo;

  * Các yêu cầu công nghệ;

  * Các yêu cầu sử dụng.

  * Các yêu cầu về tải trọng và tác động, giới hạn chịu lửa, độ không thấm nước, các giá trị giới hạn của biến dạng (độ võng, chuyển vị, biên độ dao động), về các giá trị tính toán của nhiệt độ không khí bên ngoài và độ ẩm tương đối của môi trường xung quanh, về bảo vệ kết cấu chịu tác động của môi trường xâm thực và các yêu cầu khác được quy định trong các tiêu chuẩn tương ứng (TCVN 2737:1995, Phụ lục M của tiêu chuẩn này, TCVN 9386:2012, TCVN 12251:2018, TCVN 9362:2012 và các tiêu chuẩn liên quan khác).


## Khi thiết kế kết cấu bê tông và bê tông cốt thép, độ tin cậy của các kết cấu được quy định trong TCVN 9379:2012 theo phương pháp tính toán bán xác suất bằng cách sử dụng các giá trị tính toán của tải trọng và tác động, các đặc trưng tính toán của bê tông và cốt thép (hoặc thép kết cấu), được xác định với các hệ số độ tin cậy (an toàn) riêng tương ứng của các giá trị tiêu chuẩn của các đặc trưng này, có kể đến mức độ tầm quan trọng của nhà và công trình.

Giá trị tiêu chuẩn của tải trọng và tác động, giá trị của hệ số độ tin cậy (an toàn) riêng về tải trọng, hệ số độ tin cậy về chức năng của kết cấu, cũng như sự phân loại tải trọng thành thường xuyên và tạm thời (dài hạn và ngắn hạn) được quy định trong các tiêu chuẩn tương ứng đối với kết cấu xây dựng (TCVN 2737:1995 và các tiêu chuẩn khác).

Giá trị tính toán của tải trọng và tác động lấy phụ thuộc vào trạng thái giới hạn tính toán và trường hợp tính toán.

Mức độ tin cậy của các giá trị tính toán của các đặc trưng vật liệu được quy định phụ thuộc vào trường hợp tính toán và vào nguy cơ đạt tới trạng thái giới hạn tương ứng và được điều chỉnh bằng giá trị của hệ số độ tin cậy (an toàn) về bê tông và cốt thép (hoặc thép kết cấu).

Tính toán kết cấu bê tông và bê tông cốt thép có thể được tiến hành theo giá trị độ tin cậy tiền định trên cơ sở tính toán xác suất toàn phần khi có đủ số liệu về sự biến động của các yếu tố chính trong các công thức tính toán.

# Yêu cầu đối với tính toán kết cấu bê tông và bê tông cốt thép

## Yêu cầu chung

### Tính toán kết cấu bê tông và bê tông cốt thép cần được tiến hành phù hợp với các yêu cầu của

TCVN 9379:2012 theo các trạng thái giới hạn, bao gồm:

  * Các trạng thái giới hạn thứ nhất, dẫn tới mất hoàn toàn khả năng sử dụng kết cấu;

  * Các trạng thái giới hạn thứ hai, làm khó khăn cho sử dụng bình thường hoặc giảm độ bền lâu của nhà và công trình so với thời hạn sử dụng đã dự định.


Các tính toán cần phải đảm bảo được độ tin cậy của nhà và công trình trong suốt thời hạn sử dụng của chúng, cũng như trong quá trình thi công phù hợp với các yêu cầu đề ra đối với chúng.

  * Các tính toán theo các trạng thái giới hạn thứ nhất bao gồm:

  * Tính toán độ bền;

  * Tính toán ổn định hình dạng (đối với kết cấu thành mỏng); Tính toán ổn định ví trí (lật, trượt, đẩy nổi).

  * Tính toán độ bền kết cấu bê tông và bê tông cốt thép cần được tiến hành theo điều kiện mà trong đó nội lực, ứng suất và biến dạng trong kết cấu do các tác động khác nhau có kể đến trạng thái ứng suất ban đầu (ứng suất trước, tác động nhiệt độ và tác động khác) không được vượt quá các giá trị mà kết cấu có thể chịu được.

  * Tính toán ổn định hình dạng kết cấu, cũng như ổn định vị trí (có kể đến sự làm việc đồng thời của kết cấu và nền, các tính chất biến dạng của chúng, khả năng chống trượt tại bề mặt tiếp xúc với nền và các đặc điểm riêng khác) cần được tiến hành theo các chỉ dẫn của các tiêu chuẩn áp dụng cho các loại kết cấu riêng.


Trong các trường hợp cần thiết, tùy thuộc vào loại, công năng kết cấu cần tiến hành các tính toán theo các trạng thái giới hạn liên quan đến các hiện tượng dẫn đến phải dừng sử dụng nhà và công trình (biến dạng quá mức, trượt trong các liên kết và các hiện tượng khác).

# Public_019

# Về một chiến lược Trí tuệ nhân tạo quốc gia của Viêt Nam

  * nước ta hiện nay, các thuật ngữ như “Cách mạng công nghiệp 4.0”, “Thời đại số”, “Cuộc sống số” và “Trí tuệ nhân tạo” xuất hiện khá thường xuyên trong nhiều phát biểu, bài viết trên các phương tiện thông tin đại chúng. Hầu hết hướng tới công nghiệp TTNT, tập trung vào chủ đề người máy và một số chủ đề công nghiệp TTNT khác.


TTNT được xác định là một công nghệ cho mục đích tổng thể ( _general purpose technologies_ ) vì vậy TTNT được coi là công nghệ “người cầm lái” dẫn dắt năng suất quốc gia [8]. Thủ tướng Chính phủ đã khẳng định Việt Nam cần “sớm lên đoàn tàu 4.0”13 và điều đó có nghĩa là cần thiết xây dựng một chiến lược TTNT quốc gia _**“Trí tuệ nhân tạo cùng con người vì nhân loại”**_ phù hợp nhất cho Việt Nam. Dưới đây là một khảo sát sơ bộ về chiến lược TTNT quốc gia của một số nước trên thế giới.

## Sơ lược về chiến lược Trí tuệ nhân tạo quốc gia trên thế giới

Như đã được đề cập, Hình 7 cung cấp một ước tính về lợi ích thu được từ TTNT vào năm 2030 của các quốc gia và khu vực, trong đó, Trung Quốc (7000 tỷ đô la Mỹ) và Bắc Mỹ (3700 tỷ đô la Mỹ), chiếm tới 70% lợi ích thu được từ TTNT trên thế giới [34]. Ước tính này là một trong nhiều thông số để các nước xây dựng chiến lược TTNT quốc gia. Bài viết này tập trung khảo sát chiến lược TTNT quốc gia của Mỹ, Trung Quốc, Pháp (đại diện cho Châu Âu) và một số nước có vị trí địa lý gần gũi với Việt Nam.

### Chiến lược TTNT quốc gia của Mỹ

Với lợi thế về sự phổ biến rộng rãi các công nghệ _Phân tích dữ liệu lớn_ và _Internet vạn vật_ ( _Internet of Things_ ), về độ sẵn sàng công nghệ và tiêu dùng tiên tiến, về sự sẵn có tài sản (hạ tầng tiên tiến, đầu tư mạnh, lượng lớn kỹ năng, dòng chảy nhanh dữ liệu và thông tin), nước Mỹ sớm khởi đầu mạnh mẽ và là quốc gia đầu tiên (tháng 5/2016) xây dựng Kế hoạch chiến lược TTNT quốc gia (ban hành tháng 10/2016) với mục tiêu làm cho nước Mỹ là cường quốc TTNT thế giới, và từ đó thúc đầy nền kinh tế và an ninh quốc gia của họ [29, 32]. Do khu vực tư nhân đầu tư mạnh vào TTNT với tốc độ ngày càng tăng, kế hoạch chiến lược này chọn phương thức đầu tư của Chính phủ Mỹ tập trung vào các khu vực y tế công cộng, hệ thống đô thị, phúc lợi xã hội, tư pháp hình sự, bền vững môi trường, an ninh quốc gia và khoa học cơ bản. Bảy chiến lược được xác định và hai khuyến nghị được đưa ra trong kế hoạch. Bảy chiến lược phát triển TTNT của Mỹ như sau:

  * __Chiến lược 1__. Đầu tư dài hạn cho nghiên cứu TTNT. Ưu tiên đầu tư vào thế hệ TTNT tiếp theo nhằm thúc đẩy việc khám phá và thấu hiểu TTNT làm cho Mỹ duy trì vị trí dẫn đầu thế giới về TTNT.

  * __Chiến lược 2__. Phát triển các phương pháp hiệu quả cho cộng tác con người – TTNT. Thay vì thay thế con người, hầu hết các hệ thống TTNT cộng tác với con người để đạt được hiệu năng tối ưu. Cần tiến hành nghiên cứu tạo ra sự tương tác hiệu quả giữa con người và hệ thống TTNT.

  * __Chiến lược 3__. Hiểu và giải quyết được các hệ lụy đạo đức, pháp lý và xã hội của TTNT. Công nghệ TTNT được kỳ vọng hoạt động theo các tiêu chuẩn chính thức và phi chính thức nhằm gìn giữ đồng loại của chúng ta. Cần tiến hành nghiên cứu để hiểu được ảnh hưởng đạo đức, pháp lý và xã hội của TTNT, và phát triển các phương pháp thiết kế hệ thống TTNT phù hợp với các mục đích đạo đức, pháp lý và xã hội.

  * __Chiến lược 4__. Đảm bảo an toàn và bảo mật hệ thống TTNT. Trước khi hệ thống TTNT được sử dụng rộng rãi, cần đảm bảo rằng hệ thống sẽ hoạt động an toàn và bảo mật, theo phương thức kiểm soát được, xác định tốt và hiểu rõ. Cần tiến hành các nghiên cứu tiên phong giải quyết các thách thức trong việc tạo ra hệ thống TTNT đúng đắn, có căn cứ và đáng tin cậy.

  * __Chiến lược 5__. Phát triển các tập dữ liệu và môi trường đào tạo và đánh giá về TTNT dùng chung. Độ sâu, chất lượng và độ chính xác của tập dữ liệu và nguồn lực đào tạo ảnh hưởng đáng kể đến hiệu năng TTNT. Cần nghiên cứu phát triển các tập dữ liệu và môi trường chất lượng cao cho phép truy cập có thẩm quyền vào các tập dữ liệu chất lượng cao tốt như tài nguyên đánh giá và đào tạo.

  * __Chiến lược 6__. Đo lường và đánh giá công nghệ TTNT thông qua các tiêu chuẩn và quy chuẩn. Cần cải tiến các tiêu chuẩn, quy chuẩn, bộ kiểm thử và sự tham gia của cộng đồng TTNT đối với hướng dẫn và đánh giá tiến bộ trong TTNT. Cần tiến hành các nghiên cứu bổ sung nhằm phát triển một phổ rộng rãi kỹ thuật đánh giá.

  * __Chiến lược 7__. Thấu hiểu nhu cầu về đội ngũ nghiên cứu – phát triển (NC-PT) TTNT quốc gia. Tiến bộ trong TTNT đòi hỏi một cộng đồng nhân lực nghiên cứu TTNT mạnh mẽ. Nâng cao hiểu biết về nhu cầu nhân lực NC-PT TTNT hiện tại và trong tương lai là rất cần thiết để đảm bảo sự sẵn có các chuyên gia TTNT giải quyết các khu vực NC-PT chiến lược được nêu trong bản kế hoạch.


Hai khuyến nghị về phương châm hành động để thực thi bảy chiến lược trên:

  * __Khuyến nghị 1__. Xây dựng khung triển khai NC-PT TTNT nhằm xác định được các cơ hội khoa học – công nghệ và hỗ trợ điều phối hiệu quả đầu tư ( _công và tư_ ) NC-PT TTNT, phù hợp với sáu chiến lược 1-6 trên đây,

  * __Khuyến nghị 2__. Nghiên cứu phối cảnh quốc gia để tạo dựng và duy trì một đội ngũ NC-PT TTNT lành mạnh, phù hợp với chiến lược 7 trên đây.


Hai điểm nổi bật trong bảy chiến lược và hai khuyến nghị là các khu vực tập trung đầu tư của Chính phủ Mỹ và nguồn nhân lực NC-PT TTNT cho nước Mỹ.

17

Một số dự án NC-PT TTNT do Chính phủ Mỹ tài trợ đã được khởi động, chẳng hạn Chương trình học máy suốt đời của Cơ quan dự án nghiên cứu tiên tiến quốc phòng Mỹ14. Tuy nhiên, chính quyền mới của Tổng thống Donald Trump dường như từ bỏ kế hoạch trên đây bằng cách thi hành một chính sách đầu tư TTNTkhác. Đồng thời với việc giảm đầu tư công trực tiếp cho phát triển một số khu vực TTNT, Chính phủ Mỹ sử dụng chính sách cải cách thuế để thu hồi tiền đầu tư ra nước ngoài của các công ty và cho phép các công ty dùng toàn bộ số tiền đó vào đầu tư phát triển TTNT và các công nghệ tiên tiến khác trên đất Mỹ. Chính sách này giúp một số khu vực TTNT của nước Mỹ có bước phát triển nhanh, chằng hạn như máy bay không người lái và xe tự lái [32]. Tuy nhiên, sự thay đổi chính sách như vậy cũng vấp phải sự phản đổi của một số chuyên gia hàng đầu về TTNT của Mỹ, chẳng hạn như Cựu giám đốc điều hành Google Eric Schmidt15.

### Chiến lược TTNT quốc gia của Trung Quốc

Nền công nghiệp TTNT Trung Quốc được dự báo là lớn nhất thế giới vào năm 2030 nhưng hiện vẫn ở vị trí “đuổi theo” so với Mỹ (tổng vốn đầu tư TTNT dành cho các công ty Trung Quốc giai đoạn 2012-2016 là 2,6 tỷ đô la Mỹ so với 17,2 tỷ đô la Mỹ của các công ty Mỹ; nhân lực tài năng TTNT của Trung Quốc so với Mỹ thua cả về số lượng (39 nghìn người so với 78 nghìn người), lẫn kinh nghiệm, v.v.). Với lợi thế về tài nguyên dữ liệu của quốc gia đông dân nhất thế giới (dự kiến, Trung Quốc chiếm 20% lượng 44 Zetabytes dữ liệu toàn cầu năm 2020), Chính phủ và cộng động hàn lâm – công nghiệpTrung Quốc đã chứng tỏ một quyết tâm cao trong xây dựng và thực thi chiến lược TTNT quốc gia. Một số nội dung cơ bản trong chiến lược TTNT quốc gia của Trung Quốc [5, 14, 42]:

  * Phát huy lợi thế về khối lượng dữ liệu nội tại và sự phối hợp chặt chẽ của Chính phủ và cộng động hàn lâm – công nghiệp về một lộ trình phát triển công nghiệp TTNT với tốc độ: (i) năm 2020: bắt kịp các cường quốc TTNT tiên tiến nhất thế giới (công nghiệp TTNT lõi: 22,5 tỷ đô la Mỹ, công nghiệp liên quan TTNT: 150,8 tỷ đô la Mỹ); (ii) năm 2025: trở thành một nhà lãnh đạo thế giới về TTNT (công nghiệp TTNT lõi: 60,3 tỷ đô la Mỹ, công nghiệp liên quan TTNT: 754 tỷ đô la Mỹ); (iii) năm 2030: đạt mức tiêu chuẩn quốc tế đổi mới TTNT ưu việt (công nghiệp TTNT lõi: 150,8 tỷ đô la Mỹ và công nghiệp liên quan TTNT: 1500 tỷ đô la Mỹ).

  * Sáu nhiệm vụ chính được xác định là: (i) Xây dựng một hệ thống đổi mới công nghệ

  * TTNT hợp tác mở: thiết lập một hệ thống lý thuyết cơ bản mới về TTNT, thiết lập một thế hệ mới của hệ thống công nghệ TTNT quan trọng, bố cục phối hợp nền tảng đổi mới TTNT, đẩy nhanh thu hút và ươm trồng tài năng TTNTcao cấp (đào tạo Tiến sỹ và Thạc sỹ ngành TTNT); (ii) Chăm nuôi nền kinh tế TTNT tiên tiến và hiệu quả: phát triển mạnh mẽ ngành công nghiệp TTNT mới nổi, đẩy nhanh việc thúc đẩy nâng cấp công nghiệp TTNT, phát triển mạnh mẽ các doanh nghiệp TTNT, tạo hệ sinh thái đổi mới TTNT; (ii) Xây dựng một xã hội TTNT an toàn và thuận tiện: phát triển các dịch vụ TTNT tiện lợi và hiệu quả, thúc đẩy quản trị xã hội thông minh, sử dụng TTNT cải thiện năng lực bảo mật công cộng, thúc đẩy tương tác xã hội và chia sẻ niềm tin lẫn nhau; (iv) Tăng cường sự tích hợp quân sự và dân sự trong lĩnh vực TTNT; (v) Xây dựng một hệ thống hạ tầng TTNT thông minh hiệu quả và phổ biến; (vi) Bố trí một thế hệ mới các dự án khoa học và công nghệ TTNT lớn tương lai.


  * Xác định chín lĩnh vực công nghệ TTNT gồm lĩnh vực công nghệ TTNT lõi và tám lĩnh vực công nghệ liên quan TTNT. Lĩnh vực công nghệ lõi bao gồm: (i) các nghiên cứu cơ bản như học sâu, tính toán thần kinh, hệ thống thần kinh xử lý thông tin; (ii) phát triển các phần mềm và phần cứng cơ bản như chíp, cảm biến, hệ điều hành;

3. nghiên cứu ứng dụng trong các lĩnh vực thị giác máy tính, sinh trắc học, nhận diện môi trường phức tạp, tương tác người - máy, xử lý ngôn ngữ tự nhiên, dịch máy, điều khiển thông minh và an ninh mạng. Tám lĩnh vực công nghệ liên quan TTNT gồm: (i) nền tảng dịch vụ công cộng cho tính toán; (ii) nhà thông minh; (iii) xe thông minh; (iv) các ứng dụng giao thông không người điều khiển thông minh;

5. An ninh thông minh; (vi) Ứng dụng người dùng cuối được TTNT hỗ trợ; (vii) Thiết bị neo thông minh cho con người; (viii) Người máy thông minh. Đồng thời, nhận diện bốn động cơ phát triển TTNT Trung Quốc gồm phần cứng, dữ liệu, nghiên cứu và thuật toán, hệ sinh thái TTNT thương mại.

  * Về phần cứng, Trung Quốc chủ trương bắt kịp các nước tiên tiến thế giới về sản xuất chíp và siêu máy tính. Tiếp cận của Trung Quốc là kết hợp thúc đẩy các cuộc đua tranh nội địa, khuyến khích giao dịch với các công ty nước ngoài, xây dựng siêu máy tính với việc tạo động lực cho các tập đoàn công nghệ khổng lồ và các công ty khởi nghiệp huyền thoại đầu tư vào sản xuất chíp TTNT: chip chung CPU và chip GPU ( _graphics processing unit_ ) gián tiếp cho TTNT, chíp riêng cho thuật toán học và học sâu như TPU ( _tensor processing unit_ ) của Google và FPGA ( _field-programmable gate array_ ) của Microsoft đồng thời với thiết lập các siêu máy tính.

  * Về dữ liệu, Trung Quốc chủ trương phát huy lợi thế nguồn dữ liệu kết hợp hoạt động chia sẽ dữ liệu giữa Chính phủ và các công ty, bảo hộ dòng dữ liệu xuyên biên giới với việc nâng cao sự quan tâm về quyền riêng tư trong các ứng dụng TTNT dựa trên tiêu chuẩn hóa các ngành công nghệ liên quan TTNT và tăng cường thảo luận quốc gia cho quan điểm bảo vệ quyền riêng tư dữ liệu mạnh mẽ hơn chống lại việc lợi dụng thái quá tự do hóa dữ liệu vào kinh doanh TTNT.

  * Về nghiên cứu và phát triển thuật toán, Trung Quốc tăng tốc hoạt động đào tạo và thu hút tài năng TTNT, kết hợp các biện pháp hỗ trợ nghiên cứu cơ bản thu hút và đào tạo tài năng (đặc biệt các tài năng TTNT hàng đầu thế giới) với khuyến khích các công ty công nghệ khổng lồ (Baidu, Huawei , Alibaba, Tencent, iFlyTek, v.v.) thành lập các viện nghiên cứu TTNT ở nước ngoài để tuyển dụng tài năng TTNT, khắc phục hạn chế công bố khoa học về TTNT (tuy nhiều về số lượng, nhưng yếu về tác động ảnh hưởng).


  * Về xây dựng hệ sinh thái TTNT thương mại, Chính phủ Trung Quốc đầu tư hơn một tỷ đô la Mỹ cho các công ty khởi nghiệp trong nước, đồng thời hướng dẫn các chính quyền địa phương và các tập đoàn nhà nước thu hút đầu tư tư nhân để thành lập các quỹ ( _government guidance funds:_ GGF) tài trợ các dự án TTNT khai thác khối lượng dữ liệu khổng lồ từ một quy mô dân số, tích hợp mục tiêu TTNT của công ty vào mục tiêu chiến lược TTNT của đất nước.


### Chiến lược TTNT của nước Pháp

Châu Âu đi sau Bắc Mỹ và Trung Quốc trong xây dựng chiến lược TTNT [16, 31, 41]. Do Đức tập trung vào Công nghiệp 4.0 và Anh tập trung cho việc rời khởi Liên minh châu Âu, cho nên sự kiện Tổng thống Pháp Emmanuel Macron công bố chiến lược “ _lãnh đạo TTNT_ ” quốc gia của nước Pháp với vốn đầu tư 1,5 tỷ Euro của Chính phủ Pháp trong năm năm 2018-2022 được nhìn nhận như đại diện cho chiến lược TTNT quốc gia của châu Âu. Tuyên bố của Tổng thống Pháp về chiến lược TTNT là tóm tắt các điểm chính của Báo cáo chiến lược TTNT của Pháp và Châu Âu dài 154 trang do Cédric Villani (nhà toán học Pháp được giải thưởng Fields năm 2010 và là một nghị sỹ Pháp) và cộng sự xây dựng. Bảy nội dung chính trong báo cáo nói trên là:

  * Xây dựng một chính sách dữ liệu tích cực: khuyến khích các công ty cùng tạo lập và chia sẻ dữ liệu, tạo lập dữ liệu được xã hội quan tâm, hỗ trợ quyền sao lưu dữ liệu.

  * Bốn khu vực TTNT chiến lược trọng tâm là y tế, giao thông, môi trường, quốc phòng và an ninh: tiến hành các chính sách riêng theo từng khu vực chiến lược hướng vào các vấn đề chính, tạo nền tảng đặc thù khu vực, kiểm tra vùng đổi mới cho mỗi khu vực.

  * Thúc đẩy lợi thế tiềm năng nghiên cứu TTNT của Pháp: thành lập các tổ chức TTNT liên ngành tại các trường đại học và viện nghiên cứu được chọn lựa, phân bổ nguồn lực phù hợp dành cho nghiên cứu (bao gồm một siêu máy tính được thiết kế riêng cho ứng dụng TTNT với sự hợp tác của nhà sản xuất), tăng độ hấp dẫn với nghề nghiệp nghiên cứu công nhờ thúc đẩy sự hấp dẫn của Pháp đối với tài năng xuất ngoại hoặc nước ngoài: tăng số lượng thạc sĩ và sinh viên tiến sĩ nghiên cứu TTNT, tăng lương cho nhà nghiên cứu và tăng cường trao đổi hàn lâm–công nghiệp.

  * Lập kế hoạch ứng phó tác động của công nghệ TTNT tới người lao động: thiết lập phòng thí nghiệm công về chuyển đổi công việc, phát triển nghiên cứu về sự bổ trợ của máy móc tới con người, đánh giá phương pháp tài trợ mới cho đào tạo nghề,

  * Nâng cao tính thân thiện môi trường của công nghệ TTNT: xây dựng trung tâm nghiên cứu về TTNT với hệ sinh thái (bao gồm đo lường tác động của các công cụ TTNT tới môi trường), giảm thiểu năng lượng cho sử dụng TTNT (bao gồm hỗ trợ chuyển đổi hệ sinh thái từ công nghiệp tính toán đám mây châu Âu), chuyển đổi hệ sinh thái song hành với độ tự do dữ liệu hệ sinh thái.


  * Đảm bảo tính minh bạch của công nghệ TTNT: Phát triển tính minh bạch và kiểm toán thuật toán, lưu ý trách nhiệm của các tác nhân TTNT liên quan tới đe dọa đạo đức, thành lập ủy ban đạo đức tư vấn cho các công nghệ số và TTNT với trách nhiệm tổ chức các tranh luận công khai về đạo đức TTNT, đảm bảo nguyên tắc trách nhiệm là của con người (đặc biệt khi công cụ TTNT dùng trong dịch vụ công).

  * Đảm bảo TTNT hỗ trợ tính đa dạng và không bị loại trừ xã hội: đảm bảo phụ nữ chiếm 40% số người tham dự các khóa học kỹ thuật số vào năm 2020, sửa đổi thủ tục hành chính và nâng cao kỹ năng hòa giải, hỗ trợ cải tiến xã hội dựa trên TTNT.


Sự phát triển thị trường dữ liệu với tốc độ cao (vào khoảng 739 tỷ Euro năm 2020) và tiềm năng nhân lực phân tích dữ liệu (trên 10 triệu người năm 2020) của châu Âu16 là một lợi thế cho sự phát triển TTNT tại châu lục này.

### Chiến lược TTNT quốc gia của các nước Đông Á

#### Nhật Bản

Từ nay tới năm 2030, Nhật Bản luôn là nền kinh tế lớn thứ tư thế giới tính theo GDP ngang giá sức mua17. Thị trường TTNT Nhật Bản tăng trưởng nhanh từ khoảng 3.700 tỷ Yên (năm 2015) lên khoảng 87.000 tỷ Yên (năm 2030)18. Chiến lược công nghệ TTNT Nhật Bản hướng mục tiêu dẫn đầu thế giới [39] với một số nội dung đáng chú ý sau đây:

  * Hội đồng chiến lược công nghệ TTNT Nhật Bản được Chính phủ thành lập với vai trò quản lý ngành dọc năm cơ quan NC-PT quốc gia (Ba trung tâm phát triển nòng cốt là Viện CNTT-TT quốc gia ( _National Institute of Information and Communications Technology_ : NICT), Viện nghiên cứu vật lý và hóa học ( _Institute of Physical and Chemical Research_ : RIKEN), Viện Khoa học và Công nghệ Công nghiệp quốc gia ( _National Institute of Advanced Industrial Science and Technology_ : AIST)).

  * Lộ trình công nghiệp hóa TTNT tập trung ưu tiên vào ba khu vực là năng suất, chăm sóc sức khỏe – y tế, và di động theo ba giai đoạn (i) Giai đoạn 1 (tới khoảng 2020): Phát triển việc sử dụng và ứng dụng TTNT hướng dữ liệu vào các miền ứng dụng hạt giống, (ii) Giai đoạn 2 (khoảng 2020-2025): Phát triển việc sử dụng công cộng TTNT và dữ liệu vào nhiều miền mở rộng, (ii) Giai đoạn 3 (khoảng 2025-2030):


Hệ sinh thái TTNT được thiết lập dựa trên sự kết nối và trộn nhiều miền. “TTNT như một dịch vụ” (AI as a Service: AIaaS) được thực thi dọc theo nhiều miền.

  * Ba trung tâm NC-PT nòng cốt tập trung nghiên cứu ưu tiên các công nghệ TTNT tiếp xúc xã hội (nhận dạng hình ảnh, xử lý ngôn ngữ tự nhiên, nhận dạng/tổng hợp tiếng nói, dự báo) dựa trên dữ liệu đa dạng (cá nhân, thoại – hội thoại, nội khoa, lịch sử hành động và tìm kiếm, không gian sống - làm việc, bán hàng - sản xuất, giao thông, thiên nhiên, thời tiết, bản đồ - vùng đất -không gian đô thị). Chính phủ tăng đầu tư NC-PT TTNT gấp ba lần cho các công ty thuộc các trường đại học và các cơ quan NC-PT trong vòng mười năm, đồng thời, thúc đẩy tăng cường đầu tư tư nhân cho NC-PT TTNT.

  * Phát triển môi trường đảm bảo cơ hội phát triển và thu hút nguồn nhân lực TTNT (quan tâm các nhà nghiên cứu trẻ), đặc biệt thu hút nhân lực TTNT cao cấp trong và ngoài nước ở giai đoạn 1. Khuyến khích các nhà nghiên cứu TTNT tham gia tích cực tiêu chuẩn toàn cầu về TTNT. Khuyến khích sự hiểu biết về phát triển công nghệ TTNT.


####  Hàn Quốc

Tháng 5/2018, Ủy ban Công nghiệp 4.0 Hàn Quốc công bố chiến lược TTNT quốc gia với vốn đầu tư 2.200 tỷ Won nhằm mục tiêu trở thành một trong bốn cường quốc TTNT trên thế giới, thu hút được 5.000 nhân sự TTNT cao cấp, xây dựng được 160 triệu đơn vị dữ liệu TTNT [43]. Bốn giai đoạn NC-PT TTNT của Hàn Quốc tới năm 2030 như sau:

  * **Giai đoạn 1 (tới năm 2020)**. __Công nghệ lõi__ : Phát triển công nghệ hiểu âm thanh - thị


giác ngôn ngữ. __Công nghệ mở rộng__ : Hệ thống hỏi-đáp TTNT trong các lĩnh vực chuyên môn. Rút ngắn thời gian tìm kiếm thuốc mới trong ngành y tế từ năm năm xuống một năm. __Công nghệ nền__ : Phân tích thông tin phức tạp cần vận dụng hoạt động diễn giải công suất lớn. Thu hút và đào tạo 590 nhân sự TTNT cao cấp và 2.250 nhân sự TTNT phổ thông. Xây dựng được 66,7 triệu đơn vị dữ liệu thông dụng, 4,3 triệu đơn vị dữ liệu công nghiệp và 9,2 tỷ đơn vị hiểu tiếng Hàn. Mỗi năm cung cấp hỗ trợ siêu máy tính cho 300 tổ chức.

  * **Giai đoạn 2 (tới năm 2022)**. __Công nghệ lõi__ : Làm chủ lý thuyết học không giám sát, kỹ thuật tóm tắt ảnh, công nghệ theo dõi-phát hiện và dự đoán, học suy luận chức năng diễn giải (kéo dài tới 2025). __Công nghệ mở rộng__ : Hệ thống phát hiện rủi ro thời gian thực. Rút ngắn hơn một nửa chu kỳ phát triển thuốc mới trong ngành y tế (từ 15 năm xuống 7 năm). __Công nghệ nền__ : Trao đổi thông tin nhận thức giữa mạng thần kinh não bộ và mạng thần kinh TTNT và Giao diện tích hợp an toàn não bộ và máy móc (kéo dài tới 2025). Thu hút và đào tạo 1370 nhân sự TTNT cao cấp và 3600 nhân sự TTNT phổ thông. Xây dựng được 111 triệu đơn vị dữ liệu thông dụng, 48,5 triệu đơn vị dữ liệu công nghiệp và 15,3 tỷ đơn vị hiểu tiếng Hàn. Mỗi năm cung cấp hỗ trợ siêu máy tính cho 400 tổ chức

  * **Giai đoạn 3 (tới năm 2025)**. __Công nghệ lõi__ : Tiếp tục học suy luận chức năng diễn giải. Thương mại hóa chíp mạng nơ-ron nhân tạo. __Công nghệ mở rộng__ : Hệ thống hỏi – đáp bằng hình ảnh. Phát triển thuốc mới tương tích mới với từng cá thể. __Công nghệ nền__ : Trao đổi thông tin nhận thức giữa mạng thần kinh não bộ và mạng thần kinh TTNT và Giao diện tích hợp an toàn não bộ và máy móc (tiếp tục). Phát triển nhân tài có năng lực lãnh đạo TTNT tầm thế giới (kéo dài tới 2030). Tăng cường củng cố cơ sở hạ tầng nghiên cứu với hình thức hợp tác mở rộng (kéo dài tới 2030).

  * **Giai đoạn 4 (tới năm 2030)**. __Công nghệ lõi__ : Hợp tác tự chủ giữa TTNT với con người thông qua công nghệ học không giám sát. __Công nghệ mở rộng__ : Cung cấp chế phẩm thực phẩm – y tế phù hợp với từng đối tượng cụ thể. __Công nghệ nền__ : Củng cố, cải thiện khả năng nhận thức của con người thông qua ứng dụng TTNT. Phát triển nhân tài có năng lực lãnh đạo TTNT tầm thế giới (tiếp tục). Tăng cường củng cố cơ sở hạ tầng nghiên cứu với hình thức hợp tác mở rộng (tiếp tục).


Phương án đầu tư là tập trung vào các công nghệ mới, khu vực công khó thu hút đầu tư tư nhân và hỗ trợ tạo thị trường sơ khai về các lĩnh vực có sức cạnh tranh tư nhân. Phương châm thực hiện là đảm bảo năng lực kỹ thuật TTNT theo tiêu chuẩn quốc tế trong khoa học cơ bản (TTNT thế hệ mới dựa trên nền tảng khoa học nhận thức, tính toán mạng nơ-ron), về công nghệ hạ tầng chíp TTNT, tính toán hiệu năng cao TTNT, về các lĩnh vực ứng dụng theo công thức TTNT+ X (thuốc mới, nguyên liệu tương lai, ứng dụng vào công nghiệp); Thành lập Viện đào tạo sau và trên đại học về TTNT, tăng cường hỗ trợ đào tạo, NC-PT TTNT tại các trường đại học – viện nghiên cứu; xây dựng Phòng Thí nghiệm não bộ TTNT, Hub TTNT và các nền tảng hạ tầng TTNT công và tư. Công ty dẫn đầu về TTNT của Hàn Quốc là Saltlux đã nhận được vốn đầu tư 32 tỷ Won cho sản phẩm TTNT19.

#### . Đài Loan, Singapore và Malaysia

  * Chiến lược TTNT của Đài Loan (Trung Quốc)20 gồm có: (i) TTNT cho đổi mới công nghiệp: trau dồi và phù hợp tài năng theo nhu cầu đối vói năm ngành công nghiệp (máy móc thông minh, ngành y sinh, năng lượng tái tạo, công nghiệp quốc phòng, nông nghiệp mới) cho “Thung lũng Silicon châu Á” và một nền kinh tế tuần hoàn (circular economy); (ii) Trở thành một trung tâm đổi mới quốc tế về TTNT: nuôi dưỡng 100 công ty khởi nhiệp về TTNT, phát triển các cụm đổi mới TTNT quốc tế; (iii) Áp dụng các mô hình tương tự như DARPA ở Mỹ và SIP (Strategic Innovation Promotion) ở Nhật Bản đối với các dự án hoa tiêu về TTNT; (iv) Tới năm 2021, trau dồi được 1000 tài năng ưu tú về TTNT (800 người từ các trường đại học, 200 người từ các tổ chức nghiên cứu), khuyến khích các doanh nghiệp quốc tế thành lập trung tâm NC-PT về TTNT; đào tạo 10.000 người tiên phong trong ứng dụng TTNT (5.000 người qua công nghệ TTNT thực tiễn, 2.000 người qua đào tạo đa miền từ trường đại học, 2.000 nhân viên công ty, 1.000 người từ ngành khác); thu hút tài năng TTNT toàn cầu; (v) Chứng thực lĩnh vực và đồng sáng tạo theo quy định: chứng thực các lĩnh vực và dữ liệu, nghiên cứu và phân tích về các luật và quy định có liên quan.


  * Chương trình quốc gia về TTNT của Singapore21 được đầu tư 150 triệu đô la Singapore trong năm năm nhằm kết hợp năng lực TTNT mức quốc gia để thúc đẩy nền kinh tế số Singapore trong tương lai. Chương trình nhắm tới ba mục tiêu: (i) Sử dụng TTNT để giải quyết những thách thức chính tác động lớn đến xã hội và công nghiệp trong giao thông, chăm sóc sức khỏe, v.v.; (ii) Đầu tư tăng cường năng lực TTNT (hệ thống TTNT giải thích được thế hệ TTNT tiếp theo, khoa học nhận thức, đào tạo tài năng TTNT, v.v.); (iii) Cung cấp 100 dự án để thúc đẩy việc tiếp nhận và sử dụng TTNT và học máy vào các ngành công nghiệp.

  * Chính phủ Malaysia dự kiến xây dựng một Kế hoạch TTNT quốc gia là phiên bản mở rộng Kế hoạch phân tích dữ liệu lớn (Big Data Analytics: BDA) quốc gia22. Nội dung cơ bản của Kế hoạch phân tích dữ liệu lớn (PTDLL) của Malaysia là: (i) Malaysia là một trong số ít quốc gia có lộ trình có cấu trúc cho phép giải phóng đầy đủ giá trị của dữ liệu lớn; (ii) Chủ doanh nghiệp, chính quyền và công dân sẵn sàng cho tầm nhìn “Malaysia là trung tâm giải pháp PTDLL hàng đầu Đông Nam Á”; (iii) Ba sáng kiến chiến lược: Mở rộng việc sử dụng PTDLL trong khu vực tư nhân, xúc tiến việc tiếp nhận và sử dụng PTDLL trong khu vực công, xây dựng ngành công nghiệp PTDLL của Malaysia; (iv) Ba mệnh lệnh chiến lược là: phát triển đội ngũ nhà khoa học dữ liệu, giải phóng giá trị của dữ liệu mở của chính quyền, thúc đẩy đổi mới dựa trên công nghiệp đối với các trường hợp có ảnh hưởng lớn.


## Một số trao đổi về một chiến lược Trí tuệ nhân tạo quốc gia của Việt Nam

Trong bối cảnh của Việt Nam, cần thiết phải xác định rõ ràng bối cảnh, mục tiêu và các biện pháp hướng mục tiêu trong một chiến lược TTNT quốc gia như vậy. Dưới đây là một số trao đổi liên quan.

Thứ nhất, cần xác định đúng quy mô thị trường TTNT Việt Nam hiện thời và theo kỳ vọng chiến lược của một quốc gia xếp hạng 29 vào năm 2030, xếp hạng 20 vào năm 2050 tính theo GDP ngang giá sức mua trên thế giới. Tránh kỳ vọng chiến lược bị phóng đại hoặc bị hạ thấp quá mức. Hiện chưa xuất hiện một báo cáo khảo sát chính thức về quy mô thị trường TTNT Việt Nam; các báo cáo về thị trường TTNT thế giới và khu vực của các công ty khảo sát có uy tín trên thế giới chưa cho thông tin về Việt Nam. Điều đó có nghĩa là thị trường TTNT Việt Nam vẫn còn nhỏ bé. Ngoài ra, qua trao đổi với đại diện một số doanh nghiệp tại Hội nghị AI4Life-2018, chúng tôi tiếp thu được một điều là TTNT chưa thành hạng mục đầu tư của nhiều doanh nghiệp Việt Nam và nếu có chỉ chiếm một phần không đáng kể. Đó là các chỉ dấu cho thấy thị trường TTNT Việt Nam hiện còn rất nhỏ và độ cam kết của các doanh nghiệp Việt Nam đóng góp vào thị trường TTNT chưa rõ ràng. Như vậy, một mặt, Việt Nam có lợi thế về vị trí địa lý kề cận với một trung tâm TTNT là Đông Bắc Á (chiếm tới 50,32% lợi ích toàn cầu từ TTNT năm 2030 theo dự báo), mặt khác, Việt Nam có hạn chế là thị trường TTNT hiện thời quá nhỏ bé. Tìm ra các biện pháp để khắc phục được hạn chế và khai thác tốt lợi thế để làm tăng trưởng nhanh thị trường TTNT nội địa và xuất khẩu, gia công sản phẩm TTNT Việt Nam có ý nghĩa đặc biệt quan trọng (ví dụ, Việt Nam là đối tác NC-PT phần mềm bên ngoài (offshore) lớn thứ hai của Nhật Bản vào năm 2016 [40]). Đối với thị trường TTNT nội địa, với vai trò vừa là người tiêu dùng lớn nhất vừa là tác nhân có trách nhiệm dẫn dắt phát triển nền kinh tế đất nước, Nhà nước ta cần là nhà đầu tư chiến lược vào những thành phần TTNT cốt lõi quốc gia, trước mắt là đầu tư xây dựng công phu một chiến lược TTNT quốc gia phù hợp nhất với Việt Nam; chiến lược đó cần bao gồm việc xác định đúng quy mô thị trường TTNT Việt Nam theo kỳ vọng và xây dựng các chính sách tạo động lực tăng cường quy mô thị trường TTNT Việt Nam tới quy mô theo kỳ vọng.

Thứ hai, cần xác định được chính xác các cơ hội và thách thức đối với sự phát triển TTNT Việt Nam. Như đã được đề cập, TTNT là một lĩnh vực hội tụ nhiều ngành thuộc nhiều lĩnh vực cho nên nhận thức về TTNT cũng như về công nghệ TTNT là rất đa dạng. Nghiên cứu của E. Brynjolfsson và cộng sự [8] về “nghịch lý năng suất hiện đại” của công nghệ (nói riêng công nghệ TTNT) cho thấy xu hướng khác biệt giữa đánh giá lạc quan của giới công nghệ và đầu tư mạo hiểm với đánh giá bi quan của giới kinh tế, xã hội học, thống kê và quan chức chính quyền. Nếu không dựa trên một khung nhìn khoa học trung thực, việc đánh giá cơ hội và thách thức đối với sự phát triển TTNT Việt Nam dễ rơi vào một trạng thái cực đoan theo một phía lạc quan hoặc bi quan trên đây.

Thứ ba, cần khảo sát, phân tích khoa học nội dung chiến lược TTNT quốc gia của các nước trên thế giới. Chiến lược phát triển TTNT quốc gia của Việt Nam cần đặt NC-PT theo mục tiêu kinh doanh của doanh nghiệp có mục tiêu ngắn hạn vào tổng thể nghiên cứu cơ bản theo mục tiêu chiến lược phát triển đất nước dài hạn của Nhà nước23. Nền tảng khoa học cơ bản là rất quan trọng trong xây dựng chiến lược TTNT quốc gia. Chiến lược TTNT quốc gia cũng cần xây dựng được các chính sách thúc đẩy sự chung tay đầu tư của doanh nghiệp Việt Nam cho một thị trường kinh tế số (nói chung) và thị trường TTNT (nói riêng) bền vững, đồng thời, cần giảm thiểu tác động từ cách tiếp cận theo mục tiêu kinh doanh ngắn hạn của doanh nghiệp tới chiến lược quốc gia và chính sách Nhà nước. Phát huy lợi thế ổn định chính trị vào việc giảm thiểu nhanh chóng tiến tới triệt tiêu bốn nguyên nhân dẫn đến sự trì trệ của đất nước đã được Thủ tướng Chính phủ nhận diện (chưa tuân thủ đúng tinh thần kinh tế thị trường định hướng xã hội chủ nghĩa; kỷ cương phép nước chưa nghiêm; tham nhũng, tiêu cực, lợi ích nhóm còn xảy ra trầm trọng, kéo dài; bệnh quan liêu, xa dân)24 và ngăn ngừa hiện tượng lạm dụng tiếp cận cơ hội kinh doanh của doanh nghiệp vào hoạt động quản lý Nhà nước. Trong mọi trường hợp, một nhận thức đúng đắn về TTNT, về công nghiệp TTNT, về điều kiện cụ thể của đất nước và bối cảnh quốc tế để hiểu biết đúng và phát huy thế mạnh, để giảm thiểu và khắc phục hạn chế là những yếu tố cốt lõi tiên quyết cho xây dựng và thực hiện thành công chiến lược phát triển TTNT quốc gia và nền kinh tế số Việt Nam.

Thứ tư, cần quan tâm tới năng lực hội nhập toàn cầu của các doanh nghiệp Việt Nam, đặc biệt là các doanh nghiệp vừa và nhỏ. Một tỷ lệ lớn các doanh nghiệp Việt Nam chuyên cung cấp nguyên, vật liệu gốc trong các chuỗi cung ứng toàn cầu. Một chiến lược TTNT doanh nghiệp về phân tích dữ liệu hiệu quả nhằm làm giảm thiểu hoặc triệt tiêu tác động của hiệu ứng Bullwill (lỗi dự báo nhu cầu và yêu cầu người dùng bị khuyếch đại) và thực sự đưa doanh nghiệp Việt Nam trở thành một đối tác trong chuỗi (mạng) cung ứng toàn cầu sẽ giúp doanh nghiệp Việt Nam kinh doanh bền vững trong thời đại số ngày nay. Về mặt quản lý, doanh nghiệp cần quan tâm tới ba thách thức (i) Phát triển một hiểu biết trực tiếp về TTNT; (ii) Cấu trúc tổ chức phù hợp với TTNT; (iii) Đổi mới tư duy về bối cảnh cạnh tranh. Mỗi doanh nghiệp cần tìm được một chiến lược TTNT riêng phù hợp nhất với mình. Đối với Việt Nam, các nhà quản lý trong các khu vực khác nhau trong doanh nghiệp cần phải hiểu được các nguyên tắc cơ bản của công nghệ TTNT để có năng lực tiếp nhận và sử dụng được hiệu quả từ các đòn bẩy từ công nghệ TTNT tới việc ra quyết định tốt hơn trong mọi khu vực của doanh nghiệp là một điều kiện có tầm quan trọng đặc biệt. Andrew Ng, nhà khoa học trưởng của Baidu Trung Quốc giai đoạn 2014-2017, nhận định rằng học sâu là nhiệm vụ của con người, không chỉ là của máy móc25. Như thế có nghĩa là, các nhà quản lý ở mọi khu vực kinh doanh của doanh nghiệp là chủ thể chính tiếp nhận và sử dụng hiệu quả đòn bẩy từ khoa học dữ liệu (và TTNT) để ra quyết định tốt hơn trong mọi khu vực của doanh nghiệp26. Điều này có nghĩa là chiến lược TTNT quốc gia của Việt Nam cần bao gồm hoạt động đào tạo và tự đào tạo nâng cao trình độ hiểu biết và ứng dụng TTNT của các nhà quản lý trong doanh nghiệp là một điều kiện có tầm quan trọng đặc biệt trong việc hình thành hệ sinh thái công nghiệp TTNT Việt Nam.

Thứ năm, nhân lực TTNT Việt Nam tài năng là một nhân tố cốt lõi đảm bảo sự thành công của phát triển TTNT và nền kinh tế số Việt Nam. Mặc dù vị thế quốc tế của toán học Việt Nam không còn cao như thời kỳ chống Mỹ cứu nước27, song tiềm năng NC-PT TTNT của lớp trẻ Việt Nam là khá khả quan. Dù còn có nghi ngại về phương thức lấy mẫu, song kết quả đánh giá PISA hai đợt của Việt Nam (năm 2012 và năm 2015) được Tổ chức Hợp tác và Phát triển kinh tế thế giới (The Organisation for Economic Co-operation and Development: OECD) ghi nhận tích cực28. Về kỹ năng lập trình, từ 2007 tới nay, thường xuyên có các đội tuyển sinh viên Việt Nam vượt qua các vòng đấu loại quốc tế (có sự tham gia của hàng nghìn trường đại học trên thế giới) để được tham dự vòng chung kết toàn cầu cuộc thi lập trình sinh viên ACM/ICPC; ở khu vực Đông Nam

  * chỉ có Singapore có được kết quả như vậy. Trường Đại học Công nghệ (ĐHQGHN), Trường Đại học Khoa học Tự nhiên (ĐHQG Thành phố Hồ Chí Minh), Trường Đại học Bách khoa (ĐHQG Thành phố Hồ Chí Minh), Trường Đại học PFT là các trường đại học có các đội tuyển như vậy, trong đó dẫn đầu là Trường Đại học Công nghệ (ĐHQGHN) với bảy lần (2007-2009, 2015-2018) tham dự vòng thi chung kết toàn cầu ACM/ICPC và ở khu vực Đông Nam Á thì chỉ có Đại học Quốc gia Singapore và Đại học Công nghệ Nanyang (Singapore) có được thành công như vậy. Hơn nữa, đội tuyển sinh viên của Trường Đại học Công nghệ (ĐHQGHN) nhiều năm đạt thứ hạng cao, sánh ngang với các trường đại học công nghệ hàng đầu thế giới, chẳng hạn, đội tuyển sinh viên của Trường Đại học Công nghệ (ĐHQGHN) đạt hạng 14 vào năm 201829. Trên cơ sở khai thác các tiềm năng về khoa học và lập trình của lớp trẻ Việt Nam, đầu tư phát triển tài năng TTNT Việt Nam có chuyên môn và đạo đức tốt _không chỉ biết tạo sản phẩm TTNT mà còn đảm bảo sử dụng nó có lợi cho loài người 30_, thấm nhuần triết lý “ _TTNT cùng con người, TTNT vì nhân loại_ ”cần là một nội dung quan trọng trong chiến lược phát triển TTNT quốc gia của Việt Nam. Đầu tư ưu tiên cho phát triển tài năng TTNT cần được coi là thành phần quan trọng nhất trong đầu tư chiến lược tăng cường quy mô thị trường TTNT của Nhà nước. Cần tiến hành một nghiên cứu công phu về các khía cạnh con người, văn hóa, lịch sử, xã hội, đặc biệt là các khía cạnh chính sách và quản lý để tìm ra nguyên nhân làm cho hệ thống giáo dục đại học Việt Nam không đạt mức đặc biệt hiệu quả hơn hẳn hệ thống Bắc Mỹ ở một số phương diện của các hệ thống giáo dục đại học Hàn Quốc, Trung Quốc, Đài Loan, Hồng Kông, Singapore dù có cùng một gốc rễ giáo dục dân tộc “nho giáo”[26]. Xây dựng chương trình đào tạo chuyên TTNT và các chương trình đào tạo liên ngành có liên quan tới TTNT. Chương trình đào tạo cần quan tâm tới các khối kiến thức toán học, khoa học máy tính, điều khiển học cùng một số kiến thức khoa học cơ bản khác (bao gồm kiến thức khoa học xã hội và nhân văn) để cung cấp một nền tảng khoa học cốt lõi phát triển các mô hình và thuật toán TTNT độc đáo. Phân tích toán học để hiểu sâu hơn cơ chế nền tảng của mạng nơ-ron học sâu là rất quan trọng không chỉ để cải thiện hiệu năng của mạng mà quan trọng hơn là để đảm bảo triển khai một cách có trách nhiệm các ứng dụng có ảnh hưởng xã hội [10, 17]; điều đó cho thấy tầm quan trọng đặc biệt của kiến thức khoa học cơ bản trong việc phát triển nhân lực TTNT tài năng.


# Kết luận

Trong thời đại số ngày nay, dù tiềm ẩn một số thách thức như làm gia tăng tình trạng bất bình đẳng xã hội và đe dọa đời sống con người nhưng TTNT được coi là một công nghệ “người cầm lái” dẫn dắt năng suất quốc gia và mang tới các cơ hội lớn cho mọi người, mọi tổ chức và mọi quốc gia. Theo một dự báo được thừa nhận rộng rãi, lợi ích từ TTNT sẽ đóng góp tới 15.700 tỷ đô la Mỹ và chiếm 14% GDP danh nghĩa toàn cầu vào năm 2030.

Nhận thức đúng đắn và đầy đủ về NC-PT TTNT theo triết lý “ _TTNT cùng con người, TTNT vì nhân loại_ ”, tập trung phát triển các khu vực TTNT có lợi thế là những đặc trưng cốt lõi của chiến lược TTNT quốc gia của nhiều nước trên thế giới. Chú trọng phát triển đội ngũ nhân lực TTNT tài năng, tăng cường phát triển các công nghệ TTNT lõi (đặc biệt là các thuật toán học máy và công nghệ dữ liệu lớn), triển khai công nghệ TTNT phục vụ cộng đồng, mở rộng hệ sinh thái TTNT thương mại và nâng cao đạo đức TTNT là những nội dung nổi bật trong chiến lược TTNT quốc gia của không chỉ các nước siêu cường kinh tế mà còn các nước khác.

Phát huy lợi thế về ổn định chính trị, ưu tiên đầu tư phát triển tiềm năng nhân lực về khoa học và lập trình, khai thác lợi thế có vị trí địa lý kề cận một khu vực tiềm năng có lợi ích từ TTNT lớn nhất thế giới, khắc phục hạn chế về thị trường TTNT nội địa còn nhỏ bé cần là một số giải pháp trong một chiến lược TTNT quốc gia của Việt Nam.

Chúng ta tin tưởng vào tương lai công nghiệp TTNT Việt Nam sẽ phát triển với tốc độ cao, góp phần xứng đáng vào sự nghiệp phát triển kinh tế - xã hội của đất nước trong thời đại số ngày nay.

# Tài liệu tham khảo

  1. Ngân hàng Thế giới (Khối Thương mại và Cạnh tranh Toàn cầu). _Việt Nam: Tăng cường_


_năng lực cạnh tranh và liên kết của doanh nghiệp vừa và nhỏ: Bài học kinh nghiệm trong nước và quốc tế_. Tài liệu 119861, Ngân hàng Thế giới, 2017.

  2. Wil M. P. van der Aalst. _Process Mining - Data Science in Action (2nd edition)_. Springer, 2016.

  3. Ajay Agrawal, Joshua Gans, Avi Goldfarb. _Prediction Machines The Simple Economics of Artificial Intelligence_. Harvard Business Review, 2018.

  4. James Barrat. _Our Final Invention Artificial Intelligence and the End of the Human Era_. Thomas Dunne Books, 2013.

  5. Dominic Barton, Jonathan Woetzel, Jeongmin Seong, Qinzheng Tian. _Artificial intelligence: Implications for China._ Report, McKinsey Global Institute, April 2017.

  6. Gaurav Batra, Andrea Queirolo, and Nick Santhanam. _Artificial intelligence: The time to_


_act is now_. Article January 2018, McKinsey.& Company. _https://www.mckinsey.com/industries/advanced-electronics/our-insights/artificial-intelligence-the-time-to-act-is-now_

  7. Bhabani Shankar Prasad Mishra, Satchidananda Dehuri, Euiwhan Kim, Gi-Name Wang. _Techniques and Environments for Big Data Analysis: Parallel, Cloud, and Grid Computing_. Springer, 2016.

  8. Erik Brynjolfsson, Daniel Rock, Chad Syverson. _Artificial Intelligence and the Modern Productivity Paradox: A Clash of Expectations and Statistics_. Working Paper 24001, 2017.

  9. Andrew Burgess. _The Executive Guide to Artificial Intelligence: How to identify and implement applications for AI in your organization_. Palgrave Macmillan, 2018.

  10. Anthony L. Caterini, Dong Eui Chang. _Deep Neural Networks in a Mathematical Framework_. Springer, 2018.

  11. Calum Chace. _Artificial Intelligence and the Two Singularities_. CRC, 2018.

  12. Clarivate Analytics. _Artificial Intelligence in Southeast Asia_. Industry Bytes, Clarivate Analytics, 2018.

  13. Francesco Corea. _Artificial Intelligence and Exponential Technologies: Business Models Evolution and New Investment Opportunities_. Springer International, 2017.

  14. Jeffrey Ding. _Deciphering China’s AI Dream: The context, components, capabilities, and consequences of China’s strategy to lead the world in AI_. Research Report, Future of Humanity Institute, University of Oxford, March 2018. _https://www.fhi.ox.ac.uk/wp-content/uploads/Deciphering_Chinas_AI-Dream.pdf_.

  15. Wolfgang Ertel, Nathanael T. Black. _Introduction to Artificial Intelligence_. Springer, 2018.

  16. European Political Strategy Center. _The Age of Artificial Intelligence: Towards a European Strategy for Human-Centric Machines_. EPSC Strategic Notes, Issue 29, 27 March 2018.

  17. Ian Goodfellow, Yoshua Bengio, Aaron Courville. _Deep Learning_. The MIT Press, 2016.

  18. M. Hilbert and P. Lopez. _The World’s Technological Capacity to Store, Communicate, and Compute Information_. Science, 332(6025): 60–65, 2011.

  19. Kai Hwang, Min Chen. _Big-Data Analytics for Cloud, IoT and Cognitive Computing_. Wiley, 2017.


  20. Fernando Iafrate. _Artificial intelligence and big data: the birth of a new intelligence._ Wiley-ISTE, 2018.

  21. IEEE Global Initiative. _Ethically Aligned Design: A Vision for Prioritizing Human Well-being with Autonomous and Intelligent Systems (Version 2 - For Public Discussion)_. IEEE's document, December 2017.

  22. Ray Kurzweil. _The Singularity Is Near: When Humans Transcend Biology_. Viking Adult, 2005.

  23. Ray Kurzweil. _How to Create a Mind - The Secret of Human Thought Revealed_. Viking Books, 2012.

  24. Tsugio Makimoto. _Implications of Makimoto's Wave_. IEEE Computer 46(12): 32-37, 2013.

  25. Tsugio Makimoto. _Chip Technologies as the Engine for IT Revolution_. COMPSAC 2015: 3.

  26. Simon Marginson. _The Confucian Model of Higher Education in East Asiaand Singapore_. In _Simon Marginson, Sarjit Kaur, Erlenawati Sawir. Higher Education in the Asia-Pacific_ , pp. 53-75, Springer, 2011.

  27. John McCarthy, M.L. Minsky, N. Rochester, C.E.Shannon. _A Proposal for the Dartmouth summer conference on artificial intelligence_. AI Magazine, 31 Aug. 1955.

  28. Bob Merritt. _The Digital Revolution_. Morgan & Claypool, 2016.

  29. National Science and Technology Council. _National Artificial Intelligence Research and Development Strategic Plan_. National Science and Technology Council of USA, October 2016.

  30. David L Poole, Alan K Mackworth. _Artificial intelligence foundations of computational agents (2nd edition)_. Cambridge University Press, 2017.

  31. Laurent Probst, Bertrand Pedersen, Virginie Lefebvre, Lauriane Dakkak. _USA-China-EU plans for AI: where do we stand?_ A report of Digital Transformation Monitor, January 2018.

  32. PwC. _2018 AI predictions 8 insights to shape business strategy_. PwC report, January 2018. _https://www.pwc.com/us/en/advisory-services/assets/ai-predictions-2018-report.pdf_

  33. S. Ransbotham, D. Kiron, P. Gerbert, và M. Reeves. _Reshaping Business With Artificial Intelligence._ MIT Sloan Management Review and The Boston Consulting Group, September 2017. Bài đi kèm “Philipp Gerbert, Martin Reeves, Sebastian Steinhäuser, and Patrick Ruwolt. _Is Your Business Ready for Artificial Intelligence?_ ” _https://www.bcg.com/publications/2017/strategy-technology-digital-is-your-business-ready-artificial-intelligence.aspx._

  34. Anand S. Rao, Gerard Verweij. _Sizing the prize: What’s the real value of AI for your business and how can you capitalise_. PwC report, 2017.

  35. Stuart Russell, Peter Norvig. _Artificial Intelligence. A Modern Approach (3rd Global Edition)_. Pearson, 2016.

  36. Ralph M. Stair, George Reynolds. _Principles of Information Systems (13thedition)_. Course Tachnology, 2018

  37. Jim Sterne. _Artificial Intelligence for Marketing: Practical Applications_. Wiley, 2017.

  38. Ion Stoica, Dawn Song, Raluca Ada Popa, David A. Patterson, Michael W. Mahoney, Randy H. Katz, Anthony D. Joseph, Michael Jordan, Joseph M. Hellerstein, Joseph Gonzalez, Ken Goldberg, Ali Ghodsi, David E. Culler, Pieter Abbeel. _A Berkeley View of_


_Systems Challenges for AI_. Technical Report No. UCB/EECS-2017-159, University of California at Berkeley, October 16, 2017.

  39. Strategic Council for AI Technology. _Artificial Intelligence Technology Strategy_. Report, Japan Strategic Council for AI Technology, 31/3/2017.

  40. Dinh Thi Quynh Van. _Vietnam has potential to become the next BPO giant_. PwC Vietnam, 22 January 2018.

  41. Cédric Villani et al. _For a Meaningful Artificial Intelligence: Towards a French and European strategy_. Mission Report, March 2018.

  42. 国务院关于印发. 新一代人工智能发展规划的通知. 国发〔2017〕35号 . 2017年7月8日（此件公开发布）. _http://www.gov.cn/zhengce/content/2017-07/20/content_5211996.htm_

  43. 4차산업혁명위원회 심의안건. 인공지능(AI) R&D 전략. 5/2018.

# Public_020

# Giới thiệu

Việc xác định độ dày của vật liệu bảo vệ chịu lửa và các vật liệu khác được sử dụng trong thử nghiệm khả năng chịu lửa là rất quan trọng để dự đoán chính xác chiều dày lớp chống cháy yêu cầu từ kết quả thử nghiệm.
Do đó, các phương pháp được sử dụng để thiết lập các đặc tính này phải nhất quán và Phụ lục này đưa ra hướng dẫn về các quy trình thích hợp được sử dụng.
Mọi mẫu thử được sử dụng để xác định độ dày phải phù hợp với mẫu thử cháy thực tế trong các điều kiện được mô tả trong Điều 8.
Các quy trình nêu trong EN 1363-1 phải được tuân thủ cùng với các yêu cầu sau.

## Chiều dày của vật liệu bảo vệ

### Chiều dày màng khô

Độ dày màng khô phải được xác định trực tiếp trên các mẫu thử nghiệm, sau khi lớp phủ được để khô hoàn toàn theo quy định của khách hàng.
Phòng thử nghiệm phải đo chiều dày bằng dụng cụ sử dụng nguyên tắc cảm ứng điện từ hoặc nguyên tắc dòng điện xoáy với đường kính tiếp xúc đầu dò ít nhất là 2,5 mm.

### Vị trí đo

Số lượng và vị trí điểm đo chiều dày (được coi là yêu cầu tối thiểu) phải như sau:

#### Dầm chịu tải

Cần thực hiện số lượng tối thiểu 88 phép đo trên các mặt cắt đo được chỉ ra trong Hình 6 và Hình 13.

  * Các mặt cắt đo nhiệt tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của dầm thử nghiệm.

  * Vị trí thực hiện phép đo nhiệt độ ở mặt trên của bản cánh dưới dầm hoặc mặt dưới của dầm rỗng, giữa mỗi mặt cắt đo nhiệt.

  * Vị trí nằm giữa các mặt cắt đo nhiệt độ ngoài cùng và giữa các điểm ngoài cùng trên mặt trên của bản cánh dưới dầm hoặc mặt dưới của dầm rỗng.


#### Dầm không chịu tải

Số lượng tối thiểu là 24 phép đo tại các vị trí trên bề mặt tiếp xúc với lửa của dầm (bản bụng và bản cánh hoặc mặt của dầm rỗng; xem Hình 12) tại các vị trí gần với.

  * Các mặt cắt đo nhiệt (cách từ 50 mm đến 100 mm) tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của dầm thử nghiệm.


#### Cột cao chịu tải

Cần thực hiện số lượng tối thiểu 50 phép đo trên các mặt cắt đo nhiệt được chỉ ra trong Hình 13 đối với cấu kiện tiết diện chữ I hoặc H và Hình 14 đối với cấu kiện có tiết diện rỗng.

  * Các mặt cắt đo nhiệt (cách từ 50 mm đến 100 mm) tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của cột thử nghiệm.

  * Các vị trí nằm giữa mỗi mặt cắt đo nhiệt.


#### Cột ngắn không chịu tải

Cần thực hiện số lượng tối thiểu 24 phép đo trên các mặt cắt đo nhiệt được chỉ ra trong Hình 13 đối với cấu kiện tiết diện chữ I hoặc H và Hình 14 đối với cấu kiện tiết diện rỗng.

  * Các mặt cắt đo nhiệt (cách từ 50 mm đến 100 mm) tại đó các phép đo nhiệt độ được thực hiện trên bề mặt của cột thử nghiệm.


## Nhận dạng

Việc xác định lớp phủ phải phù hợp với ETAG 018-Phần 2.

Các thuộc tính của vật liệu phải được đặc trưng / nhận dạng rõ ràng (công thức).

# Lắp đặt đầu đo nhiệt vào cấu kiện thép và đi dây

## Nguyên tắc chung

Việc đo chính xác nhiệt độ thép là cơ sở cho phương pháp đánh giá. Loại đầu đo nhiệt và phương pháp gắn và lắp đặt dây dẫn, bảo vệ và kết nối với cáp nối dài hoặc phần mở rộng thích hợp phải được xem xét cẩn thận. Phụ lục này đưa ra hướng dẫn về các quy định phù hợp.

## Kiểu đầu đo nhiệt

Một vài loại khác nhau của đầu đo nhiệt được cho là phù hợp, bao gồm loại “T”, “N”, “K” và “J” như quy định trong IEC 60584-1.

Ưu tiên sử dụng đầu đo nhiệt nằm trong lớp vỏ bọc bằng thép không gỉ được cách nhiệt bằng sợi khoáng với đầu nóng được cách nhiệt. Đường kính tổng thể của lớp vỏ bọc ít nhất là 1,5 mm.

Các đầu đo nhiệt khác có thể được sử dụng với sự tham vấn giữa phòng thí nghiệm và khách hàng thử nghiệm về tính phù hợp của chúng. Các đầu đo nhiệt thích hợp phải là dạng dây đơn có đường kính tối thiểu 0,5 mm và có lớp cách nhiệt giữa 2 sợi dây và giữa mỗi sợi dây với bất kỳ vật liệu dẫn nhiệt bên ngoài sao cho không bị hỏng trong quá trình thử nghiệm.

## Lắp đặt đầu đo nhiệt

Đầu nóng của đầu đo nhiệt cần được gắn trên cấu kiện thép bằng búa hoặc phương pháp khác mà không gây ảnh hưởng đến độ nhậy và độ chính xác của đầu đo nhiệt. Không được gắn bằng vít hoặc bu lông.

Với bất kỳ phương pháp cố định nào điều cơ bản là các đầu đo nhiệt không được tiếp xúc ngoài phạm

  6. mối nối nóng được đặt ở trong hoặc tại bề mặt thép; mối nối nóng của đầu đo nhiệt phải được lắp đặt tại vị trí gần nhất với điểm nối lạnh. Đầu đo nhiệt phải được cố định để đảm bảo rằng nó vẫn phải ở đúng vị trí.


## Lắp đặt dây dẫn cho sợi dây đo nhiệt

Cần thực hiện mọi nỗ lực bất cứ khi nào có thể để đảm bảo rằng dây dẫn từ đầu nóng đi theo một đường để đến đầu lạnh mà không để nó tiếp xúc với nhiệt độ vượt quá nhiệt độ ở đầu nóng. Các dây dẫn phải được luồn ra sau vật liệu chống cháy và ra khỏi lò mà không đi qua môi trường lò.

Có thể cần thiết phải bảo vệ các sợi dây đo nhiệt bằng cách sử dụng các thanh thép C hoặc ống dẫn trước khi phủ lớp vật liệu bảo vệ. Nó được lắp đặt từ thanh thép nhẹ và được hàn điểm vào góc của bản bụng và bản cánh.

Nên xác định rằng đặc tính nhiệt độ công bố của vật liệu cách nhiệt của đầu đo nhiệt có liên quan đến đầu đo nhiệt ở trong môi trường mà các dây dẫn không được dịch chuyển hoặc có các biến dạng khác

Có thể các dây đo nhiệt sẽ cần được đỡ để đảm bảo rằng phá hoại của vật liệu cách nhiệt không xảy ra.

## Kết nối đầu đo nhiệt

Không được có mối nối giữa các dây đo nhiệt và bất kỳ phần mở rộng hoặc cáp nối dài trong bất kỳ khu vực có nhiệt độ cao.
Dây dẫn bù phải là loại phù hợp với dây dẫn nhiệt.

## Hỏng đầu đo nhiệt

Các hư hỏng của đầu đo nhiệt không dễ dàng xác định được. Hỏng do đứt dây hoặc do hỏng lớp cách nhiệt giữa các dây, do đó làm chập mối nối nóng.
Tuy nhiên các dấu hiệu hỏng rõ ràng là:

  * Sự giảm đột ngột của nhiệt độ được chỉ định so với nhiệt độ đã ghi trước đó.

  * Sự gia tăng đột ngột nhiệt độ được chỉ định đến một giá trị đại diện cho phạm vi tối đa của thiết bị đo được

  * Nhiệt độ hiển thị “thay đổi và biến động” không phù hợp với các giá trị dự báo.


Một dấu hiệu phổ biến của hỏng lớp cách nhiệt mà có thể quan sát được là giá trị nhiệt độ hiển thị không phù hợp với nhiệt độ lò thử nghiệm.

# Phương pháp thử nghiệm đối với lửa âm ỉ (đường cong nhiệt chậm)

## Giới thiệu

Các sản phẩm bảo vệ chịu lửa được hoạt động bởi thông lượng nhiệt của đám cháy có thể được yêu cầu thử nghiệm đối với đường cong âm ỉ (đường cong nhiệt chậm được định nghĩa trong ISO 834-2), với tốc độ tăng nhiệt độ nhỏ hơn tốc độ của đường cong nhiệt độ / thời gian tiêu chuẩn.

Sự tiếp xúc với lửa này, áp dụng cho các vật liệu chống cháy phản ứng, chỉ được sử dụng trong những trường hợp đặc biệt, khi có thể dự kiến rằng công năng của sản phẩm khi tiếp xúc với lửa âm ỉ kém hơn đáng kể so với khi nó được tiếp xúc với đường cong nhiệt độ / thời gian tiêu chuẩn và khi thí nghiệm này được quy định trong các quy chuẩn xây dựng quốc gia.

Quy định này không phải là bắt buộc đối với tất cả các vật liệu chống cháy áp dụng cho các cấu kiện thép kết cấu.

## Trang thiết bị thử nghiệm

Lò đốt và các thiết bị thử nghiệm nên được lựa chọn để các mẫu thử nghiệm tiếp xúc với sự gia nhiệt theo quy định trong F.5

Đường cong âm ỉ (đường cong nhiệt chậm) phải như quy định trong ISO 834-2, được cung cấp một chế độ gia nhiệt trong đó trong khoảng thời gian t = 0 phút đến 20 phút, nhiệt độ lò (T) tuân theo mối quan hệ:


| T 1544 | t | 20 | (F.1) |
| --- | --- | --- | --- |

 

![](images/image1.png)

Sau t = 20 phút và trong khoảng thời gian còn lại của thử nghiệm, nhiệt độ lò thử nghiệm (T) tuân theo mối quan hệ nhiệt độ - thời gian

# Public_021

# Mở đầu

Gần đây khi có dịp nói chuyện về xử lý ngôn ngữ (XLNN) và xử lý tiếng Việt (XLTV) trong công nghệ thông tin (CNTT) với một số nhà quản lý khoa học và công nghệ hoặc một số đồng nghiệp, chúng tôi thấy có sự khác nhau giữa nhiều người về cách hiểu một số khái niệm cũng như giữa những nhìn nhận về tình hình nghiên cứu-phát triển trong lĩnh vực này. Điều này cũng tự nhiên, tự nhiên như hầu hết chúng ta không thật rõ về bệnh tim, hay không rõ protein được tổng hợp ra như thế nào. Khi chuẩn bị dự án về xử lý tiếng Việt, chúng tôi bỗng thấy cần giải thích cho nhiều người không làm chuyên môn về xử lý ngôn ngữ rõ hơn về các câu chuyện của lĩnh vực này. Và thay vì viết ngay đề cương, chúng tôi bắt đầu các việc của dự án bằng bài viết này.

# Những khái niệm cơ bản

Tiếng nói và chữ viết là hai yếu tố cơ bản nhất của bất kỳ ngôn ngữ nào. Trong sự phát triển của công nghệ thông tin (CNTT) ở Việt Nam, một số việc liên quan đến “tiếng Việt” đã được làm và ít nhiều có kết quả ban đầu:

  * Trước hết là các _bộ gõ chữ Việt_ và thành công của việc đưa được _bộ mã chữ Việt_ vào bảng mã Unicode, cũng như việc chọn Unicode cho bộ mã chuẩn tiếng Việt (nhân đây cũng xin nói thêm, do chưa ý thức về chuẩn, rất nhiều cán bộ CNTT, nhiều cơ quan nhà nước vẫn chưa chịu đổi thói quen cũ để dùng bộ mã chuẩn Unicode, một việc rất quan trọng của xử lý tiếng Việt). Bảo tồn chữ Nôm trên máy tính cũng là một việc đầy nỗ lực và nhiều ý nghĩa được nhiều người theo đuổi lâu nay, cần được nhà nước tiếp tục ủng hộ lâu dài ( _http://nomfoundation.org_ ).

  * Tiếp theo có thể kể đến các chương trình _nhận dạng chữ Việt in_ (OCR: optical character recognition), như hệ VnDOCR của Viện Công nghệ Thông tin, Viện Khoa học và Công nghệ Việt Nam. Các chương trình nhận dạng chữ in nhằm _chuyển_ các tài liệu in trên giấy thành các tài liệu điện tử (dưới dạng các tệp văn bản trên máy tính).

  * Các _phần mềm hỗ trợ việc sử dụng_ tiếng nước ngoài, tiêu biểu là các từ điển song ngữ trên máy tính, thí dụ như các từ điển điện tử của Lạc Việt đã được dùng rộng rãi trên máy tính để tra cứu từ Anh-Việt, Việt-Anh. Điều ta cần phân biệt là các từ điển điện tử này dành cho con người sử dụng, khác với từ điển điện tử dành cho máy tính sử dụng trong xử lý ngôn ngữ tự nhiên (sẽ được đề cập ở phần sau).

  * Các nỗ lực trong việc làm các _phần mềm dịch Anh-Việt,Việt-Anh_ , chẳng hạn như các hệ dịch EVTRAN và VETRAN.

  * Một loại việc nữa là _Việt hóa các phần mềm_ mà gần đây tiêu biểu là kết quả Việt hóa Windows và Microsoft Office của Microsoft. Việc này có thể xem như việc “dịch” các thông báo tiếng Anh _cố định_ trong các phần mềm thành các thông báo tiếng Việt.

  * Tuy liên quan đến tiếng Việt, không phải tất cả các việc kể trên đều thuộc về lĩnh vực xử lý ngôn ngữ tự nhiên nói chung và xử lý tiếng Việt nói riêng theo nghĩa thông thường trong CNTT, vốn chủ yếu nhằm vào những vấn đề liên quan đến xử lý văn bản (text) và tiếng nói (speech) [Jurafsky and Martin, 2000].


Để làm sáng tỏ điều này ta thử xem xét lại khái niệm “xử lý thông tin”, một khái niệm cốt lõi của công nghệ thông tin và là khái niệm rộng hơn “xử lý ngôn ngữ”. Về bản chất, _xử lý thông tin là quá trình biến đổi dữ liệu từ dạng này thành dạng khác để có thể thu được thông tin và tri thức_. Trong giai đoạn đầu, CNTT tập trung vào các dữ liệu dạng số, biểu diễn bởi các dạng được cấu trúc (structured) như các vectơ (vector) hay bảng biểu (tables). Trong hơn nửa thế kỷ phát triển, CNTT dần dần “xử lý” nhiều kiểu dữ liệu khác, như hình ảnh (image), âm thanh (voice, speech), văn bản (text), kí hiệu hình thức (symbols), đồ thị (graph),… và gần đây là nhiều kiểu dữ liệu phức tạp như dữ liệu sinh học (genomic data). Phương pháp xử lý cũng ngày càng phong phú, từ tính toán (computing) đến suy luận (reasoning), và nhiều kiểu khác nữa. _Xử lý ngôn ngữ_ chính là xử lý thông tin khi đầu vào là “dữ liệu ngôn ngữ” (dữ liệu cần biến đổi), tức dữ liệu “văn bản” hay “tiếng nói”.

Các dữ liệu liên quan đến ngôn ngữ viết (văn bản) và nói (tiếng nói) đang dần trở nên kiểu dữ liệu chính con người có và lưu trữ dưới dạng điện tử. Đặc điểm chính của các kiểu dữ liệu này là không có cấu trúc hoặc nửa cấu trúc (non-structured hoặc semi-structured) và chúng không thể lưu trữ trong các khuôn dạng cố định như các bảng biểu. Theo đánh giá của công ty Oracle, hiện có đến 80% dữ liệu không cấu trúc trong lượng dữ liệu của loài người đang có [Oracle Text]. Với sự ra đời và phổ biến của Internet, của sách báo điện tử, của máy tính cá nhân, của viễn thông, của thiết bị âm thanh, … người người ai cũng có thể tạo ra dữ liệu văn bản hay tiếng nói. Vấn đề là làm sao ta có thể xử lý chúng, tức chuyển chúng từ các dạng ta chưa hiểu được thành

các dạng ta có thể hiểu và giải thích được, tức là ta có thể tìm ra thông tin, tri thức hữu ích cho mình.

Giả sử chúng ta có các câu sau trong các tiếng nước ngoài:

  * “We meet here today to talk about Vietnamese language and speech processing.”

  * “Aujourd'hui nous nous réunissons ici pour discuter le traitement de langue et de parole vietnamienne.”

  * “Mы встрачаемся здесь сегодня, чтобы говорить о вьетнамском языке и обработке речи.”

  * “今日我々はここに集まりベトナム語処理について議論します.”

  * “오늘 우리는 여기에 모여서 베트남어와 발언처리에 대하여 의론하겠습니다.”


Và giả sử chúng ta không ai biết cả năm thứ tiếng trên, nhưng tò mò muốn biết các câu đó nói gì. Nếu có ai đó dịch, hoặc có một chương trình máy tính dịch (biến đổi) chúng ra tiếng Việt, ta sẽ hiểu nghĩa các câu trên đều là:

  * “Hôm nay chúng ta gặp nhau ở đây để bàn về xử lý ngôn ngữ và tiếng nói tiếng Việt.”


Nếu các câu này được lưu trữ như các tệp tiếng Anh, Pháp, Nga, Nhật, Hàn và Việt như ta nhìn thấy ở trên, ta có các dữ liệu “văn bản”. Nếu ai đó đọc các câu này, ghi âm lại, ta có thể chuyển chúng vào máy tính dưới dạng các tệp các tín hiệu (signal) “tiếng nói”. Tín hiệu sóng âm của hai âm tiết tiếng Việt có thể nhìn thấy như sau

![](images/image1.jpeg)

Tuy nhiên, một văn bản thật sự (một bài báo khoa học chẳng hạn) có thể có đến hàng nghìn câu, và ta không phải có một mà hàng triệu văn bản. Web là một nguồn dữ liệu văn bản khổng lồ, và cùng với các thư viện điện tử − khi trong một tương gần các sách báo xưa nay và các nguồn âm thanh được chuyển hết vào máy tính (chẳng hạn bằng các chương trình nhận dạng chữ, thu nhập âm thanh, hoặc gõ thẳng vào máy) − sẽ sớm chứa hầu như toàn bộ kiến thức của nhân loại. Vấn đề là làm sao “xử lý” (chuyển đổi) được khối dữ liệu văn bản và tiếng nói khổng lồ này qua dạng khác để mỗi người có được thông tin và tri thức cần thiết từ chúng? Điều này càng quan trọng khi đa số nguồn tri thức quý giá này lại bằng tiếng nước ngoài và đa số người Việt chúng ta còn ít nghe hay đọc được chúng.

Có thể hình dung phần mềm gõ chữ Việt cho phép ta trực tiếp tạo ra một tệp văn bản trên máy tính (như chúng tôi đang gõ máy tính để viết bài này), còn chương trình nhận dạng chữ VnDOCR cho phép ta biến đổi một văn bản in trên giấy thành một tệp văn bản trên máy tính. Tuy nhiên, các sản phẩm trên vẫn chưa động chạm đến cốt lõi của xử lý ngôn ngữ. Theo nghĩa “xử lý ngôn ngữ” nêu ở trên − tức biến đổi dữ liệu ngôn ngữ − có thể nêu ra một số bài toán tiêu biểu của xử lý ngôn ngữ với các mức độ khác nhau về xử lý và sử dụng ngôn ngữ tự nhiên của con người:

  * _Nhận dạng tiếng nói (speech recognition)_ : từ sóng tiếng nói, nhận biết và chuyển chúng thành dữ liệu văn bản tương ứng [Jelinek, 1998], [Jurafsky and Martin, 2000].

  * _Tổng hợp tiếng nói (speech synthesis):_ từ dữ liệu văn bản, phân tích và chuyển thành tiếng người nói [Jelinek, 1998], [Jurafsky and Martin, 2000].

  * _Nhận dạng chữ viết (optical character recognition, OCR):_ từ một văn bản in trên giấy, nhận biết từng chữ cái và chuyển chúng thành một tệp văn bản trên máy tính.

  * _Dịch tự động (machine translation)_ : từ một tệp dữ liệu văn bản trong một ngôn ngữ (tiếng Anh chẳng hạn), máy tính dịch và chuyển thành một tệp văn bản trong một ngôn ngữ khác (tiếng Việt chẳng hạn) [Dorr et al., 2000], [Nagao, 1989].

  * _Tóm tắt văn bản (text summarization):_ từ một văn bản dài (mười trang chẳng hạn) máy tóm tắt thành một văn bản ngắn hơn (một trang) với những nội dung cơ bản [Mani and Maybury, 1999]

  * _Tìm kiếm thông tin (information retrieval)_ : từ một nguồn rất nhiều tệp văn bản hay tiếng nói, tìm ra những tệp có nội dung liên quan đến một vấn đề (câu hỏi) ta cần biết (hay trả lời) [Baeza-Yates and Ribeiro-Neto, 1999].. Điển hình của công nghệ này là _Google_ , một hệ tìm kiếm thông tin trên Web, mà hầu như chúng ta đều dùng thường xuyên. Cần nói thêm rằng mặc dù hữu hiệu hàng đầu như vậy, Google mới có khả năng cho chúng ta tìm kiếm câu hỏi dưới dạng các từ khóa (keywords) và luôn “tìm” cho chúng ta rất nhiều tài liệu không liên quan, cũng như rất nhiều tài liệu liên quan đã tồn tại thì Google lại tìm không ra. Hình bên chỉ ra một màn

  * hình của Google đưa ra các trang Web liên quan đến câu hỏi “protein-protein interaction”


  * _Trích chọn thông tin (information extraction)_ : từ một nguồn rất nhiều tệp văn bản hay tiếng nói, tìm ra những _đoạn bên trong_ một số tệp liên quan đến một vấn đề (câu hỏi) ta cần biết hay trả lời. Hình bên phải minh họa một kết quả trích chọn thông tin với

  * cùng câu hỏi “protein-protein interaction”. Một hệ trích chọn thông tin có thể “lần” vào từng trang Web liên quan, phân tích bên trong và trích ra các thông tin cần thiết, nói gọn trong tiếng Anh để phân biệt với tìm kiếm thông tin là “find things but not pages” [Cohen and McCallum, 2003].

  * _Phát hiện tri thức và khai phá dữ liệu văn bảm (knowledge discovery and text data mining)_ : Từ những nguồn rất nhiều văn bản thậm chí hầu như không có quan hệ với nhau, tìm ra được những tri thức trước đấy chưa ai biết. Đây là một vấn đề rất phức tạp và đang ở giai đoạn đầu của các nghiên cứu trên thế giới [Berry, 2004], [Sirmakessis, 2004].


Còn nhiều bài toán và công nghệ xử lý ngôn ngữ khác, như giao diện người máy bằng ngôn ngữ tự nhiên, các hệ hỏi đáp, các hệ sinh ra ngôn ngữ, …

Ứng dụng của công nghệ xử lý ngôn ngữ hết sức phong phú. Có thể lấy vài thí dụ gần đây. Tin trên Internet ngày 21/4/2005, hãng Samsung đưa ra thị trường điện thoại di động P207 có thể nhận biết được các câu nói đơn giản của người sử dụng điện thoại di động như “Hãy gọi cho tôi” hay “Tôi sẽ gọi lại”, rồi chuyển chúng thành dạng văn bản (tin nhắn) cho người dùng điện thoại di động gửi nhắn tin. Đây là một ứng dụng của QuickPhrase trong VoiceSignal Technologies, tất nhiên là cho tiếng Hàn. Ta có thể hình dung đây là việc ghi lại tín hiệu một câu nói đơn giản, so sánh tín hiệu này với tín hiệu của một rất nhiều câu nói đã được ghi trước rồi chọn câu gần nhất ( _http://www.vnexpress.net/Vietnam/Vi-tinh/San-pham-moi/2005/04/ 3B9D D713/_ ). Tin ngày 22/4/2005 ( _http://www2.tuoitre.com.vn/Tianyon/Index.aspx?ArticleID=75496 &ChannelID=17_) cho biết công ty CombiWith (Nhật) công bố sắp tung ra các bức ảnh biết nói để cho những người cô đơn ở Nhật có thể có ảnh của người thân biết nói với chính giọng của họ. Có thể hình dung đây chính là việc tổng hợp tiếng nói của người trong ảnh dựa trên việc học giọng nói từ rất nhiều mẫu câu nói của người đó. Tất nhiên, đây lại là tiếng Nhật vì công nghệ cho tiếng Việt sẽ rất khác. Cũng vậy, có rất nhiều phần mềm dịch tự động trên Web, như Babel Fish Translation của AltaVista ( _http://babelfish.altavista.com/_ ), dịch Anh-Nhật, Nhật-Anh bởi Excite bản tiếng Nhật

( _http://www.excite.co.jp/world/english/_ ), hay Language Tools dịch nhiều thứ tiếng của Google ( _http://www.google.com/language_tools?hl=en_ ).

Có thể phân loại các bài toán:

  * 1-3 thuộc lĩnh vực _xử lý tiếng nói và xử lý ảnh_ (speech and image processing),

  * 4-5 thuộc lĩnh vực _xử lý văn bản_ (text processing),

  * 6-8 thuộc lĩnh vực _khai phá văn bản và Web_ (text and Web mining).


Phân loại này là tương đối, vì các lĩnh vực trên có rất nhiều phần chung nhau. Về bản chất, xử lý tiếng nói dựa hay ảnh trên các kỹ thuật _phân tích và nhận dạng tín hiệu_ (signal processing and recognition). Xử lý văn bản cũng như khai phá văn bản và Web lại dựa trên các kỹ thuật của _xử lý ngôn ngữ tự nhiên_ (natural language processing hay computational linguistics) mà quan trọng là việc _hiểu_ (understanding) và _dùng tri thức về ngôn ngữ_ ở các mức độ khác nhau [Jurafsky and Martin, 2000]. Nếu các bài toán 1-5 có đối tượng xử lý là _một tệp_ văn bản hay tiếng nói, thì các bài toán 6-8 có đối tượng xử lý là một tập hợp _rất nhiều tệp_ văn bản hay tiếng nói. Cần nhấn mạnh thêm là do sự phát triển của Internet, việc tìm kiếm và trích chọn thông tin, phát hiện tri thức từ các cơ sở dữ liệu lớn là các nội dung thời sự và xu thế của phát triển CNTT trên thế giới [Berry, 2004], [Chakrabarti, 2003], [Cole et al., 1997], [Sirmakessis, 2004].

Các bài toán 1-3, 5-8 liên quan việc “xử lý” _một ngôn ngữ_ , trong khi (g) “xử lý” _hai ngôn ngữ khác nhau_. Khi đầu vào hay đầu ra của các bài toán 1-8 là tiếng Việt, ta có các vấn đề của __xử lý tiếng Việt__.

# Về sự phát triển của xử lý ngôn ngữ và tiếng nói trong CNTT

Có thể nói xử lý ngôn ngữ tự động trên máy tính là một trong những vấn đề khó nhất của CNTT. Cái khó nằm ở chỗ làm sao cho máy được hiểu ngôn ngữ con người, từ việc hiểu nghĩa từng từ trong mỗi hoàn cảnh cụ thể, đến việc hiểu nghĩa một câu, rồi hiểu cả văn bản. Ta lấy lại thí dụ của Marvin Minsky (1992), một cây đa cây đề của ngành trí tuệ nhân tạo (artificial intelligence): “Xét từ “sợi dây” chẳng hạn. Ngày nay không một máy tính nào có thể hiểu nghĩa từ này như con người. Còn chúng ta ai cũng biết có thể dùng sợi dây để kéo một vật, nhưng không thể đẩy một vật bằng sợi dây này. Ta có thể gói một gói hàng hoặc thả diều bằng một sợi dây, nhưng không thể ăn sợi dây. Trong vài phút, một đứa trẻ nhỏ có thể chỉ ra hàng trăm cách dùng hoặc không dùng một sợi dây, nhưng không máy tính nào có thể làm việc này.”

Mấu chốt ở đây là bản chất phức tạp của ngôn ngữ của con người, đặc biệt là sự đa nghĩa và nhập nhằng nghĩa của ngôn ngữ. Thêm nữa, có một khác biệt sâu sắc nữa là con người ngầm hiểu và dùng quá nhiều _lẽ thường_ (common sense) trong ngôn ngữ, như biết “lửa” thì nóng còn “chim” thì biết bay, hay sợi dây thì không dùng để đẩy hay khều các vật, trong khi rất khó làm cho máy hiểu các lẽ thường này.

_Công nghệ ngôn ngữ_ , nhất là xử lý văn bản, về đại thể bao gồm các bước (tầng, layer) cơ bản sau đây [Allen, 1994], [Jurafsky and Martin, 2000]:

  * _Tầng ngữ âm (phonetic and phonological layer)_ : Nghiên cứu về ngữ âm (linguistic sounds), như mô hình hóa việc các từ trong cách nói thông thường được phát âm thế nào, về bản chất thanh điệu, ngôn điệu, ngữ điệu (prosody, intonation), trường độ âm tiết, độ nhấn, biến thanh, …

  * _Tầng hình thái (morphological layer):_ Nghiên cứu về các thành phần có nghĩa của từ (word), như từ được tạo ra bởi các hình vị (morphemes) và từ được tách ra trong một câu thế nào. Thí dụ, từ “tiếng Việt” tạo thành từ “t-iế-ng V-iệ-t”, còn ngữ (phrase) “xử lý tiếng Việt” tạo thành gồm hai từ “xử lý” và “tiếng Việt”. Trong tiếng Việt, một bài toán quan trọng là phân tách từ (word segmentation). Một thí dụ quen thuộc là câu “Ông già đi nhanh quá” có thể phân tách thành (Ông già) (đi) (nhanh quá) hoặc (Ông) (già đi) (nhanh quá) hoặc những cách khác nữa.

  * _Tầng ngữ pháp (morphological layer **)** :_ Nghiên cứu các quan hệ cấu trúc giữa các từ, xem các từ đi với nhau thế nào để tạo ra câu đúng. Quá trình này thường được cụ thể trong các bước cơ bản sau:

* _Xác định từ loại_ (POS tagging): Xem mỗi từ trong câu là loại gì (danh từ, động từ, giới từ, …). Trong thí dụ trên, có thể “Ông già” là danh từ, “đi” là động từ, “nhanh” là trạng từ, và “quá” là thán từ.

* _Xác định cụm từ_ (chunking): Thí dụ “Ông già” là cụm danh từ, “đi” là cụm động từ, “nhanh quá” là cụm trạng từ. Như vậy câu trên có hai phân tích (Ông già) (đi) (nhanh quá) hoặc (Ông) (già đi) (nhanh quá).

* _Xác định quan hệ ngữ pháp_ (parsing): (Ông già) (đi) (nhanh quá) là quan hệ chủ ngữ-vị ngữ-trạng ngữ.

  * _Tầng ngữ nghĩa (semantic layer_ ): Nghiên cứu xác định nghĩa của từng từ và tổ hợp của chúng để tạo nghĩa của câu. Thí dụ trong phân tích (Ông già) (đi) (nhanh quá), động từ “đi” có thể có nghĩa “bước đi”, hay “chết” hay “điều khiển” (khi đánh cờ), … và tương ứng ta có các nghĩa khác nhau của câu.

  * _Tầng ngữ dụng (pragmatic layer):_ Nghiên cứu mối quan hệ giữa ngôn ngữ và ngữ cảnh xử dụng ngôn ngữ (context-of-use). Ngữ dụng như vậy nghiên cứu việc ngôn ngữ được dùng để nói về người và vật như thế nào.


Việc phân tích một câu nói hay một câu trong văn bản ở các tầng từ ngữ âm (1) đến tầng ngữ pháp (3) gọi là _phân tích sơ bộ_ (shallow parsing). Nếu phân tích thêm cả tầng ngữ nghĩa (từ (1) đến (4)) ta sẽ có _phân tích đầy đủ_ (fully parsing). Trong các vấn đề của xử lí ngôn ngữ, có vấn đề cần đến phân tích đầy đủ (như dịch tự động), nhưng cũng có những vấn đề chỉ với phân tích sơ bộ cũng có thể đã xử lí được (như tìm kiếm thông tin, phân tích văn bản cho tổng hợp tiếng nói, mô hình ngôn ngữ trong nhận dạng tiếng nói…).

_Nhận dạng tiếng nói_ là một quá trình nhận dạng mẫu, với các mẫu là các đơn vị nhận dạng, có thể là các từ hoặc các âm vị. Khó khăn cơ bản của bài toán này là tiếng nói luôn biến thiên theo thời gian và có sự khác biệt lớn giữa tiếng nói của những người nói khác nhau, tốc độ nói, ngữ cảnh và môi trường âm học khác nhau. Các nghiên cứu về nhận dạng tiếng nói dựa trên _ba nguyên tắc cơ bản_ :

  * Tín hiệu tiếng nói được biểu diễn chính xác bởi các giá trị phổ trong một khung thời gian ngắn (short-term amplitude spectrum). Nhờ vậy ta có thể trích ra các đặc điểm tiếng nói từ những khoảng thời gian ngắn và dùng các đặc điểm này làm dữ liệu để nhận dạng tiếng nói.

  * Nội dung của tiếng nói được biểu diễn dưới dạng chữ viết, là một dãy các ký hiệu ngữ âm. Do đó ý nghĩa của một phát âm được bảo toàn khi chúng ta phiên âm phát âm thành dãy các ký hiệu ngữ âm.

  * Nhận dạng tiếng nói là một quá trình nhận thức. Ngôn ngữ nói có nghĩa, do đó thông tin về ngữ nghĩa (semantics) và ngữ dụng (pragmatics) có giá trị trong quá trình nhận dạng tiếng nói, đặc biệt khi thông tin về âm học là không rõ ràng.


Lĩnh vực nghiên cứu của nhận dạng tiếng nói là khá rộng liên quan đến nhiều ngành khác nhau, như xử lý tín hiệu số (digital signal proccessing), vật lý hay âm học (acoustic), nhận dạng mẫu, lý thuyết thông tin và khoa học máy tính (information and computer science theory), ngôn ngữ học (linguistics), sinh lý học (physiology), tâm lý học ứng dụng (applied psychology). Các hệ thống nhận dạng tiếng nói có thể được phân chia thành hai loại khác nhau: hệ thống _nhận dạng từ rời rạc_ và hệ thống _nhận dạng từ liên tục_. Trong hệ thống nhận dạng tiếng nói liên tục, người ta lại phân biệt hệ thống nhận dạng có kích thước từ điển nhỏ và hệ thống nhận dạng với kích thước từ điển trung bình hoặc lớn.

_Tổng hợp tiếng nói_ (text-to-speech, TTS) có mục tiêu ngược với mục tiêu của nhận dạng tiếng nói. Kiến trúc của một hệ thống TTS giống như kiến trúc đọc chữ của con người, bao gồm một _môđun xử lý ngôn ngữ tự nhiên_ (bộ tiền xử lý nhằm tổ chức các câu thành danh sách, bộ phân tích hình thái, bộ phân tích ngữ cảnh, bộ phân tích câu cú pháp, ngôn điệu, …), có khả năng sinh ra phiên âm phù hợp với cách phát âm của quá trình đọc văn bản cùng với ngữ điệu, ngôn điệu; và một _môđun xử lý tín hiệu số_ , môđun này chuyển thông tin tượng trưng nhận được thành tiếng nói (môđun letter-to-sound và môđun sinh ra ngôn điệu). Khi hai khối xử lý ngôn ngữ tự nhiên và xử lý tín hiệu số được định nghĩa rõ ràng, việc nghiên cứu về hai quá trình có thể được thực hiện riêng rẽ, độc lập với nhau. Khối xử lý tín hiệu số phải xét đến các hạn chế phát âm, vì sự biến đổi ngữ âm (phần động, chuyển tiếp giữa các âm) là quan trọng đối với việc hiểu lời nói hơn là các phần tĩnh của lời nói. Tổng hợp tiếng nói có thể đạt được cơ bản theo hai phương pháp thuộc về hai trường phái tổng hợp tiếng nói có nội dung và mục tiêu khác nhau:

  * Phương pháp thứ nhất được thực hiện dưới dạng các quy tắc mô tả âm vị, ảnh hưởng lẫn nhau giữa các âm vị khi phát ra một âm (tổng hợp bằng qui luật).

  * Phương pháp thứ hai lưu giữ những đơn vị âm cơ bản, biến đổi đơn vị âm cơ bản và đồng thời tạo ra cơ sở dữ liệu tiếng nói, sử dụng chúng như là các đơn vị âm học cơ bản để tạo thành lời nói (phương pháp tổng hợp theo xích chuỗi).


Trong khi xử lý tiếng Việt còn đang chập chững những bước đi đầu, các nghiên cứu và ứng dụng về xử lý ngôn ngữ nói chung trên thế giới và nhiều nước khác đã có một lịch sử hơn nửa thế kỷ, đã trải qua nhiều giai đoạn, và điều quan trọng hơn cả là nhiều con đường và cách thức xử lí ngôn ngữ đã được trải nghiệm và thừa nhận. Lịch sử xử lý ngôn ngữ có thể được chia ra các giai đoạn như sau [Jurafsky and Martin, 2000]:

**Các lý thuyết nền tảng được xây dựng trong các năm 1940 và 1950** : Hai kiểu mô hình nền tảng của giai đoạn này có ảnh hưởng sâu sắc đến xử lý ngôn ngữ là mô hình các máy tự động (automaton) và các mô hình của lý thuyết thông tin hay xác suất: Máy tính điện tử bắt nguồn từ các mô hình máy Turing (1936), lý thuyết ngôn ngữ hình thức, mã hóa, entropy, …

**Hai nhánh tách rời nhau từ cuối các năm 1950 đến đầu năm 1970** : Hai kiểu xử lý khác biệt nhau rõ rệt: (a) kiểu hình thức (symbolic paradigm) cho văn bản như lý thuyết ngôn ngữ hình thức của Chomsky và trí tuệ nhân tạo, và (b) kiểu ngẫu nhiên (stochastic paradigm) cho tiếng nói như các phương pháp Bayes.

**Bốn kiểu xử lý ngôn ngữ phổ biến trong thập kỷ 70 đến giữa thập kỷ 80** :

  * các _mô hình ngẫu nhiên_ đóng một vai trò lớn, tiêu biểu là các mô hình Markov ẩn (HMM, Hidden Markov Model) trong xử lý tiếng nói;

  * _kiểu dựa trên logic_ (logic-based paradigm);

  * _hiểu ngôn ngữ tự nhiên_ (natural language understanding);

  * _mô hình hóa các cuộc đối thoại liên tục_ (discourse modeling).


Cũng trong thời gian này xuất hiện các bài toán và tài nguyên chuẩn (Penn Treebank, WordNet, MUC, etc.).

**Chủ nghĩa kinh nghiệm và các mô hình hữu hạn trạng thái từ giữa thập kỷ 80 đến giữa thập kỷ 90:** Ở giai đoạn này đã có thể huấn luyện các mô hình hữu hạn trạng thái ra đời trong thập kỷ 60. Các mô hình xác suất và tiếp cận dựa vào dữ liệu (data-driven approach) xuất hiện trong hầu hết các nhiệm vụ của xử lý ngôn ngữ [Manning and Schutze, 1999], [Jelinek, 1998].

**Xử lý văn bản và tiếng nói gặp nhau trong mười năm qua** : Đây là giai đoạn tiến bộ vượt bậc với mô hình thống kê và tiếp cận dựa vào dữ liệu, với việc tăng trưởng nhanh chóng của tốc độ và bộ nhớ máy tính, của các ứng dụng dựa trên Web [Jurafsky and Martin, 2000]. Công nghệ xử lý tiếng nói không thể chỉ dựa trên các kỹ thuật xử lý tín hiệu, mà còn phải dựa cả trên việc hiểu ngôn ngữ. Do tham số của các mô hình thống kê hoặc các mô hình hữu hạn trạng thái đã có thể huấn luyện được từ các kho ngữ liệu lớn, nhiều mô hình kiểu này tiếp tục ra đời và được ứng dụng rộng rãi như Maximum Entropy (MaxEnt), Maximum Entropy Markov Model (MEMM), Conditional Random Fields (CRF), … [Cohen and McCallum, 2003]

Như đã trình bày sơ bộ ở trên, xử lí ngôn ngữ là một việc khó, phức tạp, chỉ có thể làm lâu dài theo nhiều bước tuần tự, chỉ có thể đạt được kết quả bước sau khi bước trước đã có kết quả. Chẳng hạn như các chương trình dịch tự động trên thế giới đã được theo đuổi hàng chục năm và chặng đường đến đích cuối vẫn còn rất xa. Nếu chúng ta muốn làm dịch tự động Anh-Việt, bắt buộc chúng ta đi qua các tầng của xử lý ngôn ngữ kể trên, và nói chung không thể hy vọng thời gian sẽ ngắn hơn nhiều so với người đi trước [Dorr et al., 2000].

Trên thế giới, nhiều tổ chức quốc tế, nhiều hiệp hội xử lí ngôn ngữ tự nhiên đã được thành lập với các hoạt động phong phú hàng năm, với lực lượng nghiên cứu đông đảo: ACL (Association Computational Linguistics), NAACL (North American Association on Computational Linguistics), EACL (Euro Association on Computational Linguistics), PACLIC (Pacific Association on Computational Linguistics), ICCL (International committee Computational Linguistics). Rất đáng chú ý là nhiều nguồn tài nguyên, ngữ liệu phong phú được tạo ra, được chia sẻ dù đôi khi dưới dạng thương mại nhưng với giá cả hợp lí, tiêu biểu là LDC (Linguistic Data Consortium, _http://ww.ldc.upenn.edu_ ).

Nhiều chính phủ đã đầu tư lớn cho xử lý ngôn ngữ trong CNTT (Mỹ, Nhật bản, Trung quốc, Singapore, etc.). Hãy thử nhìn đến các nước quanh Việt Nam. Ở Trung quốc, nghiên cứu về xử lý ngôn ngữ có từ lâu và hiện đang rất phát triển với sự đầu tư mạnh mẽ từ chính phủ. Họ đã làm ra nhiều công cụ, tài nguyên phong phú, như Wordnet cho tiếng Trung quốc, các hệ dịch giữa tiếng Trung quốc và qua tiếng một số nước, các ngân hàng ngữ liệu cho phân tích cú pháp như Chinese Bank. Ngay với nước láng giềng Thailand, xử lý ngôn ngữ Thái đã là phần được đầu tư lớn của chính phủ tại National Electronics and Computer Technology Center (NECTEC), National research council of Thailand (NRCT), Thai Research Foundation (TRF) với những kết quả ban đầu về dịch máy, về POS tagging. Thailand đã có các phòng thí nghiệm lớn nghiên cứu về NLP, Thai Computational Linguistics Laboratories ( _http://www.tcllab.org_ ).

Là người đi sau trong lĩnh vực xử lí ngôn ngữ, việc hiểu các công nghệ ngôn ngữ, các xu thế công nghệ, các nguồn ngữ liệu, kinh nghiệm và bài học từ các nước khác trong lĩnh vực này là hết sức quan trọng. _Biết, học và khai thác được chúng sẽ giúp ta cân nhắc chọn được đường đi hợp lí trong xử lý tiếng Việt_.

# Tình hình và những vấn đề chính trong xử lý tiếng Việt

Hãy thử nhìn lại tình hình của chúng ta. Ngoài những việc đã làm và bước đầu làm được kể ở phần đầu, đã có những cố gắng trong nhiều nội dung khác nhau về xử lý ngôn ngữ và tiếng Việt. Trong các bài giảng về Trí tuệ Nhân tạo, về Lý thuyết Nhận dạng, về Xử lý Tín hiệu, về Khai phá Dữ liệu ở nhiều đại học, các nội dung và kỹ thuật xử lý ngôn ngữ đã ít nhiều được đề cập. Về xử lý tiếng nói và tiếng Việt, theo chúng tôi biết, hai tập thể làm nghiên cứu đã có những kết quả gần đây là Viện Công nghệ Thông tin và Trung tâm nghiên cứu quốc tế Thông tin đa phương tiện, truyền thông và ứng dụng (MICA) – Đại học Bách khoa Hà nội; một số kết quả ở một số trường Đại học là những đề tài tiến sĩ, thạc sĩ, mang tính chất tìm hiểu, chưa hệ thống và định hướng rõ ràng. Nghiên cứu về xử lý ngôn ngữ (văn bản) đã được theo đuổi bởi một số tập thể từ khá lâu (Đại học Bách khoa và Đại học Khoa học Tự nhiên thành phố Hồ Chí Minh, Đại học Bách Khoa Đà Nẵng, Đại học Bách khoa và Đại học Khoa học Tự nhiên Hà Nội, Trường Đại học Công nghệ, Viện Ứng dụng Công nghệ, Viện Công nghệ Thông tin, công ty Lạc Việt,…) về các vấn đề dịch máy, các bài toán cơ bản của xử lý tiếng Việt [Dien et al., 2001; Dien, 2003], [Huyen et al., 2003], và gần đây là tóm tắt văn bản [Minh, 2004; Minh et al., 2004], [Huong, 2004], tìm kiếm và trích chọn thông tin [Bao and Funakoshi, 1998], phân loại và chia nhóm văn bản [Bao and Binh, 2001], khai phá Web [Hieu, 2005], gióng hàng văn bản [Huyen et al., 2003], mô hình từ điển điện tử [Bao et al., 2003], xây dựng kho ngữ liệu [Dien, 2002], … và gần đây nhất là đề tài nhà nước “Nghiên cứu phát triển công nghệ nhận dạng, tổng hợp và xử lý ngôn ngữ tiếng Việt” giai đoạn 2001-2004 trong chương trình quốc gia KC-01 [Khang, 2004].
Bên ngoài Việt Nam, cũng có những nỗ lực về xử lý tiếng Việt, như nhóm dịch Anh-Việt của tiến sỹ Phạm Hải và bè bạn (Mỹ) khởi đầu từ đầu các năm 1990, của tiến sỹ Lê Tăng Hồ và phần mềm tổng hợp tiếng Việt VVV (Canada), … đặc biệt là của các cán bộ và nghiên cứu sinh Việt Nam tại Viện Khoa học và Công nghệ Tiên tiến Nhật bản (JAIST) với 6 nghiên cứu sinh về xử lý ngôn ngữ, hợp tác theo một kế hoạch thống nhất. Số nghiên cứu sinh về xử lý ngôn ngữ mới tốt nghiệp như Lê Thanh Hương (Anh) [Huong, 2004], Nguyễn Thị Minh Huyền (Pháp), Hồ Bảo Quốc (Pháp), Nguyễn Lê Minh (Nhật) [Minh, 2004], và số sắp tốt nghiệp trong 1-2 năm tới đây ước tính khoảng 10 người.
Ngoài những kết quả ban đầu, sau đây có thể là một vài đặc điểm chính về hoạt động xử lý ngôn ngữ của chúng ta:

  * Thường _tập trung vào làm các sản phẩm cho người dùng cuối_ với nhiều kỳ vọng vào các sản phẩm dịch máy, một loại sản phẩm khó làm và cần làm dài hạn với những phương pháp hợp lý.

  * _Ít các nghiên cứu nền tảng, thiếu phát triển “hạ tầng cơ sở”_ cho xử lý ngôn ngữ như công cụ và tài nguyên: từ điển (dùng cho máy), kho ngữ liệu, …, những thứ đã được cả cộng đồng quốc tế xác định là không thể thiếu trong xử lý ngôn ngữ.

  * Phần đông là các _nghiên cứu ngắn hạn và đơn lẻ ở mức đề tài thạc sỹ, tiến sỹ_ với nhiều hạn chế về thời hạn và điều kiện. Đa số mới xây dựng được mô hình, thử và kiểm tra trên những tập ngữ liệu nhỏ. Những kết quả đạt được ở đây còn xa với mức sử dụng được trong thực tế.

  * Rất có thể nhiều nhóm đã bắt đầu với _sự khảo sát chưa đầy đủ_ , hoặc tiến hành công việc khi _có thể còn thiếu kiến thức_. Do vấn đề mới và phức tạp, các hội đồng đánh gía thẩm định các đề tài về xử lý ngôn ngữ còn _chưa có chuyên gia_ , chưa thật rõ hết cái có thể và cái chưa thể làm được, người làm đi đường ngắn hay đường vòng, …

  * Đáng băn khoăn hơn cả là các nỗ lực của chúng ta _chưa được liên kết, thiếu chia sẻ, phân công, hợp tác theo một lộ trình có kế hoạch, thiếu “kim chỉ nam”_ về xử lý tiếng Việt, và _không có tính kế thừa_ về kết quả giữa các tầng của xử lý ngôn ngữ tự nhiên. Nếu hình dung công việc trong các tầng của xử lý ngôn ngữ được đánh số từ A đến Z, thì hầu hết các việc làm ra cho người dùng cuối đều ở quãng từ R, S, … trở đi, mà muốn làm mấy việc này thì đều cần kết quả của tất cả các bước từ A đến tận P, Q. Hiềm nỗi mỗi việc từ A, B, … đến P, Q muốn làm tốt đều đòi hỏi một nhóm người làm trong một vài năm. Vì vậy, nếu ai cũng phải làm từ A đến gì đấy tận P, Q, có lẽ sẽ không ai có thể làm ra các sản phẩm R, S, …, Z đủ tốt. Dù bây giờ hay năm, mười, hai mươi năm sau cũng vậy.


# Kết luận

Chúng ta ai cũng biết xử lý tiếng Việt chỉ có thể do người Việt làm, không thể mua được từ bên ngoài. Ngoài ra, xử lý tiếng Việt là công việc phải làm _trên đường dài gồm nhiều chặng ngắn với các đích chọn lựa kỹ lưỡng_ , và _cần được nhà nước hỗ trợ_. Trước mắt, trong kế hoạch 2006-2010, hai mục tiêu của dự án đầu là:

  * _Xây dựng và phát triển một số sản phẩm tiêu biểu_ về xử lý tiếng Việt và tìm kiếm thông tin trên Internet bằng tiếng Việt cho đông đảo người sử dụng máy tính và Internet.

  * _Xây dựng các công cụ và nguồn tài nguyên thiết yếu,_ với vai trò hạ tầng cơ sở, để thực hiện mục tiêu 1 của dự án này và các phát triển lâu dài của công nghệ thông tin của nước nhà.


Mặc dù việc phải tạo các sản phẩm cho người dùng cuối là cấp bách và đích cuối cùng ta cần đến, chúng ta vẫn luôn phải chú ý đầu tư cho việc tạo ra các công cụ và tài nguyên cho xử lý tiếng Việt, vì chỉ có như vậy ta mới có thể làm được các sản phẩm có thể dùng được trong những năm về sau.

# Public_022

# Phạm vi áp dụng

Tiêu chuẩn này quy định phương pháp thử nghiệm các hệ bọc bảo vệ chịu lửa cho cấu kiện kết cấu thép được sử dụng trong công trình như dầm, cột, hoặc cấu kiện chịu kéo. Tiêu chuẩn này được biên soạn để sử dụng kết hợp với quy trình đánh giá được trình bày trong ISO 834-11. Tiêu chuẩn áp dụng cho các loại tiết diện thép (bao gồm các tiết diện rỗng) và chỉ xét đến các tiết diện không có các lỗ hở trên bản bụng. Các kết quả từ phân tích tiết diện chữ I hoặc tiết diện chữ H được áp dụng trực tiếp cho tiết diện thép góc, tiết diện chữ C và tiết diện chữ T có cùng hệ số tiết diện được sử dụng như các cấu kiện riêng lẻ, ví dụ như giằng, hoặc một phần của hệ kết cấu chế tạo sẵn như hệ giàn thép. Tiêu chuẩn này không áp dụng đối với các thanh/que đặc, hoặc tiết diện rỗng được nhồi bê tông.
Tiêu chuẩn này mô tả các quy trình thử nghiệm chịu lửa cần được thực hiện để đánh giá khả năng của hệ bọc bảo vệ để duy trì đủ sự kết dính và giữ đúng vị trí đối với một phạm vi biến dạng, nhiệt độ lò và nhiệt độ thép được xác định rõ từ trước, sao cho hiệu quả của hệ bọc bảo vệ không bị suy giảm đáng kể, và để cung cấp dữ liệu về các đặc tính nhiệt của hệ bọc bảo vệ khi chịu tác động của đường cong nhiệt độ/thời gian tiêu chuẩn được quy định trong tiêu chuẩn TCVN 9311-1.
Trong các trường hợp đặc biệt được quy định trong các quy chuẩn xây dựng quốc gia, các vật liệu chống cháy dạng phản ứng có thể được yêu cầu phải chịu đường cong nhiệt chậm. Thử nghiệm và các yêu cầu cho việc sử dụng đường cong này được mô tả trong phụ lục F.
Tiêu chuẩn này có thể áp dụng cho cả hệ bọc bảo vệ chịu lửa dạng thụ động và dạng phản ứng như được định nghĩa trong phần thuật ngữ và định nghĩa, được lắp đặt hoặc bọc phủ sao cho chúng giữ nguyên vị trí trong khoảng thời gian dự kiến chịu lửa.
Phương pháp thử nghiệm chịu lửa cung cấp các quy định cho việc thu thập và diễn giải số liệu được sử dụng làm đầu vào trực tiếp của tiêu chuẩn ISO 834-11 để xác định các giới hạn áp dụng trực tiếp cho các tiết diện thép với hình dạng, kích thước và khoảng thời gian chịu lửa bất kì.

# Tài liệu viện dẫn

Một phần hoặc toàn bộ các tài liệu viện dẫn sau là cần thiết cho việc sử dụng tiêu chuẩn này. Đối với các tài liệu viện dẫn ghi năm công bố thì áp dụng phiên bản được nêu. Đối với các tài liệu viện dẫn không ghi năm công bố thì áp dụng phiên bản mới nhất, bao gồm cả các sửa đổi, bổ sung (nếu có).TCVN xxxx:202x

TCVN 9311-1 (ISO 834-1), Thử nghiệm chịu lửa - Các bộ phận công trình xây dựng - Phần 1: Yêu cầu chung

TCVN 9311-6:2012 (ISO 834-6), Thử nghiệm chịu lửa - Các bộ phận công trình xây dựng - Phần 6:

Các yêu cầu riêng đối với dầm

TCVN 9311-7:2012 (ISO 834-7), Thử nghiệm chịu lửa - Các bộ phận công trình xây dựng - Phần 7:

Các yêu cầu riêng đối với cột

ISO 1182:2010, Thử nghiệm sản phẩm phản ứng với lửa – Phương pháp thử tính không cháy

ISO 1716, Thử nghiệm sản phẩm phản ứng với lửa – Xác định nhiệt lượng của quá trình đốt (giá trị nhiệt lượng).

ISO 8421-2, Bảo vệ chịu lửa – Từ vựng – Phần 2: Bảo vệ chịu lửa kết cấu.

ISO 834-11, Thử nghiệm chịu lửa – Các bộ phận công trình xây dựng – Phần 11: các yêu cầu riêng cho việc đánh giá lớp bọc bảo vệ với cấu kiện của kết cấu thép.

EN 13501-1, Phân loại chịu lửa cho sản phẩm xây dựng và bộ phận công trình – Phần 1: Phân loại dữ liệu từ các thử nghiệm phản ứng với lửa.

EN 1363-1, Thử nghiệm chịu lửa – Phần 1: Các quy định chung.

ISO 13943, An toàn cháy – Từ vựng.

IEC 584-1, Đầu đo nhiệt – Phần 1: Bảng tham khảo.

ETAG 018, Các sản phẩm bọc bảo vệ chịu lửa.

# Thuật ngữ và định nghĩa

Các thuật ngữ và định nghĩa được nêu trong TCVN 9311-1, ISO 13943, TCVN 9310-4 và những thuật ngữ, định nghĩa sau được áp dụng khi sử dụng tiêu chuẩn này.

## Nhiệt độ đặc trưng của thép (characteristic steel temperature)

Nhiệt độ của cấu kiện thép kết cấu được sử dụng để xác định hệ số hiệu chỉnh cho khả năng bám dính được tính toán bằng (nhiệt độ trung bình + nhiệt độ lớn nhất)/2

## Nhiệt độ thiết kế (design temperature)

Nhiệt độ của cấu kiện thép được sử dụng cho mục đích thiết kế kết cấu

## Bảo vệ chịu lửa

Biện pháp bảo vệ các cấu kiện thép bằng hệ bảo vệ chịu lửa sao cho nhiệt độ của cấu kiện thép được giới hạn trong suốt thời gian tiếp xúc với lửa

## Hệ bảo vệ chịu lửa (fire protection system)

Vật liệu chống cháy cùng với hệ đỡ bao gồm lưới thép như được thử nghiệm.
CHÚ THÍCH 1: Hệ vật liệu chống cháy dạng phản ứng bao gồm sơn lót và lớp sơn phủ nếu có.

## Chiều dày lớp bảo vệ chịu lửa (fire protection thickness)

Chiều dày khô của 1 lớp trong hệ bảo vệ chịu lửa hoặc chiều dày tổng cộng của tất cả các lớp trong hệ bảo vệ chịu lửa
CHÚ THÍCH 1: Chiều dày các bộ phận của hệ đỡ hoặc dải che mối nối không được tính vào chiều dày lớp bảo vệ chịu lửa
CHÚ THÍCH 2: với hệ bảo vệ dạng phản ứng, chiều dày là chiều dày trung bình của lớp màng phủ khô không bao gồm sơn lót và sơn phủ nếu có

## Cấu kiện chữ H (H section)

Cấu kiện thép có chiều rộng bản cánh lớn so với chiều cao tiết diện có chức năng chính là chịu tải dọc trục, có thể kết hợp chịu uốn và chịu cắt

## Cấu kiện chữ I (I section)

Dầm phụ hoặc dầm chính bằng thép với phần bản cánh ngắn như chữ “I” có chức năng chính là chịu tải vuông góc với trục dọc của cấu kiện
CHÚ THÍCH 1: các tải trọng trên thường gây ra uốn cho cấu kiện dầm. Các bản cánh dầm có thể song song với nhau hoặc dạng dốc

## Vật liệu bảo vệ dạng thụ động (passive fire protection material)

Các vật liệu, không thay đổi tính chất vật lý khi chịu nhiệt, cung cấp hiệu quả bảo vệ bằng các tính chất vật lý hoặc cách nhiệt của chúng.

## Vật liệu bảo vệ dạng phản ứng (reactive fire protection material)

Các vật liệu mà thành phần của nó xảy ra phản ứng hóa học khi chịu nhiệt để làm thay đổi tính chất vật lý và do đó cung cấp hiệu quả bảo vệ chịu lửa thông qua các hiệu ứng cách nhiệt và làm mát.

## Cấu kiện tham chiếu (reference section)

Cấu kiện thép được lấy cùng chiều dài với cấu kiện tương đương mang tải

## Hệ số tiết diện (với cấu kiện không được bọc bảo vệ) (section factor- unprotected steel)

Tỷ lệ của diện tích phần chu vi tiếp xúc với lửa của cấu kiện thép, trên một đơn vị chiều dài, Am, với thể tích mặt cắt ngang trên mỗi đơn vị chiều dài, V

## **Hệ số tiết diện (với hệ bảo vệ dạng định hình) (section factor-profiled fire protection** system)

Tỉ số giữa diện tích của chu vi bên ngoài phần tiếp xúc với lửa của bộ phận kết cấu thép không bao gồm vật liệu bảo vệ, trên một đơn vị chiều dài, Am, với thể tích của tiết diện trên một đơn vị chiều dài,

## Hệ số tiết diện (với hệ bảo vệ dạng hộp) (section factor - boxed fire protection system)

Tỉ số giữa diện tích bề mặt bên trong của vỏ bọc hình chữ nhật hoặc hình vuông nhỏ nhất được đo xung quanh cấu kiện kết cấu, Am, với thể tích trên một đơn vị chiều dài, V

## Cấu kiện thép (steel member)

Cấu kiện của công trình xây dựng, chịu tải trọng và được chế tạo từ thép

CHÚ THÍCH 1: đối với mục đích của tiêu chuẩn ISO 834, thép được sử dụng trong thử nghiệm phải cùng loại.

## Nhiệt độ thép (steel temperature)

Sử dụng nhiệt độ trung bình tổng thể làm dữ liệu đầu vào cho phân tích, tính toán như sau:

  * Với dầm tiết diện chữ I và tiết diện chữ H, bằng nhiệt độ trung bình của bản cánh trên cộng với nhiệt độ trung bình của bản bụng cộng với nhiệt độ trung bình của bản cánh dưới , chia cho 3.

  * Với cột có tiết diện chữ I, chữ H và tiết diện rỗng, bằng tổng của nhiệt độ trung bình trên mỗi mặt cắt đo chia cho số mặt cắt đo

  * Với dầm tiết diện rỗng, bằng nhiệt độ trung bình của các mặt bên cộng với nhiệt độ trung bình của mặt dưới, chia cho 2.


## Khả năng bám dính (stickability)

Khả năng của hệ bảo vệ chịu lửa duy trì đủ sự kết dính và giữ đúng vị trí đối với một phạm vi biến dạng, nhiệt độ lò và nhiệt độ thép được xác định rõ từ trước, sao cho hiệu quả của hệ bọc bảo vệ không bị suy giảm đáng kể

## Gói thử nghiệm (test package)

Tập hợp các tiết diện thép bao gồm cả mẫu ngắn và mẫu dài được thử nghiệm để xác định đầy đủ khả năng bám dính thích hợp của hệ bảo vệ chịu lửa và cung cấp dữ liệu nhiệt trong một phạm vi chiều dày bảo vệ, hệ số tiết diện, nhiệt độ thép.

## Mẫu thử nghiệm (test specimen)

Cấu kiện thép cùng với hệ bảo vệ chịu lửa được thử nghiệm
CHÚ THÍCH 1: cấu kiện thép được thử nghiệm, đại diện cho một cấu kiện thép được xác định cho mục đích thử nghiệm, bao gồm cột hoặc dầm thép dài và ngắn.

# Ký hiệu và từ viết tắt

  * Diện tích (m2);


Am
Ap

Diện tích phần chu vi tiếp xúc với lửa của cấu kiện kết cấu thép, trên một đơn vị chiều

dài (m2);

Với hệ bảo vệ dạng định hình: là diện tích phần chu vi ngoài của cấu kiện thép kết cấu

không bao gồm vật liệu bảo vệ, trên một đơn vị chiều dài (m2);

Với hệ bảo vệ dạng hộp: diện tích bề mặt phía trong của lớp bảo vệ hình chữ nhật hoặc

hình vuông mà có thể đo được xung quanh cấu kiện thép (m2);

  * Bề rộng của tiết diện thép (m);


  * Chiều dày (mm);


daver
dp
dp(max)
dp(min)

Chiều dày trung bình (mm);

Chiều dày của vật liệu bảo vệ chịu lửa (mm);

Chiều dày lớn nhất của vật liệu bảo vệ chịu lửa (mm);

Chiều dày nhỏ nhất của vật liệu bảo vệ chịu lửa (mm);

  * Chiều cao tiết diện thép (mm);


Kp
Ks
Lexp
Lspec
Lsup

Hệ số ảnh hưởng của chiều dày;

Hệ số ảnh hưởng của tiết diện;

Chiều dài của đoạn dầm tiếp xúc với lửa (mm);

Tổng chiều dài của mẫu thử (mm);

Chiều dài của dầm giữa hai gối tựa (mm);

  * Chu vi của phần tiết diện tiếp xúc với lửa (m);


sp
smax

Hệ số tiết diện của hệ số Ks (m-1);

Hệ số tiết diện lớn nhất tương ứng với hệ số Ks bằng 1 (m-1);


| smin | Hệ số tiết diện nhỏ nhất tương ứng với hệ số Ks bằng 0
(m-1); |
| --- | --- |
| tf | Chiều dày bản cánh của tiết diện (m-1); |
| tw | Chiều dày thành của tiết diện rỗng hoặc chiều dày bản bụng của cột
tiết diện chữ I và |
|  | chữ H (mm); |

 

  * Thể tích của tiết diện thép trên một đơn vị chiều dài (m3/m);


Vp

Thể tích của phần bảo vệ chịu lửa trên một đơn vị chiều dài (m3/m);

LB

Dầm chịu tải

LC

Cột chịu tải dài 3 m

TC

Cột cao không chịu tải (2 m)

LHB

Dầm rỗng chịu tải

LHC

Cột rỗng chịu tải

SIB

Dầm ngắn tiết diện chữ I

SIC

Cột ngắn tiết diện chữ I

TCHS

Dầm cao hình tròn rỗng

TRHS

Dầm cao hình chữ nhật rỗng

SHB

Dầm ngắn tiết diện rỗng

SHC

Cột ngắn tiết diện rỗng

RB

Dầm tham chiếu

# Thiết bị thử nghiệm

## Yêu cầu chung

Lò thử nghiệm và các thiết bị thử nghiệm phải phù hợp với những yêu cầu được quy định trong TCVN 9311-1

## Lò thử nghiệm

Lò thử nghiệm phải được thiết kế phù hợp với kích thước của mẫu thử chịu nhiệt được quy định trong 7.2 và phải phù hợp với việc lắp đặt ở trên hoặc trong lò thử nghiệm được quy định trong mục 8.

## Thiết bị gia tải

Tải trọng phải được tác dụng theo TCVN 9311-1 (ISO 834-1). Hệ gia tải có khả năng chất tải lên dầm theo quy định tại 6.2.2 và lên cột theo quy định tại 6.2.4

# Các điều kiện thử nghiệm

## Yêu cầu chung

Các quy trình được đưa ra trong TCVN 9311-1 phải được tuân thủ trong quá trình thực hiện thử nghiệm trừ khi có hướng dẫn cụ thể khác được đưa ra.
Một số lượng các cấu kiện thép có tiết diện chữ “I”, tiết diện chữ “H”, và tiết diện rỗng, được bảo vệ bằng hệ bọc bảo vệ, được gia nhiệt trong lò thử nghiệm theo cách thức được đưa ra trong tiêu chuẩn TCVN 9311-1
Dầm chịu tải và cột chịu tải được gia nhiệt để cung cấp các thông tin về khả năng của hệ bọc bảo vệ chịu lửa đối với việc duy trì tính nguyên vẹn và bám dính với cấu kiện của kết cấu thép. Dầm không chịu tải và cột không chịu tải được gia nhiệt để cung cấp thông tin về các đặc tính nhiệt học của hệ bọc bảo vệ.
Kiến nghị các thử nghiệm được tiếp tục tiến hành cho đến khi nhiệt độ của thép đạt mức giá trị tối đa tương ứng với ứng dụng của dữ liệu.
Phương pháp thử nghiệm dầm chịu tải trong phần này của phương pháp thử nghiệm được xây dựng để cung cấp giá trị chuyển vị lớn nhất (nhịp/30) dưới tác dụng của tải trọng và nhiệt độ được quy định trong tiêu chuẩn TCVN 9311-1 (ISO 834-1). Nếu không thực hiện được việc xác định này, thì tốc độ võng không được vượt quá giá trị quy định trong tiêu chuẩn TCVN 9311-1 (ISO 834-1).
Trong trường hợp nhiều mẫu thử được thử nghiệm đồng thời, cần lưu ý rằng mỗi mẫu thử cần phải đảm bảo được tiếp xúc với lửa đúng với các điều kiện thử nghiệm đã quy định.

## Gối đỡ và điều kiện tải trọng

### Yêu cầu chung

Chi tiết về các tính toán được thực hiện để xác định tải trọng thử nghiệm cần được đưa vào báo cáo thử nghiệm.

### Dầm chịu tải

Đối với mỗi mẫu thử nghiệm dầm chịu tải, cần có các quy định đối với hệ gối đỡ thích hợp, vị trí và sự căn chỉnh trong lò theo yêu cầu của tiêu chuẩn TCVN 9311-6 (ISO 834-6), tùy thuộc vào bất kỳ yêu cầu sửa đổi nào của tiêu chuẩn này.
Cấu kiện dầm không nên được bổ sung thêm liên kết chống xoắn trừ trường hợp cần thiết nêu trong 7.2.1. Nhịp của gối đỡ đơn giản (Lsup) không nên lớn hơn chiều dài phần tiếp xúc với lửa cộng thêm 400 mm ở mỗi đầu. Chiều dài của mẫu thử nghiệm (Lspec) nên bằng chiều dài tiếp xúc với lửa cộng thêm tối đa 500 mm ở mỗi đầu.
Mẫu thử nghiệm là dầm chịu tải cần phải chịu tổng tải trọng đại diện cho 60 % sức kháng mô men thiết kế, được tính toán sử dụng giới hạn chảy thực tế lấy từ chứng chỉ thử nghiệm lô hoặc giá trị đo thực tế.
Tải trọng thực tế tác dụng lên mẫu thử là tổng tải trọng tính toán trừ đi trọng lượng bản thân của dầm, lớp bê tông đổ bù, và hệ bảo vệ chịu lửa.

# Public_023

# Các hệ bảo vệ chịu lửa

## Nguyên tắc chung

Thành phần của hệ bảo vệ chịu lửa cần được quy định bởi khách hàng và cần bao gồm ít nhất khối lượng riêng danh nghĩa và độ ẩm dự kiến của vật liệu đó. Thông tin bổ sung có thể được yêu cầu liên quan đến khả năng chịu nhiệt cho mục đích đánh giá.

Vì lý do bảo mật, khách hàng có thể không muốn thông báo chi tiết về công thức hoặc thành phần trong báo cáo thử nghiệm.

Đối với các lớp phủ dạng phản ứng, độ dày màng khô của lớp phủ phải được đo tại thời điểm thử nghiệm. Các bước thực hiện và quy trình kiểm tra thích hợp được nêu trong Phụ lục B.

Đối với các vật liệu chống cháy thụ động như dạng tấm, dạng bản và dạng phun, độ dày thực tế, khối lượng riêng và độ ẩm thực tế của vật liệu phải được đo tại thời điểm thử nghiệm đối với từng mẫu thử. Các quy trình thích hợp với các loại vật liệu bảo vệ khác nhau được nêu trong Phụ lục A.

Kích thước và độ dày của tấm và bản sàn phải được xác định theo các tiêu chuẩn quốc gia và nằm trong dung sai được xác định trong các tiêu chuẩn này.

## Chiều dày của vật liệu bảo vệ

### Bản và tấm

Chiều dày vật liệu bọc bảo vệ dạng bản hoặc tấm không sai lệch quá 15% giá trị trung bình trên toàn bộ bề mặt của nó. Giá trị trung bình phải được sử dụng trong đánh giá kết quả và trong giới hạn khả năng áp dụng của đánh giá. Nếu độ dày của tấm thay đổi lớn hơn 15% thì chiều dày lớn nhất sẽ được ghi nhận để sử dụng trong đánh giá.

Giá trị trung bình là giá trị trung bình của tất cả các phép đo theo Phụ lục A.

### Vữa phun và vật liệu phủ dạng bị động

Chiều dày vật liệu bảo vệ dạng vữa phun và lớp phủ dạng bị động cần được đo tại các vị trí quy định trong Phụ lục A. Các điểm đo chiều dày không gần hơn 150 mm tới sườn cứng bản bụng của dầm chịu tải.

Phép đo phải được thực hiện cách xa các vị trí đặt đầu đo nhiệt từ 50 mm đến 100 mm.

Chiều dày của lớp phủ dạng phun không được sai lệch quá 20% giá trị trung bình. Giá trị trung bình được sử dụng trong đánh giá kế quả trong trong giới hạn khả năng áp dụng đánh giá. Nếu độ lệch của chiều dày lớn hơn 20 %, chiều dày lớn nhất cần được sử dụng trong đánh giá.

Chiều dày trung bình (hoặc chiều dày tối đa theo các yêu cầu nêu trên về độ lệch chiều dày cho phép) của vật liệu bảo vệ chịu lửa được áp dụng cho từng cấu kiện dầm chịu tải và cột chịu tải, nếu được sử dụng, phải giống như đối với cấu kiện dầm hoặc cột ngắn tham chiếu. Trong mỗi trường hợp, chênh lệch không được lớn hơn 10% giá trị lớn nhất hoặc ± 5mm, tùy theo giá trị nào nhỏ hơn.TCVN xxxx:202x

### Lớp phủ dạng phản ứng

Đối với vật liệu bọc phủ dạng phản ứng, độ dày trung bình của lớp sơn lót phải được đo trước và trừ đi từ tổng chiều dày trung bình của lớp sơn lót và lớp sơn dạng phản ứng. Dung sai độ dày cho phép không bao gồm sơn lót và sơn phủ (giả sử phân bố chuẩn của độ dày đo được) phải như sau:

  * Tại các mặt cắt đo nhiệt độ

  * Tối thiểu 68% số đọc phải nằm trong khoảng ± 20% giá trị trung bình.

  * Tối thiểu 95% số đọc phải nằm trong khoảng ± 30% giá trị trung bình.

  * Tất cả các số đọc phải nằm trong khoảng ± 45% giá trị trung bình.

  * Về tổng thể

  * Tối thiểu 68% số đọc phải nằm trong khoảng ± 20% giá trị trung bình tại các mặt cắt đo nhiệt độ.

  * Tối thiểu 95% số đọc phải nằm trong khoảng ± 30% giá trị trung bình tại các mặt cắt đo nhiệt độ.

  * Tất cả các số đọc phải nằm trong khoảng ± 45% giá trị trung bình tại các mặt cắt đo nhiệt độ.


Nếu chiều dày vượt quá những giá trị giới hạn trên, mẫu thử nghiệm cần phải được điều chỉnh để phù hợp với những yêu cầu trên.

### Khối lượng riêng của vật liệu bảo vệ dạng thụ động

Khối lượng riêng của vật liệu bảo vệ (nếu phù hợp) được áp dụng cho từng cấu kiện phải được xác định theo Phụ lục A và được ghi nhận.
Với mỗi chiều dày của vật liệu bảo vệ, trọng lượng riêng của vật liệu không được sai lệch quá 15 % giá trị trung bình. Giá trị trung bình phải được sử dụng trong việc đánh giá kết quả và trong phạm vi áp dụng của đánh giá. Nếu có sai lệch lớn hơn 15% thì phải sử dụng giá trị lớn nhất để đánh giá.
Khối lượng riêng trung bình của vật liệu bảo vệ (hoặc khối lượng riêng lớn nhất theo độ lệch cho phép) được áp dụng cho cấu kiện dầm thép mang tải và cột thép mang tải phải giống như áp dụng cho cấu kiện dầm thép hoặc cột thép ngắn tương đương không chịu tải . Chênh lệch giữa các giá trị khối lượng riêng trong mỗi trường hợp không được lớn hơn 10 % giá trị trung bình lớn nhất tại chiều dày sử dụng. Phòng thí nghiệm phải xác nhận các giá trị cân bằng đối với cấu kiện chịu tải và cấu kiện tham chiếu phải nằm trong phạm vi 10 % của nhau.

### Kiểm tra mẫu thử

Việc kiểm tra và xác nhận mẫu thử để đảm bảo sự phù hợp với đặc điểm kỹ thuật phải được thực hiện như trong mô tả của tiêu chuẩn TCVN 9311-1.
Đặc tính của vật liệu bảo vệ được sử dụng trong việc chuẩn bị các mẫu thử nghiệm phải được xác định bằng cách sử dụng các mẫu đặc biệt khi cần thiết theo các phương pháp được nêu trong Phụ lục A hoặc Phụ lục B.
Khách hàng phải có trách nhiệm kiểm tra rằng vật liệu bảo vệ được áp dụng đúng cách, và trong trường hợp vật liệu dạng phun hoặc phủ, phải đảm bảo bằng chúng được sử dụng đúng thành phần và đặc điểm kỹ thuật.TCVN xxxx:202x

Phải ghi chép đầy đủ khoảng hở giữa mặt trong của hệ tấm hoặc bản và tiết diện thép. Đối với dầm, các phép đo phải được thực hiện ở khoảng giữa nhịp và ở cả hai đầu của dầm. Đối với cột, các phép đo phải được thực hiện ở khoảng giữa chiều cao và ở trên cùng của cột.

## Lựa chọn mẫu thử nghiệm

### Nguyên tắc lựa chọn

Phạm vi đánh giá sẽ quyết định việc lựa chọn mẫu thử

Đối với vật liệu bảo vệ dạng thụ động, hướng dẫn lựa chọn mẫu thử được nêu trong Phụ lục C. Đối với vật liệu bảo vệ dạng phản ứng, hướng dẫn lựa chọn mẫu thử được nêu trong Phụ lục D.

Phụ lục C và Phụ lục D cho phép thực hiện nhiều đánh giá khác nhau, tùy thuộc vào việc nhà sản xuất muốn thực hiện thử nghiệm hạn chế hay mở rộng. Mỗi gói thử nghiệm chỉ ra số lượng mẫu thử tối thiểu cần thiết cho phạm vi đã cho.

### Cấu kiện thử nghiệm để đánh giá khả năng bám dính

Phương pháp để xác định việc hiệu chỉnh khả năng bám dính phụ thuộc vào phạm vi của gói thử nghiệm và hệ bọc bảo vệ.

Hướng dẫn lựa chọn cho vật liệu bảo vệ dạng thụ động được nêu trong Phụ lục C. Hướng dẫn cho vật liệu bảo vệ dạng phản ứng được nêu trong Phụ lục D.

### Yêu cầu cho phân tích nhiệt

Ngoài các yêu cầu, sẽ cần có một phạm vi các cấu kiện tiết diện chữ I không chịu tải mà không phụ thuộc vào phương pháp phân tích được sử dụng. Các cấu kiện này sẽ được chọn để bao được phạm vi chiều dày bảo vệ, hệ số tiết diện và khoảng thời gian chịu lửa và cũng bao gồm cấu kiện ngắn tham chiếu tương đương với cấu kiện chịu tải hoặc cấu kiện cao.

Các cấu kiện ngắn và cao sẽ được yêu cầu bổ sung để phân tích với cấu kiện tiết diện rỗng được lựa chọn tương tự để kể đến các yếu tố về chiều dày bảo vệ, hệ số tiết diện và khoảng thời gian chịu lửa

Lựa chọn mẫu thử nghiệm được xác định bởi phạm vi đánh giá cần thiết đối với sản phẩm bảo vệ. Điều này sẽ dựa trên phạm vi hệ số tiết diện (lớn nhất và nhỏ nhất) và phạm vi chiều dày (lớn nhất và nhỏ nhất) cho từng khoảng thời gian chịu lửa. Các hệ số phạm vi sẽ có giá trị lớn nhất là 1,0 và giá trị nhỏ nhất 0,0 và sẽ được xác định bởi nhà sản xuất.

Lựa chọn mẫu cho vật liệu bảo vệ dạng thụ động được nêu trong Phụ lục D. Đối với vật liệu bảo vệ phản ứng, Lựa chọn mẫu trong Phụ lục E.

# Lắp đặt mẫu thử nghiệm 

## Dầm chịu tải

Các tấm sàn bê tông nhẹ hoặc bê tông khí phải được dùng làm lớp bê tông trên cùng, được bắt vít vào dầm bằng bu lông có đường kính 12 mm. Chỉ có hai mặt bên và mặt dưới của dầm được tiếp xúc với nhiệt, như thể hiện trong Hình 1. Các tấm sàn phải có các đặc tính sau:

  * Chiều rộng dọc theo dầm là 600 mm ± 100 mm.

  * Chiều dày tấm sàn trong khoảng 150 mm đến 200 mm.

  * Chiều dài tối đa là 625 mm.

  * Khối lượng riêng danh nghĩa của các tấm sàn dạng bê tông khí là 500 kg/m3.

  * Khối lượng riêng danh nghĩa của các tấm sàn bê tông nhẹ là 1 500 kg/m3.

  * Tấm sàn bê tông phải có khoảng cách giữa chúng đủ lớn cho phép dầm chịu uốn.

  * Phải có một lớp vật liệu cách nhiệt chịu nén bằng sợi gốm giữa lớp bê tông nhẹ và bản cánh trên của dầm. Lớp vật liệu cách nhiệt có cấp A1 được xác định theo tiêu chuẩn EN 13501-1 và chịu được nhiệt độ thấp nhất là 1 0000C. Độ dày khi không nén là 30 mm ± 5 mm và có khối lượng riêng danh nghĩa là 125 ± 25 kg/m3 . Lớp cách nhiệt có chiều rộng bằng chiều rộng mặt trên của dầm thép (xem Hình 1).


Vật liệu cách nhiệt thay thế cấp A1 được xác định theo tiêu chuẩn ISO 1182:2010, (1) và tiêu chuẩn ISO 1716 có thể được sử dụng với điều kiện có đặc tính tương tự về nhiệt và chiều dày so với tấm cách nhiệt bằng sợi bông gốm.
Các bộ phận của lớp bê tông nhẹ phía trên phải được liên kết bu lông vào dầm thông qua đinh chống cắt có đường kính thích hợp được hàn vào dầm. Phải có một tấm thép đệm thích hợp bên dưới đai ốc khóa. Các đinh chống cắt này có thể được đặt trong phần tiếp giáp giữa mỗi cấu kiện của lớp mặt bê tông phía trên hoặc trong nằm chiều dài của lớp tấm bê tông (xem Hình 1; cố định trong chiều dài của lớp tấm).
Mỗi cấu kiện của lớp bê tông phải được cố định ít nhất tại 2 vị trí. Khoảng hở giữa các cấu kiện của lớp bê tông phải được lấp đầy bằng vật liệu chống cháy.
Tại thời điểm bắt đầu thử nghiệm, mặt dưới của lớp bê tông phủ trên mặt dầm chịu tải về danh nghĩa phải bằng với mặt dưới của các tấm nắp lò liền kề.
Việc bố trí mẫu thử, phù hợp với điều kiện phòng thí nghiệm, cần đảm bảo rằng khe hở giữa lớp bê tông phủ trên mặt dầm chịu tải và các tấm nắp lò liền kề được bịt kín để tránh thoát khí lò ra ngoài, đặc biệt khi dầm bị biến dạng trong quá trình thử nghiệm. Dầm chịu tải phải được lắp đặt với yêu cầu các gối đỡ của dầm phải được cách nhiệt.
Ngoài ra, các đầu dầm chịu tải bên ngoài lò phải được cách nhiệt và có đủ khe hở giữa mặt dưới của lớp bảo vệ và thành lò để ngăn cản ảnh hưởng.

## Dầm không chịu tải

Mỗi mẫu thử nghiệm dầm không chịu tải phải được bắt bu lông vào mặt dưới của các tấm nắp lò làm từ cùng một loại bê tông được sử dụng làm lớp phủ lên dầm có tải. Phải có một tấm thép thích hợp bên dưới đai ốc khóa của bu lông.
Mỗi mẫu thử phải được cung cấp một lớp cách nhiệt bằng sợi gốm được đặt giữa mặt dưới nắp lò và bản cánh trên của dầm như quy định trong 8.1 đối với dầm chịu tải và Hình 2.
Các vật liệu cách nhiệt thay thế (Loại A1) có thể được sử dụng với điều kiện chúng có các thông số về nhiệt và độ dày tương tự như lớp cách nhiệt bằng sợi gốm đã chỉ định.

Các dầu dầm phải được cách nhiệt bằng các vật liệu cách nhiệt cứng hoặc vật liệu cách nhiệt đàn hồi.

Xem cấu tạo chi tiết tại hình 2.

## Cột chịu tải

Mẫu thử nghiệm cột chịu tải được bố trí lắp đặt như Hình 3 và được mô tả trong tiêu chuẩn TCVN 9311-7.

## Cột không chịu tải

Mẫu thử nghiệm cột cao và cột ngắn phải được liên kết bu lông vào mặt dưới của tấm nắp lò bê tông nhẹ [mô tả trong 6.2.5, sử dụng đinh chống cắt đường kính 10 mm hàn vào cấu kiện cột và có các tấm (100 × 100 × 6) mm nằm dưới có đai ốc khóa] hoặc đặt trên sàn lò nung (trực tiếp hoặc trên bệ).

Cách nhiệt dạng sợi phù hợp như mô tả trong 8.1 được sử dụng giữa các bề mặt tiếp xúc của cột và tấm nắp lò, hoặc sàn lò, hoặc bệ đỡ để tránh truyền nhiệt qua các đầu của cấu kiện.

Kích thước của vật liệu cách nhiệt không nhỏ hơn kích thước tổng thể của cấu kiện thép được bảo vệ chống cháy.

## Bố trí lắp đặt mẫu thử nghiệm

Đối với mỗi thử nghiệm cho một dầm hoặc một cột chịu tải, một dầm hoặc cột tương đương không chịu tải phải được đưa vào và thử nghiệm trong lò cùng một lúc.

Đối với mỗi dầm chịu tải, dầm tham chiếu tương đương phải được bố trí song song và ở giữa nhịp của dầm chịu tải.

Mỗi cột cao và cấu kiện cột tham chiếu tương đương không chịu tải của nó phải được lắp đặt trong lò cùng một lúc và được thử nghiệm cùng nhau nếu có thể.

Các cấu kiện phải được định vị trong lò để đảm bảo chúng không bị che chắn hoặc bị ảnh hưởng bởi thành lò, các mẫu thử khác và các chướng ngại vật. Khoảng cách tối thiểu đến mẫu thử là 300 m hoặc bằng chiều cao của bản bụng dầm nếu chiều cao của dầm lớn hơn 300 mm. Lắp đặt mẫu thử điển hình có thể sử dụng được trong lò nung 4 m x 3 m

# Public_024

# THỰC PHẨM LÀ GÌ?

Khái niệm thực phẩm (food) liên quan đến các loại thức ăn và thức uống của con người. Nhìn từ góc độ hóa học, thực phẩm là một hỗn hợp các chất hóa học có nguồn gốc từ thực vật và động vật, được con người sử dụng qua đường tiêu hóa nhằm mục đích chủ yếu là dinh dưỡng.  
Trong thực phẩm, các hợp chất hữu cơ là những thành phần chủ yếu.

Thực phẩm rất đa dạng về chủng loại. Một số loại thực phẩm rất phổ biến và được sử dụng khắp nơi trên thế giới, ví dụ như sữa, đường saccharose... Tuy nhiên, mỗi địa phương, khu vực, tùy theo điều kiện địa lý và thói quen ẩm thực, sẽ có những sản phẩm thực phẩm truyền thống và đặc trưng riêng, ví dụ như natto của Nhật Bản, kim chi của Hàn Quốc, chả giò của Việt Nam...  
Hiện nay, cùng với vấn đề toàn cầu hóa, sự phát triển du lịch, giao lưu văn hóa và khoa học công nghệ giữa các nước, người dân trên thế giới có điều kiện tìm hiểu về các loại thực phẩm đặc trưng của nhiều quốc gia khác nhau.  
Ngoài ra, cần lưu ý rằng theo thời gian, con người sáng tạo và chế biến thêm nhiều sản phẩm thực phẩm mới từ các nguyên liệu sẵn có. Do đó, chúng ta không thể thống kê đầy đủ tên các sản phẩm thực phẩm hiện có của một vùng miền hay một quốc gia.

# PHÂN LOẠI THỰC PHẨM

Có nhiều phương pháp để phân loại thực phẩm, dựa trên những nguyên lý khác nhau. Dưới đây là ba phương pháp phổ biến:

## Phân loại thực phẩm theo thành phần hóa học

Thực phẩm có thể được chia thành bốn nhóm chính: thực phẩm giàu glucid, thực phẩm giàu protein, thực phẩm giàu lipid và thực phẩm dạng hỗn hợp.

Một sản phẩm thực phẩm bất kỳ thường chứa nhiều hợp chất hóa học khác nhau. Trong phương pháp phân loại thực phẩm theo thành phần hóa học, người ta dựa vào hợp chất có hàm lượng cao nhất trong thực phẩm (trừ nước) để phân loại sản phẩm.

### Thực phẩm giàu glucid

Glucid được chia thành hai nhóm cơ bản: nhóm có phân tử lượng thấp và nhóm có phân tử lượng cao.

  * **Nhóm glucid có phân tử lượng thấp** bao gồm các loại đường như glucose, fructose, saccharose, lactose, maltose và các loại oligosaccharide khác. Ví dụ thực phẩm giàu glucid phân tử lượng thấp: mật ong, đường mía, kẹo caramel...

  * **Nhóm glucid có phân tử lượng cao** gồm tinh bột, cellulose, hemicellulose, pectin, agar và một số loại polysaccharide khác. Tinh bột là polysaccharide quan trọng trong dinh dưỡng người. Tinh bột có nhiều trong các loại ngũ cốc (lúa mì, lúa mạch, gạo, bắp, đại mạch...) và các loại củ (khoai tây, khoai mì, khoai lang...). Cellulose là một chất xơ quan trọng, có nhiều trong rau.  
Ví dụ thực phẩm giàu glucid phân tử lượng cao phổ biến ở Việt Nam: bánh mì, bánh biscuit, mì sợi, các loại bún từ gạo, rau câu...


### Thực phẩm giàu protein

Protein có nhiều trong nguyên liệu động vật (thịt, thủy sản) và một số nhóm nguyên liệu thực vật (các loại đậu, nấm mũ...). Ví dụ: thịt, cá đóng hộp; khô thịt, cá; nấm rơm đóng hộp...

### Thực phẩm giàu lipid

Cùng với glucid và protein, lipid là một trong ba thành phần bắt buộc trong khẩu phần ăn hàng ngày. Ví dụ: dầu thực vật, bơ, margarine...

### Thực phẩm dạng hỗn hợp

Một số thực phẩm mà tỷ lệ khối lượng của các thành phần hóa học chính (trừ nước) gần như tương đương nhau được xếp vào nhóm thực phẩm dạng hỗn hợp. Ví dụ: sữa bò tươi, trong đó glucid, protein và lipid có tỷ lệ gần như tương đương.

Cần lưu ý ngoài glucid, protein và lipid, khẩu phần ăn hàng ngày của con người cần cung cấp thêm vitamin, khoáng, nước và một số hợp chất khác.

## Phân loại thực phẩm theo mục đích sử dụng

### Mục đích dinh dưỡng

Hầu hết các loại thực phẩm được sử dụng nhằm mục đích chủ yếu là dinh dưỡng. Thành phần trong thực phẩm khi đưa vào cơ thể sẽ được chuyển hóa thành năng lượng sinh học (ATP) và vật chất tế bào, giúp cơ thể tồn tại và phát triển.  
Ngày nay, một số thực phẩm được chế biến để ngoài mục đích dinh dưỡng còn có các mục đích khác. Ví dụ tại Việt Nam, các nhà sản xuất dùng khái niệm “thực phẩm dinh dưỡng” cho nhóm giàu năng lượng hoặc bổ sung vitamin, khoáng chất.

### Mục đích phòng và trị bệnh

Một số thực phẩm có chứa các thành phần hóa học đặc biệt, giúp phòng ngừa hoặc điều trị một số bệnh, được gọi là **thực phẩm chức năng (functional food)**. Theo Gibson Œ.R. et al. (2000), thực phẩm chức năng vừa cung cấp giá trị dinh dưỡng thông thường, vừa tác động có lợi đến một hay nhiều chức năng cơ thể nhằm tăng cường sức khỏe hoặc giảm nguy cơ bệnh tật.

Ví dụ: nhóm thực phẩm phòng bệnh như sữa bột giàu canxi để ngừa loãng xương, gia vị - nước mắm bổ sung iod để ngừa bướu cổ. Nhóm thực phẩm trị bệnh như nhân sâm (Panax ginseng C.A. Meyer) có các saponin kháng khuẩn, kháng viêm, chống khối u; hoặc phô mai chứa peptide sinh học và probiotic có tác dụng điều trị một số bệnh.

Lưu ý: thực phẩm chức năng khác thuốc, liều dùng phải cân đối trong khẩu phần, tác dụng thường chậm hơn thuốc.

##  Các mục đích sử dụng khác

Một số người coi ăn uống là thú vui, thư giãn, không quan tâm đến dinh dưỡng hay phòng bệnh. Ví dụ: uống trà vào buổi sáng tại Việt Nam là thói quen lâu đời, không chỉ để giải khát hay dinh dưỡng.

### Thực phẩm tươi

Thực phẩm tươi là thực phẩm không qua chế biến hoặc chế biến tối thiểu, không làm thay đổi đáng kể thành phần hóa học và giá trị cảm quan so với nguyên liệu ban đầu. Ví dụ: trái cây tươi, rau tươi, sữa tươi.  
**Chế biến tối thiểu (minimal processing)** nhằm bảo đảm chất lượng và tiện dụng, ví dụ: trái cây bóc vỏ, cắt miếng, bảo quản lạnh.

### Thực phẩm chế biến ở quy mô gia đình

Được chế biến trong bếp gia đình hoặc nhà hàng, khách sạn (tôm rim, thịt kho, cá chiên, canh chua, rau xào...). Quy trình phụ thuộc kinh nghiệm người chế biến, chất lượng có thể không đồng đều.

### Thực phẩm chế biến ở quy mô công nghiệp

Chế biến trong nhà máy quy mô lớn, áp dụng khoa học công nghệ, kiểm soát nghiêm ngặt chất lượng nguyên liệu, bán thành phẩm và thành phẩm. Ví dụ: mì ăn liền, bánh biscuit, đường saccharose, cà phê hòa tan, paté đóng hộp, xúc xích tiệt trùng.

# CÁC CHỈ TIÊU CHẤT LƯỢNG CỦA THỰC PHẨM

Chất lượng thực phẩm được đánh giá dựa trên nhiều chỉ tiêu. Có thể phân loại theo hai cách:

## Theo lĩnh vực khoa học tự nhiên

Chia thành vật lý, hóa học, hóa lý, sinh học và hóa sinh.

### Chỉ tiêu vật lý

  * Thực phẩm rắn: hình dạng, kích thước, khối lượng, độ giòn, dẻo, dai...

  * Thực phẩm lỏng: thể tích, tỷ trọng...


### Chỉ tiêu hóa học

#### Chất dinh dưỡng

Bao gồm nước, glucid, protein, lipid, vitamin, khoáng, acid trong thực phẩm. Ví dụ: nước cam đóng hộp - hàm lượng chất khô, độ chua, đường, vitamin C; mì sợi - độ ẩm, tinh bột, protein, độ chua.

#### Phụ gia và chất hỗ trợ kỹ thuật

  * **Phụ gia:** chất màu, mùi, ức chế vi sinh vật, chống oxy hóa, nhũ hóa, tạo cấu trúc, tạo vị...

  * **Chất hỗ trợ kỹ thuật:** phá bọt, trợ lọc, trợ lắng, hiệu chỉnh pH, xúc tác...


#### Các chất khác

  * **Tác dụng tốt:** hợp chất sinh học như alkaloid, flavonoid, glycoside.

  * **Tác dụng xấu:** độc tố sinh ra từ nguyên liệu hoặc trong chế biến.  
Ví dụ: khoai mì chứa HCN, nước tương nếu xúc tác bằng HCl có thể tạo 3-MCPD.


### Chỉ tiêu hóa lý

Liên quan hệ phân tán: nhũ tương, huyền phù, bọt, độ hòa tan, khả năng hấp phụ hơi nước.

### Chỉ tiêu sinh học

  * **Liên quan dinh dưỡng:** giá trị năng lượng, hệ số hấp thu protein NN.

  * **Vi sinh vật:** tổng số vi sinh vật hiếu khí, nấm men, nấm sợi, vi sinh vật gây bệnh.


### Chỉ tiêu hóa sinh

Hoạt tính enzyme ảnh hưởng thành phần hóa học. Ví dụ: phosphatase và lactoperoxidase trong sữa thanh trùng.

### Chỉ tiêu bao bì

Hình dạng, kích thước, khối lượng, vật liệu, độ kín, thông tin in trên bao bì, giá trị thẩm mỹ.

## Theo cơ sở khoa học của phương pháp phân tích

Chia thành hóa lý, sinh học, cảm quan.

### Chỉ tiêu hóa lý

Định lượng bằng thiết bị phân tích. Ví dụ: độ giòn bằng lực, hàm lượng hương bằng sắc ký khí, mức độ phân bố pha phân tán bằng nhiễu xạ laser, hoạt tính enzyme bằng quang phổ.

### Chỉ tiêu sinh học

Định lượng bằng phương pháp sinh học (nuôi cấy vi sinh, thực nghiệm in vivo).

### Chỉ tiêu cảm quan

Đánh giá bằng giác quan: màu sắc, độ trong, mùi, vị.

# NHỮNG VẤN ĐỀ QUAN TÂM CỦA NGƯỜI TIÊU DÙNG VỀ CHẤT LƯỢNG THỰC PHẨM

## An toàn thực phẩm

Thực phẩm phải đảm bảo an toàn tuyệt đối. Ngưỡng hàm lượng độc tố được quy định và có thể khác nhau giữa các quốc gia. Ở các nước phát triển, ngưỡng này thường thấp hơn ở các nước đang phát triển.

# Public_025

# Cơ sở khoa học

Chiếu xạ là một quá trình vật lý. Người ta sử dụng tia bức xạ điện từ hoặc dòng electron để tác động lên các mẫu thực phẩm. Khi thực phẩm hấp thụ năng lượng từ tia bức xạ điện từ hoặc dòng electron, sẽ xảy ra một số biến đổi có lợi cho chất lượng của sản phẩm.

Tia bức xạ điện từ gồm nhiều loại như tia X, tia gamma, tia beta... Hiện nay, tia gamma được sử dụng phổ biến trong sản xuất công nghiệp.

Ứng dụng của phương pháp chiếu xạ đã được phát hiện từ đầu thế kỷ XX. Năm 1930, nhà khoa học người Đức Wurt O. đã đăng ký bằng sáng chế tại Pháp về việc sử dụng phương pháp chiếu xạ để tiệt trùng thực phẩm. Tuy nhiên, lúc bấy giờ chiếu xạ được xem là một “phương pháp nhạy cảm”. Người ta lo lắng không biết thực phẩm đã qua chiếu xạ có chứa các chất phóng xạ gây nguy hiểm cho sức khỏe hay không. Sau một thời gian dài nghiên cứu, các nhà khoa học nhiều nước trên thế giới kết luận: chiếu xạ là một phương pháp an toàn trong công nghiệp thực phẩm nếu sử dụng liều thích hợp tương ứng với từng loại thực phẩm. Ngày nay, nhiều quốc gia trên thế giới cho phép sử dụng chiếu xạ trong công nghiệp thực phẩm, trong đó có nhiều nước công nghiệp phát triển như Mỹ, Canada, Anh, Pháp, Đức, Hà Lan, Bỉ, Đan Mạch, Nga, Nhật, Australia... Việt Nam cũng nằm trong danh mục các nước cho phép sử dụng chiếu xạ trong công nghiệp thực phẩm.

Giá trị năng lượng mà tia bức xạ điện từ hoặc dòng electron truyền cho thực phẩm được gọi là **liều xạ** (irradiation dose). Trong hệ SI, liều xạ có đơn vị đo là **Gy (Gray)** , với:

1 Gy=10−2 kGy=10−5 MGy1 \text{ Gy} = 10^{-2} \text{ kGy} = 10^{-5} \text{ MGy}

Các tổ chức thế giới đã quy định liều xạ tối đa được phép sử dụng cho từng loại thực phẩm.

# Mục đích công nghệ và phạm vi thực hiện

## Bảo quản

Quá trình chiếu xạ có thể kéo dài thời gian bảo quản một số loại thực phẩm do nhiều nguyên nhân khác nhau:

  * Chiếu xạ sẽ ức chế hoặc tiêu diệt một số loại côn trùng, sâu bọ và vi sinh vật. Sự hư hỏng của thực phẩm bởi các tác nhân này, đặc biệt là vi sinh vật, có thể xảy ra rất nhanh. Do đó, việc làm giảm mật độ vi sinh vật sẽ gia tăng thời hạn sử dụng sản phẩm. Quá trình chiếu xạ được sử dụng phổ biến trong công nghệ sau thu hoạch trái cây và rau tươi, ngũ cốc, thịt và thủy sản tươi. Ngoài ra, chiếu xạ còn được sử dụng trong sản xuất một số loại bột gia vị (tiêu bột, ớt bột...) và các loại bột trái cây, bột rau (ví dụ: bột măng tây khô).

  * Khi chiếu xạ với liều lượng thích hợp, quá trình chín sau thu hoạch và quá trình lão hóa ở một số loại trái cây sẽ bị chậm lại, ví dụ: chuối, xoài, đu đủ. Quá trình chiếu xạ làm chậm quá trình trao đổi chất trong các loại trái cây này, kéo dài thời gian bảo quản mà không phụ thuộc hoàn toàn vào việc ức chế vi sinh vật.

  * Chiếu xạ có thể gây ức chế sự nảy mầm ở một số loại thực vật như khoai tây, củ hành, tỏi, gừng. Nhờ đó, thời gian bảo quản những nguyên liệu này được kéo dài, giảm tỷ lệ tổn thất do nảy mầm.


## Chuẩn bị

Chiếu xạ có thể được xem là một quá trình chuẩn bị nguyên liệu cho các giai đoạn khai thác và chế biến:

  * Khi chiếu xạ đại mạch với liều thấp (10–100 Gy), sự nảy mầm của hạt được kích thích, giúp quá trình ươm mầm diễn ra thuận lợi và nhanh hơn. Chiếu xạ được xem là bước chuẩn bị cho quá trình ươm mầm trong sản xuất malt.

  * Khi chiếu xạ nho với liều 2–7 kGy, quá trình ép thu nhận dịch nho diễn ra dễ dàng hơn, hiệu suất thu hồi chất chiết trong nước nho tăng cao so với mẫu đối chứng không qua chiếu xạ. Quá trình chiếu xạ nho được xem là bước chuẩn bị cho sản xuất nước ép trái cây hoặc rượu vang.


## Hoàn thiện

Chiếu xạ có thể cải thiện một số chỉ tiêu chất lượng sản phẩm. Ví dụ, trong công nghệ sản xuất súp ăn liền, chiếu xạ sẽ làm gãy mạch một số phân tử carbohydrate dài, nhờ đó chúng dễ hydrat hóa hơn khi pha với nước, cải thiện chất lượng súp.

Hiện nay, mục đích chính của chiếu xạ thực phẩm vẫn là **kéo dài thời gian bảo quản sản phẩm**.

# Các biến đổi của nguyên liệu

## Vật lý

Khi chiếu tia gamma hoặc dòng electron lên mẫu thực phẩm, các photon hoặc electron trong chùm chiếu sẽ tác động lên các hạt vật chất của nguyên tử. Nguyên tử gồm proton, neutron và electron. Proton và neutron nằm trong nhân, electron chuyển động quanh hạt nhân theo quỹ đạo xác định. Với liều xạ sử dụng trong công nghiệp thực phẩm, photon và electron của chùm chiếu không tác động đến proton và neutron; chúng chỉ tác động lên electron của nguyên tử.

**Sử dụng tia gamma:**  
Khi photon gamma chiếu vào thực phẩm, có thể xảy ra hai trường hợp:

  1. Photon xuyên qua mẫu, truyền một phần năng lượng.

  2. Photon bị hấp thu toàn bộ năng lượng.


Hai kiểu tương tác giữa photon và electron:

  * **Hiệu ứng quang điện (Photoelectric effect):**  
Photon tác động lên electron, tách electron ra khỏi nguyên tử, photon biến mất. Nguyên tử mất electron bị ion hóa và electron thứ cấp được sinh ra. Electron thứ cấp tiếp tục gây ion hóa các electron khác.


  * **Hiệu ứng Compton:**  
Photon tác động tách electron, nhưng photon vẫn tồn tại với năng lượng giảm và quỹ đạo thay đổi. Photon và electron thứ cấp đều có thể tiếp tục tương tác với các electron khác.


**Sử dụng dòng electron:**  
Electron từ nguồn chiếu tác động lên electron của nguyên tử trong mẫu (tương tác Coulomb), dẫn đến:

  1. Tách electron ra khỏi nguyên tử → tạo electron thứ cấp, ion hóa nguyên tử.

  2. Thay đổi quỹ đạo electron → nguyên tử bị kích thích.


**Lưu ý:** Khả năng xuyên qua của tia gamma cao hơn dòng electron, là lý do phổ biến trong chiếu xạ thực phẩm.

## Hóa học

### Nước

Phân tử nước có thể biến đổi qua:

  * **Ion hóa:**


  * **Kích thích:**


Các gốc tự do (H·, OH·) có thể phản ứng tạo ra hợp chất mới:

### Polysaccharide

Các polysaccharide như tinh bột, pectin, cellulose, hemicellulose... có thể bị gãy mạch, tạo sản phẩm phân tử thấp.

  * Lợi: trong súp ăn liền, polysaccharide gãy → dễ hydrat hóa, cải thiện chất lượng.

  * Hại: chiếu xạ trái cây tươi liều cao → làm mềm trái cây, giảm giá trị cảm quan.


### Protein

Với liều xạ cho phép, protein hầu như không thay đổi về cấu trúc và tính chất hóa học. Liều thấp cũng không ảnh hưởng hàm lượng acid amin tự do.

### Lipid

Trong điều kiện có oxy, acid béo, đặc biệt là không no, dễ oxy hóa. Gốc tự do sinh ra từ phân tử nước và các hợp chất khác phản ứng với acid béo không no, tạo aldehyde, ketone, hydrogen peroxide… ảnh hưởng xấu đến giá trị dinh dưỡng và cảm quan.

### Khoáng

Các hợp chất khoáng không biến đổi đáng kể.

### Vitamin

Mức độ tổn thất phụ thuộc liều xạ:

  * Liều 1 kGy: nhóm trái cây có múi không mất vitamin C.

  * Liều 2–4 kGy: lượng vitamin C giảm mạnh.


### Acid nucleic

Biến đổi DNA/RNA:

  * Gãy mạch phân tử, tạo nhánh hoặc cả hai nhánh.

  * Hydroxyl hóa các base (A, T, G, C, U).

  * Phân hủy đường ribose/desoxyribose.

  * Tạo cầu nối ngẫu nhiên giữa các mạch DNA.


### Các hợp chất khác

Các hợp chất sinh học, màu, mùi… thay đổi tùy liều xạ. Ví dụ, carotenoids trong đu đủ 1,5 kGy không biến đổi đáng kể.

## Hóa lý

Chiếu xạ không ảnh hưởng trạng thái pha của thực phẩm.

## Sinh học

Chiếu xạ làm biến đổi acid nucleic → ảnh hưởng cấu trúc nhân tế bào vi sinh vật.

  * Tế bào vi sinh vật có hệ enzyme (ligase, exonuclease, polymerase…) sửa chữa DNA, duy trì trao đổi chất.

  * Nếu tổn thương quá lớn → tế bào chết hoặc không sinh sản được.

  * Có thể gây đột biến ở một số vi sinh vật.

  * Chiếu xạ còn tổn thương phospholipid màng tế bào, làm giảm vận chuyển chất, giảm hoạt tính trao đổi chất hoặc gây chết vi sinh vật.


Khả năng tiêu diệt vi sinh vật của tia gamma phụ thuộc loài. **Liều xạ phá hủy thập phân** : liều cần thiết để giảm số vi sinh vật xuống 10 lần.

# Public_026

# KHÁI NIỆM CHUNG

Vật liệu dệt là một ngành chuyên môn nghiên cứu **về cấu tạo, tính chất của các loại xơ, sợi và chế phẩm dệt** , cùng những phương pháp xác định cấu tạo và các tính chất đó.

Đối tượng nghiên cứu của vật liệu dệt bao gồm tất cả các loại xơ và sản phẩm làm ra từ xơ, như: sợi đơn (sợi con), sợi xe, chỉ khâu, hàng dệt kim, các loại dây lưới… Ngoài những sản phẩm kể trên có thể sử dụng trực tiếp, vật liệu dệt còn bao gồm các loại bán thành phẩm chưa dùng trực tiếp được như quả hông, cứu, sợi thô.

Hiểu biết về đặc trưng cấu tạo và tính chất của vật liệu dệt có liên quan trực tiếp đến việc sản xuất các loại hàng dệt **có phẩm chất đáp ứng yêu cầu sử dụng** , cũng như thực hiện các biện pháp tiết kiệm, hợp lý trong sản xuất (ví dụ: đay có tính hút ẩm tốt và xơ bền nên dùng để sản xuất các loại bao bì đựng đường, muối rất thích hợp).

Nghiên cứu cấu tạo và tính chất của vật liệu dệt còn có ý nghĩa trong việc **thiết lập tiêu chuẩn thử nghiệm ngành dệt** , quy định phương pháp chọn mẫu thí nghiệm, kiểm tra chất lượng sản phẩm, quy định về hình thức, kích thước của chế phẩm và bán chế phẩm.

Các loại xơ, sợi và chế phẩm dệt được sử dụng rộng rãi trong thực tế sản xuất và đời sống hàng ngày. Ngoài việc may mặc, vải còn được dùng trong công nghiệp, y tế và các lĩnh vực sinh hoạt văn hóa, xã hội. Ví dụ: vải may quần áo chống nóng dùng trong luyện kim, trang phục bảo hộ cứu hỏa, lưới đánh cá, các loại dây, chỉ khâu trong y tế, vải dù, dây dù, vải bạt trong quân đội, vải che phủ thiết bị máy móc và làm lán trại.

Theo số liệu thống kê ở nhiều nước, chế phẩm dệt bằng vật liệu dệt được sử dụng như sau:


| Mục đích sử dụng | Tỷ lệ (%) |
| --- | --- |
| May mặc | 35–40 |
| Nội trợ, sinh hoạt | 20–25 |
| Mục đích kỹ thuật | 30–35 |
| Các công việc khác (bao gói, văn hóa phẩm, y tế…) | ~10 |

 

Sản lượng các loại xơ, sợi dệt trên thế giới tăng nhanh trong những thập kỷ gần đây, đặc biệt là sản xuất các loại xơ tổng hợp.

# PHÂN LOẠI VẬT LIỆU DỆT

Các loại xơ, sợi được liệt kê trên có thể thay đổi tùy theo từng nước, phụ thuộc vào điều kiện công nghiệp phát triển, khí hậu và chế độ xã hội. Vật liệu dệt được phân biệt dựa theo **hình dạng, đặc trưng cấu tạo và tính chất** , vì vậy chế phẩm dệt sản xuất ra cũng được phân loại theo nguyên liệu.

Để nghiên cứu tính chất vật liệu dệt thuận tiện, cần tiến hành phân loại. **Nguyên tắc phân loại vật liệu dệt** dựa vào: kết cấu đặc biệt, phương pháp sản xuất, thành phần hóa học của các loại xơ.

Trong phân loại vật liệu dệt, bao gồm: **xơ, sợi và chế phẩm dệt**.

## XƠ DỆT

### Khái niệm

Xơ là những vật thể mềm dẻo, giãn nở (bông, len), nhỏ bé, dùng để làm sợi, vải. Chiều dài đo bằng milimet (mm), kích thước ngang đo bằng micromet (µm).

### Phân loại

Phần lớn xơ dệt có cấu tạo thuộc dạng liên kết cao phân tử. Tuy nhiên, do nguồn gốc, thành phần cấu tạo và phương pháp tạo xơ khác nhau, mỗi loại xơ được chia thành các nhóm riêng biệt theo nguồn gốc.

**Các loại xơ:**

  1. **Xơ thiên nhiên:** Hình thành trong điều kiện tự nhiên từ các chất hữu cơ. Gồm:


  * **Xơ cơ bản:** Không phá vỡ theo chiều dọc xơ thì không thể chia nhỏ.

  * **Xơ kỹ thuật:** Ghép nhiều xơ cơ bản lại với nhau (xơ lay).


**Xơ thiên nhiên chia thành:**

  * **Xơ thực vật:** Thành phần chủ yếu là xenlulozơ, ví dụ: xơ hồng (từ quả hồng), xơ tẩy, gel, lanh (từ thân cây).

  * **Xơ động vật:** Thành phần chủ yếu là protein, ví dụ:

* Xơ len: keratin chiếm 50%

* Xơ tơ tằm: fibroin chiếm 75%, sericin 25%

  * **Xơ khoáng vật:** Tạo từ chất vô cơ thiên nhiên, ví dụ xơ trăng.


  2. **Xơ hóa học:** Hình thành trong điều kiện nhân tạo.


  * **Xơ nhân tạo:** Tạo từ chất hữu cơ thiên nhiên, ví dụ:

* Nhóm xơ từ hydrat xenlulozơ: viscose, cuprammonium…

* Nhóm xơ từ axetyl xenlulozơ: cellulose acetate, triacetate

* Nhóm xơ từ mô tơ tự nhiên: capron, đen

  * **Xơ tổng hợp:** Tạo từ chất tổng hợp, phổ biến nhất hiện nay, ví dụ: polyester, polyamide, polyacrylonitrile.


Xơ hóa học được sản xuất dưới nhiều dạng: xơ staple, sợi cơ bản, sợi phức. Quá trình sản xuất: nguyên liệu (từ thiên nhiên hoặc tổng hợp) chế biến thành dung dịch hoặc trạng thái nóng chảy, ép qua ống định hình sợi (lỗ nhỏ tùy yêu cầu sản xuất), tạo sợi cơ bản. Sợi cắt đoạn gọi là xơ staple (thường 40–15 mm). Có thể tạo sợi đơn dùng trực tiếp cho chế phẩm như lưới đánh cá, bít tất mỏng.

## SỢI DỆT

Sợi là sự liên kết của các xơ có kích thước nhỏ, mềm, uốn dẻo và bền. Chiều dài sợi được xác định trong quá trình gia công.

### Phân loại theo cấu trúc

#### **Loại sợi thứ nhất:** Dạng sợi nhận trực tiếp sau quá trình kéo sợi:

  * **Sợi con (sợi đơn):** Nhiều xơ cơ bản ghép và xoắn lại (ví dụ: sợi bông, sợi len). Chiếm ~85% sản lượng thế giới.

* **Sợi trơn:** Kết cấu và màu sắc đồng đều.

* **Sợi hoa:** Kết cấu không đồng đều, chỗ dày mỏng khác nhau, nhiều màu sắc do quá trình sản xuất.

  * **Sợi phức:** Nhiều sợi cơ bản liên kết bằng xoắn hoặc dính, thường là sợi hóa học (trừ sợi tơ tằm).

  * **Sợi cử:** Tạo bằng cách xe xoắn các dải băng (giấy, nhựa, kim loại).


#### **Loại sợi thứ hai:** Ghép và xoắn các loại sợi thứ nhất thành sợi xe.

### Phân loại theo nguyên liệu và thiết bị kéo sợi

  1. **Sợi chỉ thường (chải thô):** Nguyên liệu xơ trung bình, kéo trên dây chuyền máy chải thô, cho sợi chất lượng trung bình (sợi bông, sợi đay).

  2. **Sợi chỉ kỹ:** Nguyên liệu xơ dài, tốt, kéo trên dây chuyền máy chủ thôn và chủ kỹ, sản xuất sợi chất lượng cao (sản xuất chỉ khâu, hàng dệt kim, vải cao cấp).

  3. **Sợi chi liên hợp:** Nguyên liệu xơ ngắn, chất lượng thấp, xơ phế liệu trộn, kéo trên dây chuyền nhiều máy, tạo sợi xốp dùng dệt chăn, mền, đồ nội thất.


### Phân loại theo quá trình sản xuất và sử dụng

  * **Sản phẩm mộc:** Xơ, sợi hay vải còn ở dạng nguyên liệu chưa xử lý hóa lý, dùng làm phụ liệu hoặc nguyên liệu cho ngành sản xuất khác. Ví dụ: sợi đưa vào sản xuất chỉ khâu là sợi mộc từ máy xe và máy quấn ống.

  * **Sản phẩm hoàn tất:** Xơ, sợi hay vải đã qua xử lý hóa lý (nấu, tẩy, nhuộm, in, định hình nhiệt, tẩm hóa chất chống nhăn, chống thấm). Sản phẩm hoàn tất được bày bán rộng rãi. Ngành may sử dụng chủ yếu **vải hoàn tất** và **chỉ khâu**.

# Public_027

# 1\. TÍNH CHẤT LÝ HÓA CỦA SỢI DỆT

## Xơ xenlulô (Cotton)

**Xenlulô** là polyme chính của các loại xơ gốc thực vật (bông, lanh, gai…).
**Công thức hóa học:** (C6H10O5)n(C_6H_{10}O_5)_n
**Khối lượng riêng:** 1,52 – 1,56 g/cm³
**Các tính chất chủ yếu của xơ xenlulô (xơ bông)**

### Ảnh hưởng của nước

  * Xenlulô không tan trong nước, cồn, benzen, axit loãng… Để hòa tan xenlulô thường dùng dung dịch amôniac đồng [Cu(NH3)4](OH)2[Cu(NH_3)_4](OH)_2.

  * Trong nước, xơ bông bị trương nở, diện tích mặt cắt ngang tăng 22–34%, chiều dài chỉ tăng ~1%.


### Ảnh hưởng của ánh sáng mặt trời

  * Dưới tác dụng ánh sáng mặt trời và khí quyển, đặc biệt tia tử ngoại, các phần tử xenlulô bị oxy hóa, làm giảm độ bền. Chiếu trực tiếp trong 900–1000 giờ có thể làm giảm độ bền một nửa.

  * Khí quyển cũng gây lão hóa, giảm độ bền cơ học, giảm độ dãn nở, tăng độ cứng. Quá trình mạnh hơn khi nhiệt độ và độ ẩm cao.


### Ảnh hưởng của nhiệt độ

  * Đốt nóng xơ xenlulô ở 120–130°C vài giờ không gây thay đổi đáng kể.

  * Trên 160°C, quá trình phá hủy bắt đầu nhanh hơn; 180°C phá hủy mạnh các phần tử xenlulô.

  * Nếu đốt trong trạng thái khô, xenlulô tạo than (~40% khối lượng), nước, CO₂ và các chất khác.

  * Với quần áo bằng cotton, không nên sử dụng nhiệt độ quá 100°C.


### Ảnh hưởng của axit

  * Axit vô cơ phá hủy đại phân tử xenlulô, cắt liên kết glucôzit → thủy phân thành glucose:

  * Axit hữu cơ tác dụng yếu hơn.

  * Xenlulô tác dụng với HNO₃ tạo nitrat xenlulô (10,5–12% N), dùng làm nguyên liệu xơ nhân tạo đầu tiên.

  * Axetyl xenlulô (este của axit axetic) dùng sản xuất xơ axetat và triacetat.


### Ảnh hưởng của chất oxy hóa

  * Với Na₂S₂O₃, tính chất xơ không thay đổi → dùng tẩy trắng an toàn.

  * Bột tẩy trắng, muối Na, K… có thể làm giảm độ bền hoặc phá hủy xơ.


### Ảnh hưởng của kiềm

  * Xenlulô bền với kiềm, NaOH không phá vỡ liên kết glucôzit nhưng có thể oxy hóa khi có O₂ → xenlulô kiềm:

  * Ứng dụng: làm tăng độ bền khi kéo sợi, bề mặt sợi tròn hơn, nhẵn hơn, phản chiếu ánh sáng tốt.

  * Quá trình NaOH quá mạnh hoặc kéo căng → phá hủy hoàn toàn xơ.


### Ảnh hưởng của vi sinh vật

  * Xơ ẩm lâu trong không khí ẩm → vi khuẩn, nấm mốc phát triển → thủy phân xenlulô, phá hủy cấu trúc phân tử.


### Ứng dụng

  * Dùng may quần áo mùa hè, trang phục trẻ em, người già, người bệnh, lao động, quân đội.

  * Vải cotton thích hợp cho đồ dùng sinh hoạt hút ẩm tốt: áo gối, chăn mền, khăn tay, khăn tắm, khăn bàn, giày vải…

  * Giặt bằng xà phòng kiềm, phơi nơi khô ráo, tránh nắng trực tiếp.

  * **Ưu điểm:** hút ẩm cao, ít tĩnh điện, thích hợp may mặc.

  * **Nhược điểm:** dễ hỏng do vi sinh vật, không chịu được axit mạnh.


## Xơ protein (Len, Tơ tằm)

### Tơ tằm

  * Tơ tằm là sợi tự nhiên, chiếm >90% sản lượng tơ. Tằm ăn lá dâu → chất lỏng tiết ra → đông cứng thành sợi tơ.

  * Việt Nam: nuôi tằm ở Hà Tây, Hòa Bình, Nam Hà, Thái Bình, Nghệ Tĩnh, Phú Thọ, Lâm Đồng.

  * Chu kỳ sinh trưởng: trứng → tằm → kéo kén → nhộng → ngài (bướm).


**Cấu tạo kén tằm:**

  * Lớp ngoài: sợi cứng, nhiều keo, dùng dệt lụa gốc hoặc đan lưới.

  * Lớp giữa: sợi mềm mịn, dùng dệt lụa.

  * Lớp trong: không ươm tơ, dùng kéo sợi đũi.


**Tính chất cơ lý:**

  * Fibroin: 75% thành phần tơ.

  * Khối lượng riêng: 1,37 g/cm³.

  * Độ dài: 300–1500 m/kén.

  * Độ mảnh, độ bền: cao hơn xơ bông.


**Ảnh hưởng của nước, nhiệt độ, ánh sáng, axit, kiềm và chất oxy hóa:**

  * Nước: trương nở 16–20% chiều ngang, chiều dài tăng 1–2%.

  * Nhiệt độ: 130–140°C không thay đổi tính chất; trên 170°C phá hủy tơ.

  * Ánh sáng: tia tử ngoại làm oxy hóa → giảm độ bền 50% sau 200 giờ.

  * Axit: axit mạnh và nhiệt độ cao phá hủy nhanh.

  * Kiềm: phá hủy tùy nhiệt độ và nồng độ dung dịch.

  * Chất oxy hóa: H₂O₂, Na₂O₂ phá hủy màu, làm trắng.


**Ứng dụng:**

  * Dệt vải mỏng, may quần áo, sản xuất phế phẩm sợi, chỉ khâu, chỉ thêu.

  * Giặt bằng xà phòng trung tính, tránh ánh sáng trực tiếp, là ở 140–150°C.


### Len

  * Len lấy từ lông phủ của cừu, thỏ, dê, lạc đà. Lông cừu chiếm 96–97%, dê 2%, lạc đà 1%.

  * Thành phần cơ bản: keratin 50–90%.


**Phân loại:**

  * Len mịn: đồng nhất, lông cừu mịn (Merino) hoặc cừu lai.

  * Len nửa mịn: lông tơ kích thước 25–31 µm.

  * Len nửa thô: hỗn hợp lông tơ, lông thô, 31–40 µm.

  * Len thô: hỗn hợp lông tơ, lông thô, lông chết, >34 µm.


**Tính chất cơ lý:**

  * Khối lượng riêng: 1,3 g/cm³.

  * Độ bền: kém hơn tơ tằm.


**Ảnh hưởng của hơi nước, nhiệt độ, ánh sáng, axit, kiềm và chất oxy hóa:**

  * Hơi nước 25°C: diện tích mặt cắt tăng 26%, chiều dài tăng 1,2%.

  * Hơi nước 100°C: giảm độ bền đáng kể (3h giảm 18%, 6h giảm 23%, 60h giảm 74%).

  * Nhiệt độ 130–140°C ngắn: không thay đổi. 80–100°C lâu: cứng, giòn, giảm độ bền và màu. 170–200°C: phá hủy.

  * Ánh sáng: chiếu trực tiếp 1120h giảm độ bền 50%.

  * Axit: axit trung bình ít ảnh hưởng, axit mạnh + nhiệt độ cao → phá hủy.

  * Kiềm: phá hủy nhanh, phụ thuộc nhiệt độ và nồng độ.

  * Oxy hóa: H₂O₂, Na₂O₂ phá hủy màu, làm trắng.


**Ứng dụng:**

  * Sử dụng nguyên chất hoặc pha với xơ hóa học, kéo sợi, dệt kim, may khăn, bít tất, giày, lót, đệm…

  * Quần áo mùa đông: manteau, áo khoác…

  * Giặt: xà phòng trung tính, giặt khô cho hàng cao cấp.

  * Bảo quản: nơi khô ráo, tránh côn trùng.

# Public_028

Sự phát triển của ngành công nghiệp điện tử như chúng ta thấy ngày nay bắt đầu với sự phát minh ra **Transistor**. Cách thức hoạt động của transistor có thể được hiểu dễ dàng nếu bạn đã có kiến thức về **Diode bán dẫn**. Việc thêm một lớp khác vào một diode mối nối P-N tạo thành một thiết bị **3 đầu cuối** được gọi là **Transistor**. Thuật ngữ transistor thường đề cập đến **Transistor Bipolar Junction (BJT)**.

Transistor đã được kiểm chứng thành công vào ngày **23/12/1947** tại Phòng thí nghiệm Bell, New Jersey. Ba cá nhân được ghi nhận phát minh ra transistor là **John Bardeen, William Shockley và Walter Brattain** , trong đó William Shockley đóng vai trò quan trọng trong việc phát minh.

**Các ứng dụng của Transistor lưỡng cực (BJT) bao gồm:**

  * Ti vi

  * Điện thoại di động

  * Máy tính

  * Thiết bị phát sóng vô tuyến

  * Bộ khuếch đại âm thanh …


# Cấu tạo – Ký hiệu

## Cấu tạo

Giống như diode mối nối P-N, một BJT cũng được tạo thành từ sự kết hợp của các lớp bán dẫn loại P và loại N. Tuy nhiên, transistor có thể chứa:

  * Một lớp P giữa hai lớp N → **Transistor NPN**

  * Một lớp N giữa hai lớp P → **Transistor PNP**


Transistor có ba thiết bị đầu cuối ( **3 chân ra** ):

  * **Emitter (Bộ phát)**

  * **Base (Cơ sở / Đế / Lớp nền)**

  * **Collector (Bộ thu)**


**Cấu tạo cụ thể:**

**Transistor NPN:**

  * Emitter kết nối với lớp N bên trái

  * Collector kết nối với lớp N bên phải

  * Base kết nối với lớp P ở giữa


**Transistor PNP:**

  * Emitter kết nối với lớp P bên trái

  * Collector kết nối với lớp P bên phải

  * Base kết nối với lớp N ở giữa


Transistor có **hai mối nối P-N** :

  1. **Emitter-Base (E-B)**

  2. **Base-Collector (B-C)**


## Thiết bị đầu cuối của BJT

  * **Emitter:**  
Cung cấp các điện tích. Emitter được pha tạp nặng để bơm nhiều hạt mang điện vào Base. Kích thước E > Base.

  * **Base:**  
Lớp giữa, rất mỏng, pha tạp nhẹ, nồng độ tạp chất thấp nhất.

  * **Collector:**  
Thu thập các hạt mang điện, pha tạp vừa phải. Kích thước lớn hơn Emitter và Base, để xử lý năng lượng và tản nhiệt tốt.


## Ký hiệu

Transistor được xem như **hai diode mắc chung Anode hoặc Cathode** :

  * **NPN:** chung Anode

  * **PNP:** chung Cathode


# Nguyên lý hoạt động

## Nguyên lý làm việc của Transistor NPN

Khi không có điện áp cấp cho transistor NPN → **không phân cực**.

  * **Lớp N (Emitter & Collector):** điện tử tự do là hạt dẫn đa số, lỗ trống là hạt mang điện thiểu số.

  * **Lớp P (Base):** điện tử tự do là hạt mang điện thiểu số, lỗ trống là hạt dẫn đa số.


Các hạt mang điện luôn di chuyển từ vùng nồng độ cao → nồng độ thấp:

  * Điện tử: từ N (n-region) → P (p-region)

  * Lỗ trống: từ P (p-region) → N (n-region)


Quá trình này tạo ra **vùng nghèo kiệt (depletion region)** tại mối nối **B-E** và **B-C**.

### Tại sao vùng nghèo kiệt thâm nhập nhiều hơn về phía pha tạp nhẹ?

  * Doping là quá trình thêm tạp chất vào chất bán dẫn để tăng dẫn điện.

  * **Pha tạp nặng:** nhiều hạt mang điện, dẫn điện cao

  * **Pha tạp nhẹ:** ít hạt mang điện, dẫn điện thấp


Trong **Transistor NPN** :

  * **Emitter (N):** pha tạp nặng → nhiều điện tử tự do

  * **Base (P):** pha tạp nhẹ → ít lỗ trống

  * **Collector (N):** pha tạp vừa phải → nồng độ giữa Emitter và Base


### Nguyên tử và ion trong bán dẫn

  * Nguyên tử nhường electron → **ion dương**

  * Nguyên tử nhận electron → **ion âm**

  * Nguyên tử cho electron → **nhà tài trợ (donor)**

  * Nguyên tử nhận electron → **người nhận (acceptor)**


## Mối nối B- E(Emitter-base junction)

### n lỗ trống từ Base sang Emitter:

  * Đồng thời, các **lỗ trống** trong vùng p (Base) di chuyển sang vùng n (Emitter).

  * Tuy nhiên, vì Emitter được pha tạp nặng, số lỗ trống đi vào Emitter chỉ là một phần rất nhỏ so với số electron đi sang Base.


### Tương tác nguyên tử tại mối nối

Tại **mối nối B-E** , khi các electron từ Emitter di chuyển vào Base:

  * Mỗi nguyên tử trong **n-region (Emitter)** nhường electron cho các nguyên tử lỗ trống trong **p-region (Base)**.

  * Ví dụ: nếu mỗi nguyên tử Emitter nhường **3 electron tự do** , thì **3 nguyên tử trong Base** sẽ nhận các electron này.

  * Khi nguyên tử Emitter nhường electron → trở thành **ion dương** , do mất electron.

  * Khi nguyên tử Base nhận electron → trở thành **ion âm** , do thêm electron vào lỗ trống.


Kết quả của quá trình này là:

  1. Hình thành **vùng nghèo kiệt (depletion region)** tại mối nối B-E:

* Vùng này chứa các **ion dương cố định** ở phía Emitter và **ion âm cố định** ở phía Base.

* Vùng nghèo kiệt này tạo ra một **điện trường nội** ngăn cản dòng electron và lỗ trống tự do tiếp tục khuếch tán một cách quá mức.

  2. Dòng điện chủ yếu là **electron từ Emitter sang Base** :

* Chỉ một phần nhỏ electron kết hợp với lỗ trống trong Base, số còn lại đi vào **Collector** nhờ hiệu ứng điện trường tại mối nối Base-Collector.


### Tóm tắt cơ chế hoạt động B-E

  * **Emitter:** cung cấp electron tự do với nồng độ cao.

  * **Base:** mỏng, pha tạp nhẹ, chứa lỗ trống nhưng ít electron.

  * **Khuếch tán:** electron từ Emitter sang Base, lỗ trống từ Base sang Emitter.

  * **Vùng nghèo kiệt:** ion dương Emitter và ion âm Base hình thành điện trường nội.

  * **Dòng điện chủ yếu:** từ Emitter sang Collector qua Base, cơ chế này giúp transistor hoạt động như **bộ khuếch đại dòng điện**.

# Public_029

# Chất bán dẫn (Semiconductor)

Chất bán dẫn là những vật liệu có khả năng dẫn điện trung gian giữa chất dẫn điện tốt (kim loại) và chất cách điện. Các vật liệu bán dẫn phổ biến gồm **silic (Si)** , **germanium (Ge)** và **gallium arsenide (GaAs)**. Chúng không phải là chất dẫn điện tốt nhưng cũng không phải là chất cách điện hoàn hảo, do đó chúng được gọi là **"bán dẫn"**.

Chất bán dẫn tinh khiết có rất ít **electron tự do** vì các nguyên tử của chúng được sắp xếp trong một **mạng tinh thể**. Tuy nhiên, dưới một số điều kiện nhất định hoặc khi được thêm các tạp chất thích hợp, các electron có thể di chuyển và dẫn điện.

Khả năng dẫn điện của chất bán dẫn có thể được **cải thiện đáng kể** bằng cách **thêm các nguyên tử tạp chất** vào mạng tinh thể. Các nguyên tử này có thể cung cấp thêm electron hoặc tạo ra nhiều lỗ trống (hole), từ đó thay đổi tính chất dẫn điện của vật liệu. Quá trình này được gọi là **doping**.

## Bán dẫn thuần khiết (Pure Semiconducting)

Chất bán dẫn thuần khiết như **Silicon (Si)** và **Germanium (Ge)** về mặt hóa học không chứa tạp chất.

  * Mỗi nguyên tử **silicon** có **4 electron hóa trị** trong lớp vỏ ngoài cùng.

  * Các nguyên tử silicon chia sẻ electron với các nguyên tử lân cận để tạo ra **liên kết cộng hóa trị bền vững** , giúp mỗi nguyên tử silicon đạt được **8 electron ở lớp vỏ ngoài**.


Trong silicon tinh khiết, có rất ít electron tự do để di chuyển quanh mạng tinh thể. Vì vậy, **silicon tinh khiết hoặc germanium tinh khiết** hoạt động giống như chất cách điện, có điện trở cao.

Để silicon có thể dẫn điện, cần tạo ra **cực dương (+) và cực âm (-)** thông qua việc **doping silicon với một số tạp chất nhất định**.

## Bán dẫn loại N (N-type Semiconductor)

Để tạo **bán dẫn loại N** , các nguyên tử tạp chất có **5 electron hóa trị** (pentavalent) như **Phốt pho (P)** , **Arsenic (As)** hoặc **Antimon (Sb)** được thêm vào tinh thể silicon.

  * 4 trong 5 electron hóa trị của nguyên tử tạp chất sẽ tạo liên kết cộng hóa trị với các nguyên tử silicon lân cận.

  * Electron thứ 5 còn dư trở thành **electron tự do** , có thể di chuyển trong mạng tinh thể khi có điện áp, trở thành **hạt mang điện**.


Các nguyên tử pentavalent được gọi là **chất cho (donor)** vì chúng cung cấp electron tự do.

  * **Vật liệu loại N** có **điện tích âm dư thừa** do electron tự do chiếm ưu thế so với các lỗ trống.

  * **Hạt dẫn đa số** là electron, **hạt dẫn thiểu số** là lỗ trống.


Khi bị kích thích bởi nguồn điện hoặc nhiệt, electron tự do từ các nguyên tử tạp chất này dễ dàng di chuyển, tạo ra dòng điện trong silicon loại N.

## Bán dẫn loại P (P-type Semiconductor)

Ngược lại, để tạo **bán dẫn loại P** , các nguyên tử tạp chất **3 electron hóa trị** (trivalents) như **Nhôm (Al)** hoặc **Bo (B)** được thêm vào silicon.

  * Mỗi nguyên tử tạp chất loại P tạo ra một **lỗ trống** trong mạng tinh thể, nơi electron có thể di chuyển để lấp vào.

  * **Hạt dẫn đa số** là **lỗ trống** , **hạt dẫn thiểu số** là electron.


### Dòng điện trong chất bán dẫn loại P

  * Khi có điện áp, các **electron tự do** di chuyển đến cực dương (+) để lấp vào các lỗ trống.

  * Khi electron lấp vào lỗ trống, lỗ mới lại xuất hiện ở vị trí khác.

  * Quá trình này lặp lại, tạo ra **dòng chuyển động của lỗ trống về phía cực âm (-)** , đồng thời electron di chuyển về phía cực dương (+).


Như vậy, trong chất bán dẫn loại P, **electron thực sự di chuyển về cực dương** , còn **lỗ trống** di chuyển theo hướng ngược lại, tạo ra dòng điện.

## Chuyển động của electron và lỗ trống trong chất bán dẫn

  * **Electron** là hạt mang điện thực sự đang di chuyển trong mạng tinh thể.

  * **Lỗ trống** xuất hiện như một hạt tích điện dương, di chuyển ngược chiều electron.


Nhờ cơ chế này, cả chất bán dẫn loại P và loại N đều dẫn điện, nhưng không tốt bằng kim loại. **Điểm đặc biệt của chất bán dẫn** là khả năng **kiểm soát dòng điện** bằng cách thay đổi điều kiện điện áp, nhiệt độ, hoặc ánh sáng, thông qua việc sử dụng **mối nối P-N**.

## Mối nối P-N (P-N Junction)

Mối nối P-N được tạo ra khi **bán dẫn loại P** được ghép với **bán dẫn loại N** :

  * **Diode P-N** là thiết bị cơ bản xuất phát từ mối nối P-N, cho phép dòng điện đi theo một hướng nhất định.

  * Khi **P nối cực dương (+)** và **N nối cực âm (-)** :

* Các **electron** từ N di chuyển vào P.

* Các **lỗ trống** từ P di chuyển vào N.


Quá trình tái hợp tại mối nối

  * Khi electron gặp lỗ trống, chúng **tái hợp** và bị loại bỏ.

  * Các electron mới từ lớp N tiếp tục di chuyển vào lớp P, và các lỗ trống mới xuất hiện ở lớp P, duy trì dòng điện liên tục.


Mối nối P-N cho phép **dòng điện đi theo một hướng** , tạo cơ sở cho các thiết bị điện tử như **diode, transistor, LED, và IC**.

### Cấu trúc mối nối P-N

Mối nối P-N hình thành khi **bán dẫn loại P** (có lỗ trống là hạt dẫn đa số) được ghép với **bán dẫn loại N** (có electron tự do là hạt dẫn đa số). Khi hai loại bán dẫn này tiếp xúc:

  * **Electron** từ vùng N di chuyển sang vùng P để lấp vào các lỗ trống.

  * **Lỗ trống** từ vùng P di chuyển sang vùng N, nhưng thực tế các lỗ này không phải là vật chất, mà là sự “khuyết thiếu” electron, giúp dòng điện được hình dung.


Khi quá trình này diễn ra, tại **giao diện P-N** , một **vùng nghèo (depletion region)** hình thành.

### Vùng nghèo (Depletion Region)

  * Vùng nghèo là **khu vực gần mối nối** nơi các electron và lỗ trống đã tái hợp và bị loại bỏ, do đó **không còn hạt dẫn tự do**.

  * Trong vùng này tồn tại **các ion dương cố định** ở lớp N và **các ion âm cố định** ở lớp P.

  * Các ion này tạo ra một **điện trường nội** (internal electric field) hướng từ N → P, cản trở sự di chuyển của electron từ N sang P và lỗ từ P sang N.


Vùng nghèo là yếu tố quan trọng, vì nó xác định **điện áp chặn** và **điện áp phân cực thuận** của diode.

### Phân cực thuận (Forward Bias)

  * Khi **cực dương (+)** của nguồn nối vào **vùng P** và **cực âm (-)** nối vào **vùng N** :

* Điện áp ngoài **giảm bớt rào cản của vùng nghèo** , làm electron và lỗ dễ dàng vượt qua mối nối.

* Kết quả là **dòng điện lớn** chạy qua diode theo hướng thuận.

  * Trong phân cực thuận:

* Electron từ N đi vào P, lấp vào các lỗ trống.

* Lỗ từ P đi vào N, tạo dòng chuyển động ngược hướng electron.

* Quá trình tái hợp liên tục, cho phép dòng điện duy trì ổn định.


Điện áp cần thiết để diode bắt đầu dẫn điện thuận thường gọi là **điện áp ngưỡng** (~0,7 V đối với silicon và ~0,3 V đối với germanium).

### Phân cực ngược (Reverse Bias)

  * Khi **cực dương (+)** của nguồn nối vào **vùng N** và **cực âm (-)** nối vào **vùng P** :

* Điện áp ngoài **tăng rào cản vùng nghèo** , làm electron và lỗ khó di chuyển qua mối nối.

* Kết quả là **dòng điện rất nhỏ** , gần như bằng 0, gọi là **dòng rò ngược** (leakage current).

  * Điện trường nội cùng với điện áp ngược ngăn cản dòng electron từ N sang P, và lỗ từ P sang N.

  * Khi điện áp ngược đủ lớn, vùng nghèo có thể bị phá vỡ (breakdown), tạo ra **dòng điện lớn đột ngột** , cơ sở cho các thiết bị như **zener diode**.


### Tóm tắt hoạt động


| Điều kiện phân cực | Vùng nghèo | Dòng điện | Điện áp điển hình |
| --- | --- | --- | --- |
| Thuận (Forward) | Thu hẹp | Dẫn điện lớn | ~0,7 V (Si), 0,3 V (Ge) |
| Ngược (Reverse) | Mở rộng | Dòng rò nhỏ | Tùy vật liệu |
| Phá vỡ (Breakdown) | Bị phá hủy | Dòng lớn đột ngột | Zener: ~tùy chọn |

# Public_030

# Tụ điện (Capacitor)

## Giới thiệu về tụ điện (Introduction to Capacitors)

### Tụ điện là gì?

Tụ điện là linh kiện thụ động có khả năng tích trữ năng lượng điện trường dưới dạng điện tích khi áp một điện áp tĩnh (Static Voltage) trên các bản cực (plates) của nó. Tụ điện tích trữ năng lượng điện tương tự như một pin sạc nhỏ.

Có rất nhiều loại tụ điện khác nhau, từ các tụ điện rất nhỏ được sử dụng trong các mạch cộng hưởng, lọc nguồn, lọc tín hiệu, cho đến các tụ điện lớn dùng để bù công suất. Tuy khác nhau về kích thước và ứng dụng, tất cả đều có chức năng tương tự là lưu trữ điện tích.

### Cấu tạo tụ điện cơ bản

Trong dạng cơ bản, một tụ điện bao gồm hai hoặc nhiều tấm dẫn điện (kim loại) đặt song song, không nối hoặc chạm vào nhau. Để cách ly về điện, người ta sử dụng không khí hoặc các vật liệu cách điện tốt như giấy, sáp, mica, gốm, nhựa hoặc một số dạng gel lỏng dùng trong tụ điện phân cực. Lớp cách điện giữa các tấm thường được gọi là điện môi (Dielectric).

Do lớp cách điện này, dòng điện một chiều (DC) không thể chảy qua tụ điện; nó chỉ cho phép tạo ra điện áp trên các tấm dưới dạng điện tích (electrical charge). Các tấm kim loại dẫn điện của tụ điện có thể có hình vuông, hình tròn, hình chữ nhật, hoặc hình trụ, hình cầu. Hình dạng, kích thước và cấu trúc tấm song song phụ thuộc vào ứng dụng và mức điện áp của tụ điện.

### Nguyên lý hoạt động

Khi được sử dụng trong mạch điện một chiều (DC), tụ điện sẽ sạc lên đến điện áp cung cấp nhưng chặn dòng điện chạy qua nó do điện môi không dẫn điện.

Có hai loại điện tích: điện tích dương (+) dưới dạng proton và điện tích âm (−) dưới dạng electron. Khi một điện áp DC được đặt trên tụ điện, điện tích dương tích lũy trên một tấm, trong khi điện tích âm tích lũy trên tấm còn lại. Các tấm giữ điện tích cân bằng, tạo ra sự khác biệt điện áp giữa hai tấm. Khi đạt trạng thái ổn định, dòng điện không thể chảy qua tụ điện.

Khi kết nối với dòng điện xoay chiều (AC), dòng điện có thể đi qua tụ điện nhờ sự thay đổi liên tục điện áp. Dòng electron vào các tấm tụ điện được gọi là dòng điện sạc, chảy cho đến khi điện áp trên cả hai tấm bằng với điện áp cung cấp VcV_c. Khi đó tụ điện được gọi là “fully charged”.

## Các tham số chính của tụ điện (Main Parameters of the Capacitor)

### Điện dung của tụ điện

Điện dung là thước đo khả năng tụ điện lưu trữ điện tích giữa hai tấm của nó. Đơn vị điện dung là Farad (F), đặt theo tên nhà vật lý người Anh Michael Faraday.

Điện dung CC được tính bằng:

C=QVC = Q/V

Trong đó:

  * CC: điện dung, đơn vị Farad (F)

  * QQ: điện lượng (coulomb), là điện tích tích trên tụ

  * VV: điện áp (volt), là điện áp cấp cho tụ


### Đơn vị tiêu chuẩn của điện dung

Do Farad là đơn vị lớn, các bội số thường dùng là:

  * Microfarad (μF\mu F) : 1μF=10−6F1 \mu F = 10^{-6} F

  * Nanofarad (nF) : 1nF=10−9F1 nF = 10^{-9} F

  * Picofarad (pF) : 1pF=10−12F1 pF = 10^{-12} F


### Điện dung của tụ điện phẳng (Parallel Plate Capacitor)

Điện dung của tụ điện phẳng tỷ lệ thuận với diện tích AA (m²) của hai tấm và tỷ lệ nghịch với khoảng cách dd (m) giữa hai tấm:

C=εAd=εrε0AdC = eA/d = e_r e_0 A/d

Trong đó:

  * CC: điện dung (F)

  * εre_r: hằng số điện môi tương đối của vật liệu

  * ε0e_0: hằng số điện môi chân không, ε0=8.854×10−12 F/m, e_0 = 8.854 e-12, F/m

  * AA: diện tích bản cực (m²)

  * dd: khoảng cách giữa hai tấm (m)


## Các loại tụ điện (Types of Capacitors)

Tùy theo vật liệu điện môi và cấu tạo, tụ điện được phân loại như sau:

### Tụ gốm (Ceramic Capacitor)

  * Điện môi: gốm.

  * Điện dung: thường nhỏ, từ vài pF đến vài μF.

  * Ứng dụng: lọc tín hiệu, mạch cộng hưởng, mạch cao tần.

  * Ưu điểm: nhỏ gọn, chịu nhiệt tốt, giá rẻ.

  * Nhược điểm: điện dung thay đổi theo nhiệt độ và điện áp.


### Tụ phim (Film Capacitor)

  * Điện môi: nhựa polyester, polypropylene, polystyrene.

  * Điện dung: từ vài nF đến vài μF.

  * Ứng dụng: lọc nguồn, mạch bảo vệ, mạch công suất.

  * Ưu điểm: điện dung ổn định, chịu được điện áp cao.

  * Nhược điểm: kích thước lớn hơn tụ gốm cùng điện dung.


### Tụ hóa (Electrolytic Capacitor)

  * Điện môi: chất điện phân.

  * Điện dung: lớn, từ vài μF đến vài mF.

  * Ứng dụng: lọc nguồn, bù công suất, lưu trữ năng lượng tạm thời.

  * Ưu điểm: dung lượng cao, giá rẻ.

  * Nhược điểm: điện áp làm việc thấp hơn, tuổi thọ ngắn, phân cực (+, −) rõ ràng.


### Tụ tantalum (Tantalum Capacitor)

  * Điện môi: tantalum oxide.

  * Điện dung: từ vài μF đến vài trăm μF.

  * Ứng dụng: mạch điện tử nhạy, nguồn xung.

  * Ưu điểm: dung lượng ổn định, kích thước nhỏ.

  * Nhược điểm: nhạy cảm với quá áp, giá cao hơn tụ nhôm.


### **Tụ** siêu điện (Supercapacitor / Ultracapacitor)

  * Điện dung: rất lớn, từ vài F đến vài nghìn F.

  * Ứng dụng: lưu trữ năng lượng tạm thời, backup nguồn, hệ thống hybrid/EV.

  * Ưu điểm: lưu trữ năng lượng lớn, tuổi thọ dài.

  * Nhược điểm: điện áp thấp, giá cao, kích thước lớn.


## Ứng dụng của tụ điện (Applications of Capacitors)

  * **Lọc nguồn (Power Supply Filtering)**  
Tụ điện dùng để lọc nhiễu và ổn định điện áp DC. Chúng loại bỏ các xung AC còn sót lại sau khi chỉnh lưu từ AC sang DC.

  * **Lưu trữ năng lượng tạm thời**  
Trong mạch xung hoặc hệ thống hybrid, tụ điện có thể cung cấp dòng điện lớn trong thời gian ngắn.

  * **Mạch cộng hưởng và lọc tín hiệu**  
Kết hợp với cuộn cảm (inductor), tụ điện tạo mạch LC dùng để chọn tần số hoặc loại bỏ tần số không mong muốn.

  * **Bù công suất (Power Factor Correction)**  
Trong các mạch điện công nghiệp, tụ điện được dùng để cải thiện hệ số công suất, giảm tổn thất điện năng.

  * **Khởi động động cơ (Motor Start)**  
Tụ điện khởi động giúp động cơ chạy êm và đạt mô-men xoắn ban đầu cao.


## Lưu ý khi sử dụng và bảo quản tụ điện (Precautions and Storage)

  * **Điện áp**  
Không vượt quá điện áp làm việc, đặc biệt với tụ phân cực. Quá áp có thể gây đánh thủng điện môi.

  * **Nhiệt độ**  
Bảo quản và vận hành trong phạm vi nhiệt độ cho phép để tránh giảm tuổi thọ hoặc hỏng tụ.

  * **Phân cực**  
Với tụ điện phân cực (electrolytic, tantalum), chú ý cực (+/−) khi lắp mạch, lắp sai có thể gây nổ.

  * **Lão hóa**  
Một số tụ điện (như tụ hóa) mất điện dung theo thời gian; cần kiểm tra định kỳ nếu dùng lâu năm.

  * **Bảo quản**

1. Tránh ẩm ướt, bụi bẩn.

2. Không để gần nguồn nhiệt cao.

3. Tụ siêu điện và tụ hóa nên xả điện trước khi bảo quản lâu dài.


# Bài tập mẫu (Sample Problem)

Một tụ điện có A=10 m2A = 10\, \text{m}^2, d=5 md = 5\,\text{m}, điện môi là không khí. Tính điện dung CC.

# Hướng dẫn giải (Tutorial)

Điện dung được tính bởi công thức:

C=εAd=εrε0AdC = eA/d = e_r e_0 A/d

Điện dung của tụ điện thay đổi theo vật liệu điện môi. Các vật liệu điện môi thường là cách điện, tấm kim loại dẫn điện có thể làm bằng đồng, nhôm; điện môi có thể là giấy, sáp, mica, gốm, polyme, gel. Theo thời gian, vật liệu lão hóa dẫn đến giảm điện dung. Sai số tụ điện có thể dao động từ −20% đến +80% so với giá trị danh định.

## Điện áp làm việc (Working Voltage)

Điện áp làm việc là mức điện áp tối đa DC hoặc AC mà tụ điện chịu được mà không bị hỏng. Giá trị này thường được in trên thân tụ.

Điện áp AC và DC khác nhau do AC đề cập đến giá trị hiệu dụng; điện áp cực đại AC = 1.414 × điện áp hiệu dụng. Khi chọn tụ điện, điện áp làm việc nên cao hơn điện áp mạch ~30%.  
Ví dụ: mạch 12V → chọn tụ 16V.

## Nhiệt độ làm việc (Working Temperature)

Nhiệt độ ảnh hưởng điện dung do thay đổi tính chất điện môi. Phạm vi làm việc bình thường: −30°C đến +125°C, điện áp danh định. Nhiệt độ làm việc không quá +70°C đối với tụ nhựa.

**Lưu ý:**

  * Tụ phân nhôm: trên 85°C chất lỏng điện phân có thể bay hơi; thân tụ có thể biến dạng hoặc rò rỉ.

  * Tụ phân không dùng ở dưới −10°C do chất điện phân đóng băng.

# Public_031

# Điện trở (Resistor)

## Điện trở là gì? (What is a Resistor)

Điện trở (Resistor) là linh kiện điện tử thụ động tạo ra trở kháng (resistance), làm cản trở dòng chảy của các electron trong mạch điện.

Chúng được gọi là phần tử thụ động (passive) vì chỉ tiêu thụ năng lượng (consume power) mà không tạo ra năng lượng.

Điện trở thường được sử dụng trong các mạch như OP-AMP, vi điều khiển (microcontrollers) và các mạch tích hợp khác (IC – integrated circuits). Chúng dùng để hạn dòng (limit current), chia điện áp (divide voltages) và điều khiển các đường I/O (pull-up/pull-down lines).

## Đơn vị điện trở (Resistor Units)

Đơn vị đo điện trở là **Ohm (Ω)** , ký hiệu bằng chữ Hy Lạp Omega (Ω). Ohm đặt theo tên nhà vật lý Georg Simon Ohm (1784–1854), người đã nghiên cứu và phát hiện mối quan hệ giữa điện áp, dòng điện và điện trở (Luật Ohm).

Trong hệ SI, các tiền tố được dùng để biểu thị điện trở lớn hoặc nhỏ: kilo (kΩ), mega (MΩ), giga (GΩ) hoặc mili (mΩ).

**Ví dụ:**

  * 4.700 Ω = 4.7 kΩ

  * 5.600.000 Ω = 5.6 MΩ hoặc 5,600 kΩ


Tên các điện trở trong mạch thường bắt đầu bằng chữ **R** , mỗi điện trở có một số duy nhất.

## Ký hiệu điện trở trong sơ đồ mạch (Resistor Schematic Symbol)

Tất cả các điện trở có hai đầu nối. Trên sơ đồ mạch, điện trở được biểu thị theo hai tiêu chuẩn:

  * **Hình chữ nhật** : theo tiêu chuẩn IEC (International Electrotechnical Commission)

  * **Đường ngoằn ngoèo (zigzag)** : theo tiêu chuẩn IEEE (Institute of Electrical and Electronics Engineers)


Cả hai ký hiệu đều chấp nhận được. Hình chữ nhật thường được ưu tiên; dạng zigzag phổ biến ở Mỹ và châu Á. Số đỉnh zigzag tiêu chuẩn là 7, với 4 đỉnh trên và 3 đỉnh dưới.

## Thành phần điện trở (Resistor Composition)

Điện trở được chế tạo từ nhiều loại vật liệu, phổ biến là **màng carbon, kim loại hoặc oxit kim loại**. Một lớp vật liệu dẫn điện mỏng được quấn quanh và bao phủ bởi lớp cách điện.

  * **Màng dày** : rẻ nhưng ít chính xác

  * **Màng mỏng** : đắt hơn nhưng chính xác cao


**Ví dụ giá trị điện trở:**

  * 27 Ω, 330 Ω, 3.3 MΩ


Bên trong, màng carbon quấn quanh lõi cách điện. Nhiều lớp bọc → điện trở cao hơn.

## Ý nghĩa điện trở trong mạch điện (Resistor in Circuit)

Điện trở có thể thay thế nhiều thiết bị điện như bóng đèn hoặc động cơ. Trong mạch điện đốt nóng (electric heater circuit), sợi dây đốt nóng được xem như điện trở.

**Định luật Ohm:**

R=VIR = V/I

**Ví dụ:**

  * Tổng điện trở bình thường: RT=60 ΩR_T = 60\,\Omega (240 ÷ 4 = 60 Ω)

  * Khi dòng điện giảm còn 3 A, điện trở tăng: RT=240÷3=80 ΩR_T = 240 ÷ 3 = 80\,\Omega → báo hiệu mạch có vấn đề.


## Giá trị điện trở của dây dẫn (Resistance of Conductor)

Bốn yếu tố ảnh hưởng điện trở dây dẫn:

### Vật liệu (Material)

  * Dây dẫn tốt: đồng, bạc, nhôm

  * Cách điện: cao su, thủy tinh, sứ


### Chiều dài (L)

  * Dây càng dài, điện trở càng cao.

  * Ví dụ: dây 2 m → điện trở gấp đôi dây 1 m


### Diện tích mặt cắt ngang (A)

  * Mặt cắt lớn → điện trở giảm.

  * Ví dụ: diện tích tăng gấp đôi → điện trở giảm phân nửa


### Nhiệt độ (T)

  * Nhiệt độ tăng → điện trở tăng.

  * Khó dự đoán so với các yếu tố khác.


**Công thức tính điện trở dây dẫn:**

R=ρLAR

Trong đó:

  * RR: điện trở (Ω)

  * ρ\rho: điện trở suất của vật liệu (Ω·m)

  * LL: chiều dài dây (m)

  * AA: diện tích mặt cắt ngang (m²)


## Mạch điện trở mắc nối tiếp (Resistor Series Circuits)

Trong **mạch nối tiếp** , các điện trở được kết nối từ đầu đến cuối, tạo thành một **đường dẫn duy nhất** cho dòng điện.

**Tổng điện trở mạch nối tiếp:**

RT=R1+R2+R3+…R_T = R_1 + R_2 + R_3 + \dots

**Ví dụ 1:** 3 điện trở nối tiếp

  * R1=2 Ω,R2=4 Ω,R3=6 ΩR_1 = 2\,\Omega, R_2 = 4\,\Omega, R_3 = 6\,\Omega

  * Dòng điện I=4 AI = 4\,A

  * Tổng điện trở: RT=2+4+6=12 ΩR_T = 2 + 4 + 6 = 12\,\Omega

  * Điện áp nguồn: E=I⋅RT=4×12=48 VE = I \cdot R_T = 4 \times 12 = 48\,V


**Ví dụ 2:** 3 điện trở nối tiếp với điện áp nguồn E=9 VE = 9\,V

  * R1=3 kΩ,R2=10 kΩ,R3=5 kΩR_1 = 3\,k\Omega, R_2 = 10\,k\Omega, R_3 = 5\,k\Omega

  * Dòng điện trong mạch:


Sau đó, điện áp rơi trên mỗi điện trở:

VR1=I⋅R1=0.5×3=1.5 VV_{R1} = I R_1 = 0.5 x3 = 1.5\,V VR2=I⋅R2=0.5×10=5 VV_{R2} = I R_2 = 0.5 x 10 = 5\,V VR3=I⋅R3=0.5×5=2.5 VV_{R3} = I R_3 = 0.5 x 5 = 2.5\,V

Tôi sẽ viết thêm một đoạn mở rộng về **mạch điện trở song song (parallel resistor circuits)** để nối tiếp tài liệu hiện tại:

## Mạch điện trở mắc song song (Resistor Parallel Circuits)

Trong **mạch điện song song** , các điện trở được kết nối sao cho cả hai đầu của chúng được nối trực tiếp vào cùng hai điểm, tạo ra **nhiều đường dẫn** cho dòng điện chảy. Điện áp trên mỗi điện trở trong mạch song song luôn bằng nhau, nhưng dòng điện phân chia theo giá trị điện trở của từng nhánh.

**Ví dụ:**  
Ba điện trở mắc song song: R1=6 ΩR_1 = 6 , R2=3 ΩR_2 = 3, R3=2 ΩR_3 = 2.  
Tổng điện trở: 1

Dòng điện tổng từ nguồn được chia theo tỉ lệ nghịch với điện trở từng nhánh:

Điều này giúp mạch **giảm tổng điện trở** so với bất kỳ điện trở riêng lẻ nào và **tăng khả năng phân phối dòng điện** cho các thiết bị nối vào nhánh khác nhau. Mạch song song phổ biến trong **hệ thống chiếu sáng, mạch nguồn và điện gia dụng** , nơi các tải cần hoạt động độc lập nhưng cùng điện áp.

**Ưu điểm của mạch song song:**

  * Nếu một nhánh hỏng, các nhánh khác vẫn hoạt động.

  * Dễ dàng điều chỉnh dòng điện cho từng nhánh bằng cách chọn điện trở phù hợp.


**Nhược điểm:**

  * Cần tính toán tổng điện trở cẩn thận, đặc biệt khi nhiều nhánh nối song song, để tránh dòng quá tải.

# Public_032

# Dòng điện một chiều (Direct Current – DC)

## Định nghĩa (Definition)

Dòng điện một chiều (DC) là dòng điện mà các electron chảy liên tục theo **một hướng** trong mạch kín. Loại điện áp tạo ra dòng điện này gọi là **điện áp một chiều (DC voltage)** , và dòng điện gọi là **dòng điện một chiều (DC current)**.

**Các nguồn DC điển hình:** Pin, ắc quy, máy phát DC.

## Định luật Ohm (Ohm’s Law)

Có một mối quan hệ xác định giữa ba đặc tính điện cơ bản: **dòng điện (I), điện áp (V), điện trở (R)**.

Định luật Ohm do nhà vật lý người Đức **Georg Simon Ohm** phát hiện vào thế kỷ 19:

I=VRI = V/R

Trong đó:

  * II: dòng điện (amps – A)

  * VV: điện áp (volts – V)

  * RR: điện trở (ohms – Ω)


**Giải thích:**

  * Điện áp 1 V đặt vào điện trở 1 Ω → dòng điện 1 A chảy qua.

  * Điện trở tăng → dòng điện giảm (với cùng điện áp).


**Thiết bị Ohmic và Non-Ohmic:**

  * **Ohmic:** Tuân theo luật Ohm (điện trở tuyến tính, ví dụ dây dẫn, điện trở thông thường).

  * **Non-Ohmic:** Không tuân theo (ví dụ transistor, diode).


## Ví dụ minh họa

**Ví dụ 1:** Biết V=12 VV = 12V , R=6 ΩR = 6Ω. Tìm dòng điện II:

I=VR= 2A

**Ví dụ thực tế:** Pin 4.2 V cấp cho tải 0.5 Ω:

I= 8.4A

Nếu pin còn 3.7 V, dòng điện giảm:

I= 7.4A

**Ví dụ 2:** Biết V=24 VV = 24\,V, I=6 AI = 6\,A. Tìm điện trở RR:

$$
R=VI=246=4ΩR=V/I=24/6=4ΩR = VI = 246 = 4,Omega R  =  V/I  =  24/6  =  4Omega
$$

**Ví dụ 3:** Biết I=5 AI = 5\,A, R=8 ΩR = 8\,Ω. Tìm điện áp VV:

## Công suất điện (Power Calculation)

Công suất (P) do dòng điện tạo ra trong điện trở tính theo:

$$
P=V⋅I=V2R=I2⋅RP=V⋅I=V2R=I2⋅RP = V cdot I = V2R = I2 cdot RP  =  V  cdot I  = frac{V^{2}}{R} =  I^{2} cdot R
$$

**Ví dụ:** Pin 4.2 V, điện trở 0.5 Ω, dòng điện 8.4 A:

P=4.2×8.4=35.3 WP = 4.2 \times 8.4 = 35.3\,W

Như vậy, cuộn dây 0.5 Ω với pin sạc đầy 4.2 V sẽ kéo 8.4 A và cung cấp 35.3 W. Khi điện trở tăng → dòng điện giảm → công suất giảm.

# Dòng điện xoay chiều (Alternating Current – AC)

## Định nghĩa (Definition)

Dòng điện xoay chiều (AC) là dòng điện mà các electron **thay đổi hướng liên tục** theo thời gian. Điện áp AC buộc electron chảy theo một hướng, sau đó theo hướng ngược lại, tuần hoàn liên tục.

**Nguồn AC:** Máy phát điện.  
**Ứng dụng:** Cung cấp điện cho hộ gia đình, nhà máy, văn phòng.

## Dạng sóng (Waveform)

AC có nhiều dạng sóng khác nhau. Khi kết nối nguồn AC với dao động kế và vẽ điện áp theo thời gian, các dạng sóng phổ biến:

  * **Sóng sin:** Dạng sóng chính dùng trong dân dụng và công nghiệp.

  * **Sóng vuông và sóng tam giác:** Thường dùng trong mạch điện tử và điều khiển.


## Mô tả toán học của sóng sin AC

Sóng sin AC có thể mô tả bằng hàm toán học:

$$
V(t)=Vpsin(2πft+ϕ)V(t)=Vp∖sin(2πft+ϕ)V(t) = Vpsin(2pi ft + phi)V(t) =  V_{p}backslash sin(2pi f t  +  phi)
$$

Trong đó:

  * V(t)V(t): điện áp theo thời gian (V)

  * VpV_p: biên độ (amplitude), điện áp cực đại ±Vp

  * sin(): dao động hình sin tuần hoàn

  * 2π2\pi: hằng số chuyển đổi từ chu kỳ (Hz) sang tần số góc (rad/s)

  * ff: tần số (Hz), số dao động trong 1 giây

  * tt: thời gian (s)

  * ϕ\phi: pha (phase), dịch chuyển sóng theo thời gian, đơn vị độ (°)


**Ví dụ:** Ở Mỹ, điện áp AC cho hộ gia đình: biên độ 170 V, tần số 60 Hz, pha 0°:

$$
V(t)=170sin(2π⋅60⋅t)V(t)=170∖sin(2π⋅60⋅t)V(t) = 170sin(2pi cdot 60 cdot t)V(t) =  170 backslash sin(2 pi cdot 60  cdot t)
$$

## Ứng dụng (Applications)

Nguồn AC phổ biến trong **nhà dân, cửa hàng, văn phòng** , vì:

  1. **Truyền tải dễ dàng trên khoảng cách dài:**

* Điện áp cao (>110 kV) → dòng điện thấp → giảm tổn hao năng lượng (I²R) trên đường dây.

* AC có thể biến đổi điện áp bằng **máy biến áp** , tiện lợi cho truyền tải.

  2. **Cung cấp năng lượng cho động cơ điện:**

* Động cơ AC chuyển năng lượng điện thành cơ học.

* Máy phát điện cũng là động cơ hoạt động ngược lại (quay trục sinh điện áp).

* Thiết bị sử dụng AC: máy rửa chén, tủ lạnh, máy lạnh, máy giặt, máy bơm,…


## Điện áp hiệu dụng (RMS Voltage)

Để tính công suất thực tế của AC, sử dụng **điện áp RMS (Root Mean Square)** :

VRMS=Vp2V_\text{RMS} = \frac{V_p}{\sqrt{2}}

Trong đó VpV_p là biên độ cực đại.

Ví dụ: Nguồn AC 170 V (biên độ) → điện áp RMS:

VRMS=1702≈120 VV_\text{RMS} = \frac{170}{\sqrt{2}} \approx 120\,V

Điện áp RMS cho biết mức điện áp tương đương DC tạo ra cùng công suất trên tải điện trở.

## Công suất AC (AC Power)

**Công suất tức thời:**

P(t)=V(t)⋅I(t)P(t) = V(t) \cdot I(t)

**Lưu ý:** Đối với tải thuần trở, ϕ=0\phi = 0, công suất trung bình:

Pavg=VRMS⋅IRMSP_\text{avg} = V_\text{RMS} \cdot I_\text{RMS}

## So sánh DC và AC


| Tiêu chí | DC | AC |
| --- | --- | --- |
| Dòng chảy điện | Một hướng | Thay đổi luân phiên |
| Nguồn | Pin, ắc quy, máy phát DC | Máy phát AC, lưới điện |
| Truyền tải | Khó trên khoảng cách dài | Dễ dàng qua máy biến áp |
| Ứng dụng chính | Điện tử, thiết bị nhỏ | Nhà dân, công nghiệp, động cơ |

# Public_033

# Nguồn gốc của dòng điện (The Origin of the Current)

## Sơ lược về lịch sử phát triển (A Brief History of Development)

Lịch sử phát triển điện học có thể nói bắt đầu từ khoảng **600 năm trước Công nguyên**. Thời bấy giờ, những người Hi Lạp cổ đại lần đầu tiên đề cập đến những tính chất bí ẩn. Nhà triết học **Thales xứ Miletus** đã phát hiện rằng mảnh hổ phách cọ xát (rubbed piece of amber) có thể hút được lông chim và nâng các chất liệu nhẹ khác như vỏ gỗ bào (lift small chips of wood). Phát hiện này nhắc nhở Thales về truyền thuyết về **Magnus** (từ “magnetism”) – đá từ còn gọi là nam châm có khả năng hút sắt.

Sau nhiều thế kỷ, các hiệu ứng tĩnh điện và từ tính (the electrostatic and magnetic effects) đã được nghiên cứu và xác minh bằng thực nghiệm, đặt nền móng cho mạch điện (electrical circuits).

Mãi đến thế kỉ 13, **Pierre de Maricourt (Petrus Peregrinus)** thực hiện các thí nghiệm với đá nam châm hình cầu và các vật liệu khác, rồi công bố kết quả trong cuốn _“Epistola de Magnete”_. Ông là một trong những người đầu tiên đề xuất khai thác tính chất từ tính để chế tạo các cỗ máy.

Một công cụ từ tính quan trọng được sử dụng từ lâu là **la bàn**. La bàn do người Trung Hoa phát minh từ thời Chiến Quốc sau khi tìm ra đá nam châm (từ thạch). Người ta mài gọt đá thành hình chiếc thìa, đặt trên đế đồng nhẵn và quay. Khi chiếc thìa dừng lại, cán thìa hướng về Nam, gọi là "kim chỉ Nam". La bàn được sử dụng trong hàng hải sớm hơn phương Tây gần 100 năm, giúp các nhà thám hiểm châu Âu khám phá các vùng địa lý mới, như Cristoforo Colombo tìm ra châu Mỹ.

Năm 1752, **Benjamin Franklin** thực hiện thí nghiệm thả diều trong cơn bão, chứng minh rằng sét là một dạng điện (electricity).  
Năm 1800, **Alessandro Volta** phát minh ra pin đầu tiên, đơn vị lực điện hay điện áp là **volt** được đặt theo tên ông.  
Năm 1831, **Michael Faraday** phát hiện ra rằng khi nam châm di chuyển bên trong cuộn dây đồng, một dòng điện nhỏ chạy qua, tạo ra máy biến áp và máy phát điện đầu tiên.  
Năm 1879, **Thomas Edison** phát minh ra bóng đèn điện đầu tiên.

## Giới thiệu về điện (Introduction to Electricity)

Mọi vật, từ nước và không khí đến đá, thực vật và động vật, đều được tạo thành từ các hạt nhỏ gọi là **nguyên tử**. Nguyên tử gồm **proton, neutron và electron**. Hạt nhân chứa proton (dương) và neutron (trung hòa), các electron (âm) quay quanh hạt nhân. Nguyên tử có thể được so sánh với hệ mặt trời, hạt nhân là Mặt Trời, electron là các hành tinh quay quanh.

Các electron có thể bị giải phóng bởi lực từ bên ngoài: từ trường, nhiệt độ, ma sát hoặc phản ứng hóa học. Khi electron tự do chuyển từ nguyên tử này sang nguyên tử khác, **dòng điện tử** được tạo ra – cơ sở của **dòng điện**.

# Đặc tính (Characteristics)

Có ba đặc tính chính của điện:

  * **Dòng điện (Current)** – ký hiệu **I**

  * **Điện áp (Voltage)** – ký hiệu **E** hoặc **V** (đôi khi U)

  * **Trở kháng (Resistance)** – ký hiệu **R**

  * **Dòng điện (Current)**


Dòng electron tự do di chuyển cùng hướng từ nguyên tử này sang nguyên tử kia được gọi là **dòng điện** , đo bằng **ampe (A)**. Số lượng electron chảy qua mặt cắt dây trong 1 giây được đo bằng **amps**.


| Quantity | Symbol | Decimal |
| --- | --- | --- |
| 1 milliampere | 1 mA | 1/1000 A |
| 1 ampere | 1 A | 1 ampere |
| 1 kiloampere | 1 kA | 1000 amperes |

 

**Chiều của dòng điện:**

  * **Dòng quy ước (Conventional Flow):** dòng điện đi từ cực dương sang cực âm. Benjamin Franklin là người phát triển lý thuyết này.

  * **Dòng điện tử (Electron Flow):** electron đi từ cực âm sang cực dương. Dù đây là lý thuyết chính xác, dòng quy ước vẫn được sử dụng phổ biến trong giáo khoa và thiết bị điện.


## Điện áp (Voltage)

Điện áp là lực điện áp lên dây dẫn để electron chuyển động, đo bằng **volt (V)**. Dòng điện tiếp tục chạy miễn có điện áp đặt lên dây dẫn.


| Quantity | Symbol | Decimal |
| --- | --- | --- |
| 1 millivolt | 1 mV | 1/1000 volt |
| 1 volt | 1 V | 1 volt |
| 1 kilovolt | 1 kV | 1000 volts |

 

Điện áp tạo dòng điện theo hai cách:

  * **Dòng điện một chiều (Direct Current – DC)**

  * **Dòng điện xoay chiều (Alternating Current – AC)**


## Trở kháng (Resistance)

Trở kháng là khả năng hạn chế dòng electron chảy qua dây dẫn, đo bằng **ohm (Ω)**.


| Quantity | Symbol | Decimal |
| --- | --- | --- |
| 1 ohm | 1 Ω | 1 ohm |
| 1 kilohm | 1 kΩ | 1000 ohms |
| 1 megohm | 1 MΩ | 1,000,000 ohms |

 

Trở kháng là khả năng **cản trở dòng điện** chạy qua một vật dẫn. Khi dòng điện chạy qua dây dẫn, electron va chạm với các nguyên tử của vật liệu, làm giảm tốc độ di chuyển của chúng. Khả năng cản trở này được gọi là **trở kháng** , ký hiệu **R** và đo bằng **ohm (Ω)** , biểu tượng là chữ **Ω** trong bảng chữ cái Hy Lạp.

### Công thức cơ bản

Điện trở của dây dẫn được xác định bởi các yếu tố:

$R=ρ⋅LAR=ρ⋅L/AR = rho cdot LAR  =  rho cdot L/A$

Trong đó:

  * R là điện trở (Ω)

  * ρ là **điện trở suất của vật liệu** (ohm·m)

  * L là chiều dài dây dẫn (m)

  * A là diện tích mặt cắt ngang của dây dẫn (m²)


**Giải thích:**

  * **Vật liệu (ρ\rho)** : Các vật liệu khác nhau có khả năng dẫn điện khác nhau. Đồng, bạc, nhôm là những vật dẫn tốt (ρ\rho thấp), còn cao su, thủy tinh là cách điện (ρ\rho rất cao).

  * **Chiều dài dây dẫn (L)** : Dây càng dài, điện trở càng lớn. Ví dụ, dây 2 m có điện trở gấp đôi dây 1 m cùng loại và cùng tiết diện.

  * **Diện tích mặt cắt ngang (A)** : Dây càng dày, điện trở càng nhỏ. Nếu tiết diện dây tăng gấp đôi, điện trở giảm còn một nửa.


### Ảnh hưởng của nhiệt độ

Điện trở của hầu hết vật liệu dẫn điện thay đổi theo **nhiệt độ**. Thông thường, khi nhiệt độ tăng, điện trở tăng theo:

$$
RT=R0(1+αΔT)RT=R0(1+αΔT)RT = R0(1 + alphaDelta T)R_{T} =  R_{0}(1  +  alphaDelta T)
$$

Trong đó:

  * RTR_T là điện trở ở nhiệt độ T

  * R0R_0 là điện trở ở nhiệt độ chuẩn (thường 20°C)

  * α\alpha là hệ số nhiệt điện trở của vật liệu (1/°C)

  * ΔT=T−20°C\Delta T = T - 20°C


Ví dụ: hệ số α\alpha của đồng khoảng 0.00393/°C. Nếu điện trở 10 Ω ở 20°C, ở 50°C:

$$
R50=10(1+0.00393⋅30)≈11.18ΩR{50}=10(1+0.00393⋅30)≈11.18ΩR50 = 10(1 + 0.00393 cdot 30) approx 11.18Omega R_{left{ 50 right}} =  10 (1  +  0.00393  cdot 30) approx 11.18 Omega
$$

Điều này giải thích tại sao dây điện nóng lên sẽ làm giảm hiệu suất truyền tải.

### Loại điện trở

  * **Điện trở dây quấn (Wire-wound resistor):** điện trở được tạo từ dây hợp kim quấn quanh lõi cách điện. Dùng cho công suất lớn, chịu nhiệt tốt.

  * **Điện trở màng carbon hoặc màng kim loại (Carbon/Metal film resistor):** phổ biến trong mạch điện tử. Giá trị chính xác và ổn định, công suất nhỏ hơn dây quấn.

  * **Điện trở biến thiên (Variable resistor, potentiometer):** có thể thay đổi điện trở theo nhu cầu.


### Trở kháng trong mạch

  * **Điện trở nối tiếp:** các điện trở cộng lại tổng cộng:


$$
RT=R1+R2+R3+…RT=R1+R2+R3+…RT = R1 + R2 + R3 + ldots R_{T} =  R_{1} +  R_{2} +  R_{3} +  ldots
$$

  * **Điện trở song song**


  * **Ứng dụng:**

* Hạn chế dòng điện vào các thiết bị điện tử.

* Chia điện áp cho các mạch điều khiển.

* Làm mạch tải (load) cho nguồn hoặc máy đo.


### Điện trở và công suất

Công suất tiêu tán trên điện trở được tính bằng:

$$
P=I2R=V2R=V⋅IP=I2R=V2/R=V⋅IP = I2R = V2R = V cdot IP  =  I^{2}R  =  V^{2}/R =  V  cdot I
$$

Trong đó:

  * P là công suất (Watt)

  * I là dòng điện (A)

  * V là điện áp (V)

  * R là điện trở (Ω)


Điều này rất quan trọng khi thiết kế mạch điện, tránh tình trạng **cháy điện trở** do công suất vượt mức.

# Public_034

# Giới thiệu

Một **photodiode** là một tiếp giáp **P–N** hoặc thiết bị bán dẫn tiêu thụ năng lượng ánh sáng để tạo ra dòng điện. Nó đôi khi còn được gọi là **bộ dò ánh sáng** , **bộ cảm biến ảnh** hoặc **bộ dò tìm ảnh**.

Photodiodes được thiết kế đặc biệt để hoạt động trong **điều kiện phân cực nghịch**. Phân cực nghịch có nghĩa là mặt **P** của photodiode được kết nối với cực âm của nguồn và mặt **N** được kết nối với cực dương của nguồn.

Photodiode rất nhạy với ánh sáng; khi photon rơi vào photodiode, nó chuyển đổi năng lượng ánh sáng thành dòng điện. **Tế bào năng lượng mặt trời** còn được gọi là photodiode diện tích lớn vì chúng chuyển đổi năng lượng ánh sáng mặt trời thành năng lượng điện. Tuy nhiên, pin mặt trời chỉ hoạt động với ánh sáng khả kiến.

Cấu tạo và hoạt động của photodiode gần như **tương tự diode nối tiếp P–N thông thường** , nhưng photodiode chủ yếu được sử dụng trong các ứng dụng **tốc độ cao**.

Trong diode P–N thông thường, **điện áp** là nguồn năng lượng tạo dòng điện; trong diode quang, **cả điện áp và ánh sáng** đều được sử dụng để sinh dòng điện.

## Ký hiệu Photodiode

Ký hiệu của photodiode tương tự như diode P–N thông thường, ngoại trừ có thêm **mũi tên đại diện cho ánh sáng hoặc photon**. Một photodiode có **hai đầu cuối (terminals)** : một cực âm và một cực dương.

## Mục tiêu và hạn chế của Photodiode

  * Luôn hoạt động khi phân cực nghịch.

  * Điện áp phân cực nghịch nên thấp.

  * Tạo ra tiếng ồn thấp.

  * Tốc độ phản ứng cao.

  * Độ nhạy cao với ánh sáng.

  * Độ nhạy thấp với nhiệt độ.

  * Giá thấp.

  * Kích thước nhỏ.

  * Tuổi thọ lâu dài.


## Các loại Photodiode

Hoạt động của tất cả các loại photodiode là **tương tự nhau** , nhưng các loại khác nhau được phát triển dựa trên ứng dụng cụ thể. Ví dụ, **PIN photodiode** được phát triển để tăng tốc độ đáp ứng.

Các loại photodiode phổ biến:

  * PN photodiode

  * PIN photodiode

  * Avalanche photodiode


Trong số đó, **PN junction** và **PIN photodiode** được sử dụng rộng rãi nhất.

## Ứng dụng của Photodiode

  * Máy chơi đĩa compact (CD/DVD)

  * Thiết bị báo khói

  * Ứng dụng không gian

  * Ứng dụng y tế: chụp cắt lớp vi tính, dụng cụ phân tích mẫu, đo oxy xung

  * Truyền thông quang học

  * Đo cường độ ánh sáng cực thấp


## Phototransistor

Phototransistor là thiết bị có thể cảm nhận mức ánh sáng và thay đổi dòng chảy giữa **emitter** và **collector** theo mức ánh sáng.

  * Phototransistor nhạy hơn photodiode về **độ lợi (gain)** do transistor cung cấp.

  * Ý tưởng về phototransistor được William Shockley đề xuất năm 1951, hai năm sau khi transistor thông thường được phát hiện. Phototransistor đã được sử dụng rộng rãi trong nhiều ứng dụng kể từ đó.


## Hoạt động của Phototransistor

Phototransistor dựa trên **khái niệm transistor cơ bản**. Nó được tạo ra bằng cách **phơi bày chất bán dẫn của transistor thông thường với ánh sáng**.

  * Ánh sáng chiếu vào vùng cơ sở, tạo ra các cặp **electron–lỗ**.

  * Các electron bị bơm vào bộ phát, tạo ra dòng phototransistor, được khuếch đại bởi transistor.


**So sánh:**

  * Một photodiode có thể cho dòng điện khoảng **1 µA** trong điều kiện phòng.

  * Một phototransistor có thể cho dòng điện khoảng **100 µA** , cho thấy hiệu suất lớn hơn.


**Nhược điểm:**

  * Phototransistor không đáp ứng tần số cao tốt do **điện dung lớn** kết hợp với tiếp điểm cơ sở–thu.

  * Băng thông điển hình bị giới hạn ~250 kHz, trong khi photodiode có thể hoạt động tới 1 GHz.


## Ứng dụng Phototransistor

Phototransistor hoạt động ở hai chế độ cơ bản:

  * **Chế độ tuyến tính:** phản ứng tỷ lệ với kích thích ánh sáng, sử dụng trong đo lường.

  * **Chế độ chuyển mạch:** phản ứng phi tuyến, với hai trạng thái: **bật** và **tắt**.

* Khi không có ánh sáng, dòng điện gần như bằng 0 ("tắt").

* Khi ánh sáng đủ lớn, dòng điện đạt bão hòa ("bật").


Ứng dụng: phát hiện đối tượng, gửi dữ liệu, đọc bộ mã hóa, v.v.

## Các bộ ghép quang (Opto–Couplers)

**Optocoupler (Optoisolator)** là thành phần **cách ly tín hiệu điện giữa hai mạch** bằng ánh sáng.

  * Thường gồm **LED** và **phototransistor** trong cùng một gói.

  * Chủ yếu sử dụng giữa **cảm biến và PLC** để ngăn dòng điện trực tiếp có thể gây hỏng thiết bị.


**Chức năng:**

  * Duy trì kết nối giữa hai thiết bị mà không có **dẫn điện trực tiếp**.

  * Đảm bảo an toàn cho PLC hoặc thiết bị điều khiển khi xảy ra lỗi mạch.


# Nguyên lý vật lý của Photodiode và Phototransistor

## Hiệu ứng quang điện

Photodiode hoạt động dựa trên **hiệu ứng quang điện** , nghĩa là khi photon ánh sáng tác động vào vùng **P–N** , năng lượng của photon đủ lớn sẽ **giải phóng các electron** khỏi liên kết hóa học, tạo ra cặp electron–lỗ. Quá trình này tạo ra **dòng điện quang** trong mạch, tỷ lệ với cường độ ánh sáng chiếu vào diode.

  * **Photon năng lượng cao** : tạo ra nhiều cặp electron–lỗ, tăng dòng quang.

  * **Photon năng lượng thấp** : có thể không đủ năng lượng để giải phóng electron, dòng quang rất nhỏ hoặc bằng 0.


Hiệu suất quang điện của photodiode được đo bằng **hiệu suất lượng tử (Quantum Efficiency)** , là tỷ lệ giữa số electron tạo ra và số photon chiếu vào.

## Các tham số quan trọng của Photodiode

  * **Dark Current (Dòng tối)** : dòng nhỏ chạy qua photodiode ngay cả khi không có ánh sáng.

  * **Responsivity (Độ nhạy quang)** : tỷ lệ giữa dòng điện quang tạo ra và công suất ánh sáng chiếu vào diode.

* $$
R=IphPopt[AW]RR = IphPoptleftlbrack frac{A}{W} rightrbrack R
$$

* Trong đó IphI_{ph} là dòng quang, PoptP_{opt} là công suất ánh sáng.

  * **Công suất tối đa cho phép** : photodiode chỉ chịu được một mức công suất ánh sáng nhất định. Quá mức có thể làm hỏng diode.

  * **Tốc độ phản ứng (Response Time)** : thời gian để dòng điện quang đạt 63% giá trị cuối cùng khi ánh sáng thay đổi đột ngột.


## Phân cực Photodiode

  * **Phân cực thuận** : diode dẫn điện, nhưng hiệu suất quang thấp, dòng tối cao.

  * **Phân cực nghịch** : diode hầu như không dẫn, nhưng **tăng tốc độ phản ứng** và giảm dòng tối. Đây là chế độ hoạt động chuẩn của photodiode.


$I=Iph−IDI=Iph−IDI = Iph - IDI  =  I_{ph} -  I_{D}$

Trong đó:

  * II là dòng tổng.

  * $IphI_{ph}$ là dòng quang.

  * $IDI_{D}$ là dòng dò điện (Dark Current).


## Nguyên lý hoạt động của Phototransistor

Phototransistor là **sự kết hợp giữa transistor và photodiode** :

  * Ánh sáng chiếu vào vùng cơ sở, tạo ra dòng quang nhỏ.

  * Dòng quang này được transistor **khuếch đại** ở bộ phát, tạo ra dòng lớn hơn nhiều.

  * Do transistor khuếch đại dòng, phototransistor có **độ lợi dòng cao** , nhưng **điện dung lớn** nên tốc độ phản ứng thấp hơn diode.


## Nguyên lý cách ly quang của Optocoupler

Optocoupler truyền tín hiệu bằng ánh sáng để **cách ly điện hai mạch** :

  * LED bên trong phát sáng khi có dòng vào.

  * Phototransistor bên trong nhận ánh sáng, tạo ra dòng điện trong mạch nhận.

  * Không có **kết nối điện trực tiếp** , nhờ đó mạch nhận được bảo vệ khỏi điện áp cao hoặc nhiễu điện.


  * Optocoupler thường dùng để:

* Ngăn nhiễu trong truyền tín hiệu.

* Bảo vệ vi điều khiển, PLC hoặc mạch điều khiển khỏi dòng cao bất ngờ.


## Các thông số quan trọng của Optocoupler

  * **CTR (Current Transfer Ratio)** : tỷ lệ giữa dòng ra của phototransistor và dòng vào LED.


$$
CTR=IoutIin×100%CTR={I{out}}{I{in}}×100∖%CTR = IoutIin times 100% CTR  = frac{left{ I_{left{ out right}} right}}{left{ I_{left{ in right}} right}} times 100backslash%
$$

  * **Isolation Voltage** : điện áp tối đa mà hai mạch cách ly có thể chịu trước khi bị dò điện.

  * **Tốc độ phản hồi (Response Time)** : thời gian từ LED bật/tắt đến phototransistor phản hồi.

# Public_035

Thuật toán linear regression giải quyết các bài toán có đầu ra là giá trị thực, ví dụ: dự đoán giá nhà, dự đoán giá cổ phiếu, dự đoán tuổi,...

# Bài toán

Bạn làm ở công ty bất động sản, bạn có dữ liệu về diện tích và giá nhà, giờ có một ngôi nhà mới bạn muốn ước tính xem giá ngôi nhà đó khoảng bao nhiêu. Trên thực tế thì giá nhà phụ thuộc rất nhiều yếu tố: diện tích, số phòng, gần trung tâm thương mại,.. nhưng để cho bài toán đơn giản giả sử giá nhà chỉ phụ thuộc vào diện tích căn nhà. Bạn có dữ liệu về diện tích và giá bán của 30 căn nhà như sau:


| Diện tích(m2) | Giá bán (triệu VNĐ) |
| --- | --- |
| 30 | 448.524 |
| 32.4138 | 509.248 |
| 34.8276 | 535.104 |
| 37.2414 | 551.432 |
| 39.6552 | 623.418 |
| ... | ... |

 

Khi có dữ liệu mình sẽ visualize dữ liệu lên hình 3.1
Nếu giờ yêu cầu bạn ước lượng nhà 50 mét vuông khoảng bao nhiêu tiền thì bạn sẽ làm thế nào? Vẽ một đường thẳng gần với các điểm trên nhất và tính giá nhà ở điểm 50 như ở hình 3.2
Về mặt lập trình cũng cần làm 2 việc như vậy:

  1. Training: Tìm đường thẳng (model) gần các điểm trên nhất. Mọi người có thể vẽ ngay được đường thẳng mô tả dữ liệu từ hình 1, nhưng máy tính thì không, nó phải đi tìm bằng thuật toán Gradient descent ở phía dưới. (Từ model và đường thẳng được dùng thay thế lẫn nhau trong phần còn lại của bài này).


  1. Prediction: Dự đoán xem giá của ngôi nhà 50 _m_ 2 có giá bao nhiêu dựa trên đường tìm được ở phần trên.


![](images/image1.png)
Hình 3.1: Đồ thị quan hệ giữa diện tích và giá nhà.

# Thiết lập công thức

## Model

Phương trình đường thẳng có dạng _y_ = _ax_ + _b_ ví dụ hình 3.3. Thay vì dùng kí hiệu a, b cho phương trình đường thẳng; để tiện cho biểu diễn ma trận phần sau ta sẽ thay _w_ 1 = _a,w_ 0 = _b_
Nên phương trình được viết lại thành: _y_ = _w_ 1∗ _x_ + _w_ 0 => Việc tìm đường thẳng giờ thành việc tìm _w_ 0 _,w_ 1.
Để tiện cho việc thiết lập công thức, ta sẽ đặt ký hiệu cho dữ liệu ở bảng dữ liệu: ( _x_ 1 _,y_ 1) = (30, 448.524), ( _x_ 2 _,y_ 2) = (32.4138, 509.248),..
Tức là nhà diện tích _x i _thực sự có giá _y i _. Còn giá trị mà model hiện tại đang dự đoán kí hiệu là _y_ ˆ _i_ = _w_ 1∗ _x i _+ _w_ 0

## Loss function

Việc tìm _w_ 0 _,w_ 1 có thể đơn giản nếu làm bằng mắt nhưng máy tính không biết điều đấy, nên ban đầu giá trị được chọn ngẫu nhiên ví dụ _w_ 0 = 0 _,w_ 1 = 1 sau đấy được chỉnh dần.
Rõ ràng có thể thấy đường y = x như ở hình 3.4 không hề gần các điểm hay không phải là đường mà ta cần tìm. Ví dụ tại điểm x = 42 (nhà 42 _m_ 2 ) giá thật là 625 triệu nhưng giá mà model dự đoán chỉ là 42 triệu.
![](images/image2.png)
Hình 3.2: Ước tính giá căn nhà 50 _m_ 2
![](images/image3.png)
Hình 3.4: Sự khác nhau tại điểm x = 42 của model đường thẳng y = x và giá trị thực tế ở bảng 1
![](images/image4.png)
Hình 3.3: Ví dụ đường thẳng y = x + 1 (a = 1 và b = 1)
Nên giờ cần 1 hàm để đánh giá là đường thẳng với bộ tham số ( _w_ 0 _,w_ 1) = (0 _,_ 1) có tốt hay không. Với mỗi điểm dữ liệu ( _x i,yi_) độ chênh lệch giữa giá thật và giá dự đoán được tính bằng: $$
12(ŷi−yi)2frac{1}{2}left( {widehat{y}}_{i} - y_{i} right)^{2}
$$.
Và độ chênh lệch trên toàn bộ dữ liệu tính bằng tổng chênh lệch của từng điểm:
$$
J=12⋅1N⋅∑i=1N(ŷi−yi)2J = frac{1}{2} cdot frac{1}{N} cdot sum_{i = 1}^{N}{}left( {widehat{y}}_{i} - y_{i} right)^{2}
$$ (N là số điểm dữ liệu). Nhận xét:

  * J không âm

  * J càng nhỏ thì đường thẳng càng gần điểm dữ liệu. Nếu J = 0 thì đường thẳng đi qua tất các điểm dữ liệu.


J được gọi là loss function, hàm để đánh giá xem bộ tham số hiện tại có tốt với dữ liệu không.
=> Bài toán tìm đường thẳng gần các điểm dữ liệu nhất trở thành tìm _w_ 0 _,w_ 1 sao cho hàm J đạt giá trị nhỏ nhất.
Tóm tắt: Cần tìm đường thẳng (model) fit nhất với dữ liệu, tương ứng với việc tìm tham số _w_ 0 _,w_ 1 để cực tiểu hóa hàm J.
Giờ cần một thuật toán để tìm giá trị nhỏ nhất của hàm J( _w_ 0, _w_ 1). Đó chính là thuật toán gradient descent.

# Thuật toán gradient descent

## Đạo hàm là gì?

Có nhiều người có thể tính được đạo hàm của hàm _f_ ( _x_ ) = _x_ 2 hay _f_ ( _x_ ) = _sin_ ( _cos_ ( _x_ )) nhưng vẫn không biết thực sự đạo hàm là gì. Theo tiếng hán đạo là con đường, hàm là hàm số nên đạo hàm chỉ sự biến đổi của hàm số hay có tên thân thương hơn là độ dốc của đồ thị.
![](images/image5.png)
Hình 3.5: Đồ thị _y_ = _x_ 2
Như mọi người đã học đạo hàm _f_ ( _x_ ) = _x_ 2 là _f’_ ( _x_ ) = 2∗ _x_ (hoàn toàn có thể chứng minh từ định nghĩa nhưng cấp 3 mọi người đã học quá nhiều về công thức nên tôi không đề cập lại). Nhận xét:

  * f’(1) = 2 * 1 < f’(2) = 2 * 2 nên mọi người có thể thấy trên hình là đồ thị tại điểm x = 2 dốc hơn đồ thị tại điểm x = 1, tuy nhiên f’(-2) = -4 < f’(-1) = -2 nhưng đồ thị tại x = -2 dốc hơn đồ thị tại x = -1 => trị tuyệt đối của đạo hàm tại một điểm càng lớn thì đồ thị tại điểm đấy càng dốc.

  * f’(-1) = 2 * (-1) = -2 < 0 => đồ thị đang giảm hay khi tăng x thì y sẽ giảm; ngược lại đạo hàm tại điểm nào đó mà dương thì đồ thị tại điểm đấy đang tăng.


## Gradient descent

Gradient descent là thuật toán tìm giá trị nhỏ nhất của hàm số f(x) dựa trên đạo hàm. Thuật toán:

  1. Khởi tạo giá trị _x_ = _x_ 0 tùy ý

  2. Gán x = x - learning_rate * f’(x) ( learning_rate là hằng số dương ví dụ learning_rate = 0.001) 3. Tính lại f(x): Nếu f(x) đủ nhỏ thì dừng lại, ngược lại tiếp tục bước 2


Thuật toán sẽ lặp lại bước 2 một số lần đủ lớn (100 hoặc 1000 lần tùy vào bài toán và hệ số learning_rate) cho đến khi f(x) đạt giá trị đủ nhỏ. Ví dụ cần tìm giá trị nhỏ nhất hàm _y_ = _x_ 2, hàm này ai cũng biết là giá giá trị nhỏ nhất là 0 tại x = 0 nhưng để cho mọi người dễ hình dung hơn về thuật toán Gradient descent nên tôi lấy ví dụ đơn giản.
![](images/image6.png)
Hình 3.6: Ví dụ về thuật toán gradient descent

  1. Bước 1: Khởi tạo giá trị ngẫu nhiên x = -2 (điểm A).

  2. Bước 2: Do ở A đồ thị giảm nên f’(x=-2) = 2*(-2) = -4 < 0 => Khi gán x = x - learning_rate * f’(x) nên x tăng nên đồ thị bước tiếp theo ở điểm C. Tiếp tục thực hiện bước 2, gán x = x learning_rate * f’(x) thì đồ thị ở điểm D,... => hàm số giảm dần dần tiến tới giá trị nhỏ nhất.


Mọi người có để ý là trị tuyệt đối của đạo hàm tại A lớn hơn tại C và tại C lớn hơn tại D không? Đến khi đến gần điểm đạt giá trị nhỏ nhất x = 0, thì đạo hàm xấp xỉ 0 đến khi hàm đạt giá trị nhỏ nhất tại x = 0, thì đạo hàm bằng 0, nên tại điểm gần giá trị nhỏ nhất thì bước 2 gán x = x - learning_rate * f’(x) là không đáng kể và gần như là giữ nguyên giá trị của x.
Tương tự nếu giá trị khởi tạo tại x = 2 (tại B) thì đạo hàm tại B dương nên do x = x - learning_rate * f’(x) giảm -> đồ thị ở điểm E -> rồi tiếp tục gán x=x -learning_rate * f’(x) thì hàm f(x) cũng sẽ giảm dần dần đến giá trị nhỏ nhất.
Ví dụ: chọn x = 10, learning_rate = 0.1, bước 2 sẽ cập nhất x = x - learning_rate*f’(x) = x learning_rate *2*x, giá trị f(x) = _x_ 2 sẽ thay đổi qua các lần thực hiện bước 2 như sau:


| Lần | x | f(x) |
| --- | --- | --- |
| 1 | 8.00 | 64.00 |
| 2 | 6.40 | 40.96 |
| 3 | 5.12 | 26.21 |
| 4 | 4.10 | 16.78 |
| 5 | 3.28 | 10.74 |
| 6 | 2.62 | 6.87 |
| 7 | 2.10 | 4.40 |
| 8 | 1.68 | 2.81 |
| 9 | 1.34 | 1.80 |
| 10 | 1.07 | 1.15 |

 

![](images/image7.png)
Hình 3.7: Ví dụ về thuật toán gradient descent
Nhận xét:

  * Thuật toán hoạt động rất tốt trong trường hợp không thể tìm giá trị nhỏ nhất bằng đại số tuyến tính.

  * Việc quan trọng nhất của thuật toán là tính đạo hàm của hàm số theo từng biến sau đó lặp lại bước 2.


Việc chọn hệ số learning_rate cực kì quan trọng, có 3 trường hợp:

  * Nếu learning_rate nhỏ: mỗi lần hàm số giảm rất ít nên cần rất nhiều lần thực hiện bước 2 để hàm số đạt giá trị nhỏ nhất.

  * Nếu learning_rate hợp lý: sau một số lần lặp bước 2 vừa phải thì hàm sẽ đạt giá trị đủ nhỏ.

  * Nếu learning_rate quá lớn: sẽ gây hiện tượng overshoot (như trong hình 3.8) và không bao giờ đạt được giá trị nhỏ nhất của hàm.


![](images/image8.png)
Hình 3.8: Các giá trị learning_rate khác nhau [13]
Cách tốt nhất để kiểm tra learning_rate hợp lý hay không là kiểm tra giá trị hàm f(x) sau mỗi lần thực hiện bước 2 bằng cách vẽ đồ thị với trục x là số lần thực hiện bước 2, trục y là giá trị loss function tương ứng ở bước đấy.
![](images/image9.png)
Hình 3.9: Loss là giá trị của hàm cần tìm giá trị nhỏ nhất, Epoch ở đây là số cần thực hiện bước 2 [13]

# So sánh các loss function

## Mean Absolute Error, L1 Loss

Mean Absolute Error (MAE) hay còn được gọi là L1 Loss là một loss function được sử dụng cho các mô hình hồi quy, đặc biệt cho các mô hình hồi quy tuyến tính. MAE được tính bằng tổng các trị tuyệt đối của hiệu giữa giá trị thực ( _y i_: target) và giá trị mà mô hình của chúng ra dự đoán ($ŷi{widehat{y}}_{i}$: predicted).
$$
MAE=1N∑i=1N|ŷi−yi|MAE = frac{1}{N}sum_{i = 1}^{N}{}left| {widehat{y}}_{i} - y_{i} right|
$$

## Mean Square Error, L2 Loss

Mean Square Error (MSE) hay còn được gọi là L2 Loss là một loss function cũng được sử dụng cho các mô hình hồi quy, đặc biệt là các mô hình hồi quy tuyến tính. MSE được tính bằng tổng các bình phương của hiệu giữa giá trị thực ( _y i_: target) và giá trị mà mô hình của chúng ra dự đoán ($ŷi{widehat{y}}_{i}$: predicted).
$$
MSE=1N∑i=1N(ŷi−yi)2MSE = frac{1}{N}sum_{i = 1}^{N}{}left( {widehat{y}}_{i} - y_{i} right)^{2}
$$

# Public_036

# Bài toán Image segmentation

Bài trước bạn đã được giới thiệu về object detection, đi tìm các bounding box quanh các đối tượng trong ảnh và sau đó phân loại các bounding box. Tuy nhiên là các bounding box thì không biểu thị được đúng hình dạng của đối tượng và có nhiều nhiễu ở trong bounding box đấy ví dụ như trong bounding box màu đỏ có cả một phần của cây thông cũng như cái gối => Image segmentation ra đời để chia ảnh thành nhiều vùng khác nhau hay tìm được đúng hình dạng của các đối tượng.
![](images/image1.png)
Hình 15.1: So sánh object detection và segmentation [4]
Cùng thử lấy ví dụ tại sao cần image segmentation nhé. Ung thư là một căn bệnh hiểm nghèo và cần được phát hiện sớm để điều trị. Vì hình dạng của các tế bào ung thư là một trong những yếu tố quyết định độ ác tính của bệnh, nên ta cần image segmentation để biết được chính xác hình dạng của các tế bào ung thư để có các chẩn đoán xác định. Rõ ràng object detection ở đây không giải quyết được vấn đề.
![](images/image2.png)
Hình 15.2: Ví dụ về segmentation [15]

## Phân loại bài toán image segmentation

Bài toán image segmentation được chia ra làm 2 loại:

  * **Semantic segmentation** : Thực hiện segment với từng lớp khác nhau, ví dụ: tất cả người là 1 lớp, tất cả ô tô là 1 lớp.

  * **Instance segmentation** : Thực hiện segment với từng đối tượng trong một lớp. Ví dụ có 3 người trong ảnh thì sẽ có 3 vùng segment khác nhau cho mỗi người.


![](images/image3.png)
Hình 15.3: Phân loại semantic segmentation và instance segmentation [27]
Cần áp dụng kiểu segmentation nào thì phụ thuộc vào bài toán. Ví dụ: cần segment người trên đường cho ô tô tự lái, thì có thể dùng semantic segmentation vì không cần thiết phải phân biệt ai với ai, nhưng nếu cần theo dõi mọi hành vi của mọi người trên đường thì cần instance segmentation thì cần phân biệt mọi người với nhau.

## Ứng dụng bài toán segmentation

### Ô tô tự lái

Segmentation dùng để xác định đường, các xe ô tô, người đi bộ,... để hỗ trợ cho ô tô tự lái
![](images/image4.png)

### Chẩn đoán trong y học

Segmentation được ứng dụng rất nhiều trong y học để hỗ trợ việc chẩn đoán bệnh. Ví dụ phân tích ảnh X-quang.
![](images/image5.png)
Hình 15.4: Ứng dụng segmentation [16]

# Mạng U-Net với bài toán semantic segmentation

Như trong bài xử lý ảnh ta đã biết thì ảnh bản chất là một ma trận của các pixel. Trong bài toán image segmentation, ta cần phân loại mỗi pixel trong ảnh. Ví dụ như trong hình trên với semantic segmentation, với mỗi pixel trong ảnh ta cần xác định xem nó là background hay là người. Thêm nữa là ảnh input và output có cùng kích thước.
U-Net được phát triển bởi Olaf Ronneberger et al. để dùng cho image segmentation trong y học. Kiến trúc có 2 phần đối xứng nhau được gọi là encoder (phần bên trái) và decoder (phần bên phải).

## Kiến trúc mạng U-Net

![](images/image6.png)
Hình 15.5: Mạng U-Net [20]
Nhận xét:

  * Thực ra phần encoder chỉ là ConvNet bình thường (conv, max pool) với quy tắc quen thuộc từ bài VGG, các layer sau thì width, height giảm nhưng depth tăng.

  * Phần decoder có mục đích là khôi phục lại kích thước của ảnh gốc, ta thấy có up-conv lạ. Conv với stride > 1 thì để giảm kích thước của ảnh giống như max pool, thì up-conv dùng để tăng kích thước của ảnh.

  * Bạn thấy các đường màu xám, nó nối layer trước với layer hiện tại được dùng rất phổ biến trong các CNN ngày nay như DenseNet để tránh vanishing gradient cũng như mang được các thông tin cần thiết từ layer trước tới layer sau.


## Loss function

Vì bài toán là phân loại cho mỗi pixel nên loss function sẽ là tổng cross-entropy loss cho mỗi pixel trong toàn bộ bức ảnh.

## Transposed convolution

Hình ở trên có kích thước là 6*6, hình ở dưới có kích thước là 4*4, kernel có kích thước 3*3.
Nếu ta thực hiện phép tính convolution với input là hình ở trên, padding = 0, stride = 1 và kernel 3*3 thì output sẽ là hình ở dưới.
![](images/image7.png)
Phép tính transposed convolution thì sẽ ngược lại, input là hình ở dưới, padding = 0, stride = 1 và kernel 3*3 thì output sẽ là hình ở trên. Các ô vuông ở hình trên bị đè lên nhau thì sẽ được cộng dồn. Các quy tắc về stride và padding thì tương tự với convolution.

# Public_037

Ở những bài trước tôi đã giới thiệu về mô hình Recurrent Neural Network (RNN) cho bài toán dữ liệu dạng chuỗi. Tuy nhiên RNN chỉ có short term memory và bị vanishing gradient. Tiếp đó tôi đã giới thiệu về Long short term memory (LSTM) có cả short term memory và long term memory, hơn thế nữa tránh được vanishing gradient. Bài này tôi sẽ viết về ứng dụng của LSTM cho ứng dụng image captioning.

# Ứng dụng

![](images/image1.png)
Hình 18.1: Ví dụ image captioning [10]
Ta có thể thấy ngay 2 ứng dụng của image captioning:

  * Để giúp những người già mắt kém hoặc người mù có thể biết được cảnh vật xung quanh hay hỗ trợ việc di chuyển. Quy trình sẽ là: Image -> text -> voice.

  * Giúp google search có thể tìm kiếm được hình ảnh dựa vào caption.


# Dataset

Dữ liệu dùng trong bài này là Flickr8k Dataset. Mọi người tải ở [đây.](http://academictorrents.com/details/9dea07ba660a722ae1008c4c8afdd303b6f6e53b) Dữ liệu gồm 8000 ảnh, 6000 ảnh cho training set, 1000 cho dev set (validation set) và 1000 ảnh cho test set.
Bạn tải về có 2 folder: Flicker8k_Dataset và Flicker8k_Text. Flicker8k_Dataset chứa các ảnh với tên là các id khác nhau. Flicker8k_Text chứa:

  * Flickr_8k.testImages, Flickr_8k.devImages, Flickr_8k.trainImages, Flickr_8k.devImages chứa id các ảnh dùng cho việc test, train, validation.

  * Flickr8k.token chứa các caption của ảnh, mỗi ảnh chứa 5 captions.


Ví dụ ảnh ở hình 18.2 có 5 captions:

  * A child in a pink dress is climbing up a set of stairs in an entry way.

  * A girl going into a wooden building.

  * A little girl climbing into a wooden playhouse.

  * A little girl climbing the stairs to her playhouse.

  * A little girl in a pink dress going into a wooden cabin.


Thực ra 1 ảnh nhiều caption cũng hợp lý vì bức ảnh có thể được mô tả theo nhiều cách khác nhau. Một ảnh 5 caption sẽ cho ra 5 training set khác nhau: (ảnh, caption 1), (ảnh, caption 2), (ảnh, caption 3), (ảnh, caption 4), (ảnh, caption 5). Như vậy training set sẽ có 6000 * 5 = 40000 dataset.

# Phân tích bài toán

Input là ảnh và output là text, ví dụ "man in black shirt is playing guitar".
Nhìn chung các mô hình machine learning hay deep learning đều không xử lý trực tiếp với text như ’man’, ’in’, ’black’,... mà thường phải quy đổi (encode) về dạng số. Từng từ sẽ được encode sang dạng vector với độ dài số định, phương pháp đấy gọi là word embedding.
Nhìn thấy output là text nghĩ ngay đến RNN và sử dụng mô hình LSTM.
Input là ảnh thường được extract feature qua pre-trained model với dataset lớn như ImageNet và model phổ biến như VGG16, ResNet, quá trình được gọi là embedding và output là 1 vector.
**Ý tưởng sẽ là dùng embedding của ảnh và dùng các từ phía trước để dự đoán từ tiếp theo trong caption.**
Ví dụ:

  * Embedding vector + A -> girl

  * Embedding vector + A girl -> going

  * Embedding vector + A girl going -> into

  * Embedding vector + A girl going into -> a.

  * Embedding vector + A girl going into a -> wooden building .

  * Embedding vector + A girl going into a wooden -> building .


![](images/image2.png)
Hình 18.3: Mô hình của bài toán
Để dự đoán từ tiếp theo ta sẽ xây dựng từ điển các từ xuất hiện trong training set (ví dụ 2000 từ) và bài toán trở thành bài toán phân loại từ, xem từ tiếp theo là từ nào, khá giống như bài phân loại ảnh.

# Các bước chi tiết

## Image embedding với Inception

Có lẽ cái tên GoogLeNet sẽ quen thuộc hơn và gặp nhiều hơn so với Inception, GoogLeNet là version 1 của Inception, hiện giờ mô hình phổ biến là Inception v3.
![](images/image3.png)
Hình 18.4: Mô hình Googlenet, Going Deeper with Convolutions, Szegedy et al
Thay vì trong mỗi Conv layer chỉ dùng 1 kernel size nhất định như 3*3, 5*5, thì giờ ở một layer có nhiều kernel size khác nhau, do đó mô hình có thể học được nhiều thuộc tính khác nhau của ảnh trong mỗi layer.
Ta sẽ sử dụng pre-trained model Inception v3 với dataset Imagenet. Do là pre-trained model yêu cầu ảnh đầu vào là 229*229 nên ra sẽ resize ảnh về kích thước này. Sau khi qua pre-trained model ta sẽ lấy được embedding vector của ảnh, kích thước 256*1.

## Text preprocessing

Ta xử lý text qua một số bước cơ bản.

  * Chuyển chữ hoa thành chữ thường, "Hello" -> "hello"

  * Bỏ các kí tự đặc biệt như "

  * Loại bỏ các chữ có số như hey199


Sau đó ta sẽ thêm 2 từ "startseq" và "endseq" để biểu thị sự bắt đầu và kết thúc của caption. Ví dụ: "startseq a girl going into a wooden building endseq". "endseq" dùng khi test ảnh thì biết kết thúc của caption.
Ta thấy có 8763 chữ khác nhau trong số 40000 caption. Tuy nhiên ta không quan tâm lắm những từ mà chỉ xuất hiện 1 vài lần, vì nó giống như là nhiễu vậy và không tốt cho việc học và dự đoán từ của model, nên ta chỉ giữ lại những từ mà xuất hiện trên 10 lần trong số tất cả các caption. Sau khi bỏ những từ xuất hiện ít hơn 10 lần ta còn 1651 từ.
Tuy nhiên do độ dài các sequence khác nhau, ví dụ: "A", " A girl going", " A girl going into a wooden", nên ta cần padding thêm để các chuỗi có cùng độ dài bằng với độ dài của chuỗi dài nhất là 34. Do đó số tổng số từ (từ điển) ta có là 1651 + 1 (từ dùng để padding).

## Word embedding

Để có thể đưa text vào mô hình deep learning, việc đầu tiên chúng ta cần làm là số hóa các từ đầu vào (embedding). Ở phần này chúng ta sẽ thảo luận về các mô hình nhúng từ (word embedding) và sự ra đời của mô hình word2vec rất nổi tiếng được google giới thiệu vào năm 2013. Trước đó ta thảo luận một số phương pháp cổ điển

### One hot encoding

Phương pháp này là phương pháp đơn giản nhất để đưa từ về dạng số hóa vector với chiều bằng với kích thước bộ từ điển. Mỗi từ sẽ được biểu diễn bởi 1 vector mà giá trị tại vị trí của từ đó trong từ điển bằng 1 và giá trị tại các vị trí còn lại đều bằng 0.
Ví dụ: Ta có 3 câu đầu vào: "Tôi đang đi học", "Mình đang bận nhé", "Tôi sẽ gọi lại sau". Xây dựng bộ từ điển: "Tôi, đang , đi, học, Mình, bận, nhé, sẽ , gọi, lại, sau". Ta có các biểu diễn one hot encoding của từng từ như sau:
Tôi:[1 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0] _,_
đang: [0 _,_ 1 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0] _,_
_..._
Mình: [0 _,_ 0 _,_ 0 _,_ 0 _,_ 1 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0] _,_
_...  
_sau: [0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 0 _,_ 1] _._
Cách biểu diễn này rất đơn giản, tuy nhiên ta có thể nhận thấy ngay các hạn chế của phương pháp này. Trước hết, one hot encoding không thể hiện được thông tin về ngữ nghĩa của từ, ví dụ như khoảng cách(vector(Tôi) - vector(Mình)) = khoảng cách(vector(Tôi) - vector(đang)), trong khi rõ ràng từ "Tôi" và từ "Mình" trong ngữ cảnh như trên có ý nghĩa rất giống nhau còn từ "Tôi" và từ "đang" lại khác nhau hoàn toàn. Tiếp nữa, mỗi từ đều được biểu diễn bằng một vector có độ dài bằng kích thước bộ từ điển, như bộ từ điển của google gồm 13 triệu từ, thì mỗi one hot vector sẽ dài 13 triệu chiều. Cách biểu diễn này tốn rất nhiều tài nguyên nhưng thông tin biểu diễn được lại rất hạn hẹp.
=> Cần một cách biểu diễn từ ít chiều hơn và mang nhiều thông tin hơn.

### Co-occurrence Matrix

Năm 1957, nhà ngôn ngữ học J.R. Firth phát biểu rằng: "Bạn sẽ biết nghĩa của một từ nhờ những từ đi kèm với nó.". Điều này cũng khá dễ hiểu. Ví dụ nhắc đến Việt Nam, người ta thường có các cụm từ quen thuộc như "Chiến tranh Việt Nam", "Cafe Việt Nam", "Việt Nam rừng vàng biển bạc", dựa vào những từ xung quanh ta có thể hiểu hoặc mường tượng ra được "Việt Nam" là gì, như thế nào. Co-occurrence Matrix được xây dựng dựa trên nhận xét trên, co-occurrence đảm bảo quan hệ ngữ nghĩa giữa các từ, dựa trên số lần xuất hiện của các cặp từ trong "context window". Một context window được xác dựa trên kích thước và hướng của nó, ví dụ của context window:
![](images/image4.png)
Hình 18.5: Ví dụ về context window
Co-occurrence matrix là một ma trận vuông đối xứng, mỗi hàng, mỗi cột sẽ làm vector đại diện cho từ tương ứng. Từ ví dụ trên ta tiếp tục xây dựng co-occurrence matrix:
![](images/image5.png)
Hình 18.6: Ví dụ về co-occurrence matrix
Trong đó, giá trị tại ô [i, j] là số lần xuất hiện của từ i nằm trong context window của từ j. Cách biểu diễn trên mặc dù đã giữ được thông tin về ngữ nghĩa của một từ, tuy vẫn còn các hạn chế như sau:

  * Khi kích thước bộ từ điển tăng, chiều vector cũng tăng theo.

  * Lưu trữ co-occurrence matrix cần rất nhiều tài nguyên về bộ nhớ.

  * Các mô hình phân lớp bị gặp vấn đề với biểu diễn thưa (có rất nhiều giá trị 0 trong ma trận).


Để làm giảm kích thước của co-occurrence matrix người ta thường sử dụng phép SVD (Singular Value Decomposition) để giảm chiều ma trận. Ma trận thu được sau SVD có chiều nhỏ hơn, dễ lưu trữ hơn và ý nghĩa của từ cũng cô đọng hơn. Tuy nhiên, SVD có độ phức tạp tính toán cao, tăng nhanh cùng với chiều của ma trận ( _O_ ( _mn_ 2) với m là chiều của ma trận trước SVD, n là chiều của ma trận sau SVD và _n < m_ ) , ngoài ra phương pháp này cũng gặp khó khăn khi thêm các từ vựng mới vào bộ từ điển.
=> Cần phương pháp khác lưu trữ được nhiều thông tin và vector biểu diễn nhỏ.

### Word to vec (Word2vec)

Với tư tưởng rằng ngữ cảnh và ý nghĩa của một từ có sự tương quan mật thiết đến nhau, năm 2013 nhóm của Mikolov đề xuất một phương pháp mang tên Word2vec.
Ý tưởng chính của Word2vec:

  * Thay thế việc lưu thông tin số lần xuất hiện của các từ trong context window như co-occurrence matrix, word2vec học cách dự đoán các từ lận cận.

  * Tính toán nhanh hơn và có thể transfer learning khi thêm các từ mới vào bộ từ điển.

  * Phương pháp:


Với mỗi từ t trong bộ từ điển ta dự đoán các từ lân cận trong bán kính _m_ của nó.
Hàm mục tiêu nhằm tối ưu xác suất xuất hiện của các từ ngữ cảnh (context word) đối với từ đang xét hiện tại: 
Có 2 kiến trúc khác nhau của word2vec, là CBoW và Skip-Gram:

  * Cbow: Cho trước ngữ cảnh ta dự đoán xác suất từ đích. Ví dụ: "I ... you", với đầu vào là 2 từ "I" và "you" ta cố gắng dự đoán từ còn thiếu, chẳng hạn "love".

  * Skip-Gram: Cho từ đích ta dự đoán xác suất các từ ngữ cảnh (nằm trong context window) của nó. Ví dụ: "... love ...", cho từ "love" ta dự đoán các từ là ngữ cảnh của nó, chẳng hạn "I", "you".


Trong bài báo giới thiệu word2vec, Mikolov và cộng sự có so sánh và cho thấy 2 mô hình này cho kết quả tương đối giống nhau.
Chi tiết mô hình:
![](images/image6.png)
Hình 18.7: Mô hình Cbow
![](images/image7.png)
Hình 18.8: Mô hình Skip-Gram
Do 2 kiến trúc khá giống nhau nên ta chỉ thảo luận về Skip-Gram.
Mô hình Skip-Gram sẽ input từ đích và dự đoán ra các từ ngữ cảnh. Thay vì input từ đích và output ra nhiều từ ngữ cảnh trong 1 mô hình, họ xây dựng model để input từ đích và output ra 1 từ ngữ cảnh.
Mô hình là một mạng neural network 2 lớp, với chỉ 1 hidden layer. Input là một từ trong từ điển đã được mã hóa thành dạng one hot vector chiều _V_ ∗1 với V là kích thước từ điển. Hidden layer không sử dụng activation function có N node, trong đó N chính là độ dài vector embedding của mỗi từ. Output layer có V node, sau đó softmax activation được sử dụng để chuyển về dạng xác suất. Categorical cross entropy loss function được học để dự đoán được từ ngữ cảnh với input là từ đích. Ví dụ của xây dựng training data:
![](images/image8.png)
Hình 18.9: Ví dụ của xây dựng training data, window size = 2, tức là lấy 2 từ bên trái và 2 từ bên phải mỗi từ trung tâm làm từ ngữ cảnh (context word)
Một số kết quả của Word2vec:
![](images/image9.png)
Hình 18.11: Vị trí các word vector trong không gian
Ví dụ trên là ví dụ kinh điển của Word2vec cho thấy các vector biểu diễn tốt quan hệ về mặt ngữ nghĩa của từ vựng như thế nào.

## Output

Bài toán là dự đoán từ tiếp theo trong chuỗi ở input với ảnh hiện tại, nên output là từ nào trong số 1652 từ trong từ điển mà ta có. Với bài toán phân loại thì softmax activation và categorical_crossentropy loss function được sử dụng.

# Public_038

# Giới thiệu

Mô hình RNN ra đời để xử lý các dữ liệu dạng chuỗi (sequence) như text, video.

![](images/image1.png)

Hình 19.1: Các dạng bài toán RNN

Bài toán RNN được phân làm một số dạng:

  * **One to one** : mẫu bài toán cho Neural Network (NN) và Convolutional Neural Network (CNN), 1 input và 1 output, ví dụ với bài toán phân loại ảnh MNIST input là ảnh và output ảnh đấy là số nào.

  * **One to many** : bài toán có 1 input nhưng nhiều output, ví dụ với bài toán caption cho ảnh, input là 1 ảnh nhưng output là nhiều chữ mô tả cho ảnh đấy, dưới dạng một câu.

  * **Many to one** : bài toán có nhiều input nhưng chỉ có 1 output, ví dụ bài toán phân loại hành động trong video, input là nhiều ảnh (frame) tách ra từ video, output là hành động trong video.

  * **Many to many** : bài toán có nhiều input và nhiều output, ví dụ bài toán dịch từ tiếng anh sang tiếng việt, input là 1 câu gồm nhiều chữ: "I love Vietnam" và output cũng là 1 câu gồm nhiều chữ "Tôi yêu Việt Nam". Để ý là độ dài sequence của input và output có thể khác nhau.


Mô hình sequence to sequence (seq2seq) sinh ra để giải quyết bài toán many to many và rất thành công trong các bài toán: dịch, tóm tắt đoạn văn. Bài này mình sẽ cùng tìm hiểu về mô hình seq2seq với bài toán dịch từ tiếng anh sang tiếng việt.

# Mô hình seq2seq

Input của mô hình seq2seq là một câu tiếng anh và output là câu dịch tiếng việt tương ứng, độ dài hai câu này có thể khác nhau. Ví dụ: input: I love teaching -> output: Tôi thích dạy học, input 1 câu 3 từ, output 1 câu 4 từ.

![](images/image2.png)

Hình 19.2: Seq2seq model

Mô hình seq2seq gồm 2 thành phần là encoder và decoder.

![](images/image3.png)

Hình 19.3: Seq2seq model

Encoder nhận input là câu tiếng anh và output ra context vector, còn decoder nhận input là context vector và output ra câu tiếng việt tương ứng. Phần encoder sử dụng mô hình RNN (nói là mô hình RNN nhưng có thể là các mô hình cải tiến như GRU, LSTM) và context vector được dùng là hidden states ở node cuối cùng. Phần decoder cũng là một mô hình RNN với _s_ 0 chính là context vector rồi dần dần sinh ra các từ ở câu dịch.

Phần decoder này giống với bài toán image captioning. Ở bài image captioning mình cũng cho ảnh qua pre-trained model để lấy được embedding vector, sau đó cho embedding vector làm _s_ 0 của mô hình RNN rồi sinh ta caption tương ứng với ảnh.

Bài trước mình đã biết model RNN chỉ nhận input dạng vector nên dữ liệu ảnh (từ) sẽ được encode về dạng vector trước khi cho vào model.

![](images/image4.png)

Hình 19.4: Mô hình encoder

Các từ trong câu tiếng anh sẽ được embedding thành vector và cho vào mô hình RNN, hidden state ở node cuối cùng sẽ được dùng làm context vector. Về mặt lý thuyết thì context vector sẽ mang đủ thông tin của câu tiếng anh cần dịch và sẽ được làm input cho decoder.

![](images/image5.png)

Hình 19.5: Mô hình decoder

2 tag <START> và <END> được thêm vào câu output để chỉ từ bắt đầu và kết thúc của câu dịch. Mô hình decoder nhận input là context vector. Ở node đầu tiên context vector và tag <START> sẽ output ra chữ đầu tiên trong câu dịch, rồi tiếp tục mô hình sinh chữ tiếp theo cho đến khi gặp tag <END> hoặc đến max_length của câu output thì dừng lại.

**Vấn đề** : Mô hình seq2seq encode cả câu tiếng anh thành 1 context vector, rồi dùng context vector để sinh ra các từ trong câu dịch tương ứng tiếng Việt. Như vậy khi câu dài thì rất khó cho decoder chỉ dùng 1 context vector có thể sinh ra được câu output chuẩn. Thêm vào đó các mô hình RNN đều bị mất ít nhiều thông tin ở các node ở xa nên bản thân context vector cũng khó để học được thông tin ở các từ ở phần đầu của encoder.

=> Cần có cơ chế để lấy được thông tin các từ ở input cho mỗi từ cần dự đoán ở output thay vì chỉ dựa vào context vector => **Attention** ra đời.

# Cơ chế attention

## Motivation

Attention tiếng anh nghĩa là chú ý, hay tập trung. Khi dịch ở mỗi từ tiếng việt ta cần chú ý đến 1 vài từ tiếng anh ở input, hay nói cách khác là có 1 vài từ ở input có ảnh hưởng lớn hơn để dịch từ đấy.

![](images/image6.png)

Hình 19.6: Dịch tiếng anh sang tiếng việt, độ quan trọng các từ khi dịch

Ta thấy từ I có trọng số ảnh hưởng lớn tới việc dịch từ tôi, hay từ teaching có ảnh hưởng nhiều tới việc dịch từ dạy và từ học.

=> Do đó khi dịch mỗi từ ta cần chú ý đến các từ ở câu input tiếng anh và đánh trọng số khác nhau cho các từ để dịch chuẩn hơn.

## Cách hoạt động

Attention sẽ định nghĩa ra 3 thành phần query, key, value.

![](images/image7.png)

Hình 19.7: Các thành phần attention

Query (q) lấy thông tin từ từ tiếp theo cần dịch (ví dụ từ dạy). Mỗi từ trong câu input tiếng anh sẽ cho ra 2 thành phần tương ứng là key và value, từ thứ i kí hiệu là _k i_, _v i_.

Mỗi bộ q, _k i _qua hàm _α_ sẽ cho ra _a i _tương ứng, _a i _chính là độ ảnh hưởng của từ thứ i trong input lên từ cần dự đoán. Sau đó các giá trị _a i _được normalize theo hàm softmax được _b i_.

![](images/image8.png)

Hình 19.8: Các thành phần attention

Cuối cùng các giá trị _v i _được tính tổng lại theo hệ số _b i_, output = ∑ _b i _∗ _v i_, trong đó N là số từ trong câu input. Việc normalize các giá trị _a i _giúp output cùng scale với các giá trị value.

![](images/image9.png)

Hình 19.9: Các bước trong attention

Ở phần encoder, thông thường mỗi từ ở input thì hidden state ở mỗi node được lấy làm cả giá trị key và value của từ đấy. Ở phần decoder, ở node 1 gọi input là _x_ 1, output _y_ 1 và hidden state _s_ 1; ở node 2 gọi input là _x_ 2, output _y_ 2. Query là hidden state của node trước của node cần dự đoán từ tiếp theo ( _s_ 1). Các bước thực hiện:

  * Tính score: _a i _= _α_ ( _q,k i_)

  * Normalize score: _b i_

  * Tính output: output_attention = ∑ _b i _∗ _v i_

  * Sau đó kết hợp hidden state ở node trước _s_ 1, input node hiện tại _x_ 2 và giá trị output_attention để dự đoán từ tiếp theo _y_ 2.


![](images/image10.png)

Hình 19.10: Một số hàm _α_ hay được sử dụng

Nhận xét: Cơ chế attention không chỉ dùng context vector mà còn sử dụng hidden state ở từng từ trong input với trọng số ảnh hưởng tương ứng, nên việc dự đoán từ tiếp theo sẽ tốt hơn cũng như không sợ tình trạng từ ở xa bị mất thông tin ở context vector.

Ngoài ra các mô hình deep learning hay bị nói là hộp đen (black box) vì mô hình không giải thích được, attention phần nào giúp visualize được kết quả dự đoán, ví dụ từ nào ở output ảnh hưởng nhiều bởi từ nào trong input. Do đó model học được quan hệ giữa các từ trong input và output để đưa ra kết quả dự đoán.

Lúc đầu cơ chế attention được dùng trong bài toán seq2seq, về sau do ý tưởng attention quá hay nên được dùng trong rất nhiều bài toán khác, ví dụ như trong CNN người ta dùng cơ chế attention để xem pixel nào quan trọng đến việc dự đoán, feature map nào quan trọng hơn trong CNN layer,.. Giống như resnet, attention cũng là 1 đột phá trong deep learning. Mọi người để ý thì các mô hình mới hiện tại đều sử dụng cơ chế attention.

# Public_039

Mô hình GAN được giới thiệu bởi Ian J. Goodfellow vào năm 2014 và đã đạt được rất nhiều thành công lớn trong Deep Learning nói riêng và AI nói chung. Yann LeCun, VP and Chief AI Scientist, Facebook, từng mô tả về GAN: "The most interesting idea in the last 10 years in Machine Learning". Để mọi người thấy được các ứng dụng của GAN, phần dưới tôi sẽ trình bày một vài ứng dụng điển hình của GAN.

# Ứng dụng của GAN

## Generate Photographs of Human Faces

Ví dụ về ảnh mặt người do GAN sinh ra từ 2014 đến 2017. Mọi người có thể thấy chất lượng ảnh sinh ra tốt lên đáng kể theo thời gian.

![](images/image1.png)

Hình 20.1: Ảnh mặt GAN sinh ra qua các năm, Malicious Use of Artificial Intelligence: Forecasting, Prevention, and Mitigation, 2018.

Hình dưới là ảnh sinh ra bởi GAN năm 2018, phải để ý rất chi tiết thì mới có thể phân biệt được ảnh mặt đấy là sinh ra hay ảnh thật.

![](images/image2.png)

Hình 20.2: [StyleGAN](https://github.com/NVlabs/stylegan)

## Image editing

Chắc mọi người vẫn nhớ tới FaceApp làm mưa làm gió trong thời gian vừa qua. Nó là một ứng dụng của GAN để sửa các thuộc tính của khuôn mặt như màu tóc, da, giới tính, cảm xúc hay độ tuổi.

![](images/image3.png)

Hình 20.3: [StarGAN](https://github.com/yunjey/stargan)

![](images/image4.png)

Hình 20.4: [Age-cGAN](https://arxiv.org/pdf/1702.01983.pdf)

## Generate Realistic Photographs

Năm 2018, Andrew Brock cho ra paper [bigGAN](https://arxiv.org/abs/1809.11096) với có khả năng sinh ra các ảnh tự nhiên rất khó phân biệt với ảnh chụp thường.

![](images/image5.png)

Hình 20.5: Example of Realistic Synthetic Photographs Generated with BigGAN Taken from Large Scale GAN Training for High Fidelity Natural Image Synthesis, 2018.

## Image-to-Image Translation

Ví dụ điển hình của mô hình image to image translation là Pix2pix. Input là 1 ảnh và output là 1 ảnh tương ứng, ví dụ input là ảnh không màu, output là ảnh màu. Mọi người có thể vào [đây](https://affinelayer.com/pixsrv/) thử, input là bản phác (draft) con mèo, output là ảnh con mèo hay input là các khối block, output là ảnh ngôi nhà.

![](images/image6.png)

Hình 20.6: Ví dụ ảnh draft sang ảnh màu, taken from Image-to-Image Translation with Conditional Adversarial Networks, 2016.

# GAN là gì?

GAN thuộc nhóm generative model. Generative là tính từ nghĩa là khả năng sinh ra, model nghĩa là mô hình. Vậy hiểu đơn giản generative model nghĩa là mô hình có khả năng sinh ra dữ liệu. Hay nói cách khác, GAN là mô hình có khả năng sinh ra dữ liệu mới. Ví dụ như những ảnh mặt người ở trên bạn thấy là do GAN sinh ra, không phải mặt người thật. Dữ liệu sinh ra nhìn như thật nhưng không phải thật.

GAN viết tắt cho Generative Adversarial Networks. Generative giống như ở trên, Network có nghĩa là mạng (mô hình), còn Adversarial là đối nghịch. Tên gọi như vậy là do GAN được cấu thành từ 2 mạng gọi là Generator và Discriminator, luôn đối nghịch đầu với nhau trong quá trình train mạng GAN. Chi tiết sẽ được trình bày ở phần dưới.

Tóm lại GAN là mạng để sinh dữ liệu mới giống với dữ liệu trong dataset có sẵn và có 2 mạng trong GAN là Generator và Discriminator.

# Cấu trúc mạng GAN

GAN cấu tạo gồm 2 mạng là Generator và Discriminator. Trong khi Generator sinh ra các dữ liệu giống như thật thì Discriminator cố gắng phân biệt đâu là dữ liệu được sinh ra từ Generator và đâu là dữ liệu thật có.

Ví dụ bài toán giờ là dùng GAN để generate ra tiền giả mà có thể dùng để chi tiêu được. Dữ liệu có là tiền thật.

Generator giống như người làm tiền giả còn Discriminator giống như cảnh sát. Người làm tiền giả sẽ cố gắng làm ra tiền giả mà cảnh sát cũng không phân biệt được. Còn cảnh sát sẽ phân biệt đâu là tiền thật và đâu là tiền giả. Mục tiêu cuối cùng là người làm tiền giả sẽ làm ra tiền mà cảnh sát cũng không phân biệt được đâu là thật và đâu là giả và thế là mang tiền đi tiêu được.

Trong quá trình train GAN thì cảnh sát có 2 việc: 1 là học cách phân biệt tiền nào là thật, tiền nào là giả, 2 là nói cho thằng làm tiền giả biết là tiền nó làm ra vẫn chưa qua mắt được và cần cải thiện hơn. Dần dần thì thằng làm tiền giả sẽ làm tiền giống tiền thật hơn và cảnh sát cũng thành thạo việc phân biệt tiền giả và tiền thật. Và mong đợi là tiền giả từ GAN sẽ đánh lừa được cảnh sát.

Ý tưởng của GAN bắt nguồn từ [zero-sum non-cooperative game,](https://cs.stanford.edu/people/eroberts/courses/soco/projects/1998-99/game-theory/nonzero.html) hiểu đơn giản như trò chơi đối kháng 2 người (cờ vua, cờ tướng), nếu một người thắng thì người còn lại sẽ thua. Ở mỗi lượt thì cả 2 đều muốn maximize cơ hội thắng của tôi và minimize cơ hội thắng của đối phương. Discriminator và Generator trong mạng GAN giống như 2 đối thủ trong trò chơi. Trong lý thuyết trò chơi thì GAN model converge khi cả Generator và Discriminator đạt tới trạng thái Nash equilibrium, tức là 2 người chơi đạt trạng thái cân bằng và đi tiếp các bước không làm tăng cơ hội thắng. "A strategy profile is a Nash equilibrium if no player can do better by unilaterally changing his or her strategy", [nguồn.](https://medium.com/cantors-paradise/the-nash-equilibrium-explained-c9ad7e97633a)

**Bài toán** : Dùng mạng GAN sinh ra các chữ số viết tay giống với dữ liệu trong [MNIST dataset.](http://yann.lecun.com/exdb/mnist/)

## Generator

Generator là mạng sinh ra dữ liệu, tức là sinh ra các chữ số giống với dữ liệu trong MNIST dataset. Generator có input là noise (random vector) là output là chữ số.

Tại sao input là noise? Vì các chữ số khi viết ra không hoàn toàn giống nhau. Ví dụ số 0 ở hàng đầu tiên có rất nhiều biến dạng nhưng vẫn là số 0. Thế nên input của Generator là noise để khi ta thay đổi noise ngẫu nhiên thì Generator có thể sinh ra một biến dạng khác của chữ viết tay. Noise cho Generator thường được sinh ra từ normal distribution hoặc uniform distribution.

![](images/image7.png)

Hình 20.14: MNIST dataset, [nguồn](https://syncedreview.com/2019/06/19/mnist-reborn-restored-and-expanded-additional-50k-training-samples/)

Input của Generator là noise vector 100 chiều. Sau đấy mô hình neural network được áp dụng với số node trong hidden layer lần lượt là 256, 512, 1024.

![](images/image8.png)

Hình 20.15: Mô hình generator

Output layer có số chiều là 784, vì output đầu ra là ảnh giống với dữ liệu MNIST, ảnh xám kích thước 28*28 (784 pixel).

Output là vector kích thước 784*1 sẽ được reshape về 28*28 đúng định dạng của dữ liệu MNIST.

![](images/image9.png)

Hình 20.16: Ví dụ về reshape, [nguồn](http://jalammar.github.io/visual-numpy/)

## Discriminator

Discriminator là mạng để phân biệt xem dữ liệu là thật (dữ liệu từ dataset) hay giả (dữ liệu sinh ra từ Generator). Trong bài toán này thì discriminator dùng để phân biệt chữ số từ bộ MNIST và dữ liệu sinh ra từ Generator. Discriminator có input là ảnh biểu diễn bằng 784 chiều, output là ảnh thật hay ảnh giả.

Đây là bài toán binary classification, giống với [logistic regression.](https://nttuan8.com/bai-2-logistic-regression/)

![](images/image10.png)

Hình 20.17: Ví dụ về reshape, [nguồn](http://jalammar.github.io/visual-numpy/)

Input của Discriminator là ảnh kích thước 784 chiều.

Sau đấy mô hình neural network được áp dụng với số node trong hidden layer lần lượt là 1024, 512, 256. Mô hình đối xứng lại với Generator.

Output là 1 node thể hiện xác suất ảnh input là ảnh thật, hàm sigmoid được sử dụng.

# Public_040

# Deep Convolutional GAN

Bài trước tôi đã giới thiệu về GAN, cấu trúc mạng GAN và hướng dẫn dùng GAN để sinh các số trong bộ dữ liệu MNIST. Tuy nhiên mô hình của Generator và Discriminator đều dùng Neural Network. Trong khi ở bài CNN tôi đã biết CNN xử lý dữ liệu ảnh tốt hơn và hiệu quả hơn rất nhiều so với Neural Network truyền thống. Vậy nên bài này tôi sẽ hướng dẫn áp dụng CNN vào mô hình GAN bài trước, mô hình đấy gọi là Deep Convolutional GAN (DCGAN).

Bài toán: Dùng mạng GAN sinh ra các ảnh giống với dữ liệu trong CIFAR-10 dataset.

CIFAR-10 dataset bao gồm 60000 ảnh màu kích thước 32x32 thuộc 10 thể loại khác nhau. Mỗi thể loại có 6000 ảnh.

## Cấu trúc mạng

Nhắc lại bài trước 1 chút thì GAN gồm 2 mạng là generator và discriminator. Trong khi discriminator được train để phân biệt ảnh thật (trong dataset) và ảnh fake (do generator sinh ra), thì generator được train để đánh lừa discriminator. Ở bài trước thì cả generator và discriminator đều được xây bằng mạng neural network thông thường với các fully connected layer, bài này thì generator và discriminator được xây dựng bằng mô hình CNN với 2 layers chính là convolutional layer và transposed convolutional layer.

### Generator

Mạng Generator nhằm mục đích sinh ảnh fake, input là noise vector kích thước 128 và output và ảnh fake cùng kích thước ảnh thật (32 * 32 *3)

![](images/image1.png)

Hình 21.1: Mô hình generator của DCGAN

Các layer trong mạng

  * Dense (fully-connected) layer: 128*1 -> 2048*1

  * Flatten chuyển từ vector về dạng tensor 3d, 2048*1 -> 2*2*512

  * Transposed convolution stride=2, kernel=256, 2*2*512 -> 4*4*256 • Transposed convolution stride=2, kernel=128, 4*4*256 -> 8*8*128

  * Transposed convolution stride=2, kernel=64, 8*8*128 -> 16*16*64

  * Transposed convolution stride=2, kernel=3, 16*16*64 -> 32*32*3


Đầu tiên thì input noise (128) được dùng full-connected layer chuyển thành 2048 ( = 2*2*512). Số 2048 được chọn để reshape về dạng tensor 3d (2*2*512). Sau đó transposed convolution với stride = 2 được dùng để tăng kích thước tensor lên dần 4*4 -> 8*8 -> 16*16 -> 32*32. Cho tới khi kích thước tensor 32*32 (bằng đúng width, height của ảnh trong CIFAR-10 dataset) thì ta dùng 3 kernel để ra đúng shape của ảnh.

Mọi người để ý thấy là khi width, height tăng thì depth sẽ giảm, cũng giống như trong mạng CNN bình thường width, height giảm thì depth sẽ tăng.

Transposed convolution hay deconvolution có thể coi là phép toán ngược của convolution. Nếu như convolution với stride > 1 giúp làm giảm kích thước của ảnh thì transposed convolution với stride > 1 sẽ làm tăng kích thước ảnh. Ví dụ stride = 2 và padding = ’SAME’ sẽ giúp gấp đôi width, height kích thước của ảnh.

Transposed convolution có 2 kiểu định nghĩa:

  * **Kiểu 1** Kiểu 1 được định nghĩa đơn giản hơn lấy từ sách Dive into deep learning. Ý tưởng đơn giản là transposed convolution là phép tính ngược của convolution.


![](images/image2.png)

Hình 21.3: Convolution s=1, p=0

Nếu như ở phép tính convolution thì 1 vùng kích thước 2*2 được nhân element-wise với kernel và tính tổng viết ra ở output thì ở phép tính transposed convolution mỗi phần tử ở input sẽ được nhân với kernel và ma trận kết quả cùng kích thước với kernel được viết vào output. Nếu các phần tử ở output viết đè lên nhau thì ta sẽ cộng dồn vào.

![](images/image3.png)

Hình 21.4: Transposed convolution với s=1, p=0

Stride trong transposed convolution được định nghĩa là số bước nhảy khi viết kết quả ra ma trận output. Với padding thì ta tính toán bình thường như với p=0 sau đó kết quả ta sẽ bỏ p hàng và cột ở 4 cạnh (trên, dưới, trái, phải)

![](images/image4.png)

Hình 21.6: Transposed convolution s=2, p=1

  * **Kiểu 2** Kiểu định nghĩa thứ 2 thì phức tạp hơn nhưng lại có vẻ chuẩn và hay gặp hơn. Ý nghĩa của stride và padding ở đây là khi ta thực hiện phép tính convolution trên output sẽ được kích thước giống input.


![](images/image5.png)

Hình 21.7: Các bước thực hiện transposed convolution

### Discriminator

Mạng Discriminator nhằm mục đích phân biệt ảnh thật từ dataset và ảnh fake do Generator sinh ra, input là ảnh kích thước (32 * 32 *3), output là ảnh thật hay fake (binary classification)

![](images/image6.png)

Hình 21.8: Mô hình discriminator của DCGAN

Mô hình discriminator đối xứng lại với mô hình generator. Ảnh input được đi qua convolution với stride = 2 để giảm kích thước ảnh từ 32*32 -> 16*16 -> 8*8 -> 4*4 -> 2*2. Khi giảm kích thước thì depth tăng dần. Cuối cùng thì tensor shape 2*2*512 được reshape về vector 2048 và dùng 1 lớp fully connected chuyển từ 2048d về 1d.

Loss function được sử dụng giống như bài trước về GAN.

## Tips

Đây là một số tips để build model và train DCGAN

  * Dùng ReLU trong generator trừ output layer

  * Output layer trong generator dùng tanh (-1, 1) và scale ảnh input về (-1,1) sẽ cho kết quả tốt hơn dùng sigmoid và scale ảnh về (0, 1) hoặc để nguyên ảnh.

  * Sử dụng Leaky ReLU trong discriminator

  * Thay thế max pooling bằng convolution với stride = 2

  * Sử dụng transposed convolution để upsampling

  * Sử dụng batch norm từ output layer trong generator và input layer trong discriminator


## Thực nghiệm

Ảnh CIFAR-10 được scale về (-1, 1) để cùng scale với ảnh sinh ra bởi generator khi dùng tanh activation.

Ở những epoch đầu tiên thì generator chỉ sinh ra noise.

![](images/image7.png)

Hình 21.9: Ảnh sinh ra bởi generator sau 10 epochs

Tuy nhiên sau 150 epoch thì mạng đã học được thuộc tính của ảnh trong dữ liệu CIFAR-10 và có thể sinh ra được hình con chim, ô tô.

![](images/image8.png)

Hình 21.10: Ảnh sinh ra bởi generator sau 150 epochs **  
**

# Conditional GAN

Phần trước tôi giới thiệu về DCGAN, dùng deep convolutional network trong mô hình GAN. Tuy nhiên khi ta train GAN xong rồi dùng generator để sinh ảnh mới giống trong dataset tôi không kiểm soát được là ảnh sinh ra giống category nào trong dataset. Ví dụ như dùng GAN để sinh các chữ số trong bộ MNIST, thì khi train xong và dùng generator sinh ảnh thì tôi không biết được ảnh sinh ra sẽ là số mấy (0 -> 9). Bài toán hôm nay muốn kiểm soát được generator sinh ra ảnh theo 1 category nhất định. Ví dụ có thể chỉ định generator sinh ra số 1 chẳng hạn. Mô hình đấy gọi là Conditional GAN (cGAN).

## Fashion-MNIST

Dữ liệu Fashion-MNIST về quần áo, giày dép gồm 60000 ảnh training và 10000 ảnh test. Ảnh xám kích thước 28*28 thuộc 10 lớp khác nhau.


| 0 | T-shirt/top |
| --- | --- |
| 1 | Trouser |
| 2 | Pullover |
| 3 | Dress |
| 4 | Coat |
| 5 | Sandal |
| 6 | Shirt |
| 7 | Sneaker |
| 8 | Bag |
| 9 | Ankle boot |

 

Bài toán hôm nay sẽ dùng cGAN để sinh ra dữ liệu trong từng thể loại ở dữ liệu Fashion-MNIST như sinh ra các ảnh áo Shirt. Ví dụ dữ liệu Fashion-MNIST ở hình 22.1

![](images/image9.png)

Hình 22.1: Ảnh dữ liệu Fashion-MNIST

## Cấu trúc mạng

### Generator

Ở bài trước thì Generator sinh ảnh fake từ noise vector. Cái hay của random vector là có thể sample được nhiều giá trị khác nhau, thành ra khi train xong mạng GAN thì có thể sinh được nhiều ảnh fake khác nhau. Tuy nhiên lại không thể kiểm soát xem ảnh sinh ra thuộc thể loại nào (áo, giày, dép,...).

Bên cạnh noise vector z, tôi sẽ thêm vào y, 1 số từ (0 - 9), mỗi thể loại trong dữ liệu Fashion-MNIST sẽ được encode về 1 số. tôi mong muốn là z với số y nào thì sẽ cho ra dữ liệu tương ứng thể loại đấy.

![](images/image10.png)

Hình 22.2: Mô hình Generator cGAN

Input z là noise vector như bài trước, sau đấy được qua dense layer về kích thước 7*7*128 rồi reshape về dạng 3D tensor kích thước 7x7x128 (y1)

Input y là 1 số được đi qua embedding layer của keras, layer này giống như 1 dictionary map mỗi số thành một vector 50*1, sau đó được qua dense với output 49 node cuối cùng được reshape về 3D tensor kích thước 7x7x1 (y2)

Sau đó y1 và y2 được xếp chồng lên nhau thành tensor 3d kích thước 7*7*129, tiếp đi qua transposed convolution để tăng kích thước lên 14*14 và 28*28, cuối cùng cho ra output 28*28*1.

### Discriminator

Discriminator mục đích phân biệt ảnh thật trong dataset và ảnh fake sinh ra bởi generator.

Tương tự như ở trong generator bên cạnh ảnh, tôi sẽ thêm vào y, 1 số từ (0 - 9) tương ứng với thể loại trong dữ liệu Fashion-MNIST.

![](images/image11.png)

Hình 22.3: Mô hình Discriminator cGAN

Input y là 1 số được đi qua embedding layer của keras, layer này giống như 1 dictionary map mỗi số thành một vector 50*1, sau đó được qua dense với output 28*28 node cuối cùng được reshape về 3D tensor kích thước 28x28x1 (y1)

Sau đó y1 và ảnh input được xếp chồng lên nhau thành tensor 3d kích thước 28*28*2, sau đó tensor đi qua convolution với stride = 2 để giảm kích thước ảnh từ 28*28 -> 14*14 -> 7*7. Khi giảm kích thước thì depth tăng dần. Cuối cùng thì tensor shape 2*2*512 được reshape về vector 2048 và dùng 1 lớp fully connected chuyển từ 2048d về 1d.

### Loss function

![](images/image12.png)

Hình 22.4: Loss function cGAN

# Public_041

# Bài toán

Ngân hàng bạn đang làm có chương trình cho vay ưu đãi cho các đối tượng mua chung cư. Tuy nhiên gần đây có một vài chung cư rất hấp dẫn (giá tốt, vị trí đẹp,...) nên lượng hồ sơ người nộp cho chương trình ưu đãi tăng đáng kể. Bình thường bạn có thể duyệt 10-20 hồ sơ một ngày để quyết định hồ sơ có được cho vay hay không, tuy nhiên gần đây bạn nhận được 1000-2000 hồ sơ mỗi ngày. Bạn không thể xử lý hết hồ sơ và bạn cần có một giải pháp để có thể dự đoán hồ sơ mới là có nên cho vay hay không.
Sau khi phân tích thì bạn nhận thấy là hai yếu tố chính quyết định đến việc được vay tiền đó là mức lương và thời gian công tác. Đây là dữ liệu bạn có từ trước đến nay:


| Lương | Thời gian làm việc | Cho vay |
| --- | --- | --- |
| 10 | 1 | 1 |
| 9 | 0.5 | 1 |
| 5 | 2 | 1 |
| ... | ... | ... |
| 8 | 0.1 | 0 |
| 6 | 0.3 | 0 |
| 7 | 0.15 | 0 |
| ... | ... | ... |

 

Khi có dữ liệu bạn visualize dữ liệu lên như hình 4.1
Về mặt logic, giờ ta cần tìm đường thẳng phân chia giữa các điểm cho vay và từ chối. Rồi quyết định hồ sơ mới có nên có vay hay không từ đường đấy như hình 4.2
![](images/image1.png)
Hình 4.1: Đồ thị giữa mức lương, số năm kinh nghiệm và kết quả cho vay
![](images/image7.png)
Hình 4.2: Đường phân chia và dự đoán điểm dữ liệu mới
Ví dụ đường xanh là đường phân chia. Dự đoán cho hồ sơ của người có mức lương 6 triệu và 1 năm kinh nghiệm là không cho vay.
Tuy nhiên, do ngân hàng đang trong thời kỳ khó khăn nên việc cho vay bị thắt lại, chỉ những hồ sơ nào chắc chắn trên 80% mới được vay.
Vậy nên bây giờ bạn không những tìm là hồ sơ ấy cho vay hay không cho vay mà cần tìm xác suất nên cho hồ sơ ấy vay là bao nhiêu.
Hay trong nhiều trường hợp khác trong bài toán phân loại người ta quan tâm hơn đến xác suất hay vì chỉ 1 hay 0. Ví dụ: bác sĩ sẽ thông báo ca mổ này 80% thành công cho người nhà bệnh nhân.

# Xác suất

Bạn được học xác suất từ cấp hai, cấp ba rồi đến toán cao cấp, nhưng có bao giờ bạn hỏi tại sao lại có xác suất không? Vì trong cuộc sống này có những sự việc không chắc chắn, ví dụ ngày mai trời có mưa không. Vậy nên xác suất ra đời để đo lường sự không chắc chắn ấy.
Vậy xác suất là gì? "Các nhà toán học coi xác suất là các số trong khoảng [0,1], được gán tương ứng với một biến cố mà khả năng xảy ra hoặc không xảy ra là ngẫu nhiên" [28]. Ví dụ bạn tung đồng xu có 2 mặt, thì xác suất bạn tung được mặt ngửa là 50% ( = 50/100 = 0.5).
Nhận xét:

  * Xác suất của 1 sự kiện trong khoảng [0,1]

  * Sự kiện bạn càng chắc chắn xảy ra thì xác suất càng cao. Ví dụ bạn lương cao và còn đi làm lâu lăm thì xác suất bạn được vay mua chung cư là cao.

  * Tổng xác suất của sự kiện A và sự kiện phủ định của A là 100% (hay 1). Ví dụ sự kiện A: tung đồng xu mặt ngửa, xác suất 50%; phủ định của sự kiện A: tung đồng xu mặt sấp, xác suất 50% => tổng 100%.


Bạn sẽ thấy xác suất quan trọng hơn là chỉ 0 hay 1, ví dụ trước mỗi ca mổ khó, bác sĩ không thể chắc chắn là sẽ thất bại hay thành công mà chỉ có thể nói xác suất thành công là bao nhiêu (ví dụ 80%).

# Hàm sigmoid

Giờ ta cần tìm xác suất của hồ sơ mới nên cho vay. Hay giá trị của hàm cần trong khoảng [0,1]. Rõ ràng là giá trị của phương trình đường thẳng như bài trước có thể ra ngoài khoảng [0,1] nên cần một hàm mới luôn có giá trị trong khoảng [0,1]. Đó là hàm sigmoid.
![](images/image4.png)
Hình 4.3: Đồ thị hàm sigmoid
Nhận xét:

  * Hàm số liên tục, nhận giá trị thực trong khoảng (0,1).

  * Hàm có đạo hàm tại mọi điểm (để áp dụng gradient descent).


# Thiết lập bài toán

Mọi người có để ý các bước trong bài linear regression không nhỉ, các bước bao gồm:

  1. Visualize dữ liệu

  2. Thiết lập model

  3. Thiết lập loss function

  4. Tìm tham số bằng việc tối ưu loss function

  5. Dự đoán dữ liệu mới bằng model vừa tìm được 


Đây là mô hình chung cho bài toán trong Deep Learning.

## Model

Với dòng thứ i trong bảng dữ liệu, gọi _x_ 1 là lương và _x_ 2 là thời gian làm việc của hồ sơ thứ i .
$$
p(x(i)=1)=ŷipleft( x^{(i)} = 1 right) = {widehat{y}}_{i}
$$ là xác suất mà model dự đoán hồ sơ thứ i được cho vay.
$$
p(x(i)=0)=1−ŷipleft( x^{(i)} = 0 right) = 1 - {widehat{y}}_{i}
$$là xác suất mà model dự đoán hồ sơ thứ i không được cho vay.
Như bài trước công thức của linear regression là: $$
ŷi=w0+w1x1+w2x2{widehat{y}}_{i} = w_{0} + w_{1}x_{1} + w_{2}x_{2}
$$ thì giờ công thức của logistic regression là:

$$
ŷi=σ(w0+w1x1(i)+w2x2(i))=11+e−(w0+w1x1(i)+w2x2(i)){widehat{y}}_{i} = sigmaleft( w_{0} + w_{1}x_{1}^{(i)} + w_{2}x_{2}^{(i)} right) = frac{1}{1 + e^{- left( w_{0} + w_{1}x_{1}^{(i)} + w_{2}x_{2}^{(i)} right)}}
$$

Ở phần cuối mọi người sẽ thấy được quan hệ giữa xác suất và đường thẳng.

## Loss function

Giờ cũng cần một hàm để đánh giá độ tốt của model. Như bài trước là _y_ ˆ càng gần y càng tốt, giờ cũng vậy:

  * Nếu hồ sơ thứ i là cho vay, tức _y i _= 1 thì ta cũng mong muốn _y_ ˆ _i_ càng gần 1 càng tốt hay model dự đoán xác suất người thứ i được vay vốn càng cao càng tốt.

  * Nếu hồ sơ thứ i không được vay, tức _y i _= 0 thì ta cũng mong muốn _y_ ˆ _i_ càng gần 0 càng tốt hay model dự đoán xác suất người thứ i được vay vốn càng thấp càng tốt.


Với mỗi điểm ![](images/image3.png), gọi hàm loss function $$
L=−(yiloglogŷi+(1−yi)loglog(1−ŷi))L = - left( y_{i}loglog {widehat{y}}_{i}  + left( 1 - y_{i} right)loglog left( 1 - {widehat{y}}_{i} right)  right)
$$, loss function này có tên gọi là binary_crossentropy
**Mặc định trong machine learning nói chung hay deep learning thì viết log hiểu là ln**
Thử đánh giá hàm L nhé. Nếu _y i _= 1 => L = − _log_ ( _y_ ˆ _i_ )
![](images/image2.png)
Hình 4.4: Đồ thị hàm loss function trong trường hợp _y i _= 1
Nhận xét:

  * Hàm L giảm dần từ 0 đến 1.

  * Khi model dự đoán _y_ ˆ _i_ gần 1, tức giá trị dự đoán gần với giá trị thật _y i _thì L nhỏ, xấp xỉ 0

  * Khi model dự đoán _y_ ˆ _i_ gần 0, tức giá trị dự đoán ngược lại giá trị thật _y i _thì L rất lớn


Ngược lại, nếu _y i _= 0 => L = − _log_ (1− _y_ ˆ _i_ )
![](images/image5.png)
Hình 4.5: Đồ thị hàm loss function trong trường hợp _y i _= 0
Nhận xét:

  * Hàm L tăng dần từ 0 đến 1

  * Khi model dự đoán _y_ ˆ _i_ gần 0, tức giá trị dự đoán gần với giá trị thật _y i _thì L nhỏ, xấp xỉ 0

  * Khi model dự đoán _y_ ˆ _i_ gần 1, tức giá trị dự đoán ngược lại giá trị thật _y i _thì L rất lớn => Hàm L nhỏ khi giá trị model dự đoán gần với giá trị thật và rất lớn khi model dự đoán sai, hay nói cách khác L càng nhỏ thì model dự đoán càng gần với giá trị thật. => Bài toán tìm model trở thành tìm giá trị nhỏ nhất của L


Hàm loss function trên toàn bộ dữ liệu $$
J=−1N∑i=1N(yiloglogŷi+(1−yi)loglog(1−ŷi))J = - frac{1}{N}sum_{i = 1}^{N}left( y_{i}loglog {widehat{y}}_{i}  + left( 1 - y_{i} right)loglog left( 1 - {widehat{y}}_{i} right)  right)
$$

# Public_042

# Neural network là gì

Con chó có thể phân biệt được người thân trong gia đình và người lạ hay đứa trẻ có thể phân biệt được các con vật. Những việc tưởng chừng như rất đơn giản nhưng lại cực kì khó để thực hiện bằng máy tính. Vậy sự khác biệt nằm ở đâu? Câu trả lời nằm ở cấu trúc bộ não với lượng lớn các nơ-ron thần kinh liên kết với nhau. Liệu máy tính có thể mô phỏng lại cấu trúc bộ não để giải các bài toán trên ???
Neural là tính từ của neuron (nơ-ron), network chỉ cấu trúc, cách các nơ-ron đó liên kết với nhau, nên neural network (NN) là một hệ thống tính toán lấy cảm hứng từ sự hoạt động của các nơ-ron trong hệ thần kinh.

## Hoạt động của các nơ-ron

Nơ-ron là đơn vị cơ bản cấu tạo hệ thống thần kinh và là thành phần quan trọng nhất của não. Đầu chúng ta gồm khoảng 10 triệu nơ-ron và mỗi nơ-ron lại liên kết với tầm 10.000 nơ-ron khác.
Ở mỗi nơ-ron có phần thân (soma) chứa nhân, các tín hiệu đầu vào qua sợi nhánh (dendrites) và các tín hiệu đầu ra qua sợi trục (axon) kết nối với các nơ-ron khác. Hiểu đơn giản mỗi nơ-ron nhận dữ liệu đầu vào qua sợi nhánh và truyền dữ liệu đầu ra qua sợi trục, đến các sợi nhánh của các nơ-ron khác.
Mỗi nơ-ron nhận xung điện từ các nơ-ron khác qua sợi nhánh. Nếu các xung điện này đủ lớn để kích hoạt nơ-ron, thì tín hiệu này đi qua sợi trục đến các sợi nhánh của các nơ-ron khác.
![](images/image1.png)
Hình 5.1: Tế bào thần kinh [14]
=> Ở mỗi nơ-ron cần quyết định có kích hoạt nơ-ron đấy hay không. Tương tự các hoạt động của hàm sigmoid bài trước.
Tuy nhiên NN chỉ là lấy cảm hứng từ não bộ và cách nó hoạt động, chứ không phải bắt chước toàn bộ các chức năng của nó. Việc chính của chúng ta là dùng mô hình đấy đi giải quyết các bài toán chúng ta cần.

# Mô hình neural network

## Logistic regression

Logistic regression là mô hình neural network đơn giản nhất chỉ với input layer và output layer.
Mô hình của logistic regression từ bài trước là: _y_ ˆ= _σ_ ( _w_ 0+ _w_ 1∗ _x_ 1+ _w_ 2∗ _x_ 2). Có 2 bước:
Tính tổng linear: _z_ =1∗ _w_ 0+ _x_ 1∗ _w_ 1+ _x_ 2∗ _w_ 2
Áp dụng sigmoid function: _y_ ˆ= _σ_ ( _z_ )
Để biểu diễn gọn lại ta sẽ gộp hai bước trên thành một trên biểu đồ như hình 5.2.
![](images/image2.png)
Hình 5.2: Mô hình logistic regression
Hệ số _w_ 0 được gọi là bias. Để ý từ những bài trước đến giờ dữ liệu khi tính toán luôn được thêm 1 để tính hệ số bias _w_ 0 . Tại sao lại cần hệ số bias? Quay lại với bài 1, phương trình đường thẳng sẽ thế nào nếu bỏ _w_ 0, phương trình giờ có dạng: _y_ = _w_ 1∗ _x_ , sẽ luôn đi qua gốc tọa độ và nó không tổng quát hóa phương trình đường thẳng nên có thể không tìm được phương trình mong muốn. => Việc thêm bias (hệ số tự do) là rất quan trọng.
Hàm sigmoid ở đây được gọi là activation function.

## Mô hình tổng quát

Layer đầu tiên là input layer, các layer ở giữa được gọi là hidden layer, layer cuối cùng được gọi là output layer. Các hình tròn được gọi là node.
Mỗi mô hình luôn có 1 input layer, 1 output layer, có thể có hoặc không các hidden layer. Tổng số layer trong mô hình được quy ước là số layer - 1 (không tính input layer).
Ví dụ như ở hình trên có 1 input layer, 2 hidden layer và 1 output layer. Số lượng layer của mô hình là 3 layer.
Mỗi node trong hidden layer và output layer :
Liên kết với tất cả các node ở layer trước đó với các hệ số w riêng.
Mỗi node có 1 hệ số bias b riêng.
Diễn ra 2 bước: tính tổng linear và áp dụng activation function.

## Kí hiệu

Số node trong hidden layer thứ i là _l_ ( _i_ ).
Ma trận _W_ ( _k_ ) kích thước _l_ ( _k_ −1) ∗ _l_ ( _k_ ) là ma trận hệ số giữa layer (k-1) và layer k, trong đó _w_ ( _ij k_) là hệ số kết nối từ node thứ i của layer k-1 đến node thứ j của layer k.
![](images/image3.png)
Hình 5.3: Mô hình neural network
Vector $b(k)b^{(k)}$ kích thước $lkl^{k}$∗1 là hệ số bias của các node trong layer k, trong đó _b_ ( _i k_) là bias của node thứ i trong layer k.
( _l_ )
Với node thứ i trong layer l có bias _b i(l)_ thực hiện 2 bước:

  * Tính tổng tất cả các node trong layer trước nhân với hệ số w tương ứng, rồi cộng với bias b.


Áp dụng activation function: _a i(l)_ = _σ_ ( _z i (l)_)
Vector _z_ ( _k_ ) kích thước _l_ ( _k_ ) ∗1 là giá trị các node trong layer k sau bước tính tổng linear.
Vector _a_ ( _k_ ) kích thước _l_ ( _k_ ) ∗1 là giá trị của các node trong layer k sau khi áp dụng hàm activation function.
![](images/image4.png)
Mô hình neural network trên gồm 3 layer. Input layer có 2 node ( _l_ (0) =2), hidden layer 1 có 3 node, hidden layer 2 có 3 node và output layer có 1 node.
Do mỗi node trong hidden layer và output layer đều có bias nên trong input layer và hidden layer cần thêm node 1 để tính bias (nhưng không tính vào tổng số node layer có).

# Feedforward

Để nhất quán về mặt ký hiệu, gọi input layer là _a_ (0)(= _x_ ) kích thước 2*1.
![](images/image5.png)
Tương tự ta có:
_z_ (2) =( _W_ (2)) _T_ ∗ _a_ (1) + _b_ (2)
_a_ (2) = _σ_ ( _z_ (2)) 
_z_ (3) =( _W_ (3)) _T_ ∗ _a_ (2) + _b_ (3)
_y_ ˆ= _a_ (3) = _σ_ ( _z_ (3))
![](images/image6.png)
Hình 5.4: Feedforward

# Logistic regression với toán tử XOR

Phần này không bắt buộc, nó giúp giải thích việc có nhiều layer hơn thì mô hình sẽ giải quyết được các bài toán phức tạp hơn. Cụ thể là mô hình logistic regression bài trước không biểu diễn được toán tử XOR nhưng nếu thêm 1 hidden layer với 2 node ở giữa input layer và output layer thì có thể biểu diễn được toán tử XOR.
AND, OR, XOR là các phép toán thực hiện phép tính trên bit. Thế bit là gì? bạn không cần quan tâm, chỉ cần biết mỗi bit nhận 1 trong 2 giá trị là 0 hoặc 1.

## NOT

Phép tính NOT của 1 bit cho ra giá trị ngược lại.


| A | NOT(A) |
| --- | --- |
| 0 | 1 |
| 1 | 0 |

 

## AND

Phép tính AND của 2 bit cho giá trị 1 nếu cả 2 bit bằng 1 và cho giá trị bằng 0 trong các trường hợp còn lại. Bảng chân lý


| A | B | A AND B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

 

## OR

Phép tính OR của 2 bit cho giá trị 1 nếu 1 trong 2 bit bằng 1 và cho giá trị bằng 0 trong các trường hợp còn lại. Bảng chân lý


| A | B | A OR B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

 

## XOR

Phép tính XOR của 2 bit cho giá trị 1 nếu đúng 1 trong 2 bit bằng 1 và cho giá trị bằng 0 trong các trường hợp còn lại. Bảng chân lý


| A | B | A XOR B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

 

Khi thiết lập bài toán logistic regression, ta có đồ thị
![](images/image7.png)
Rõ ràng là không thể dùng một đường thẳng để phân chia dữ liệu thành 2 miền. Nên khi bạn dùng gradient descent vào bài toán XOR thì bất kể bạn chạy bước 2 bao nhiêu lần hay chỉnh learning_rate thế nào thì vẫn không ra được kết quả như mong muốn. Logistic regression như bài trước không thể giải quyết được vấn đề này, giờ cần một giải pháp mới !!!
Áp dụng các kiến thức về bit ở trên lại, ta có:


| A | B | A XOR B | A AND B | NOT(A AND B) | A OR B | (NOT(A AND B)AND (A OR B)) |
| --- | --- | --- | --- | --- | --- | --- |
| 0 | 0 | 0 | 0 | 1 | 0 | 0 |
| 0 | 1 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 1 | 0 | 1 | 0 |

 

Do đó: A XOR B = (NOT(A AND B) AND (A OR B)), vậy để tính được XOR ta kết hợp NOT(AND) và OR sau đó tính phép tính AND.
![](images/image8.png)
Hình 5.12: Mô hình XOR
Nhìn có vẻ rối nhỉ, cùng phân tích nhé:
node NOT( _x_ 1 AND _x_ 2) chính là từ hình 5.10, với 3 mũi tên chỉ đến từ 1 _,x_ 1 _,x_ 2 với hệ số _w_ 0 _,w_ 1 _,w_ 2 tương ứng là 1.5, -1, -1.
node tính _x_ 1 OR _x_ 2 là từ hình 5.11
node trong output layer là phép tính AND từ 2 node của layer trước, giá trị hệ số từ hình 1 mang xuống.
Nhận xét: mô hình logistic regression không giải quyết được bài toán XOR nhưng mô hình mới thì giải quyết được bài toán XOR. Đâu là sự khác nhau:
Logistic regression chỉ có input layer và output layer
Mô hình mới có 1 hidden layer có 2 node ở giữa input layer và output layer.
Càng nhiều layer và node thì càng giải quyết được các bài toán phức tạp hơn.

# Public_043

# Ảnh trong máy tính

## Hệ màu RGB

RGB viết tắt của Red (đỏ), Green (xanh lục), Blue (xanh lam), là ba màu chính của ánh sáng khi tách ra từ lăng kính. Khi trộn ba màu trên theo tỉ lệ nhất định có thể tạo thành các màu khác nhau.
![](images/image1.png)
Hình 7.1: Thêm đỏ vào xanh lá cây tạo ra vàng; thêm vàng vào xanh lam tạo ra trắng [19]
Ví dụ khi bạn chọn màu ở [_đây._](https://www.w3schools.com/colors/colors_picker.asp) Khi bạn chọn một màu thì sẽ ra một bộ ba số tương ứng (r,g,b) Với mỗi bộ 3 số r, g, b nguyên trong khoảng [0, 255] sẽ cho ra một màu khác nhau. Do có 256 cách chọn r, 256 cách chọn màu g, 256 cách chọn b => tổng số màu có thể tạo ra bằng hệ màu RGB là: 256 * 256 * 256 = 16777216 màu !!!
![](images/image2.png)
Hình 7.2: màu được chọn là rgb(102, 255, 153), nghĩa là r=102, g=255, b=153.

## Ảnh màu

Ví dụ về ảnh màu trong hình 7.3
Khi bạn kích chuột phải vào ảnh trong máy tính, bạn chọn properties (mục cuối cùng), rồi chọn tab details
![](images/image3.png)
Bạn sẽ thấy chiều dài ảnh là 800 pixels (viết tắt px), chiều rộng 600 pixels, kích thước là 800 * 600. Trước giờ chỉ học đơn vị đo là mét hay centimet, pixel là gì nhỉ ?
Theo wiki, pixel (hay điểm ảnh) là một khối màu rất nhỏ và là đơn vị cơ bản nhất để tạo nên một bức ảnh kỹ thuật số.
Vậy bức ảnh trên kích thước 800 pixel * 600 pixel, có thể biểu diễn dưới dạng một ma trận kích thước 600 * 800 (vì định nghĩa ma trận là số hàng nhân số cột).
![](images/image4.png)
Hình 7.3: Mathematical bridge, Cambridge
Trong đó mỗi phần tử _w ij _là một pixel.
Như vậy có thể hiểu là mỗi pixel thì biểu diễn một màu và bức ảnh trên là sự kết hợp rất nhiều pixel. Hiểu đơn giản thì in bức ảnh ra, kẻ ô vuông như chơi cờ ca rô với 800 đường thẳng ở chiều dài, 600 đường ở chiều rộng, thì mỗi ô vuông là một pixel, biểu diễn một chấm màu.
Tuy nhiên để biểu diễn 1 màu ta cần 3 thông số (r,g,b) nên gọi _w ij _=( _r ij,gij,bij_) để biểu diễn dưới dạng ma trận thì sẽ như sau:
![](images/image5.png)
Hình 7.4: Ảnh màu kích thước 3*3 biểu diễn dạng ma trận, mỗi pixel biểu diễn giá trị (r,g,b)
Để tiện lưu trữ và xử lý không thể lưu trong 1 ma trận như thế kia mà sẽ tách mỗi giá trị màu trong mỗi pixel ra một ma trận riêng.
![](images/image6.png)
Hình 7.5: Tách ma trận trên thành 3 ma trận cùng kích thước: mỗi ma trận lưu giá trị từng màu khác nhau red, green, blue
Mỗi ma trận được tách ra được gọi là 1 channel nên ảnh màu được gọi là 3 channel: channel red, channel green, channel blue.
Tóm tắt: Ảnh màu là một ma trận các pixel mà mỗi pixel biểu diễn một điểm màu. Mỗi điểm màu được biểu diễn bằng bộ 3 số (r,g,b). Để tiện cho việc xử lý ảnh thì sẽ tách ma trận pixel ra 3 channel red, green, blue.

## Tensor là gì

Khi dữ liệu biểu diễn dạng 1 chiều, người ta gọi là vector, mặc định khi viết vector sẽ viết dưới dạng cột.
Khi dữ liệu dạng 2 chiều, người ta gọi là ma trận, kích thước là số hàng * số cột.
![](images/image7.png)
Hình 7.7: Vector v kích thước n, ma trận W kích thước m*n
Khi dữ liệu nhiều hơn 2 nhiều thì sẽ được gọi là tensor, ví dụ như dữ liệu có 3 chiều.
Để ý thì thấy là ma trận là sự kết hợp của các vector cùng kích thước. Xếp n vector kích thước m cạnh nhau thì sẽ được ma trận m*n. Thì tensor 3 chiều cũng là sự kết hợp của các ma trận cùng kích thước, xếp k ma trận kích thước m*n lên nhau sẽ được tensor kích thước m*n*k.
![](images/image8.png)
Hình 7.8: Hình hộp chữ nhật kích thước a*b*h
Tưởng tượng mặt đáy là một ma trận kích thước a * b, được tạo bởi b vector kích thước a. Cả hình hộp là tensor 3 chiều kích thước a*b*h, được tạo bởi xếp h ma trận kích thước a*b lên nhau.
Do đó biểu diễn ảnh màu trên máy tính ở phần trên sẽ được biểu diễn dưới dạng tensor 3 chiều kích thước 600*800*3 do có 3 ma trận (channel) màu red, green, blue kích thước 600*800 chồng lên nhau.
Ví dụ biểu diễn ảnh màu kích thước 28*28, biểu diễn dưới dạng tensor 28*28*3
![](images/image9.png)
Hình 7.9: Ảnh màu biểu diễn dưới dạng tensor [1]

## Ảnh xám

![](images/image10.png)

Hình 7.10: Ảnh xám của mathematical bridge
Tương tự ảnh màu, ảnh xám cũng có kích thước 800 pixel * 600 pixel, có thể biểu diễn dưới dạng một ma trận kích thước 600 * 800 (vì định nghĩa ma trận là số hàng nhân số cột).
Tuy nhiên mỗi pixel trong ảnh xám chỉ cần biểu diễn bằng một giá trị nguyên trong khoảng từ [0,255] thay vì (r,g,b) như trong ảnh màu. Do đó khi biểu diễn ảnh xám trong máy tính chỉ cần một ma trận là đủ.
![](images/image11.png)
Hình 7.11: Biểu diễn ảnh xám
Giá trị 0 là màu đen, 255 là màu trắng và giá trị pixel càng gần 0 thì càng tối và càng gần 255 thì càng sáng.

## Chuyển hệ màu của ảnh

Mỗi pixel trong ảnh màu được biểu diễn bằng 3 giá trị (r,g,b) còn trong ảnh xám chỉ cần 1 giá trị x để biểu diễn.
Khi chuyển từ ảnh màu sang ảnh xám ta có thể dùng công thức: x = r * 0.299 + g * 0.587 + b * 0.114.
Tuy nhiên khi chuyển ngược lại, bạn chỉ biết giá trị x và cần đi tìm r,g,b nên sẽ không chính xác.

# Phép tính convolution

## Convolution

Để cho dễ hình dung tôi sẽ lấy ví dụ trên ảnh xám, tức là ảnh được biểu diễn dưới dạng ma trận A kích thước m*n.
Ta định nghĩa kernel là một ma trận vuông kích thước k*k trong đó k là số lẻ. k có thể bằng 1, 3, 5, 7, 9,... Ví dụ kernel kích thước 3*3
![](images/image12.png)
Kí hiệu phép tính convolution (⊗), kí hiệu _Y_ = _X_ ⊗ _W_
Với mỗi phần tử _x ij _trong ma trận X lấy ra một ma trận có kích thước bằng kích thước của kernel W có phần tử _x ij _làm trung tâm (đây là vì sao kích thước của kernel thường lẻ) gọi là ma trận A. Sau đó tính tổng các phần tử của phép tính element-wise của ma trận A và ma trận W, rồi viết vào ma trận kết quả Y.
![](images/image13.png)
Ví dụ khi tính tại _x_ 22 (ô khoanh đỏ trong hình), ma trận A cùng kích thước với W, có _x_ 22 làm trung tâm có màu nền da cam như trong hình. Sau đó tính _y_ 11 = _sum_ ( _A_ ⊗ _W_ )= _x_ 11∗ _w_ 11+ _x_ 12∗ _w_ 12+ _x_ 13∗ _w_ 13+ _x_ 21∗ _w_ 21+ _x_ 22∗ _w_ 22+ _x_ 23∗ _w_ 23+ _x_ 31∗ _w_ 31+ _x_ 32∗ _w_ 32+ _x_ 33∗ _w_ 33 =4. Và làm tương tự với các phần tử còn lại trong ma trận.
Thế thì sẽ xử lý thế nào với phần tử ở viền ngoài như _x_ 11? Bình thường khi tính thì sẽ bỏ qua các phần tử ở viền ngoài, vì không tìm được ma trận A ở trong X.
Nên bạn để ý thấy ma trận Y có kích thước nhỏ hơn ma trận X. Kích thước của ma trận Y là (m-k+1) * (n-k+1).
![](images/image14.png)
Hình 7.12: Các bước thực hiện phép tính convolution cho ma trận X với kernel K ở trên

## Padding

Như ở trên thì mỗi lần thực hiện phép tính convolution xong thì kích thước ma trận Y đều nhỏ hơn X. Tuy nhiên giờ ta muốn ma trận Y thu được có kích thước bằng ma trận X => Tìm cách giải quyết cho các phần tử ở viền => Thêm giá trị 0 ở viền ngoài ma trận X.
![](images/image15.png)
Hình 7.13: Ma trận X khi thêm viền 0 bên ngoài
Rõ ràng là giờ đã giải quyết được vấn đề tìm A cho phần tử _x_ 11 , và ma trận Y thu được sẽ bằng
kích thước ma trận X ban đầu.
Phép tính này gọi là convolution với padding=1. Padding=k nghĩa là thêm k vector 0 vào mỗi phía (trên, dưới, trái, phải) của ma trận.

## Stride

Như ở trên ta thực hiện tuần tự các phần tử trong ma trận X, thu được ma trận Y cùng kích thước ma trận X, ta gọi là stride=1.
![](images/image16.png)
Hình 7.14: stride=1, padding=1
Tuy nhiên nếu stride=k (k > 1) thì ta chỉ thực hiện phép tính convolution trên các phần tử _x_ 1+ _i_ ∗ _k,_ 1+ _j_ ∗ _k_. Ví dụ k = 2.
![](images/image17.png)
Hình 7.15: padding=1, stride=2
Hiểu đơn giản là bắt đầu từ vị trí _x_ 11 sau đó nhảy k bước theo chiều dọc và ngang cho đến hết ma trận X.
Kích thước của ma trận Y là 3*3 đã giảm đi đáng kể so với ma trận X.
Công thức tổng quát cho phép tính convolution của ma trận X kích thước m*n với kernel kích thước k*k, stride = s, padding = p ra ma trận Y kích thước là
$$
(m−2k+ps+1)×(n−2k+ps+1)left( frac{m - 2k + p}{s} + 1 right) times left( frac{n - 2k + p}{s} + 1 right)
$$
Stride thường dùng để giảm kích thước của ma trận sau phép tính convolution.

# Public_044

# Thiết lập bài toán

Gần đây việc kiểm tra mã captcha để xác minh không phải robot của google bị chính robot vượt qua
![](images/image1.png)
Hình 8.1: Robot vượt qua kiểm tra captcha
Thế nên google quyết định cho ra thuật toán mới, dùng camera chụp ảnh người dùng và dùng deep learning để xác minh xem ảnh có chứa mặt người không thay cho hệ thống captcha cũ.
Bài toán: Input một ảnh màu kích thước 64*64, output ảnh có chứa mặt người hay không.

# Convolutional neural network

## Convolutional layer

Mô hình neural network từ những bài trước
![](images/image2.png)
Hình 8.2: Mô hình neural network.
Mỗi hidden layer được gọi là fully connected layer, tên gọi theo đúng ý nghĩa, mỗi node trong hidden layer được kết nối với tất cả các node trong layer trước. Cả mô hình được gọi là fully connected neural network (FCN).
Như bài trước về xử lý ảnh, thì ảnh màu 64*64 được biểu diễn dưới dạng 1 tensor 64*64*3. Nên để biểu thị hết nội dung của bức ảnh thì cần truyền vào input layer tất cả các pixel (64*64*3 = 12288). Nghĩa là input layer giờ có 12288 nodes.
![](images/image3.png)
Hình 8.3: Input layer và hidden layer 1
Giả sử số lượng node trong hidden layer 1 là 1000. Số lượng weight W giữa input layer và hidden layer 1 là 12288*1000 = 12288000, số lượng bias là 1000 => tổng số parameter là: 12289000. Đấy mới chỉ là số parameter giữa input layer và hidden layer 1, trong model còn nhiều layer nữa, và nếu kích thước ảnh tăng, ví dụ 512*512 thì số lượng parameter tăng cực kì nhanh => Cần giải pháp tốt hơn !!!
Nhận xét:

  * Trong ảnh các pixel ở cạnh nhau thường có liên kết với nhau hơn là những pixel ở xa. Ví dụ như phép tính convolution trên ảnh ở bài trước. Để tìm các đường trong ảnh, ta áp dụng sobel kernel trên mỗi vùng kích thước 3*3. Hay làm nét ảnh ta áp dụng sharpen kernel cũng trên vùng có kích thước 3*3.

  * Với phép tính convolution trong ảnh, chỉ 1 kernel được dùng trên toàn bộ bức ảnh. Hay nói cách khác là các pixel ảnh chia sẻ hệ số với nhau.


=> Áp dụng phép tính convolution vào layer trong neural network ta có thể giải quyết được vấn đề lượng lớn parameter mà vẫn lấy ra được các đặc trưng của ảnh.

### Convolutional layer đầu tiên

Bài trước phép tính convolution thực hiện trên ảnh xám với biểu diễn ảnh dạng ma trận
![](images/image4.png)
Tuy nhiên ảnh màu có tới 3 channels red, green, blue nên khi biểu diễn ảnh dưới dạng tensor 3 chiều. Nên ta cũng sẽ định nghĩa kernel là 1 tensor 3 chiều kích thước k*k*3.
![](images/image5.png)
Hình 8.4: Phép tính convolution trên ảnh màu với k=3.
Ta định nghĩa kernel có cùng độ sâu (depth) với biểu diễn ảnh, rồi sau đó thực hiện di chuyển khối kernel tương tự như khi thực hiện trên ảnh xám.
![](images/image6.png)
Hình 8.5: Tensor X, W 3 chiều được viết dưới dạng 3 matrix.
Khi biểu diễn ma trận ta cần 2 chỉ số hàng và cột: i và j, thì khi biểu diễn ở dạng tensor 3 chiều cần thêm chỉ số độ sâu k. Nên chỉ số mỗi phần tử trong tensor là _x ijk_.
Nhận xét:

  * Output Y của phép tính convolution trên ảnh màu là 1 matrix.

  * Có 1 hệ số bias được cộng vào sau bước tính tổng các phần tử của phép tính element-wise


**Các quy tắc đối với padding và stride toàn hoàn tương tự như ở bài trước.**
Với mỗi kernel khác nhau ta sẽ học được những đặc trưng khác nhau của ảnh, nên trong mỗi convolutional layer ta sẽ dùng nhiều kernel để học được nhiều thuộc tính của ảnh. Vì mỗi kernel cho ra output là 1 matrix nên k kernel sẽ cho ra k output matrix. Ta kết hợp k output matrix này lại thành 1 tensor 3 chiều có chiều sâu k.
![](images/image7.png)
Hình 8.6: Thực hiện phép tính convolution trên ảnh màu.
![](images/image8.png)
Hình 8.7: Convolutional layer đầu tiên
Output của convolutional layer đầu tiên sẽ thành input của convolutional layer tiếp theo.

### Convolutional layer tổng quát

Giả sử input của 1 convolutional layer tổng quát là tensor kích thước H * W * D.
Kernel có kích thước F * F * D (kernel luôn có depth bằng depth của input và F là số lẻ), stride: S, padding: P.
Convolutional layer áp dụng K kernel.
=> Output của layer là tensor 3 chiều có kích thước: $$
(H−F+2PS+1)*(W−F+2PS+1)left( frac{H - F + 2P}{S} + 1 right)*left( frac{W - F + 2P}{S} + 1 right)
$$∗ _K_
Lưu ý:

  * Output của convolutional layer sẽ qua hàm non-linear activation function trước khi trở thành input của convolutional layer tiếp theo.

  * Tổng số parameter của layer: Mỗi kernel có kích thước F*F*D và có 1 hệ số bias, nên tổng parameter của 1 kernel là F*F*D + 1. Mà convolutional layer áp dụng K kernel => Tổng số parameter trong layer này là K * (F*F*D + 1).


## Pooling layer

Pooling layer thường được dùng giữa các convolutional layer, để giảm kích thước dữ liệu nhưng vẫn giữ được các thuộc tính quan trọng. Việc giảm kích thước dữ liệu giúp giảm các phép tính toán trong model.
Bên cạnh đó, với phép pooling kích thước ảnh giảm, do đó lớp convolution học được các vùng có kích thước lớn hơn. Ví dụ như ảnh kích thước 224*224 qua pooling về 112*112 thì vùng 3*3 ở ảnh 112*112 tương ứng với vùng 6*6 ở ảnh ban đầu. Vì vậy qua các pooling thì kích thước ảnh nhỏ đi và convolutional layer sẽ học được các thuộc tính lớn hơn.
Gọi pooling size kích thước K*K. Input của pooling layer có kích thước H*W*D, ta tách ra làm D ma trận kích thước H*W. Với mỗi ma trận, trên vùng kích thước K*K trên ma trận ta tìm maximum hoặc average của dữ liệu rồi viết vào ma trận kết quả. Quy tắc về stride và padding áp dụng như phép tính convolution trên ảnh.
![](images/image9.png)
Hình 8.8: max pooling layer với size=(3,3), stride=1, padding=0
Nhưng hầu hết khi dùng pooling layer thì sẽ dùng size=(2,2), stride=2, padding=0. Khi đó output width và height của dữ liệu giảm đi một nửa, depth thì được giữ nguyên.
![](images/image10.png)
Hình 8.9: Sau pooling layer (2*2) [4]
Có 2 loại pooling layer phổ biến là: max pooling và average pooling.
![](images/image11.png)
Hình 8.10: Ví dụ về pooling layer
**Trong một số model người ta dùng convolutional layer với stride > 1 để giảm kích thước dữ liệu thay cho pooling layer.**

## Fully connected layer

Sau khi ảnh được truyền qua nhiều convolutional layer và pooling layer thì model đã học được tương đối các đặc điểm của ảnh (ví dụ mắt, mũi, khung mặt,...) thì tensor của output của layer cuối cùng, kích thước H*W*D, sẽ được chuyển về 1 vector kích thước (H*W*D, 1)
![](images/image12.png)
Sau đó ta dùng các fully connected layer để kết hợp các đặc điểm của ảnh để ra được output của model.

# Mạng VGG 16

VGG16 là mạng convolutional neural network được đề xuất bởi K. Simonyan and A. Zisserman, University of Oxford. Model sau khi train bởi mạng VGG16 đạt độ chính xác 92.7% top-5 test trong dữ liệu ImageNet gồm 14 triệu hình ảnh thuộc 1000 lớp khác nhau. Giờ áp dụng kiến thức ở trên để phân tích mạng VGG 16.
![](images/image13.png)
Hình 8.11: Kiến trúc VGG16 conv: convolutional layer, pool: pooling layer, fc: fully connected layer
Phân tích:

  * Convolutional layer: kích thước 3*3, padding=1, stride=1. Tại sao không ghi stride, padding mà vẫn biết? Vì mặc định sẽ là stride=1 và padding để cho output cùng width và height với input.

  * Pool/2 : max pooling layer với size 2*2

  * 3*3 conv, 64: thì 64 là số kernel áp dụng trong layer đấy, hay depth của output của layer đấy.

  * Càng các convolutional layer sau thì kích thước width, height càng giảm nhưng depth càng tăng.

# Public_045

# Transfer learning

Bạn có bài toán cần nhận diện 1000 người nổi tiếng ở Việt Nam, tuy nhiên dữ liệu để train chỉ khoảng 10 ảnh / 1 người. Số lượng dữ liệu là quá ít để train một mô hình CNN hoàn chỉnh.

Bạn tìm trên mạng thấy VGGFace2 dataset có 3.31 triệu ảnh của 9131 người, với trung bình 362.6 ảnh cho mỗi người. Họ làm bài toán tương tự đó là nhận diện ảnh từng người và họ đã train được CNN model với accuracy hơn 99%.

Bạn nhớ ra là trong convolutional neural network, convolutional layer có tác dụng lấy ra các đặc trưng của ảnh, và sau hàng loạt các convolutional layer + pooling layer (ConvNet) thì model sẽ học được các đặc điểm của ảnh, trước khi được cho vào fully connected layer => ConvNet trong VGGFace2 model cũng lấy ra được các đặc điểm của mặt người (tai, mũi, tóc,...) => Ta cũng có thể áp dụng phần ConvNet của VGGFace2 model vào bài toán nhận diện mặt người nổi tiếng ở Việt Nam để lấy ra các đặc điểm của mặt.

Quá trình sử dụng pre-trained model như trên gọi là transfer learning.

Các pre-trained model được sử dụng thường là các bài toán được train với dữ liệu lớn ví dụ ImageNet, dữ liệu chứa 1.2 triệu ảnh với 1000 thể loại khác nhau.

Có 2 loại transfer learning:

  * **Feature extractor** : Sau khi lấy ra các đặc điểm của ảnh bằng việc sử dụng ConvNet của pre-trained model, thì ta sẽ dùng linear classifier (linear SVM, softmax classifier,..) để phân loại ảnh. Hiểu đơn giản thì các đặc điểm ảnh (tai, mũi, tóc,...) giờ như input của bài toán linear regression hay logistic regression.

  * **Fine tuning** : Sau khi lấy ra các đặc điểm của ảnh bằng việc sử dụng ConvNet của pre-trained model, thì ta sẽ coi đây là input của 1 CNN mới bằng cách thêm các ConvNet và Fully Connected layer. Lý do là ConvNet của VGGFace 2 model có thể lấy ra được các thuộc tính của mặt người nói chung nhưng người Việt Nam có những đặc tính khác nên cần thêm 1 số Convnet mới để học thêm các thuộc tính của người Việt Nam.


![](images/image4.png)

Hình 11.1: Hiệu quả khi sử dụng transfer learning [2]

**Bài toán** : Ta muốn nhận diện ảnh của 17 loài hoa, mỗi loài hoa có khoảng 80 ảnh.

Sử dụng pre-trained model là VGG 16 của ImageNet. Mô hình VGG 16 mọi người có thể xem lại bài CNN. Mô hình VGG16 của ImageNet dataset, phân loại ảnh thuộc 1000 thể loại khác nhau. Nên có thể hiểu là nó đủ tổng quát để tách ra các đặc điểm của bức ảnh, cụ thể ở đây là hoa.

## Feature extractor

Ta chỉ giữ lại phần ConvNet trong CNN và bỏ đi FCs. Sau đó dùng output của ConvNet còn lại để làm input cho Logistic Regression với nhiều output, như trong hình 11.2.

Mô hình logistic regression với nhiều output có 2 dạng:

Dạng thứ nhất là một neural network, không có hidden layer, hàm activation ở output layer là softmax function, loss function là hàm categorical-cross entropy, giống như bài phân loại ảnh.

![](images/image2.png)

Hình 11.2: Bên trái là mô hình VGG16, bên phải là mô hình VGG16 chỉ bao gồm ConvNet (bỏ Fully Connected layer) [21]

![](images/image3.png)

Dạng thứ hai giống như bài logistic regression, tức là model chỉ phân loại 2 class. Mỗi lần ta sẽ phân loại 1 class với tất cả các class còn lại.

![](images/image10.png)

Hình 11.3: 1 vs all classification [13]

## Fine tuning

Ta chỉ giữ lại phần ConvNet trong CNN và bỏ đi FCs. Sau đó thêm các Fully Connected layer mới vào output của ConvNet như trong hình 11.4.

Khi train model ta chia làm 2 giai đoạn

**Giai đoạn 1** : Vì các Fully Connected layer ta mới thêm vào có các hệ số được khởi tạo ngẫu nhiên tuy nhiên các layer trong ConvNet của pre-trained model đã được train với ImageNet dataset nên ta sẽ không train (đóng băng/freeze) trên các layer trong ConvNet của model VGG16. Sau khoảng 20-30 epoch thì các hệ số ở các layer mới đã được học từ dữ liệu thì ta chuyển sang giai đoạn 2.

![](images/image9.png)

Hình 11.5: Freeze các layer của pre-trained model, chỉ train ở các layer mới [21]

**Giai đoạn 2** : Ta sẽ unfreeze các layer trên ConvNet của pre-trained model và train trên các layer của ConvNet của pre-trained model và các layer mới. Bạn có thể unfreeze tất cả các layer trong ConvNet của VGG16 hoặc chỉ unfreeze một vài layer cuối tùy vào thời gian và GPU bạn có.

![](images/image5.png)

Hình 11.6: Freeze các layer của pre-trained model, chỉ train ở các layer mới [21]

Accuracy của fine-tuning tốt hơn so với feature extractor tuy nhiên thời gian train của fine-tuning cũng lâu hơn rất nhiều. Giải thích đơn giản thì feature extractor chỉ lấy ra đặc điểm chung chung từ pre-trained model của ImageNet dataset cho các loài hoa, nên không được chính xác lắm. Tuy nhiên ở phần fine-tuning ta thêm các layer mới, cũng như train lại 1 số layer ở trong ConvNet của VGG16 nên model giờ học được các thuộc tính, đặc điểm của các loài hoa nên độ chính xác tốt hơn.

## Khi nào nên dùng transfer learning

Có 2 yếu tố quan trọng nhất để dùng transfer learning đó là kích thước của dữ liệu bạn có và sự tương đồng của dữ liệu giữa mô hình bạn cần train và pre-trained model.

  * Dữ liệu bạn có nhỏ và tương tự với dữ liệu ở pre-trained model. Vì dữ liệu nhỏ nên nếu dùng fine-tuning thì model sẽ bị overfitting. Hơn nữa là dữ liệu tương tự nhau nên là ConvNet của pre-trained model cũng lấy ra các đặc điểm ở dữ liệu của chúng ta. Do đó nên dùng feature extractor.

  * Dữ liệu bạn có lớn và tương tự với dữ liệu ở pre-trained model. Giờ có nhiều dữ liệu ta không sợ overfitting do đó nên dùng fine-tuning.

  * Dữ liệu bạn có nhỏ nhưng khác với dữ liệu ở pre-trained model. Vì dữ liệu nhỏ nên ta lên dùng feature extractor để tránh overfitting. Tuy nhiên do dữ liệu ta có và dữ liệu ở pre-trained model khác nhau, nên không nên dùng feature extractor với toàn bộ ConvNet của pre-trained model mà chỉ dùng các layer đầu. Lý do là vì các layer ở phía trước sẽ học các đặc điểm chung chung hơn (cạnh, góc,...), còn các layer phía sau trong ConvNet sẽ học các đặc điểm cụ thể hơn trong dataset (ví dụ mắt, mũi,..).

  * Dữ liệu bạn có lớn và khác với dữ liệu ở pre-trained model. Ta có thể train model từ đầu, tuy nhiên sẽ tốt hơn nếu ta khởi tạo các giá trị weight của model với giá trị của pre-trained model và sau đó train bình thường.


**Lưu ý**

  * Vì pre-trained model đã được train với kích thước ảnh cố định, nên khi dùng pre-trained model ta cần resize lại ảnh có kích ảnh bằng kích thước mà ConvNet của pre-trained model yêu cầu.

  * Hệ số learning rate của ConvNet của pre-trained model nên được đặt với giá trị nhỏ vì nó đã được học ở pre-trained model nên ít cần cập nhật hơn so với các layer mới thêm.


# Data augmentation

Ngoài transfer learning, có một kĩ thuật nữa giải quyết vấn đề có ít dữ liệu cho việc training model, đó là data augmentation. Augmentation là kĩ thuật tạo ra dữ liệu training từ dữ liệu mà ta đang có. Cùng xem một số kĩ thuật augmentation phổ biến với ảnh nhé.

Flip: Lật ngược ảnh theo chiều dọc hoặc chiều ngang

![](images/image7.png)

Hình 11.7: lật ngược ảnh theo chiều dọc

Rotation: Quay ảnh theo nhiều góc khác nhau

![](images/image6.png)

Hình 11.8: Rotate ảnh 30 độ

Scale: Phóng to hoặc thu nhỏ ảnh

![](images/image8.png)

Hình 11.9: Scale ảnh

Crop: Cắt một vùng ảnh sau đó resize vùng ảnh đấy về kích thước ảnh ban đầu

![](images/image8.png)

Hình 11.10: Crop ảnh

# Public_046

# Vectorization

Ngay từ bài đầu tiên về linear regression, tôi đã giới thiệu về việc biểu diễn và tính toán dưới dạng vector. Việc biểu diễn bài toán dưới dạng vector như vậy gọi là vectorization. Nó không chỉ giúp code gọn lại mà còn tăng tốc độ tính đoán một cách đáng kể khi thực hiện các phép tính trên vector, ma trận so với for-loop.
_# -*- coding: utf-8 -*-_
import numpy as np import time  
a = np.random.rand(10000000)  
b = np.random.rand(10000000)  
start = time.time()  
c = np.dot(a, b.T)  
end = time.time()  
print("Vectorization time : ", end-start)
start = time.time()  
c = 0  
for i in range(len(a)):  
c += a[i] * b[i]  
end = time.time()  
print("For-loop time : ", end-start)
Bạn sẽ thấy nếu dùng for-loop mất hơn 4s để nhân 2 vector trong khi dùng thư viện numpy để tính chỉ mất 0.01s. Tại sao lại như thế nhỉ?
Giả sử bạn có 10 tấn hàng cần vận chuyển từ A đến B và bạn có một xe tải với khả năng chở được 5 tấn mỗi lần. Vậy nếu chất đầy hàng mỗi lần chở thì chỉ cần 2 lần chạy là chuyển hết số hàng. Tuy nhiên nếu mỗi lần bạn chỉ chất 1 tấn hàng lên xe để chở đi thì xe cần đi tới 10 lần để chuyển hết số hàng.
Tương tự như vậy, khi nhân 2 vector ở trên bạn cần thực hiện 10000000 phép tính nhân 2 số. Giả sử máy tính có thể tính được tối đa 1000 phép tính nhân một lúc. Việc bạn dùng for-loop giống như mỗi thời điểm bạn chỉ yêu cầu máy tính thực hiện một phép nhân, nên để nhân 2 vector sẽ cần 10000000 đơn vị thời gian. Tuy nhiên thư viện numpy sẽ tối ưu việc tính toán bằng cách yêu cầu máy tính thực hiện 1000 phép tính một lúc, tức là chỉ cần ![](images/image1.png) =10000 đơn vị thời gian để hoàn thành phép nhân 2 vector. Vậy nên là việc vectorization thông thường sẽ tính toán nhanh hơn.

# Mini-batch gradient descent

## Mini-batch gradient descent là gì

Ở trong thuật toán gradient descent, tại bước thứ hai khi ta tính đạo hàm của loss function với các biến. Trong bài linear regression, ta dùng tất cả các dữ liệu trong dataset để tính đạo hàm rồi cập nhật bước 2:
![](images/image2.jpg)
Thuật toán gradient descent chạy tốt nhưng số lượng dữ liệu trong training set chỉ là 30. Tuy nhiên nếu dữ liệu có kích thước lớn như ảnh và số lượng lớn hơn ví dụ 5000 thì việc tính đạo hàm với loss function với toàn bộ dữ liệu sẽ rất tốn thời gian. Và mini-batch gradient descent ra đời để giải quyết vấn đề đấy.
Dựa vào số lượng dữ liệu cho mỗi lần thực hiện bước 2 trong gradient descent là người ta chia ra làm 3 loại:

  * Batch gradient descent: Dùng tất cả dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm.

  * Mini-batch gradient descent: Dùng một phần dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm.

  * Stochastic gradient descent: Chỉ dùng một dữ liệu trong training set cho mỗi lần thực hiện bước tính đạo hàm.


Ví dụ điểm thi đại học trung bình của một trường trung học phổ thông là 24 điểm. Batch gradient descent giống như tính điểm trung bình tất cả học sinh thi đại học năm nay của trường, con số sẽ tương đối gần 24, ví dụ 24,5. Mini-batch sẽ chọn ngẫu nhiên một số học sinh, ví dụ 32 học sinh để tính điểm trung bình thì điểm trung bình sẽ xa 24 hơn ví dụ 22. Tuy nhiên, Stochastic giống như chỉ chọn một học sinh làm điểm trung bình, thì lúc này điểm trung bình có thể khác xa con số 24 rất nhiều, ví dụ 18 hoặc 29. Việc điểm trung bình ở mini-batch hay stochastic khác so với điểm trung bình toàn trường gọi là nhiễu trong dữ liệu. Hay giải thích đơn giản là chỉ lấy 1 hoặc một phần dữ liệu thì không thể mô tả hết được tất cả dữ liệu.
Do đó hàm loss-function với hệ số learning_rate phù hợp thì batch gradient descent theo epoch sẽ giảm đều đặn. Vì có nhiễu trong dữ liệu nên mini-batch thì vẫn giảm nhưng có dao động và stochastic có giảm nhưng dao động cực kì lớn.
![](images/image3.jpg)
Hình 12.1: So sánh loss function khi dùng batch và mini-batch [13]
Hình dưới là biểu diễn biệc cập nhật hệ số trong gradient descent, điểm đỏ là giá trị nhỏ nhất ta cần tìm, các điểm ở ngoài cùng là giá trị khởi tạo của hệ số trong gradient descent. Ta có thể thấy vì không có nhiễu nên batch gradient descent thì hệ số cập nhật trực tiếp theo 1 đường thẳng. Mini-batch thì mất nhiều thời gian hơn và còn đi chệch hướng tuy nhiên thì vẫn đến được điểm đỏ. Còn stochastic thì đi khá lòng vòng để đến được điểm đỏ và vì dữ liệu quá nhiễu nên có thể thuật toán gradient descent chỉ quanh điểm đỏ mà không đến được điểm đỏ (minimum point).
![](images/image4.jpg)
Hình 12.2: Cập nhật loss function đến minimum point của các thuật toán [13]
Batch gradient descent thường được dùng khi số lượng dữ liệu trong training set nhỏ hơn 2000. Với lượng dữ liệu lớn thì mini-batch gradient descent được sử dụng. Nó có thể giải quyết được vấn đề lượng dữ liệu quá lớn như trong batch gradient descent, hơn nữa đỡ nhiễu và có thể dùng vectorization so với stochastic gradient descent nên thường được sử dụng trong deep learning.

## Các thông số trong mini-batch gradient descent

Ví dụ code trong bài 7, trong bài toán phân loại chữ số cho dữ liệu MNIST
H = model.fit(X_train, Y_train, validation_data=(X_val, Y_val), batch_size=32, epochs=10, verbose=1)
X_train, Y_train là dữ liệu và label cho training set. Tương tự X_val, Y_val là dữ liệu cho validation set.
**batch_size** : Là size trong mini-batch gradient descent, nghĩa là dùng bao nhiêu dữ liệu cho mỗi lần tính và cập nhật hệ số.
**steps_per_epoch** : Là bao nhiêu lần thực hiện bước 2 trong gradient descent trong mỗi epoch. Mặc định sẽ là số lượng dữ liệu chia cho batch_size. Hiểu đơn giản là mỗi epoch sẽ dùng hết các dữ liệu để tính gradient descent. **epochs** : số lượng epoch thực hiện trong quá trình training.
Vậy thực sự số lần thực hiện bước 2 trong gradient descent trong quá trình training là: epochs * steps_per_epoch.
Lời khuyên:

  * Batch_size nên được chọn là số mũ của 2 ví dụ 16, 32, 64, 128 để CPU/GPU tính toán tốt hơn. Giá trị mặc định là 32.

  * Nên vẽ đồ thị loss/epoch để chọn batch_size phù hợp.


# Bias và variance

## Bias, variance là gì

Bias: nghĩa là độ lệch, biểu thị sự chênh lệch giữa giá trị trung bình mà mô hình dự đoán và giá trị thực tế của dữ liệu.
Variance: nghĩa là phương sai, biểu thị độ phân tán của các giá trị mà mô hình dự đoán so với giá trị thực tế.
![](images/image5.jpg)
Giá trị thật dữ liệu (ground truth) ở giữa tâm các đường tròn. Các dấu X là các giá trị dự đoán. Ta thấy nếu high bias thì giá trị dự đoán rất xa tâm. Tuy nhiên nếu high variance thì các giá trị dự đoán phân tán rộng dẫn đến việc ra giá trị thực tế. => Ta mong muốn low bias và low variance.
![](images/image6.jpg)
Đây là bài toán logistic regression, cần tìm đường phân chia dữ liệu.

  * Ở hình 1, thì đường phân chia có khá nhiều điểm bị lỗi => sự chênh lệch giữa mô hình dự đoán và giá trị thực tế của dữ liệu cao => **high bias** , hay còn được gọi là **underfitting** , ý hiểu là mô hình hiện tại đơn giản hơn và chưa mô tả được mô hình của dữ liệu thực tế.

  * Ở hình 2, đường phân chia vẫn có lỗi nhưng ở mức chấp nhận được và nó có thể mô tả dữ liệu => **low bias, low variance**.

  * Ở hình 3, đường phân chia có thể dự đoán đúng tất cả các điểm trong training set nhưng vì nó không tổng quát hóa mô hình dữ liệu thực sự nên khi áp dụng dự đoán vào validation set thì sẽ có rất nhiều lỗi => **high variance** hay còn được gọi là **overfitting** , ý hiểu là mô hình hiện tại thực hiện tốt với dữ liệu trong training set nhưng dự đoán không tốt với validation set. Thực ra khái niệm high bias và high variance khá trìu tượng và nhiều lúc dùng nhầm lẫn giữa thống kê và machine learning. Nên khái niệm hay được dùng hơn là underfitting và overfitting.


![](images/image7.jpg)
Hình 12.3: Các điểm màu xanh là training set, điểm màu đỏ là validation set
Ví dụ khi luyện thi đại học, nếu bạn chỉ luyện khoảng 1-2 đề trước khi thi thì bạn sẽ bị underfitting vì bạn chưa hiểu hết cấu trúc, nội dung của đề thi. Tuy nhiên nếu bạn chỉ luyện kĩ 50 đề thầy cô giáo bạn soạn và đưa cho thì khả năng bạn sẽ bị overfitting với các đề mà thầy cô giáo các bạn soạn mà khi thi đại học có thể điểm số của các bạn vẫn tệ.

## Bias, variance tradeoff

Nếu model quá đơn giản thì ta sẽ bị high bias và low variance. Tuy nhiên nếu model quá phức tạp thì sẽ bị high variance và low bias. Đấy là bias, variance tradeoff. Do đó để train được model tốt ta cần cân bằng giữa bias và variance.

## Đánh giá bias and variance

Có 2 thông số thường được sử dụng để đánh giá bias and variance của mô hình là training set error và validation set error. Ví dụ error (1-accuracy) trong logistic regression.


| Train set error | 1% | 15% | 15% | 0.5% |
| --- | --- | --- | --- | --- |
| Val set error | 11% | 16% | 30% | 1% |
|  | High variance | High bias | High biasHigh variance | Low biasLow variance |

 

Ta mong muốn model là low bias và low variance. Cùng xem một số cách để giải quyết vấn đề high bias hoặc high variance nhé.
Giải quyết high bias (underfitting): Ta cần tăng độ phức tạp của model

  * Tăng số lượng hidden layer và số node trong mỗi hidden layer.

  * Dùng nhiều epoch hơn để train model. Giải quyết high variance (overfitting):

  * Thu thập thêm dữ liệu hoặc dùng data augmentation

  * Dùng regularization như: L1, L2, dropout


# Dropout

## Dropout là gì

Dropout với hệ số p nghĩa là trong quá trình train model, với mỗi lần thực hiện cập nhật hệ số trong gradient descent ta ngẫu nhiên loại bỏ p% số lượng node trong layer đấy, hay nói cách khác là giữ lại (1-p%) node. Mỗi layer có thể có các hệ số dropout p khác nhau.
![](images/image8.jpg)
Hình 12.4: So sánh model dropout và neural network thông thường [26]
Ví dụ mô hình neural network 1-2-1: 1 input layer, 2 hidden layer và 1 output layer. Ví dụ như hidden layer 1, ta dùng dropout với p = 0.6, nên chỉ giữ lại 2 trên 5 node cho mỗi lần cập nhật.

## Dropout hạn chế việc overfitting

Overfitting là mô hình đang dùng quá phức tạp so với mô hình thật của dữ liệu. Khi ta dùng dropout như hình trên thì rõ ràng mô hình bên phải đơn giản hơn => tránh overfitting.
Thêm vào đó, vì mỗi bước khi train model thì ngẫu nhiên (1-p%) các node bị loại bỏ nên model không thể phụ thuộc vào bất kì node nào của layer trước mà thay vào đó có xu hướng trải đều weight, giống như trong L2 regularization => tránh được overfitting.

## Lời khuyên khi dùng dropout

  * Hệ số p nên ở khoảng [0.2, 0.5] . Nếu p quá nhỏ thì không có tác dụng chống overfitting, tuy nhiên nếu p quá lớn thì gần như loại bỏ layer đấy và có thể dẫn đến underfitting.

  * Nên dùng model lớn, phức tạp hơn vì ta có dropout chống overfitting.

  * Dropout chỉ nên dùng cho Fully Connected layer, ít khi được dùng cho ConvNet layer

  * Hệ số p ở các layer nên tỉ lệ với số lượng node trong FC layer đó.


# Activation function

## Non-linear activation function

Hàm activation function được dùng sau bước tính tổng linear trong neural network hoặc sau convolutional layer trong CNN. Và hàm activation là non-linear function.
Linear function là gì? Theo wiki, "a linear function from the real numbers to the real numbers is a function whose graph is a line in the plane ", tóm lại linear function là một đường thẳng dạng y = a*x + b. Vậy sẽ ra sao nếu hàm activation trong neural network là một linear function?
Giả sử hàm activation dạng y = f(x) = 2*x + 3 và neural network như sau:
![](images/image9.jpg)
Hình 12.5: Mô hình neural network, 1-2-1.
_z_ ![](images/image10.png)
Tương tự _a_ ![](images/image11.png)
Do đó
_y_ ˆ![](images/image12.png)

_x_ ![](images/image13.png)

![](images/image14.png)
Tóm lại _y_ ˆ = _x_ ∗ _a_ + _b_ hay nói cách khác mô hình neural network chỉ là mô hình linear regression đơn giản => **Hàm activation function phải là non-linear function**.

## Vanishing và exploding gradient

Backpropagation là thuật toán được dùng để tính đạo hàm các hệ số trong neural network với loss function đề rồi áp dụng gradient descent để tìm các hệ số.
![](images/image15.jpg)
Hình 12.6: Mô hình neural network 2-3-3-1
![](images/image16.jpg)
Hình 12.7: Quá trình backpropagation
Ta có tổng quát:
$$
∂J∂Â(l)=∂J∂Ŷ⋅∏i=l+1nD(i)W(i)frac{partial J}{partial{widehat{A}}^{(l)}} = frac{partial J}{partialwidehat{Y}} cdot prod_{i = l + 1}^{n}{D^{(i)}W^{(i)}}
$$
Nhận xét:

  * Nếu các hệ số W và D đều nhỏ hơn 1 thì khi tính gradient ở các layer đầu ta sẽ phải nhân tích của rất nhiều số nhỏ hơn 1 nên giá trị sẽ tiến dần về 0 và bước cập nhật hệ số trong gradient descent trở nên vô nghĩa và các hệ số neural network sẽ không học được nữa. => **Vanishing gradient**

  * Nếu các hệ số W và D đều lớn hơn 1 thì khi tính gradient ở các layer đầu ta sẽ phải nhân tích của rất nhiều số lớn hơn 1 nên giá trị sẽ tiến dần về vô cùng và bước cập nhật hệ số trong gradient descent trở nên không chính xác và các hệ số neural network sẽ không học được nữa. => **Exploding gradient**


Cách giải quyết vaninshing/exproding gradient là lựa chọn các giá trị khởi tạo cho hệ số phù hợp và chọn activation function phù hợp.

## Một số activation thông dụng

### Sigmoid activation function

![](images/image17.jpg)
Hình 12.8: Hàm sigmoid
Đạo hàm hàm sigmoid là $$
σ(x)⋅(1−σ(x))≤14sigma(x) cdot left( 1 - sigma(x) right) leq frac{1}{4}
$$
Ví dụ ![](images/image18.png) nên nếu bạn nhìn vào công thức (1) ở trên thì ở những layer đầu tiên sẽ bị **vanishing gradient**.

### Tanh activation function

![](images/image19.jpg)
Hình 12.9: Hàm tanh
Hàm tanh: $$
g(x)=ex−e−xex+e−xg(x) = frac{e^{x} - e^{- x}}{e^{x} + e^{- x}}
$$, giá trị g(x) trong đoạn (-1,1)
Đạo hàm hàm tanh: $1−g2(x)≤11 - g^{2}(x) leq 1$. Do đó khi dùng tanh activation function sẽ bị vanishing gradient.

### ReLU activation function

![](images/image20.jpg)
Hình 12.10: Hàm ReLU
Hàm relu (rectified linear unit): _y_ = _max_ (0 _,x_ ) Nhận xét:

  * Hàm ReLU activation đơn giản để tính => thời gian train model nhanh hơn.

  * Đạo hàm là 1 với x >= 0 nên không bị vanishing gradient.


Tuy nhiên với các node có giá trị nhỏ hơn 0, qua ReLU activation sẽ thành 0, hiện tượng đấy gọi là "Dying ReLU". Nếu các node bị chuyển thành 0 thì sẽ không có ý nghĩa với bước linear activation ở lớp tiếp theo và các hệ số tương ứng từ node đấy cũng không được cập nhật với gradient descent. => Leaky ReLU ra đời.

### Leaky ReLU

![](images/image21.jpg)
Hình 12.11: Hàm Leaky ReLU
Hàm Leaky ReLU có các điểm tốt của hàm ReLU và giải quyết được vấn đề Dying ReLU bằng cách xét một độ dốc nhỏ cho các giá trị âm thay vì để giá trị là 0.
Lời khuyên: Mặc định nên dùng ReLU làm hàm activation. Không nên dùng hàm sigmoid.

# Batch Normalize

Một trong những giả định chính trong được đưa ra trong quá trình huấn luyện một mô hình học máy đó là phân phối của dữ liệu được giữ nguyên trong suốt quá trình training. Đối với các mô hình tuyến tính, đơn giản là ánh xạ input với output thích hợp, điều kiện này luôn được thỏa mãn. Tuy nhiên, trong trường hợp Neural Network với các lớp được xếp chồng lên nhau, ảnh hưởng của các hàm activation non-linear, điều kiện trên không còn đúng nữa.
Trong kiến trúc neural network, đầu vào của mỗi lớp phụ thuộc nhiều vào tham số của toàn bộ các lớp trước đó. Hậu quả là trong quá trình backprop, các trọng số của một lớp được cập nhật dẫn đến những thay đổi về mặt dữ liệu sau khi đi qua lớp đó, những thay đổi này bị khuyếch đại khi mạng trở nên sâu hơn và cuối cùng làm phân phối của bản đồ đặc trưng (feature map) thay đổi, đây được gọi là hiện tượng covariance shifting. Khi huấn luyện, các lớp luôn phải điều chỉnh trọng số để đáp ứng những thay đổi về phân phối dữ liệu nhận được từ các lớp trước, điều này làm chậm quá trình hội tụ của mô hình.

## Phân tích nguyên nhân

Vấn đề 1 : Khi dữ liệu chứa nhiều thành phần lớn hơn hoặc nhỏ hơn 0 và không phân bố quanh giá trị trung bình 0 (Non zero mean), kết hợp với việc phương sai lớn (high variance) làm cho dữ liệu chứa nhiều thành phần rất lớn hoặc rất nhỏ. Trong quá trình cập nhật trọng số bằng gradient descent, giá trị của dữ liệu ảnh hưởng trực tiếp lên giá trị đạo hàm (gradient), do đó làm giá trị gradient trở nên quá lớn hoặc qúa nhỏ, như chúng ta đã biết điều này không hề tốt chút nào. Hiện tượng trên xuất hiện khá phổ biến, phụ thuộc nhiều vào việc khởi tạo trọng số, và có xu hướng nghiêm trọng hơn khi mạng ngày càng sâu.
=> Cần một bước normalize các thành phần dữ liệu về cùng mean và chuẩn hóa variance.
Vấn đề 2 : Các hàm activation non-linear như sigmoid, relu, tanh,... đều có ngưỡng hay vùng bão hòa. Khi lan truyền thẳng, nếu dữ liệu có các thành phần quá lớn hoặc quá nhỏ, sau khi đi qua các hàm activation, các thành phần này sẽ rơi vào vùng bão hòa và có đầu ra giống nhau. Điều này dẫn đến luồng dữ liệu sau đó trở nên giống nhau khi lan truyền trong mạng (covariance
shifting), lúc này các lớp còn lại trong mạng không còn phân biệt được các đặc trưng khác nhau. Ngoài ra, đạo hàm tại ngưỡng của các hàm activation bằng 0, điều này cũng khiến mô hình bị vanishing gradient.
=> Cần một bước normalize dữ liệu trước khi đi qua hàm activation.
![](images/image22.jpg)
Hình 12.12: Đồ thị các hàm activation

## Batch Normalization ra đời

Batch normalization thực hiện việc chuẩn hóa (normalizing) và zero centering (mean substracting) dữ liệu trước khi đưa qua hàm activation (giá trị trung bình (mean) sẽ được đưa về 0 và phương sai (variance) sẽ được đưa về 1). Để thực hiện 2 công việc trên, batch normalization tính toán phương sai và độ lệch chuẩn của dữ liệu dựa trên các batchs, rồi sử dụng 2 tham số _γ_ và _β_ tinh chỉnh đầu ra.
Batch normalization:
_µ B _![](images/image23.png) _x_ ( _i_ )
![](images/image24.png)
_x_ ˆ![](images/image25.png)
_z_ ( _i_ ) = _γx_ ˆ+ _β_
Trong đó: _µ B _là giá trị trung bình của batch B
_σ 2B_ là phương sai của batch B
_x_ ˆ( _i_ ) là giá trị của mẫu thứ i trong batch B sau khi được normalize và zero centering
_z_ ( _i_ ) là đầu ra của mẫu thứ i trong batch B
_γ_ là scaling parameter của lớp
_β_ là shifting parameter của lớp
_ξ_ là smoothing parameter, tránh xảy ra việc chia cho 0, giá trị rất nhỏ
Chú ý: _γ_ và _β_ là 2 tham số được học trong quá trình training.

## Hiệu quả của batch normalization

  * Batch normalization đưa dữ liệu về zero mean và chuẩn hóa variance trước khi đưa qua activation function nhờ đó giải quyết các vấn đề vanishing gradient hay exploding gradient.

  * Batch normalization cho phép learning rate lớn trong quá trình huấn luyện.

  * Batch-Norm giảm thiểu sự ảnh hưởng của quá trình khởi tạo trọng số ban đầu.

  * Batch-Norm chuẩn hóa dữ liệu đầu ra của các layer giúp model trong quá trình huấn luyện không bị phụ thuộc vào một thành phần trọng số nhất định. Do đó, Batch-norm còn được sử dụng như một regularizer giúp giảm overfitting

# Public_047

# Bài toán object detection

Trong bài 7, sách đã giới thiệu về ứng dụng mô hình CNN cho bài toán phân loại ảnh, tuy nhiên các ảnh input của bài toán phân loại chỉ bao gồm 01 đối tượng cụ thể như chữ số hay 01 loài hoa.
![](images/image1.png)
Hình 13.1: Ví dụ ảnh trong bài toán phân loại ảnh
Tuy nhiên là ảnh trong cuộc sống bình thường thì không chỉ có 01 đối tượng mà thường chứa nhiều các đối tượng khác. Từ đó nảy sinh vấn đề cần tìm vị trí của từng đối tượng trong ảnh. Đó là bài toán object detection.
![](images/image2.png)
Hình 13.2: Ví dụ output của object detection [22]
Bài toán object detection có input là ảnh màu và output là vị trí của các đối tượng trong ảnh. Ta thấy nó bao gồm 2 bài toán nhỏ:

  * Xác định các bounding box (hình chữ nhật) quanh đối tượng.

  * Với mỗi bounding box thì cần phân loại xem đấy là đối tượng gì (chó, ngựa, ô tô,...) với bao nhiêu phần trăm chắc chắn.


Việc lựa chọn có bao nhiêu loại đối tượng thì phụ thuộc vào bài toán mà ta đang giải quyết.
Bạn tự hỏi liệu mô hình CNN có giải quyết được bài toán object detection không? Vấn đề chính là vì không biết trước có bao nhiêu đối tượng trong ảnh, nên không thiết kế được output layer hiệu quả => mô hình CNN truyền thống không giải quyết được => R-CNN (regional convolutional neural network) ra đời.

# Faster R-CNN

## R-CNN (Region with CNN feature)

Ý tưởng thuật toán R-CNN khá đơn giản

  * Bước 1: Dùng Selective Search algorithm để lấy ra khoảng 2000 bounding box trong input mà có khả năng chứa đối tượng.

  * Bước 2: Với mỗi bounding box ta xác định xem nó là đối tượng nào (người, ô tô, xe đạp,...)


### Selective search algorithm

Input của thuật toán là ảnh màu, output là khoảng 2000 region proposal (bounding box) mà có khả năng chứa các đối tượng.
Đầu tiên ảnh được segment qua thuật toán Graph Based Image Segmentation, vì thuật toán dựa vào lý thuyết đồ thị và không áp dụng deep learning nên sách không giải thích chi tiết, bạn có thể đọc theo link ở dưới để tìm hiểu thêm.
![](images/image3.png)
Hình 13.3: Output sau khi thực hiện graph based image segmentation [23]
Nhận xét: Ta không thể dùng mỗi màu trong output để làm 1 region proposal được vì:

  * Mỗi đối tượng trong ảnh có thể chứa nhiều hơn 1 màu.

  * Các đối tượng bị che mất một phần như cái đĩa dưới cái chén không thể xác định được. => Cần nhóm các vùng màu với nhau để làm region proposal.


Tiếp theo, các vùng màu được nhóm với nhau dựa trên độ tương đồng về màu sắc, hướng gradient, kích thước,...
Cuối cùng các region proposal được xác định dựa trên các nhóm vùng màu.

### Phân loại region proposal

Bài toán trở thành phân loại ảnh cho các region proposal. Do thuật toán selective search cho tới 2000 region proposal nên có rất nhiều region proposal không chứa đối tượng nào. Vậy nên ta cần thêm 1 lớp background (không chứa đối tượng nào). Ví dụ như hình dưới ta có 4 region proposal, ta sẽ phân loại mỗi bounding box là người, ngựa hay background.
![](images/image4.png)
Hình 13.4: Các bước trong RCNN [8]
Sau đó các region proposal được resize lại về cùng kích thước và thực hiện transfer learning với feature extractor, sau đó các extracted feature được cho vào thuật toán SVM để phân loại ảnh.
Bên cạnh đó thì extracted feature cũng được dùng để dự đoán 4 offset values cho mỗi cạnh. Ví dụ như khi region proposal chứa người nhưng chỉ có phần thân và nửa mặt, nửa mặt còn lại không có trong region proposal đó thì offset value có thể giúp mở rộng region proposal để lấy được toàn bộ người.

### Vấn đề với R-CNN

Hồi mới xuất hiện thì thuật toán hoạt động khá tốt cho với các thuật toán về computer vision trước đó nhờ vào CNN, tuy nhiên nó vẫn có khá nhiều hạn chế:

  * Vì với mỗi ảnh ta cần phân loại các class cho 2000 region proposal nên thời gian train rất lâu.

  * Không thể áp dụng cho real-time vì mỗi ảnh trong test set mất tới 47s để xử lý.


## Fast R-CNN

Khoảng 1.5 năm sau đó, Fast R-CNN được giới thiệu bởi cùng tác giả của R-CNN, nó giải quyết được một số hạn chế của R-CNN để cải thiện tốc độ.
Tương tự như R-CNN thì Fast R-CNN vẫn dùng selective search để lấy ra các region proposal. Tuy nhiên là nó không tách 2000 region proposal ra khỏi ảnh và thực hiện bài toán image classification cho mỗi ảnh. Fast R-CNN cho cả bức ảnh vào ConvNet (một vài convolutional layer + max pooling layer) để tạo ra convolutional feature map.
Sau đó các vùng region proposal được lấy ra tương ứng từ convolutional feature map. Tiếp đó được Flatten và thêm 2 Fully connected layer (FCs) để dự đoán lớp của region proposal và giá trị offset values của bounding box.
![](images/image5.png)
Hình 13.5: Các bước trong Fast RCNN [7]
Tuy nhiên là kích thước của các region proposal khác nhau nên khi Flatten sẽ ra các vector có kích thước khác nhau nên không thể áp dụng neural network được. Thử nhìn lại xem ở trên R-CNN đã xử lý như thế nào? Nó đã resize các region proposal về cùng kích thước trước khi dùng transfer learning. Tuy nhiên ở feature map ta không thể resize được, nên ta phải có cách gì đấy để chuyển các region proposal trong feature map về cùng kích thước => Region of Interest (ROI) pooling ra đời.

### Region of Interest (ROI) pooling

ROI pooling là một dạng của pooling layer. Điểm khác so với max pooling hay average pooling là bất kể kích thước của tensor input, ROI pooling luôn cho ra output có kích thước cố định được định nghĩa trước.
Ta kí hiệu a/b là phần nguyên của a khi chia cho b và a%b là phần dư của a khi chia cho b. Ví dụ: 10/3 = 3 và 10%3 = 1.
Gọi input của ROI pooling kích thước m*n và output có kích thước h*k (thông thường h, k nhỏ ví dụ 7*7).

  * Ta chia chiều rộng thành h phần, (h-1) phần có kích thước m/h, phần cuối có kích thước m/h + m%h.

  * Tương tự ta chia chiều dài thành k phần, (k-1) phần có kích thước n/k, phần cuối có kích thước n/k + n%k.


Ví dụ m=n=10, h=k=3, do m/h = 3 và m%h = 1, nên ta sẽ chia chiều rộng thành 3 phần, 2 phần có kích thước 3, và 1 phần có kích thước 4.
![](images/image6.png)
Sau đó với mỗi khối được tạo ra bằng các đường đỏ và cạnh, ta thực hiện max pooling lấy ra 1 giá trị.
![](images/image7.png)
Hình 13.6: Thực hiện ROI pooling
Ta có thể thấy là kích thước sau khi thực hiện ROI pooling về đúng h*k như ta mong muốn.

### Đánh giá Fast R-CNN

![](images/image8.png)
Hình 13.7: So sánh thời train train và test giữa R-CNN và Fast R-CNN [17]
Fast R-CNN khác với R-CNN là nó thực hiện feature map với cả ảnh sau đó với lấy các region proposal ra từ feature map, còn R-CNN thực hiện tách các region proposal ra rồi mới thực hiện CNN trên từng region proposal. Do đó Fast R-CNN nhanh hơn đáng kể nhờ tối ưu việc tính toán bằng Vectorization.
Tuy nhiên nhìn hình trên ở phần test time với mục Fast R-CNN thì thời gian tính region proposal rất lâu và làm chậm thuật toán => Cần thay thế thuật toán selective search. Giờ người ta nghĩ đến việc dùng deep learning để tạo ra region proposal => Faster R-CNN ra đời.

## Faster R-CNN

Faster R-CNN không dùng thuật toán selective search để lấy ra các region proposal, mà nó thêm một mạng CNN mới gọi là Region Proposal Network (RPN) để tìm các region proposal.
![](images/image9.png)
Hình 13.8: Kiến trúc mới Faster R-CNN [18]
Đầu tiên cả bức ảnh được cho qua pre-trained model để lấy feature map. Sau đó feature map được dùng cho Region Proposal Network để lấy được các region proposal. Sau khi lấy được vị trí các region proposal thì thực hiện tương tự Fast R-CNN.

### Region Proposal Network (RPN)

Input của RPN là feature map và output là các region proposal. Ta thấy các region proposal là hình chữ nhật.
Mà một hình chữ nhật được xác định bằng 2 điểm ở 2 góc, ví dụ A(x_min, y_min) và B(x_max, y_max). Nhận xét:

  * Khi RPN dự đoán ta phải rằng buộc x_min < x_max và y_min < y_max.

  * Hơn nữa các giá trị x,y khi dự đoán có thể ra ngoài khỏi bức ảnh


=> Cần một kĩ thuật mới để biểu diễn region propsal => Anchor ra đời.
Ý tưởng là thay vì dự đoán 2 góc ta sẽ dự đoán điểm trung tâm (x_center, y_center) và width, height của hình chữ nhật. Như vậy mỗi anchor được xác định bằng 4 tham số (x_center, y_center, width, height).
Vì không sử dụng Selective search nên RPN ban đầu cần xác định các anchor box có thể là region proposal, sau đó qua RPN thì chỉ output những anchor box chắc chắn chứa đối tượng.
![](images/image10.png)
Hình 13.9: Ví dụ về anchor [21]
Ảnh bên trái kích thước 400 * 600 pixel, các tâm của anchor box màu xanh, cách nhau 16 pixel => có khoảng (400*600)/(16*16) = 938 tâm. Do các object trong ảnh có thể có kích thước và tỉ lệ khác nhau nên với mỗi tâm ta định nghĩa 9 anchors với kích thước 64 × 64, 128 × 128, 256×256, mỗi kích thước có 3 tỉ lệ tương ứng: 1 : 1, 1 : 2 và 2 : 1.
Giống như hình bên phải với tâm ở giữa 3 kích thước ứng với màu da cam, xanh lam, xanh lục và với mỗi kích thước có 3 tỉ lệ.
=> Số lượng anchor box giờ là 938 * 9 = 8442 anchors. Tuy nhiên sau RPN ta chỉ giữ lại khoảng 1000 anchors box để thực hiện như trong Fast R-CNN.
**Việc của RPN là lấy ra các region proposal giống như selective search thôi chứ không phải là phân loại ảnh.**
Mô hình RPN khá đơn giản, feature map được cho qua Conv layer 3*3, 512 kernels. Sau đó với mỗi anchor lấy được ở trên, RPN thực hiện 2 bước:

  1. Dự đoán xem anchor đấy là foreground (chứa object) hay background (không chứa object)

  2. Dự đoán 4 offset value cho x_center, y_center, width, height cho các anchor.


Nhận xét: có rất nhiều anchor bị chồng lên nhau nên non-maxima suppression được dùng để loại bỏ các anchor chồng lên nhau.
Sau cùng dựa vào phần trăm dự đoán background RPN sẽ lấy N anchor (N có thể 2000, 1000, thậm chí 100 vẫn chạy tốt) để làm region proposal.

### Intersection over Union (IoU)

IoU được sử dụng trong bài toán object detection, để đánh giá xem bounding box dự đoán đối tượng khớp với ground truth thật của đối tượng.
![](images/image11.png)
Hình 13.10: Ví dụ về IoU [11]
Ví dụ về hệ số IoU, nhận xét:

  * Chỉ số IoU trong khoảng [0,1]

  * IoU càng gần 1 thì bounding box dự đoán càng gần ground truth

# Public_048

# Lời mở đầu

Bài toán nhận diện biển số xe Việt Nam là một bài toán không còn mới, đã được phát triển dựa trên các phương pháp xử lý ảnh truyền thống và cả những kỹ thuật mới sử dụng Deep Learning. Trong bài toán này tôi chỉ phát triển bài toán phát hiện biển số (một phần trong bài toán nhận diện biển số) dựa trên thuật toán YOLO-Tinyv4 với mục đích:

  * Hướng dẫn chuẩn bị dữ liệu cho bài toán Object Detection.

  * Hướng dẫn huấn luyện YOLO-TinyV4 dùng darknet trên Google Colab.


# Chuẩn bị dữ liệu

## Đánh giá bộ dữ liệu

Trong bài viết tôi sử dụng bộ dữ liệu biển số xe máy Việt Nam chứa 1750 ảnh, bạn đọc có thể tải tại [_đây._](https://thigiacmaytinh.com/tai-nguyen-xu-ly-anh/tong-hop-data-xu-ly-anh/?fbclid=IwAR2tajA5Ku83kIrb09ovhmb_68Zmdwo9KvV_CSNBCTbuIIsiK_FUM4W4Dh8)
![](images/image1.png)
Hình 14.1: Ảnh biển số trong bộ dữ liệu
Ảnh biển số xe được trong bộ dữ liệu được chụp từ một camera tại vị trí kiểm soát xe ra vào trong hầm. Do vậy:

  * Kích thước các biển số xe không có sự đa dạng, do khoảng cách từ camera đến biển số xe xấp xỉ gần bằng nhau giữa các ảnh.

  * Ảnh có độ sáng thấp và gần giống nhau do ảnh được chụp trong hầm chung cư.


=> Cần làm đa dạng bộ dữ liệu.

## Các phương pháp tăng sự đa dạng của bộ dữ liệu

### Đa dạng kích thước của biển số

Đa dạng kích thước bằng 2 cách:

  * Cách 1: Thu nhỏ kích thước biển bằng cách thêm biên kích thước ngẫu nhiên vào ảnh gốc, sau đó resize ảnh bằng kích thước ảnh ban đầu.

  * Cách 2: Crop ảnh chứa biển số với kích thước ngẫu nhiên, sau đó resize ảnh bằng kích thước ảnh ban đầu.


_# Cách1_ def add_boder(image_path, output_path, low, high):
_""" low: kích thước biên thấp nhất (pixel) hight: kích thước biên lớn nhất (pixel)_
_"""_
_# random các kích thước biên trong khoảng (low, high)_
top = random.randint(low, high)
bottom = random.randint(low, high)
left = random.randint(low, high)
right = random.randint(low, high)
image = cv2.imread(image_path)
original_width, original_height = image.shape[1], image.shape[0]
_#sử dụng hàm của opencv để thêm biên_
image = cv2.copyMakeBorder(image, top, bottom, left, right, cv2.BORDER_REPLICATE)
_#sau đó resize ảnh bằng kích thước ban đầu của ảnh_
image = cv2.resize(image, (original_width, original_height))
cv2.imwrite(output_path, image)
![](images/image2.png)
Hình 14.2: Ảnh thu được (bên phải) sau khi chạy hàm trên
_# Cách2_ def random_crop(image_path, out_path):
image = cv2.imread(image_path)
original_width, original_height = image.shape[1], image.shape[0]
x_center,y_center = original_height//2, original_width//2
x_left = random.randint(0, x_center//2)
x_right = random.randint(original_width-x_center//2, original_width)
y_top = random.randint(0, y_center//2)
y_bottom = random.randint(original_height-y_center//2, original_width)
_# crop ra vùng ảnh với kích thước ngẫu nhiên_
cropped_image = image[y_top:y_bottom, x_left:x_right]
_# resize ảnh bằng kích thước ảnh ban đầu_
cropped_image = cv2.resize(cropped_image, (original_width, original_height))
cv2.imwrite(out_path, cropped_image)
![](images/image3.png)
Hình 14.3: Ảnh thu được (bên phải) sau khi chạy hàm trên

### Thay đổi độ sáng của ảnh

def change_brightness(image_path, output_path, value):
_""" value: độ sáng thay đổi"""_
img=cv2.imread(image_path)
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
h, s, v = cv2.split(hsv)
v = cv2.add(v, value)
v[v > 255] = 255
v[v < 0] = 0
final_hsv = cv2.merge((h, s, v))
img = cv2.cvtColor(final_hsv, cv2.COLOR_HSV2BGR)
cv2.imwrite(output_path, img)
![](images/image4.png)
Hình 14.4: Độ sáng thay đổi (bên phải)

### Xoay ảnh

import imutils def rotate_image(image_path, range_angle, output_path):
_""" range_angle: Khoảng góc quay"""_
image = cv2.imread(image_path)
_#lựa chọn ngẫu nhiên góc quay_
angle = random.randint(-range_angle, range_angle)
img_rot = imutils.rotate(image, angle)
cv2.imwrite(output_path, img_rot)
![](images/image5.png)
Hình 14.5: Ảnh được xoay (bên phải)

## Gán nhãn dữ liệu

Tool gán nhãn ở đây tôi dùng là **labelImg** , bạn đọc có thể tải và đọc hướng dẫn sử dụng tại [_đây._](https://github.com/tzutalin/labelImg)
![](images/image6.png)
Hình 14.6: Xác định vùng biển chứa biển số
**LabelImg** hỗ trợ gán nhãn trên cả 2 định dạng PASCAL VOC và YOLO với phần mở rộng file annotation tương ứng là .xml và .txt.
Trong bài toán sử dụng mô hình YOLO, tôi lưu file annotation dưới dạng .txt.
![](images/image7.png)
Hình 14.7: Nội dung trong một file annotation
Mỗi dòng trong một file annotation bao gồm: <object-class> <x> <y> <width> <height>.
Trong đó: <x> <y> <width> <height> tương ứng là tọa độ trung tâm và kích thước của đối tượng. Các giá trị này đã được chuẩn hóa lại, do vậy giá trị luôn nằm trong đoạn [0,1]. object-class là chỉ số đánh dấu các classes.
Lưu ý: Với bài toán có nhiều nhãn, nhiều người cùng gán nhãn thì cần thống nhất với nhau trước về thứ tự nhãn. Nguyên nhân do trong file annotation chỉ lưu chỉ số (0,1,3,4,...) của nhãn chứ không lưu tên nhãn.
Sau khi gán nhãn xong các bạn để file annotation và ảnh tương ứng **vào cùng một thư mục**.

# Huấn luyện mô hình

## Giới thiệu về YOLO-Tinyv4 và darknet

### YOLO-Tinyv4

YOLOv4 là thuật toán Object Detection, mới được công bố trong thời gian gần đây với sự cải thiện về kết quả đáng kể so với YOLOv3.
![](images/image8.png)
Hình 14.8: Sự cải thiện của YOLOv4 ([ _source)_](https://arxiv.org/pdf/2004.10934.pdf)
YOLOv4 cho kết quả real-time khi chạy trên các nền tảng GPU cao cấp. Với mục đích trade-off giữa độ chính xác và tốc độ để có thể chạy trên các nền tảng CPU và GPU thấp hơn thì YOLO-Tinyv4 được ra đời.
![](images/image9.png)
Hình 14.9: YOLOv4 với YOLO-Tinyv4 ([ _source)_](https://github.com/AlexeyAB/darknet/issues/6067)
![](images/image10.png)
Hình 14.10: YOLO-Tinyv4 trên các nền tảng ([ _source)_](https://github.com/AlexeyAB/darknet/issues/6067)

### Darknet

**[_Darknet_](https://pjreddie.com/darknet/)** là một framework open source chuyên về Object Detection được viết bằng ngôn ngữ C và CUDA. Darknet dùng để huấn luyện các mô hình YOLO một cách nhanh chóng, dễ sử dụng.

# Public_049

Mục tiêu chính của chương này là giải thích rõ tầm quan trọng của việc phân tích thuật toán cùng với mối liên hệ và sự ảnh hưởng qua lại giữa dữ liệu và thuật toán. Để thực hiện được điều này, chúng ta sẽ bắt đầu từ những khái niệm và định nghĩa cơ bản về dữ liệu, thuật toán sau đó mở rộng sang những vấn đề quan trọng hơn độ phức tạp thuật toán, độ phức tạp chương trình. Cuối cùng, chúng ta sẽ xem xét đến quy trình giải quyết một vấn đề trong khoa học máy tính bằng thuật toán.

# Kiểu và cấu trúc dữ liệu 

Trước khi định nghĩa chính xác các khái niệm về kiểu dữ liệu ( _data types_ ), biến ( _variables_ ) ta xem xét lại với những gì ta đã từng biết trước đây trong toán học. Chẳng hạn khi ta giải phương trình:

𝑥2−2𝑦−2=1

Tiếp cận bằng toán học ta nói nghiệm của phương trình trên là tập các cặp ( _x_ , _y_ ) sao cho 𝑥2−2𝑦−2=1. Ví dụ cặp (1, -1) là một nghiệm của phương trình. Tiếp cận bằng tin học ta sẽ thấy phương trình trên có hai tên là _x_ và _y_. Nếu _x_ và _y_ có giá trị tương ứng là _1_ , _-1_ thì đó là một nghiệm của phương trình. Trong khoa học máy tính cũng gọi _x_ và _y_ là hai biến và các bộ giá trị của _x_ và _y_ được gọi là dữ liệu.

Hai biến _x_ và _y_ có thể nhận giá trị trong các miền khác nhau. Để giải được phương trình ta cần phải xác định được miền giá trị của hai biến _x_ và _y_. Ví dụ, _x_ , _y_ xác định trong miền các số nguyên (10, 20, 30,..), số thực (0.23, 0.55,…) hoặc (0, 1). Để xác định miền giá trị của các biến, trong khoa học máy tính sử dụng một từ khóa đại diện cho một tập các giá trị còn được gọi là một kiểu dữ liệu ( _a data type_ ). Ta sẽ bắt đầu bằng cách tổng quát hóa những khái niệm cơ bản này theo cách tiếp cận của khoa học máy tính.

## Kiểu dữ liệu 

**Kiểu dữ liệu ( _a data type_ )** là một tên hay từ khóa dùng để chỉ tập các đối tượng dữ liệu cùng các phép toán trên nó. Ví dụ trong C++, từ khóa _int_ dùng để chỉ tập các số nguyên có độ lớn biểu diễn bằng 2 byte (tùy thuộc vào các compiler) cùng với các phép toán số học, các phép toán so sánh, các phép toán cấp bít, các phép toán dịch chuyển bit. Từ khóa _float_ dùng để chỉ tập các số thực có độ chính xác đơn có độ lớn được biểu diễn bằng 4 byte (tùy thuộc vào các compiler) cùng với các phép toán số học, các phép toán so sánh. Không có phép lấy phần dư, các phép toán thao tác cấp bít với kiểu dữ liệu _float_. Kiểu dữ liệu được chia thành hai loại kiểu dữ liệu cơ bản hay còn gọi là kiểu dữ liệu nguyên thủy và các kiểu dữ liệu do người dùng định nghĩa.

**Kiểu dữ liệu nguyên thủy** ( _primitive data types_ ) các kiểu dữ liệu được định nghĩa bởi hệ thống ( _system defined data type_ ) được gọi là các kiểu dữ liệu nguyên thủy. Thông thường, các ngôn ngữ lập trình cung cấp ba kiểu dữ liệu nguyên thủy đó là ký tự ( _character_ ), số ( _numeric_ ), và kiểu logic ( _bool_ ). Kiểu dữ liệu ký tự được chia thành hai loại ký tự ASCII ( _char_ ) và ký tự unicode ( _wchar_t_ ). Kiểu dữ liệu số cũng được chia thành hai loại: số kiểu số nguyên ( _integer_ ) và kiểu số thực ( _real_ ). Kiểu số nguyên được chia thành ba loại: số nguyên nhỏ ( _int_ ), số nguyên lớn ( _long_ ), số nguyên rất lớn ( _long long_ ). Kiểu số thực được chia làm hai loại: số thực có độ chính xác đơn ( _float_ ) và số thực có độ chính xác kép ( _double_ ). Dữ liệu kiểu bool chỉ định nghĩa bộ hai giá trị đúng ( _true_ ) và sai ( _false_ ).

Đương nhiên, hai từ khóa khác nhau đại diện cho hai kiểu dữ liệu khác nhau. Quan sát này chỉ mang tính hình thức vì ta có thể quan sát được bằng mắt. Sự khác biệt bên trong giữa các kiểu dữ liệu là không gian bộ nhớ dùng để biểu diễn kiểu và các phép toán dành cho mỗi biến thuộc kiểu. Không gian nhớ dành cho kiểu phụ thuộc vào compiler của ngôn ngữ lập trình và hệ thống máy tính ta đang sử dụng. Chẳng hạn, kiểu dữ liệu _int_ một số compiler dùng 2 byte biểu diễn, một số compiler dùng 4 byte để biểu diễn. Các phép toán lấy phần dư ( _modulo_ ), dịch chuyển bít ( _bit operations_ ) định nghĩa cho các số _int_ , _long_ nhưng không định nghĩa cho các số _float_ và _double_. Để xác định độ lớn của kiểu ta có thể sử dụng hàm _sizeof_ ( _tên kiểu_ ). Ví dụ dưới đây dùng để xác định không gian nhớ dành cho kiểu.


| //Ví dụ 1.1.Xác định kích cỡ bộ nhớ biểu diễn
kiểu#include <iostream> using namespace std; int main(void){cout<<"KÍCH CỠ KIỂU CƠ BẢN"<<endl; cout<<"Kích cỡ
kiểu bool:"<<sizeof(bool)<<endl;cout<<" Kích cỡ kiểu
char:"<<sizeof(char)<<endl;cout<<" Kích cỡ kiểu
wchar_t:"<<sizeof(wchar_t)<<endl; cout<<" Kích cỡ kiểu
int:"<<sizeof(int)<<endl; cout<<" Kích cỡ kiểu
long:"<<sizeof(long)<<endl; cout<<" Kích cỡ kiểu long
long:"<<sizeof(long long)<<endl;cout<<" Kích cỡ kiểu float:"<<sizeof(float)<<endl;
cout<<" Kích cỡ kiểu
double:"<<sizeof(double)<<endl;} |
| --- |

 

**Kiểu dữ liệu do người dùng định nghĩa** ( _user defined data types_ ) là các kiểu dữ liệu được do người dùng xây dựng bằng cách tổ hợp các kiểu dữ liệu nguyên thủy theo một nguyên tắc nào đó. Chẳng hạn, kiểu mảng ( _array_ ) là dãy có thứ tự các phần tử ( _các biến_ ) có cùng chung một kiểu dữ liệu được tổ chức liên tục nhau trong bộ nhớ. Kiếu xâu ký tự (string) là một mảng mỗi phần tử là một ký tự và có ký tự kết thúc là ‘\0’. Như vậy, các kiểu dữ liệu không thuộc các kiểu dữ liệu nguyên thủy như mảng, cấu trúc, file đều được xem là các kiểu dữ liệu do người dùng định nghĩa.

**Cấu trúc dữ liệu ( _data structure_ )** là phương pháp biểu diễn các đối tượng ở thế giới thực thành một đối tượng dữ liệu được tổ chức và lưu trữ trong máy tính để có thể sử lý một cách hiệu quả. Theo nghĩa này, mảng ( _array_ ), danh sách liên kết ( _linked list_ ), ngăn xếp ( _stack_ ), hàng đợi ( _queue_ ), cây ( _tree_ ), đồ thị ( _graph_ )… đều được gọi là các cấu trúc dữ liệu. Dựa vào biểu diễn của các cấu trúc dữ liệu, khoa học máy tính chia các cấu trúc dữ liệu thành hai loại: các cấu trúc dữ liệu tuyến tính ( _linear data structures_ ) và các cấu trúc dữ liệu không tuyến tính ( _non-linear data structures_ ). Một cấu trúc dữ liệu được gọi là tuyến tính nếu việc truy cập các phần tử được thực hiện tuần tự nhưng không nhất thiết được tổ chức liên tục. Điều này có nghĩa, các cấu trúc dữ liệu mảng, danh sách liên kết đơn, danh sách liên kết kép đều là các cấu trúc dữ liệu tuyến tính. Một cấu trúc dữ liệu được gọi là không tuyến tính nếu các phần tử của nó được tổ chức và truy cập không tuần tự. Theo nghĩa này, các cấu trúc dữ liệu cây, graph đều là các cấu trúc dữ liệu không tuyến tính.

**Cấu trúc dữ liệu trừu tượng ( _Abstract Data types: ADTs_ )** là phương pháp kết hợp giữa cấu trúc dữ liệu cùng với các phép toán trên dữ liệu cụ thể của cấu trúc dữ liệu. Như vậy, mỗi kiểu dữ liệu ADTs bao gồm hai thành phần:

  * _Biểu diễn cấu trúc dữ liệu_.

  * _Xây dựng các phép toán trên dữ liệu_ _cụ thể_ _của cấu trúc dữ liệu._


Theo nghĩa này các cấu trúc dữ liệu danh sách liên kết ( _linked list_ ), ngăn xếp ( _stack_ ), hàng đợi ( _queue_ ), hàng đợi ưu tiên ( _priority queue_ ), cây nhị phân ( _binary tree_ ), đồ thị ( _graph_ ) đều là _ADTs_. Mỗi cấu trúc dữ liệu cụ thể cùng các thao tác trên nó sẽ được trình bày trong những chương tiếp theo của tài liệu.

Đối với mỗi cấu trúc dữ liệu trừu tượng, ta cần quan tâm và nắm bắt được những vấn đề sau:

  * **Định nghĩa** : nhằm xác định rõ cấu trúc dữ liệu ADTs ta đang quan tâm đến là gì.

  * **Biểu diễn** : nhằm định hình nên cấu trúc dữ liệu ADTs.

  * **Thao tác (phép toán)** : những thao tác và phép toán nào được cài đặt trên cấu trúc dữ liệu ADTs.

  * **Ứng dụng** : sử dụng cấu trúc dữ liệu ADTs để giải quyết lớp những bài toán nào trong khoa học máy tính.


## Biến 

Khi một cấu trúc dữ liệu được thiết lập thì thể hiện cụ thể của cấu trúc dữ liệu đó là các phần tử dữ liệu và ta thường gọi là biến. Biến trong tin học và biến trong toán học cũng có một số điểm khác biệt. Biến trong toán học hoàn toàn là một tên hình thức. Ngược lại, biến trong tin học có tên mang tính hình thức, nhưng tên này được lưu trữ tại một vị trí bộ nhớ xác định được gọi là địa chỉ của biến. Dựa vào địa chỉ của biến, giá trị của biến sẽ được lưu trữ tại địa chỉ ô nhớ dành cho biến trong khi xử lý dữ liệu.

**Biến ( _variables_ )**: là một tên thuộc kiểu. Trong đó, mỗi tên biến dùng để chỉ bộ ba thành phần: tên ( _name_ ), địa chỉ ( _address_ ), giá trị ( _value_ ). Chẳng hạn khi ta có khai báo _int a =10_ ; khi đó tên biến là _a_ , địa chỉ của biến là _& a_, giá trị của biến là _10_. Trong các ngôn ngữ lập trình, biến cũng được chia thành hai loại: biến toàn cục (global variables) và biến cục bộ (local variables).

Một biến được gọi là biến toàn cục nếu nó được khai báo ngoài tất cả các hàm kể cả hàm main(). Không gian nhớ dành cho biến toàn cục sẽ được cấp phát cho biến ngay từ khi bắt đầu thực hiện chương trình cho đến khi kết thúc thực hiện chương trình. Phạm vi sử dụng biến mang tính toàn cục. Người lập trình được phép truy cập và thay đổi giá trị của biến toàn cục ở bất kể vị trí nào trong chương trình. Một biến được gọi là biến cục bộ nếu nó được khai báo trong thân của hàm kể cả hàm main(). Không gian nhớ dành cho biến toàn cục chỉ được cấp phát sau mỗi lần kích hoạt hàm. Phạm vi sử dụng biến cục bộ chỉ được phép trong nội bộ hàm. Chú ý, khi tên biến toàn cục trùng với tên biến cục bộ thì ưu tiên xử lý dành cho biến cục bộ. Ví dụ dưới đây sẽ minh họa cho biến toàn cục và biến cục bộ.


| //Ví dụ 1.2.Biến toàn cục và biến cục bộ#include <iostream> using namespace std; int a = 10, b = 20;
int Swap (int &a, int & b){int t = a; a=b; b = t;}int main(void){Swap(a, b); //Tại điểm này ta thao tác với hai biến toàn cục a,
bcout<<"a = "<<a <<" b = "<<b<<endl; int
a = 5, b = 7; //Từ vị trí này trở điSwap(a,b);//Ta hoàn toàn thao tác với hai biến a, b cục bộcout<<"a = "<<a <<" b = "<<b<<endl;} |
| --- |

 

# Thuật toán và một số vấn đề liên quan 

Như đã trình bày trong Mục 1.1.1, cấu trúc dữ liệu là phương pháp biểu diễn các đối tượng ở thế giới thực thành một đối tượng trong máy tính. Còn thuật toán được hiểu là phương pháp xử lý các đối tượng dữ liệu đã được biểu diễn để đưa ra kết quả mong muốn. Ta có thể tổng quát hóa khái niệm thuật toán như sau.

**Định nghĩa thuật toán (Algorithm)** : Thuật toán _F_ giải bài toán _P_ là dãy các thao tác sơ cấp _F_ 1, _F_ 2,.., _F_ N trên tập dữ kiện đầu vào ( _Input_ ) để đưa ra được kết quả ra ( _Output_ ).

_F_ 1 _F_ 2.. _F_ N( _Input_ )  _Ouput_.

  * _F_ = _F_ 1 _F_ 2.. _F_ N được gọi là thuật toán giải bài toán _P_. Trong đó, mỗi _F_ i là các phép toán sơ cấp.

  * _Input_ được gọi là tập dữ kiện đầu vào hay tập thông tin đầu vào.

  * _Output_ là kết quả nhận được sau khi thực hiện thuật toán _F_ trên tập _Input_.


**Ví dụ**. Thuật toán tìm USCLN(a, b).

_int USCLN ( int a, int b)_ {// _đầu vào là số nguyên a, b_

_while (b!=0 )_ {// _lặp trong khi b khác 0_

_x = a % b; //lấy x là a mode b_

  1. _= b; //đặt a bằng b_

  2. _=x; //đặt b bằng x_


}

_return(a);//kết quả thực thi thuật toán_

}
**Những đặc trưng cơ bản của thuật toán** :

  * **Tính đơn định**. Ở mỗi bước của thuật toán, các thao tác sơ cấp phải hết sức rõ ràng, không tạo ra sự lộn xộn, nhập nhằng, đa nghĩa. Thực hiện đúng các bước của thuật toán trên tập dữ liệu đầu vào chỉ cho duy nhất một kết quả.

  * **Tính dừng**. Thuật toán không được rơi vào quá trình vô hạn. Thuật toán phải dừng lại và cho kết quả sau một số hữu hạn các bước.

  * **Tính đúng**. Sau khi thực hiện tất cả các bước của thuật toán theo đúng quy trình đã định, ta phải nhận được kết quả mong muốn với mọi bộ dữ liệu đầu vào. Kết quả đó được kiểm chứng bằng yêu cầu của bài toán.

  * **Tính phổ dụng**. Thuật toán phải dễ sửa đổi để thích ứng được với bất kỳ bài toán nào trong lớp các bài toán cùng loại và có thể làm việc trên nhiều loại dữ liệu khác nhau.

  * **Tính khả thi**. Thuật toán phải dễ hiểu, dễ cài đặt, thực hiện được trên máy tính với thời gian cho phép.


Đối với thuật toán ta cần quan tâm đến những vấn đề sau:

  * **Biểu diễn thuật toán:** xác định ngôn ngữ để biểu diễn thuật toán.

  * **Đánh giá độ phức tạp thuật toán** : ước lượng thời gian và không gian nhớ khi thực hiện thuật toán.

  * **Kiểm nghiệm thuật toán** : kiểm nghiệm thuật toán với các bộ dữ liệu thực khác nhau.

  * **Cài đặt thuật toán** : cài đặt thuật toán bằng ngôn ngữ lập trình cụ thể.


# Biểu diễn thuật toán 

Có ba ngôn ngữ chính để biểu diễn thuật toán: ngôn ngữ tự nhiên, ngôn ngữ máy tính và ngôn ngữ hình thức.

  * **Ngôn ngữ tự nhiên** là phương tiện giao tiếp giữa con người với con người. Ta có thể sử dụng chính ngôn ngữ này vào việc biểu diễn thuật toán.

  * **Ngôn ngữ máy tính** là phương tiện giao tiếp giữa máy tính và máy tính. Trong trường hợp này ta có thể sử dụng bất kỳ ngôn ngữ lập trình nào để biểu diễn thuật toán (C, Pascal, Java…).

  * **Ngôn ngữ hình thức**. Ngôn ngữ hình thức là phương tiện giao tiếp trung gian giữa con người và hệ thống máy tính. Ví dụ ngôn ngữ sơ đồ khối, ngôn ngữ tựa tự nhiên, ngôn ngữ đặc tả. Đặc điểm chung của các loại ngôn ngữ hình thức là việc sử dụng nó rất gần gũi với ngôn ngữ tự nhiên, rất gần gũi với ngôn ngữ máy tính. Tuy nhiên, ngôn ngữ hình thức lại không phụ thuộc vào ngôn ngữ tự nhiên, không phụ thuộc vào ngôn ngữ máy tính. Chính vì lý do này, ngôn ngữ hình thức được sử dụng phổ biến trong biểu diễn thuật toán.


Ví dụ dưới đây sẽ minh họa cho các ngôn ngữ biểu diễn thuật toán.


| //Ví dụ 1.3. Biểu diễn thuật toán bằng ngôn ngữ tự nhiênĐầu
vào (Input). Hai số tự nhiên a, b.Đầu ra (Output). Số nguyên u lớn nhất để a và b đều chia hết
cho u.Thuật toán (Euclide Algorithm):Bước 1. Đưa vào hai số tự nhiên a và b.Bước 2. Nếu b 0 thì chuyển đến bước 3, nếu b=0 thì thực
hiện bước 4.Bước 3. Đặt r = a mod b; a = b; b = r ; Quay quay trở lại
bước 2.Bước 4 (Output). Kết luận u=a là số nguyên cần tìm. |
| --- |

 
| //Ví dụ 1.4.Biểu diễn thuật toán bằng ngôn ngữ
máy tính (C++)int USCLN( int a, int b){while ( b != 0
){//lặp trong khi b khác 0r = a % b; //đặt r bằng phần dư của a/b= b; // đặt a bằng b= r; //đặt b bằng r}return(a);//trả lại giá trị a} |
| --- |
| //Ví dụ 1.5.Biểu diễn thuật toán bằng ngôn ngữ
hình thứcThuật toán Euclide:Đầu vào (Input): aN, aN.Đầu ra (Output): s = max { uN : a mod u =0 and b mod u
=0}.Format : s = Euclide (a, b). Actions:while (b0 ) do //lặp trong khi b khác 0r = a mod b; //đặt r bằng a mod b= b; //đổi giá trị của a thành b= r;// đổi giá trị của b thành rendwhile;//kết thúc cấu trúc lặp while return(a);//giá trị trả về
của hàmEndactions. |

 

Một số lưu ý trong khi biểu diễn thuật toán bằng ngôn ngữ hình thức:

  * Khi biểu diễn bằng ngôn ngữ hình thức ta được phép sử dụng cả ngôn ngữ tự nhiên hoặc ngôn ngữ máy tính thông dụng. Mỗi bước thực hiện của thuật toán không cần mô tả quá chi tiết mà chỉ cần mô tả một cách hình thức miễn là đầy đủ thông tin để chuyển đổi thành ngôn ngữ lập trình.

  * Đối với những thuật toán phức tạp nặng nề về tính toán, các công thức cần được mô tả một cách tường minh, có ghi chú rõ ràng.

  * Đối với các thuật toán kinh điển thì ta cần phải thuộc. Không bắt buộc phải chứng minh lại độ phức tạp của các thuật toán kinh điển.


#

# Public_050

# Khái niệm độ phức tạp thuật toán 

Thời gian thực hiện một giải thuật bằng chương trình máy tính phụ thuộc vào các yếu tố:

  * Kích thước dữ liệu đầu vào: một giải thuật hay một chương trình máy tính thực hiện trên tập dữ liệu có kích thước lớn hiển nhiên mất nhiều thời gian hơn thuật toán hoặc chương trình này thực hiện trên tập dữ liệu đầu vào có kích thước nhỏ.

  * Phần cứng của hệ thống máy tính: hệ thống máy tính có tốc độ cao thực hiện nhanh hơn trên hệ thống máy tính có tốc độ thấp.


Tuy nhiên, nếu ta quan niệm thời gian thực hiện của một thuật toán là số các phép toán sơ cấp thực hiện trong thuật toán đó thì phần cứng máy tính không còn là yếu tố ảnh hưởng đến quá trình xác định thời gian thực hiện của một thuật toán. Với quan niệm này, độ phức tạp thời gian thực hiện của một thuật toán chỉ còn phụ thuộc duy nhất vào độ dài dữ liệu đầu vào.

Gọi độ dài dữ liệu đầu vào là _T_ ( _n_ ). Khi đó, số lượng các phép toán sơ cấp để giải bài toán _P_ thực hiện theo thuật toán _F_ = _F_ 1 _F_ 2.. _F_ n trên độ dài dữ liệu _T_ ( _n_ ) là _F_ ( _T_ ( _n_ )). Để xác định số lượng các phép toán sơ cấp _F_ i ( _i_ = _1_ , _2_ , .., _n_ ) thực hiện trong thuật toán _F_ ta cần phải giải bài toán đếm để xác định _F_ ( _T_ ( _n_ )). Đây là bài toán vô cùng khó và không phải lúc nào cũng giải được []. Để đơn giản điều này, người ta thường tìm đến các phương pháp xấp xỉ để tính toán độ phức tạp thời gian của một thuật toán. Điều này có nghĩa, khi ta không thể xây dựng được công thức đếm _F_ ( _T_ ( _n_ )), nhưng ta lại có khẳng định chắc chắn _F_ ( _T_ ( _n_ )) không vượt quá một phiếm hàm biết trước _G_ ( _n_ ) thì ta nói _F_ ( _T_ ( _n_ )) thực hiện nhanh nhất là _G_ ( _n_ ).

**Tổng quát** , _cho hai hàm f_ ( _x_ ) _, g_ ( _x_ ) _xác định trên tập các số nguyên dương hoặc tập các số thực. Hàm f_ ( _x_ ) _được gọi là O_ ( _g_ ( _x_ )) _nếu tồn tại một hằng số C >0 và n0 sao cho:_

| _f_ ( _x_ )| ≤ _C_.| _g_ ( _x_ )| với mọi _x_ ≥ _n_ 0.

Điều này có nghĩa với các giá trị _x_ ≥ _n_ 0 hàm _f_ ( _x_ ) bị chặn trên bởi hằng số _C_ nhân với _g_ ( _x_ ). Nếu _f_ ( _x_ ) là thời gian thực hiện của một thuật toán thì ta nói giải thuật đó có cấp _g_ ( _x_ ) hay độ phức tạp thuật toán _f_ ( _x_ ) là _O_ ( _g_ ( _x_ )).

**Ghi chú**. Các hằng số _C_ , _n_ 0 thỏa mãn điều kiện trên là không duy nhất. Nếu có đồng thời _f_ ( _x_ ) là _O_ ( _g_ ( _x_ )) và _h_ ( _x_ ) thỏa mãn _g_ ( _x_ ) < _h_ ( _x_ ) với _x_ > _n_ 0 thì ta cũng có _f_ ( _x_ ) là _O_ ( _h_ ( _n_ )).

**Ví dụ 1.6**. Cho 𝑓(𝑥) = 𝑎𝑛𝑥𝑛 \+ 𝑎𝑛−1𝑥𝑛−1 \+ ⋯ + 𝑎1𝑥 + 𝑎0; trong đó, _a_ i là các số thực (i =0,1, 2, ..,n). Khi đó _f_ ( _x_ ) = _O_ ( _x_ n).

**Chứng minh**. Thực vậy, với mọi _x_ > _1_ ta có:

|𝑓(𝑥) = |𝑎𝑛𝑥𝑛 \+ 𝑎𝑛−1𝑥𝑛−1 \+ ⋯ + 𝑎1𝑥 + 𝑎0|

≤ |𝑎𝑛|𝑥𝑛 \+ |𝑎𝑛−1|𝑥𝑛−1 \+ ⋯ \+ |𝑎1|𝑥 + |𝑎0|

≤ |𝑎𝑛|𝑥𝑛 \+ |𝑎𝑛−1|𝑥𝑛 \+ ⋯ + |𝑎1|𝑥𝑛 \+ |𝑎0|𝑥𝑛

≤ 𝑥𝑛(|𝑎𝑛| + |𝑎𝑛−1| + ⋯ + |𝑎1| \+ |𝑎0|)

≤ 𝐶. 𝑥𝑛 = 𝑂(𝑥𝑛) . Trong đó, 𝐶 = (|𝑎𝑛| + |𝑎𝑛−1| + ⋯ + |𝑎1| \+ |𝑎0|).

# Một số quy tắc xác định độ phức tạp thuật toán 

Như đã đề cập ở trên, bản chất của việc xác định độ phức tạp thuật toán là giải bài toán đếm số lượng các phép toán sơ cấp thực hiện trong thuật toán đó. Do vậy, tất cả các phương pháp giải bài toán đếm thông thường đều được áp dụng trong khi xác định độ phức tạp thuật toán. Hai nguyên lý cơ bản để giải bài toán đếm là nguyên lý cộng và nguyên lý nhân cũng được mở rộng trong khi ước lượng độ phức tạp thuật toán.

**Nguyên tắc tổng:** Nếu _f_ 1( _x_ ) có độ phức tạp là O( _g_ 1( _x_ )) và _f_ 2( _x_ ) có độ phức tạp là O( _g_ 2( _x_ )) thì độ phức tạp của ( _f_ 1( _x_ ) + f2( _x_ ) là O( _Max_ ( _g_ 1( _x_ ), _g_ 2( _x_ )).

**Chứng minh**. Vì _f_ 1( _x_ ) có độ phức tạp là O( _g_ 1( _x_ ) nên tồn tại hằng số _C_ 1 và _k_ 1 sao cho | _f_ 1( _x_ )|| _g_ 1( _x_ )| với mọi _x_  _k_ 1. Vì _f_ 2( _x_ ) có độ phức tạp là O( _g_ 2( _x_ )) nên tồn tại hằng số _C_ 2 và _k_ 2 sao cho | _f_ 2( _x_ )|| _g_ 2( _x_ )| với mọi _x_  _k_ 2.

Ta lại có :
| _f_ 1( _x_ )+ _f_ 2( _x_ )|  | _f_ 1( _x_ )| + | _f_ 2( _x_ )|

 _C_ 1| _g_ 1( _x_ )| + _C_ 2| _g_ 2( _x_ )|

 _C_ | _g_ ( _x_ )| với mọi _x_ > _k_ ;

Trong đó, _C_ = _C_ 1 \+ _C_ 2; _g_ ( _x_ ) = _max_ ( _g_ 1( _x_ ), _g_ 2( _x_ )); _k_ = _max_ ( _k_ 1, _k_ 2).

**Tổng quát**. Nếu độ phức tạp của _f_ 1( _x_ ), _f_ 2( _x_ ),.., _f_ m( _x_ ) lần lượt là O( _g_ 1( _x_ )), O( _g_ 2( _x_ )),.., O( _g_ n( _x_ )) thì độ phức tạp của _f_ 1( _x_ ) + _f_ 2( _x_ ) \+ ..+ _f_ m( _x_ ) là O( _max_ ( _g_ 1( _x_ ), _g_ 2( _x_ ),.., _g_ m( _x_ )).

**Nguyên tắc nhân:** Nếu _f_ ( _x_ ) có độ phức tạp là O( _g_ ( _x_ ) thì độ phức tạp của _f_ n( _x_ ) là O( _g_ n( _x_ )). Trong đó:

_f_ n( _x_ ) = _f_ ( _x_ ). _f_ ( _x_ )…. _f_ ( _x_ ). //n lần _f_ ( _x_ ). _g_ n( _x_ ) = _g_ ( _x_ ). _g_ ( _x_ )… _g_ ( _x_ ).// _n_ lần _g_ ( _x_ )

**Chứng minh**. Thật vậy theo giả thiết _f_ ( _x_ ) là O( _g_ ( _x_ )) nên tồn tại hằng số _C_ và _k_ sao cho với mọi _x_ > _k_ thì | _f_ ( _x_ )| C.| _g_ ( _x_ ). Ta có:

|𝑓𝑛(𝑥)| = |𝑓1(𝑥). 𝑓2(𝑥) … 𝑓𝑛(𝑥)|

≤ |𝐶. 𝑔1(𝑥). 𝐶. 𝑔2(𝑥) … 𝐶. 𝑔𝑛(𝑥)|

≤ |𝐶𝑛. 𝑔𝑛(𝑥)| = 𝑂(𝑔𝑛(𝑥))

# Một số dạng hàm được dùng xác định độ phức tạp thuật toán 

Như đã đề cập ở trên, để xác định chính xác độ phức tạp thuật toán f(x) là bài toán

khó nên ta thường xấp xỉ độ phức tạp thuật toán với một phiếm hàm O(g(x)). Dưới đây là

một số phiếm hàm của O(g(x)).

**Bảng 1.1. Các dạng hàm xác định độ phức tạp thuật toán**

![](images/image1.jpg)

**Hình 1.1**. _Độ tăng của các hàm theo độ dài dữ liệu_

Dưới đây là một số qui tắc xác định O(g(x)):

  * Nếu một thuật toán có độ phức tạp hằng số thì thời gian thực hiện thuật toán đó không phụ thuộc vào độ dài dữ liệu.

  * Một thuật toán có độ phức tạp logarit của f(n) thì ta viết O(log(n)) mà không cần chỉ rõ cơ số của phép logarit.

  * Với P(n) là một đa thức bậc k thì O(P(n)) = O(nk).

  * Thuật toán có độ phức tạp đa thức hoặc nhỏ hơn được xem là những thuật toán thực tế có thể thực hiện được bằng máy tính. Các thuật toán có độ phức tạp hàm mũ, hàm giai thừa được xem là những thuật toán thực tế không giải được bằng máy tính.


# Độ phức tạp của các cấu trúc lệnh 

Để đánh giá độ phức tạp của một thuật toán đã được mã hóa thành chương trình máy tính ta thực hiện theo một số qui tắc sau.

**Độ phức tạp hằng số O(1):** đoạn chương trình không chứa vòng lặp hoặc lời gọi đệ qui có tham biến là một hằng số.

**Ví dụ 1.7**. Đoạn chương trình dưới đây có độ phức tạp hằng số. _for_ ( _i=1; i <=c; i++_) {

_< Tập các chỉ thị có độ phức tạp O(1)>;_

}

**Độ phức tạp O(n)** : Độ phức tạp của hàm hoặc đoạn code là O(n) nếu biến trong vòng lặp tăng hoặc giảm bởi mộ hằng số c.

**Ví dụ 1.8**. Đoạn code dưới đây có độ phức tạp hằng số. for (i=1; i<=n; i = i + c ) {

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

for (i=n; i>0; i = i - c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

**Độ phức tạp đa thức O(n** c **):** Độ phức tạp của _c_ vòng lặp lồng nhau, mỗi vòng lặp đều có độ phức tạp O(n) là **O(n** c **).**

**Ví dụ 1.9**. Đoạn code dưới đây có độ phức tạp O(n2).

for (i=1; i<=n; i = i + c ) { for (j=1; j<=n; j = j + c){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

}

for (i = n; i >0 ; i = i - c ) { for (j = i- 1; j>1; j = j -c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

} }

**Độ phức tạp logarit O(Log(n))** : Độ phức tạp của vòng lặp là log(n) nếu biểu thức khởi đầu lại của vòng lặp được chia hoặc nhân với một hằng số c.

**Ví dụ 1.10**. Đoạn code dưới đây có độ phức tạp Log(n). for (i=1; i <=n; i = i *c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

for (j=n; j >0 ; j = j / c ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

**Độ phức tạp hằng số O(Log (Log(n))):** nếu biểu thức khởi đầu lại của vòng lặp được nhân hoặc chia cho một hàm mũ.

**Ví dụ 1.11**. Đoạn code dưới đây có độ phức tạp Log Log(n). for (i=1; j<=n; j*= Pow(i, c) ){

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

for (j=n; j>=0; j = j- Function(j) ){ //Function(j) =sqrt(j) hoặc lớn hơn 2.

< _Tập các chỉ thị có độ phức tạp O(1)_ >;

}

**Độ phức tạp của chương trình** : độ phức tạp của một chương trình bằng số lần thực hiện một chỉ thị tích cực trong chương trình đó. Trong đó, một chỉ thị được gọi là tích cực trong chương trình nếu chỉ thị đó phụ thuộc vào độ dài dữ liệu và thực hiện không ít hơn bất kỳ một chỉ thị nào khác trong chương trình.

**Ví dụ 1.12**. Tìm độ phức tạp thuật toán sắp xếp kiểu Bubble-Sort? Void Bubble-Sort ( int A[], int n ) {

for ( i=1; i<n; i++) { for ( j = i+1; j<=n; j++){ if (A[i] > A[j]) {// _đây chính là chỉ thị tích cực_ t = A[i]; A[i] = A[j]; A[j] = t;

}

}

}

}

**Lời giả** i. Sử dụng trực tiếp nguyên lý cộng ta có:

  * Với i =1 ta cần sử dụng n-1 phép so sánh A[i] với A[j];

  * Với i = 2 ta cần sử dụng n-2 phép so sánh A[i] với A[j];

  * . . . . .

  * Với i = n-1 ta cần sử dụng 1 phép so sánh A[i] với A[j]; Vì vậy tổng số các phép toán cần thực hiện là:


S = (n-1) + (n-2) + . . . + 2 + 1 = n(n-1)/2 n2 = O(n2).

**Ghi chú**. Độ phức tạp thuật toán cũng là số lần thực hiện phép toán tích cực. Phép toán tích cực là phép toán thực hiện nhiều nhất đối với thuật toán.

# Quy trình giải quyết bài toán trên máy tính 

Để giải quyết một bài toán hoặc vấn đề trong tin học ta thực hiện thông qua 6 bước như sau:

**Bước 1. Xác định yêu cầu bài toán.** Xem xét bài toán cần xử lý vấn đề gì? Giả thiết nào đã được biết trước và lời giải cần đạt những yêu cầu gì? Ví dụ thời gian, hay không gian nhớ.

**Bước 2. Tìm cấu trúc dữ liệu thích hợp biểu diễn các đối tượng cần xử lý của bài toán.** Cấu trúc dữ liệu phải biểu diễn đầy đủ các đối tượng thông tin vào của bài toán. Các thao tác trên cấu trúc dữ liệu phải phù hợp với những thao tác của thuật toán được lựa chọn. Cấu trúc dữ liệu phải cài đặt được bằng ngôn ngữ lập trình cụ thể đáp ứng yêu cầu bài toán.

**Bước 3. Lựa chọn thuật toán.** Thuật toán phải đáp ứng được yêu của bài toán và phù hợp với cấu trúc dữ liệu đã được lựa chọn Bước 1.

**Bước 4. Cài đặt thuật toán.** Thuật toán cần được cài đặt bằng một ngôn ngữ lập trình cụ thể. Ngôn ngữ lập trình sử dụng phải có các cấu trúc dữ liệu đã lựa chọn.

**Bước 5. Kiểm thử chương trình.** Thử nghiệm thuật toán (chương trình) trên các bộ dữ liệu thực. Các bộ dữ liệu cần phải bao phủ lên tất cả các trường hợp của thuật toán.

**Bước 6. Tối ưu chương trìn** h: Cải tiến để chương trình tốt hơn.

.

# Public_051

Nội dung chính của chương trình bày một số lược đồ thuật toán kinh điển dùng để giải lớp các bài toán liệt kê, bài toán đếm, và bài toán tối ưu và bài toán tồn tại. Mỗi lược đồ thuật toán giải quyết một lớp các bài toán thỏa mãn một số tính chất nào đó. Đây là những lược đồ thuật toán quan trọng nhằm giúp người học vận dụng nó trong khi giải quyết các vấn đề trong tin học. Các lược đồ thuật toán được trình bày trong chương này bao gồm: thuật toán sinh, thuật toán đệ qui, thuật toán quay lui, thuật toán tham lam, thuật toán nhánh cận, thuật toán qui hoạch động.

# Mô hình thuật toán sinh (Generative Algorithm) 

Mô hình thuật toán sinh được dùng để giải lớp các bài toán liệt kê, bài toán đếm, bài toán tối ưu, bài toán tồn tại thỏa mãn hai điều kiện:

  * **Điều kiện 1:** _Có thể xác định được một thứ tự trên tập các cấu hình cần liệt kê của bài toán. Biết cấu hình đầu tiên, biết cấu hình cuối cùng._

  * **Điều kiện 2:** _Từ một cấu hình chưa phải cuối cùng, ta xây dựng được thuật toán sinh ra cấu hình đứng ngay sau nó._


Mô hình thuật toán sinh được biểu diễn thành hai bước: bước khởi tạo và bước lặp. Tại bước khởi tạo, cấu hình đầu tiên của bài toán sẽ được thiết lập. Điều này bao giờ cũng thực hiện được theo giả thiết của bài toán. Tại bước lặp, quá trình lặp được thực hiện khi gặp phải cấu hình cuối cùng. Điều kiện lặp của bài toán bao giờ cũng tồn tại theo giả thiết của bài toán. Hai chỉ thị cần thực hiện trong thân vòng lặp là đưa ra cấu hình hiện tại và sinh ra cấu hình kế tiếp. Mô hình sinh kế tiếp được thực hiện tùy thuộc vào mỗi bài toán cụ thể. Tổng quát, mô hình thuật toán sinh được thể hiện như dưới đây.

**Thuật toán Generation;**
**begin**
**Bước1 (Khởi tạo):**

_< Thiết lập cấu hình đầu tiên>;_

**Bước 2 (Bước lặp):**

**while** ( _< Lặp khi cấu hình chưa phải cuối cùng>_) **do**

_< Đưa ra cấu hình hiện tại>;_

_< Sinh ra cấu hình kế tiếp>;_ **endwhile** ;

**End**.

**Ví dụ 2.1**. Vector _X_ = ( _x_ 1, _x_ 2, .., _x_ n), trong đó _x_ i = 0, 1 được gọi là một xâu nhị phân có độ dài _n_. Hãy liệt kê các xâu nhị phân có độ dài _n_. Ví dụ với n=4, ta sẽ liệt kê được 24 xâu nhị phân độ dài 4 như trong Bảng 2.1.

**Bảng 2.1**. Các xâu nhị phân độ dài 4


| STT | X=(x1,x2,x3,x4) | STT | X=(x1,x2,x3,x4) |
| --- | --- | --- | --- |
| 0 | 0 0 0 0 | 8 | 1 0 0 0 |
| 1 | 0 0 0 1 | 9 | 1 0 0 1 |
| 2 | 0 0 1 0 | 10 | 1 0 1 0 |
| 3 | 0 0 1 1 | 11 | 1 0 1 1 |
| 4 | 0 1 0 0 | 12 | 1 1 0 0 |
| 5 | 0 1 0 1 | 13 | 1 1 0 1 |
| 6 | 0 1 1 0 | 14 | 1 1 1 0 |
| 7 | 0 1 1 1 | 15 | 1 1 1 1 |

 

**Lời giải:**

**Điều kiện 1** : Gọi thứ tự của xâu nhị phân _X_ =( _x_ 1, _x_ 2,.., _x_ n) là _f_ ( _X_ ). Trong đó, _f_ (X)= _k_ là số chuyển đồi xâu nhị _X_ thành số ở hệ cơ số 10. Ví dụ, xâu _X_ = (1, 0, 1, 1) được chuyển thành số hệ cơ số 10 là 11 thì ta nói xâu _X_ có thứ tự 11. Với cách quan niệm này, xâu đứng sau xâu có thứ tự 11 là 12 chính là xâu đứng ngay sau xâu _X_ = (1, 0, 1, 1). Xâu đầu tiên có thứ tự là _0_ ứng với xâu có _n_ số _0_. Xâu cuối cùng có thứ tự là _2_ n- _1_ ứng với xâu có _n_ số _1_. Như vậy, điều kiện 1 của thuật toán sinh đã được thỏa mãn.

**Điều kiện 2** : Về nguyên tắc ta có thể lấy _k_ = _f_ ( _X_ ) là thứ tự của một xâu bất kỳ theo nguyên tắc ở trên, sau đó lấy thứ tự của xâu kế tiếp là ( _k_ \+ _1_ ) và chuyển đổi ( _k_ + _1_ ) thành số ở hệ cơ số 10 ta sẽ được xâu nhị phân tiếp theo. Xâu cuối cùng sẽ là xâu có n số 1 ứng với thứ tự _k_ = _2_ n- _1._ Với cách làm này, ta có thể coi mỗi xâu nhị phân là một số, mỗi thành phần của xâu là một bít và chỉ cần cài đặt thuật toán chuyển đổi cơ số ở hệ 10 thành số ở hệ nhị phân. Ta có thể xây dựng thuật toán tổng quát hơn bằng cách xem mỗi xâu nhị phân là một mảng các phần tử có giá trị 0 hoặc 1. Sau đó, duyệt từ vị trí bên phải nhất của xâu nếu gặp số 1 ta chuyển thành 0 và gặp số 0 đầu tiên ta chuyển thành 1. Ví dụ với xâu X = (0, 1, 1, 1) được chuyển thành xâu X= (1, 0, 0, 0), xâu X = (1,0,0,0) được chuyển thành xâu X =(1, 0, 0, 1). Lời giải và thuật toán sinh xâu nhị phân kế tiếp được thể hiện trong chương trình dưới đây. Trong đó, thuật toán sinh xâu nhị phân kế tiếp từ một xâu nhị phân bất kỳ là hàm _Next_Bits_String_ ().

#include <iostream>
#include <iomanip> #define MAX 100 using namespace std; int X[MAX], n, dem = 0; // _sử dụng các biến toàn cục X[], n, OK, dem_ bool OK =true; void Init(void){ // _khởi tạo xâu nhị phân đầu tiên_

cout<<"Nhập n="; cin>>n;

for(int i = 1; i<=n; i++) // _thiết lập xâu với n số 0_

X[i]=0;

} void Result(void){ // _đưa ra xâu nhị phân hiện tại_ cout<<"\n Xâu thứ "<<++dem<<":";

for(int i=1; i<=n; i++)

cout<<X[i]<<setw(3);

} void Next_Bits_String(void){ // _thuật toán sinh xâu nhị phân kế tiếp_ int i=n;

while(i>0 && X[i]){ // _duyệt từ vị trí bên phải nhất_

X[i]=0; // _nếu gặp X[i] = 1 ta chuyển thành 0_

i--; // _lùi lại vị trí sau_

}

if (i>0) X[i]=1; // _gặp X[i] =0 đầu tiên ta chuyển thành 1_ else OK = false; // _kết thúc khi gặp xâu có n số 1_
}
int main(void){ // _đây là thuật toán sinh_ Init(); // _thiết lập cấu hình đầu tiên_ while(OK){// _lặp khi chưa phải cấu hình cuối cùng_ Result(); // _đưa ra cấu hình hiện tại_

Next_Bits_String(); // _sinh ra cấu hình kế tiếp_

}

}

**Ví dụ 2.2**. Liệt kê các tập con k phần tử của 1, 2, .., n.

**Lời giải.** Mỗi tập con k phần tử của 1, 2, .., N là một tổ hợp chập K của 1, 2,.., N. Ví dụ với n=5, k= 3 ta sẽ có C(n,k) tập con trong Bảng 2.2.

**Điều kiện 1**. Ta gọi tập con X =( _x_ 1,.. _x_ K) là đứng trước tập con Y =( _y_ 1, _y_ 2,.. _y_ K) nếu tìm được chỉ số t sao cho _x_ 1 = _y_ 1, _x_ 2 = _y_ 2,.., _x_ t-1 = _y_ t-1, _x_ t < _y_ t. Ví dụ tập con _X_ = ( _1, 2, 3_ ) đứng trước tập con _Y_ =( _1, 2, 4_ ) vì ta tìm được t=3 thỏa mãn _x_ 1 = _y_ 1, _x_ 2 = _y_ 2, _x_ 3<y3. Tập con đầu tiên là _X_ = (1 _, 2,.., k_ ), tập con cuối cùng là ( _n–k+1,.., N_ ). Như vậy điều kiện 1 của thuật toán sinh được thỏa mãn.

**Điều kiện 2**. Để ý rằng, tập con cuối cùng (n-k+1,..., n) luôn thỏa mãn đẳng thức X[i] = n – k + i. Ví dụ tập con cuối cùng X[] = (3, 4, 5) ta đều có: X[1] = 3 = 5 – 3 + 1; X[2] = 4 = 5 – 3 + 2; X[3] = 5 = 5 – 3 + 3. Để tìm tập con kế tiếp từ tập con bất kỳ ta chỉ cần duyệt từ phải qua trái tập con X[] = (x1, x2, .., xk) để xác định chỉ số i thỏa mãn điều kiện X[i] n – k + i. Ví dụ với X[] = (1, 4, 5), ta xác định được i=1 vì X[3] = 5 = 5-3+3, X[2] = 4 = 5-3+2, và X[1] = 1 5-3+1. Sau khi xác định được chỉ số i, tập con mới sẽ được sinh là Y[] = (y1,.., yi, ..., yk) ra thỏa mãn điều kiện: y1 = x1, y2 = x2,.., yi-1 = xi-1, yi = xi+1, và yj = xt + j – i với (j = j+1, ..., k).

**Bảng 2.2**. Tập con 3 phần tử của 1, 2, 3, 4, 5


| STT | Tập con |
| --- | --- |
| 1 | 1 2 3 |
| 2 | 1 2 4 |
| 3 | 1 2 5 |
| 4 | 1 3 4 |
| 5 | 1 3 5 |
| 6 | 1 4 5 |
| 7 | 2 3 4 |
| 8 | 2 3 5 |
| 9 | 2 4 5 |
| 10 | 3 4 5 |

 

Chương trình cài đặt thuật toán sinh tập con k phần tử được thể hiện như dưới đây.

Trong đó, thuật toán sinh tổ hợp kế tiếp có tên là Next_Combination().

#include <iostream>
#include <iomanip>  
#define MAX 100  
int X[MAX], n, k, dem=0;  
bool OK = true;  
using namespace std;
void Init(void){ //thiết lập tập con đầu tiên
cout<<"\n Nhập n, k:"; cin>>n>>k;
for(int i=1; i<=k; i++) //tập con đầu tiên là 1, 2, .., k
X[i] = i;

}

void Result(void){ // _đưa ra tập con hiện tại_ cout<<"\n Kết quả "<<++dem<<":";

for(int i=1; i<=k; i++) // _đưa ra_ _X_ [] _=_ ( _x_ 1 _, x_ 2 _, .., x_ k)

cout<<X[i]<<setw(3);

}
void Next_Combination(void){ // _sinh tập con k phần tử từ tập con bất kỳ_

int i = k; // _duyệt từ vị trí bên phải nhất của tập con_ while(i>0 && X[i]== n-k+i) // _tìm i sao cho x i n-k+i_

i--;

if (i>0){// _nếu chưa phải là tập con cuối cùng_

X[i]= X[i]+1; // _thay đổi giá trị tại vị trí i: x i = xi +_1 _;_ for(int j=i+1; j<=k; j++) // _các vị trí j từ i+1,.., k_ X[j] = X[i] + j - i; // được thay đổi là _x j = xi +j - i;_

}

else // _nếu là tập con cuối cùng_

OK = false; / _/ta kết thúc duyệt_
}

int main(void){

Init(); // _khởi tạo cấu hình đầu tiên_

while(OK){ // _lặp trong khi cấu hình chưa phải cuối cùng_ Result(); // _đưa ra cấu hình hiện tại_

Next_Combination(); // _sinh ra cấu hình kế tiếp_

}

}

**Ví dụ 2.3**. Liệt kê các hoán vị của 1, 2, .., n.

**Lời giải.** Mỗi hoán vị của 1, 2, .., N là một cách xếp có tính đến thứ tự của 1, 2,..,N. Số các hoán vị là N!. Ví dụ với N =3 ta có 6 hoán vị dưới đây.

**Bảng 2.3**. Hoán vị của 1, 2, 3.


| STT | Hoán vị |
| --- | --- |
| 1 | 1 2 3 |
| 2 | 1 3 2 |
| 3 | 2 1 3 |
| 4 | 2 3 1 |
| 5 | 3 1 2 |
| 6 | 3 2 1 |

 

**Điều kiện 1.** Có thể xác định được nhiều trật tự khác nhau trên các hoán vị. Tuy nhiên, thứ tự đơn giản nhất có thể được xác định như sau. Hoán vị X =(x1, x2,.., xn) được gọi là đứng sau hoán vị Y = (y1, y2,..,yn) nếu tồn tại chỉ số k sao cho x1 = y1, x2 = y2,…, xk-1 =yk-1, xk<yk. Ví dụ hoán vị X = (1, 2, 3 ) được gọi là đứng sau hoán vị Y =(1, 3, 2) vì tồn tại k =2 để x1 = y1, và x2<y2. Hoán vị đầu tiên là X[] = (1, 2, …, n), hoán vị cuối cùng là X[] = (n, n-1, …, 1).

**Điều kiện 2**. Được thể hiện thông qua hàm Next_Permutation() như chương trình dưới đây.

#include <iostream>
#include <iomanip> #define MAX 100 int X[MAX], n, dem=0; bool OK = true; using namespace std; void Init(void){ // _thiết lập hoán vị đầu tiên_ cout<<"\n Nhap n:"; cin>>n;

for(int i=1; i<=n; i++) // _thiết lập X_ [] _=_ ( _1, 2, ..,n_ )

X[i] = i;

} void Result(void){ // _đưa ra hoán vị hiện tại_ cout<<"\n Kết quả "<<++dem<<":";

for(int i=1; i<=n; i++)

cout<<X[i]<<setw(3);

}
void Next_Permutation(void){ // _sinh ra hoán vị kế tiếp_ int j = n-1; // _xuất phát từ vị trí j = n-1_
while(j>0 && X[j]>X[j+1]) // _tìm chỉ số j sao cho X[j] < X[j+1]_ j--;
if ( j > 0){ // _nếu chưa phải hoán vị cuối cùng_ int k = n; // _xuất phát từ vị trí k = n_

while(X[j]>X[k]) // _tìm chỉ số k sao cho X[j] < X[k]_

k--;

int t = X[j]; X[j] = X[k]; X[k]=t; // _đổi chỗ X[j] cho X[k]_ int r = j+1, s = n; while (r<=s){ // _lật ngược lại đoạn từ j+1,..,n_ t=X[r]; X[r]=X[s]; X[s]=t;

r++; s--;

}

}

else // _nếu là cấu hình cuối cùng_

OK = false; // _ta kết thúc duyệt_
}
int main(void){ // _đây là thuật toán sinh_ Init(); // _thiết lập cấu hình đầu tiên_
while(OK){ // _lặp trong khi cấu hình chưa phải cuối cùng_ Result(); // _đưa ra cấu hình hiện tại_

Next_Permutation(); // _sinh ra cấu hình kế tiếp_

}

}

# Mô hình thuật toán đệ qui (Recursion Algorithm) 

Một đối tượng được định nghĩa trực tiếp hoặc gián tiếp thông qua chính nó được gọi là phép định nghĩa bằng đệ qui. Thuật toán giải bài toán _P_ một cách trực tiếp hoặc gián tiếp thông qua bài toán _P_ ’ giống như _P_ được gọi là thuật toán đệ qui giải bài toán _P_. Một hàm được gọi là đệ qui nếu nó được gọi trực tiếp hoặc gián tiếp đến chính nó.

Tổng quát, một bài toán có thể giải được bằng đệ qui nếu nó thỏa mãn hai điều kiện:

  * **Phân tích được** _: Có thể giải được bài toán P bằng bài toán P’ giống như P. Bài tóa P’ và chỉ khác P ở dữ liệu đầu vào. Việc giải bài toán P’ cũng được thực hiện theo cách phân tích giống như P._

  * **Điều kiện dừng** _: Dãy các bài toán P’ giống như P là hữu hạn và sẽ dừng tại một bài toán xác định nào đó._


Thuật toán đệ qui tổng quát có thể được mô tả như sau:

_Thuật toán Recursion ( P )_ {

  1. _Nếu P thỏa mãn điều kiện dừng:_


< _Giải P với điều kiện dừng_ >;

  2. Nếu _P_ không thỏa mãn điều kiện dừng:


_< Giải P’ giống như P:Recursion(P’)>;_

}

**Ví dụ 2.4**. Tìm tổng của n số tự nhiên đầu tiên bằng phương pháp đệ qui.

**Lời giải**. Gọi Sn là tổng của n số tự nhiên. Khi đó:

  * **Bước phân tích** : dễ dàng phận thấy tổng n số tự nhiên Sn = n + Sn-1, với n1. • **Điều kiện dừng** : S0 = 0 nếu n = 0;


Từ đó ta có lời giải của bài toán như sau:

int Tong (int n ) {

if (n ==0 ) return(0); // _Điều kiện dừng_

else return(n + Tong(n-1)); // _Điều kiện phân tích được_

}

Chẳng hạn ta cần tìm tổng của 5 số tự nhiên đầu tiên, khi đó:

S = Tong(5)

= 5 + Tong(4)

= 5 + 4 + Tong(3)

= 5 + 4 + 3 + Tong(2)

= 5 + 4 + 3 + 2+ Tong(1)

= 5 + 4 + 3 + 2 + 1 + Tong(0)

= 5 + 4 + 3 + 2 + 1 + 0

= 15

**Ví dụ 2.5**. Tìm n!.

**Lời giải**. Gọi Sn là n!. Khi đó:

  * **Bước phân tích** : Sn = n*(n-1)! nếu n>0;

  * **Điều kiện dừng** : s0=1 nếu n=0.


Từ đó ta có lời giải của bài toán như sau:
long Giaithua (int n ) {

if (n ==0 ) return(1); // _Điều kiện dừng_

else return(n *Giaithua(n-1)); // _Điều kiện phân tích được_

} **Ví dụ 2.6.** Tìm ước số chung lớn nhất của a và b bằng phương pháp đệ qui.

**Lời giải**. Gọi d =USCLN(a,b). Khi đó:

  * **Bước phân tích** : nếu b0 thì d = USCLN(a, b) = USCLN(b, r), trong đó a =b, b = r = a mod b .

  * **Điều kiện dừng** : nếu b = 0 thì a là ước số chung lớn nhất của a và b. Từ đó ta có lời giải của bài toán như sau: int USCLN (int a, int b ) { if (a ==b ) return(a); // _Điều kiện dừng_ else { // _Điều kiện phân tích được_ int r = a % b; a = b; b = r; return(USCLN(a, b)); // _giải bài toán USCLN(a, b)_


}

}

# Public_052

# Mô hình thuật toán quay lui (Backtrack Algorithm)

Giả sử ta cần xác định bộ _X_ =( _x_ 1, _x_ 2,.., _x_ n) thỏa mãn một số ràng buộc nào đó. Ứng với mỗi thành phần _x_ i ta có _n_ i khả năng cần lựa chọn. Ứng với mỗi khả năng _j∈ni_ dành cho thành phần xi ta cần thực hiện:

  * _Kiểm tra xem khả năng j có được chấp thuận cho thành phần xi hay không? Nếu khả năng j được chấp thuận thì ta xác định thành phần xi theo khả năng j. Nếu i là thành phần cuối cùng (i=n) ta ghi nhận nghiệm của bài toán. Nếu i chưa phải cuối cùng ta xác định thành phần thứ i +1._

  * _Nếu không có khả năng j nào được chấp thuận cho thành phần xi thì ta quay lại bước trước đó (i-1) để thử lại các khả năng còn lại._


Thuật toán quay lui được mô tả như sau:
Thuật toán Back-Track ( int i ) {
for ( j =<Khả năng 1>; j <=ni; j++ ){ if (<chấp thuận khả năng j>) {
X[i] = <khả năng j>; if ( i ==n) Result(); else Back-Track(i+1);
}
}
**Ví dụ 2.7**. Duyệt các xâu nhị phân có độ dài n.
**Lời giải**. Xâu nhị phân _X_ = ( _x_ 1, _x_ 2,.., _x_ n)| xi =0, 1. Mỗi _x_ i∈X có hai lựa chọn xi=0, 1. Cả hai giá trị này đều được chấp thuận mà không cần có thêm bất kỳ điều kiện gì. Thuật toán được mô tả như sau:
void Try ( int i ) {
for (int j =0; j<=1; j++){ X[i] = j;
if (i ==n) Result(); else Try (i+1);
}
}
Khi đó, việc duyệt các xâu nhị phân có độ dài n ta chỉ cần gọi đến thủ tục Try(1). Cây quay lui được mô tả như Hình 2.1 dưới đây.
![](images/image1.png)
**Hình 2.1**. _Duyệt các xâu nhị phân độ dài 3_
Chương trình duyệt các xâu nhị phân có độ dài n bằng thuật toán quay lui được thể hiện như dưới đây.
#include <iostream> #include <iomanip> #define MAX 100 using namespace std; int X[MAX], n, dem=0;
void Init(){ // _thiết lập độ dài xâu nhị phân  
_cout<<"\n Nhập n="; cin>>n;
}
void Result(void){ // _In ra xâu nhị phân X[] = x_ 1 _, x_ 2 _,.., x_ n
cout<<"\n Kết quả "<<++dem<<":"; for(int i =1; i<=n; i++)
cout<<X[i]<<setw(3);
}
void Try(int i){ // _thuật toán quay lui_
for (int j=0; j<=1; j++){ // _duyệt các khả năng j dành cho x_ i
X[i]=j; // _thiết lập thành phần x_ i _là j_
if(i==n) // _nếu i là thành phần cuối cùng_
Result(); // _ta đưa ra kết quả_
else // _trong trường hợp khác_
Try(i+1); // _ta xác định tiếp thành phần x_ i+1
}
}
int main(void){ Init(); Try(1);}

**Ví dụ 2**. **8.** Duyệt các tập con K phần tử của 1, 2, .., N.

**Lời giải**. Mỗi tập con K phần tử _X_ = ( _x_ 1, _x_ 2,.., _x_ K) là bộ không tính đến thứ tự K phần tử của 1, 2, .., N. Mỗi _x_ i∈X có N-K+i lựa chọn. Các giá trị này đều được chấp thuận mà không cần có thêm bất kỳ điều kiện gì. Thuật toán được mô tả như sau:
void Try ( int i ) {
for (int j =X[i-1]+1; j<=N-K+ i; j++){ X[i] = j;
if (i ==K) Result(); else Try (i+1);
}
}
Khi đó, việc duyệt các tập con K phần tử của 1, 2, .., N ta chỉ cần gọi đến thủ tục Try(1). Cây quay lui được mô tả như hình dưới đây.
![](images/image2.png)
**Hình 2.2**. _Duyệt các tập con 3 phần tử của 1, 2, 3, 4, 5._
Chương trình liệt kê các tập con k phần tử của 1, 2, ..,n được thể hiện như sau. #include <iostream>
#include <iomanip> #define MAX 100 using namespace std;
int X[MAX], n, k, dem=0;
void Init(){// _thiết lập giá trị cho n, k_
cout<<"\n Nhập n, k: "; cin>>n>>k;
}
void Result(void){ cout<<"\n Kết quả "<<++dem<<":";// _đưa ra kết quả_
for(int i =1; i<=k; i++) cout<<X[i]<<setw(3);
}
void Try(int i){// _thuật toán quay lui_
for (int j=X[i-1]+1; j<=n-k+i; j++){ // _duyệt trên tập khả năng dành cho x_ i
X[i]=j; // _thiết lập thành phần xi là j_
if(i==k) // _nếu x_ i _đã là thành phần cuối_
Result(); // _ta đưa ra kết quả_
else // _trong trường hợp khác_
Try(i+1); // _ta đi xác định thành phần thứ x_ i+1
}
}
int main(void){
Init(); X[0] =0 ; Try(1);
}
**Ví dụ 2.9**. Duyệt các hoán vị của 1, 2, .., N.
**Lời giải**. Mỗi hoán vị _X_ = ( _x_ 1, _x_ 2,.., _x_ K) là bộ có tính đến thứ tự của 1, 2, .., N. Mỗi _x_ i∈X có N lựa chọn. Khi xi = j được lựa chọn thì giá trị này sẽ không được chấp thuận cho các thành phần còn lại. Để ghi nhận điều này, ta sử dụng mảng chuaxet[] gồm N phần tử. Nếu chuaxet[i] = True điều đó có nghĩa giá trị i được chấp thuận và chuaxet[i] = False tương ứng với giá trị i không được phép sử dụng. Thuật toán được mô tả như sau:
void Try ( int i ) {
for (int j=1; j<=N; j++){ if (chuaxet[j] ) {
X[i] = j;chuaxet[j] = False; if ( i ==N) Result();
else Try (i+1); Chuaxet[j] = True;
}
}
}
Khi đó, việc duyệt các hoán vị của 1, 2, .., N ta chỉ cần gọi đến thủ tục Try(1). Cây quay lui được mô tả như hình dưới đây.
![](images/image3.png)
**Hình 2.3**. Duyệt các hoán vị của 1, 2, 3.

Chương trình liệt kê tất cả các hoán vị của 1, 2, .., n được thể hiện như sau: |  
#include <iostream>

#include <iomanip> #define MAX 100  
using namespace std;  
int X[MAX], n, dem=0; bool chuaxet[MAX];
void Init(){// _thiết lập giá trị cho n_
cout<<"\n Nhập n="; cin>>n;
for(int i=1; i<=n; i++) // _thiết lập giá trị cho mảng chuaxet[]_
chuaxet[i]=true;
}
void Result(void){ // _Đưa ra hoán vị hiện tại_
cout<<"\n Kết quả "<<++dem<<":";
for(int i =1; i<=n; i++) cout<<X[i]<<setw(3);
}
void Try(int i){ // _thuật toán quay lui duyệt các hoán vị của 1, 2, .., n._
for (int j=1; j<=n; j++){ // _duyệt các khả năng j cho thành phần xi_
if(chuaxet[j]){ // _nếu khả năng j đúng chưa được dùng đến_ X[i]=j; // _thiết lập thành phần xi là j  
_chuaxet[j]=false; // _thiết lập chuaxet[j] đã được dùng_ if(i==n) // _nếu xi đã là thành phần cuối cùng_
Result();// _ta đưa ra kết quả_
else /// _trong trường hợp khác_
Try(i+1); // _ta xác định tiếp thành phần thứ i+1_
chuaxet[j]=true; // _nhớ hoàn trả lại giá trị cho chuaxet[j]_
}
}
}
int main(void){
Init(); Try(1);
}
**Ví dụ 2.10**. Bài toán N quân hậu. Trên bàn cờ kích cỡ N×N, hãy đặt N quân hậu mỗi quân trên 1 hàng sao cho tất cả các quân hậu đều không ăn được lẫn nhau.
**Lời giải**. Gọi X =(x1, x2,..,xn) là một hoán vị của 1, 2, .., n.. Khi đó, xi = j được hiểu là quân hậu hàng thứ i đặt ở cột j. Để các quân hậu khác không thể ăn được, quân hậu thứ i cần không được lấy trùng với bất kỳ cột nào, không được cùng đường chéo xuôi, không được cùng trên đường chéo ngược. Ta có n cột Cot = (c1,..cn), có Xuoi[2*n-1] đường chéo xuôi, Nguoc[2*n-1] đường chéo ngược. Quân hậu ở hàng _i_ được đặt vào cột _j_ nếu A[j] = True (chưa có quân hậu nào án ngữ cột j), Xuoi[i-j+n] = True (chưa có quân hậu nào án ngữ đường chéo i-j+n), Nguoc[i + j -1] = True (chưa có quân hậu nào án ngữ đường chéo ngược i + j-1).
Đường chéo xuôi Xuoi[i-j+n] Đường chéo ngược Nguoc[i+j-1]![](images/image4.png)
**Hình 2.4**. _Mô tả các đường chéo, xuôi đường chéo ngược_
Thuật toán quay lui giải bài toán n quân hậu được mô tả như dưới đây. void Try (int i){
for(int j=1; j<=n; j++){
if( Cot[j] && Xuoi[ i – j + n ] && Nguoc[i + j -1]){ X[i] =j; Cot[j]=FALSE;
Xuoi[ i - j + n]=FALSE; Nguoc[ i + j - 1]=FALSE; if(i==n) Result();
else Try(i+1); Cot[j] = TRUE;
Xuoi[ i - j + n] = TRUE; Nguoc[ i + j - 1] = TRUE;
}
}
}
Chương trình giải bài toán n quân hậu được thể hiện như dưới đây. #include <iostream>
#include <iomanip> #define MAX 100  
using namespace std;  
int X[MAX], n, dem=0;
bool COT[MAX], DCXUOI[MAX], DCNGUOC[MAX];;

void Init(){ // _thiết lập kích cỡ bàn cờ_

cout<<"\n Nhap n="; cin>>n;

for(int i=1; i<=n; i++){ // _thiết lập tất cả các cột đều chưa bị án ngữ_
COT[i]=true;
}
for(int i=1; i<2*n; i++){ // _thiết lập các đường chéo_ DCXUOI[i]=true; // _đường chéo xuôi chưa bị án ngữ_ DCNGUOC[i]=true; // _đường chéo ngược chưa bị án ngữ_
}
}
void Result(void){ // _đưa ra một phương án_ cout<<"\n Kết quả "<<++dem<<":"; for(int i =1; i<=n; i++)
cout<<X[i]<<setw(3);
}
void Try(int i){ // _đây là thuật toán quay lui_
for (int j=1; j<=n; j++){ // _duyệt các khả năng j đặt quân hậu vào hàng i_
if( COT[j] && DCXUOI[i-j+n]&& DCNGUOC[i+j-1]){
// _nếu đúng cột j, đường chéo xuôi i-j +n, đường chéo ngược i+j-1_
_// chưa bị án ngữ_
X[i]=j; // _ta đặt được quân hậu hàng i vào vột j_
COT[j] = false; // _cột j đã bị án ngữ_
DCXUOI[i-j+n]=false; // _đường chéo xuôi i-j+n bị án ngữ_ DCNGUOC[i+j-1]=false;// _đường chéo ngược i+j-1 bị án ngữ_ if(i==n) // _nếu đây là quân hậu hàng n_
Result();// _ta đưa ra phương án hiện tại_
else // _trong trường hợp khác_
Try(i+1); // _ta đặt tiếp quân hậu hành i+1_
COT[j] = true; // _nhớ trả lại giá trị cột j_
DCXUOI[i-j+n]=true; // _trả lại giá trị đường chéo xuôi_
DCNGUOC[i+j-1]=true; // _trả lại giá trị đường chéo ngược_
}
}
}
int main(void){ Init(); Try(1); }

# Public_053

Một trong những vấn đề quan trọng bậc nhất của khoa học máy tính là tìm kiếm thông tin. Có thể nói, hầu hết các hoạt động của người dùng hoặc các ứng dụng tin học đều liên quan đến tìm kiếm. Muốn tìm kiếm thông tinh nhanh, hiệu quả, chính xác ta cần có phương pháp tổ chức và sắp xếp dữ liệu tốt. Chính vì vậy, sắp xếp được xem như giai đoạn đầu chuẩn bị cho quá trình tìm kiếm. Nội dung chương này trình bày các thuật toán sắp xếp và tìm kiếm, bao gồm: các thuật toán sắp xếp đơn giản, các thuật toán sắp xếp nhanh, các thuật toán tìm kiếm tuyến tính, tìm kiếm nhị phân, tìm kiếm nội suy & tìm kiếm Jumping.

# Giới thiệu vấn đề

Bài toán tìm kiếm có thể được phát biểu như sau: Cho dãy gồm n đối tượng _r_ 1, _r_ 2,
.., _r_ n. Mỗi đối tượng _r_ i được tương ứng với một khóa _k_ i (1≤i ≤n). Nhiệm vụ của tìm kiếm là xây dựng thuật toán tìm đối tượng có giá trị khóa là _X_ cho trước. _X_ còn được gọi là khóa tìm kiếm hay tham biến tìm kiếm (argument). Bài toán tìm kiếm bao giờ cũng hoàn thành bởi một trong hai tình huống:

  * Nếu tìm thấy đối tượng có khóa _X_ trong tập các đối tượng thì ta nói phép tìm kiếm thành công (successful).

  * Nếu không tìm thấy đối tượng có khóa _X_ trong tập các đối tượng thì ta nói phép tìm kiếm không thành công (unsuccessful).


**Sắp xếp** là phương pháp bố trí lại các đối tượng theo một trật tự nào đó. Ví dụ bố trí theo thứ tự tăng dần hoặc giảm dần đối với dãy số, bố trị theo thứ tự từ điển đối với các xâu ký tự. Mục tiêu của sắp xếp là để lưu trữ và tìm kiếm đối tượng (thông tin) để đạt hiệu quả cao trong tìm kiếm. Có thể nói, sắp xếp là sân sau quả quá trình tìm kiếm. Muốn tìm kiếm và cung cấp thông tin nhanh thì ta cần phải sắp xếp thông tin sao cho hợp lý. Bài toán sắp xếp có thể được phát biểu như sau:
**Bài toán sắp xếp** : Cho dãy gồm n đối tượng r1, r2, .., rn. Mỗi đối tượng ri được tương ứng với một khóa ki (1≤i ≤n). Nhiệm vụ của sắp xếp là xây dựng thuật toán bố trí các đối tượng theo một trật tự nào đó của các giá trị khóa. Trật tự của các giá trị khóa có thể là tăng dần hoặc giảm dần tùy thuộc vào mỗi thuật toán tìm kiếm cụ thể.
Trong các mục tiếp theo, chúng ta xem tập các đối tượng cần sắp xếp là tập các số. Việc mở rộng các số cho các bản ghi tổng quát cũng được thực hiện tương tự bằng cách thay đổi các kiểu dữ liệu tương ứng. Cũng giống như tìm kiếm, việc làm này không làm mất đi bản chất của thuật toán.

# Các thuật toán sắp xếp đơn giản

Các thuật toán sắp xếp đơn giản được trình bày ở đây bao gồm:

  * Thuật toán sắp xếp kiểu lựa chọn (Selection Sort).

  * Thuật toán sắp xếp kiểu chèn trực tiếp (Insertion Sort).

  * Thuật toán sắp xếp kiểu sủi bọt (Bubble Sort)


## **Thuật toán Selection-Sort**

Thuật toán sắp xếp đơn giản nhất được đề cập đến là thuật toán sắp xếp kiểu chọn. Thuật toán thực hiện sắp xếp dãy các đối tượng bằng cách lặp lại việc tìm kiếm phần tử có giá trị nhỏ nhất từ thành phần chưa được sắp xếp trong mảng và đặt nó vào vị trí đầu tiên của dãy. Trên dãy các đối tượng ban đầu, thuật toán luôn duy trì hai dãy con: dãy con đã được sắp xếp là các phần tử bên trái của dãy và dãy con chưa được sắp xếp là các phần tử bên phải của dãy. Quá trình lặp sẽ kết thúc khi dãy con chưa được sắp xếp chỉ còn lại đúng một phần tử. Thuật toán được trình bày chi tiết trong Hình 3.1.

  1. **Biểu diễn thuật toán** ![](images/image1.png)


**Hình 3.1**. Thuật toán Selection Sort.

  2. **Độ phức tạp thuật toán**


Độ phức tạp thuật toán Selection Sort là O(N2), trong đó N là số lượng phần tử cần sắp xếp. Bạn đọc tự tìm hiểu phương pháp xác định độ phức tạp thuật toán Selection Sort trong các tài liệu tham khảo liên quan.

  3. **Kiểm nghiệm thuật toán**


![](images/image2.png)

  4. **Cài đặt thuật toán**


#include <iostream> #include <iomanip> using namespace std;
void swap(int *x, int *y){ // _đổi giá trị của x và y_
int temp = *x; *x = *y; *y = temp;
}
void SelectionSort(int arr[], int n){ // _thuật toán selection sort_
int i, j, min_idx; // _min_idx là vị trí để arr[min_index] nhỏ nhất_
for (i = 0; i < n-1; i++) { // _duyệt n-1 phần tử_
min_idx = i; // _vị trí số bé nhất tạm thời là i_
for (j = i+1; j < n; j++){ // _tìm vị trí số bé nhất arr[i+1],.., arr[n-1]_
if (arr[j] < arr[min_idx]) min_idx = j;
}
swap(&arr[min_idx], &arr[i]); _//tráo đổi arr[min_idx] và arr[i]_
}
}
void printArray(int arr[], int size){ // _hiển thị kết quả_
for (int i=0; i < size; i++) cout<<arr[i]<<setw(5);
cout<<endl;
}
int main(){ // _chương trình chính_
int arr[] = {64, 25, 12, 22, 11};
int n = sizeof(arr)/sizeof(arr[0]); SelectionSort(arr, n); cout<<"Dãy số được sắp: \n"; printArray(arr, n);
}

## Thuật toán Insertion Sort

Thuật toán sắp xếp kiểu chèn được thực hiện đơn giản theo cách của người chơi bài thông thường. Phương pháp được thực hiện như sau:

  * Lấy phần tử đầu tiên Arr[0] (quân bài đầu tiên) như vậy ta có dãy một phần tử được sắp.

  * Lấy phần tiếp theo (quân bài tiếp theo) Arr[1] và tìm vị trí thích hợp chèn Arr[1] vào dãy Arr[0] để có dãy hai phần tử đã được sắp.

  * Tổng quát, tại bước thứ i ta lấy phần tử thứ i và chèn vào dãy Arr[0],..,Arr[i-1] đã được sắp trước đó để nhận được dãy i phần tử được sắp. Quá trình sắp xếp sẽ kết thúc khi quân bài cuối cùng (i = n) được chèn đúng vị trí. Thuật toán Insertion Sort được mô tả chi tiết trong Hình 3.2.

1. **Biểu diễn thuật toán** ![](images/image3.png)


**Hình 3.2**. Thuật toán Insertion Sort

  2. **Độ phức tạp thuật toán**


Độ phức tạp thuật toán là O(N2), với N là số lượng phần tử. Thuật toán có thể cải tiến bằng cách sử dụng hàng đợi ưu tiên với độ phức tạp O(N.Log(N)).
**c) Kiểm nghiệm thuật toán**

  3. **Cài đặt thuật toán** #include <iostream> #include <iomanip> using namespace std;![](images/image4.jpg)


void insertionSort(int arr[], int n){ int i, key, j;
for (i = 1; i < n; i++){
key = arr[i]; j = i-1;
while (j >= 0 && arr[j] > key){ arr[j+1] = arr[j];
j = j-1;
}
arr[j+1] = key;
}
}
void printArray(int arr[], int n){
int i;cout<<"\n Day so duoc sap:"; for (i=0; i < n; i++)
cout<<arr[i]<<setw(3);
}
int main(){
int arr[] = {12, 11, 13, 5, 6};
int n = sizeof(arr)/sizeof(arr[0]); insertionSort(arr, n); printArray(arr, n);
}

# Public_054

# Thuật toán Bubble Sort

Thuật toán sắp xếp kiểu sủi bọt được thực hiện đơn giản bằng cách tráo đổi hai phần từ liền kề nhau nếu chúng chưa được sắp xếp. Thuật toán được mô tả chi tiết trong Hình 3.3.

## ![](images/image1.png) Biểu diễn thuật toán

**Hình 3.3**. Thuật toán Bubble Sort

## Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(N2), với N là số lượng phần tử. Bạn đọc tự tìm hiểu phương pháp ước lượng và chứng minh độ phức tạp thuật toán Bubble Sort trong các tài liệu liên quan.

## Kiểm nghiệm thuật toán

![](images/image2.png)

## Cài đặt thuật toán

#include <iostream>  
#include <iomanip>  
using namespace std;

void swap(int *x, int *y){ // _đổi chỗ hai số x và y_
int temp = *x; *x = *y;*y = temp;
}
void bubbleSort(int arr[], int n){ // _thuật toán bubble sort_
int i, j;
for (i = 0; i < n; i++) {

for (j = 0; j < n-i-1; j++) {

if (arr[j] > arr[j+1])

swap(&arr[j], &arr[j+1]);
}
}
}
void printArray(int arr[], int size){  
cout<<"\n Dãy được sắp:";  
for (int i=0; i < size; i++)
cout<<arr[i]<<setw(3);
}
int main(){
int arr[] = {64, 34, 25, 12, 22, 11, 90};
int n = sizeof(arr)/sizeof(arr[0]); bubbleSort(arr, n); printArray(arr, n);
}

# Thuật toán Quick Sort

Thuật toán sắp xếp Quick-Sort được thực hiện theo mô hình chia để trị (Divide and Conquer). Thuật toán được thực hiện xung quanh một phần tử gọi là chốt (key). Mỗi cách lựa chọn vị trí phần tử chốt trong dãy sẽ cho ta một phiên bản khác nhau của thuật toán. Các phiên bản (version) của thuật toán Quicksort bao gồm:

  * Luôn lựa chọn phần tử đầu tiên trong dãy làm chốt.

  * Luôn lựa chọn phần tử cuối cùng trong dãy làm chốt.

  * Luôn lựa chọn phần tử ở giữa dãy làm chốt.

  * Lựa chọn phần tử ngẫu nhiên trong dãy làm chốt.


Mấu chốt của thuật toán Quick-Sort là làm thế nào ta xây dựng được một thủ tục phân đoạn (Partition). Thủ tục Partition có hai nhiệm vụ chính:

  * Định vị chính xác vị trí của chốt trong dãy nếu được sắp xếp;

  * Chia dãy ban đầu thành hai dãy con: dãy con ở phía trước phần tử chốt bao gồm các phần tử nhỏ hơn hoặc bằng chốt, dãy ở phía sau chốt có giá trị lớn hơn chốt.


Thuật toán Partition được mô tả chi tiết trong Hình 3.4 với khóa chốt là phần tử cuối cùng của dãy. Phiên bản Quick Sort tương ứng được mô tả chi tiết trong Hình 3.5.

##  Biểu diễn thuật toán![](images/image3.png)

**Hình 3.4**. Thuật toán Partition với chốt là vị trí cuối cùng của dãy
![](images/image4.png)
**Hình 3.5**. Thuật toán Quick-Sort với chốt là vị trí cuối cùng của dãy

##  Độ phức tạp thuật toán

Độ phức tạp thuật toán trong trường hợp xấu nhất là O(N2), trong trường hợp tốt nhất là O(N.Log(N)), với N là số lượng phần tử. Bạn đọc tự tìm hiểu và chứng minh độ phức tạp thuật toán Quick Sort trong các tài liệu liên quan.

## Kiểm nghiệm thuật toán

![](images/image5.png)

**2.4. Cài đặt thuật toán** #include<iostream> #include<iomanip>

using namespace std;

void swap(int* a, int* b){ // _đổi chỗ a và b_
int t = *a; *a = *b; *b = t;
}
int partition (int arr[], int l, int h){ // _thuật toán partition chốt h_
int x = arr[h]; // _x chính là chốt_
int i = (l - 1); // _i lấy vị trí nhỏ hơn l_
for (int j = l; j <= h- 1; j++) {// _duyệt từ l đến h-1_
// If current element is smaller than or equal to pivot if (arr[j] <= x){ // _nếu arr[j] bé hơn hoặc bằng chốt_
i++; // _tăng i lên một đoen vị_
swap(&arr[i], &arr[j]); // _đổi chỗ arr[i] cho arr[j]_
}
}
swap(&arr[i + 1], &arr[h]); // _đổi chỗ cho arr[i+1] và arr[h]_
return (i + 1); // _đây là vị trí của chốt_
}
void quickSort(int arr[], int l, int h){ if (l < h){
int p = partition(arr, l, h); // _tìm vị trí của chốt_
quickSort(arr, l, p - 1);// _trị nửa bên trái_
quickSort(arr, p + 1, h);// _trị nửa bên phải_
}
}
void printArray(int arr[], int size){ // _thủ tục in kết quả_
int i; cout<<"\n _Dãy được sắp_ :"; for (i=0; i < size; i++)
cout<<arr[i]<<setw(3);
}
int main(){ // _chương trình chính_
int arr[] = {10, 27, 15, 29, 21, 11, 14, 18, 12, 17};
int n = sizeof(arr)/sizeof(arr[0]); quickSort(arr, 0, n-1); printArray(arr, n);
}

# Thuật toán Merge Sort

Giống như Quick-Sort, Merge-Sort cũng được xây dựng theo mô hình chia để trị (Divide and Conquer). Thuật toán chia dãy cần sắp xếp thành hai nửa. Sau đó gọi đệ qui lại cho mỗi nửa và hợp nhất lại các đoạn đã được sắp xếp. Thuật toán được tiến hành theo 4 bước dưới đây:

  * Tìm điểm giữa của dãy và chia dãy thành hai nửa.

  * Thực hiện Merge-Sort cho nửa thứ nhất.

  * Thực hiện Merge-Sort cho nửa thứ hai.

  * Hợp nhất hai đoạn đã được sắp xếp.


![](images/image6.png)

Mấu chốt của thuật toán Merge-Sort là làm thế nào ta xây dựng được một thủ tục hợp nhất (Merge). Thủ tục Merge thực hiện hòa nhập hai dãy đã được sắp xếp để tạo thành một dãy cũng được sắp xếp. Bài toán có thể được phát biểu như sau:
**Bài toán hợp nhất Merge** : Cho hai nửa của một dãy Arr[1,..,m] và A[m+1,..,r] đã được sắp xếp. Nhiệm vụ của ta là hợp nhất hai nửa của dãy Arr[1,..,m] và Arr[m+1,..,r] để trở thành một dãy Arr[1, 2,..,r] cũng được sắp xếp.
Thuật toán Merge được mô tả chi tiết trong Hình 3.6. Thuật toán Merge Sort được mô tả chi tiết trong Hình 3.7.
**Biểu diễn thuật toán:**

![](images/image7.png)

**Hình 3.6**. Thuật toán hợp nhất hai đoạn đã được sắp xếp.
![](images/image8.png)
**Hình 3.7**. Thuật toán Merge Sort

## Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(N.Log(N)) với N là số lượng phần tử. Bạn đọc tự tìm hiểu và chứng minh độ phức tạp thuật toán Merge Sort trong các tài liệu liên quan.

##  Kiểm nghiệm thuật toán![](images/image9.png)

## Cài đặt thuật toán 

#include<iostream>  
#include<iomanip>  
using namespace std;

void merge(int arr[], int l, int m, int r){// _thuật toán hợp nhất hai đoạn đã sắp xếp_
int i, j, k;
int n1 = m - l + 1; // _số lượng phần tử đoạn 1_
int n2 = r - m; // _số lượng phần tử đoạn 3_
int L[n1], R[n2]; // _tạo hai mảng phụ để lưu hai đoạn được sắp_
for(i = 0; i < n1; i++)// _lưu đoạn thứ nhất vào L[]_
L[i] = arr[l + i];
for(j = 0; j < n2; j++)// _lưu đoạn thứ hai vào R[]_
R[j] = arr[m + 1+ j];
i = 0; j = 0; k = l; // _bắt đầu hợp nhất_
while (i < n1 && j < n2){ // _quá trình hợp nhất_
if (L[i] <= R[j]){
arr[k] = L[i]; i++;

}

else {

arr[k] = R[j]; j++;

} k++;
}while (i < n1) { // _lấy các phần tử còn lại trong L[] vào arr[]_
arr[k] = L[i]; i++; k++;
}
while (j < n2){ // _lấy các phần tử còn lại trong R[] vào arr[]_
arr[k] = R[j]; j++; k++;
}
}
void mergeSort(int arr[], int l, int r){ // _thuật toán Merge Sort_
if (l < r){ // _nếu cận dưới còn bé hơn cận trên_
int m = l+(r-l)/2; // _tìm vị trí ở giữa đoạn l, r_ mergeSort(arr, l, m); // _trị nửa thứ nhất_ mergeSort(arr, m+1, r); // _trị nửa thứ hai_
merge(arr, l, m, r); // _hợp nhất hai đoạn đã được sắp_
}
}
void printArray(int Arr[], int size){ // _in kết quả_
int i;cout<<"\n Dãy được sắp:"; for (i=0; i < size; i++)
cout<<Arr[i]<<setw(3);
}
int main(){
int arr[] = {38, 27, 43, 3, 9, 82, 10};
int arr_size = sizeof(arr)/sizeof(arr[0]); mergeSort(arr, 0, arr_size \- 1); printArray(arr, arr_size);
}

# Thuật toán Heap Sort

Thuật toán Heap-Sort được thực hiện dựa trên cấu trúc dữ liệu Heap. Nếu ta muốn sắp xếp theo thứ tự tăng dần ta sử dụng cấu trúc Max Heap, ngược lại ta sử dụng cấu trúc Min-Heap. Vì Heap là một cây nhị phân đầy đủ nên việc biểu diễn Heap một cách hiệu quả có thể thực hiện được bằng mảng. Nếu ta xem xét phần tử thứ i trong mảng thì phần tử 2*i +1, 2*i +2 tương ứng là node con trái và node con phải của i.
Tư tưởng của Heap Sort giống như Selection Sort, chọn phần tử lớn nhất trong dãy đặt vào vị trí cuối cùng, sau đó lặp lại quá trình này cho các phần tử còn lại. Tuy nhiên, điểm khác biệt ở đây là phần tử lớn nhất của Heap luôn là phần tử đầu tiên trên Heap và các phần tử node trái và phải bao giờ cũng nhỏ hơn nội dung node gốc.
Thuật toán được thực hiện thông qua ba bước chính như sau:

  * Xây dựng Max Heap từ dữ liệu vào. Ví dụ với dãy A[] = {9, 7, 12, 8, 6, 5} thì Max Heap được xây dựng là A[] = {12, 8, 9, 7, 6, 5}.

  * Bắt đầu tại vị trí đầu tiên là phần tử lớn nhất của dãy. Thay thế, phần tử này cho phần tử cuối cùng ta nhận được dãy A[] = {5, 8, 9, 7, 6, 12}.

# Public_055

# Một số thuật toán tìm kiếm thông dụng

Tìm kiếm là lĩnh vực quan trọng của khoa học máy tính có mặt trong hầu hết các ứng dụng trên máy tính. Các thuật toán tìm kiếm được chia thành ba loại: tìm kiếm trên các đối tượng dữ liệu chưa được sắp xếp (tìm kiếm tuyến tính), tìm kiếm trên các đối tượng dữ liệu đã được sắp xếp (tìm kiếm nhị phân) và tìm kiếm xấp xỉ. Nội dung cụ thể của các phương pháp được thể hiện như dưới đây.

## Thuật toán tìm kiếm tuyến tính (Sequential Search)

Thuật toán tìm kiếm tuyến tính áp dụng cho tất cả các đối tượng dữ liệu chưa được sắp xếp. Để tìm vị trí của _x_ trong dãy A[] gồm _n_ phần tử, ta chỉ cần duyệt tuần tự trên dãy A[] từ phần tử đầu tiên đến phần tử cuối cùng. Nếu _x_ = A[ _i_ ] thì _i_ chính là vị trí của _x_ thuộc dãy A[]. Nếu duyệt đến phần tử cuối cùng vẫn chưa tìm thấy _x_ ta kết luận _x_ không có mặt trong dãy số A[]. Thuật toán được mô tả chi tiết trong Hình 3.9.

### Biểu diễn thuật toán

**Hình 3.9**. Thuật toán Sequential-Search.

### Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(n), với n là số lượng phần tử trong dãy A[].

### Kiểm nghiệm thuật toán

Ví dụ ta cần tìm x = 9 trong dãy A[] = {56, 3, 249, 518, 7, 26, 94, 651, 23, 9 }. Khi đó quá trình tìm kiếm được thể hiện như dưới đây.![](images/image5.jpg)

### Cài đặt thuật toán 

#include <iostream>
using namespace std;
int Sequential_Search( int A[], int n, int x){
for(int i=0; i<n; i++){
if ( x == A[i]) return i;
}
return -1;
}
int main(void){
int A[] = {9, 7, 12, 8, 6, 5};
int x = 15, n = sizeof(A)/sizeof(A[0]); int t = Sequential_Search(A,n,x); if(t>=0)cout<<"\n Vị trí của x:"<<t; else cout<<"\n Không tìm thấy x";
}

## Thuật toán tìm kiếm nhị phân

Thuật toán tìm kiếm nhị phân là phương pháp định vị phần tử _x_ trong một danh sách A[] gồm n phần tử đã được sắp xếp. Quá trình tìm kiếm bắt đầu bằng việc chia danh sách thành hai phần. Sau đó, so sách x với phần từ ở giữa. Khi đó có 3 trường hợp có thể xảy ra:

**Trường hợp 1** : nếu x bằng phần tử ở giữa A[mid], thì mid chính là vị trí của x trong danh sách A[].
**Trường hợp 2** : Nếu x lớn hơn phần tử ở giữa thì nếu x có mặt trọng dãy A[] thì ta chỉ cần tìm các phần tử từ mid+1 đến vị trí thứ n.
**Trường hợp 3** : Nếu x nhỏ hơn A[mid] thì x chỉ có thể ở dãy con bên trái của dãy A[].

Lặp lại quá trình trên cho đến khi cận dưới vượt cận trên của dãy A[] mà vẫn chưa tìm thấy _x_ thì ta kết luận _x_ không có mặt trong dãy A[]. Thuật toán được mô tả chi tiết trong Hình 3.10.

### Biểu diễn thuật toán

![](images/image2.png)
**Hình 3.10**. Thuật toán Binary-Search

### Độ phức tạp thuật toán

Độ phức tạp thuật toán là O(log(n)), với n là số lượng phần tử của dãy A[].

### Kiểm nghiệm thuật toán

Ví dụ ta cần tìm x = 23 trong dãy A[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91}. Khi đó quá trình được tiến hành như dưới đây.![](images/image9.jpg)

### Cài đặt thuật toán 

#include <iostream>  
using namespace std;
int Binary_Search( int A[], int n, int x) {//tìm vị trí của x trong dãy A[]
int low = 0; _//cận dưới của dãy khóa_
int hight = n-1; _//cận trên của dãy khóa_
int mid = (low+hight)/2; _//vị trí phần tử ở giữa_
while ( low <=hight) { // _lặp trong khi cận dưới nhỏ hơn cận trên_
if ( x > A[mid] ) _//nếu x lớn hơn phần tử ở giữa_
low = mid + 1; _//cận dưới dịch lên vị trí mid +1_
else if ( x < A[mid] ) _//nếu x nhỏ hơn phần tử ở giữa_
hight = mid -1; _//cận trên dịch xuống vị trí mid -1_
else
return(mid); // _đây chính là vị trí của x_
mid = (low + hight)/2; // _xác định lại vị trí ở giữa_
}
return(-1); // _không tìm thấy x trong A[]_.
}
int main(void){
int A[] = {2, 5, 8, 12, 16, 23, 38, 56, 72, 91};
int x = 91, n = sizeof(A)/sizeof(A[0]); int t = Binary_Search(A,n,x); if(t>=0)cout<<"\n Vị trí của x:"<<t; else cout<<"\n không tìm thấy x";
}

## Thuật toán tìm kiếm nội suy

Thuật toán tìm kiếm kiểu nội suy (interpolation search) là cải tiến của thuật toán tìm kiếm nhị phân. Thuật toán tìm kiếm nhị phân luôn thực hiện so sánh khóa với phần tử ở giữa. Trong đó, thuật toán tìm kiếm nội suy định vị giá trị so sánh tùy thuộc vào giá trị của khóa cần tìm. Bằng cách này, giá trị của khóa cần tìm kiếm dù ở đầu dãy, cuối dãy hay vị trí bất kỳ thuật toán đều tìm được vị trí gần nhất để thực hiện so sánh. Thuật toán được mô tả chi tiết trong Hình 3.11.

### Biểu diễn thuật toán

![](images/image3.png)

**Hình 3.11**. Thuật toán Interpolation-Search

### Độ phức tạp thuật toán

Độ phức tạp trung bình của thuật toán tìm kiếm nội suy là O(log(n)), với n là số lượng phần tử của dãy A[]. Trong trường hợp xấu nhất, thuật toán có độ phức tạp là O(n).

### Kiểm nghiệm thuật toán

Bạn đọc tự tìm hiểu phương pháp kiểm nghiệm thuật toán tìm kiếm nội suy trong các tài liệu liên quan.

### Cài đặt thuật toán 

#include <iostream>  
using namespace std;
int interpolationSearch(int A[], int n, int x){// _thuật toán tìm kiếm nội suy_
int L = 0, H = (n - 1);// _cận dưới và cận trên của dãy_
if (x < A[L] || x > A[H])// _nếu điều này xảy ra_
return -1; // _chắc chắn x không có mặt trong dãy A[]_
while (L <= H){// _lặp trong khi cận dưới bé hơn cận trên_
int pos = L + (((H-L) /(A[H]-A[L]))*(x - A[L])); // _xác định vị trí_
if (A[pos] == x)// _nếu vị trí đúng là x_
return pos; // _đây là vị trí cần tìm_
if (A[pos] < x)// _nếu x lớn hơn A[pos]_
L = pos + 1; // _dịch cận dưới lên 1_
else // _nếu x bé hơn A[pos]_
H = pos - 1; // _giảm cận trên đi 1_
}
return -1; // _kết luận không tìm thấy_
}
int main(){
int A[] = {10, 12, 13, 16, 31, 33, 35, 42, 47};
int n = sizeof(A)/sizeof(A[0]); int x = 42; // _phần tử cần tìm_
int index = interpolationSearch(A, n, x); if (index != -1)// _nếu tìm thấy x_
cout<<"Vị trí:"<<index;
else
cout<<"Không tìm thấy x";
}

## Thuật toán tìm kiếm Jumping

Thuật toán tìm kiếm Jumping được thực hiện bằng cách so sánh phần tử cần tìm với bước nhảy là một hàm mũ. Nếu khóa cần tìm lớn hơn phần tử tại bước nhảy ta nhảy tiếp một khoảng cũng là một hàm mũ. Trong trường hợp, khóa cần tìm nhỏ hơn phần tử tại bước nhảy, ta quay lại bước trước đó và thực hiện phép tìm kiếm tuyến tính thuần túy. Thuật toán được mô tả chi tiết trong Hình 3.12.

### Biểu diễn thuật toán![](images/image4.png)

**Hình 3.12**. Thuật toán Jumping Search.

### Độ phức tạp thuật toán

Độ phức tạp thuật toán trong trường hợp tốt, xấu nhất là 𝑂(√𝑛). Trường hợp tốt nhất là O(log(n)), với n là số lượng phần tử của dãy A[].

### Kiểm nghiệm thuật toán

Giả sử ta cần tìm vị trí của x = 55 trong dãy số A[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, 233, 377, 610}. Khi đó, thuật toán được thực hiện như sau:
**Bước 1**. Ta tìm được step=4. So sánh 53 với vị trí số A[3]=2<55.
**Bước 2**. Dịch chuyển step = 8, so sánh 53 với vị trí số A[7]=13<55\. **Bước 3**. Dịch chuyển step = 16, so sánh 53 với vị trí số A[15]=610>55\. **Bước 4**. Vì 610>55 nên ta trở về bước trước đó cộng thêm 1 là 9.
**Bước 5**. Tìm kiếm tuyến tính từ vị trí 9 đến 15 ta nhận được kết quả là 10.

### **Cài đặt thuật toán**

#include <iostream> #include <cmath>
using namespace std;
int JumpSearch(int A[], int n, int x){ // _thuật toán Jumping Search_
int step = (int) sqrt(n); // _giá trị bước nhảy_
int prev = 0; // _giá trị bước nhảy trước_
int r = min(step,n)-1;//vị trí cần so sánh while (A[r]<x) {// _lặp trong khi A[r] <x_
prev = step; // _lưu lại giá trị bước trước_
step += (int)sqrt(n);// _tăng bước nhảy_
if (prev >= n) // _nếu điều này xảy ra_

return -1; // _x chắc chắn không có trong A[]_

r = min(step,n)-1; / _/tính toán lại vị trí cần so sánh_

}
while (A[prev] < x){// _tìm kiếm tuyến tính thông thường_
prev++;
if (prev == min(step, n)) return -1;
}
if (A[prev] == x) // _nếu tìm thấy x_
return prev;
return -1;// _không tìm thấy x_

}

int main(void){
int A[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21,
34, 55, 89, 144, 233, 377, 610};
int x = 233, n = sizeof(A)/sizeof(A[0]); int index = JumpSearch(A, n,x);
if (index!=-1) cout<<"\n Vị trí:"<<index; else cout<<"\n Không tìm thấy x";
}

# Public_056

Như đã trình bày trong Chương 1, một kiểu dữ liệu trừu tượng (ADTs) được xác định khi ta xây dựng đầy đủ hai phần: cấu trúc dữ liệu cùng các phép toán trên cấu trúc dữ liệu đó. Nội dung của chương này trình bày ba kiểu dữ liệu trừu tượng quan trọng đó là danh sách liên kết, ngăn xếp và hàng đợi. Mỗi kiểu dữ liệu trừu tượng được xây dựng giải quyết lớp các vấn đề cụ thể của khoa học máy tính. Đối với người học, mỗi cấu trúc dữ liệu trừu tượng cần làm chủ được bốn điểm quan trọng sau:

  * Định nghĩa cấu trúc dữ liệu ADTs.

  * Biểu diễn cấu trúc dữ liệu ADTs.

  * Thao tác (phép toán) trên cấu trúc dữ liệu ADTs.

  * Ứng dụng của cấu trúc dữ liệu ADTs.


# Danh sách liên kết đơn (Single Linked List)

Như ta đã biết mảng ( _array_ ) là tập có thứ tự các phần tử có cùng chung một kiểu dữ liệu và được tổ chức liên tục nhau trong bộ nhớ. Ưu điểm lớn nhất của mảng là đơn giản và xử lý nhanh nhờ cơ chế truy cập phần tử trực tiếp vào các phần tử của mảng. Hạn chế lớn nhất của mảng là số lượng phần tử không thay đổi gây nên hiện tượng thừa bộ nhớ trong một số trường hợp và thiếu bộ nhớ trong một số trường hợp khác. Đối với một số bài toán có dữ liệu lớn, nhiều khi ta không đủ không gian nhớ tự do liên tục để cấp phát cho mảng. Để khắc phục hạn chế này ta có thể xây dựng kiểu dữ liệu danh sách liên kết đơn được định nghĩa, biểu diễn và thao tác như dưới đây.

## Định nghĩa danh sách liên kết đơn

Tập hợp các node thông tin được tổ chức rời rạc trong bộ nhớ. Trong đó, mỗi node gồm có hai thành phần:

  * Thành phần dữ liệu ( _data_ ): dùng để lưu trữ thông tin của node.

  * Thành phần con trỏ ( _pointer_ ): dùng để liên kết với node dữ liệu tiếp theo.


## Biểu diễn danh sách liên kết đơn

Để biểu diễn danh sách liên kết đơn ta sử dụng phương pháp định nghĩa cấu trúc tự trỏ của các ngôn ngữ lập trình. Giả sử thành phần thông tin của mỗi node được định nghĩa như một cấu trúc Item như sau:

struct Item {
<Kiểu 1> <Thành viên 1>;
<Kiểu 2> <Thành viên 2>;
……………………………;
<Kiểu N> <Thành viên N>;
};
Khi đó, danh sách liên kết đơn được định nghĩa như sau: struct node {
Item infor; // _Thành phần thông tin của node;_
struct node *next; // _thành phần con trỏ của node_
} *Start; // _Start là một danh sách liên kết đơn_

![](images/image1.png)

**Hình 3.1. Biểu diễn danh sách liên kết đơn**

## Thao tác trên danh sách liên kết đơn

Các thao tác trên danh sách liên kết đơn bao gồm:

  * Tạo node rời rạc có giá trị value cho danh sách liên kết đơn

  * Thêm một node vào đầu danh sách liên kết đơn.

  * Thêm một node vào cuối danh sách liên kết đơn.

  * Thêm node vào vị trí xác định trong danh sách liên kết đơn.

  * Loại node trong sách liên kết đơn.

  * Tìm node trong sách liên kết đơn.

  * Sắp xếp node trong danh sách liên kết đơn.

  * Sửa đổi nội dung node trong sách liên kết đơn.

  * Đảo ngược các node trong danh sách liên kết đơn.

  * Duyệt các node của danh sách liên kết đơn.


Để đơn giản, ta xem thành phần thông tin của node (Item) là một số nguyên. Khi đó, các thao tác trên danh sách liên kết đơn ta định nghĩa một lớp các thao tác như sau:

struct node { // _biểu diễn node_
int info; // _thành phần thông tin của node_
struct node *next; // _thành phần con trỏ của node_
}*start; // _danh sách liên kết đơn: *start._
class single_linked_list { // _biểu diễn lớp danh sách liên kết đơn_
public:
node* create_node(int);// _Tạo một node cho danh sách liên kết đơn_
void insert_begin(); // _thêm node vào đầu DSLKĐ_
void insert_pos(); // _thêm node tại vị trí cụ thể trên DSLKĐ_
void insert_last(); // _thêm node vào cuối DSLKĐ_
void delete_pos(); // _loại node tại vị trí cho trước trên DSLKĐ_
void sort(); // _sắp xếp nội dung các node theo thứ tự tăng dần_
void search(); // _tìm kiếm node trên DSLKĐ_
void update(); // _sửa đổi thông tin của node trên DSLKĐ_
void reverse(); // _đảo ngược danh sách liên kết đơn_
void display(); // _hiển thị nội dung DSLKĐ_
single_linked_list(){// _constructor của lớp single linked list_. start = NULL;// _chú ý start là biến toàn cục_
}
};

**Thao tác:** _tạo một node rời rạc có giá trị value cho DSLKĐ_ **.**

node *single_linked_list::create_node(int value){
struct node *temp; // _khai báo hai con trỏ node *temp_ temp = new(struct node); // _cấp phát miền nhớ cho temp_ if (temp == NULL){ // _nếu không đủ không gian nhớ_
cout<<“ _không đủ bộ nhớ để cấp phát_ "<<endl; return 0;
else {
temp->info = value;// _thiết lập thông tin cho node temp_
temp->next = NULL; // _thiết lập liên kết cho node temp_
return temp;// _trả lại node temp đã được thiết lập_
}

}

**Thao tác: _thêm node vào đầu DSLKĐ_.**

void single_linked_list::insert_begin(){ // _chèn node vào đầu DSLKĐ_
int value; cout<<“Nhập giá trị node:"; cin>>value; // _giá trị node cần chèn_
struct node *temp, *p; // _sử dụng hai con trỏ temp và p_
temp = create_node(value);// _tạo một node rời rạc có giá trị value_
if (start == NULL){ // _nếu danh sách liên kết rỗng_
start = temp; // _danh sách liên kết chính là node temp_
start->next = NULL; // _không có liêt kết với node khác_
}
else { // _nếu danh sách không rỗng_
p = start; // _p trỏ đến node đầu của start_
start = temp; // _node temp trở thành node đầu tiên của start_
start->next = p;// _các node còn lại chính là p_
}
}

Hình 3.2. dưới đây mô tả phép thêm node vào đầu danh sách liên kết đơn.

![](images/image2.png)

**Hình 3.2. Thêm node vào đầu danh sách liên kết đơn**

**Thao tác thêm node vào cuối danh sách liên kết đơn** :

void single_linked_list::insert_last() **{** // _thêm node vào cuối DSLKĐ_

int value;
cout<<“Nhập giá trị cho node: ";cin>>value; // _nhập giá trị node_
struct node *temp, *s; // _sử dung hai con trỏ temp và s_
temp = create_node(value);// _tạo node rời rạc có giá trị value_
if(start==NULL) {// _trường hợp DSLKĐ rỗng_
start = temp;
temp->next=NULL;
}
s = start; // _s trỏ đến node đầu danh sách_
while (s->next != NULL){ // _di chuyển s đến node cuối cùng_
s = s->next;
}
temp->next = NULL; // _temp không chỏ đi đâu nữa_ s->next = temp; // _thiết lập liên kết cho s_ cout<<“ _Hoàn thành thêm node vào cuối_ "<<endl;

}

![](images/image3.png)

**Hình 3.3. Thêm node vào cuối danh sách liên kết đơn**

**Thao tác thêm node vào vị trí pos của danh sách liên kết đơn** :

void single_linked_list::insert_pos() **{** // _thêm node vào vị trí pos_

int value, pos, counter = 0; cout<<"Nhap gia tri node:";cin>>value; struct node *temp, *s, *ptr; // _sử dụng ba con trỏ node_
temp = create_node(value);// _tạo node rời rạc có giá trị value_
cout<<“Nhập vị trí node cần thêm: ";cin>>pos; int i; s = start; // _s trỏ đến node đầu tiên_
while (s != NULL){ // _đếm số node của DSLKĐ_
s = s->next; counter++;

}

if (counter==0) {// _trường hợp DSLK đơn rỗng_
cout<<”Danh sách rỗng”; return;
}
if (pos == 1){ // _nếu pos là vị trí đầu tiên_

if (start == NULL){ // _trường hợp DSLKĐ rỗng_

start = temp; start->next = NULL;

}
else { // _thêm node temp vào đầu DSLKĐ_
ptr = start; start = temp; start->next = ptr;
}
}
else if (pos > 1 && pos <= counter){ // _trường hợp pos hợp lệ_
s = start; // _s trỏ đến node đầu tiên_
for (i = 1; i < pos; i++){ // _di chuyển đến node pos-1_
ptr = s; s = s->next;
}
ptr->next = temp; temp->next = s; // _thiết lập liên kết cho node_
}
else { cout<<“ _Vượt quá giới hạn DSLKĐ_ "<<endl; }

}

![](images/image4.png)

**Hình 3.4. Thêm node vào vị trí pos**

**Thao tác loại node tại vị trí pos** :

void single_linked_list::delete_pos() **{** // _loại node ở vị trí pos_

int pos, i, counter = 0;
if (start == NULL){ // _nếu danh sách liê kết đơn rỗng_
cout<<“Không thực hiện được"<<endl; return;
}
cout<<“ _Vị trí cần loại bỏ_ :";cin>>pos;
struct node *s, *ptr; s = start; // _s trỏ đến đầu danh sách_
if (pos == 1){// _nếu vị trí loại bỏ là node đầu tiên_
start = s->next; s->next=NULL; free(s);}
else {
while (s != NULL) { // _đếm số node của DSLKĐ_
s = s->next; counter++;}
if (pos > 0 && pos <= counter){ // _nếu vị trí pos hợp lệ_
s = start;// _s trỏ đến node đầu của danh sách_
for (i = 1;i < pos; i++){ // _di chuyển đến vị trí pos-1_
ptr = s; s = s->next;
}
ptr->next = s->next; // _thiết lập liên kết cho node_
}
else { cout<<"Vi tri ngoai danh sach"<<endl; } free(s); // _giải phóng s_
cout<<"Node da bi loai bo"<<endl;
}

}

![](images/image5.png)

**Hình 3.5. Thao tác loại node ở vị trí pos**

**Thao tác sửa đổi nội dung của node** :

void single_linked_list::update() **{** // _sửa đổi thông tin của node_

int value, pos, i;
if (start == NULL){ // _nếu danh sách LKĐ rỗng_
cout<<“ _Không thực hiện được_ "<<endl; return;
}
cout<<“Nhập vị trí node cần sửa:";cin>>pos; cout<<“ _Giá trị mới của node_ :";cin>>value; struct node *s, *ptr; // _sử dụng hai con trỏ s và ptr_ s = start; // _s trỏ đến node đầu tiên_
if (pos == 1) { start->info = value;} // _sửa luôn node đầu tiên_
else { // _nếu pos không phải là node đầu tiên_
for (i = 0;i < pos - 1;i++){// _chuyển s đến vị trí pos-1_
if (s == NULL){// _Nếu s là node cuối cùng_
cout<<"Vị trí "<<pos<<" _không hợp lệ_ “; return;
}
s = s->next;
}
s->info = value; // _Sửa đổi thông tin cho node_
}
cout<<“ _Hoàn thành việc sửa đổi_ "<<endl;

}

**Thao tác duyệt danh sách liên kết đơn** :

void single_linked_list::display() **{** // _hiển thị nội dung DSLKĐ_

struct node *temp; // _sử dụng một con trỏ temp_
if (start == NULL){ // _nếu danh sách rỗng_ cout<<“ _Có gì đâu mà hiển thị_ "<<endl; return;
}
temp = start; // _temp trỏ đến node đầu trong DSLKĐ_
cout<<“ _Nội dung DSLKĐ_ : "<<endl;
while (temp != NULL) { // _lặp cho đến node cuối cùng_ cout<<temp->info<<"->"; // _hiển thị thông tin node_ temp = temp->next; // _di chuyển đến node tiếp theo_
}
cout<<" _NULL_ "<<endl; // _node cuối cùng là NULL_

}

**Thao tác tìm node trong danh sách liên kết đơn** :

_**void single_linked_list::search(){**_ // _Tìm kiếm node_

int value, pos = 0; bool flag = false;
if (start == NULL){// _nếu danh sách rỗng_ cout<<“ _ta không có gì để tìm_ "<<endl; return;
}
cout<<“ _Nội dung node cần tìm_ :";cin>>value; struct node *s; s = start;// _s trỏ đến đầu danh sách_ while (s != NULL){ pos++;
if (s->info == value){// _Nếu s- >infor là value_
flag = true;
cout<<“ _Tìm thấy_ "<<value<<" _tại vị trí_ "<<pos<<endl;
}
s = s->next;
}
if (!flag) {// _đến cuối vẫn không thấy_
cout<<“ _Giá trị_ "<<value<<“ _không tồn tại_ "<<endl;
}

}

**Thao tác sắp xếp các node trong danh sách liên kết đơn** : void single_linked_list::sort() **{** // _sắp xếp theo nội dung các node_

struct node *ptr, *s; // _sử dụng hai con trỏ ptr và s_
int value; // _giá trị trung gian_
if (start == NULL){// _nếu danh sách rỗng_ cout<<“ _không có gì để sắp xếp_ "<<endl; return;
}
ptr = start;// _ptr trỏ đến node đầu danh sách_
while (ptr != NULL){ // _lặp trong khi ptr khác rỗng_
for (s = ptr->next; s !=NULL; s = s->next){ // _s là node tiếp theo_
if (ptr->info > s->info){// _nếu điều này xảy ra_
value = ptr->info;// _tráo đổi nội dung hai node_
ptr->info = s->info; s->info = value;
}
}
ptr = ptr->next;
}

}

**Thao tác đảo ngược các node của DSLKĐ** :

void single_linked_list::reverse() **{** // _đảo ngược danh sách_

struct node *ptr1, *ptr2, *ptr3; // _sử dụng ba con trỏ node_
if (start == NULL) {// _Nếu danh sách rỗng_
cout<<“ _ta không cần đảo_ "<<endl; return;
}
if (start->next == NULL){//Nếu danh sách chỉ có một node cout<<“ _đảo ngược là chính nó_ "<<endl; return;
}
ptr1 = start; // _ptr1 trỏ đến node đầu tiên_
ptr2 = ptr1->next;// _ptr2 trỏ đến node kế tiếp của ptr1_ ptr3 = ptr2->next;// _ptr3 trỏ đến nod kế tiếp của ptr2_ ptr1->next = NULL;// _Ngắt liên kết ptr1_
ptr2->next = ptr1;// _node ptr2 bây giờ đứng trước node ptr1_
while (ptr3 != NULL){// _Lặp nếu ptr3 khác rỗng_ ptr1 = ptr2; // _ptr1 lại bắt đầu tại vị trí ptr2_ ptr2 = ptr3; // _ptr2 bắt đầu tại vị trí ptr3_
ptr3 = ptr3->next; // _ptr3 trỏ đến node kế tiếp_
ptr2->next = ptr1; // _Thiết lập liên kết cho ptr2_
}
start = ptr2; // _node đầu tiên bây giờ là ptr2_

}

**//Chương trình cài đặt các thao tác trên danh sách liên kết đơn:**

#include<iostream> using namespace std;

struct node { // _biểu diễn danh sách liên kết đơn_

int info; // _thành phần thông tin_
struct node *next; // _thành phần liên kết_

}*start;

class single_linked_list { // _biểu diễn lớp single_linked_list_

public:
node* create_node(int);// _tạo node rời rạc có giá trị value_
void insert_begin();// _thêm node vào đầu danh sách liên kết đơn_
void insert_pos();// _thêm node vào vị trí pos trong danh sách liên kết đơn_
void insert_last();// _thêm node vào cuối danh sách liên kết đơn_ void delete_pos();// _loại node tại vị trí pos của sách liên kết đơn_ void sort();// _sắp xếp theo giá trị node cho danh sách liên kết đơn_ void search();// _tìm node trong danh sách liên kết đơn_
void update(); // _cập nhật thông tin cho node_
void reverse(); // _đảo ngược các node trong danh sách liên kết đơn_ void display(); // _duyệt danh sách liên kết đơn_ single_linked_list(){// _constructor của lớp_
start = NULL;
}

};

# Public_057

Đồ thị là một cấu trúc dữ liệu rời rạc bao gồm các đỉnh và các cạnh nối các cặp đỉnh này. Với quan niệm như trên, một mạng máy tính được xem như một đồ thị có mỗi đỉnh là một máy tính, có các cạnh là một liên kết giữa các máy tính khác nhau trong mạng. Các mạch điện, các hệ thống giao thông, các mạng xã hội đều được xem xét như một đồ thị. Có thể nói đồ thị được ứng dụng rộng rãi trong nhiều lĩnh vực khác nhau của khoa học máy tính. Nội dung chính của chương này đề cập đến phương pháp biểu diễn và các thuật toán trên đồ thị.

# Định nghĩa và khái niệm

Ta có thể phân chia đồ thị thành hai loại: đồ thị vô hướng (directed graph) và đồ thị có hướng (directed graph). Mỗi loại đồ thị lại được chia thành 3 loại: đơn đồ thị, đa đồ thị và giả đồ thị. Mỗi loại đồ thị có các thuật ngữ chung và những khái niệm riêng. Dưới đây là một số thuật ngữ cơ bản trên các loại đồ thị.

## Một số thuật ngữ cơ bản trên đồ thị

**Định nghĩa**. Bộ đô _G_ =< _V_ , _E_ >, trong đó _V_ = {1, 2 , .., n} là tập hợp hữu hạn được gọi là tập đỉnh, _E_ là tập có thứ tự hoặc không có thứ tự các cặp đỉnh trong V được gọi là tập cạnh.

**Đồ thị vô hướng**. Đồ thị G=<V, E> được gọi là đồ thị vô hướng nếu các cạnh thuộc E là các cặp không tính đến thứ tự các đỉnh trong V.

**Đơn đồ thị vô hướng**. Đồ thị G=<V, E> được gọi là đơn đồ thị vô hướng nếu G là đồ thị vô hướng và giữa hai đỉnh bất kỳ thuộc V có nhiều nhất một cạnh nối.

**Đa đồ thị vô hướng**. Đồ thị G=<V, E> được gọi là đơn đồ thị vô hướng nếu là đồ thị vô hướng và tồn tại một cặp đỉnh trong V có nhiều hơn một cạnh nối. Cạnh e1∈E, e2∈E được gọi là cạnh bội nếu chúng cùng chung cặp đỉnh.

**Giả đồ thị vô hướng.** Đồ thị G = <V, E> bao gồm V là tập đỉnh, E là họ các cặp không có thứ tự gồm hai phần tử (hai phần tử không nhất thiết phải khác nhau) trong V được gọi là các cạnh. Cạnh e được gọi là khuyên nếu có dạng e =(u, u), trong đó u là đỉnh nào đó thuộc V.

**Đơn đồ thị có hướng**. Đồ thị G = <V, E> bao gồm V là tập các đỉnh, E là tập các cặp có thứ tự gồm hai phần tử của V gọi là các cung. Giữa hai đỉnh bất kỳ của G tồn tại nhiều nhất một cung.

**Đa đồ thị có hướng**. Đồ thị G = <V, E> bao gồm V là tập đỉnh, E là cặp có thứ tự gồm hai phần tử của V được gọi là các cung. Hai cung e1, e2 tương ứng với cùng một cặp đỉnh được gọi là cung lặp.

**Giả đồ thị có hướng.** Đa đồ thị G = <V, E>, trong đó V là tập đỉnh, E là tập các cặp không có thứ tự gồm hai phần tử (hai phần tử không nhất thiết phải khác nhau) trong V được gọi là các cung. Cung e được gọi là khuyên nếu có dạng e =(u, u), trong đó u là đỉnh nào đó thuộc V.

## Một số thuật ngữ trên đồ thị vô hướng

**Đỉnh kề**. Hai đỉnh _u_ và _v_ của đồ thị vô hướng _G = <V, E>_ được gọi là kề nhau nếu ( _u,v_ ) là cạnh thuộc đồ thị _G_. Nếu _e =_ ( _u, v_ ) là cạnh của đồ thị _G_ thì ta nói cạnh này liên thuộc với hai đỉnh _u_ và _v_ , hoặc ta nói cạnh _e_ nối đỉnh _u_ với đỉnh _v_ , đồng thời các đỉnh _u_ và _v_ sẽ được gọi là đỉnh đầu của cạnh ( _u,v_ ).

**Bậc của đỉnh**. Ta gọi bậc của đỉnh _v_ trong đồ thị vô hướng là số cạnh liên thuộc với nó và ký hiệu là _deg_ ( _v_ ). Đỉnh có bậc là 0 được gọi là đỉnh cô lập. Đỉnh có đỉnh bậc 1 được gọi là đỉnh treo.

**Đường đi, chu trình**. Đường đi độ dài _n_ từ đỉnh _u_ đến đỉnh _v_ trên đồ thị vô hướng _G= <V, E>_ là dãy _x0, x1, . . ., xn-1, xn ,_ trong đó _n_ là số nguyên dương, _x0=u_ , _xn=v, (xi, xi+1)_ ∈ _E, i =0, 1, 2, . . ., n-1_. Đường đi có đỉnh đầu trùng với đỉnh cuối gọi là chu trình.

**Tính liên thông**. Đồ thị vô hướng được gọi là liên thông nếu luôn tìm được đường đi giữa hai đỉnh bất kỳ của nó.

**Thành phần liên thông**. Đồ thị vô hướng liên thông thì số thành phần liên thông là 1. Đồ thị vô hướng không liên thông thì số liên thông của đồ thị là số các đồ thị con của nó liên thông.

**Đỉnh trụ**. Đỉnh u∈V được gọi là đỉnh trụ nếu loại bỏ u cùng với các cạnh nối với u làm tăng thành phần liên thông của đồ thị.

**Cạnh cầu**. Cạnh (u,v) ∈E được gọi là cầu nếu loại bỏ (u,v) làm tăng thành phần liên thông của đồ thị.

**Đỉnh rẽ nhánh**. Đỉnh s được gọi là đỉnh rẽ nhánh (đỉnh thắt) của cặp đỉnh u, v nếu mọi đường đi từ u đến v đều qua s.

## Một số thuật ngữ trên đồ thị có hướng

**Đỉnh kề**. Nếu _e=_ ( _u,v_ ) là cung của đồ thị có hướng _G_ thì ta nói hai đỉnh _u_ và _v_ là kề nhau, và nói cung ( _u, v_ ) nối đỉnh _u_ với đỉnh _v,_ hoặc nói cung này đi ra khỏi đỉnh _u_ và đi vào đỉnh _v_. Đỉnh _u_ được gọi là đỉnh đầu, đỉnh _v_ được gọi là đỉnh cuối của cung ( _u,v_ ).

**Bán bậc của đỉnh**. Ta gọi bán bậc ra của đỉnh _v_ trên đồ thị có hướng là số cung của đồ thị đi ra khỏi _v_ và ký hiệu là _deg +_( _v_ ). Ta gọi bán bậc vào của đỉnh _v_ trên đồ thị có hướng là số cung của đồ thị đi vào _v_ và ký hiệu là _deg -_( _v_ ).

**Đường đi**. Đường đi độ dài _n_ từ đỉnh _u_ đến đỉnh _v_ trong đồ thị có hướng

_G= <V,A>_ là dãy _x0, x1, . . ., xn ,_ trong đó, _n_ là số nguyên dương, _u = x0, v = xn, (xi, xi+1)_

∈ _E._ Đường đi như trên có thể biểu diễn thành dãy các cung : _(x0, x1), (x1, x2), . . ., (xn-1, xn)._ Đỉnh _u_ được gọi là đỉnh đầu, đỉnh _v_ được gọi là đỉnh cuối của đường đi. Đường đi có đỉnh đầu trùng với đỉnh cuối ( _u=v_ ) được gọi là một chu trình. Đường đi hay chu trình được gọi là đơn nếu như không có hai cạnh nào lặp lại.

**Liên thông mạnh**. Đồ thị có hướng G=<V, E> được gọi là liên thông mạnh nếu giữa hai đỉnh bất kỳ u∈V, v∈V đều có đường đi từ u đến v.

**Liên thông yếu**. Ta gọi đồ thị vô hướng tương ứng với đồ thị có hướng G=<V, E> là đồ thị tạo bởi G và bỏ hướng của các cạnh trong G. Khi đó, đồ thị có hướng G=<V, E> được gọi là liên thông yếu nếu đồ thị vô hướng tương ứng với nó là liên thông.

**Thành phần liên thông mạnh**. Đồ thị con có hướng H =<V1, E1> được gọi là một thành phần liên thông mạnh của đồ thị có hướng G=<V, E> nếu V1⊆V, E1⊆E và H liên thông mạnh.

## Một số loại đồ thị đặc biệt

Dưới đây là một số dang đơn đồ thị vô hướng đặc biệt có nhiều ứng dụng khác nhau của thực tế.

**Đồ thị đầy đủ**. Đồ thị đầy đủ n đỉnh, ký hiệu là Kn, là đơn đồ thị vô hướng mà giữa hai đỉnh bất kỳ của nó đều có cạnh nối. Ví dụ đồ thị K3, K4, K5 trong Hình 5.1a.

**Đồ thị vòng**. Đồ thị vòng Cn (n≥3) có các cạnh (1,2), (2,3),..,(n-1,n), (n,1). Ví dụ đồ thị C3, C4, C5 trong Hình 5.1.b.

**Đồ thị bánh xe**. Đồ thị bánh xe Wn thu được bằng cách bổ sung một đỉnh nối với tất cả các đỉnh của Cn. Ví dụ đồ thị W3, W4, W5 trong Hình 5.1.c.

**Đồ thị hai phía**. Đồ thị G =<V, E> được gọi là đồ thị hai phía nếu tập đỉnh V của nó có thể phân hoạch thành hai tập X và Y sao cho mỗi cạnh của đồ thị chỉ có dạng ( _x_ , _y_ ), trong đó _x_ ∈ _X_ và _y_ ∈ _Y_. Ví dụ đồ thị K2,3, K33, K3,5 trong Hình 5.1.d.

![](images/image1.png)

**Hình 5.1**. Một số dạng đồ thị đặc biệt.

# Biểu diễn đồ thị

Để lưu trữ, xử lý hiệu quả ta cần có phương pháp biểu diễn đồ thị trên máy tính. Ba phương pháp biểu diễn thông dụng thường được ứng dụng trên đồ thị đó là: ma trận kề, danh sách cạnh và danh sách kề. Phương pháp biểu diễn cụ thể được thể hiện như dưới đây.

## Biểu diễn bằng ma trận kề

Phương pháp biểu diễn đồ thị bằng ma trận kề là phép làm tương ứng đồ thị G = <V, E> với một ma trận vuông cấp n. Các phần tử của ma trận kề được xác định như dưới đây.
$auv=I{(u,v)∈E}a_{uv} = I{(u,v) in E}$
Ví dụ với đồ thị cho bởi Hình 5.2 sẽ cho ta biểu diễn ma trận kề như sau:![](images/image2.png)![](images/image3.png)
**Hình 5.2**. Biểu diễn ma trận kề của đồ thị.

### Tính chất của ma trận kề:

  * Ma trận kề biểu diễn đồ thị vô hướng G = <V, E> là ma trận đối xứng.

  * Ma trận kề biểu diễn đồ thị có hướng G =<V, E> thường là không đối xứng.

  * Tổng các phần tử của ma trận kề biểu diễn đồ thị vô hướng G = <V, E> bằng _2.m_ , trong đó _m_ là số cạnh của đồ thị.

  * Tổng các phần tử của ma trận kề biểu diễn đồ thị có hướng G = <V, E> bằng đúng _m_ , trong đó _m_ là số cạnh của đồ thị.

  * Tổng các phần tử của hàng _u_ hoặc cột _u_ của ma trận kề biểu diễn đồ thị vô hướng G= <V, E> là bậc của đỉnh u (deg(u)).

  * Tổng các phần tử của hàng _u_ của ma trận kề biểu diễn đồ thị có hướng G= <V, E> là bán bậc ra của đỉnh u (deg+(u)).

  * Tổng các phần tử của cột _u_ của ma trận kề biểu diễn đồ thị có hướng G= <V, E> là bán bậc vào của đỉnh u (deg-(u)).


### Ưu điểm của ma trận kề:

  * Đơn giản dễ cài đặt trên máy tính bằng cách sử dụng một mảng hai chiều.

  * Dễ dàng kiểm tra được hai đỉnh _u, v_ có kề với nhau hay không bằng đúng một phép so sánh (a[u][v]≠0).


### Nhược điểm của ma trận kề:

  * Lãng phí bộ nhớ: bất kể số cạnh nhiều hay ít ta cần n2 đơn vị bộ nhớ để biểu diễn.

  * Không thể biểu diễn được với các đồ thị có số đỉnh lớn .

  * Để xem xét đỉnh đỉnh _u_ có những đỉnh kề nào cần mất n phép so sánh kể cả đỉnh u là đỉnh cô lập hoặc đỉnh treo.


## Biểu diễn đồ thị bằng danh sách cạnh

Phương pháp biểu diễn đồ thị G =<V, E> bằng cách liệt kê tất cả các cạnh của nó được gọi là phương pháp biểu diễn bằng danh sách cạnh. Đối với đồ thị có hướng ta liệt kê các cung tương ứng. Đối với đồ thị vô hướng ta chỉ cần liệt kê các cạnh (u,v)∈E mà không cần liệt kê các cạnh (v,u)∈E. Ví dụ về biểu diễn đồ thị bằng danh sách cạnh được cho trong Hình 5.3.![](images/image4.png)

**Hình 5.3**. Biểu diễn đồ thị bằng danh sách cạnh

### Tính chất của danh sách cạnh:

  * Đỉnh đầu luôn nhỏ hơn đỉnh cuối của mỗi cạnh đối với đồ thị vô hướng.

  * Đỉnh đầu không phải lúc nào cũng nhỏ hơn đỉnh cuối của mỗi cạnh đối với đồ thị có hướng.

  * Số các số có giá trị _u_ thuộc cả tập đỉnh đầu và tập đỉnh cuối các cạnh là bậc của đỉnh u đối với đồ thị vô hướng.

  * Số các số có giá trị _u_ thuộc cả tập đỉnh đầu các cạnh là bán bậc ra của đỉnh u đối với đồ thị có hướng.

  * Số các số có giá trị _u_ thuộc cả tập đỉnh cuối là bán bậc vào của đỉnh _u_ đối với đồ thị có hướng.


### Ưu điểm của danh sách cạnh:

  * Trong trường hợp đồ thị thưa (m<6n), biểu diễn bằng danh sách cạnh tiết kiệm được không gian nhớ.

  * Thuận lợi cho một số thuật toán chỉ quan tâm đến các cạnh của đồ thị.


### Nhược điểm của danh sách cạnh:

  * Khi cần duyệt các đỉnh kề với đỉnh u bắt buộc phải duyệt tất cả các cạnh của đồ thị. Điều này làm cho thuật toán có chi phí tính toán cao.


## Biểu diễn đồ thị bằng danh sách kề

Ta định nghĩa 𝐿𝑖𝑠𝑡(𝑢) = {𝑣 ∈ 𝑉: (𝑢, 𝑣) ∈ 𝐸} là danh sách các đỉnh kề với đỉnh _u_. Biểu diễn đồ thị bằng danh sách kề là phương pháp liệt kê tập đỉnh kề của mỗi đỉnh. Ví dụ về biểu diễn đồ thị bằng danh sách kề được cho trong Hình 5.4.

![](images/image5.png)
**Hình 5.4**. Biểu diễn đồ thị bằng danh sách kề.

### Tính chất của danh sách kề:

  * Lực lượng tập đỉnh kề của đỉnh _u_ là bậc của đỉnh _u_ đối với đồ thị vô hướng (deg( _u_ )=|List( _u_ )|.

  * Lực lượng tập đỉnh kề của đỉnh _u_ là bán bậc ra của đỉnh _u_ đối với đồ thị có hướng (deg+( _u_ )=|List( _u_ )|.

  * Số các số có giá trị _u_ thuộc tất cả các danh sách kề là bán bậc vào của đỉnh _u_


đối với đồ thị có hướng.

### Ưu điểm của danh sách kề:

  * Dễ dàng duyệt tất cả các đỉnh của một danh sách kề.

  * Dễ dàng duyệt các cạnh của đồ thị trong mỗi danh sách kề.

  * Tối ưu việc cài đặt một số giải thuật trên đồ thị.


### Nhược điểm của danh sách kề:

  * Khó khăn cho người học có kỹ năng lập trình yếu vì khi biểu diễn đồ thị ta phải dùng một mảng, mỗi phần tử của nó là một danh sách liên kết.

# Public_058

# Mô tả bài toán kiểm thử qua biểu đồ Venn

Kiểm thử chủ yếu liên quan tới hành vi của chương trình nơi mà hành vi phản ánh quan điểm về cấu trúc phổ biến đối với các nhà phát triển hệ thống hoặc phần mềm. Sự khác biệt là quan điểm cấu trúc tập trung vào “là cái gì”, còn quan điểm hành vi lại tập trung vào “làm gì”. Một trong những nguyên nhân gây khó cho người kiểm thử là các tài liệu cơ sở thường được viết bởi và viết cho người phát triển. Kết quả là các tài liệu này thường thiên về thông tin cấu trúc và coi nhẹ thông tin về hành vi của chương trình cần kiểm thử. Trong mục này, chúng ta sẽ phát triển một biểu đồ Venn đơn giản nhằm làm sáng tỏ một số vấn đề về kiểm thử. Chi tiết về biểu đồ Venn sẽ được trình bày trong chương 3.

![](images/image1.png)

**Hình 1.3: Các hành vi được cài đặt và được đặc tả.**

Xét một vũ trụ của hành vi chương trình cần kiểm thử, lưu ý rằng chúng ta đang quan tâm đến bản chất của việc kiểm thử. Cho trước một chương trình cùng đặc tả của nó. Gọi _S_ là tập các hành vi được đặc tả và _P_ là tập các hành vi của chương trình. Hình 1.3 mô tả mối quan hệ giữa vũ trụ các hành vi được lập trình và hành vi được đặc tả. Trong tất cả các hành vi có thể của chương trình, những hành vi được đặc tả nằm trong vòng tròn với nhãn _S_ , còn những hành vi được lập trình là ở trong vòng tròn với nhãn _P_ . Từ biểu đồ này, ta thấy rõ các bài toán mà người kiểm thử cần đối mặt là gì. Nếu có hành vi được đặc tả nhưng không được lập trình thì theo thuật ngữ trước đây, đấy là những sai lầm về bỏ quên. Tương tự, nếu có những hành vi được lập trình nhưng không được đặc tả, thì điều đó tương ứng với những sai lầm về nhiệm vụ, và chúng tương ứng với những lỗi xuất hiện sau khi đặc tả đã hoàn thành. Tương giao giữa _S_ và _P_ là phần đúng đắn, gồm có các hành vi vừa được đặc tả vừa được cài đặt. Chú ý rằng tính đúng đắn chỉ có nghĩa đối với đặc tả và cài đặt và là khái niệm mang tính tương đối.

![](images/image2.png)

**Hình 1.4: Các hành vi được cài đặt, được đặc tả và được kiểm thử.**

Vòng tròn mới (vòng tròn _T_ ) trong hình 1.4 là cho các ca kiểm thử. Lưu ý rằng tập các hành vi của chương trình nằm trọn trong vũ trụ chuyên đề của ta. Ở đây một ca kiểm thử cũng được coi là xác định một hành vi. Xét mối quan hệ giữa _S, P_ và _T_ . Có thể có các hành vi được đặc tả mà không được kiểm thử (các miền 2 và 5), các hành vi được đặc tả và được kiểm thử (các miền 1 và 4), và các ca kiểm thử tương ứng với các hành vi không được đặc tả (các miền 3 và 7).

Tương tự, có thể có các hành vi được lập trình mà không được kiểm thử (các miền 2 và 6), các hành vi được lập trình và được kiểm thử (các miền 1 và 3), và các ca kiểm thử tương ứng với các hành vi không được lập trình (các miền 4 và 7). Việc xem xét tất cả các miền này là hết sức quan trọng. Nếu có các hành vi được đặc tả mà không có các ca kiểm thử tương ứng, việc kiểm thử là chưa đầy đủ. Nếu có các ca kiểm thử tương ứng với các hành vi không được đặc tả, có thể có hai khả năng: hoặc đặc tả còn thiếu hoặc ca kiểm thử không đảm bảo. Theo kinh nghiệm, một người kiểm thử giỏi sẽ thường phát triển các ca kiểm thử thuộc loại đầu, và đấy chính là lý do người kiểm thử cần tham gia vào giai đoạn khảo duyệt đặc tả và thiết kế (xem chương 4).

Ta có thể thấy việc kiểm thử như là công việc của một nghệ nhân: người kiểm thử có thể làm gì để làm cho miền tương giao của các tập (miền 1) là lớn nhất có thể? Làm thế nào để xác định các ca kiểm thử trong tập _T_ ? Câu trả lời là các ca kiểm thử cần được xác định bởi một phương pháp kiểm thử. Chính khuôn khổ này cho phép ta so sánh tính hiệu quả của các phương pháp kiểm thử khác nhau như sẽ được giới thiệu trong các chương 5, 6 và 7.

# Việc xác định các ca kiểm thử

Có hai cách tiếp cận cơ bản để xác định các ca kiểm thử là kiểm thử chức năng hay kiểm thử hộp đen (black-box testing) và kiểm thử cấu trúc hay kiểm thử hộp trắng (white-box testing). Mỗi cách tiếp cận có các phương pháp xác định các ca kiểm thử khác nhau và được gọi chung là các phương pháp kiểm thử.

## Kiểm thử chức năng

Kiểm thử chức năng (kiểm thử hộp đen) dựa trên quan niệm rằng bất kỳ chương trình nào cũng được coi là một hàm ánh xạ các giá trị từ miền dữ liệu đầu vào tới miền dữ liệu đầu ra của nó. Khái niệm này được dùng chung trong kỹ thuật khi các hệ thống đều được coi là các hộp đen. Chính điều này dẫn đến thuật ngữ kiểm thử hộp đen, trong đó nội dung của hộp đen (việc cài đặt) không được biết hoặc không cần quan tâm, và chức năng của hộp đen được hiểu theo các dữ liệu đầu vào và dữ liệu đầu ra của nó. Trong thực tế, chúng ta thường thao tác hiệu quả với những kiến thức về hộp đen. Chính điều này là trung tâm của khái niệm định hướng đối tượng. Chẳng hạn, hầu hết mọi người lái xe thành thạo với kiến thức hộp đen.

![](images/image3.png)

**Hình 1.5: Một hộp đen kỹ thuật.**

Với cách tiếp cận của kiểm thử chức năng, để xác định các ca kiểm thử, thông tin duy nhất được dùng là đặc tả của phần mềm cần kiểm thử. Có hai lợi điểm chính của các ca kiểm thử được sinh ra bởi cách tiếp cận kiểm thử chức năng: chúng độc lập với việc phần mềm được cài đặt thế nào, và vì thế khi cài đặt thay đổi thì các ca kiểm thử vẫn dùng được, đồng thời các ca kiểm thử được phát triển song song và độc lập với việc cài đặt hệ thống. Do đó, cách tiếp cận này rút gọn được thời gian phát triển của dự án. Điểm yếu của cách tiếp cận này là các ca kiểm thử thường có thể có tính dư thừa đáng kể trong các ca kiểm thử và vấn đề hố phân cách.

Hình 1.6 mô tả các ca kiểm thử được xác định bởi các phương pháp kiểm thử chức năng khác nhau. Phương pháp A xác định một tập các ca kiểm thử lớn hơn so với phương pháp B. Lưu ý rằng đối với cả hai phương pháp này, tập các ca kiểm thử đều chứa trọn trong tập các hành vi được đặc tả.

Do các phương pháp kiểm thử chức năng đều dựa trên các hành vi đặc tả, các phương pháp này khó có thể xác định được các hành vi không được đặc tả. Trong chương 5 ta sẽ so sánh các ca kiểm thử sinh bởi các phương pháp kiểm thử chức năng khác nhau cho các ví dụ được mô tả trong chương 2.

**Hình 1.6: So sánh các phương pháp xác định các ca kiểm thử chức năng.** ![](images/image4.png)

Trong chương 5, chúng ta sẽ khảo sát các cách tiếp cận chủ yếu cho các phương pháp kiểm thử chức năng bao gồm phân tích giá trị biên, kiểm thử tính bền vững, phân tích trường hợp xấu nhất, kiểm thử giá trị đặc biệt, kiểm thử phân lớp tương đương của miền dữ liệu đầu vào, lớp tương đương của miền dữ liệu đầu ra, kiểm thử dựa trên bảng quyết định. Điều xuyên suốt trong các kỹ thuật này là tất cả đều dựa trên thông tin xác định về các thành phần đang được kiểm thử. Cơ sở toán học trình bày trong chương 3 chủ yếu được áp dụng cho cách tiếp cận kiểm thử chức năng.

## Kiểm thử cấu trúc

Kiểm thử cấu trúc (kiểm thử hộp trắng) là cách tiếp cận khác để xác định các ca kiểm thử. Biểu tượng hộp trong suốt (hộp trắng) là thích hợp cho cách tiếp cận này vì sự khác nhau cốt lõi của cách tiếp cận này so với kiểm thử hộp đen là việc cài đặt của hộp đen (mã nguồn) được cung cấp và được dùng làm cơ sở để xác định các ca kiểm thử. Việc hiểu biết được bên trong của hộp đen cho phép người kiểm thử dựa trên việc cài đặt để xác định các ca kiểm thử. Kiểm thử cấu trúc đã trở thành chủ đề của một lý thuyết tương đối mạnh. Để hiểu rõ kiểm thử cấu trúc, các khái niệm về lý thuyết đồ thị tuyến tính được trình bày trong chương 3 là cần thiết. Với những khái niệm này, người kiểm thử có thể mô tả chính xác các yêu cầu kiểm thử và hệ thống cần kiểm thử. Do có cơ sở lý thuyết mạnh, kiểm thử cấu trúc cho phép định nghĩa chính xác và sử dụng các độ đo về độ bao phủ. Các độ đo về độ phủ cho phép khẳng định tường minh phần mềm đã được kiểm thử tới mức nào và do đó giúp cho việc quản lý quá trình kiểm thử tốt hơn.

**Hình 1.7: So sánh các phương pháp xác định ca kiểm thử đối với kiểm thử cấu trúc.** ![](images/image5.png)

Hình 1.7 phản ánh các ca kiểm thử được xác định bởi hai phương pháp kiểm thử cấu trúc khác nhau. Giống như trước đây, phương pháp A xác định tập các ca kiểm thử lớn hơn so với phương pháp B. Có chắc là tập các ca kiểm thử lớn hơn là tốt hơn không? Đây là một câu hỏi thú vị và kiểm thử cấu trúc cung cấp các giải pháp để tìm câu trả lời cho vấn đề này.

Lưu ý rằng cả hai phương pháp A và B đều cho các tập các ca kiểm thử nằm trọn trong tập các hành vi được lập trình. Do các ca kiểm thử của các phương pháp này được sinh ra dựa trên chương trình nên rất khó để xác định các lỗi liên quan đến các hành vi đã được đặc tả nhưng không được lập trình. Tuy nhiên, dễ thấy rằng tập các ca kiểm thử cấu trúc là tương đối nhỏ so với tập tất cả các hành vi được lập trình.

Chúng ta sẽ tìm hiểu các so sánh đánh giá về các ca kiểm thử được sinh bởi các phương pháp kiểm thử cấu trúc khác nhau ở mục 1.4.3. Một số phương pháp kiểm thử cấu trúc (kiểm thử dòng điều khiển, kiểm thử dòng dữ liệu và kiểm thử dựa trên lát cắt) sẽ được giới thiệu chi tiết trong các chương 6 và 7.

## Tranh luận về kiểm thử chức năng so với kiểm thử cấu trúc

Cho trước hai cách tiếp cận khác nhau để xác định các ca kiểm thử, câu hỏi tự nhiên được đặt ra là phương pháp nào tốt hơn? Cho đến nay chúng ta vẫn chưa có câu trả lời thỏa đáng cho câu hỏi này.

Nói về kiểm thử cấu trúc, Robert Poston viết: công cụ này lãng phí thời gian của người kiểm thử vì từ những năm bảy mươi (của thế kỷ trước) nó chẳng trợ giúp tốt việc thực hành kiểm thử phần mềm và đừng có đưa nó vào bộ công cụ của người kiểm thử [Pos91]. Nhằm bảo vệ cho việc kiểm thử cấu trúc, Edward Miller [Mil91] viết: Độ bao phủ nhánh (một độ đo độ bao phủ của kiểm thử), nếu đạt được 85% hoặc cao hơn, có thể xác định số lỗi gấp đôi so với số lỗi phát hiện bởi kiểm thử trực quan (kiểm thử chức năng).

![](images/image6.png)

**Hình 1.8: Nguồn các ca kiểm thử.**

Biểu đồ Venn được mô tả trong hình 1.8 có thể giúp ta trả lời câu hỏi mà cuộc tranh luận này đã đề cập. Chúng ta cần khẳng định lại rằng mục đích của cả hai cách tiếp cận trên là để xác định các ca kiểm thử. Kiểm thử chức năng chỉ dùng đặc tả để xác định ca kiểm thử, trong khi kiểm thử cấu trúc dùng mã nguồn của chương trình (cài đặt) để làm cơ sở xác định các ca kiểm thử. Những bàn luận trước đây cho thấy chẳng có cách tiếp cận nào là đủ tốt.

Xét các hành vi chương trình: nếu tất cả các hành vi được đặc tả vẫn chưa được cài đặt, kiểm thử cấu trúc sẽ không thể nhận biết được điều đó. Ngược lại, nếu các hành vi được cài đặt chưa được đặc tả, điều đó chẳng khi nào có thể được phơi bày nhờ kiểm thử chức năng. Một con vi rút là một ví dụ tốt về các hành vi không được đặc tả. Câu trả lời sơ bộ cho câu hỏi trên là cả hai cách tiếp cận đều là rất cần thiết; còn câu trả lời cẩn thận hơn là cách kết hợp khôn khéo giữa hai cách tiếp cận này sẽ cung cấp niềm tin cho kiểm thử chức năng và độ đo của kiểm thử cấu trúc. Ta đã khẳng định ở trên rằng kiểm thử chức năng có khiếm khuyết về tính dư thừa và hố phân cách. Nếu kiểm thử chức năng được tiến hành kết hợp với các số đo về độ phủ của kiểm thử cấu trúc thì khiếm khuyết trên có thể được phát hiện và giải quyết.

Quan điểm biểu đồ Venn cho việc kiểm thử đặt ra câu hỏi về quan hệ giữa tập các ca kiểm thử ( _T_ ) với các tập _S_ và _P_ của các hành vi cài đặt và đặc tả như thế nào? Rõ ràng, các ca kiểm thử trong _T_ được xác định bởi phương pháp xác định ca kiểm thử được dùng. Một câu hỏi rất hay cần đặt ra là thế thì phương pháp này thích hợp và hiệu quả ra sao. Ta có thể đóng lại vòng luẩn quẩn này bằng những lời bàn trước đây. Với đường đi từ lỗi đến sai, thất bại và sự cố, nếu biết loại lỗi nào ta hay phạm, và loại sai nào hay có trong phần mềm được kiểm thử, ta có thể dùng thông tin này để lựa chọn phương pháp thích hợp để xác định các ca kiểm thử. Chính điểm này làm cho việc kiểm thử thành một nghệ thuật.

# Phân loại các lỗi và sai

Các định nghĩa về lỗi và sai được trình bày trong mục 1.1 xoay quanh sự phân biệt giữa quy trình và sản phẩm. Trong khi quy trình cho chúng ta biết cần làm điều gì đó như thế nào thì sản phẩm là kết quả cuối cùng của quy trình. Kiểm thử phần mềm và đảm bảo chất lượng phần mềm (Software Quality Assurance - SQA) gặp nhau ở điểm là SQA cố gắng cải tiến chất lượng sản phẩm bằng việc cải tiến quy trình. Theo nghĩa này thì kiểm thử là các hoạt động định hướng sản phẩm. SQA quan tâm nhiều hơn đến việc giảm thiểu lỗi trong quá trình phát triển, còn kiểm thử quan tâm chủ yếu đến phát hiện sai trong sản phẩm. Cả hai nguyên lý này đều sử dụng định nghĩa về các loại sai. Các sai được phân loại theo nhiều cách khác nhau: giai đoạn phát triển khi cái sai tương ứng xuất hiện, các hậu quả của các thất bại tương ứng, độ khó cho việc giải quyết, độ rủi ro của việc không giải quyết được, v.v. Một cách phân loại được ưa thích là dựa trên việc xuất hiện bất thường: chỉ một lần, thỉnh thoảng, xuất hiện lại hoặc lặp đi lặp lại nhiều lần. Hình 1.9 minh họa một cách phân loại sai [Bor84] dựa trên độ nghiêm trọng của hậu quả mà các lỗi gây ra.

# Public_059

# Kiểm thử tích hợp

Các chương trước chủ yếu tập trung vào các kỹ thuật kiểm thử các hàm đơn lẻ, còn gọi là kiểm thử đơn vị. Kiểm thử tích hợp tập trung vào việc kiểm thử khi ghép nối các đơn vị này, hay tổng quát hơn là các mô-đun đã được kiểm thử đơn vị. Kiểm thử ở mức này gọi là kiểm thử tích hợp. Kiểm thử tích hợp giúp kiểm tra sự tương thích giữa các mô-đun. Kiểm thử hệ thống và kiểm thử chấp thuận ở phần sau sẽ kiểm tra toàn bộ hệ thống so với đặc tả và yêu cầu của người sử dụng.
Một mô-đun phần mềm (hay còn gọi là một thành phần) là một phần tử tương đối độc lập trong một hệ thống. Khái niệm mô-đun mang tính tương đối. Mô-đun có thể đơn giản là một hàm, một thủ tục, một lớp, hay một tập các phần tử cơ bản này kết hợp với nhau
để cung cấp một dịch vụ tích hợp mới. Các mô-đun thường có giao diện rõ ràng để giao tiếp với các mô-đun khác. Một hệ thống là một tập các mô-đun kết nối với nhau theo một cách nhất định để thực hiện một mục đích đã đặt ra.
Trong các dự án lớn có hàng chục hoặc hàng trăm người lập trình, hệ thống thường được chia thành các mô-đun để nhiều nhóm cùng phát triển. Các mô-đun thường được kiểm thử độc lập và kiểm thử ở mức này gọi là kiểm thử đơn vị. Người lập trình thường chịu trách nhiệm thực hiện kiểm thử đơn vị. Các kỹ thuật kiểm thử hộp đen (kiểm thử chức năng) và kiểm thử hộp trắng (kiểm thử cấu trúc) chủ yếu để kiểm thử ở mức này. Sau khi các đơn vị được kiểm thử xong, chúng được ghép với nhau để tạo thành mô-đun lớn hơn, hay hệ thống con, hoặc thành hệ thống phần mềm tùy độ lớn và phức tạp của hệ thống. Việc ghép này không hề đơn giản vì lúc này các lỗi ở mức giao diện giữa các mô-đun có thể xảy ra. Việc kiểm tra lỗi trong quá trình ghép này là kiểm thử tích hợp và kiểm thử hệ thống. Kiểm thử tích hợp thường phải được thực hiện trước và làm trong nội bộ đội phát triển. Khi kiểm thử tích hợp đã ổn định, kiểm thử hệ thống mới được tiến hành để đảm bảo hệ thống hoạt động tốt ở môi trường thật.
Ba lý do chính chúng ta cần kiểm thử tích hợp là:

  * Các mô-đun có thể do các nhóm khác nhau làm. Dù đã có thống nhất với nhau từ trước về giao diện của các mô-đun, việc hiểu sai, nhầm lẫn, và chủ quan nhiều khi vẫn xảy ra trên thực tế. Phần sau chúng ta sẽ xem những nguyên nhân có thể gây ra lỗi giao diện này.

  * Các mô-đun thường được kiểm thử với các hàm giả trước khi tích hợp, hoặc là với hàm giả (stub), hoặc hàm giả gọi (driver). Các hàm giả (stub) chỉ trả về giá trị kết quả với một số tham số định trước, mô phỏng một vài trường hợp của hàm thật. Các hàm giả gọi (driver) gọi nhiều mô-đun khác theo


các đường đi khác nhau nên nếu hàm giả gọi này không được kiểm thử hết tất cả các đường đi thì khó có thể khẳng định việc thay hàm giả gọi bằng hàm thật chắc chắn không sinh ra lỗi.

  * Một số mô-đun bản chất là phức tạp nên dễ có lỗi hơn. Chúng ta cần xác định mô-đun gây ra lỗi nhiều nhất.


Kiểm thử tích hợp kết thúc khi toàn bộ các mô-đun được tích hợp đầy đủ với nhau, các lỗi phát hiện được sửa chữa. Khi hệ thống có nhiều mô-đun thì cũng có nhiều cách ghép chúng lại. Các cách ghép khác nhau sẽ kéo theo các phương pháp kiểm thử tích hợp khác nhau và mỗi trong chúng đều có các ưu nhược điểm. Các phần sau chúng ta sẽ xem xét các yếu tố gây lỗi tích hợp, các phương pháp ghép nối các mô-đun chính, và ưu nhược điểm của việc kiểm thử tích hợp tương ứng.

## Các loại giao diện và lỗi giao diện

Mô-đun hóa là một nguyên lý quan trọng trong thiết kế phần mềm và các mô-đun tương tác với nhau qua các giao diện để thực hiện các yêu cầu chức năng của hệ thống. Một giao diện giữa hai mô-đun cho phép một mô-đun truy cập dịch vụ cung cấp bởi mô-đun kia. Giao diện có cả cơ chế chuyển điều khiển (thực thi) và chuyển dữ liệu giữa các mô-đun. Ba loại giao diện chính chúng ta thường gặp là:

  * **Giao diện gọi hàm/thủ tục (procedure call):** một hàm trong một mô-đun gọi một hàm trong một mô-đun khác. Phía gọi sẽ chuyển điều khiển cho mô-đun được gọi. Phía gọi cũng có thể chuyển dữ liệu cho hàm được gọi. Ngược lại hàm được gọi cũng có thể chuyển dữ liệu trả về cho hàm gọi khi nó trả điều khiển về cho hàm gọi.


Trong ví dụ dưới đây, khi thực thi lệnh đầu tiên trong hàm main(), điều khiển sẽ được được chuyển cho hàm print_str() và dữ liệu là xâu ký tự "Hello␣World!" cũng được chuyển cho hàm được gọi (hàm print_str). Giao diện ở đây chính là chữ ký/khai báo hàm void print_str(char*).
**Đoạn mã 10.1: Giao diện gọi hàm/thủ tục**
# include <stdio .h>
void print_str( char* str){ printf("% s", str);
}
int main ( void ){
print_str(" Hello ␣World !"); return 0;
}

  * **Giao diện bộ nhớ chia sẻ (shared memory):** một khối bộ nhớ được chia sẻ giữa hai mô-đun. Khối bộ nhớ này có thể do một trong hai mô-đun cấp phát, hoặc cũng có thể do một mô-đun thứ ba cấp phát. Một mô-đun sẽ ghi dữ liệu lên khối bộ nhớ và mô-đun kia đọc dữ liệu từ khối bộ nhớ.


Trong ví dụ dưới đây hàm main và hàm print_str sử dụng bộ nhớ chia sẻ là biến str để trao đổi dữ liệu giữa các hàm này. Hàm main() ghi dữ liệu và hàm print_str() đọc dữ liệu. Trong trường hợp này, bộ nhớ cho biến str không được cấp phát mà sử dụng hằng ký tự.
**Đoạn mã 10.2: Giao diện bộ nhớ chia sẻ**
# include <stdio .h> char* str;
void print_str ()
{
printf("% s", str);
}
int main ( void )
{
str = " Hello ␣World !"; print_str ();
return 0;
}

  * **Giao diện truyền thông điệp (message passing):** một mô-đun tạo một thông điệp và gửi thông điệp đó cho một mô-đun khác. Dạng này rất phổ biến trong các hệ thống có nhiều tiến trình, khách-chủ hay các hệ thống trên nền Web, dịch vụ Web.


Trong Đoạn mã 10.3 chương trình tạo một đường ống (bằng hàm pipe()) để tiến trình cha liên lạc với tiến trình con (sinh ra bởi hàm fork()). Sau khi sinh ra tiến trình con, tiến trình cha truyền một xâu ký tự vào đường ống và tiến trình con sử dụng vòng lặp để đọc dữ liệu từ đường ống và in ra màn hình.
Lỗi giao diện là lỗi gắn với các cấu trúc tồn tại bên ngoài môi trường của mô-đun nhưng được mô-đun đó sử dụng [BP84]. Một số lỗi giao diện này được phân loại như sau [PE85]:

  1. _Không đủ chức năng:_ lỗi này do một mô-đun giả thiết sai về mô-đun kia. Mô-đun cung cấp dịch vụ không hoạt động như mô-đun sử dụng mong đợi - cố tình hoặc ngoài ý muốn của người lập trình mô-đun cung cấp dịch vụ.


  1. _Thay đổi tính năng:_ một mô-đun được sửa đổi nhưng các mô- đun sử dụng nó không được điều chỉnh theo nên chức năng của hệ thống bị ảnh hưởng.


**Đoạn mã 10.3: Giao diện truyền thông điệp**
_// ----------------------------------------------_
_// Excerpt from " Linux Programmer’s Guide - Chapter~6"_
_//( C) opyright 1994 -1995 , Scott Burkett_
_// ----------------------------------------------_
# include <stdio .h> # include <unistd .h>
# include <sys / types .h>
int main ( int argc , char* argv [] ) { int fd [2], nbytes ;
pid_t childpid ;
char string [] = " Hello , ␣world !\ n", readbuffer [80];
pipe ( fd );
_// fd [0] is opened for reading ( input side);_
_// fd [1] is opened for writing ( output side)._
if (( childpid = fork ()) == -1) { perror( " fork " );
exit( 1 );
}
if ( childpid == 0) {
_// child closes input side of pipe , & writes_
close ( fd [0]);
_// Send " string" through the out. side of pipe_
write ( fd [1], string , ( strlen ( string )+ 1 ));
}
else {
_// parent proc. closes out. side of pipe ,\ & reads_
close ( fd [1]);
_// Read in a string from the pipe_
nbytes = read ( fd [0], readbuffer , sizeof( readbuffer ));
_// Print the obtained string_
printf(" parent: received ␣string :\% s", readbuffer );
}
return 0;
}

  1. _Sử dụng giao diện không đúng:_ một mô-đun đã sử dụng không đúng giao diện của mô-đun được gọi. Với giao diện hàm việc sử dụng sai này có thể do truyền tham số không đúng thứ tự.


  1. _Hiểu giao diện không đầy đủ:_ một mô-đun khi thiết kế đã giả thiết một số điều kiện của tham số đầu vào, nhưng phía gọi lại không để ý đến giả thiết này nên đã truyền các tham số nằm ngoài giả thiết. Ví dụ hàm tìm kiếm nhị phân giả sử đầu vào là một mảng được sắp, nhưng phía gọi không sắp xếp mảng này trước khi gọi thì lỗi xảy ra thuộc kiểu này.


  1. _Không xử lý lỗi trả về:_ một mô-đun được gọi có thể trả về một mã lỗi nhưng mô-đun gọi lại không kiểm tra lỗi, coi nó là kết quả. Hoặc mô-đun được gọi bổ sung thêm mã lỗi trả về nhưng mô-đun gọi chưa kịp biết/sửa.


  1. _Hiệu ứng phụ với tham số hoặc tài nguyên:_ một mô-đun có thể sử dụng tài nguyên không mô tả trong giao diện. Ví dụ một mô-đun sử dụng file tạm tên là "temp", nhưng khi tích hợp một mô-đun khác cũng sử dụng file tạm với tên này sẽ gây lỗi xung đột. Hay ví dụ hàm strdup trong ngôn ngữ C cấp phát bộ nhớ mới và trả về con trỏ đến xâu mới. Nếu bên gọi không giải phóng bộ nhớ thì lỗi dò bộ nhớ sẽ xảy ra.


  1. _Các vấn đề phi chức năng:_ Các yêu cầu phi chức năng như tốc độ chỉ được nêu ra khi chúng có thể gây vấn đề. Các yêu cầu này ngay cả khi không nêu ra thì chúng ta vẫn ngầm định là chúng phải chạy không quá chậm. Khi tích hợp các vấn đề này mới thường phát sinh.


## Tích hợp dựa trên cấu trúc mô-đun

Một chương trình trong ngôn ngữ C hay Java thường có hàm main, hàm này sẽ gọi các hàm khác trong thân của nó. Các hàm khác này
lỗi gọi tiếp các hàm khác nữa. Rộng hơn là một hệ thống có nhiều mô-đun thì theo cấu trúc phân cấp này chúng tạo thành một cấu trúc hình cây như trong Hình 10.1. Sơ đồ lớp trong nhiều ngôn ngữ hướng đối tượng sẽ có cấu trúc này.
![](images/image1.png)
**Hình 10.1: Cấu trúc phân cấp mô-đun.**
Khi đã có các đơn vị là đỉnh của cây chúng ta có thể lắp dần chúng với nhau và kiểm thử tích hợp trong quá trình lắp. Thứ tự lắp các mô-đun vào cây sẽ dẫn đến các chiến lược kiểm thử tương ứng. Có bốn cách ghép thông dụng là từ trên xuống (top down), dưới lên (bottom up), song song của cả trên xuống và dưới lên gọi là bánh kẹp (sandwich), và một cách đơn giản khác là chỉ kiểm thử sau khi đã ghép hết tất cả các mô-đun (bigbang). Nhược điểm của kiểm thử theo kiểu bigbang là khi có lỗi thì chúng ta rất khó để xác định vị trí của lỗi (khó định vị lỗi). Nếu chúng ta ghép dần dần và kiểm thử luôn thì khi có lỗi xuất hiện, chúng ta tập trung vào các mô-đun vừa ghép với nhau sẽ dễ xác định lỗi hơn. Chú ý ở đây chúng ta giả sử các mô-đun đã được kiểm thử đơn vị xong, nên kiểm thử tích hợp có thể coi là kiểm thử giao diện giữa các mô-đun.

# Public_060

Chương này trình bày một số ví dụ mà sẽ được dùng trong các chương tiếp theo nhằm minh họa cho các phương pháp kiểm thử. Các ví dụ này gồm: bài toán tam giác và hàm NextDate tương đối phức tạp về mặt lôgic. Các ví dụ này liên quan đến một số vấn đề mà người kiểm thử sẽ gặp trong quá trình kiểm thử. Khi bàn về kiểm thử tích hợp và kiểm thử hệ thống trong chương 10, ta sẽ dùng ví dụ về một phiên bản đơn giản của máy rút tiền tự động (ATM).
Trong chương này các ví dụ mức đơn vị, cài đặt bằng ngôn ngữ C, sẽ được trình bày cho mục đích kiểm thử cấu trúc. Các mô tả mức hệ thống của máy ATM dưới dạng một tập các sơ đồ dòng dữ liệu và máy hữu hạn trạng thái sẽ được trình bày trong các chương tiếp theo.

# Bài toán tam giác

Kể từ ngày được công bố lần đầu dưới dạng một ví dụ của kiểm thử cách đây 30 năm [Gru73], bài toán tam giác đã được nhắc tới trong nhiều bài báo và sách về kiểm thử, chẳng hạn trong các tài liệu [Gru73, BL75, Mye75, S.82, AJ83, AJ84, Mal87, Bil88].

## Phát biểu bài toán

Bài toán tam giác nhận ba số nguyên làm các dữ liệu đầu vào; các dữ liệu này là số đo các cạnh của một tam giác. Đầu ra của chương trình là loại của tam giác xác định bởi ba cạnh ứng với các số đo này: tam giác đều, tam giác cân, tam giác thường, hoặc không là tam giác. Ta sẽ dùng các từ tiếng Anh làm dữ liệu đầu ra tương ứng cho các loại này như lấy từ ví dụ nguyên thủy: Equilateral, Isosceles, Scalene, hoặc NotATriangle. Bài toán này đôi khi được mở rộng với đầu ra thứ năm là tam giác vuông (right triangle). Trong các bài tập, ta sẽ dùng bài toán mở rộng như vậy.

## Nhận xét

Một trong các lý do làm bài toán này được sử dụng rất phổ biến có thể là vì nó tiêu biểu cho việc định nghĩa không đầy đủ làm phương hại đến việc trao đổi thông tin giữa khách hàng, người phát triển và người kiểm thử. Đặc tả này giả thiết rằng người phát triển biết các chi tiết về tam giác, đặc biệt tính chất sau của tam giác: tổng của hai cạnh bất kỳ cần thực sự lớn hơn cạnh còn lại. Nếu _a, b_ và _c_ ký hiệu cho ba cạnh của tam giác thì tính chất trên được biểu diễn chính xác bằng ba bất đẳng thức toán học _a < b_ \+ _c_ , _b < a_ \+ _c_ và _c < a_ \+ _b_. Nếu bất kỳ một trong ba bất đẳng thức này không được thỏa mãn thì _a, b_ và _c_ không tạo thành ba cạnh của một tam giác. Nếu cả ba cạnh đều bằng nhau, chúng tạo thành tam giác đều, nếu chỉ có một cặp cạnh bằng nhau, chúng tạo thành tam giác cân và nếu không có cặp cạnh nào bằng nhau thì chúng là độ dài ba cạnh của một tam giác thường. Một người kiểm thử giỏi có thể làm rõ ý nghĩa bài toán này hơn nữa bằng việc đặt giới hạn cho các độ dài của các cạnh. Ví dụ, câu trả lời nào cho trường hợp khi đưa vào
chương trình ba số _−_ 5 _, −_ 4 và _−_ 3? Ta sẽ đòi hỏi là các cạnh phải ít nhất là bằng 1, và khi đó ta cũng có thể khai báo giới hạn của cận trên, chẳng hạn 20000.

## Cài đặt truyền thống

Cài đặt truyền thống của ví dụ cổ điển này có kiểu tựa FORTRAN [S.82]. Tuy nhiên, chúng tôi chuyển cài đặt của ví dụ này sang ngôn ngữ C để thống nhất với các ví dụ khác trong giáo trình này. Sơ đồ khối của ví dụ này được biểu thị trong hình 2.1. Các số của khối trong sơ đồ này tương ứng với các chú giải trong chương trình sau đây. Một cài đặt có cấu trúc hơn sẽ được cho trong mục 2.1.4.
Biến match được dùng để ghi nhận sự bằng nhau giữa các cặp cạnh. Nếu hai cạnh bằng nhau, chẳng hạn _a_ = _c_ , thì chỉ cần so sánh _a_ \+ _c_ với _b_ (do _b >_ 0, _a_ \+ _b > c_ sẽ phải thỏa mãn vì _a_ = _c_ ). Nhờ quan sát này, chúng ta có thể rút gọn số các so sánh cần làm. Cái giá phải trả cho tính hiệu quả này chỉ là sự rõ ràng và dễ kiểm thử!.
Trong các chương tiếp theo, ta sẽ thấy lợi thế của phiên bản này khi bàn đến các đường đi thực thi được của chương trình. Đó là lý do tốt nhất để giữ lại bản này.
int main(){
int a, b, c, match;
printf("Enter 3 sides (a, b, c) of a triangle \n"); printf("a = ");
scanf("%d",&a);
printf("b = ");
scanf("%d",&b);
printf("c = ");
scanf("%d",&c);
printf ("Side A is %d\n", a); printf ("Side B is %d\n", b);
![](images/image1.png)
**Hình 2.1: Sơ đồ khối cho cài đặt chương trình tam giác truyền thống.**
printf ("Side C is %d\n", c); match = 0;
if(a == b) {1}
match = match + 1; {2}
if(a == c) {3}
match = match + 2; {4}
if(b == c) {5}
match = match + 3; {6}
if(match == 0) {7}
if((a+b) <= c) {8}
printf("Not a Triangle"); {12.1} else if((b+c) <= a) {9}
printf("Not a Triangle"); {12.2} else if((a+c) <= b) {10} printf("Not a Triangle"); {12.3}
else printf("Triangle is Scalene");{11}
else
if(match == 1) {13}
if((a+c) <= b) {14}
printf("Not a Triangle"); {12.4} else printf("Triangle is Isosceles"); {15.1}
else
if(match == 2) {16}
if((a+c) <= b) {17}
printf("Not a Triangle"); {12.5}
else printf("Triangle’s Isoscel.");{15.2} 
else if(match == 3) {18} if((b+c) <= a) {19}
printf("Not a Triangle"); {12.6} else
printf("Triangle’s Isoscel.");{15.3} 
else printf("Triangle’s Equilat."); {20}
return 0;
}//the end.
Lưu ý là có sáu cách để đi đến nút “Not A Triangle” (12.1 – 12.6) và có ba cách để đi đến nút “Isosceles” (15.1 – 15.3).

## Cài đặt có cấu trúc

Hình 2.2 là một mô tả sơ đồ dòng dữ liệu của chương trình tam giác. Ta có thể cài đặt bằng một chương trình chính và bốn thủ tục. Vì ta sẽ dùng ví dụ này cho việc kiểm thử đơn vị, bốn thủ tục đã được kết hợp thành một chương trình C. Các dòng chú giải liên kết các đoạn mã với việc phân rã cho trong hình 2.2.
int main(){
int a, b, c, IsATriangle;
//Function 1: Get Input
printf("Enter 3 sides (integers) of a triangle"); printf("a = ");
scanf("%d",&a);
printf("b = ");
scanf("%d",&b);
printf("c = ");
scanf("%d",&c);
printf ("Side A is %d\n", a); printf ("Side B is %d\n", b); printf ("Side C is %d\n", c);
//Function 2: Is A Triangle?
if((a < b + c) && (b < a + c) && (c < a + b)) IsATriangle = 1;
else IsATriangle = 0;
//Function 3: Determine Triangle Type if(IsATriangle)
if((a == b) && (b == c)) printf("Triangle is Equilateral");
else if((a != b) && (a != c) && (b != c))
printf("Triangle is Scalene"); else printf("Triangle is Isosceles");
else printf("Not a Triangle");
return 0;
}//the end
Lưu ý: Function 4 và Output Controller đã được kết hợp thành các lệnh trong Function 3.
**Hình 2.2: Sơ đồ dòng dữ liệu cho cài đặt có cấu trúc của chương trình tam giác.** ![](images/image2.png) **  
**

# Hàm NextDate (ngày kế tiếp)

Độ phức tạp của chương trình tam giác nằm ở các mối quan hệ giữa dữ liệu đầu vào và dữ liệu đầu ra. Hàm NextDate nhằm minh họa một loại độ phức tạp khác: mối quan hệ giữa các biến đầu vào.

## Phát biểu bài toán

NextDate là một hàm có ba biến biểu diễn ngày, tháng và năm là day, month và year. Hàm này trả về ngày kế tiếp của ngày đầu vào. Các biến day, month, year có các giá trị số thỏa mãn các ràng buộc: 1 _≤_ day _≤_ 31 _,_ 1 _≤_ month _≤_ 12 _,_ 1812 _≤_ year _≤_ 2012.

## Nhận xét

Có hai nguyên nhân tạo nên độ phức tạp của hàm NextDate: độ phức tạp nêu trong các ràng buộc trên đây của miền dữ liệu đầu vào, và quy tắc phân biệt giữa năm nhuận và năm không nhuận. Do trung bình một năm có 365 _,_ 2422 ngày, năm nhuận được dùng để giải quyết ngày “vượt trội”. Nếu ta chấp thuận cứ bốn năm lại có một năm nhuận thì sẽ có một sai số nhỏ. Lịch Gregorian (đề xuất năm 1582 bởi Giáo hoàng Gregory) giải quyết vấn đề này bằng cách điều chỉnh các năm nhuận theo năm thế kỷ (những năm chia hết cho 100). Do đó, một năm là nhuận nếu nó chia hết cho 4 nhưng không là năm thế kỷ. Các năm thế kỷ là nhuận khi và chỉ khi nó là bội của 400 [Ing61, fS91]. Do đó các năm 1992, 1996 và 2000 là năm nhuận, nhưng năm 1900 lại không phải là năm nhuận.
Hàm NextDate cũng minh họa một khía cạnh của kiểm thử phần mềm. Ta thường thấy các ví dụ về luật Zipf - nói rằng 80% các hoạt động xảy ra tại chỉ 20% của không gian. Ta cũng thấy ở đây phần lớn mã nguồn (80% các hoạt động) được dành cho các năm nhuận (20% của không gian).

# Public_061

Chương này giới thiệu các kỹ thuật khảo sát đặc tả và mã nguồn. Mã nguồn được phát triển dựa trên đặc tả và vì thế việc khảo sát đặc tả cần được tiến hành trước khi phát triển mã nguồn để tránh các rủi ro về các lỗi có thể có trong đặc tả về sản phẩm phần mềm. Vì đặc tả không thể thực thi được trên máy nên chúng ta chỉ có thể phát hiện các lỗi bằng các kỹ thuật khảo sát đặc tả. Tuy nhiên, mã nguồn thì có thể thực thi được và có thể được kiểm thử thông qua việc chạy trên máy. Vì vậy, liệu chúng ta có cần phải khảo sát mã nguồn trước không? Câu trả lời là rất cần vì khảo sát giúp ta phát hiện các lỗi sớm, các lỗi về lôgic, các lỗi về cấu trúc và giúp đề xuất các ca kiểm thử hiệu quả hơn. Khảo sát mã nguồn và không tiến hành phần mềm để phát hiện lỗi trong quá trình phát triển phần mềm được gọi là kiểm thử hộp trắng tĩnh (static white-box testing). Đây là một kỹ thuật kiểm thử bổ sung vào các kỹ thuật kiểm thử khác để đảm bảo chất lượng phần mềm. Còn khảo sát đặc tả được liệt vào phạm trù của kiểm thử hộp đen tĩnh (static black-box testing) vì việc này thường được tiến hành khi chưa có mã nguồn

# Khảo sát đặc tả

Đặc tả phần mềm là một tài liệu quan trọng, mô tả các chức năng mà phần mềm cần có cũng như các ràng buộc mà phần mềm cần thỏa mãn. Tài liệu này được tạo ra từ nhiều nguồn khác nhau như thông qua các nghiên cứu về nhu cầu sử dụng của người dùng, về các biểu mẫu, về thị trường, v.v. Việc tài liệu này được tạo ra thế nào và viết ra dưới dạng nào không phải là mối quan tâm của người kiểm thử, miễn là nó đã được đúc kết thành một tài liệu mô tả sản phẩm để phát triển và người kiểm thử sẽ tiến hành các khảo sát trên tài liệu này để tìm các lỗi đặc tả có thể có. Cũng có trường hợp đặc tả không được viết ra. Trong trường hợp này, nó ở trong đầu của người thiết kế và lập trình, và người kiểm thử phải khảo sát các tài liệu này bằng việc phỏng vấn họ. Mục này giới thiệu hai kỹ thuật khảo sát đặc tả là duyệt đặc tả mức cao và duyệt đặc tả mức thấp nhằm nâng cao chất lượng của các đặc tả phần mềm. Đây là những công việc đầu tiên và không thể thiếu trước khi tiến hành các hoạt động đảm bảo chất lượng về sau.

## Tiến hành duyệt đặc tả mức cao

Định nghĩa một sản phẩm phần mềm là một việc khó. Đặc tả thường liên quan đến nhiều thứ chưa biết, việc xây dựng đặc tả lấy vô số đầu vào thay đổi, kết hợp chúng với nhau để tạo nên một tài liệu mô tả sản phẩm mới. Quá trình này là khoa học không chính xác và rất dễ mắc sai lầm.

Bước thứ nhất để kiểm thử đặc tả không phải đi vào chi tiết ngay để tìm lỗi mà là xem xét nó từ mức cao. Hãy khảo sát đặc tả để tìm các lỗi cơ bản lớn, những lỗi về bỏ sót trước đã. Việc xem xét đặc tả lúc này là theo quan điểm nghiên cứu nhiều hơn là kiểm thử. Chỉ khi đã hiểu những “tại sao” và “làm thế nào” ở đằng sau đặc tả, bạn mới có thể phản biện tốt các chi tiết trong nó. Sau đây là các kỹ thuật để tiến hành duyệt đặc tả mức cao.

### Hãy là khách hàng của sản phẩm

Khi nhận một tài liệu đặc tả để kiểm thử, điều dễ nhất người kiểm thử cần làm là hãy giả định mình là khách hàng của sản phẩm. Vì thế, trước hết cần tìm hiểu ai sẽ là khách hàng của sản phẩm. Hãy nói chuyện với những người chào hàng và ma-ket-ting cho sản phẩm để tìm hiểu về người dùng cuối cùng của sản phẩm. Nếu sản phẩm là trung gian trong một dự án phần mềm khác, hãy tìm hiểu ai sẽ dùng nó và nói chuyện với họ.

Điều quan trọng là cần phải hiểu khách hàng chờ đợi gì ở sản phẩm này. Thỏa mãn yêu cầu người dùng là yếu tố chất lượng quan trọng nhất. Để hiểu yêu cầu người dùng không nhất thiết phải là một chuyên gia trong lĩnh vực ứng dụng. Tuy nhiên, hiểu biết chút ít về nó sẽ giúp cho việc kiểm thử tốt hơn.

Không được giả thiết bất cứ cái gì khi tìm hiểu về đặc tả. Khi ta khảo sát một phần của đặc tả và không hiểu thì không được cho là nó đúng. Ta sẽ dùng đặc tả để thiết kế các ca kiểm thử sau này. Vì thế, nếu không hiểu được đặc tả thì sẽ không thiết kế tốt các ca kiểm thử. Xem xét đặc tả theo quan điểm người dùng giúp ta phát hiện những lỗi bỏ sót hoặc sai với yêu cầu của họ. Một điều cần lưu ý là tính an ninh và bảo mật thường được giả thiết bởi người dùng. Khi giả định là người dùng, người kiểm thử không được bỏ qua yêu cầu này.

### Hãy nghiên cứu các chuẩn và hướng dẫn hiện hành

Trên thế giới đã có nhiều nghiên cứu về cách con người sử dụng máy tính, và hiện nay đã có những chuẩn cả về phần cứng lẫn phần mềm về giao diện với người sử dụng, tương tác người máy, v.v. Vì thế, người phát triển phần mềm tốt nhất hãy tuân thủ nghiêm ngặt các chuẩn này. Các chuẩn về tương tác người máy được cải tiến để đáp ứng tốt nhất các yêu cầu của người dùng. Sau đây là một số chuẩn có thể nghiên cứu để áp dụng trong đặc tả phần mềm:  
**Hợp thức các thuật ngữ và quy ước.** Nếu phần mềm được làm riêng cho một công ty nào đó hãy sử dụng các thuật ngữ và quy ước của họ.

  * **Yêu cầu công nghiệp.** Trong mỗi lĩnh vực ứng dụng như y tế, dược phẩm, tài chính, v.v. đều có các chuẩn riêng và nghiêm ngặt của họ mà phần mềm phải tuân thủ.

  * **Chuẩn quy định bởi chính phủ.** Chính phủ có những quy định, đặc biệt trong các lĩnh vực quốc phòng, an ninh và quản lý mà phần mềm phải tuân thủ.

  * **Giao diện đồ họa với người sử dụng (GUI).** Các phần mềm chạy trong Windows hoặc Macintosh phải tuân thủ các quy định về giao diện đồ họa của các hệ điều hành này.

  * **Chuẩn bảo mật.** Phần mềm có thể phải thỏa mãn một số quy định về bảo mật mà cần phải được chứng nhận và cấp phép.


Người kiểm thử cần nắm được các chuẩn này để kiểm thử xem phần mềm có thỏa mãn hay không, có gì bị bỏ qua hay không. Các chuẩn này được coi là một phần của đặc tả khi thẩm định phần mềm.

### Hãy xem xét và kiểm thử các phần mềm tương tự

Một trong các phương pháp để hiểu phần mềm của ta sẽ như thế nào là nghiên cứu các sản phẩm tương tự. Đó có thể là sản phẩm cạnh tranh hoặc sản phẩm nào đó giống như sản phẩm ta đang phát triển. Rất có thể điều đó đã được làm bởi người quản lý dự án hoặc chính người viết đặc tả cho sản phẩm ta đang phát triển. Các phần mềm không thể giống hệt nhau (là lý do để ta xây dựng sản phẩm tương tự), nhưng việc nghiên cứu các sản phẩm tương tự này giúp ta xây dựng cách tiếp cận kiểm thử sản phẩm của mình.

Những điểm cần tìm kiếm khi xem xét các sản phẩm tương tự bao gồm:

Ôm

  * **Kích cỡ.** Các đặc trưng sẽ nhiều hơn hay ít hơn? Chương trình sẽ ít hay nhiều lệnh hơn, việc kiểm thử có bị ảnh hưởng bởi kích cỡ không?


  * **Độ phức tạp.** Tương tự như kích cỡ, độ phức tạp sẽ cao hơn hay thấp hơn, và điều đó ảnh hưởng thế nào đến kiểm thử?


  * **Tính khả kiểm thử.** Liệu ta có đủ tài nguyên, thời gian và trình độ để kiểm thử phần mềm như vậy?


  * **Chất lượng và độ tin cậy.** Liệu phần mềm này đại diện cho chất lượng của phần mềm đang xây dựng, độ tin cậy sẽ cao hơn hay thấp hơn?


  * **Tính bảo mật.** Phần mềm cạnh tranh này có tính bảo mật so với sản phẩm ta đang phát triển thế nào?


Ta sẽ thu được nhiều kinh nghiệm để khảo sát đặc tả của sản phẩm của mình bằng việc xem xét các vấn đề trên.

## Các kỹ thuật kiểm thử đặc tả ở mức thấp

Sau khi đã hoàn thành việc khảo sát đặc tả bậc cao, ta hiểu rõ hơn về sản phẩm của mình và những yếu tố bên ngoài ảnh hưởng đến thiết kế của sản phẩm phần mềm. Khi được trang bị những thông tin này, chúng ta sẽ tiếp tục khảo sát đặc tả ở mức thấp và chi tiết hơn. Mục này sẽ giải thích các chi tiết cần tiến hành nhằm đạt được mục tiêu này.

### Danh sách các hạng mục cần thẩm định về các thuộc tính của đặc tả

Một đặc tả sản phẩm phần mềm được xây dựng tốt cần thỏa mãn tám thuộc tính sau đây:

  * **Đầy đủ.** Liệu đặc tả còn thiếu cái gì không? Đã đủ chi tiết chưa? Liệu nó đã bao gồm mọi điều cần thiết để không phụ thuộc vào tài liệu khác?

  * **Trúng đích.** Liệu nó đã cung cấp lời giải đúng đắn cho bài toán, liệu nó đã xác định đầy đủ các mục tiêu và không có lỗi.

  * **Chính xác, không nhập nhằng và rõ ràng.** Mô tả có chính xác không, có rõ ràng và dễ hiểu không, liệu còn có gì là nhập nhằng với ý nghĩa không xác định?

  * **Tương thích.** Các đặc trưng và chức năng được mô tả có bị xung đột với nhau không?

  * **Hợp lệ.** Các khẳng định có thực sự cần thiết để mô tả đặc trưng sản phẩm không? Có gì thừa không? Có thể truy ngược về yêu cầu của người dùng không?

  * **Khả thi.** Liệu đặc tả có thể được cài đặt trong khuôn khổ nhân lực, công cụ, tài nguyên, thời gian và kinh phí cho phép hay không?

  * **Phi mã lệnh.** Trong đặc tả không được dùng các câu lệnh hoặc thuật ngữ cho người lập trình. Ngôn ngữ dùng trong đặc tả phải là phổ biến với người dùng.

  * **Khả kiểm thử.** Liệu các đặc trưng có thể kiểm thử được? Liệu đã cung cấp đủ thông tin để có thể kiểm thử và xây dựng các ca kiểm thử?


Khi xây dựng đặc tả phần mềm, hãy duyệt đặc tả (văn bản, hình vẽ, v.v.) và đánh giá xem nó có thỏa mãn các thuộc tính nêu trên chưa.

### Danh sách các hạng mục cần thẩm định về các thuật ngữ của đặc tả

Bên cạnh danh sách các thuộc tính trên đây là danh sách các từ hay có vấn đề cần tìm trong đặc tả khi phản biện. Sự xuất hiện của các từ này có thể tiết lộ rằng các đặc trưng được mô tả chưa được suy nghĩ thấu đáo và không gặp đủ các thuộc tính trên đây. Hãy tìm các từ này trong đặc tả và xem xét cẩn thận xem có lỗi ở đó không.

  * **Luôn luôn, mỗi một, tất cả, không có, không bao giờ.** Những từ như vậy mô tả sự tuyệt đối và chắc chắn. Hãy xét xem tình trạng có đúng như vậy không, có trường hợp nào vi phạm các khẳng định đó hay không.


  * **Tất nhiên, do đó, rõ ràng là, hiển nhiên là.** Các từ này được dùng để thuyết phục người khác chấp nhận cái gì đó. Đừng có rơi vào các bẫy đó.


  * **Nào đó, đôi khi, thông thường, thường gặp, hầu hết.** Các từ này là nhập nhằng, không có nghĩa rõ ràng và không thể kiểm thử, chẳng hạn bạn phải kiểm thử tính “đôi khi” thế nào?


  * **Vân vân, chẳng hạn, như vậy.** Các từ này thường mô tả thứ mà không thể kiểm thử được.


  * **Tốt, nhanh, rẻ, hiệu quả, ổn định.** Những từ không định lượng như vậy sẽ mô tả các hạng mục không thể kiểm thử được nếu không được làm chi tiết hóa sau này.


  * **Xử lý, từ chối, bỏ qua, bị khử.** Những thuật ngữ này thường dấu trong nó những chức năng cần phải đặc tả đầy đủ.


  * **Nếu ... thì (thiếu trái lại).** Trường hợp “trái lại” có thể bị bỏ quên. Hãy tránh các khẳng định như vậy.


Trên đây là kỹ thuật kiểm thử hộp đen tĩnh, tức là phản biện đặc tả của sản phẩm, tìm xem đặc tả có lỗi không. Khi đặc tả đã được hoàn thành và đã được phản biện, mã nguồn của chương trình được phát triển dựa trên đặc tả này. Bây giờ, chúng ta sẽ sử dụng kỹ thuật tương tự để phản biện/khảo sát mã nguồn.

# Khảo sát mã nguồn

Mục này giới thiệu các kỹ thuật cơ sở để tiến hành kiểm chứng thiết kế và mã nguồn của phần mềm. Nội dung chính của mục này bao gồm việc phân tích lợi ích của công việc, các kiểu khảo sát mã nguồn, một số hướng dẫn về chuẩn lập trình, và cách chung để khảo sát mã nguồn nhằm tìm lỗi.

## Khảo sát thiết kế và mã nguồn hay là việc kiểm thử hộp trắng tĩnh

Kiểm thử tĩnh tức là việc kiểm thử chỉ gồm việc khảo sát mà không cần tiến hành chương trình, còn kiểm thử hộp trắng là việc kiểm thử có trong tay mã nguồn của chương trình. Vì thế kiểm thử hộp trắng tĩnh chính là việc khảo sát thiết kế và mã nguồn của chương trình. Công việc này bao gồm một quy trình để khảo sát một cách cẩn thận và có phương pháp đối với thiết kế, kiến trúc và mã nguồn của phần mềm để tìm lỗi mà không cần tiến hành phần mềm. Công việc này còn có tên khác nữa là _phân tích cấu trúc_.

# Public_062

# Kiểm thử giá trị biên

Kiểm thử giá trị biên (boundary value testing) là một trong những kỹ thuật được áp dụng phổ biển nhất trong cách tiếp cận kiểm thử chức năng (kiểm thử hộp đen). Trong thực tế, các lỗi hay xảy ra ở các giá trị biên hoặc cận biên của các biến đầu vào của chương trình cần kiểm thử. Kỹ thuật kiểm thử giá trị biên được đề xuất nhằm phát hiện những lỗi này. Chúng ta sẽ coi một chương trình là một hàm toán học với đầu vào của chương trình tương ứng với các tham số của hàm và đầu ra của chương trình là giá trị trả về của hàm. Vì hàm toán học là ánh xạ từ miền xác định của hàm đến miền giá trị của hàm, chúng ta sẽ tập trung vào các giá trị biên và cận biên của hai miền đầu vào và đầu ra này của hàm để xây dựng các ca kiểm thử. Khi chúng ta dùng biên đầu ra tức là chúng ta cho các kết quả mong đợi nằm ở trên biên và cận biên đầu ra.

## Giá trị biên

Giả sử _y_ = _f_ ( _x_ 1 _, x_ 2) với _x_ 1 _, x_ 2 _, y_ ∈ N là một hàm toán học của một chương trình. Khi đó thông thường _x_ 1 và _x_ 2 có miền xác định thể hiện bằng các biên. Ví dụ:

_a_ ≤ _x_ 1 ≤ _b_ và _c_ ≤ _x_ 2 ≤ _d_

trong đó _a, b, c, d_ là các hằng số nào đó. Phần tô đậm trong hình 5.2 thể hiện miền xác định của hai biến này.

![](images/image1.png)

**Hình 5.2: Miền xác định của hàm hai biến.**

Ý tưởng kiểm thử giá trị biên xuất phát từ quan sát nhiều lỗi xảy ra với các giá trị biên này, khi chúng ta không kiểm tra khoảng giá trị hợp lệ của dữ liệu được nhập vào, hay do lỗi lập trình hoặc đặc tả làm các biểu thức điều kiện không chính xác. Ví dụ, đúng ra phải là dấu <= nhưng người lập trình hoặc đặc tả lại chỉ viết < hoặc ngược lại. Kiểm thử với các giá trị biên giúp chúng ta phát hiện các lỗi này. Trong nhiều trường hợp các biên này là ẩn, không được viết rõ ra trong yêu cầu nên lập trình viên dễ mắc lỗi không kiểm tra các giá trị đầu vào, hoặc không kiểm tra kết quả có hợp lệ không trước khi trả về.

Để tăng khả năng phát hiện lỗi, kiểm thử giá trị biên thường lấy năm ca kiểm thử cho mỗi biến là các giá trị: cực đại, cực tiểu, các giá trị cạnh chúng trong miền xác định (gọi là cận biên hoặc cạnh biên), và một giá trị ở giữa miền xác định đại diện cho giá trị thông thường. Chúng ta đánh chỉ số cho chúng lần lượt là _max_ , _min_ , _min_ +, _max_ − và _nom_. Hình 5.3 minh họa các giá trị này.

Thông thường lỗi chương trình xảy ra ngay khi có một sai sót trong phần mềm, chứ không cần kết hợp của nhiều sai sót mới gây ra lỗi. Khi đó các ca kiểm thử theo phương pháp kiểm thử giá trị biên được xây dựng bằng cách lấy một bộ giá trị _nom_ của các biến, rồi lần lượt thay mỗi giá trị đó của từng biến bằng giá trị biên và

![](images/image2.png)

**Hình 5.3: Các ca kiểm thử phân tích giá trị biên cho một hàm hai biến.**

cận biên để tạo ra ca kiểm thử mới. Ví dụ với hàm _f_ trên ta có bộ kiểm thử sau, thể hiện trên Hình 5.3.

{( _x_ 1 _nom, x_ 2 _nom_ ) _,_

( _x_ 1 _min, x_ 2 _nom_ ) _,_ ( _x_ 1 _min_ + _, x_ 2 _nom_ ) _,_ ( _x_ 1 _max−, x_ 2 _nom_ ) _,_ ( _x_ 1 _max, x_ 2 _nom_ ) _,_ ( _x_ 1 _nom, x_ 2 _min_ ) _,_ ( _x_ 1 _nom, x_ 2 _min_ +) _,_ ( _x_ 1 _nom, x_ 2 _max−_ ) _,_ ( _x_ 1 _nom, x_ 2 _max_ )}

Tổng quát hóa kiểm thử giá trị biên cho hàm _n_ biến số và mỗi biến có các giá trị biên và cận biên khác nhau ta có thể dễ thấy sẽ có 1 \+ 4 _n_ ca kiểm thử vì xuất phát từ một ca kiểm thử gồm các giá trị trung bình của các biến, ta thay nó bằng bốn giá trị biên và cận biên: _min_ , _min_ +, _max_ , và _max_ −. Với _n_ biến sẽ tạo thêm 4 _n_ bộ kiểm thử. Do đó tổng số ca kiểm thử là 1 + 4 _n_. Tuy nhiên tùy theo miền xác định của biến mà số lượng này thực tế có thể ít hơn. Ví dụ biến nguyên thuộc khoảng [1 _,_ 2] thì không có cận biên và không có giá trị ở giữa. Với cách tạo bộ kiểm thử giá trị biên này, mỗi giá trị biên và cận biên xuất hiện một lần với các giá trị trung bình của các biến còn lại, chứ không phải tổ hợp các bộ giá

trị của các biên. Tổ hợp của các biên được gọi là kiểm thử giá trị biên mạnh sẽ được thảo luận trong phần tiếp theo.

Trong thực tế, miền xác định của các biến không chỉ là các miền số, nên chúng ta cần có các vận dụng thích hợp để xác định các giá trị biên tinh tế hơn. Ví dụ trong chương trình NextDate biến tháng month có thể là số nguyên trong khoảng từ 1 đến 12. Nhưng không phải ngôn ngữ lập trình nào cũng cho phép khai báo miền xác định của biến trong khoảng này. Chúng ta cũng có thể dùng kiểu liệt kê (enumeration) để khai báo các tháng bằng tên Januray, ..., December và chúng ta vẫn có giá trị biên và cận biên. Tuy nhiên như trong ngôn ngữ lập trình Java chúng ta phải dùng biến kiểu nguyên int và không khai báo miền giá trị cho chúng được, thì chúng ta sẽ phải dùng các cận của kiểu làm biên. Trong Java, biên của số nguyên là Interger.MIN_VALUE và Interger.MAX_VALUE. Trong ngôn ngữ lập trình C, chúng ta cũng có các khoảng giá trị này.

Với biến kiểu Boolean, các giá trị của miền chỉ có TRUE và FALSE, chúng ta không có cận biên và giá trị ở giữa. Với kiểu xâu ký tự, mảng, hay danh sách, tập hợp (collection), chúng ta có thể dựa vào chiều dài/kích thước để làm các giá trị biên. Với các kiểu cấu trúc dữ liệu khác chúng ta có thể xây dựng các giá trị biên và cận biên dựa theo các thành phần của cấu trúc.

**Ưu nhược điểm:** Khi các biến của hàm là độc lập, không có quan hệ ràng buộc lẫn nhau, thì kiểm thử giá trị biên tỏ ra hiệu quả. Nhưng khi chúng có quan hệ phụ thuộc nào đó thì phương pháp này dễ tạo ra các ca kiểm thử không hợp lý, vì các giá trị cực đại, cực tiểu có thể không kết hợp với nhau để tạo thành ca kiểm thử hợp lệ.

Ví dụ, khi _x_ 1 và _x_ 2 của hàm _f_ trên có các ràng buộc là _x_ 1 ∈ [1 _,_ 100], _x_ 2 ∈ [1 _,_ 100] and _x_ 1 \+ _x_ 2 ≤ 120 thì một biến đạt cực đại sẽ không thể kết hợp với một biến khác ở giá trị trung bình. Nếu chúng ta xuất phát 

từ ca kiểm thử của hai giá trị trung bình (50 _,_ 50) thì khi thay giá trị đầu bằng giá trị cực đại sẽ tạo ra ca kiểm thử (100 _,_ 50). Ca kiểm thử này không thỏa mãn quan hệ _x_ 1 \+ _x_ 2 ≤ 120. Ví dụ khác với hàm NextDate thì biến ngày, tháng và năm có ràng buộc. Một số tháng có 31 ngày, một số lại có 30 ngày. Năm nhuận lại có ràng buộc với số ngày trong tháng hai. Nếu không xét sự phụ thuộc này kiểm thử giá trị biên không tạo ra được ca kiểm thử ngày 28 tháng 2 năm 2012, vì 28 không là biên và cận biên của khoảng ngày từ 1 đến 31.

Kiểm thử giá trị biên cũng không quan tâm đến tính chất, đặc trưng của hàm, đồng thời cũng không xét đến ngữ nghĩa của biến hay quan hệ giữa các biến. Nó chỉ máy móc lấy các giá trị biên, cận biên và trung bình để tổ hợp tạo ra các ca kiểm thử. Nên khi áp dụng chúng ta cần xác định sơ bộ các tính chất trên của hàm có không.

Ưu điểm của phương pháp này là đơn giản và có thể tự động hóa việc sinh các ca kiểm thử khi chúng ta đã xác định được các biên của các biến. Với nhiều kiểu dữ liệu cơ bản có sẵn chúng ta cũng có thể xây dựng sẵn các biên này để sử dụng.

## Một số dạng kiểm thử giá trị biên

### Kiểm thử giá trị biên mạnh

Kiểm thử giá trị biên mạnh là mở rộng của kiểm thử giá trị biên bằng việc bổ sung các giá trị cận biên bên ngoài miền xác định. Ngoài 5 giá trị biên đã nêu ở phần trước chúng ta lấy thêm các giá trị cận biên ở ngoài miền xác định là _max_ \+ và _min_ − như trong Hình 5.4. Các ca kiểm thử này sẽ giúp ta kiểm tra chương trình với dữ liệu không hợp lệ, nằm ngoài khoảng mong đợi. Ví dụ khi nhập ngày 32/1/2013 chương trình cần có thông báo lỗi thích hợp.

Các ca kiểm thử mạnh này giúp chúng ta kiểm tra xem chương trình có xử lý các ngoại lệ hay kiểm tra biến đầu vào hay không.

Với các ngôn ngữ lập trình không kiểm tra kiểu khi biên dịch hay dữ liệu được nhập vào bên ngoài, do người sử dụng đưa vào hoặc lấy từ hệ thống khác, việc này là rất cần thiết. Rất nhiều lập trình viên mới vào nghề thường xuyên không kiểm tra dữ liệu đầu vào nên chương trình chỉ chạy với dữ liệu nhập đúng như suy nghĩ của người lập trình. Hậu quả của việc này không chỉ đơn thuần là chương trình bị sai, mà thường gây vi phạm bộ nhớ, dẫn đến tắt chương trình (crash), và là một trong những lỗ hổng an ninh dễ bị khai thác.

![](images/image3.png)

**Hình 5.4: Các ca kiểm thử mạnh cho hàm hai biến.**

### Kiểm thử giá trị biên tổ hợp

Ở trên, chúng ta chỉ tạo các ca kiểm thử với giá trị biên và cận biên cho từng biến. Nếu chúng ta mở rộng với hai hoặc với tất cả các biến đều được đẩy đến giá trị biên và cận biên thì chúng ta sẽ tạo ra được các ca kiểm thử giá trị biên tổ hợp. Tức là từ bộ giá trị 5 phần tử _min_ , _min_ +, _nom_ , _max_ − và _max_ của mỗi biến ta lấy tích Đề-các (Cartesian) của chúng để tạo ra các ca kiểm thử. Hình 5.5 minh họa các ca kiểm thử giá trị biên tổ hợp của hàm hai biến.

![](images/image4.png)

**Hình 5.5: Các ca kiểm thử biên tổ hợp của hàm hai biến.**

Có thể thấy cách tổ hợp các biên và cận biên này sẽ kiểm tra kỹ hơn kiểm thử giá trị biên thông thường. Tuy nhiên số ca kiểm thử theo cách này tăng lên đáng kể, lên đến 5 _n_ ca kiểm thử so với 4 _n_ \+ 1 ca theo kiểm thử biên thông thường.

Tương tự như kiểm thử giá trị biên mạnh, ta có thể mở rộng kiểm thử biên tổ hợp với bộ 7 giá trị của kiểm thử giá trị biên mạnh. Chúng ta sẽ kiểm tra được kỹ hơn nhưng cũng mất nhiều công sức hơn, đến 7 _n_ ca kiểm thử.

### Kiểm thử các giá trị đặc biệt

Kiểm thử các giá trị đặc biệt cũng là một phương pháp phổ biến. Đây cũng là phương pháp trực quan nhất và không theo một khuôn dạng cụ thể nào. Dựa trên hiểu biết về bài toán và miền ứng dụng kết hợp với kinh nghiệm cá nhân, người kiểm thử đưa ra các giá trị kiểm thử. Do đó không có hướng dẫn cụ thể nào cho phương pháp này. Mức độ hiệu quả của phương pháp này phụ thuộc nhiều vào khả năng của người kiểm thử. Trên thực tế các đơn vị phát triển phần mềm vẫn áp dụng phương pháp này, vì nhiều khi nó giúp phát hiện lỗi nhanh, không tốn nhiều công sức.

# Public_063

# Kiểm thử bằng bảng quyết định

Kỹ thuật kiểm thử lớp tương đương và kiểm thử giá trị biên thích hợp cho các hàm có các biến đầu vào không có quan hệ ràng buộc với nhau. Kỹ thuật kiểm thử dựa trên bảng quyết định sẽ phù hợp cho các hàm có các hành vi khác nhau dựa trên tính chất của bộ giá trị của đầu vào. Nói cách khác, kỹ thuật này phù hợp với các hàm/chương trình có các biến đầu vào phụ thuộc lẫn nhau.
Kiểm thử dựa trên bảng quyết định là phương pháp chính xác nhất trong các kỹ thuật kiểm thử chức năng. Bảng quyết định là phương pháp hiệu quả để mô tả các sự kiện, hành vi sẽ xảy ra khi một số điều kiện thỏa mãn.

## Bảng quyết định

Cấu trúc của một bảng quyết định chia thành bốn phần chính như trong Bảng 5.9, bao gồm:

  * Các biểu thức điều kiện _C_ 1 _, C_ 2 _, C_ 3;


  * Giá trị điều kiện T, F, –;


  * Các hành động _A_ 1 _, A_ 2 _, A_ 3 _, A_ 4; và


  * Giá trị hành động, có (xảy ra) hay không. Chúng ta ký hiệu X để chỉ hành động là có xảy ra ứng với các điều kiện tương ứng của cột.


Khi lập bảng quyết định, chúng ta thường tìm các điều kiện có thể xảy ra để xét các tổ hợp của chúng mà từ đó chúng ta sẽ xác định được các ca kiểm thử tương ứng cho các điều kiện được thỏa mãn. Các hành động xảy ra chính là kết quả mong đợi của ca kiểm thử đó.
Bảng quyết định với các giá trị điều kiện chỉ là T, F, và – được gọi là _bảng quyết định lôgic_. Chúng ta có thể mở rộng các giá trị này bằng các tập giá trị khác, ví dụ 1, 2, 3, 4, khi đó chúng ta có _bảng quyết định tổng quát_.
Bảng 5.10 là một ví dụ đơn giản về một bảng quyết định để khắc phục sự cố máy in. Khi máy in có sự cố, chúng ta sẽ xem xét tình trạng dựa trên các điều kiện trong bảng là đúng (T) hay sai (F), từ đó xác định được cột duy nhất có các điều kiện thỏa mãn, và thực hiện các hành động khắc phục sự cố tương ứng.

**Bảng 5.9: Ví dụ về một bảng quyết định**

![](images/image1.png)
Chú ý là ở đây thứ tự các điều kiện và thứ tự thực hiện hành động không quan trọng, nên chúng ta có thể đổi vị trí các hàng. Với các hành động cũng vậy, tuy nhiên tùy trường hợp chúng ta có thể làm mịn hơn bằng việc đánh số thứ tự hành động xảy ra thay cho dấu X để chỉ ra hành động nào cần làm trước. Với bảng quyết định tổng quát, các giá trị của điều kiện không chỉ nhận giá trị đúng (T) hoặc sai (F), khi đó ta cần tăng số cột để bao hết các tổ hợp có thể của các điều kiện.

**Bảng 5.10: Bảng quyết định để khắc phục sự cố máy in**

![](images/image2.png)

**Kỹ thuật thực hiện:** Để xác định các ca kiểm thử dựa trên bảng quyết định, ta dịch các điều kiện thành các đầu vào và các hành động thành các đầu ra. Đôi khi các điều kiện sẽ xác định các lớp tương đương của đầu vào và các hành động tương ứng với các mô-đun xử lý chức năng đang kiểm thử. Do đó mỗi cột tương ứng với một ca kiểm thử. Vì tất cả các cột bao phủ toàn bộ các tổ hợp đầu vào nên chúng ta có một bộ kiểm thử đầy đủ.
Trên thực tế không phải tổ hợp đầu vào nào cũng là hợp lệ, do đó khi sử dụng bảng quyết định người ta thường bổ sung thêm một giá trị đặc biệt “–” để đánh dấu các điều kiện không thể cùng xảy ra này. Các giá trị – (không quan tâm) có thể hiểu là luôn sai, không hợp lệ. Nếu các điều kiện chỉ là T và F ta có 2 _n_ cột qui tắc. Mỗi giá trị “–” sẽ đại diện cho hai cột. Để dễ kiểm tra không sót cột nào ta có thể thêm hàng đếm “Số luật” như trong Bảng 5.11 và khi tổng hàng này bằng 2 _n_ ta biết số cột qui tắc đã đủ.

**Bảng 5.11: Bảng quyết định cho hàm Triangle**

![](images/image3.png)

## Ví dụ minh họa

**Kiểm thử bằng bảng quyết định cho hàm Triangle:** Sử dụng bảng quyết định được mô tả ở Bảng 5.11, ta có 11 ca kiểm thử nhằm kiểm tra tính đúng đắn của hàm Triangle. Cụ thể, có ba (3) trường hợp không hợp lệ, ba (3) trường hợp không phải là tam giác, một (1) trường hợp tam giác đều, một (1) trường hợp tam giác thường và ba (3) trường hợp tam giác cân. Bảng 5.12 là kết
quả chi tiết về các ca kiểm thử này. Nếu ta thêm điều kiện kiểm tra bất đẳng thức tam giác ta sẽ có thêm ba (3) ca kiểm thử nữa (trường hợp một cạnh có độ dài bằng tổng hai cạnh còn lại).

**Bảng 5.12: Ca kiểm thử bằng bảng quyết định cho hàm Triangle**


| TT | a | b | c | Kết quả mong đợi |
| --- | --- | --- | --- | --- |
| 1 | 4 | 1 | 2 | Không phải tam giác |
| 2 | 1 | 4 | 2 | Không phải tam giác |
| 3 | 1 | 2 | 4 | Không phải tam giác |
| 4 | 5 | 5 | 5 | Tam giác đều |
| 5 | ? | ? | ? | Không khả thi |
| 6 | ? | ? | ? | Không khả thi |
| 7 | 2 | 2 | 3 | Tam giác cân |
| 8 | ? | ? | ? | Không khả thi |
| 9 | 2 | 3 | 2 | Tam giác cân |
| 10 | 3 | 2 | 2 | Tam giác cân |
| 11 | 3 | 4 | 5 | Tam giác thường |

 

**Kiểm thử bằng bảng quyết định cho hàm NextDate:** Có nhiều cách xác định các điều kiện. Ví dụ chúng ta sẽ đặc tả ngày và tháng trong năm và quy đổi về dạng của một năm nhuận hay một năm thông thường giống như trong lần thử đầu tiên, do đó năm 1900 sẽ không có gì đặc biệt. Các miền tương đương bây giờ như sau:

  * M1 = { tháng _|_ tháng có 30 ngày }


  * M2 = { tháng _|_ tháng có 31 ngày, trừ tháng 12 }


  * M3 = { tháng _|_ tháng 12 }


  * M4 = { tháng _|_ tháng 2 } 


Ngày

  * D1 = {ngày _|_ 1 _≤_ ngày _≤_ 27 }


  * D2 = {ngày _|_ ngày = 28 }


  * D3 = {ngày _|_ ngày = 29 }


  * D4 = {ngày _|_ ngày = 30 }


  * D5 = {ngày _|_ ngày = 31 } 


Năm

  * Y1 = {năm _|_ năm nhuận }


  * Y2 = {năm _|_ năm thông thường }


Trong khi tích Đề-các sẽ tạo ra 40 bộ giá trị nếu áp dụng kiểm thử lớp tương đương mạnh, bảng quyết định được lập như Bảng 5.13 chỉ cần 22 bộ giá trị ứng với 22 ca kiểm thử. Có 22 quy tắc, so với 36 trong thử lần hai. Chúng ta có một bảng quyết định với 22 quy tắc. Năm quy tắc đầu tiên cho tháng có 30 ngày. Hai bộ tiếp theo (6-10 và 11-15) cho tháng có 31 ngày, với các tháng khác Tháng Mười Hai và với Tháng Mười Hai.

# Public_064

Trong chương này, chúng ta sẽ tìm hiểu chi tiết về phương pháp kiểm thử dòng điều khiển (control flow testing) nhằm phát hiện các lỗi tiềm ẩn bên trong chương trình/đơn vị chương trình cần kiểm thử. Các lỗi này thường khó phát hiện bởi các kỹ thuật kiểm thử chức năng hay kiểm thử hộp đen được trình bày trong chương 5. Để áp dụng phương pháp này, chúng ta cần phân tích mã nguồn và xây dựng các ca kiểm thử ứng với các dòng điều khiển của chương trình/đơn vị chương trình. Các độ đo hay tiêu chí kiểm thử cho phương pháp này cũng sẽ được giới thiệu.

# Kiểm thử hộp trắng

Kiểm thử hộp trắng sử dụng các chiến lược cụ thể và sử dụng mã nguồn của chương trình/đơn vị phần mềm cần kiểm thử nhằm kiểm tra xem chương trình/đơn vị phần mềm có thực hiện đúng so với thiết kế và đặc tả hay không. Trong khi các phương pháp kiểm thử hộp đen hay kiểm thử chức năng chỉ cho phép phát hiện các lỗi/khiếm khuyết có thể quan sát được, kiểm thử hộp trắng cho phép phát hiện các lỗi/khiếm khuyết tiềm ẩn bên trong chương trình/đơn vị phần mềm. Các lỗi này thường khó phát hiện bởi các phương pháp kiểm thử hộp đen. Khác với các phương pháp kiểm thử hộp đen nơi mà các ca kiểm thử được sinh ra từ đặc tả của hệ thống, các ca kiểm thử trong các phương pháp kiểm thử hộp trắng được sinh ra từ mã nguồn. Kiểm thử hộp đen và kiểm thử hộp trắng không thể thay thế cho nhau mà chúng cần được sử dụng kết hợp với nhau trong một quy trình kiểm thử thống nhất nhằm đảm bảo chất lượng phần mềm. Tuy nhiên, để áp dụng các phương pháp kiểm thử hộp trắng, người kiểm thử không chỉ cần hiểu rõ giải thuật mà còn cần có các kỹ năng và kiến thức tốt về ngôn ngữ lập trình được dùng để phát triển phần mềm, nhằm hiểu rõ mã nguồn của chương trình/đơn vị phần mềm cần kiểm thử. Do vậy, việc áp dụng các phương pháp kiểm thử hộp trắng thường tốn thời gian và công sức nhất là khi chương trình/đơn vị phần mềm có kích thước lớn. Vì lý do này, các phương pháp kiểm thử hộp trắng chủ yếu được sử dụng cho kiểm thử đơn vị [D.95].
Hai phương pháp được sử dụng trong kiểm thử hộp trắng là kiểm thử dòng điều khiển (control flow testing) và kiểm thử dòng dữ liệu (data flow testing). Phương pháp kiểm thử dòng điều khiển tập trung kiểm thử tính đúng đắn của các giải thuật sử dụng trong các chương trình/đơn vị phần mềm. Phương pháp kiểm thử dòng dữ liệu tập trung kiểm thử tính đúng đắn của việc sử dụng các biến dữ liệu sử dụng trong chương trình/đơn vị phần mềm. Trong chương này, chúng ta sẽ tìm hiểu chi tiết về phương pháp kiểm thử dòng điều khiển. Phương pháp kiểm thử dòng dữ liệu sẽ được giới thiệu trong chương 7.

# Đồ thị dòng điều khiển

Phương pháp kiểm thử dòng điều khiển dựa trên khái niệm đồ thị dòng điều khiển (control flow graph). Đồ thị này được xây dựng từ mã nguồn của chương trình/đơn vị chương trình. Đồ thị dòng điều khiển là một đồ thị có hướng gồm các đỉnh tương ứng với các câu lệnh/nhóm câu lệnh và các cạnh là các dòng điều khiển giữa các câu lệnh/nhóm câu lệnh. Nếu _i_ và _j_ là các đỉnh của đồ thị dòng điều khiển thì tồn tại một cạnh từ _i_ đến _j_ nếu lệnh tương ứng với _j_ có thể được thực hiện ngay sau lệnh tương ứng với _i_.
Xây dựng một đồ thị dòng điều khiển từ một chương trình/đơn vị chương trình khá đơn giản. Hình 6.1 mô tả các thành phần cơ bản của đồ thị dòng điều khiển bao gồm điểm bắt đầu của đơn vị chương trình, khối xử lý chứa các câu lệnh khai báo hoặc tính toán, điểm quyết định ứng với các câu lệnh điều kiện trong các khối lệnh rẽ nhánh hoặc lặp, điểm nối ứng với các câu lệnh ngay sau các lệnh rẽ nhánh, và điểm kết thúc ứng với điểm kết thúc của đơn vị chương trình. Các cấu trúc điều khiển phổ biến của chương trình được mô tả trong Hình 6.2. Chúng ta sẽ sử dụng các thành phần cơ bản và các cấu trúc phổ biến này để dễ dàng xây dựng đồ thị dòng điều khiển cho mọi đơn vị chương trình viết bằng mọi ngôn ngữ lập trình.
**Hình 6.1: Các thành phần cơ bản của đồ thị chương trình.** ![](images/image1.png)
**Hình 6.2: Các cấu trúc điều khiển phổ biến của chương trình.** ![](images/image2.png)
Chúng ta thử xem cách dựng đồ thị dòng điều khiển cho đơn vị chương trình có mã nguồn bằng ngôn ngữ C như Hình 6.3. Chúng ta đánh số các dòng lệnh của đơn vị chương trình và lấy số này làm đỉnh của đồ thị. Điểm xuất phát của đơn vị chương trình ứng với câu lệnh khai báo hàm foo. Đỉnh 1 ứng với câu lệnh khai báo biến _e_. Các đỉnh 2 và 3 ứng với câu lệnh if. Đỉnh 4 ứng với câu lệnh khai báo biến _x_ trong khi các đỉnh 5 và 6 ứng với câu lệnh if. Đỉnh 7,8 đại diện cho hai câu lệnh 7 và 8. Trong trường hợp này, chúng ta không tách riêng thành hai đỉnh vì đây là hai câu lệnh tuần tự nên chúng ta ghép chúng thành một đỉnh nhằm tối thiểu số đỉnh của đồ thị dòng điều khiển. Với cách làm này, chúng ta xây dựng được đồ thị dòng điều khiển với số đỉnh nhỏ nhất. Chúng ta sẽ sử dụng đồ thị này để phân tích và sinh các ca kiểm thử nên đồ thị càng ít đỉnh thì độ phức tạp của thuật toán phân tích càng nhỏ.

![](images/image3.png)

**Hình 6.3: Mã nguồn của hàm** foo **và đồ thị dòng điều khiển của nó.**

# Các độ đo kiểm thử

Kiểm thử chức năng (kiểm thử hộp đen) có hạn chế là chúng ta không biết có thừa hay thiếu các ca kiểm thử hay không so với chương trình cài đặt và thiếu thừa ở mức độ nào. Độ đo kiểm thử là một công cụ giúp ta đo mức độ bao phủ chương trình của một tập ca kiểm thử cho trước. Mức độ bao phủ của một bộ kiểm thử (tập các ca kiểm thử) được đo bằng tỷ lệ các thành phần thực sự được kiểm thử so với tổng thể sau khi đã thực hiện các ca kiểm thử. Thành phần liên quan có thể là câu lệnh, điểm quyết định, điều kiện con, đường thi hành hay là sự kết hợp của chúng. Độ bao phủ càng lớn thì độ tin cậy của bộ kiểm thử càng cao. Độ đo này giúp chúng ta kiểm soát và quản lý quá trình kiểm thử tốt hơn. Mục tiêu của chúng ta là kiểm thử với số ca kiểm thử tối thiểu nhưng đạt được độ bao phủ tối đa. Có rất nhiều độ đo kiểm thử đang được sử dụng hiện nay, dưới đây là ba độ đo kiểm thử đang được sử dụng phổ biến nhất trong thực tế [Lee03].
**Độ đo kiểm thử cấp 1 (** _C_ 1 **):** mỗi câu lệnh được thực hiện ít nhất một lần sau khi chạy các ca kiểm thử (test cases). Ví dụ, với hàm foo có mã nguồn như trong Hình 6.3, ta chỉ cần hai ca kiểm thử như Bảng 6.1 là đạt 100% độ phủ cho độ đo _C_ 1 với EO (expected output) là giá trị đầu ra mong đợi và RO (real output) là giá trị đầu ra thực tế (giá trị này sẽ được điền khi thực hiện ca kiểm thử).
**Bảng 6.1: Các ca kiểm thử cho độ đo** _C_ 1 **của hàm** foo


| ID | Inputs | EO | RO | Note |
| --- | --- | --- | --- | --- |
| tc1 | 0, 1, 2, 3 | 0 |  |  |
| tc2 | 1, 1, 2, 3 | 1 |  |  |

 

**Độ đo kiểm thử cấp 2 (** _C_ 2 **):** các điểm quyết định trong đồ thị dòng điều khiển của đơn vị kiểm thử đều được thực hiện ít nhất một lần cả hai nhánh đúng và sai. Ví dụ, Bảng 6.2 mô tả các trường hợp cần kiểm thử để đạt được 100% độ phủ của độ đo _C_ 2 ứng với hàm foo được mô tả trong Hình 6.3.
**Bảng 6.2: Các trường hợp cần kiểm thử của độ đo** _C_ 2 **với hàm** foo


| Điểm quyết định | Điều kiện tương ứng | Đúng | Sai |
| --- | --- | --- | --- |
| 2 | a==0 | tc1 | tc2 |
| 5 | (a == b) || (c == d) | tc2 | ? |

 

Như vậy, với hai ca kiểm thử trong độ đo kiểm thử cấp 1 (tc1 và tc2), ta chỉ kiểm thử được 3/4 = 75% ứng với độ đo kiểm thử cấp 2. Chúng ta cần một ca kiểm thử nữa ứng với trường hợp sai của điều kiện (a == b) || (c == d) nhằm đạt được 100% độ phủ của độ đo _C_ 2. Bảng 6.3 mô tả các ca kiểm thử cho mục đích này.
**Bảng 6.3: Các ca kiểm thử cho độ đo** _C_ 2 **của hàm** foo


| ID | Inputs | EO | RO | Note |
| --- | --- | --- | --- | --- |
| tc1 | 0, 1, 2, 3 | 0 |  |  |
| tc2 | 1, 1, 2, 3 | 1 |  |  |
| tc3 | 1, 2, 1, 2 | Lỗi chia cho 0 |  |  |

 

**Độ đo kiểm thử cấp 3 (** _C_ 3 **):** Với các điều kiện phức tạp (chứa nhiều điều kiện con cơ bản), việc chỉ quan tâm đến giá trị đúng sai là không đủ để kiểm tra tính đúng đắn của chương trình ứng với điều kiện phức tạp này. Ví dụ, nếu một điều kiện phức tạp gồm hai điều kiện con cơ bản, chúng ta có bốn trường hợp cần kiểm thử chứ không phải hai trường hợp đúng sai như độ đo _C_ 2. Với các đơn vị chương trình có yêu cầu cao về tính đúng đắn, việc tuân thủ độ đo _C_ 3 là hết sức cần thiết. Điều kiện để đảm bảo độ đo này là các điều kiện con thuộc các điều kiện phức tạp tương ứng với các điểm quyết định trong đồ thị dòng điều khiển của đơn vị cần kiểm thử đều được thực hiện ít nhất một lần cả hai nhánh đúng và sai. Ví dụ, Bảng 6.4 mô tả các trường hợp cần kiểm thử để đạt được 100% độ phủ của độ đo _C_ 3 ứng với hàm foo được mô tả trong Hình 6.3. Như vậy, với ba ca kiểm thử trong độ đo kiểm thử cấp 2 (tc1, tc2 và tc3), ta chỉ kiểm thử được 7/8 = 87,5% ứng với độ đo kiểm thử cấp 3. Chúng ta cần một ca kiểm thử nữa ứng với trường hợp sai của điều kiện con cơ bản (c == d) nhằm đạt được 100% độ phủ của độ đo _C_ 3. Bảng 6.5 mô tả các ca kiểm thử cho mục đích này.
**Bảng 6.4: Các trường hợp cần kiểm thử của độ đo** _C_ 3 **với hàm** foo


| Điểm quyết định | Điều kiện tương ứng | Đúng | Sai |
| --- | --- | --- | --- |
| 2 | a==0 | tc1 | tc2 |
| 5 | (a == b) | tc2 | tc3 |
| 5 | (c == d) | ? | tc2 |

 

**Bảng 6.5: Các ca kiểm thử cho độ đo** _C_ 3 **của hàm** foo


| ID | Inputs | EO | RO | Note |
| --- | --- | --- | --- | --- |
| tc1 | 0, 1, 2, 3 | 0 |  |  |
| tc2 | 1, 1, 2, 3 | 1 |  |  |
| tc3 | 1, 2, 1, 2 | Lỗi chia cho 0 |  |  |
| tc4 | 1, 2, 1, 1 | 1 |  |  |

# Public_065

# Kiểm thử dựa trên lát cắt

Kiểm thử dòng dữ liệu như đã trình bày ở trên là một phương pháp tốt nhằm phát hiện các lỗi tiềm tàng bên trong các đơn vị chương trình. Tuy nhiên, độ phức tạp của phương pháp này rất lớn. Với các đơn vị chương trình có kích thước lớn, phương pháp này khá tốn kém. Trong thực tế, để áp dụng phương pháp này, chúng ta không cần phân tích tất cả các câu lệnh thuộc đơn vị chương trình cần kiểm thử. Với mỗi biến, chỉ có một tập con các câu lệnh có liên quan (khai báo, gán giá trị và sử dụng) đến biến này. Dựa trên quan sát này, phương pháp kiểm thử chương trình dựa trên lát cắt được đề xuất nhằm giảm thiểu độ phức tạp trong việc sinh các ca kiểm thử của phương pháp kiểm thử dòng dữ liệu.

## Ý tưởng về kiểm thử dựa trên lát cắt

Các lát cắt chương trình đã từng có những bước thăng trầm trong ngành công nghệ phần mềm kể từ đầu những năm 1980. Chúng được đề xuất bởi Weiser [Mar81, Mar84], được dùng như là một phương pháp tiếp cận bảo trì phần mềm, và gần đây nhất chúng được sử dụng như là một cách để kết dính các chức năng. Một phần sự linh hoạt này là do tính tự nhiên cũng như mục đích rõ ràng của lát cắt chương trình.
Thông thường, một lát cắt chương trình là một phần chương trình có ảnh hưởng tới giá trị của biến tại một vị trí trong chương trình. Hình 7.7 là một ví dụ về một lát cắt chương trình ứng với biến _sum_ (phần bên phải). Lát cắt này có được bằng cách lựa chọn các câu lệnh có ảnh hưởng đến biến _sum_ từ đoạn chương trình phía bên trái. Các câu lệnh int product = 1;, product = product*i;, và printf("product␣=␣%d",product); không có ảnh hưởng đến biến
_sum_ nên đã bị loại bỏ khỏi lát cắt này.
Chúng ta sẽ bắt đầu bằng việc định nghĩa thế nào là một lát cắt chương trình. Giả sử ta có một chương trình ký hiệu là _P_ , đồ thị của chương trình là _G_ ( _P_ ), và tập các biến của chương trình là _V_ . Sau đây, chúng ta sẽ tìm hiểu chi tiết về kỹ thuật kiểm thử dựa trên lát cắt.
**Hình 7.7: Một ví dụ về lát cắt chương trình.**
![](images/image1.png)
**Định nghĩa 7.29.** (Lát cắt.) Cho một chương trình _P_ và _V_ là tập các biến trong chương trình này. Một lát cắt trên _V_ tại câu lệnh _n_ , kí hiệu _S_ ( _V, n_ ), là tập tất các lệnh trong _P_ có góp phần làm thay đổi giá trị của tập biến trong _V_ .
Tuy nhiên, định nghĩa trên còn khá chung chung nên rất khó để xác định _S_ ( _V, n_ ). Định nghĩa sau giúp chúng ta giải quyết vấn đề này.
**Định nghĩa 7.30.** (Lát cắt chương trình.) Cho một chương trình _P_ với đồ thị chương trình _G_ ( _P_ ) (trong đó các câu lệnh và các đoạn câu lệnh được đánh số) và một tập các biến _V_ trong _P_ , lát cắt trên tập biến _V_ tại đoạn câu lệnh _n_ , ký hiệu là _S_ ( _V, n_ ), là tập các số nút của tất cả các câu lệnh và đoạn câu lệnh trong _P_ “trước thời điểm” _n_ “ảnh hưởng” đến các giá trị của các biến trong _V_ tại đoạn mã lệnh thứ _n_ [Jor13].
Trong định nghĩa trên, thuật ngữ “các đoạn câu lệnh” có nghĩa là một câu lệnh có thể là một câu lệnh phức do vậy ta có thể tách các câu lệnh này thành từng câu lệnh riêng biệt. Ví dụ, câu lệnh phức int intMin=0, intMax=100; sẽ được tách thành hai câu lệnh đơn int intMin=0; và int intMax=100;. Khái niệm “trước thời điểm” _n_ “ảnh hưởng” không có nghĩa là thứ tự các câu lệnh mà là thời điểm trước khi câu lệnh đó được thực hiện. Ví dụ, trong hàm tính tổng các số chẵn nhỏ hơn _n_ như Đoạn mã 7.3, câu lệnh i++; đứng sau nhưng lại ảnh hưởng trực tiếp đến câu lệnh result += i;.
**Đoạn mã 7.3: Hàm tính tổng các số chẵn nhỏ hơn** _n_
int Tong Cac So Chan ( int n){ int i = 0;
int result = 0; while ( i < n){
if( i%2 == 0){
result += i;
} i++;
}
return result;
}
Ý tưởng của các lát cắt là để tách một chương trình thành các thành phần, mỗi một thành phần có một số ý nghĩa nhất định. Các phần ảnh hưởng tới giá trị của các biến đã được giới thiệu trong mục 7.1.5 bằng việc sử dụng các định nghĩa và sử dụng của từng biến ( _Def_ , _C_ - _use_ , _P_ - _use_ ), nhưng chúng ta cần phải tinh chỉnh lại một số hình thức sử dụng biến. Cụ thể là mối quan hệ sử dụng ( _Use_ ) của biến gắn liền với năm hình thức sử dụng như sau.

  * _P_ - _use_ : Biến được sử dụng trong các câu lệnh rẽ nhánh. Ví dụ, if(x>0){...}


  * _C_ - _use_ : Biến được sử dụng trong các câu lệnh tính toán. Ví dụ, x = x + y;


  * _O_ - _use_ : Biến được sử dụng cho các câu lệnh hiển thị hoặc trả về kết quả. Ví dụ, return x; hoặc printf("%d",x);

  * _L_ - _use_ : Biến được sử dụng như một con trỏ trỏ đến các địa chỉ hoặc chỉ số của mảng. Ví dụ, int x =100, *ptr; ptr = &x;

  * _I_ - _use_ : Biến được sử dụng như các biến đếm (trong các vòng lặp). Ví dụ, i++;


Chúng ta cũng có hai dạng xác định giá trị cho các biến như sau:

  * _I_ - _def_ : xác định từ đầu vào (từ bàn phím, truyền tham số, v.v.)


  * _A_ - _def_ : xác định từ phép gán


Giả sử lát cắt _S_ ( _V, n_ ) là một lát cắt trên một biến, ở đây tập
_V_ chỉ chứa một biến _v_ duy nhất. Nếu nút _n_ chứa một định nghĩa của _v_ thì ta thêm _n_ vào lát cắt _S_ ( _V, n_ ). Ngược lại, nếu nút _n_ chứa một sử dụng của biến _v_ ∈ _V_ thì _n_ không được thêm vào lát cắt _S_ ( _V, n_ ). Những nút chứa _P_ - _use_ và _C_ - _use_ của các biến khác (không phải biến _v_ trong tập _V_ ) mà ảnh hưởng trực tiếp hoặc gián tiếp tới giá trị của biến _v_ thì được thêm vào tập _V_ . Đối với lát cắt _S_ ( _V, n_ ), những định nghĩa và sử dụng của các biến sau được thêm vào lát cắt _S_ ( _V, n_ ).

  * Tất cả các _I_ - _def_ và _A_ - _def_ của biến _v_

  * Tất cả các _C_ - _use_ và _P_ - _use_ của biến _v_ sao cho nếu loại bỏ nó sẽ làm thay đổi giá trị của _v_


  * Tất cả các _P_ - _use_ và _C_ - _use_ của các biến khác (không phải biến _v_ ) sao cho nếu loại bỏ nó thì sẽ làm thay đổi giá trị của biến _v_


  * Loại bỏ khỏi lát cắt các _I_ - _use_ , _L_ - _use_ và _O_ - _use_ của biến _v_

  * Loại bỏ toàn bộ các câu lệnh không được thực thi như các câu lệnh khai báo biến

  * Kiểm tra các hằng số, nếu hằng số đó ảnh hưởng đến biến _v_


thì ta thêm hằng số đó vào lát cắt

## Ví dụ áp dụng

Quay trở lại với ví dụ về hàm ReturnAverage được trình bày ở Đoạn mã 7.2 trong mục 7.1.4, để áp dụng kỹ thuật kiểm thử dựa trên lát cắt, chúng ta phân mảnh hàm này như Đoạn mã 7.4. Tiếp đến, chúng ta xây dựng đồ thị của hàm sau khi phân mảnh như hình 7.8. Sau đó, chúng ta cũng sẽ định nghĩa lại các định nghĩa ( _Def_ ) và sử dụng ( _Use_ ) của các biến trong các bảng 7.3 và 7.4. Và cuối cùng, các lát cắt trên từng biến của hàm sẽ được tính toán.
**Đoạn mã 7.4: Mã nguồn hàm** ReturnAverage **sau khi phân mảnh** double Return Average ( int value [], int AS , int MIN , int MAX ){
int i = 0; int ti = 0; int tv = 0; int sum = 0; double av;
while ( ti < AS && value [ i] != -999) { ti++;
if ( value [ i] >= MIN && value [ i] <= MAX ) { tv ++;
sum = sum + value [ i];
} i++;
} _// end while_
if ( tv > 0)

# Public_066

Chương này giới thiệu phương pháp và một số công cụ hỗ trợ kiểm thử dựa trên mô hình nhằm tăng tính hiệu quả và độ chính xác của các hoạt động kiểm thử. Kiểm thử dựa trên mô hình có thể sử dụng với nhiều mục đích khác nhau trong việc tự động hóa các hoạt động kiểm thử. Chúng tôi giới thiệu phương pháp này nhằm kiểm tra tính đúng đắn của việc lập trình so với thiết kế. Các phương pháp và công cụ hỗ trợ kiểm thử dựa trên mô hình có vai trò hết sức quan trọng trong việc nâng cao chất lượng của các sản phẩm và tăng tính cạnh tranh cho các công ty phần mềm.

# Khái niệm về kiểm thử dựa trên mô hình

Có nhiều khái niệm khác nhau về kiểm thử dựa trên mô hình. Tựu trung lại, chúng ta có thể hiểu kiểm thử dựa trên mô hình là một phương pháp kiểm thử nơi mà các ca kiểm thử được sinh ra từ mô hình đặc tả hành vi của hệ thống đang được kiểm thử. Mô hình này được biểu diễn bằng máy hữu hạn trạng thái, ôtômat, đặc tả đại số, biểu đồ trạng thái bằng UML, v.v.

Quá trình kiểm thử dựa trên mô hình được bắt đầu bằng việc xác định yêu cầu của hệ thống từ đó xây dựng mô hình dựa vào các yêu cầu và chức năng của hệ thống. Việc xây dựng mô hình còn phải dựa trên các yếu tố dữ liệu đầu vào và đầu ra. Mô hình này được sử dụng để sinh đầu vào cho các ca kiểm thử. Tiếp đến, chúng ta sẽ sinh giá trị đầu ra mong muốn ứng với mỗi bộ đầu vào. Khi kết thúc bước này, chúng ta đã có các ca kiểm thử. Các kịch bản kiểm thử sẽ được thiết kế và thực thi nhằm phát hiện các lỗi/khiếm khuyết của sản phẩm bằng cách so sánh đầu ra thực tế với đầu ra mong đợi tương ứng của ca kiểm thử. Từ các kết quả kiểm thử, chúng ta sẽ quyết định hành động tiếp theo như sửa đổi mô hình hoặc dừng kiểm thử.

Hình 8.1 mô tả các bước của quy trình kiểm thử dựa trên mô hình, bao gồm:

**Hình 8.1: Quy trình kiểm thử dựa trên mô hình [KJ02].** ![](images/image1.png)

  * Sinh mô hình dựa trên các yêu cầu và chức năng của hệ thống.


  * Sinh các ca kiểm thử (bộ đầu vào và giá trị đầu ra mong đợi cho mỗi ca kiểm thử).


  * Chạy các kịch bản kiểm thử để phát hiện các lỗi/khiếm khuyết của sản phẩm.

  * So sánh kết quả đầu ra thực tế với kết quả đầu ra dự kiến.


  * Quyết định hành động tiếp theo (sửa đổi mô hình, tạo thêm ca kiểm thử, dừng kiểm thử, đánh giá chất lượng của phần mềm).


# Các phương pháp đặc tả mô hình

Để áp dụng phương pháp kiểm thử dựa trên mô hình, chúng ta cần xây dựng mô hình đặc tả chính xác hành vi của hệ thống cần kiểm thử. Mô hình này được đặc tả bằng một trong các phương pháp hình thức như: máy hữu hạn trạng thái, biểu đồ trạng thái, máy trạng thái UML, chuỗi Markov, văn phạm, bảng quyết định,

v.v. Trong mục này, chúng ta sẽ tìm hiểu một số phương pháp hình thức phổ biến được sử dụng để đặc tả mô hình của các hệ thống.

## Máy hữu hạn trạng thái

Máy hữu hạn trạng thái (Finite State Machine - FSM) được biết đến như là phương pháp đặc tả phổ biến nhất cho thiết kế và kiểm thử phần mềm nói riêng và các hệ thống nói chung. FSM rất hiệu quả trong việc đặc tả hành vi dựa trên việc chuyển trạng thái của các hệ thống. Một cách hình thức, FSM được định nghĩa như sau.

**Định nghĩa 8.1** (Máy hữu hạn trạng thái) **.** Máy hữu hạn trạng thái là một bộ bốn ( _S, Act, T, q_ 0), trong đó _S_ là tập hữu hạn các trạng thái, _T_ là tập các chuyển trạng thái, _Act_ là các tập các sự kiện (còn có tên khác là bảng ký hiệu) và _q_ 0 là trạng thái khởi tạo.

![](images/image2.png)

**Hình 8.2: Một ví dụ về máy hữu hạn trạng thái.**

**Bảng 8.1: Bảng chuyển của máy hữu hạn trạng thái trong hình 8.2**


|  | off | dim | normal | bright |
| --- | --- | --- | --- | --- |
| off |  |  | turn on |  |
| dim | turn off |  | incr. intensity |  |
| normal | turn off | decr. intensity |  | incr. intensity |
| bright | turn off |  | decr. intensity |  |

 

Hình 8.2 mô tả một ví dụ về một máy hữu hạn trạng thái đặc tả hành vi của một hệ thống chuyển công tắc đèn [KJ02]. Trong hình này, _off_ là trạng thái khởi đầu của hệ thống. Ở trạng thái này, đèn đang bị tắt. Với đầu vào là _turn on_ , hệ thống sẽ chuyển đến trạng thái _normal_ với đèn có độ sáng bình thường. Tại trạng thái này, chúng ta có thể tắt đèn (ứng với đầu vào _turn off_ và hệ thống sẽ chuyển về trạng thái _off_ ), tăng độ sáng của đèn (ứng với đầu vào _increase intensity_ và hệ thống sẽ chuyển về trạng thái _bright_ ) và giảm độ sáng của đèn (ứng với đầu vào _decrease intensity_ và hệ thống sẽ chuyển về trạng thái _dim_ ). Tại các trạng thái _dim_ và _bright_ , chúng ta có thể tắt đèn, tăng và giảm độ sáng tương ứng. Bảng 8.1 là một dạng đặc tả khác của máy hữu hạn trạng thái trên dưới dạng bảng chuyển. Chúng ta sẽ dùng cấu trúc dữ liệu này làm đầu vào cho các công cụ kiểm thử tự động.

## Ôtômat đơn định hữu hạn trạng thái

Tương tự như FSM, ôtômat đơn định hữu hạn trạng thái (Deter- ministic Finite state Automaton - DFA) cũng rất hiệu quả trong việc đặc tả hành vi dựa trên việc chuyển trạng thái của các hệ thống. Một cách hình thức, DFA được định nghĩa như sau.

**Định nghĩa 8.2** (Ôtômat đơn định hữu hạn trạng thái) **.** Ôtômat đơn định hữu hạn trạng thái là một bộ năm ( _S, Act, T, q_ 0 _, F_ ), trong đó: _S_ , _T_ , _Act_ và _q_ 0 được định nghĩa như trong định nghĩa của FSM, và _F_ ⊆ _S_ là tập các trạng thái kết thúc.

Một ví dụ minh họa về việc áp dụng DFA cho đặc tả hành vi của hệ thống trong kiểm thử dựa trên mô hình sẽ được giới thiệu trong mục 8.6.

## Biểu đồ trạng thái

Hình 8.3 mô tả ví dụ về một biểu đồ trạng thái đặc tả hành vi của một máy nghe nhạc. Trong biểu đồ này, trạng thái _CD_Insert_ gồm hai trạng thái con (Include/Select Track và Include/Mode). Hai trạng thái này hoạt động đồng thời. Khi chèn một CD vào máy nghe nhạc, chúng ta có thể chọn bài hát và xem thông tin của nó hoặc chúng ta có thể chọn bài hát và nghe. Cả hai chế độ này được thực hiện tại cùng một thời điểm. Một cách khác, chúng ta có thể nói _CD_Insert_ là một “trạng thái ghép nối” với tính đồng thời. Đây chính là sự khác biệt chính của biểu đồ trạng thái so với máy hữu hạn trạng thái. Bởi cách biểu diễn này, biểu đồ trạng thái có thể đặc tả hệ thống với ít trạng thái hơn và vì vậy nó giảm độ phức tạp cho quá trình đặc tả và kiểm thử/kiểm chứng sau này.

**Hình 8.3: Một ví dụ về biểu đồ trạng thái [BBH05].** ![](images/image3.png)

## Máy trạng thái UML

Các phương pháp đặc tả hình thức như máy hữu hạn trạng thái, biểu đồ trạng thái, v.v. giúp ta đặc tả các hệ thống một cách chính xác với ý nghĩa duy nhất (vì chúng sử dụng các công cụ toán học). Tuy nhiên, các phương pháp này thường khó được áp dụng trong công nghiệp vì chúng đòi hỏi các chuyên gia về đặc tả hình thức.

Máy trạng thái UML được xem là giải pháp tốt để giải quyết vấn đề này. Nó có thể được sử dụng để đặc tả hành vi động (chuyển trạng thái) của các lớp đối tượng, các ca sử dụng (use cases), các hệ thống con và thậm chí là toàn bộ hệ thống. Tuy nhiên, máy trạng thái UML thường được sử dụng cho các lớp đối tượng. Theo [AJ00], biểu đồ cộng tác đặc tả bằng UML là một mô hình quan trọng trong việc kiểm thử hệ thống bởi mô hình này đặc tả chính xác hành vi (tương tác giữa các đối tượng) của hệ thống cần kiểm thử.

Trong UML, một trạng thái ứng với một điều kiện quan trọng của một đối tượng. Trạng thái này được quyết định bởi các giá trị hiện thời của đối tượng, các mối quan hệ với các đối tượng khác và các hành động (phương thức) mà đối tượng này thực hiện. Một phép chuyển trạng thái là mối quan hệ giữa hai trạng thái. Một phép chuyển trạng thái trong UML bao gồm một sự kiện được kích hoạt, điều kiện và hành động tương ứng. Các sự kiện được kích hoạt của các phép chuyển trạng thái có thể là một trong các sự kiện sau:

  * Một lời gọi ứng với một phương thức


  * Một tín hiệu nhận được từ các trạng thái khác trong máy trạng thái


  * Một sự thay đổi giá trị của một thuộc tính nào đó của một đối tượng


  * Hết thời gian (timeout)


Hình 8.4 là ví dụ về một máy trạng thái UML đặc tả hành vi của hệ thống quản lý bán hàng.

**Hình 8.4: Một ví dụ về máy trạng thái UML.** ![](images/image4.png)

## Các phương pháp đặc tả khác

Ngoài những phương pháp đặc tả trên, có rất nhiều phương pháp đặc tả khác đã được đề xuất. Một số phương pháp đặc tả phổ biến như: mạng Petri (xem mục 3.6.3.2), chuỗi Markov, văn phạm, bảng quyết định/cây quyết định, ngôn ngữ ràng buộc đối tượng (OCL), các ngôn ngữ đặc tả đại số (Z, OBJ, v.v.), v.v. Phụ thuộc vào phương pháp và công cụ kiểm thử, chúng ta sẽ lựa chọn phương pháp đặc tả hệ thống tương ứng.

# Public_067

Kiểm thử đang được xem là giải pháp chủ yếu nhằm đảm bảo chất lượng cho các sản phẩm phần mềm. Tuy nhiên, các hoạt động kiểm thử hiện nay chủ yếu được thực hiện một cách thủ công và tiêu tốn khoảng 30-50% tài nguyên (thời gian, nhân lực và chi phí) của quá trình phát triển sản phẩm phần mềm. Hơn nữa, độ phức tạp của các phần mềm ngày càng tăng và trong môi trường cạnh tranh như hiện nay đòi hỏi các công ty phần mềm phải áp dụng các phương pháp và công cụ nhằm tự động hóa các hoạt động kiểm thử. Hơn nữa, các công cụ kiểm thử tự động là một giải pháp hữu hiệu cho kiểm thử hồi quy. Chương này giới thiệu tổng quan về kiểm thử tự động và các công cụ hỗ trợ nhằm giải quyết vấn đề này.

# Tổng quan về kiểm thử tự động

Một thực tế đáng buồn hiện nay là chất lượng của hầu hết các sản phẩm phần mềm rất thấp. Hàng năm, chúng ta phải chịu thiệt hại nhiều tỷ đô la do các lỗi phần mềm gây ra [oST02a, G.95]. Theo thống kê của NIST công bố năm 2002 [oST02b], chất lượng phần mềm thấp đã gây thiệt hại cho kinh tế Mỹ 60 tỷ đô la mỗi năm và tiêu tốn khoảng 22 tỷ đô la cho việc phát triển các công cụ nhằm phát hiện các lỗi và kiểm thử tự động. Có hai lý do chính dẫn đến tình trạng này. Thứ nhất, hầu hết các công cụ hiện nay đều tập trung vào việc thực thi tự động các ca kiểm thử (auto-test execution) trong khi vấn đề cốt lõi của kiểm thử là các phương pháp và kỹ thuật sinh các ca kiểm thử vẫn còn thiếu. Thứ hai, các công cụ hiện nay chưa hỗ trợ một cách hiệu quả cho kiểm thử hồi quy (regression testing). Một khi phần mềm bị tiến hóa/thay đổi, chúng ta cần kiểm thử lại sản phẩm. Làm thế nào để sử dụng lại các ca kiểm thử đã có và sinh ra các ca kiểm thử mới một cách hiệu quả đang là một vấn đề mở và chưa có giải pháp thỏa đáng. Hơn nữa, một trong những vấn đề khó nhất của kiểm thử tự động đó là việc sinh các giá trị đầu ra mong đợi tương ứng với các đầu vào của các ca kiểm thử. Đây là một bài toán khó và chưa có giải pháp hiệu quả nhằm giải quyết vấn đề này.
Giải pháp chủ yếu để giải quyết các vấn đề trên là đề xuất các phương pháp và công cụ hỗ trợ tối đa các hoạt động trong quy trình kiểm thử phần mềm. Trong quy trình kiểm thử, chúng ta cần một số công cụ ứng với các pha và các mục tiêu kiểm thử khác nhau. Ví dụ, để tự động hóa chiến lược kiểm thử hộp đen, phương pháp kiểm thử dựa trên mô hình (model-based testing) đang được biết đến như là một giải pháp tin cậy và hiệu quả [MRA04, KJ02, BFM04]. Với kiểm thử hộp trắng, ứng với mỗi phương pháp khác nhau chúng ta cũng có rất nhiều công cụ hỗ trợ. Ngoài ra, một số công cụ hỗ trợ kiểm thử các tính chất phi chức năng như độ an toàn, bảo mật, hiệu năng và khả năng chịu tải, v.v., cũng đã được phát triển và sử dụng rộng rãi.
Kiểm thử tự động là quá trình thực hiện một cách tự động các bước trong một kịch bản kiểm thử. Kiểm thử tự động bằng một công cụ nhằm rút ngắn thời gian kiểm thử. Mục đích của kiểm thử tự động là giảm thiểu thời gian, công sức và kinh phí trong khi vẫn tăng độ tin cậy, tăng tính hiệu quả và giảm sự nhàm chán cho người kiểm thử trong quá trình kiểm thử sản phẩm phần mềm. Kiểm thử tự động sẽ được sử dụng khi dự án không đủ tài nguyên (thời gian, nhân lực và chi phí), phải thực hiện kiểm thử hồi quy khi sản phẩm được sửa đổi hoặc nâng cấp và cần kiểm thử lại các tính năng đã thực hiện tốt trước đó, kiểm tra khả năng vận hành của sản phẩm trong các môi trường đặc biệt (đo tốc độ xử lý trung bình ứng với mỗi yêu cầu, xác định khả năng chịu tải tối đa, xác định cấu hình tối thiểu để thực thi hệ thống, kiểm tra các cơ chế an ninh và an toàn, v.v.).

# Kiến trúc của một bộ công cụ kiểm thử tự động

Trong thức tế, có rất nhiều bộ công cụ hỗ trợ kiểm thử tự động được phát triển nhằm góp phần giải quyết các vấn đề khó khăn của quy trình kiểm thử. Hình 9.1 mô tả kiến trúc chung nhất của một bộ kiểm thử tự động [Som10]. Trong kiến trúc này, các công cụ kiểm thử được tích hợp trong một quy trình thống nhất nhằm hỗ trợ đầy đủ các hoạt động kiểm thử trong quy trình kiểm thử các sản phẩm phần mềm.
**Hình 9.1: Kiến trúc chung của một bộ kiểm thử tự động.** ![](images/image1.png)
Các công cụ cơ bản trong kiến trúc này bao gồm:

  * **Quản lý kiểm thử:** công cụ này cho phép quản lý việc thực hiện/thực thi các ca kiểm thử. Nó giám sát việc thực hiện từng ca kiểm thử ứng với bộ giá trị đầu vào, giá trị đầu ra mong muốn và giá trị đầu ra thực tế. JUnit là một ví dụ điển hình về công cụ này.

  * **Sinh các ca kiểm thử:** Đây là một trong những công cụ quan trọng nhất của các bộ kiểm thử tự động. Tùy thuộc vào các kỹ thuật kiểm thử được áp dụng, công cụ này sẽ sinh ra tập các ca kiểm thử (chưa gồm giá trị đầu ra mong muốn) cho chương trình/đơn vị chương trình cần kiểm thử. Các ca kiểm thử được sinh ra chỉ chứa giá trị đầu vào để thực hiện nó. Các giá trị này có thể được lựa chọn trong cơ sở dữ liệu hoặc được sinh một cách ngẫu nhiên.


  * **Sinh giá trị đầu ra mong muốn:** Các ca kiểm thử được sinh ra bởi công cụ trên chỉ chứa các giá trị ứng với các biến đầu vào. Công cụ này cho phép sinh ra giá trị đầu ra mong muốn ứng với mỗi bộ dữ liệu đầu vào của mỗi ca kiểm thử. Giá trị đầu ra mong muốn này sẽ được sử dụng để so sánh với giá trị đầu ra thực tế khi thực hiện ca kiểm thử này nhằm phát hiện ra các lỗi/khiếm khuyết của sản phẩm.

  * **So sánh kết quả kiểm thử:** Công cụ này so sánh giá trị đầu ra thực tế và giá trị đầu ra mong muốn của mỗi ca kiểm thử khi nó được thực hiện trên chương trình/đơn vị chương trình cần kiểm thử. Đối với mục đích kiểm thử phi chức năng, chúng ta không thể sử dụng cách làm này. Các giải pháp cho bài toán này sẽ được trình bày chi tiết trong chương 10.


  * **Tạo báo cáo kiểm thử:** Một trong những ưu điểm của các bộ công cụ kiểm thử tự động là nó có cơ chế sinh báo cáo kiểm thử một cách chính xác và nhất quán. Dựa vào kết quả của công cụ so sánh kết quả kiểm thử, công cụ này sẽ tự động sinh ra báo cáo kết quả kiểm thử theo định dạng mong muốn của đơn vị phát triển.


  * **Phân tích động:** Công cụ này cung cấp một cơ chế nhằm kiểm tra việc thực hiện của các câu lệnh của chương trình cần kiểm thử nhằm phát hiện ra các lỗi và phát hiện các câu lệnh/đoạn lệnh không được thực hiện bởi một tập các ca kiểm thử cho trước. Công cụ này cũng rất hiệu quả trong việc đánh giá tính hiệu quả của một bộ kiểm thử cho trước.


  * **Bộ mô phỏng:** Có nhiều loại mình mô phỏng được cung cấp trong các bộ kiểm thử tự động. Mục đích của các công cụ này là mô phỏng quá trình thực hiện của chương trình cần kiểm thử. Ví dụ, các công cụ mô phỏng giao diện người dùng cho phép thực hiện tự động các tương tác giữa người dùng và sản phẩm. Selenium1 là một ví dụ về một công cụ mô phỏng giao diện người dùng cho các ứng dụng Web.


Trong thực tế, các bộ công cụ kiểm thử tự động có thể có thêm một số công cụ khác như cho phép đặc tả các tính chất của hệ thống cần kiểm thử, vân vân. Một số bộ công cụ chỉ hỗ trợ một số công cụ trong các công cụ đã liệt kê ở trên.
Các công cụ hỗ trợ kiểm thử tự động rất đa dạng và phục vụ nhiều mục đích khác nhau. Hình 9.2 thể hiện các loại công cụ kiểm thử tự động ứng với từng pha trong quy trình phát triển phần mềm.

  * **Các công cụ quản lý:** các công cụ này phục vụ pha lập trình và quản lý quá trình này như quản lý phiên bản, quản lý thay đổi, v.v.

  * **Các công cụ phân tích tĩnh:** các công cụ này phục vụ pha lập trình và cho phép phân tích mã nguồn để tìm các lỗi hay gặp.

  * **Các công cụ phân tích độ phủ:** các công cụ này hỗ trợ pha kiểm thử đơn vị và cho phép phân tích độ bao phủ của một bộ kiểm thử đối với mã nguồn.

  * **Các công cụ gỡ lỗi:** các công cụ này cho phép định vị các lỗi được phát hiện bởi một ca kiểm thử.

  * **Các công cụ phân tích động:** các công cụ này hỗ trợ cả pha kiểm thử đơn vị và kiểm thử tích hợp. Chúng cho phép sinh ra các ca kiểm thử từ mã nguồn và thực thi chúng nhằm phát hiện các lỗi lập trình.

  * **Các công cụ mô phỏng, kiểm thử hiệu năng:** các công cụ này trợ giúp kiểm thử tự động hệ thống và kiểm thử chấp nhận. Chúng cho phép kiểm thử một số yêu cầu về hiệu năng của hệ thống như tính hiệu quả trong sử dụng tài nguyên, tính an toàn và bảo mật, khả năng chịu tải, v.v.

  * **Các công cụ thực thi và đánh giá các ca kiểm thử:** các công cụ này cho phép thực hiện/thực thi các ca kiểm thử và giám sát việc thực hiện từng ca kiểm thử ứng với bộ giá trị đầu vào, giá trị đầu ra mong muốn và giá trị đầu ra thực tế nhằm tạo báo cáo kiểm thử.

# Public068

# Thu thập và Tiền xử lý Dữ liệu Hình Ảnh

Để một hệ thống thị giác máy tính hoạt động hiệu quả, dữ liệu hình ảnh chất lượng cao là nền tảng quan trọng nhất. Việc thu thập dữ liệu không chỉ đơn thuần là “chụp ảnh”, mà đòi hỏi một quy trình bài bản:

  * Nguồn dữ liệu đa dạng: Kết hợp ảnh từ camera dây chuyền sản xuất, dữ liệu cảm biến quang học, và các bộ dữ liệu công khai như ImageNet hoặc Open Images.

  * Tiêu chuẩn hóa bối cảnh: Đảm bảo nhiều góc chụp, ánh sáng khác nhau, và các điều kiện sản xuất khác nhau để mô hình có khả năng tổng quát tốt.

  * Định dạng thống nhất: Giữ định dạng hình ảnh đồng nhất (JPEG/PNG) và độ phân giải tối thiểu Full HD nhằm duy trì chi tiết cần thiết cho phân tích.


Sau khi thu thập, dữ liệu phải trải qua tiền xử lý để tăng tính ổn định:

  * Cân bằng dữ liệu: Dùng kỹ thuật oversampling hoặc augmentation như xoay, lật, điều chỉnh độ sáng.

  * Loại bỏ nhiễu: Ứng dụng các bộ lọc như Gaussian blur hoặc median filter để giảm nhiễu cảm biến.

  * Chuẩn hóa kích thước: Đưa tất cả ảnh về cùng kích thước đầu vào của mô hình, thường là 224×224 hoặc 512×512 pixel.


Quy trình này đảm bảo dữ liệu “sạch”, đa dạng và nhất quán, là nền tảng để huấn luyện các mô hình thị giác máy tính công nghiệp đạt hiệu quả cao.

# Xây dựng Kiến trúc Mô hình

Sau khi có dữ liệu chất lượng, bước tiếp theo là thiết kế và lựa chọn kiến trúc mô hình phù hợp. Việc chọn kiến trúc dựa trên mục tiêu cụ thể:

  * Phân loại hình ảnh: Các kiến trúc CNN như ResNet, EfficientNet, DenseNet nổi bật nhờ khả năng trích xuất đặc trưng mạnh mẽ.

  * Phát hiện vật thể: Các mô hình YOLO (phiên bản mới nhất YOLOv8) hay Faster R-CNN được sử dụng để phát hiện lỗi sản phẩm trên dây chuyền.

  * Phân đoạn ảnh: U-Net, DeepLab, hay Mask R-CNN phù hợp cho việc khoanh vùng chính xác các vùng khuyết tật.

  * Xu hướng mới: Vision Transformer (ViT) và các mô hình hybrid CNN–Transformer giúp mô hình hiểu mối liên hệ xa trong ảnh, cải thiện hiệu năng trong môi trường phức tạp.


Chiến lược huấn luyện:

  * Pretraining + Fine-tuning: Khởi đầu với mô hình đã huấn luyện trên ImageNet, sau đó tinh chỉnh trên dữ liệu nội bộ.

  * Regularization: Dùng dropout, weight decay để giảm overfitting.

  * Augmentation online: Tạo biến thể ảnh trong suốt quá trình huấn luyện để tăng khả năng tổng quát.


Quá trình này giúp mô hình đạt độ chính xác cao trong thời gian huấn luyện tối ưu, đồng thời giảm yêu cầu về tài nguyên.

# Tích hợp và Triển khai Thực Tế

Sau khi mô hình đạt hiệu suất mong muốn, bước triển khai vào môi trường công nghiệp đòi hỏi sự phối hợp chặt chẽ giữa phần mềm và phần cứng:

  * Giao tiếp thời gian thực: Dịch vụ inference nên được triển khai dưới dạng API (REST/gRPC) để xử lý video trực tiếp từ camera.

  * Đồng bộ với PLC/SCADA: Hệ thống cần tương thích với các bộ điều khiển công nghiệp để tự động loại bỏ sản phẩm lỗi hoặc điều chỉnh dây chuyền.

  * Xử lý tại biên (Edge Computing): Đưa mô hình đã nén (quantization, pruning) lên các thiết bị như NVIDIA Jetson để giảm độ trễ và tiết kiệm băng thông.


Triển khai không chỉ là chạy mô hình, mà còn liên quan đến kiến trúc hệ thống:

  * Tách biệt microservices cho từng nhiệm vụ (xử lý hình ảnh, lưu trữ, giao diện).

  * Thiết kế dashboard trực quan cho phép kỹ sư giám sát luồng dữ liệu, trạng thái từng camera, và kết quả kiểm tra theo thời gian thực.


# Giám sát, Cập nhật và Bảo trì

Môi trường sản xuất thay đổi liên tục, từ ánh sáng cho tới cấu hình máy móc, dẫn đến hiện tượng drift dữ liệu – khi phân phối dữ liệu thực tế khác so với dữ liệu huấn luyện ban đầu.

  * Theo dõi drift dữ liệu: Sử dụng công cụ như EvidentlyAI hoặc WhyLabs để cảnh báo khi thống kê dữ liệu đầu vào thay đổi.

  * Huấn luyện định kỳ: Lập lịch huấn luyện lại (ví dụ hàng tháng) với dữ liệu mới để mô hình luôn phản ánh thực tế.

  * A/B Testing: Triển khai song song hai phiên bản mô hình để so sánh hiệu suất trước khi cập nhật chính thức.


Về bảo mật:

  * Mã hóa luồng video (TLS/SSL).

  * Phân quyền người dùng và ghi log chi tiết để truy xuất quyết định của mô hình khi cần điều tra.


Việc giám sát và bảo trì liên tục đảm bảo hệ thống hoạt động ổn định, tránh giảm hiệu năng khi môi trường thay đổi.

# Tối ưu Chi phí và Mở Rộng Hệ Thống

Để giải pháp thị giác máy tính bền vững và có thể mở rộng:

  * Điện toán đám mây lai: Kết hợp cloud và edge giúp giảm chi phí băng thông nhưng vẫn đảm bảo khả năng xử lý khối lượng lớn khi cần.

  * Mô hình kinh doanh linh hoạt: “Computer Vision as a Service” – tính phí dựa trên số lượng khung hình hoặc camera đang hoạt động.

  * Tự động hóa quản trị: Sử dụng hạ tầng như Kubernetes để tự động scale khi số lượng camera tăng, giảm thiểu can thiệp thủ công.

  * Chuẩn hóa tài liệu kỹ thuật: Xây dựng bộ quy trình vận hành chuẩn (SOP) giúp việc nhân rộng sang nhiều nhà máy diễn ra nhanh chóng.


Một hệ thống được tối ưu chi phí và linh hoạt trong mở rộng sẽ dễ dàng thích ứng khi doanh nghiệp phát triển hoặc khi yêu cầu sản xuất tăng cao.

# Public069

Dữ liệu chuỗi thời gian (time series) xuất hiện trong hầu hết các lĩnh vực: từ tín hiệu cảm biến công nghiệp, log máy chủ, giao dịch tài chính cho đến dữ liệu khí tượng. Khác với dữ liệu dạng bảng thông thường, chuỗi thời gian đòi hỏi các phương pháp thu thập và quản lý đặc thù để đảm bảo tính liên tục, đồng bộ và chất lượng. Dưới đây là các phương pháp và nguyên tắc triển khai chi tiết, đủ để xây dựng một hệ thống bền vững và có khả năng mở rộng.

# Xác định Nguồn Dữ Liệu và Yêu Cầu Kỹ Thuật

  * Nguồn dữ liệu cảm biến công nghiệp: cảm biến nhiệt độ, áp suất, độ ẩm, rung động từ dây chuyền sản xuất.

  * Nguồn dữ liệu số hóa khác: log hệ thống, dữ liệu giao dịch thời gian thực từ ngân hàng, sàn giao dịch.

  * Yêu cầu quan trọng:

* Độ chính xác của thời gian ghi nhận (timestamp) phải thống nhất múi giờ và đồng bộ với đồng hồ chuẩn (NTP).

* Đảm bảo tần suất ghi nhận ổn định (1 Hz, 10 Hz hoặc cao hơn tùy ứng dụng).

* Khả năng mở rộng khi số lượng cảm biến hoặc thiết bị tăng gấp nhiều lần.


Các tổ chức cần lập kế hoạch ngay từ đầu về băng thông mạng, chuẩn truyền dữ liệu (MQTT, OPC-UA, gRPC) và phương án chống mất dữ liệu khi đường truyền gặp sự cố.

# Thu Thập Dữ Liệu Thời Gian Thực

  * Hạ tầng thu thập

* Sử dụng gateway IoT để gom dữ liệu từ nhiều cảm biến, thực hiện lọc và chuẩn hóa trước khi gửi về máy chủ.

* Dùng giao thức truyền tin gọn nhẹ như MQTT để giảm độ trễ.

  * Đảm bảo tính toàn vẹn

* Thêm checksum hoặc chữ ký số trong gói dữ liệu.

* Cơ chế retry tự động nếu mất gói, lưu tạm (buffer) tại thiết bị biên để tránh mất mát.

  * Đồng bộ thời gian

* Thiết lập NTP cho toàn bộ thiết bị.

* Kiểm tra lệch giờ định kỳ, đặc biệt quan trọng trong các phân tích tương quan giữa nhiều nguồn dữ liệu.


# Tiền Xử Lý và Làm Giàu Dữ Liệu

Trước khi lưu trữ, dữ liệu cần được xử lý để phục vụ phân tích lâu dài:

  * Làm sạch dữ liệu:

* Loại bỏ các điểm bất thường do lỗi cảm biến (outlier).

* Điền giá trị thiếu bằng phương pháp nội suy tuyến tính hoặc spline.

  * Chuẩn hóa đơn vị: tất cả cảm biến phải quy về cùng hệ đo (°C, bar, v.v.) để dễ so sánh.

  * Tạo đặc trưng (feature engineering):

* Tính toán trung bình trượt, phương sai, các chỉ số theo khung thời gian (5 phút, 1 giờ).

* Sinh nhãn sự kiện (ví dụ: “máy dừng”, “nhiệt độ vượt ngưỡng”) cho các bài toán dự đoán.

  * Nén và mã hóa: Dùng định dạng như Parquet hoặc Protobuf để giảm dung lượng mà vẫn đảm bảo truy vấn nhanh.


# Hệ Thống Lưu Trữ và Quản Lý

  * Cơ sở dữ liệu chuỗi thời gian (TSDB)

* Lựa chọn InfluxDB, TimescaleDB hoặc QuestDB cho khả năng ghi dữ liệu hàng triệu điểm/giây.

* Hỗ trợ truy vấn theo khoảng thời gian, downsampling tự động.

  * Quản lý phiên bản và phân vùng

* Thiết lập chính sách TTL (time-to-live) để lưu dữ liệu chi tiết trong thời gian nhất định rồi nén hoặc tổng hợp.

* Dùng sharding hoặc partitioning theo ngày/tháng để tăng tốc độ truy vấn.

  * Bảo mật và quyền truy cập

* Mã hóa dữ liệu khi truyền và khi lưu.

* Kiểm soát truy cập theo vai trò (Role-Based Access Control) để giới hạn người xem hoặc chỉnh sửa.


# Giám Sát, Bảo Trì và Khả Năng Mở Rộng

  * Giám sát luồng dữ liệu:

* Dùng các công cụ như Prometheus, Grafana để theo dõi tốc độ ghi, độ trễ, số gói lỗi.

* Thiết lập cảnh báo khi có bất thường, ví dụ lưu lượng giảm đột ngột.

  * Chiến lược mở rộng

* Kiến trúc microservices cho phép thêm node ghi/đọc mà không ảnh hưởng dịch vụ hiện tại.

* Dùng cloud-native (Kubernetes) để tự động cân bằng tải.

  * Sao lưu và phục hồi

* Sao lưu định kỳ sang các vùng địa lý khác nhau.

* Thử nghiệm phục hồi để đảm bảo RPO (Recovery Point Objective) và RTO (Recovery Time Objective) đạt yêu cầu.


  * Giám sát luồng dữ liệu:

* Dùng các công cụ như Prometheus, Grafana để theo dõi tốc độ ghi, độ trễ, số gói lỗi.

* Thiết lập cảnh báo khi có bất thường, ví dụ lưu lượng giảm đột ngột.

  * Chiến lược mở rộng

* Kiến trúc microservices cho phép thêm node ghi/đọc mà không ảnh hưởng dịch vụ hiện tại.

* Dùng cloud-native (Kubernetes) để tự động cân bằng tải.

  * Sao lưu và phục hồi

* Sao lưu định kỳ sang các vùng địa lý khác nhau.

* Thử nghiệm phục hồi để đảm bảo RPO (Recovery Point Objective) và RTO (Recovery Time Objective) đạt yêu cầu.

# Public070

Công nghệ 5G không chỉ là thế hệ tiếp theo của mạng di động mà còn là nền tảng cho một hệ sinh thái kết nối khổng lồ, hỗ trợ từ truyền thông siêu tốc đến Internet vạn vật (IoT) công nghiệp. Việc triển khai 5G đòi hỏi phương pháp kỹ thuật và quản lý chặt chẽ để bảo đảm hiệu năng, bảo mật và khả năng mở rộng lâu dài. Phần dưới đây trình bày chi tiết các phương pháp và nguyên tắc giúp xây dựng và vận hành hệ thống 5G toàn diện.

# Kiến Trúc Mạng 5G và Thành Phần Cốt Lõi

Mạng 5G được thiết kế với cấu trúc mở và linh hoạt hơn hẳn 4G, bao gồm:

  * **Mạng truy nhập vô tuyến (RAN – Radio Access Network)**

* Sử dụng các trạm gNodeB với công nghệ Massive MIMO, beamforming để tăng tốc độ và độ phủ sóng.

* Hỗ trợ băng tần đa dạng: dưới 6 GHz (Sub-6) và mmWave (24–100 GHz) cho các yêu cầu băng thông cực cao.

  * **Mạng lõi (5GC – 5G Core)**

* Thiết kế hoàn toàn theo hướng dịch vụ (Service-Based Architecture – SBA).

* Cho phép **network slicing** , tách mạng thành nhiều “lát” phục vụ từng ứng dụng: IoT băng hẹp, dịch vụ băng thông cao, hay truyền thông siêu tin cậy (URLLC).

  * **Edge Computing**

* Đưa xử lý dữ liệu tới gần người dùng, giảm độ trễ xuống dưới 1 ms, hỗ trợ các ứng dụng như xe tự lái hoặc phẫu thuật từ xa.


# Phương Pháp Quy Hoạch và Triển Khai Hạ Tầng

  * **Khảo sát và lập kế hoạch tần số**

* Đánh giá môi trường địa hình, mật độ dân cư, nhu cầu dịch vụ để xác định dải tần phù hợp.

* Phân tích nhiễu sóng, lập sơ đồ phủ sóng tối ưu.

  * **Triển khai gNodeB**

* Sử dụng mô hình small cell dày đặc để tận dụng băng tần cao, đặc biệt với mmWave.

* Tích hợp công nghệ beamforming để tập trung tín hiệu, giảm tiêu thụ năng lượng.

  * **Điện toán biên (MEC)**

* Xây dựng trung tâm xử lý tại các điểm nút mạng để giảm băng thông đường trục.

* Hỗ trợ các ứng dụng đòi hỏi độ trễ thấp như AR/VR, game thời gian thực.

  * **Tích hợp Cloud-Native**

* Sử dụng container (Docker/Kubernetes) để triển khai 5G Core, dễ dàng mở rộng hoặc cập nhật dịch vụ.


# Quản Lý Chất Lượng Dịch Vụ và Bảo Mật

  * **Đảm bảo QoS (Quality of Service)**

* Phân chia network slicing cho từng loại dịch vụ:

  * eMBB (Enhanced Mobile Broadband) cho video 8K, VR.

  * URLLC (Ultra-Reliable Low Latency Communications) cho xe tự lái, điều khiển robot.

  * mMTC (massive Machine Type Communications) cho hàng triệu cảm biến IoT.

  * **Bảo mật đa lớp**

* Mã hóa đầu cuối giữa thiết bị và mạng lõi.

* Hệ thống phát hiện xâm nhập thời gian thực, kiểm soát truy cập theo vai trò.

* Quản lý chứng chỉ cho hàng tỷ thiết bị IoT kết nối.

  * **Giám sát và phân tích**

* Dùng AI/ML để phát hiện bất thường trong lưu lượng.

* Cảnh báo sớm khi có dấu hiệu tấn công DDoS hoặc suy giảm hiệu năng.


# Tối Ưu Hiệu Năng và Chi Phí Vận Hành

  * **Tự động hóa O-RAN**

* Kiến trúc Open RAN cho phép nhiều nhà cung cấp thiết bị cùng tham gia, giảm chi phí đầu tư.

* AI hỗ trợ tự điều chỉnh thông số mạng dựa trên nhu cầu thực tế.

  * **Năng lượng và bền vững**

* Tích hợp năng lượng tái tạo (mặt trời, gió) cho các trạm gốc ở vùng xa.

* Chế độ ngủ động (sleep mode) cho cell khi không có lưu lượng để tiết kiệm điện.

  * **Khả năng mở rộng**

* Hỗ trợ từ mạng thành phố đến mạng chuyên dụng cho nhà máy, bệnh viện, khu công nghiệp.

* Mô hình “Network-as-a-Service” cho phép doanh nghiệp thuê hạ tầng 5G theo nhu cầu.


# Ứng Dụng Công Nghiệp và Dân Dụng

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

  * **Công nghiệp thông minh** : Kết hợp 5G và IoT để điều khiển robot, giám sát sản xuất theo thời gian thực.

  * **Y tế từ xa** : Hỗ trợ phẫu thuật và tư vấn chuyên khoa với độ trễ gần như bằng không.

  * **Giao thông thông minh** : Kết nối xe tự lái, chia sẻ dữ liệu giữa các phương tiện và hạ tầng đường bộ.

  * **Giải trí và truyền thông** : Truyền trực tiếp 8K, AR/VR tương tác thời gian thực.

# Public071

Internet vạn vật (IoT) đang mở rộng với tốc độ chưa từng có, kết nối hàng chục tỷ thiết bị từ cảm biến công nghiệp, thiết bị y tế đến phương tiện giao thông và hạ tầng thành phố thông minh. Việc quản lý và bảo mật mạng lưới IoT quy mô lớn đòi hỏi phương pháp kỹ thuật toàn diện, kết hợp từ khâu thiết kế kiến trúc đến giám sát, phản ứng sự cố. Dưới đây là nội dung chuyên sâu, được mở rộng chi tiết nhằm cung cấp cái nhìn đầy đủ cho việc xây dựng và vận hành một hệ thống IoT bền vững, đủ dài cho tài liệu khoảng 10 trang Word.

# Kiến Trúc Hệ Thống và Phương Pháp Triển Khai

Để phục vụ hàng triệu thiết bị kết nối đồng thời, kiến trúc IoT cần đảm bảo **tính phân cấp** , **khả năng mở rộng** , và **độ tin cậy cao**.

  * **Lớp thiết bị (Device Layer)**

* Bao gồm cảm biến, bộ truyền động, thiết bị đeo, phương tiện, camera giám sát.

* Thiết bị phải hỗ trợ giao thức nhẹ (MQTT, CoAP) và cơ chế bảo mật phần cứng như TPM hoặc Secure Element.

* Quản lý nguồn điện: thiết kế tối ưu năng lượng, chế độ ngủ sâu (deep sleep) để kéo dài tuổi thọ pin.

  * **Lớp mạng (Network Layer)**

* Hỗ trợ đa dạng giao thức: Wi-Fi 6, 5G, LPWAN (LoRaWAN, NB-IoT) tùy ứng dụng.

* Áp dụng định tuyến động và tự phục hồi khi có nút hỏng (mesh network).

* Tích hợp SDN (Software Defined Networking) để điều khiển luồng dữ liệu linh hoạt.

  * **Lớp xử lý và ứng dụng (Edge/Cloud Layer)**

* Edge computing giảm độ trễ, xử lý sơ bộ dữ liệu tại thiết bị biên.

* Cloud IoT platform (AWS IoT, Azure IoT Hub, Google IoT Core) lưu trữ và phân tích dữ liệu ở quy mô petabyte.

* Hỗ trợ microservices và container để dễ mở rộng, cập nhật dịch vụ mà không gây gián đoạn.


# Phương Pháp Quản Lý Thiết Bị Ở Quy Mô Hàng Triệu Node

Việc vận hành một mạng IoT khổng lồ cần hệ thống quản lý tập trung nhưng linh hoạt:

  * **Đăng ký và cung cấp (Provisioning)**

* Tự động cấp chứng chỉ số cho thiết bị mới.

* Xác minh danh tính thiết bị qua PKI (Public Key Infrastructure).

  * **Giám sát từ xa**

* Theo dõi tình trạng pin, chất lượng kết nối, tình trạng cảm biến.

* Cảnh báo khi thiết bị ngắt kết nối hoặc gửi dữ liệu bất thường.

  * **Quản lý cấu hình và cập nhật (OTA – Over-the-Air)**

* Cập nhật firmware đồng loạt mà không cần tiếp cận vật lý.

* Hỗ trợ cập nhật vi sai (delta update) để tiết kiệm băng thông.

  * **Phân nhóm và ưu tiên**

* Phân loại thiết bị theo vị trí địa lý, loại dịch vụ, hoặc mức độ quan trọng.

* Cho phép triển khai bản vá trước cho nhóm thiết bị trọng yếu.


# Bảo Mật Đa Lớp Cho Mạng IoT

Với số lượng thiết bị khổng lồ, bảo mật trở thành ưu tiên hàng đầu:

  * **Bảo mật thiết bị đầu cuối**

* Khởi động an toàn (secure boot) đảm bảo chỉ phần mềm đáng tin cậy được chạy.

* Mã hóa lưu trữ nội bộ để bảo vệ dữ liệu khi thiết bị bị đánh cắp.

  * **Bảo mật truyền thông**

* Giao thức TLS/DTLS cho kết nối TCP/UDP.

* Xác thực hai chiều giữa thiết bị và máy chủ.

  * **Phát hiện và phản ứng sự cố**

* Hệ thống IDS/IPS chuyên cho IoT, sử dụng học máy để phát hiện hành vi bất thường.

* Cơ chế cách ly thiết bị nghi ngờ bị tấn công để ngăn lan truyền.

  * **Quản lý khóa và chứng chỉ**

* Tự động luân chuyển khóa định kỳ.

* Hủy chứng chỉ ngay khi phát hiện thiết bị bị xâm nhập.


# Giám Sát Hoạt Động và Phân Tích Dữ Liệu Lớn

Khi số lượng thiết bị lên đến hàng triệu, lượng dữ liệu thu thập mỗi ngày có thể đạt đến hàng trăm terabyte:

  * **Thu thập và lưu trữ dữ liệu**

* Sử dụng cơ sở dữ liệu time-series như InfluxDB hoặc TimescaleDB cho dữ liệu cảm biến.

* Hệ thống lưu trữ phân tán (HDFS, Object Storage) cho dữ liệu phi cấu trúc như video.

  * **Thu thập và lưu trữ dữ liệu**

* Sử dụng cơ sở dữ liệu time-series như InfluxDB hoặc TimescaleDB cho dữ liệu cảm biến.

* Hệ thống lưu trữ phân tán (HDFS, Object Storage) cho dữ liệu phi cấu trúc như video.

  * **Thu thập và lưu trữ dữ liệu**

* Sử dụng cơ sở dữ liệu time-series như InfluxDB hoặc TimescaleDB cho dữ liệu cảm biến.

* Hệ thống lưu trữ phân tán (HDFS, Object Storage) cho dữ liệu phi cấu trúc như video.

  * **Phân tích và trực quan hóa**

* Dùng Apache Spark hoặc Flink để xử lý luồng dữ liệu thời gian thực.

* Dashboard Grafana, Kibana cho phép giám sát theo thời gian thực và lịch sử.

  * **Phát hiện bất thường bằng AI**

* Huấn luyện mô hình học máy để dự đoán lỗi thiết bị.

* Cảnh báo sớm giúp giảm thời gian gián đoạn dịch vụ.


# Chiến Lược Bền Vững và Tuân Thủ Quy Định

  * **Quy định và tiêu chuẩn**

* Tuân thủ các tiêu chuẩn quốc tế như ISO/IEC 27001, GDPR cho quyền riêng tư.

* Đảm bảo thiết bị đạt chứng nhận CE, FCC trước khi thương mại hóa.

  * **Tối ưu chi phí vận hành**

* Mô hình “IoT as a Service” cho phép doanh nghiệp chỉ trả tiền theo mức sử dụng.

* Tận dụng nguồn năng lượng tái tạo và pin mặt trời cho thiết bị ở vùng xa.

  * **Kế hoạch phục hồi thảm họa**

* Sao lưu dữ liệu ở nhiều khu vực địa lý.

* Kịch bản khôi phục nhanh khi xảy ra mất điện, cháy nổ hoặc tấn công mạng quy mô lớn.

# Public072

# Giới thiệu tổng quan

Học Tăng Cường Sâu (Deep Reinforcement Learning – DRL) là sự kết hợp giữa Học Tăng Cường (Reinforcement Learning – RL) và Mạng Nơ-ron Sâu (Deep Neural Networks). Đây là một hướng đi đột phá cho phép hệ thống học từ **tương tác trực tiếp với môi trường** , đưa ra các quyết định tối ưu mà không cần mô hình hóa chính xác toàn bộ động lực học.

Trong bối cảnh robot công nghiệp, DRL cho phép:

  * Robot **tự khám phá** chiến lược điều khiển để tối ưu hóa hiệu suất.

  * **Thích ứng linh hoạt** khi điều kiện môi trường hoặc cấu hình hệ thống thay đổi.

  * **Giảm phụ thuộc** vào các chuyên gia thiết kế thuật toán điều khiển thủ công.


Cốt lõi của DRL là **quy trình học qua thử-sai** : hệ thống tự động điều chỉnh chính sách để tối đa hóa phần thưởng (reward) tích lũy trong thời gian dài.

# Kiến trúc hệ thống DRL

Một hệ thống DRL tiêu chuẩn trong robot công nghiệp thường bao gồm:

  * **Agent (Tác nhân):** Bộ não của robot, thực thi thuật toán DRL để chọn hành động.

  * **Environment (Môi trường):** Không gian làm việc, có thể là thực tế (nhà máy, kho hàng) hoặc mô phỏng (Gazebo, MuJoCo).

  * **State (Trạng thái):** Dữ liệu cảm biến gồm vị trí, vận tốc, dữ liệu hình ảnh, tín hiệu lực, v.v.

  * **Action (Hành động):** Tín hiệu điều khiển như xoay khớp tay, dịch chuyển, kẹp hoặc nhả vật.

  * **Reward (Phần thưởng):** Con số định lượng để đánh giá hiệu quả của hành động, ví dụ “hoàn thành nhiệm vụ trong thời gian ngắn” hoặc “giữ độ chính xác cao”.


Quy trình lặp: Agent quan sát trạng thái → thực hiện hành động → nhận phần thưởng → cập nhật chính sách → lặp lại.

# Thuật toán DRL tiêu biểu và phân tích

Các thuật toán DRL phổ biến:

## Deep Q-Network (DQN)

  * Kết hợp Q-learning với mạng nơ-ron sâu.

  * Xấp xỉ hàm giá trị Q(s,a) để tìm hành động tối ưu.

  * Dùng replay buffer để ổn định huấn luyện.


## Policy Gradient Methods (ví dụ: REINFORCE, A2C, A3C)

  * Tối ưu trực tiếp chính sách π(a|s).

  * Thích hợp cho không gian hành động liên tục.


## Actor-Critic

  * Actor chọn hành động, Critic đánh giá chất lượng.

  * Cải thiện tốc độ và tính ổn định so với chỉ dùng Policy Gradient.


## Proximal Policy Optimization (PPO)

  * Cân bằng giữa hiệu suất và độ ổn định.

  * Phổ biến trong các ứng dụng robot phức tạp.


Các thuật toán này có thể được kết hợp với kiến trúc mạng nơ-ron hiện đại như CNN (xử lý hình ảnh), LSTM/GRU (xử lý chuỗi tín hiệu) để nâng cao khả năng nhận diện trạng thái.

# Ứng dụng trong robot công nghiệp

DRL đã được ứng dụng thành công trong nhiều mảng:

  * **Lắp ráp tự động:**  
Cánh tay robot học cách điều chỉnh lực và vị trí để lắp ráp các chi tiết cực kỳ nhỏ với sai số dưới 0.1 mm.

  * **Quản lý kho thông minh:**  
Robot tự tìm đường tối ưu, tránh va chạm, tiết kiệm thời gian di chuyển trong kho diện tích lớn.

  * **Hàn và sơn tự động:**  
Học đường đi và áp suất phun để đảm bảo lớp sơn/hàn đồng đều trên bề mặt phức tạp.

  * **Bảo trì và kiểm tra:**  
Robot gắn camera học cách di chuyển trong không gian hẹp, kiểm tra lỗi sản phẩm mà không cần lập trình tỉ mỉ.


# Quy trình triển khai thực tế

## Mô phỏng trước khi thử nghiệm thực tế  
Sử dụng các nền tảng như Gazebo, PyBullet, hoặc Isaac Gym để giảm chi phí và rủi ro. Quá trình huấn luyện có thể kéo dài hàng trăm nghìn bước, nên mô phỏng là lựa chọn tiết kiệm.

## Transfer Learning (Chuyển giao học tập)  
Sau khi huấn luyện trên mô phỏng, mô hình được tinh chỉnh để thích ứng với robot thực, khắc phục chênh lệch giữa môi trường ảo và thực tế.

##  Thiết kế phần thưởng (Reward Shaping)

  * Chia nhỏ nhiệm vụ thành nhiều giai đoạn.

  * Phạt nặng các hành động nguy hiểm (quá tốc độ, va chạm).

  * Thưởng dần theo mức độ tiến bộ để học nhanh hơn.


## Đảm bảo an toàn và ràng buộc vật lý  
Áp dụng giới hạn tốc độ, lực, vùng hoạt động. Cảm biến lực và công tắc khẩn cấp cần được tích hợp để ngăn sự cố.

# Thách thức kỹ thuật

  * **Chi phí tính toán:**  
Huấn luyện DRL đòi hỏi GPU/TPU mạnh và thời gian tính toán dài.

  * **Khả năng tổng quát hóa:**  
Robot cần hoạt động tốt trong nhiều tình huống khác nhau, đòi hỏi dữ liệu đa dạng.

  * **Tích hợp cảm biến đa dạng:**  
Camera, LiDAR, cảm biến lực, IMU… tạo ra dòng dữ liệu khổng lồ cần xử lý theo thời gian thực.

  * **Quản lý dữ liệu và nhật ký huấn luyện:**  
Lưu trữ, phân tích log để tối ưu thuật toán.


# Hướng phát triển tương lai

  * **World Model + DRL:**  
Robot tự xây dựng mô hình thế giới nội tại để dự đoán trạng thái tương lai, giảm nhu cầu tương tác thật.

  * **Học tự giám sát (Self-Supervised RL):**  
Sử dụng dữ liệu không gán nhãn để khởi tạo chính sách ban đầu.

  * **Edge Computing & Triển khai gọn nhẹ:**  
Lượng tử hóa mô hình (model quantization) giúp chạy trên phần cứng hạn chế như bộ điều khiển nhúng.

  * **Kết hợp với Học Liên Kết (Federated RL):**  
Nhiều robot học chung mà không cần chia sẻ dữ liệu thô, tăng tính bảo mật.

# Public073

# Bối cảnh và động lực

Trong ngành y tế, việc ứng dụng trí tuệ nhân tạo (AI) vào chẩn đoán, dự đoán và phân tích dữ liệu bệnh nhân ngày càng phổ biến. Tuy nhiên, dữ liệu y tế thường chứa thông tin cá nhân cực kỳ nhạy cảm (hồ sơ bệnh án, hình ảnh y khoa, kết quả xét nghiệm), chịu ràng buộc bởi các quy định nghiêm ngặt như HIPAA (Mỹ), GDPR (châu Âu) và các tiêu chuẩn bảo mật dữ liệu quốc gia.

Vấn đề: Các bệnh viện, phòng khám và tổ chức nghiên cứu muốn hợp tác để xây dựng mô hình AI có độ chính xác cao, nhưng không thể chia sẻ dữ liệu thô do rào cản pháp lý và đạo đức.

Giải pháp: Học Liên Kết (Federated Learning – FL) cho phép huấn luyện mô hình chung trên nhiều nguồn dữ liệu phân tán mà không cần chuyển dữ liệu ra khỏi cơ sở lưu trữ cục bộ.

#  Federated learning là gì?

Federated Learning là một phương pháp nhằm đào tạo các mô hình AI mà không cần bất kỳ ai nhìn thấy hoặc tác động vào dữ liệu của bạn. Điều này giúp bạn có thể sử dụng thông tin mà không cần chia sẻ dữ liệu thật sự, để phục vụ cho các ứng dụng AI mới. 

# Nguyên lý hoạt động của Federated Learning

Federated Learning được triển khai theo mô hình “huấn luyện phân tán – tổng hợp tập trung”:

  1. Khởi tạo mô hình toàn cục (Global Model):  
Máy chủ trung tâm (server) gửi mô hình khởi tạo đến từng máy khách (client).

  2. Huấn luyện cục bộ (Local Training):  
Mỗi cơ sở y tế huấn luyện mô hình trên dữ liệu của riêng mình.

  3. Gửi trọng số (Model Updates):  
Chỉ các thông số/gradient đã cập nhật được gửi về máy chủ, không truyền dữ liệu thô.

  4. Tổng hợp (Aggregation):  
Máy chủ dùng thuật toán như _Federated Averaging_ để hợp nhất các trọng số, tạo ra mô hình toàn cục mới.

  5. Lặp lại:  
Quá trình này tiếp tục cho đến khi mô hình hội tụ.


#  Lợi ích trong y tế

  * Bảo mật và quyền riêng tư:  
Dữ liệu bệnh nhân không bao giờ rời khỏi bệnh viện, giảm nguy cơ rò rỉ.

  * Đa dạng dữ liệu:  
Mô hình được huấn luyện trên dữ liệu phong phú từ nhiều vùng miền, nâng cao khả năng tổng quát hóa.

  * Tuân thủ pháp lý:  
Đáp ứng các quy định bảo mật nghiêm ngặt mà vẫn hợp tác được giữa nhiều tổ chức.


# Kiến trúc và thành phần chính

  * Central Server (Máy chủ trung tâm): Quản lý mô hình toàn cục, điều phối việc tổng hợp trọng số.

  * Clients (Máy khách): Bệnh viện, phòng thí nghiệm hoặc thiết bị y tế thông minh.

  * Secure Communication Layer: Giao thức truyền thông bảo mật (SSL/TLS) để gửi thông số mô hình.

  * Aggregation Algorithm: Thuật toán như _FedAvg_ , _FedProx_ để cân bằng chênh lệch dữ liệu giữa các khách.


# Các phương pháp bảo mật nâng cao

  1. Differential Privacy (DP):  
Thêm nhiễu vào gradient hoặc trọng số trước khi gửi về server, che giấu thông tin cá nhân.

  2. Secure Multi-Party Computation (SMPC):  
Cho phép nhiều bên tính toán chung mà không tiết lộ dữ liệu riêng.

  3. Homomorphic Encryption:  
Mã hóa dữ liệu sao cho vẫn có thể tính toán trực tiếp trên dữ liệu mã hóa.

  4. Trusted Execution Environment (TEE):  
Sử dụng phần cứng bảo mật để đảm bảo chỉ các quá trình được phép mới có thể truy cập thông tin.


# Ứng dụng thực tiễn

  * Chẩn đoán hình ảnh y khoa:  
Huấn luyện mô hình phân tích MRI, CT từ nhiều bệnh viện để phát hiện ung thư sớm.

  * Dự đoán nguy cơ bệnh mãn tính:  
Kết hợp dữ liệu hồ sơ bệnh án điện tử từ nhiều cơ sở để dự đoán tiểu đường, tim mạch.

  * Theo dõi thiết bị đeo y tế:  
Đồng bộ dữ liệu cảm biến từ hàng nghìn thiết bị đeo để phát hiện sớm rối loạn tim.


# Thách thức kỹ thuật

  * Dữ liệu không đồng nhất (Non-IID):  
Mỗi bệnh viện có đặc điểm dân số, thiết bị và quy trình thu thập dữ liệu khác nhau.

  * Kết nối mạng:  
Cần đường truyền ổn định và bảo mật.

  * Chi phí tính toán cục bộ:  
Một số cơ sở y tế có hạ tầng hạn chế, khó chạy mô hình lớn.

  * Cân bằng quyền lực giữa các bên:  
Đảm bảo công bằng giữa các bệnh viện lớn nhỏ khi đóng góp dữ liệu.

  * Kết nối mạng:  
Cần đường truyền ổn định và bảo mật.

  * Chi phí tính toán cục bộ:  
Một số cơ sở y tế có hạ tầng hạn chế, khó chạy mô hình lớn.

  * Cân bằng quyền lực giữa các bên:  
Đảm bảo công bằng giữa các bệnh viện lớn nhỏ khi đóng góp dữ liệu.

  * Kết nối mạng:  
Cần đường truyền ổn định và bảo mật.

  * Chi phí tính toán cục bộ:  
Một số cơ sở y tế có hạ tầng hạn chế, khó chạy mô hình lớn.

  * Cân bằng quyền lực giữa các bên:  
Đảm bảo công bằng giữa các bệnh viện lớn nhỏ khi đóng góp dữ liệu.


#  Hướng phát triển tương lai

  * Federated Learning kết hợp Edge Computing:  
Đưa FL xuống thiết bị di động, thiết bị đeo y tế để huấn luyện trực tiếp trên biên mạng.

  * Hybrid Federated + Transfer Learning:  
Dùng transfer learning để giảm số vòng huấn luyện liên kết.

  * Tích hợp Blockchain:  
Đảm bảo tính minh bạch, bất biến trong ghi nhận quá trình huấn luyện và cập nhật mô hình.

  * Mô hình lượng tử hóa:  
Giảm kích thước trọng số để tiết kiệm băng thông và thời gian truyền.

# Public074

#  Giới thiệu và bối cảnh

Mạng di động thế hệ thứ sáu (6G) được kỳ vọng mang lại tốc độ truyền tải dữ liệu hàng trăm gigabit/giây, độ trễ dưới 1 mili giây, và khả năng kết nối hàng tỷ thiết bị IoT. Tuy nhiên, việc tối ưu hóa cấu trúc mạng 6G – từ phân bổ tài nguyên phổ tần, định tuyến dữ liệu, đến quản lý năng lượng – đặt ra những bài toán tính toán khổng lồ, thường là NP-hard, khó giải quyết bằng máy tính cổ điển.

Điện toán lượng tử (Quantum Computing), với khả năng khai thác hiện tượng chồng chập và rối lượng tử, hứa hẹn giải quyết các bài toán tối ưu này nhanh hơn cấp số nhân so với phương pháp truyền thống.

# Cơ sở lý thuyết điện toán lượng tử

  * Qubit: Đơn vị thông tin cơ bản, tồn tại ở trạng thái chồng chập (0 và 1 đồng thời).

  * Cổng lượng tử (Quantum Gate): Thao tác toán học biến đổi trạng thái qubit, tương tự như cổng logic trong máy tính cổ điển.

  * Rối lượng tử (Entanglement): Liên kết giữa các qubit giúp tính toán song song và truyền thông tin nhanh.

  * Đo lường (Measurement): Quá trình chuyển trạng thái lượng tử thành kết quả nhị phân.


Nhờ các đặc tính này, máy tính lượng tử có thể khám phá không gian nghiệm khổng lồ của các bài toán tối ưu phức tạp.

# Các tính năng vượt trội của 6G so với 5G:

  * Tốc độ vượt trội: Mạng 6G được kỳ vọng sẽ đạt tốc độ truyền dữ liệu lên đến 1 Terabit/giây (Tbps), nhanh hơn gấp 100-500 lần so với 5G. Tốc độ này cho phép tải xuống phim 4K trong vài giây hoặc thậm chí truyền tải hình ảnh голограмма 3D theo thời gian thực.

  * Độ trễ cực thấp: Độ trễ của mạng 6G được dự đoán sẽ giảm xuống dưới 1 micro giây (µs), gần như bằng không. Điều này rất quan trọng cho các ứng dụng yêu cầu phản hồi tức thời, chẳng hạn như thực tế ảo (VR), thực tế tăng cường (AR), lái xe tự động và điều khiển từ xa các thiết bị công nghiệp.

  * Băng thông siêu rộng: 6G sẽ sử dụng các băng tần tần số cao hơn, bao gồm cả sóng milimet và Terahertz (THz), cho phép truyền tải một lượng lớn dữ liệu cùng một lúc. Điều này sẽ đáp ứng nhu cầu ngày càng tăng về băng thông của các ứng dụng như truyền phát video 8K/16K, trò chơi trực tuyến và Internet vạn vật (IoT) quy mô lớn.

  * Khả năng kết nối vạn vật: 6G được thiết kế để kết nối hàng tỷ thiết bị IoT, từ cảm biến trong nhà thông minh đến thiết bị công nghiệp và xe tự lái. Điều này sẽ tạo ra một mạng lưới kết nối rộng khắp, cho phép thu thập và phân tích dữ liệu theo thời gian thực, tối ưu hóa hiệu suất và tạo ra các dịch vụ thông minh.

  * Kết nối không gian: Ngoài kết nối mặt đất, 6G còn hướng đến việc tích hợp các mạng vệ tinh và máy bay không người lái, mở rộng phạm vi phủ sóng đến những vùng sâu vùng xa và khu vực biển đảo. Điều này sẽ đảm bảo kết nối liên tục và ổn định cho người dùng ở bất kỳ đâu.

  * Tích hợp trí tuệ nhân tạo (AI): AI sẽ đóng vai trò then chốt trong việc quản lý và tối ưu hóa mạng 6G. AI sẽ giúp phân bổ tài nguyên mạng một cách thông minh, dự đoán và ngăn chặn các sự cố, cũng như tối ưu hóa hiệu suất của các ứng dụng.

  * Bảo mật nâng cao: Với sự gia tăng của các thiết bị kết nối và lượng dữ liệu được truyền tải, bảo mật trở thành một yếu tố cực kỳ quan trọng. 6G sẽ tích hợp các công nghệ bảo mật tiên tiến để đảm bảo an toàn cho dữ liệu người dùng và ngăn chặn các cuộc tấn công mạng.


# Bài toán tối ưu trong mạng 6G

Các kịch bản tiêu biểu:

  * Phân bổ phổ tần (Spectrum Allocation): Tìm cách chia phổ tần hạn chế cho hàng triệu thiết bị.

  * Định tuyến dữ liệu động: Chọn đường truyền tốt nhất trong thời gian thực để giảm tắc nghẽn.

  * Quản lý năng lượng: Tối ưu công suất phát để tiết kiệm năng lượng mà vẫn đảm bảo chất lượng dịch vụ.

  * Lập lịch truy cập (Scheduling): Điều phối truy cập giữa các thiết bị IoT đa dạng.


Những bài toán này đều đòi hỏi giải các bài toán tối ưu tổ hợp với quy mô cực lớn.

# Ứng dụng thuật toán lượng tử

  1. Quantum Approximate Optimization Algorithm (QAOA):

* Giải các bài toán tối ưu tổ hợp như phân bổ phổ tần.

* Sử dụng mạch lượng tử lai (hybrid quantum-classical).

  2. Variational Quantum Eigensolver (VQE):

* Tìm nghiệm gần đúng của các hệ thống phức tạp, hữu ích cho tối ưu năng lượng.

  3. Grover’s Algorithm:

* Tăng tốc tìm kiếm trong cơ sở dữ liệu, giúp định tuyến và tra cứu nhanh.

  4. Quantum Annealing:

* Tương tự tối ưu hóa bậc thang, đặc biệt hiệu quả cho bài toán lập lịch lớn.


#  Kiến trúc triển khai thực tế

  * Mô hình lai (Hybrid Quantum-Classical):  
Phần lượng tử giải quyết các thành phần tối ưu nặng, trong khi phần cổ điển xử lý giao thức mạng.

  * Tích hợp Cloud-Quantum:  
Các trạm gốc 6G có thể truy cập dịch vụ máy tính lượng tử đám mây (IBM Q, D-Wave) để thực hiện tính toán.

  * Edge Computing:  
Đưa các thuật toán lượng tử nhẹ xuống rìa mạng để giảm độ trễ.


# Lợi ích tiềm năng

  * Tốc độ tính toán: Giải bài toán NP-hard trong thời gian khả thi.

  * Tiết kiệm năng lượng: Phân bổ tài nguyên tối ưu giảm lãng phí.

  * Khả năng mở rộng: Phù hợp với lượng thiết bị IoT khổng lồ trong kỷ nguyên 6G.


# Thách thức

  * Hạ tầng phần cứng lượng tử:  
Máy tính lượng tử vẫn hạn chế về số lượng qubit và độ bền.

  * Thuật toán chuyên biệt:  
Cần phát triển thuật toán phù hợp bài toán mạng viễn thông.

  * Tích hợp hệ thống:  
Đồng bộ giữa mạng lượng tử và mạng cổ điển đòi hỏi chuẩn giao thức mới.


#  Hướng nghiên cứu tương lai

  * Lượng tử hóa mạng (Quantum Networking):  
Tích hợp kênh truyền lượng tử cho truyền thông siêu an toàn.

  * AI lượng tử (Quantum Machine Learning):  
Sử dụng mạng lượng tử để học và tối ưu hóa động.

  * Chống nhiễu lượng tử:  
Tăng độ ổn định cho mạch lượng tử để triển khai thực tế.

# Public075

Các nhà nghiên cứu tại Viện Công nghệ New Jersey (NJIT) đã sử dụng trí tuệ nhân tạo (AI) để giải quyết vấn đề quan trọng trong việc lưu trữ năng lượng trong tương lai. Theo đó, công cụ AI cung cấp giải pháp thay thế bền vững với chi phí hợp lý cho pin lithium-ion. Kết quả nghiên cứu đã được công bố trên tạp chí _Cell Reports Physical Science_.

Nhóm nghiên cứu đã áp dụng thành công kỹ thuật AI tạo sinh để nhanh chóng khám phá các vật liệu xốp mới có khả năng cách mạng hóa pin đa hóa trị. Loại pin này sử dụng các nguyên tố dồi dào như magiê, canxi, nhôm và kẽm, mang đến giải pháp thay thế triển vọng và tiết kiệm chi phí cho pin lithium-ion đang gặp khó khăn về nguồn cung trên toàn cầu và tính bền vững.

Không giống pin lithium-ion truyền thống chỉ dựa vào các ion lithium mang điện tích dương, pin đa hóa trị sử dụng các nguyên tố có ion mang hai hoặc thậm chí ba điện tích dương. Điều này có nghĩa là pin đa hóa trị lưu trữ nhiều năng lượng hơn đáng kể nên trở thành giải pháp lưu trữ năng lượng hấp dẫn trong tương lai. Tuy nhiên, các ion đa hóa trị có kích thước và điện tích lớn dẫn đến khó tích hợp chúng hiệu quả vào vật liệu pin.

# Bối cảnh và động lực

Sự phát triển của lưới điện thông minh (Smart Grid) và nhu cầu tích hợp năng lượng tái tạo như gió, mặt trời đòi hỏi các giải pháp lưu trữ năng lượng hiệu quả. Năng lượng tái tạo có tính dao động cao: khi mặt trời lặn hoặc gió yếu, nguồn cung giảm đột ngột. Hệ thống lưới điện thông minh cần các công nghệ pin thế hệ mới để:

  * Cân bằng cung – cầu điện.

  * Giảm tải trong giờ cao điểm.

  * Đảm bảo độ ổn định và độ tin cậy cho toàn hệ thống.


# Hạn chế của pin truyền thống

Pin lithium-ion (Li-ion) đã trở thành chuẩn mực trong nhiều năm qua, nhưng:

  * Giới hạn về mật độ năng lượng và chu kỳ sạc xả.

  * Nguy cơ cháy nổ do chất điện phân lỏng.

  * Chi phí nguyên liệu tăng cao, đặc biệt là cobalt và lithium.


Điều này thúc đẩy nghiên cứu các pin thế hệ mới có khả năng an toàn hơn, tuổi thọ dài hơn và thân thiện với môi trường.

# Xu hướng chi phí và công nghệ:

Công nghệ pin lithium-ion (Li-ion) vẫn chiếm ưu thế tuyệt đối trong các dự án BESS hiện nay nhờ mật độ năng lượng cao, độ tin cậy và chi phí ngày càng giảm. Giá pin lithium-ion tiếp tục giảm so với giai đoạn trước, nhưng từ 2023-2025 xu hướng giảm đã chậm lại.

Theo thống kê: Giá thành pack pin Li-ion (là quá trình lắp ráp các Cells Pin Lithium, bảng mạch bảo vệ, đầu nối, vỏ ngoài, v.v... để tạo thành một bộ pin hoàn chỉnh) hiện nay vào khoảng 150-160 USD/kWh (giảm mạnh so với mức trên 1.000 USD/kWh cách đây một thập kỷ).

Các hệ thống BESS phổ biến có thời lượng lưu trữ 2-4 giờ, phù hợp với nhu cầu cân bằng phụ tải và hấp thụ NLTT dư thừa. Trong khi đó, các công nghệ lưu trữ dài hạn (LDES) như pin dòng (flow battery), sodium-ion, hay hydro đang được nghiên cứu và thử nghiệm để đáp ứng nhu cầu lưu trữ trên 8 giờ.

# Các công nghệ pin thế hệ mới

## Pin Thể Rắn (Solid-State Battery)

  * Đặc điểm: Sử dụng chất điện phân rắn thay vì lỏng.

  * Ưu điểm:

* Mật độ năng lượng cao hơn 2–3 lần pin Li-ion.

* An toàn hơn, giảm nguy cơ cháy nổ.

* Chu kỳ sạc xả dài.

  * Thách thức: Chi phí sản xuất cao, khó mở rộng công nghiệp.


## Pin Sodium-Ion (Na-ion)

  * Đặc điểm: Sử dụng natri (Na) – nguyên liệu rẻ và dồi dào.

  * Ưu điểm:

* Chi phí thấp.

* Hoạt động tốt ở nhiệt độ thấp.

  * Ứng dụng: Lưu trữ quy mô lớn trong lưới điện.


## Pin Lưu Lượng (Flow Battery)

  * Cơ chế: Năng lượng lưu trữ trong dung dịch điện phân lỏng chứa ion kim loại.

  * Ưu điểm:

* Dễ mở rộng dung lượng chỉ bằng việc tăng kích thước bể chứa.

* Tuổi thọ hàng chục nghìn chu kỳ.

  * Nhược điểm: Mật độ năng lượng thấp, cần diện tích lớn.


## Pin Lithium-Sulfur (Li-S)

  * Ưu điểm: Mật độ năng lượng cao gấp 5 lần Li-ion, nguyên liệu lưu huỳnh rẻ.

  * Thách thức: Sự hình thành polysulfide gây suy giảm dung lượng.


# Tích hợp pin vào lưới điện thông minh

  * Điều độ năng lượng (Energy Dispatch): Tự động nạp/xả pin để cân bằng tải.

  * Dự báo nguồn tái tạo: Kết hợp AI để dự đoán sản lượng gió, mặt trời và điều chỉnh lưu trữ.

  * Microgrid: Các lưới điện nhỏ độc lập dùng pin để hoạt động khi mất điện từ lưới chính.


# Lợi ích đối với lưới điện thông minh

  * Ổn định điện áp và tần số: Đáp ứng nhanh các dao động tải.

  * Giảm chi phí vận hành: Tối ưu hóa mua bán điện trên thị trường.

  * Hỗ trợ năng lượng tái tạo: Tích trữ điện dư vào ban ngày, cung cấp khi thiếu.


# Thách thức và giải pháp

  * Chi phí đầu tư: Cần giảm giá thành pin thể rắn và pin Li-S.

  * Chuỗi cung ứng nguyên liệu: Phát triển khai thác natri, lưu huỳnh bền vững.

  * Quản lý tái chế: Thiết lập hệ thống thu hồi và tái chế pin an toàn.


# Hướng phát triển tương lai

  * Kết hợp trí tuệ nhân tạo: Dự đoán tuổi thọ pin và điều khiển sạc thông minh.

  * Pin lai (Hybrid Battery): Kết hợp nhiều công nghệ (Na-ion + Flow) để cân bằng hiệu suất và chi phí.

  * Tiêu chuẩn hóa toàn cầu: Thiết lập giao thức kết nối pin với lưới điện để dễ triển khai.

# Public076

# Bối cảnh và động lực phát triển

Trong kỷ nguyên chuyển đổi số toàn diện, dữ liệu trở thành tài sản cốt lõi của doanh nghiệp và chính phủ. Cùng lúc, hạ tầng mạng ngày càng phức tạp: từ điện toán đám mây, đa đám mây (multi-cloud), tới Internet vạn vật (IoT) và 5G/6G. Sự phức tạp này mở rộng bề mặt tấn công, khiến các kỹ thuật phòng thủ truyền thống khó theo kịp.

Các cuộc tấn công hiện đại như ransomware-as-a-service, deepfake phishing, và APT (Advanced Persistent Threat) có thể ẩn mình hàng tháng, thậm chí hàng năm, trước khi gây ra thiệt hại. Việc dựa vào chữ ký (signature-based detection) hay danh sách chặn tĩnh (static blocklists) không còn đủ.

Trí tuệ nhân tạo mang lại bước nhảy vọt: học từ dữ liệu, phát hiện hành vi bất thường, và tự động phản ứng trước mối đe dọa gần như thời gian thực.

#  Kiến trúc tổng thể của hệ thống phòng thủ AI

Một giải pháp AI an ninh mạng toàn diện thường bao gồm nhiều lớp:

## Tầng thu thập dữ liệu

  * Nguồn dữ liệu: nhật ký hệ thống (syslog), gói tin mạng, sự kiện bảo mật từ các thiết bị IoT, truy cập đám mây.

  * Chuẩn hóa: hợp nhất định dạng từ nhiều nguồn, loại bỏ dữ liệu nhiễu và trùng lặp.


## Tầng phân tích và học máy

  * Giám sát (Supervised Learning): sử dụng dữ liệu đã gắn nhãn (ví dụ, gói tin tấn công) để dự đoán tấn công đã biết.

  * Không giám sát (Unsupervised/Anomaly Detection): tìm kiếm mẫu hành vi bất thường, hữu ích với các cuộc tấn công 0-day.

  * Học bán giám sát và tự giám sát: giảm phụ thuộc vào dữ liệu gắn nhãn khan hiếm.

  * Học tăng cường (Reinforcement Learning): cho phép hệ thống tự điều chỉnh chính sách phản ứng dựa trên kết quả.


## Tầng phát hiện thời gian thực

  * AI phân tích luồng dữ liệu liên tục, đưa ra cảnh báo gần như tức thời.

  * Kết hợp với các hệ thống Intrusion Detection/Prevention (IDS/IPS) để tự động chặn lưu lượng độc hại.


## Tầng phản ứng và tự động hóa

  * Tự động cách ly thiết bị nghi nhiễm.

  * Cập nhật quy tắc tường lửa động.

  * Tích hợp nền tảng SOAR (Security Orchestration, Automation and Response) để phối hợp hành động đa hệ thống.


#  Kỹ thuật AI nổi bật và vai trò

  * Deep Neural Networks (DNN): Khả năng học biểu diễn phi tuyến tính cao, thích hợp cho dữ liệu mạng phức tạp.

  * Recurrent Neural Networks (RNN, LSTM, GRU): Xuất sắc trong phân tích chuỗi thời gian, ví dụ phát hiện tấn công DDoS dựa trên luồng lưu lượng.

  * Graph Neural Networks (GNN): Mô hình hóa quan hệ giữa các nút mạng, giúp phát hiện botnet hoặc hành vi lan truyền của mã độc.

  * Generative Adversarial Networks (GAN): Sinh dữ liệu tấn công giả để huấn luyện mô hình phòng thủ, nâng cao khả năng chống đỡ trước kịch bản mới.


# .Ứng dụng thực tiễn đa dạng

## Phát hiện xâm nhập thông minh

  * AI thay thế chữ ký tĩnh, phát hiện 0-day exploit và tấn công chưa từng ghi nhận.


## Phòng chống lừa đảo (Anti-Phishing)

  * Phân tích ngôn ngữ email, hành vi người gửi, và liên kết URL để phát hiện phishing tinh vi.


## Phân tích mã độc tự động

  * Học từ đặc trưng hành vi chạy của malware, kể cả khi mã được nén hoặc làm rối.


## Bảo vệ IoT

  * Mạng cảm biến, thiết bị đeo y tế và camera IP thường thiếu lớp bảo mật truyền thống, AI có thể theo dõi hành vi để ngăn botnet.


## Tự động ứng phó sự cố

  * Khi phát hiện vi phạm, hệ thống có thể tự cô lập máy chủ, vô hiệu hóa tài khoản bị xâm nhập, đồng thời gửi báo cáo chi tiết.


# Lợi ích chiến lược

  * Phát hiện nhanh và chính xác: Giảm thời gian trung bình phát hiện (MTTD) từ hàng giờ xuống chỉ vài giây.

  * Khả năng thích ứng: Mô hình liên tục học từ dữ liệu mới, không bị giới hạn bởi danh sách chặn tĩnh.

  * Tối ưu chi phí nhân lực: Giảm tải cho đội ngũ SOC (Security Operation Center), tập trung vào quyết định chiến lược.

  * Khả năng mở rộng: Xử lý khối lượng dữ liệu từ hàng triệu điểm cuối mà vẫn đảm bảo tốc độ.


# Thách thức và hạn chế

  * Thiếu dữ liệu gắn nhãn: Việc phân loại lưu lượng độc hại đòi hỏi chuyên gia, tốn kém thời gian.

  * Tấn công đối kháng (Adversarial Attack): Hacker có thể tạo dữ liệu giả đánh lừa mô hình.

  * Quyền riêng tư và tuân thủ pháp lý: Thu thập và xử lý dữ liệu phải tuân theo chuẩn GDPR, HIPAA.

  * Khả năng giải thích (Explainability): Các mô hình sâu thường khó giải thích, gây khó khăn khi cần bằng chứng pháp lý.


#  Hướng nghiên cứu và phát triển tương lai

  * Explainable AI (XAI): Cung cấp lý do, bằng chứng rõ ràng cho từng cảnh báo để chuyên gia bảo mật kiểm chứng.

  * Federated Learning: Nhiều tổ chức cùng huấn luyện mô hình chung mà không chia sẻ dữ liệu thô, bảo vệ quyền riêng tư.

  * Multi-Agent Systems: Nhiều tác nhân AI hợp tác, trao đổi thông tin tấn công trên quy mô toàn cầu.

  * Kết hợp Blockchain: Ghi lại nhật ký bảo mật bất biến, tạo bằng chứng không thể chối cãi.

  * AI kết hợp lượng tử (Quantum AI): Tăng tốc huấn luyện mô hình khổng lồ trong thời gian gần như thực.


# Ví dụ thực tế tiêu biểu

  * Google Chronicle & Microsoft Sentinel: Sử dụng AI để phân tích hàng petabyte dữ liệu bảo mật, phát hiện tấn công trong vài phút.

  * Darktrace: Ứng dụng Machine Learning không giám sát để phát hiện bất thường trong hành vi người dùng và thiết bị.

  * IBM QRadar + Watson: Tích hợp NLP của Watson để đọc, hiểu và liên kết thông tin từ hàng triệu tài liệu bảo mật.

# Public077

#  Bối cảnh và nhu cầu cấp thiết

Chuỗi cung ứng toàn cầu là mạng lưới phức tạp liên kết nhà sản xuất, nhà cung ứng nguyên liệu, kho bãi, các công ty vận tải, và nhà bán lẻ. Mỗi sản phẩm, từ dược phẩm, thực phẩm, đến linh kiện điện tử, có thể trải qua hàng chục quốc gia và hàng trăm điểm trung gian.

Tuy nhiên, quá trình này gặp nhiều thách thức:

  * Thiếu minh bạch: Khó xác định chính xác nguồn gốc, đặc biệt với thực phẩm tươi sống hoặc thuốc.

  * Nguy cơ giả mạo: Sản phẩm giả, kém chất lượng dễ dàng thâm nhập.

  * Dữ liệu phân tán: Mỗi bên lưu trữ thông tin riêng, không đồng bộ, gây chậm trễ.

  * Chi phí xác thực cao: Việc đối soát thủ công giấy tờ, chứng từ kéo dài thời gian giao hàng và tăng chi phí.


Blockchain nổi lên như giải pháp tạo một “sổ cái phân tán” toàn cầu, minh bạch, chống chỉnh sửa, cho phép tất cả bên liên quan truy cập cùng một phiên bản dữ liệu sự thật.

#  Nguyên lý hoạt động cốt lõi của Blockchain

## Cấu trúc khối (Block):

  * Mỗi khối chứa dữ liệu giao dịch, thông tin lô hàng, thời gian, chữ ký số.

  * Khối mới được thêm sau khi đạt đồng thuận của mạng lưới.


## Chuỗi liên kết (Chain):

  * Các khối nối với nhau bằng hàm băm (hash), đảm bảo không thể chỉnh sửa lùi.


## Cơ chế đồng thuận:

  * Tùy quy mô, chuỗi cung ứng có thể dùng Proof of Stake (PoS), Practical Byzantine Fault Tolerance (PBFT) hoặc Proof of Authority (PoA) để xác nhận giao dịch nhanh, tiết kiệm năng lượng.


## Hợp đồng thông minh (Smart Contract):

  * Các điều khoản giao dịch được lập trình sẵn.

  * Tự động thanh toán, phát lệnh giao hàng khi điều kiện đạt chuẩn.


# Ứng dụng chi tiết trong chuỗi cung ứng

##  Truy xuất nguồn gốc minh bạch

  * Mỗi lần sản phẩm di chuyển, thông tin như nhiệt độ bảo quản, địa điểm, thời gian được ghi vào blockchain.

  * Người tiêu dùng chỉ cần quét mã QR để biết toàn bộ lịch sử sản phẩm.

  * Ví dụ: IBM Food Trust giúp Walmart truy xuất nguồn gốc xoài từ nông trại đến kệ hàng chỉ trong 2,2 giây (so với 6 ngày trước đây).


## Chống giả mạo và gian lận

  * Sản phẩm gắn mã định danh duy nhất, dữ liệu không thể sửa đổi.

  * Ngành dược phẩm: blockchain giúp đảm bảo thuốc không bị thay thế hay tráo đổi.


## Tự động hóa thanh toán và hợp đồng

  * Khi hàng hóa đến đúng địa điểm, cảm biến IoT cập nhật dữ liệu, Smart Contract tự động giải ngân.

  * Giảm nhu cầu trung gian tài chính, giảm chi phí giao dịch quốc tế.


##  Tối ưu vận chuyển và tồn kho

  * Dữ liệu thời gian thực giúp nhà quản lý dự báo nhu cầu, giảm hàng tồn, và điều phối xe vận chuyển hiệu quả.

  * Tích hợp với hệ thống AI để tối ưu tuyến đường, giảm phát thải carbon.


## Đảm bảo tuân thủ và kiểm toán

  * Chứng nhận an toàn thực phẩm, tiêu chuẩn môi trường, hóa đơn đều được ghi bất biến.

  * Giúp công ty đáp ứng các quy định như FDA, EU Food Law, hoặc ISO 9001.


#  Lợi ích chiến lược vượt trội

  * Minh bạch toàn diện: Mọi bên tham gia truy cập cùng một nguồn dữ liệu, hạn chế tranh chấp.

  * Tốc độ xử lý nhanh: Rút ngắn thời gian thông quan từ nhiều ngày xuống vài giờ.

  * Giảm chi phí trung gian: Cắt bỏ các khâu đối soát thủ công và đơn vị trung gian tài chính.

  * Tăng niềm tin người tiêu dùng: Minh bạch nguồn gốc sản phẩm, bảo vệ thương hiệu.


#  Thách thức triển khai

  1. Quy mô giao dịch khổng lồ:

* Hàng tỷ giao dịch đòi hỏi blockchain có khả năng mở rộng, cần giải pháp layer 2 hoặc sidechain.

  2. Bảo mật dữ liệu nhạy cảm:

* Phải kết hợp mã hóa, quyền truy cập theo vai trò, và kênh truyền riêng tư để bảo vệ bí mật thương mại.

  3. Chi phí và chuẩn hóa:

* Cần chuẩn giao tiếp chung giữa các quốc gia, doanh nghiệp và nền tảng.

  4. Tích hợp hệ thống hiện hữu:

* Đòi hỏi API linh hoạt và chiến lược chuyển đổi dần để tránh gián đoạn hoạt động.


#  Trường hợp điển hình

  * TradeLens (Maersk & IBM):  
Hơn 100 nhà khai thác cảng và hải quan toàn cầu tham gia, giúp giảm 40% thời gian thông quan.

  * De Beers:  
Theo dõi từng viên kim cương từ mỏ đến cửa hàng, ngăn chặn “kim cương xung đột”.

  * Walmart – IBM Food Trust:  
Đảm bảo thực phẩm tươi an toàn, truy xuất nguồn gốc trong vài giây.


#  Tương lai và xu hướng

  * Kết hợp IoT: Cảm biến tự động ghi dữ liệu nhiệt độ, độ ẩm, vị trí vào blockchain theo thời gian thực.

  * Blockchain liên chuỗi (Interoperability): Cho phép nhiều blockchain (Hyperledger, Ethereum, Corda) tương tác liền mạch.

  * AI + Blockchain: Phân tích dữ liệu chuỗi cung ứng để dự báo nhu cầu, nhận diện rủi ro.

  * Tính bền vững: Sử dụng blockchain để chứng minh sản phẩm thân thiện môi trường và giảm phát thải

# Public078

# Giới thiệu

Trong bối cảnh Công nghiệp 4.0, các nhà máy thông minh ngày càng phụ thuộc vào hệ thống cảm biến, robot hợp tác, và thiết bị IoT. Mỗi giây, hàng tỷ dữ liệu về nhiệt độ, áp suất, độ rung, âm thanh, hình ảnh được tạo ra. Việc truyền toàn bộ lượng dữ liệu này về trung tâm đám mây để xử lý không chỉ tốn băng thông mà còn tạo ra độ trễ không thể chấp nhận cho các ứng dụng thời gian thực như điều khiển robot hay giám sát an toàn.

Điện toán biên (Edge Computing) giải quyết vấn đề bằng cách đưa khả năng tính toán và phân tích dữ liệu tới sát nguồn phát sinh – ngay tại thiết bị hoặc gateway trong nhà máy – giúp giảm thiểu độ trễ, giảm tải cho đường truyền và tăng tính bảo mật. Đây là nền tảng cho các ứng dụng tự động hóa, sản xuất linh hoạt, và phản ứng nhanh trong môi trường công nghiệp hiện đại.

# Edge Computing là gì?

**Edge Computing** , hay còn gọi là **điện toán biên** , là một mô hình điện toán phân tán, trong đó khả năng xử lý và lưu trữ dữ liệu được đưa đến gần các thiết bị hoặc khu vực tạo ra dữ liệu. Cách tiếp cận này nhằm giảm độ trễ trong quá trình xử lý và giúp tiết kiệm băng thông mạng.

Khái niệm Edge Computing có nguồn gốc từ các mạng phân phối nội dung (CDN), được phát triển vào cuối những năm 1990 để tối ưu hóa việc phân phối nội dung web và video bằng cách sử dụng các máy chủ gần người dùng. Theo thời gian, các CDN này đã được mở rộng chức năng để lưu trữ không chỉ dữ liệu mà cả ứng dụng và các phần của ứng dụng tại rìa mạng, từ đó hình thành nên các dịch vụ điện toán biên đầu tiên, chẳng hạn như xử lý và phân tích dữ liệu theo thời gian thực.

Một kiến trúc Edge Computing điển hình thường bao gồm ba tầng chính:

  * **Tầng đám mây (hoặc tầng trung tâm)** : đảm nhiệm việc lưu trữ và xử lý toàn bộ dữ liệu quy mô lớn.

  * **Tầng biên (tầng xử lý)** : thực hiện xử lý dữ liệu gần thời gian thực, ngay tại vị trí gần với nơi dữ liệu được tạo ra.

  * **Tầng thiết bị (tầng cảm biến)** : phụ trách thu thập dữ liệu ban đầu và thực hiện các tác vụ xử lý đơn giản tại chỗ.


# Nguyên lý hoạt động

Thay vì phụ thuộc hoàn toàn vào các trung tâm dữ liệu đám mây tập trung, Edge Computing phân phối năng lực xử lý đến các nút biên. Các thiết bị này có thể là:

  * Bộ định tuyến thông minh, mini server, hoặc gateway công nghiệp.

  * Máy chủ biên được đặt ngay trong nhà máy hoặc trạm sản xuất.


Quy trình điển hình:

  1. Cảm biến và thiết bị IoT thu thập dữ liệu tại dây chuyền.

  2. Dữ liệu được xử lý sơ bộ hoặc chạy mô hình AI trực tiếp tại nút biên.

  3. Chỉ thông tin quan trọng hoặc dữ liệu đã tổng hợp mới được gửi về đám mây để lưu trữ lâu dài, phân tích nâng cao, hoặc huấn luyện mô hình lớn.


Điều này tạo nên kiến trúc phân tán, giúp hệ thống vừa đảm bảo phản hồi nhanh, vừa tận dụng sức mạnh tính toán đám mây khi cần.

# Lợi ích trong công nghiệp 4.0

  * Độ trễ cực thấp: Quyết định sản xuất hoặc cảnh báo an toàn có thể đưa ra trong vài mili giây, quan trọng cho robot tự hành và dây chuyền tốc độ cao.

  * Tiết kiệm băng thông: Giảm đáng kể dữ liệu phải gửi về trung tâm, cắt chi phí đường truyền và giảm nguy cơ tắc nghẽn.

  * Bảo mật dữ liệu: Dữ liệu nhạy cảm về quy trình sản xuất, công thức, bản thiết kế… không phải rời khỏi nhà máy, giảm rủi ro rò rỉ.

  * Khả năng tự chủ: Khi mạng Internet gặp sự cố, hệ thống biên vẫn hoạt động độc lập, đảm bảo dây chuyền không bị gián đoạn.

  * Tính mở rộng: Dễ dàng thêm mới thiết bị hoặc dây chuyền mà không ảnh hưởng đến toàn bộ hệ thống.


# Ứng dụng tiêu biểu

  * Robot hợp tác (Cobots): Các robot có thể xử lý hình ảnh và cảm biến tại chỗ để tránh va chạm và phối hợp an toàn với công nhân.

  * Bảo trì dự đoán (Predictive Maintenance): Phân tích rung động, âm thanh, nhiệt độ trực tiếp tại biên giúp phát hiện sớm hỏng hóc, giảm thời gian ngừng máy.

  * Kiểm soát chất lượng sản phẩm: Camera công nghiệp chạy mô hình thị giác máy tính ngay trên nút biên để loại bỏ sản phẩm lỗi trong thời gian thực.

  * Quản lý năng lượng: Hệ thống edge tối ưu tiêu thụ điện theo thời gian thực, giảm chi phí vận hành.

  * Thực tế tăng cường (AR) cho bảo dưỡng: Thiết bị biên cung cấp dữ liệu trực tiếp cho kính AR của kỹ sư, hỗ trợ thao tác chính xác.


# Kiến trúc hệ thống

Một kiến trúc điển hình gồm:

  * Thiết bị IoT/Cảm biến: Thu thập dữ liệu thô liên tục.

  * Nút Edge/Gateway: Mini server hoặc thiết bị chuyên dụng có GPU/TPU nhỏ, chạy thuật toán AI để lọc và phân tích dữ liệu ngay lập tức.

  * Đám mây: Lưu trữ lịch sử, huấn luyện mô hình lớn và điều phối toàn hệ thống.


Kết hợp với mạng 5G/6G, việc truyền dữ liệu giữa biên và đám mây trở nên linh hoạt và đáng tin cậy, hỗ trợ các ứng dụng đòi hỏi băng thông cao.

# Công nghệ liên quan

  * Container và Kubernetes tại biên: Giúp triển khai, nâng cấp ứng dụng AI nhanh chóng và đồng nhất.

  * TinyML và Edge AI: Mô hình học máy gọn nhẹ tối ưu cho phần cứng giới hạn.

  * Bảo mật đầu-cuối (End-to-End Encryption): Bảo vệ dữ liệu trong toàn bộ quá trình thu thập, xử lý và truyền tải.

  * Chuẩn giao thức công nghiệp (OPC UA, MQTT): Đảm bảo khả năng tương thích giữa nhiều nhà sản xuất thiết bị.


# Thách thức triển khai

  * Quản lý phân tán: Hàng trăm hoặc hàng nghìn nút biên đòi hỏi giải pháp quản lý tập trung, tự động cập nhật phần mềm và vá lỗi.

  * Bảo mật đa tầng: Cần xác thực thiết bị, phân quyền truy cập, phát hiện xâm nhập ở cả cấp cảm biến và gateway.

  * Chi phí đầu tư: Thiết bị phần cứng mạnh, chịu được môi trường khắc nghiệt, đòi hỏi vốn đầu tư ban đầu đáng kể.

  * Đồng bộ dữ liệu: Phải thiết kế cơ chế đồng bộ khi kết nối Internet không ổn định.


# Xu hướng tương lai

  * AI tự học tại biên: Thiết bị không chỉ suy luận mà còn huấn luyện mô hình nhỏ trên dữ liệu cục bộ.

  * Kết hợp Blockchain: Ghi lại dữ liệu sản xuất bất biến, tăng độ tin cậy cho các đối tác trong chuỗi cung ứng.

  * Tích hợp năng lượng tái tạo: Hệ thống biên sử dụng nguồn năng lượng xanh, vận hành bền vững và giảm phát thải carbon.

  * Edge-to-Cloud Continuum: Ranh giới giữa biên và đám mây mờ dần, cho phép chia sẻ tài nguyên động tùy theo tải công việc.

# Public079

# Giới thiệu

Phân tích ảnh y tế là một trong những ứng dụng quan trọng nhất của trí tuệ nhân tạo trong y học hiện đại. Các kỹ thuật truyền thống dựa trên đặc trưng thủ công (hand-crafted features) thường thiếu chính xác và khó tổng quát hóa cho các loại bệnh khác nhau. Mạng Thần Kinh Tích Chập (CNN) đã mở ra kỷ nguyên mới cho thị giác máy tính trong y tế, với khả năng học trực tiếp các đặc trưng từ dữ liệu hình ảnh lớn, từ đó hỗ trợ bác sĩ chẩn đoán nhanh và chính xác hơn.

CNN được áp dụng trong nhiều dạng dữ liệu y khoa: ảnh X-quang, MRI (Magnetic Resonance Imaging), CT (Computed Tomography), ảnh siêu âm, và ảnh hiển vi tế bào. Nhờ khả năng tự động trích xuất đặc trưng, CNN đã trở thành nền tảng của nhiều hệ thống hỗ trợ quyết định y khoa (Clinical Decision Support Systems).

# Nguyên lý hoạt động

CNN hoạt động dựa trên các lớp tích chập (convolutional layers) và lớp gộp (pooling layers) nhằm phát hiện các mẫu không gian trong hình ảnh.

  * Lớp tích chập (Convolutional Layer): Sử dụng bộ lọc (kernel) để phát hiện đặc trưng cục bộ như cạnh, đường viền, hình dạng.

  * Lớp gộp (Pooling Layer): Giảm chiều dữ liệu, giữ lại thông tin quan trọng, tăng tính bất biến với dịch chuyển.

  * Lớp kết nối đầy đủ (Fully Connected Layer): Kết hợp các đặc trưng đã học để phân loại bệnh lý.

  * Hàm kích hoạt phi tuyến (ReLU, Sigmoid, Softmax): Giúp mô hình học được các quan hệ phức tạp.


Điểm mạnh của CNN trong y tế là khả năng học đặc trưng phù hợp từ chính dữ liệu bệnh án, thay vì phụ thuộc vào chuyên gia thiết kế đặc trưng thủ công.

# Cấu trúc mạng CNN

Mạng CNN là một tập hợp các lớp Convolution chồng lên nhau và sử dụng các hàm nonlinear activation như ReLU và tanh để kích hoạt các trọng số trong các node. Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo.

Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo. Trong mô hình mạng truyền ngược (feedforward neural network) thì mỗi neural đầu vào (input node) cho mỗi neural đầu ra trong các lớp tiếp theo.

Mô hình này gọi là mạng kết nối đầy đủ (fully connected layer) hay mạng toàn vẹn (affine layer). Còn trong mô hình CNNs thì ngược lại. Các layer liên kết được với nhau thông qua cơ chế convolution.

Layer tiếp theo là kết quả convolution từ layer trước đó, nhờ vậy mà ta có được các kết nối cục bộ. Như vậy mỗi neuron ở lớp kế tiếp sinh ra từ kết quả của filter áp đặt lên một vùng ảnh cục bộ của neuron trước đó.

Mỗi một lớp được sử dụng các filter khác nhau thông thường có hàng trăm hàng nghìn filter như vậy và kết hợp kết quả của chúng lại. Ngoài ra có một số layer khác như pooling/subsampling layer dùng để chắt lọc lại các thông tin hữu ích hơn (loại bỏ các thông tin nhiễu).

Trong quá trình huấn luyện mạng (traning) CNN tự động học các giá trị qua các lớp filter dựa vào cách thức mà bạn thực hiện. Ví dụ trong tác vụ phân lớp ảnh, CNNs sẽ cố gắng tìm ra thông số tối ưu cho các filter tương ứng theo thứ tự raw pixel > edges > shapes > facial > high-level features. Layer cuối cùng được dùng để phân lớp ảnh.

![Cấu trúc của mạng CNN](images/image1.png)

Trong mô hình CNN có 2 khía cạnh cần quan tâm là **tính bất biến** (Location Invariance) và **tính kết hợp** (Compositionality). Với cùng một đối tượng, nếu đối tượng này được chiếu theo các gốc độ khác nhau (translation, rotation, scaling) thì độ chính xác của thuật toán sẽ bị ảnh hưởng đáng kể.

Pooling layer sẽ cho bạn tính bất biến đối với phép dịch chuyển (translation), phép quay (rotation) và phép co giãn (scaling). Tính kết hợp cục bộ cho ta các cấp độ biểu diễn thông tin từ mức độ thấp đến mức độ cao và trừu tượng hơn thông qua convolution từ các filter.

Đó là lý do tại sao CNNs cho ra mô hình với độ chính xác rất cao. Cũng giống như cách con người nhận biết các vật thể trong tự nhiên.

Mạng CNN sử dụng 3 ý tưởng cơ bản:

  * **các trường tiếp nhận cục bộ** (local receptive field)

  * **trọng số chia sẻ** (shared weights)

  * **tổng hợp** (pooling).


## Trường tiếp nhận cục bộ (local receptive field)

Đầu vào của mạng CNN là một ảnh. Ví dụ như ảnh có kích thước 28×28 thì tương ứng đầu vào là một ma trận có 28×28 và giá trị mỗi điểm ảnh là một ô trong ma trận. Trong mô hình mạng ANN truyền thống thì chúng ta sẽ kết nối các neuron đầu vào vào tầng ảnh.

Tuy nhiên trong CNN chúng ta không làm như vậy mà chúng ta chỉ kết nối trong một vùng nhỏ của các neuron đầu vào như một filter có kích thước 5×5 tương ứng (28- 5 + 1) 24 điểm ảnh đầu vào. Mỗi một kết nối sẽ học một trọng số và mỗi neuron ẩn sẽ học một bias. Mỗi một vùng 5×5 đấy gọi là một trường tiếp nhận cục bộ.

![A diagram of a brain function AI-generated content may be incorrect.](images/image2.png)

Một cách tổng quan, ta có thể tóm tắt các bước tạo ra 1 hidden layer bằng các cách sau:

  1. **Tạo ra neuron ẩn đầu tiên trong lớp ẩn 1** ![A diagram of a test AI-generated content may be incorrect.](images/image3.png)

  2. **Dịch filter qua bên phải một cột sẽ tạo được neuron ẩn thứ 2.** ![A diagram of a number of circles AI-generated content may be incorrect.](images/image4.png)


với bài toán nhận dạng ảnh người ta thường gọi ma trận lớp đầu vào là feature map, trọng số xác định các đặc trương là shared weight và độ lệch xác định một feature map là shared bias. Như vậy đơn giản nhất là qua các bước trên chúng ta chỉ có 1 feature map. Tuy nhiên trong nhận dạng ảnh chúng ta cần nhiều hơn một feature map.![A diagram of a machine AI-generated content may be incorrect.](images/image5.png)

Như vậy, local receptive field thích hợp cho việc phân tách dữ liệu ảnh, giúp chọn ra những vùng ảnh có giá trị nhất cho việc đánh giá phân lớp.

## Trọng số chia sẻ (shared weight and bias)

Đầu tiên, các trọng số cho mỗi filter (kernel) phải giống nhau. Tất cả các nơ-ron trong lớp ẩn đầu sẽ phát hiện chính xác feature tương tự chỉ ở các vị trí khác nhau trong hình ảnh đầu vào. Chúng ta gọi việc map từ input layer sang hidden layer là một feature map. Vậy mối quan hệ giữa số lượng Feature map với số lượng tham số là gì?

_Chúng ta thấy mỗi fearture map cần 25 = 5×5 shared weight và 1 shared bias. Như vậy mỗi feature map cần 5×5+1 = 26 tham số. Như vậy nếu có 10 feature map thì có 10×26 = 260 tham số. Chúng ta xét lại nếu layer đầu tiên có kết nối đầy đủ nghĩa là chúng ta có 28×28=784 neuron đầu vào như vậy ta chỉ có 30 neuron ẩn. Như vậy ta cần 28x28x30 shared weight và 30 shared bias. Tổng số tham số là 28x28x30+30 tham số lớn hơn nhiều so với CNN. Ví dụ vừa rồi chỉ mô tả để thấy được sự ước lượng số lượng tham số chứ chúng ta không so sánh được trực tiếp vì 2 mô hình khác nhau. Nhưng điều chắc chắn là nếu mô hình có số lượng tham số ít hơn thì nó sẽ chạy nhanh hơn._

Xem tiếp...

Tóm lại, một convolutional layer bao gồm các feature map khác nhau. Mỗi một feature map giúp detect một vài feature trong bức ảnh. Lợi ích lớn nhất của trọng số chia sẻ là giảm tối đa số lượng tham số trong mạng CNN.

## Lớp tổng hợp (pooling layer)

Lớp pooling thường được sử dụng ngay sau lớp convulational để đơn giản hóa thông tin đầu ra để giảm bớt số lượng neuron.

![A diagram of a diagram of a diagram AI-generated content may be incorrect.](images/image1.png)

Thủ tục pooling phổ biến là max-pooling, thủ tục này chọn giá trị lớn nhất trong vùng đầu vào 2×2.![A diagram of a diagram AI-generated content may be incorrect.](images/image6.png)

Như vậy qua lớp Max Pooling thì số lượng neuron giảm đi phân nửa. Trong một mạng CNN có nhiều Feature Map nên mỗi Feature Map chúng ta sẽ cho mỗi Max Pooling khác nhau. Chúng ta có thể thấy rằng Max Pooling là cách hỏi xem trong các đặc trưng này thì đặc trưng nào là đặc trưng nhất. Ngoài Max Pooling còn có L2 Pooling.

Cuối cùng ta đặt tất cả các lớp lại với nhau thành một CNN với đầu ra gồm các neuron với số lượng tùy bài toán.

![A diagram of a block diagram AI-generated content may be incorrect.](images/image7.png)

2 lớp cuối cùng của các kết nối trong mạng là một lớp đầy đủ kết nối (fully connected layer) . Lớp này nối mọi nơron từ lớp max pooled tới mọi nơron của tầng ra.

# Ứng dụng trong phân tích ảnh y tế

  * Chẩn đoán bệnh phổi từ ảnh X-quang: CNN có thể phát hiện viêm phổi, lao, hoặc COVID-19 với độ chính xác cao.

  * Phát hiện khối u từ MRI và CT: Hỗ trợ xác định kích thước, vị trí, và giai đoạn của khối u não, gan, hoặc phổi.

  * Phân đoạn polyp và tổn thương nội soi: CNN giúp phát hiện polyp ruột kết sớm, hỗ trợ phòng ngừa ung thư.

  * Nhận diện tế bào bất thường từ ảnh hiển vi: Ứng dụng trong xét nghiệm máu hoặc tế bào học (cytology).

  * Hỗ trợ phẫu thuật thông minh: Kết hợp CNN với hình ảnh thời gian thực từ camera nội soi để dẫn hướng phẫu thuật.


# Kiến trúc CNN phổ biến trong y tế

  * LeNet và AlexNet: Các mô hình khởi đầu, thường dùng cho dữ liệu ít phức tạp.

  * VGGNet, ResNet, DenseNet: Khả năng học sâu, xử lý dữ liệu ảnh y tế có độ phân giải cao.

  * U-Net: Chuyên biệt cho bài toán phân đoạn ảnh y tế, nổi bật trong phân đoạn MRI, CT và ảnh nội soi.

  * EfficientNet: Cân bằng hiệu quả giữa độ chính xác và tốc độ tính toán, phù hợp cho hệ thống y tế thời gian thực.


Ngoài ra, các mô hình mới như Vision Transformer (ViT) đang dần kết hợp với CNN để nâng cao khả năng xử lý hình ảnh y tế phức tạp.

# Lợi ích trong y tế

  * Chẩn đoán nhanh hơn: CNN phân tích hàng nghìn hình ảnh chỉ trong vài phút, hỗ trợ bác sĩ tiết kiệm thời gian.

  * Độ chính xác cao: Phát hiện những chi tiết tinh vi mà mắt thường có thể bỏ sót.

  * Hỗ trợ quyết định lâm sàng: Giúp bác sĩ có thêm bằng chứng trong quá trình chẩn đoán.

  * Giảm chi phí: Tự động hóa quy trình đọc phim, giảm tải cho nhân lực y tế.

  * Cá nhân hóa điều trị: Kết hợp CNN với dữ liệu bệnh nhân để dự đoán đáp ứng thuốc hoặc kết quả điều trị.


# Thách thức và hạn chế

  * Thiếu dữ liệu gắn nhãn: Dữ liệu y tế lớn nhưng việc gắn nhãn yêu cầu bác sĩ, tốn kém thời gian.

  * Chênh lệch dữ liệu (Data Shift): Mô hình huấn luyện trên dữ liệu bệnh viện này có thể hoạt động kém trên bệnh viện khác.

  * Giải thích mô hình (Explainability): CNN thường bị coi là “hộp đen”, khó giải thích kết quả cho bác sĩ.

  * Vấn đề đạo đức và pháp lý: Liên quan đến bảo mật dữ liệu bệnh nhân và trách nhiệm pháp lý khi AI chẩn đoán sai.

  * Yêu cầu tính toán cao: Đào tạo CNN cần GPU/TPU mạnh, khó triển khai tại bệnh viện nhỏ.


# Xu hướng tương lai

  * CNN kết hợp với Explainable AI (XAI): Tạo bản đồ nhiệt (heatmap) hiển thị vùng ảnh mà mô hình tập trung, giúp bác sĩ hiểu và tin tưởng hơn.

  * Học chuyển giao (Transfer Learning): Sử dụng mô hình tiền huấn luyện từ tập dữ liệu lớn để áp dụng vào lĩnh vực y tế, giảm nhu cầu dữ liệu nhãn.

  * Liên kết với Federated Learning: Nhiều bệnh viện cùng huấn luyện mô hình CNN mà không cần chia sẻ dữ liệu bệnh nhân, đảm bảo quyền riêng tư.

  * Ứng dụng mô hình nhẹ (Lightweight CNN): Tối ưu để chạy trên thiết bị cầm tay, máy siêu âm di động hoặc edge device trong bệnh viện.

  * Kết hợp CNN và Transformer: Tận dụng khả năng trích xuất đặc trưng cục bộ (CNN) và quan hệ toàn cục (Transformer) để nâng cao độ chính xác.

# Public080

# Giới thiệu

Phát triển thuốc truyền thống thường kéo dài 10–15 năm và tiêu tốn hàng tỷ đô la. Quy trình bao gồm nghiên cứu cơ bản, xác định mục tiêu (target), thiết kế phân tử, thử nghiệm lâm sàng và phê duyệt. Quá trình này tốn kém do phải sàng lọc hàng triệu hợp chất để tìm ra vài phân tử tiềm năng.

Trí tuệ nhân tạo tạo sinh (Generative AI) – bao gồm các mô hình như Generative Adversarial Networks (GANs), Variational Autoencoders (VAEs) và Diffusion Models – đã mở ra khả năng tạo ra các phân tử mới đáp ứng tiêu chí dược lý mong muốn, rút ngắn đáng kể thời gian và chi phí.

# Trí tuệ nhân tạo tạo sinh là gì?

_Trí tuệ nhân tạo tạo sinh_ (Generative AI) là một lĩnh vực của trí tuệ nhân tạo tập trung vào việc tạo ra dữ liệu mới, dựa trên dữ liệu đã được học trước đó. Dữ liệu này có thể bao gồm văn bản, hình ảnh, âm thanh, video, hoặc các loại nội dung khác. Các mô hình Generative AI không chỉ nhận biết và phân loại thông tin, mà còn có khả năng sáng tạo, mô phỏng và tái hiện thông tin. Một số ví dụ phổ biến nhất của trí tuệ nhân tạo tạo sinh là ChatGPT tạo văn bản, DeepFake mô phỏng khuôn mặt người trong video. Các mô hình này thường sở hữu một số đặc điểm cơ bản là:

  * Khả năng sáng tạo: Tạo ra nội dung mới, độc đáo dựa trên các mẫu đã học.

  * Tính thích ứng cao: Có thể áp dụng vào nhiều lĩnh vực, từ sáng tạo nội dung (viết báo, tạo hình ảnh) đến nghiên cứu khoa học (tạo mô hình phân tử).

  * Sử dụng dữ liệu huấn luyện: Chất lượng nội dung tạo ra phụ thuộc nhiều vào quy mô và độ đa dạng của tập dữ liệu đã học.

  * Dựa trên mô hình học sâu (Deep Learning): Thường sử dụng các kiến trúc mạng nơ-ron tiên tiến như GANs, VAEs và Transformers.

  * Hạn chế sự giải thích: Mô hình thường được xem là hộp đen, khó giải thích rõ ràng lý do tại sao nó tạo ra kết quả cụ thể.


# Trí tuệ nhân tạo tạo sinh hoạt động như thế nào?

Việc triển khai giải pháp trí tuệ nhân tạo tạo sinh cho mọi trường hợp sử dụng yêu cầu phải có nhiều nỗ lực từ các nhà khoa học và nhà phát triển. Đó là vì GenAI được thực hiện nhờ các bộ dữ liệu lớn và các thuật toán trí tuệ nhân tạo được đào tạo phức tạp. Công nghệ này được xây dựng và triển khai cùng với trí tuệ nhân tạo và xử lý ngôn ngữ tự nhiên (NLP), cho phép trí tuệ nhân tạo xử lý và hiểu ngôn ngữ của con người. GenAI và NLP cùng nhau có thể hiểu được lời nhắc người dùng để tạo ra phản hồi thích hợp, cho dù là văn bản, video, hình ảnh hay âm thanh.

Các giải pháp trí tuệ nhân tạo tạo sinh sử dụng các hệ thống trí tuệ nhân tạo được gọi là [các mô hình ngôn ngữ lớn (LLM)](https://www.intel.vn/content/www/vn/vi/learn/large-language-models.html), sử dụng mạng thần kinh sâu để xử lý và tạo văn bản. Chúng được đào tạo trên lượng dữ liệu khổng lồ, tìm ra sự tương đồng giữa các loại dữ liệu và thông tin để tạo ra và cung cấp các kết quả đầu ra mới, mạch lạc.

LLM dựa vào cấu trúc transformer để xử lý các chuỗi đầu vào một cách song song, giúp cải thiện hiệu năng và tốc độ so với mạng nơ-ron cổ điển. Quy trình đào tạo mô hình cũng tiếp nhận thông tin từ các nhà khoa học dữ liệu và các chuyên gia về chủ đề giúp hướng dẫn quá trình học tập của thuật toán và dẫn dắt nó đến kết quả chính xác hơn.

Để hiện thực hóa các giải pháp trí tuệ nhân tạo tạo sinh, doanh nghiệp có thể đào tạo các mô hình từ đầu hoặc chọn mô hình đã được đào tạo sẵn có thể điều chỉnh theo nhu cầu cụ thể. Ví dụ: có thể đào tạo thuật toán chatbot GenAI theo các thuộc tính cụ thể của cơ sở khách hàng và mô hình kinh doanh của tổ chức. Hoặc một mô hình có mục đích tạo ra văn bản để tiếp thị nội dung có thể được chuyên môn hóa hoặc tinh chỉnh để tập trung vào một ngành và đối tượng cụ thể. Nhiều mô hình dành riêng cho từng lĩnh vực cũng đang nổi lên với tốc độ nhanh chóng. Các mô hình này được đào tạo trên các bộ dữ liệu nhỏ hơn, nhắm mục tiêu cụ thể hơn so với các mô hình lớn hơn. Kết quả mới đây cho thấy các mô hình nhỏ hơn này có thể tái tạo độ chính xác của các mô hình lớn hơn nếu được đào tạo dựa trên dữ liệu được chọn lọc cẩn thận.

Các nhà phát triển cũng có thể sử dụng chức năng [tạo tăng cường truy xuất (RAG)](https://www.intel.vn/content/www/vn/vi/learn/what-is-rag.html) để bổ sung cho các mô hình được đào tạo trước với dữ liệu cập nhật, độc quyền và bí mật từ cơ sở dữ liệu vector trong quá trình suy luận. Điều này đơn giản hóa quy trình tùy chỉnh và cập nhật, cũng như cho phép gán nguồn thông tin được tạo ra.

Dưới đây là tổng quan tóm lược (mặc dù nâng cao về kỹ thuật) về ba loại mô hình trí tuệ nhân tạo tạo sinh phổ biến:

  * **Mạng đối nghịch tạo sinh (GAN):** Các mạng này liên quan đến hai mạng thần kinh, một bộ tạo và một bộ phân biệt, được đào tạo đồng thời. Bộ tạo tạo ra các phiên bản dữ liệu mới, trong khi bộ phân biệt đánh giá chúng so với một bộ dữ liệu thực. Mục tiêu của bộ tạo là tạo ra dữ liệu không thể phân biệt được với dữ liệu thực, trong khi mục tiêu của bộ phân biệt là phân biệt chính xác giữa hai dữ liệu này. Theo thời gian, bộ tạo được cải thiện, tạo ra dữ liệu ngày càng thực tế.

  * **Bộ tự mã hóa biến thể (VAE):** VAE kết hợp các nguyên tắc từ mạng nơ-ron và mô hình xác suất để tạo ra các phiên bản dữ liệu mới thông qua quy trình mã hóa và giải mã. Mô hình VAE bắt đầu bằng cách nén dữ liệu đầu vào thành một đại diện đơn giản hóa các đặc điểm của nó. Sau đó, nó giải mã phiên bản đơn giản hóa đó, cố gắng tái cấu trúc dữ liệu đầu vào về dạng ban đầu. Thông qua quy trình này, VAE học được các tính năng và thông số cơ bản của dữ liệu, giúp nó tạo ra các kết quả đầu ra thực tế và có thể tùy chỉnh nhiều hơn.

  * **Mô hình transformer:** Các mô hình như Generative Pre-trained Transformer (GPT) có thể tạo ra văn bản mạch lạc và liên quan đến bối cảnh. Các mô hình này, ban đầu được thiết kế dành cho các công việc xử lý ngôn ngữ tự nhiên, được đào tạo trên các bộ dữ liệu lớn và có thể hoàn thành các lời nhắc văn bản, dịch ngôn ngữ, trả lời các câu hỏi và thậm chí có thể tạo ra các văn bản sáng tạo.


Nhiều chiến lược khác nhau có thể được sử dụng trong quá trình tạo ra để cân bằng giữa tính sáng tạo và sự gắn kết trong kết quả đầu ra. Hiện có nhiều nghiên cứu nhằm mục đích làm cho các mô hình này minh bạch hơn, giảm thiên kiến và cải thiện độ chính xác thực tế. Hiện cũng đã có chuyển động hướng đến các mô hình có thể đồng thời làm việc với nhiều loại dữ liệu, chẳng hạn như văn bản, hình ảnh và âm thanh.

# Cách Generative AI hỗ trợ thiết kế thuốc

Generative AI có thể học từ cơ sở dữ liệu hóa học khổng lồ để hiểu mối quan hệ giữa cấu trúc phân tử và tính chất dược học.

  * Mô hình tạo ra các phân tử mới có đặc điểm tối ưu: khả năng gắn kết với protein mục tiêu, tính ổn định, và ít độc tính.

  * Sử dụng reinforcement learning để tối ưu dần các phân tử dựa trên phản hồi từ các mô phỏng sinh học.

  * Kết hợp mô phỏng động lực học phân tử (molecular dynamics) và AI tạo sinh giúp dự đoán tương tác phân tử nhanh hơn.


# Ứng dụng thực tế

  * Tìm hợp chất kháng virus mới: Generative AI đã được sử dụng để đề xuất phân tử ức chế protein của SARS-CoV-2 trong giai đoạn đầu dịch COVID-19.

  * Kháng sinh thế hệ mới: Tìm ra hợp chất Halicin bằng mô hình học sâu, hiệu quả chống vi khuẩn kháng thuốc.

  * Thuốc điều trị ung thư: AI gợi ý cấu trúc phân tử tương tác đặc hiệu với thụ thể tế bào ung thư, hỗ trợ thiết kế thuốc đích (targeted therapy).

  * Tối ưu hóa thuốc sẵn có: Đề xuất biến thể cấu trúc để cải thiện dược động học hoặc giảm tác dụng phụ.


# Quy trình tích hợp AI trong phát triển thuốc

  * Xác định mục tiêu (Target Identification): AI phân tích dữ liệu gen và proteomics để tìm đích tác động.

  * Sinh phân tử mới (Molecule Generation): Mô hình tạo sinh đề xuất hàng nghìn cấu trúc phân tử.

  * Đánh giá in silico: Mô phỏng tính chất hóa lý, độ hòa tan, tính độc.

  * Tổng hợp và thử nghiệm: Các phân tử triển vọng được tổng hợp trong phòng thí nghiệm và thử nghiệm in vitro/in vivo.


# Ưu điểm nổi bật

  * Tốc độ vượt trội: Rút ngắn thời gian sàng lọc từ nhiều năm xuống vài tháng.

  * Tiết kiệm chi phí: Giảm đáng kể chi phí nghiên cứu ban đầu.

  * Khả năng khám phá không gian hóa học rộng: Khám phá hàng tỷ cấu trúc mà phương pháp truyền thống khó tiếp cận.

  * Cá nhân hóa y học: Đề xuất thuốc phù hợp với đặc điểm gen của từng nhóm bệnh nhân.


# Thách thức

  * Độ tin cậy của mô hình: Phân tử do AI đề xuất cần xác thực thực nghiệm.

  * Dữ liệu đào tạo: Cần cơ sở dữ liệu hóa học lớn, chuẩn hóa, chất lượng cao.

  * Vấn đề pháp lý và đạo đức: Quy định về bằng sáng chế, quyền sở hữu trí tuệ và trách nhiệm khi thuốc thất bại.

  * Khả năng giải thích: Khó hiểu tại sao mô hình chọn một cấu trúc cụ thể.


# Xu hướng tương lai

  * Kết hợp Generative AI và Quantum Computing: Tăng độ chính xác của mô phỏng lượng tử trong tương tác phân tử.

  * Học liên kết (Federated Learning): Cho phép nhiều viện nghiên cứu cùng huấn luyện mô hình mà không chia sẻ dữ liệu bí mật.

  * Tự động hóa phòng thí nghiệm (Lab Automation): Tích hợp robot tổng hợp hóa học với AI để khép kín quy trình thiết kế–thử nghiệm.

  * AI đa mô thức (Multimodal AI): Kết hợp dữ liệu gen, hình ảnh tế bào, và văn bản y khoa để thiết kế thuốc đa mục tiêu.

# Public081

# Giới thiệu

Khám phá vật liệu mới là nền tảng của nhiều lĩnh vực công nghệ, từ pin thế hệ mới, vật liệu siêu dẫn, hợp kim nhẹ cho hàng không vũ trụ đến các vật liệu nano tiên tiến. Quá trình truyền thống đòi hỏi nhiều năm thử nghiệm trong phòng thí nghiệm, tốn kém và khó mở rộng.

Mạng Nơ-ron Đồ Thị (Graph Neural Networks – GNN) đang nổi lên như công cụ mạnh mẽ cho khoa học vật liệu tính toán. Bởi vì cấu trúc của vật liệu – bao gồm nguyên tử và liên kết – tự nhiên được biểu diễn dưới dạng đồ thị (graph), GNN có thể trực tiếp học các đặc trưng này để dự đoán tính chất vật lý, hóa học và điện tử của vật liệu mới.

# Nguyên lý hoạt động

  * Biểu diễn vật liệu dưới dạng đồ thị:

* Nút (Node): Đại diện cho các nguyên tử.

* Cạnh (Edge): Biểu diễn liên kết hóa học hoặc khoảng cách không gian giữa các nguyên tử.

  * Lan truyền thông tin (Message Passing):

* Mỗi nút cập nhật biểu diễn của mình dựa trên thông tin từ các nút láng giềng.

* Quá trình lặp lại nhiều tầng để học đặc trưng toàn cục.

  * Đọc đồ thị (Graph Readout):

* Tạo biểu diễn vector cho toàn bộ cấu trúc vật liệu, từ đó dự đoán các tính chất như độ bền, độ dẫn điện, hoặc năng lượng dải.


Các kiến trúc GNN phổ biến: Graph Convolutional Network (GCN), Graph Attention Network (GAT), Message Passing Neural Network (MPNN), và SchNet – mô hình được thiết kế riêng cho dữ liệu hóa học và vật liệu.

# So Sánh GNN Với Các Mô Hình Khác

Mạng Nơ-ron Đồ Thị (GNN) là một trong những mô hình học máy hiện đại, và để hiểu rõ hơn về giá trị của nó, chúng ta có thể so sánh GNN với một số mô hình học sâu khác như CNN (Mạng Nơ-ron Tích Chập) và RNN (Mạng Nơ-ron Hồi Tiếp).

## So Sánh GNN và CNN

  * **Cấu Trúc Dữ Liệu:** CNN thường xử lý dữ liệu có cấu trúc dạng lưới (ví dụ: hình ảnh), trong khi GNN xử lý dữ liệu có cấu trúc dạng đồ thị.

  * **Khả Năng Mô Hình Hóa Quan Hệ:** GNN xuất sắc trong việc nắm bắt các mối quan hệ phức tạp giữa các nút, điều mà CNN không thể thực hiện một cách hiệu quả.

  * **Ứng Dụng:** CNN thường được sử dụng trong nhận diện hình ảnh, trong khi GNN phù hợp hơn cho các tác vụ như phân tích mạng xã hội và hóa học.


## So Sánh GNN và RNN

  * **Cấu Trúc Dữ Liệu:** RNN chủ yếu xử lý dữ liệu tuần tự (như chuỗi thời gian), trong khi GNN làm việc với dữ liệu có cấu trúc đồ thị.

  * **Khả Năng Tương Tác:** GNN có thể mô hình hóa mối quan hệ giữa nhiều đối tượng cùng một lúc, trong khi RNN thường chỉ xem xét một chuỗi tại một thời điểm.

  * **Hiệu Quả:** GNN có thể hiệu quả hơn trong các tác vụ cần sự hiểu biết về quan hệ phức tạp giữa các phần tử, trong khi RNN thường hiệu quả trong việc dự đoán tiếp theo trong chuỗi dữ liệu.


Tóm lại, GNN không chỉ là một sự thay thế mà còn là một công cụ bổ sung mạnh mẽ cho các mô hình học sâu hiện có, mở ra nhiều khả năng mới trong việc phân tích và xử lý dữ liệu phức tạp.

![So Sánh GNN Với Các Mô Hình Khác](images/image1.png)

# Ứng Dụng Của GNN Trong Thực Tiễn

Mạng Nơ-ron Đồ Thị (GNN) đã chứng minh được tính hiệu quả của mình trong nhiều lĩnh vực khác nhau. Dưới đây là một số ứng dụng nổi bật của GNN trong thực tiễn:

  * Phân Tích Mạng Xã Hội: GNN được sử dụng để phân tích cấu trúc và mối quan hệ trong các mạng xã hội. Nó có thể giúp dự đoán hành vi của người dùng, xác định cộng đồng và phân tích sự lan truyền thông tin.

  * Hệ Thống Gợi Ý: Trong các nền tảng thương mại điện tử và dịch vụ trực tuyến, GNN có thể cải thiện hệ thống gợi ý bằng cách hiểu rõ hơn về mối quan hệ giữa người dùng và sản phẩm, từ đó cung cấp gợi ý chính xác hơn.

  * Nhận Diện Hình Ảnh: GNN được áp dụng trong lĩnh vực thị giác máy tính để nhận diện các đối tượng phức tạp trong hình ảnh, dựa trên các mối quan hệ giữa các điểm ảnh.

  * Hóa Học và Sinh Học: Trong nghiên cứu hóa học, GNN có thể được sử dụng để mô hình hóa các mối quan hệ giữa các phân tử, giúp phát hiện các hợp chất mới và dự đoán tính chất hóa học của chúng.

  * Dự Đoán Thời Tiết: GNN cũng có thể áp dụng trong lĩnh vực khí tượng để dự đoán các hiện tượng thời tiết phức tạp, bằng cách phân tích các dữ liệu không gian và thời gian.


Những ứng dụng này cho thấy GNN không chỉ là một công nghệ hứa hẹn mà còn đang dần trở thành một công cụ quan trọng trong nhiều lĩnh vực, mang lại lợi ích lớn cho nghiên cứu và phát triển.

# 

# Ứng dụng trong khám phá vật liệu

  * Pin thế hệ mới: GNN dự đoán tính dẫn ion và ổn định nhiệt của vật liệu điện cực và chất điện phân rắn.

  * Vật liệu siêu dẫn: Phân tích cấu trúc tinh thể để tìm các hợp chất có nhiệt độ tới hạn cao.

  * Hợp kim nhẹ cho hàng không: Dự đoán độ bền kéo, khả năng chịu nhiệt của hợp kim titan và nhôm.

  * Vật liệu nano và xúc tác: Xác định các cấu trúc bề mặt tối ưu cho phản ứng hóa học hoặc lưu trữ năng lượng.

  * Polyme chức năng: Dự đoán tính chất cơ học và điện của polyme mới cho thiết bị điện tử dẻo.


# Lợi ích nổi bật

  * Tốc độ khám phá nhanh: Giảm đáng kể thời gian từ ý tưởng đến thử nghiệm, từ nhiều năm xuống vài tháng.

  * Tiết kiệm chi phí: Giảm nhu cầu tổng hợp và thử nghiệm hàng nghìn mẫu trong phòng thí nghiệm.

  * Khả năng tổng quát hóa cao: Mô hình học từ dữ liệu đa dạng, có thể dự đoán tính chất của vật liệu chưa từng được biết đến.

  * Khám phá không gian hóa học rộng: Khả năng khảo sát hàng tỷ cấu trúc tinh thể tiềm năng.


# Thách thức

  * Dữ liệu hạn chế: Cần cơ sở dữ liệu vật liệu chất lượng cao như Materials Project hoặc Open Quantum Materials Database.

  * Độ chính xác mô phỏng: Tính chất dự đoán cần được xác thực bằng thí nghiệm hoặc tính toán ab initio.

  * Khả năng giải thích: Kết quả dự đoán phải giải thích được để hướng dẫn các nhà khoa học vật liệu.

  * Tích hợp với quy trình thí nghiệm: Cần tự động hóa phòng thí nghiệm để kiểm chứng nhanh các vật liệu được đề xuất.


# Xu hướng tương lai

  * Kết hợp với Học Tăng Cường (Reinforcement Learning): Tìm kiếm cấu trúc tối ưu dựa trên phản hồi của các mô phỏng.

  * AI đa mô thức: Kết hợp dữ liệu từ nhiễu xạ tia X, phổ Raman, và mô phỏng lượng tử.

  * Tích hợp với điện toán lượng tử: Tăng độ chính xác khi dự đoán tính chất điện tử phức tạp.

  * Tự động hóa toàn quy trình: GNN đề xuất, robot phòng thí nghiệm tổng hợp, và hệ thống đo đạc xác minh – tạo thành vòng lặp khám phá khép kín.


# Trường hợp nghiên cứu tiêu biểu

  * Materials Project & SchNet: Sử dụng GNN để dự đoán năng lượng hình thành, giúp xác định hàng nghìn vật liệu ổn định mới.

  * DeepMind – AlphaFold và GNN: Dù AlphaFold tập trung vào protein, kỹ thuật tương tự đã truyền cảm hứng cho mô hình GNN trong dự đoán cấu trúc tinh thể phức tạp.

  * Stanford Materials Cloud: Áp dụng GNN để dự đoán vật liệu siêu dẫn ở nhiệt độ cao, hỗ trợ nghiên cứu năng lượng sạch.

# Public082

# Giới thiệu

Biến đổi khí hậu toàn cầu đang làm gia tăng tần suất và cường độ của các hiện tượng thời tiết cực đoan: bão siêu mạnh, lũ lụt, hạn hán kéo dài, sóng nhiệt khốc liệt. Để dự báo chính xác và đưa ra cảnh báo sớm, các nhà khoa học cần mô phỏng bầu khí quyển, đại dương và đất liền ở quy mô hành tinh với độ phân giải rất cao.

Tính toán hiệu năng cao (High-Performance Computing – HPC) cung cấp siêu máy tính với hàng trăm nghìn lõi xử lý song song, giúp giải quyết các mô hình phương trình động lực học chất lưu, tương tác khí quyển–đại dương và hóa học khí quyển trong thời gian khả thi. HPC trở thành nền tảng cốt lõi cho nghiên cứu khí hậu và hệ thống dự báo thời tiết toàn cầu.

# HPC là gì? High Performance Computing là gì?

**HPC (High Performance Computing)** , hay tính toán hiệu năng cao, là một lĩnh vực sử dụng các hệ thống máy tính để giải quyết các bài toán phức tạp, đòi hỏi khối lượng tính toán lớn trong thời gian ngắn. Thông thường, HPC kết hợp nhiều máy tính hoặc các cụm máy chủ ([server cluster](https://vietnix.vn/server-cluster-la-gi/)) để làm việc đồng thời, giúp rút ngắn thời gian xử lý so với các hệ thống thông thường. HPC thường được sử dụng trong các lĩnh vực như khoa học, kỹ thuật, y tế, nghiên cứu và trí tuệ nhân tạo, nơi yêu cầu tài nguyên tính toán cao và tốc độ xử lý nhanh chóng.

![HPC (High Performance Computing)](images/image1.png)HPC (High Performance Computing)

# Thành phần của hệ thống HPC

**Cấu trúc của hệ thống HPC** thường bao gồm các thành phần tương tự như một **phòng máy chủ** hoặc trung tâm dữ liệu, với hàng chục, hàng trăm, hoặc thậm chí hàng nghìn thiết bị ngoại vi và [server](https://vietnix.vn/server-la-gi/) được kết nối với nhau. Hệ thống này được chia thành ba loại **nút** chính dựa trên chức năng của chúng:

Một cụm HPC cho AI

  * **Máy tính hoặc cụm máy tính (Compute Nodes)** : Đây là bộ não của hệ thống HPC, thực hiện các phép tính phức tạp và xử lý các tác vụ tính toán. Các nút tính toán chứa các máy chủ với [CPU](https://vietnix.vn/cpu-la-gi/)/[GPU](https://vietnix.vn/gpu-la-gi/) mạnh mẽ, giúp xử lý các bài toán nhanh chóng và hiệu quả.

  * **Hệ thống lưu trữ dữ liệu (Storage Nodes)** : Được thiết kế để xử lý và lưu trữ dữ liệu, kết quả tính toán và các tài nguyên cần thiết cho quá trình tính toán với tốc độ cao. Các nút này thường sử dụng ổ [SSD](https://vietnix.vn/ssd-la-gi/) hoặc các hệ thống lưu trữ phân tán.


Hạ tầng mạng (Network Nodes)

  * **Hạ tầng mạng (Network Nodes)** : Sử dụng mạng tốc độ cao (như InfiniBand) để truyền tải dữ liệu nhanh chóng giữa các nút trong cụm HPC, cũng như giúp các máy chủ và nút tính toán giao tiếp với nhau và kết nối với các hệ thống bên ngoài.

  * **Phần mềm quản lý** : Bao gồm hệ điều hành, phần mềm lập lịch tác vụ (job scheduler) và các công cụ tối ưu hóa hiệu năng cho các ứng dụng HPC.


Một hệ thống HPC hoạt động như một siêu máy tính gắn kết, nơi tổng thể của hệ thống mạnh mẽ hơn rất nhiều so với chỉ tổng các bộ phận của nó. Hệ thống này cho phép xử lý các bài toán yêu cầu tài nguyên tính toán lớn và tốc độ xử lý nhanh trong các lĩnh vực như khoa học, nghiên cứu, kỹ thuật và trí tuệ nhân tạo.

Thành phần của hệ thống HPC

# Cơ sở kỹ thuật của HPC cho mô phỏng khí hậu

  * Kiến trúc siêu máy tính song song:

* Hàng chục nghìn CPU/GPU kết nối bằng mạng tốc độ cao (InfiniBand).

* Khả năng xử lý hàng petaflop đến exaflop.

  * Phân tán miền (Domain Decomposition):

* Trái Đất được chia thành các ô lưới 3D nhỏ (grid cell) cho khí quyển, đại dương.

* Mỗi nút HPC xử lý một tập hợp ô lưới, truyền thông liên tục với các nút khác.

  * Mô hình phương trình đạo hàm riêng:

* Giải Navier–Stokes cho dòng chảy khí quyển.

* Ghép nối với mô hình hóa bức xạ, mây, aerosol, sinh học đại dương.


# Ứng dụng trong mô phỏng khí hậu dài hạn

  * Dự báo biến đổi khí hậu 100 năm: Mô phỏng kịch bản phát thải khác nhau (RCP, SSP) để dự đoán nhiệt độ, mực nước biển, tần suất bão.

  * Đánh giá tác động khu vực: Mô hình độ phân giải cao (1–5 km) cho phép dự báo lũ quét, sóng nhiệt cụ thể từng vùng.

  * Hỗ trợ chính sách: Cung cấp dữ liệu cho các hiệp định quốc tế như Paris Agreement, giúp chính phủ hoạch định giảm phát thải.


# Ứng dụng trong dự báo thời tiết cực đoan

  * Dự báo bão: HPC cho phép mô phỏng quỹ đạo và cường độ bão trong vài giờ, cải thiện độ chính xác cảnh báo sớm.

  * Cảnh báo lũ và mưa lớn: Mô hình thủy văn kết hợp khí tượng chạy trên siêu máy tính để ước tính lượng mưa, mực nước sông.

  * Theo dõi cháy rừng: Mô phỏng lan truyền lửa và khói theo gió, hỗ trợ sơ tán và điều động lực lượng cứu hỏa.


# Công nghệ hỗ trợ

  * GPU và tính toán dị thể: Kết hợp CPU và GPU tăng tốc giải phương trình động lực học.

  * Machine Learning kết hợp HPC: Dùng AI để tinh chỉnh mô hình, giảm sai số dự báo.

  * Cloud-HPC Hybrid: Tận dụng tài nguyên đám mây cho các chiến dịch mô phỏng lớn đột xuất.

  * Hệ thống lưu trữ tốc độ cao: Cần băng thông hàng trăm GB/s để ghi nhận hàng petabyte dữ liệu đầu ra.


# Lợi ích và tác động

  * Tăng độ chính xác: Độ phân giải cao (dưới 1 km) giúp dự báo chi tiết tới từng thành phố.

  * Giảm thời gian tính toán: Từ hàng tuần xuống còn vài giờ cho các kịch bản khẩn cấp.

  * Hỗ trợ quyết định chiến lược: Giúp chính phủ, doanh nghiệp lập kế hoạch ứng phó thiên tai và biến đổi khí hậu.

  * Nâng cao nghiên cứu khoa học: Cho phép mô hình hóa các hiện tượng phức tạp như tương tác khí hậu–băng, khí hậu–sinh học.


# Thách thức

  * Chi phí đầu tư: Xây dựng và vận hành siêu máy tính tốn hàng trăm triệu USD.

  * Tiêu thụ năng lượng lớn: Yêu cầu giải pháp làm mát và nguồn điện bền vững.

  * Đồng bộ dữ liệu toàn cầu: Cần chuẩn dữ liệu chung và mạng truyền tốc độ cao giữa các trung tâm khí tượng.

  * Đào tạo nhân lực: Đòi hỏi chuyên gia lập trình song song và khoa học khí hậu.


# Xu hướng tương lai

  * Exascale Computing: Siêu máy tính đạt trên 10^18 phép tính/giây cho mô hình toàn cầu độ phân giải vài trăm mét.

  * AI-HPC kết hợp: AI học từ kết quả mô phỏng để tạo “mô hình thay thế” (surrogate models) nhanh hơn nhưng vẫn chính xác.

  * Năng lượng xanh cho HPC: Tận dụng năng lượng tái tạo, làm mát bằng chất lỏng để giảm dấu chân carbon.

  * Mô phỏng đa vật lý: Ghép khí quyển, đại dương, băng, sinh học, kinh tế để tạo dự báo toàn diện về tác động khí hậu.

# Public083

# Giới thiệu

6G được dự đoán sẽ ra mắt vào khoảng năm 2030, tiếp nối thành công của 5G và mở ra kỷ nguyên kết nối tốc độ terabit/giây, độ trễ siêu thấp và khả năng tích hợp AI ở mọi tầng mạng. Không chỉ là nâng cấp về băng thông, 6G hứa hẹn tạo nên hạ tầng truyền thông toàn cầu, kết hợp trí tuệ nhân tạo, tính toán lượng tử, và truyền thông quang – vệ tinh, phục vụ các ứng dụng từ metaverse, Internet vạn vật công nghiệp, đến điều khiển robot từ xa với độ chính xác thời gian thực.

# 6G là gì? Tổng quan về mạng và công nghệ 6G

6G (không dây thế hệ thứ sáu) là sự kế thừa của công nghệ di động 5G . Mạng 6G sẽ có thể sử dụng tần số cao hơn mạng 5G và cung cấp dung lượng cao hơn đáng kể và độ trễ thấp hơn nhiều . Một trong những mục tiêu của internet 6G sẽ là hỗ trợ giao tiếp với độ trễ micro giây. Tốc độ này nhanh hơn 1.000 lần – hoặc độ trễ là 1/1000 – so với thông lượng một phần nghìn giây .

Thị trường công nghệ 6G được kỳ vọng sẽ tạo điều kiện cho những cải tiến lớn về hình ảnh, công nghệ hiện diện và nhận biết vị trí . Hoạt động kết hợp với trí tuệ nhân tạo ( AI ), cơ sở hạ tầng tính toán của 6G sẽ tự động xác định vị trí tốt nhất để tính toán xảy ra; điều này bao gồm các quyết định về lưu trữ , xử lý và chia sẻ dữ liệu .

# Ưu điểm của 6G so với 5G là gì?

6G dự kiến ​​sẽ hỗ trợ tốc độ dữ liệu 1 terabyte mỗi giây. Các điểm truy cập sẽ có thể phục vụ nhiều khách hàng đồng thời thông qua đa truy cập phân chia theo tần số trực giao . Mức dung lượng và độ trễ này sẽ mở rộng hiệu suất của các ứng dụng 5G và mở rộng phạm vi khả năng hỗ trợ các ứng dụng sáng tạo trong kết nối không dây, nhận thức, cảm biến và hình ảnh.

Tần số cao hơn của 6G sẽ cho phép tốc độ lấy mẫu nhanh hơn nhiều , ngoài việc cung cấp thông lượng tốt hơn đáng kể và tốc độ dữ liệu cao hơn. Sự kết hợp của các sóng dưới mm (ví dụ, bước sóng nhỏ hơn một milimét) và tính chọn lọc tần số để xác định tốc độ hấp thụ điện từ tương đối có thể dẫn đến những tiến bộ đáng kể trong công nghệ cảm biến không dây.

Điện toán biên di động (MEC) sẽ được tích hợp vào tất cả các mạng 6G, trong khi nó phải được thêm vào các mạng 5G hiện có. Điện toán biên và lõi sẽ được tích hợp liền mạch hơn như một phần của khung cơ sở hạ tầng tính toán / truyền thông kết hợp vào thời điểm mạng 6G được triển khai. Cách tiếp cận này sẽ mang lại nhiều lợi thế tiềm năng khi công nghệ 6G đi vào hoạt động, bao gồm cải thiện khả năng tiếp cận các khả năng của AI.

# Khi nào có Internet 6G?

Internet 6G dự kiến ​​sẽ ra mắt thương mại vào năm 2030. Công nghệ này sử dụng nhiều hơn mạng truy cập vô tuyến phân tán ( RAN ) và phổ terahertz (THz) để tăng dung lượng, giảm độ trễ và cải thiện việc chia sẻ phổ tần. Trong khi một số cuộc thảo luận ban đầu đã diễn ra để xác định 6G, các hoạt động nghiên cứu và phát triển (R&D) đã bắt đầu một cách nghiêm túc vào năm 2020.

Ví dụ, Trung Quốc đã phóng vệ tinh thử nghiệm 6G được trang bị hệ thống THz, trong khi các công ty công nghệ khổng lồ Huawei Technologies và China Global được cho là có kế hoạch phóng vệ tinh 6G tương tự vào năm 2021. Nhiều vấn đề liên quan đến việc triển khai vô tuyến sóng milimet cho 5G phải được giải quyết kịp thời cho các nhà thiết kế mạng để giải quyết những thách thức của 6G.

# 6G sẽ hoạt động như thế nào?

Dự kiến, các giải pháp cảm biến không dây 6G sẽ sử dụng có chọn lọc các tần số khác nhau để đo mức độ hấp thụ và điều chỉnh tần số cho phù hợp. Phương pháp này có thể thực hiện được vì các nguyên tử và phân tử phát ra và hấp thụ bức xạ điện từ ở các tần số đặc trưng, ​​và các tần số phát xạ và hấp thụ là như nhau đối với bất kỳ chất nào.

![6G sẽ hoạt động như thế nào?](images/image1.png)

6G sẽ có ý nghĩa lớn đối với nhiều phương pháp tiếp cận của chính phủ và ngành đối với an toàn công cộng và bảo vệ tài sản quan trọng như:

  * phát hiện mối đe dọa;

  * theo dõi sức khỏe;

  * tính năng và nhận dạng khuôn mặt ;

  * ra quyết định trong các lĩnh vực như thực thi pháp luật và hệ thống tín dụng xã hội;

  * đo chất lượng không khí;

  * cảm nhận khí và độc tính.


Những cải tiến trong các lĩnh vực này cũng sẽ mang lại lợi ích cho công nghệ di động, cũng như các công nghệ mới nổi như thành phố thông minh, xe tự lái, thực tế ảo và thực tế tăng cường.

# Đặc trưng công nghệ cốt lõi

  * Tốc độ dữ liệu siêu cao: Dự kiến đạt 1 Tbps, gấp hàng chục lần 5G, cho phép truyền tải video 16K, thực tế ảo (VR/AR) mượt mà.

  * Độ trễ dưới 0,1 mili giây: Hỗ trợ phẫu thuật từ xa, điều khiển xe tự hành trên toàn cầu.

  * Phổ tần Terahertz (THz): Khai thác dải tần 0,1–10 THz, cung cấp băng thông cực lớn nhưng yêu cầu giải pháp khuếch đại và anten tiên tiến.

  * Tích hợp vệ tinh – mặt đất: Tạo vùng phủ sóng toàn cầu, đặc biệt ở đại dương và khu vực hẻo lánh.

  * Mạng định nghĩa bằng phần mềm (SDN) và ảo hóa (NFV): Cho phép cấu hình linh hoạt và quản lý tự động.


# Vai trò của trí tuệ nhân tạo trong 6G

AI không chỉ là ứng dụng chạy trên mạng, mà còn là thành phần lõi:

  * Tối ưu hóa phổ tần động: AI phân tích nhu cầu và điều kiện môi trường để phân bổ phổ tần tự động.

  * Điều khiển mạng tự trị: Hệ thống tự học, tự cấu hình, tự khắc phục sự cố mà không cần can thiệp con người.

  * Dự đoán lưu lượng và bảo trì chủ động: AI dự báo tắc nghẽn, điều phối tài nguyên trước khi sự cố xảy ra.

  * Bảo mật thông minh: Phát hiện tấn công mạng, xác thực người dùng và thiết bị theo thời gian thực.


# Ứng dụng tiêu biểu

  * Thực tế ảo toàn cảnh (Immersive XR/Metaverse): 6G cung cấp băng thông và độ trễ cần thiết cho trải nghiệm ảo siêu chân thực.

  * Xe tự hành toàn cầu: Giao tiếp giữa phương tiện và hạ tầng đường bộ với độ trễ cực thấp.

  * Y tế từ xa nâng cao: Phẫu thuật robot thời gian thực, chia sẻ dữ liệu hình ảnh y tế dung lượng lớn ngay lập tức.

  * Internet vạn vật công nghiệp (IIoT): Điều khiển dây chuyền sản xuất, giám sát hàng triệu cảm biến trong thời gian thực.

  * Truyền thông lượng tử kết hợp 6G: Tăng cường bảo mật với phân phối khóa lượng tử (QKD).


# Hạ tầng kỹ thuật

  * Anten thông minh MIMO khổng lồ: Tối ưu hóa chùm sóng để đạt băng thông cao và giảm nhiễu.

  * Tích hợp quang – không dây: Sử dụng liên kết quang học tự do (FSO) cho đường truyền tốc độ cực cao.

  * Điện toán biên (Edge Computing): Đưa AI và xử lý dữ liệu gần người dùng để giảm độ trễ và tiết kiệm băng thông.

  * Điện toán lượng tử và AI: Tăng tốc giải bài toán tối ưu hóa mạng và bảo mật.


# Thách thức triển khai

  * Tiêu thụ năng lượng: Mạng 6G yêu cầu giải pháp năng lượng xanh và thiết bị tiết kiệm điện.

  * Chuẩn hóa toàn cầu: Cần sự hợp tác của nhiều quốc gia, tổ chức viễn thông để thống nhất tiêu chuẩn.

  * Chi phí đầu tư lớn: Cơ sở hạ tầng anten THz, vệ tinh và thiết bị người dùng mới đòi hỏi vốn khổng lồ.

  * Bảo mật: Dù AI hỗ trợ, mạng càng thông minh càng dễ bị tấn công tinh vi hơn.


# Xu hướng tương lai

  * AI gốc mạng (Native AI): Mọi lớp của mạng 6G, từ vật lý đến ứng dụng, đều được điều khiển bởi AI.

  * Hợp nhất đất – trời – biển – không gian: Mạng 6G cung cấp kết nối liền mạch cho mọi môi trường.

  * Tích hợp Blockchain: Đảm bảo tính minh bạch và an toàn cho các giao dịch dữ liệu khổng lồ.

  * Mạng xanh bền vững: Sử dụng năng lượng tái tạo, công nghệ thu hồi năng lượng (energy harvesting).

# Public084

# Giới thiệu

Xe tự hành đang trở thành tâm điểm của ngành giao thông thông minh. Để hoạt động an toàn trong môi trường phức tạp, phương tiện phải nhận thức xung quanh nhanh, chính xác và tin cậy. Trọng tâm của khả năng này là thị giác máy tính (computer vision) – công nghệ giúp xe “nhìn” và “hiểu” thế giới thông qua camera, radar, LiDAR và cảm biến đa dạng.

Thế hệ tiếp theo của xe tự hành yêu cầu hệ thống thị giác máy tính vượt xa các mô hình hiện tại, hỗ trợ nhận diện thời gian thực, dự đoán hành vi, và ra quyết định tự động trong điều kiện thời tiết, ánh sáng và giao thông phức tạp.

# Cấu phần chính của hệ thống thị giác

  * Cảm biến đa phương thức:

* Camera RGB/IR: Thu thập hình ảnh màu và hồng ngoại, xử lý chi tiết môi trường.

* LiDAR: Tạo bản đồ 3D chính xác của môi trường, đo khoảng cách và hình dạng vật thể.

* Radar sóng mm: Hoạt động tốt trong sương mù, mưa, tuyết, bổ trợ cho camera.

* Cảm biến siêu âm: Hỗ trợ đỗ xe, đo khoảng cách gần.

  * Xử lý cảm biến hợp nhất (Sensor Fusion):

* Kết hợp dữ liệu từ nhiều cảm biến để có bức tranh toàn cảnh, giảm sai số từng loại cảm biến.

  * Mô-đun thị giác máy tính:

* Phát hiện đối tượng (Object Detection): Nhận diện người đi bộ, xe cộ, biển báo.

* Phân đoạn ngữ nghĩa (Semantic Segmentation): Phân loại từng điểm ảnh để xác định làn đường, vỉa hè.

* Theo dõi chuyển động (Object Tracking): Dự đoán quỹ đạo vật thể di chuyển.


# Thuật toán và mô hình AI

##  Mạng CNN

  * Mạng CNN là một tập hợp các lớp Convolution chồng lên nhau và sử dụng các hàm nonlinear activation như ReLU và tanh để kích hoạt các trọng số trong các node. Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo.

  * Mỗi một lớp sau khi thông qua các hàm kích hoạt sẽ tạo ra các thông tin trừu tượng hơn cho các lớp tiếp theo. Trong mô hình mạng truyền ngược (feedforward neural network) thì mỗi neural đầu vào (input node) cho mỗi neural đầu ra trong các lớp tiếp theo.

  * Mô hình này gọi là mạng kết nối đầy đủ (fully connected layer) hay mạng toàn vẹn (affine layer). Còn trong mô hình CNNs thì ngược lại. Các layer liên kết được với nhau thông qua cơ chế convolution.

  * Layer tiếp theo là kết quả convolution từ layer trước đó, nhờ vậy mà ta có được các kết nối cục bộ. Như vậy mỗi neuron ở lớp kế tiếp sinh ra từ kết quả của filter áp đặt lên một vùng ảnh cục bộ của neuron trước đó.

  * Mỗi một lớp được sử dụng các filter khác nhau thông thường có hàng trăm hàng nghìn filter như vậy và kết hợp kết quả của chúng lại. Ngoài ra có một số layer khác như pooling/subsampling layer dùng để chắt lọc lại các thông tin hữu ích hơn (loại bỏ các thông tin nhiễu).

  * Trong quá trình huấn luyện mạng (traning) CNN tự động học các giá trị qua các lớp filter dựa vào cách thức mà bạn thực hiện. Ví dụ trong tác vụ phân lớp ảnh, CNNs sẽ cố gắng tìm ra thông số tối ưu cho các filter tương ứng theo thứ tự raw pixel > edges > shapes > facial > high-level features. Layer cuối cùng được dùng để phân lớp ảnh.

  * ![Cấu trúc của mạng CNN](images/image1.png)

  * Trong mô hình CNN có 2 khía cạnh cần quan tâm là **tính bất biến** (Location Invariance) và **tính kết hợp** (Compositionality). Với cùng một đối tượng, nếu đối tượng này được chiếu theo các gốc độ khác nhau (translation, rotation, scaling) thì độ chính xác của thuật toán sẽ bị ảnh hưởng đáng kể.

  * Pooling layer sẽ cho bạn tính bất biến đối với phép dịch chuyển (translation), phép quay (rotation) và phép co giãn (scaling). Tính kết hợp cục bộ cho ta các cấp độ biểu diễn thông tin từ mức độ thấp đến mức độ cao và trừu tượng hơn thông qua convolution từ các filter.

  * Đó là lý do tại sao CNNs cho ra mô hình với độ chính xác rất cao. Cũng giống như cách con người nhận biết các vật thể trong tự nhiên.

  * Mạng CNN sử dụng 3 ý tưởng cơ bản:

  * **các trường tiếp nhận cục bộ** (local receptive field)

  * **trọng số chia sẻ** (shared weights)

  * **tổng hợp** (pooling).


##  Recurrent Neural Network

![A diagram of a network AI-generated content may be incorrect.](images/image2.png)

  * Các x ở đây đại diện cho dữ liệu đầu vào lần lượt (được chia theo time step).

  * xt _xt_ ​ đại diện cho time step thứ t, và yt _yt_ ​ là output của một step. Ví dụ, x2 _x_ 2​ sẽ là vector đại diện của từ thứ 2 trong câu văn bản.

  * Hình ảnh dưới đây cho thấy rõ hơn điều gì thực sự xảy ra trong một step.

  *   * **Hidden state** ht _ht_ ​ (trong một số tài liệu tường ký hiện st _st_ ​). Đây chính là bộ nhớ của mạng. ht _ht_ ​ là tổng hợp thông tin của hidden state trước ( ht−1 _ht_ −1​) cộng với input tại time step t ( xt _xt_ ​). Activation function ở đây $g_1$chủ yếu là tanh hoặc ReLu.

  * ht=g1(Whh∗ht−1+Whx∗xt+bh) _ht_ ​= _g_ 1( _Whh_ ​∗ _ht_ −1​+ _Whx_ ​∗ _xt_ ​+ _bh_ ​)

  * Hoặc có thể viết gọn hơn:

  * ht=g1((WhhWhx)(ht−1xt)) _ht_ ​= _g_ 1(( _Whh_ ​ _Whx_ ​)( _ht_ −1​ _xt_ ​​))

  * ht=g1((W)(ht−1xt)) _ht_ ​= _g_ 1(( _W_ )( _ht_ −1​ _xt_ ​​))

  * **Output của từng time step yt _yt_ ​** : Tại 1 block của mạng RNN có 2 đầu ra. Trong đó, ht _ht_ ​ là tổng hợp thông tin của các state trước để tiếp tục truyền đi trong chuỗi mạng, và ta có thêm yt _yt_ ​ là output của từng time step một. Ở đây g2 _g_ 2​ thường là hàm softmax.

  * yt=g2(Wyh∗ht+by) _yt_ ​= _g_ 2( _Wyh_ ​∗ _ht_ ​+ _by_ ​)


# Ứng dụng và kịch bản thực tế

  * Điều khiển trên đường cao tốc: Nhận dạng phương tiện di chuyển nhanh, dự đoán làn đường.

  * Môi trường đô thị đông đúc: Xử lý tình huống bất ngờ như người đi bộ băng qua đường, xe đạp di chuyển ngược chiều.

  * Thời tiết khắc nghiệt: Cần thuật toán chịu nhiễu tốt trong mưa lớn, tuyết dày, hoặc ánh sáng yếu.

  * Đỗ xe tự động: Nhận diện vật cản nhỏ, khoảng trống, biển báo trong không gian hẹp.


# Thách thức kỹ thuật

  * Đa dạng môi trường: Khác biệt về điều kiện ánh sáng, thời tiết, hạ tầng đường xá giữa các quốc gia.

  * Xử lý thời gian thực: Đòi hỏi phần cứng GPU/TPU mạnh, tối ưu hóa mô hình để giảm độ trễ dưới 50 ms.

  * An toàn và tin cậy: Hệ thống phải có cơ chế dự phòng khi một hoặc nhiều cảm biến hỏng.

  * Dữ liệu huấn luyện khổng lồ: Cần hàng triệu km dữ liệu lái xe, bao gồm tình huống hiếm gặp.

  * Tấn công đối kháng (Adversarial Attacks): Cần bảo vệ trước việc kẻ xấu dùng biển báo giả hay tín hiệu gây nhiễu.


# Xu hướng phát triển

  * Edge AI trong xe: Xử lý trực tiếp trên thiết bị thay vì gửi về đám mây, giảm độ trễ và tăng tính riêng tư.

  * LiDAR thế hệ mới chi phí thấp: Giúp phổ cập xe tự hành.

  * Mô hình học tự giám sát (Self-Supervised Learning): Giảm nhu cầu dữ liệu gắn nhãn tốn kém.

  * Hợp tác xe – hạ tầng (V2X): Xe trao đổi dữ liệu trực tiếp với đèn tín hiệu, camera giao thông, và các phương tiện khác.

  * Giải thích mô hình (Explainable AI): Cho phép hiểu quyết định của hệ thống để hỗ trợ kiểm định an toàn.


# Tác động xã hội và kinh tế

  * An toàn giao thông: Giảm tai nạn do lỗi con người.

  * Hiệu quả vận tải: Giảm ùn tắc, tối ưu hóa lộ trình và tiết kiệm nhiên liệu.

  * Dịch vụ di chuyển mới: Robotaxi, giao hàng tự động, xe buýt tự lái.

  * Quy định pháp lý: Cần khung pháp luật cho bảo hiểm, trách nhiệm tai nạn và quyền riêng tư.

# Public085

# Giới thiệu

Nhà máy thông minh – nền tảng của Công nghiệp 4.0 – đòi hỏi mức độ tự động hóa và linh hoạt cao hơn bao giờ hết. Trong môi trường sản xuất hiện đại, dây chuyền phải thích ứng nhanh với thay đổi sản phẩm, khối lượng và yêu cầu chất lượng. Robot công nghiệp tự học chính là giải pháp: thay vì lập trình cứng, robot có khả năng học hỏi từ dữ liệu, tự tối ưu hành động và cộng tác an toàn với con người, tạo nên một thế hệ robot linh hoạt, thông minh và hiệu quả.

# Các loại thuật toán được sử dụng trong robot truyền thống

## Bất kỳ lúc nào A * Thuật toán

Thuật toán A * là một thuật toán tìm kiếm đường đi được sử dụng để tìm đường đi tối ưu nhất giữa hai điểm, tức là với chi phí nhỏ nhất.

Bất cứ lúc nào A * Algorithm có chi phí thời gian linh hoạt và có thể trả về đường đi ngắn nhất ngay cả khi nó bị gián đoạn vì nó tạo ra một giải pháp không tối ưu trước và sau đó tối ưu hóa nó.

Điều này cho phép ra quyết định nhanh hơn vì robot có thể xây dựng dựa trên các tính toán trước đó thay vì bắt đầu từ đầu.

![Hoạt hình tiến bộ của Astar](images/image1.gif)

### Cách sử dụng?

Nó thực hiện điều này bằng cách hình thành một 'cây' kéo dài từ nút bắt đầu cho đến khi các tiêu chí kết thúc được kích hoạt, có nghĩa là có sẵn một con đường ít tốn kém hơn.

Lưới 2D được tạo ra với các chướng ngại vật và ô bắt đầu và ô mục tiêu được thiết kế theo chiều nhọn.

Thuật toán xác định 'giá trị' của một nút bằng f là tổng các tham số g (chi phí di chuyển từ nút bắt đầu đến nút được đề cập) và h (chi phí di chuyển từ nút được đề cập đến nút đích).

### Ứng dụng

Rất nhiều trò chơi và bản đồ dựa trên web sử dụng thuật toán này để tìm đường đi ngắn nhất một cách hiệu quả. Nó cũng có thể được sử dụng cho rô bốt di động.

Bạn cũng có thể giải quyết các vấn đề phức tạp như [Newton – Raphson](https://www.sciencedirect.com/topics/mathematics/newton-raphson-method) phép lặp được áp dụng để tìm căn bậc hai của một số.

Nó cũng được sử dụng trong các bài toán về quỹ đạo để dự đoán chuyển động và va chạm của một vật thể trong không gian.

##  Thuật toán D *

D *, D * và D * Lite tiêu điểm là các thuật toán tìm kiếm tăng dần để tìm đường đi ngắn nhất giữa hai điểm.

Tuy nhiên, chúng là sự kết hợp của các thuật toán A * và những khám phá mới cho phép họ thêm thông tin vào bản đồ của mình cho những chướng ngại vật chưa biết.

Sau đó, họ có thể tính toán lại một tuyến đường dựa trên thông tin mới, giống như Mars Rover.

![Hình minh họa Lập kế hoạch đường dẫn thuật toán D Lite](images/image2.png)

### Cách sử dụng?

Hoạt động của D * Algorithm tương tự như A *, đầu tiên thuật toán xác định f, h và tạo một danh sách mở và đóng.

Sau đó, Thuật toán D * xác định giá trị g của nút hiện tại bằng cách sử dụng giá trị g của các nút lân cận của nó.

Mỗi nút lân cận đưa ra phỏng đoán về giá trị g hiện tại của một nút và giá trị g ngắn nhất được điều chỉnh thành giá trị g mới.

### Ứng dụng

D * và các biến thể của nó được sử dụng rộng rãi cho rô bốt di động và [xe tự trị](https://hashdork.com/vi/thi%E1%BA%BFt-k%E1%BA%BF-h%E1%BB%87-th%E1%BB%91ng-xe-t%E1%BB%B1-h%C3%A0nh/) dẫn đường.

Các hệ thống định vị như vậy bao gồm một hệ thống nguyên mẫu được thử nghiệm trên tàu Mars rovers Cơ hội và Tinh thần và hệ thống định vị đã giành được [Thách thức đô thị DARPA](https://www.darpa.mil/about-us/timeline/darpa-urban-challenge).

##  Thuật toán PRM

PRM, hay lộ trình xác suất, là một đồ thị mạng lưới các đường đi có thể có dựa trên các không gian trống và bị chiếm dụng trên một bản đồ nhất định.

Chúng được sử dụng trong các hệ thống lập kế hoạch phức tạp và cũng để tìm ra các con đường chi phí thấp xung quanh các chướng ngại vật.

PRM sử dụng một mẫu ngẫu nhiên các điểm trên bản đồ của họ nơi thiết bị rô bốt có thể di chuyển và sau đó tính toán đường đi ngắn nhất.

![Các nút PRM được tạo ngẫu nhiên trong không gian tự do và các cạnh của nó được vẽ như vậy](images/image3.png)

### Cách sử dụng?

PRM bao gồm giai đoạn xây dựng và truy vấn.

Trong giai đoạn đầu, một lộ trình được vẽ biểu đồ gần đúng với các chuyển động có thể có trong một môi trường. Một cấu hình ngẫu nhiên sau đó được tạo và kết nối với một số hàng xóm.

Cấu hình bắt đầu và mục tiêu được kết nối với biểu đồ trong giai đoạn truy vấn. Đường dẫn sau đó thu được bởi một [Con đường ngắn nhất của Dijkstra](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/) truy vấn.

### Ứng dụng

PRM được sử dụng trong các nhà lập kế hoạch cục bộ, trong đó thuật toán tính toán một đường thẳng giữa hai điểm, cụ thể là điểm ban đầu và điểm mục tiêu.

Thuật toán cũng có thể được sử dụng để cải thiện các ứng dụng lập kế hoạch đường đi và phát hiện va chạm.

## Thuật toán Zero Moment Point (ZMP)

Zero Moment Point (kỹ thuật ZMP) là một thuật toán được sử dụng bởi robot để giữ cho tổng quán tính ngược với phản lực của sàn.

Thuật toán này sử dụng khái niệm tính toán ZMP và áp dụng nó để cân bằng robot hai chân. Sử dụng thuật toán này trên bề mặt sàn nhẵn dường như cho phép robot đi lại như thể không có giây phút nào.

Các công ty sản xuất như ASIMO (Honda) sử dụng kỹ thuật này.

![Điểm Zero Moment ZMP và hiệu chỉnh quỹ đạo của nó](images/image4.png)

### Cách sử dụng?

Chuyển động của rô bốt đi bộ được lập kế hoạch bằng cách sử dụng phương trình mômen động lượng. Nó đảm bảo rằng chuyển động khớp được tạo ra đảm bảo sự ổn định tư thế động học của robot.

Độ ổn định này được định lượng bằng khoảng cách của điểm không mô men (được tính toán bằng thuật toán) trong ranh giới của vùng ổn định được xác định trước.

### Ứng dụng

Điểm zero moment có thể được sử dụng làm thước đo để đánh giá độ ổn định chống lại sự cố lật của robot như iRobot PackBot khi điều hướng đường dốc và chướng ngại vật.

## Thuật toán điều khiển vi phân tích phân tỷ lệ (PID)

Điều khiển vi sai tích phân tỷ lệ hoặc PID, tạo một vòng phản hồi cảm biến để điều chỉnh cài đặt cho các thành phần cơ khí bằng cách tính toán giá trị lỗi.

Các thuật toán này kết hợp cả ba hệ số cơ bản, tức là tỷ lệ, tích phân và đạo hàm để tạo ra tín hiệu điều khiển.

Nó hoạt động trong thời gian thực và áp dụng các chỉnh sửa khi cần thiết. Điều này có thể được nhìn thấy trong [xe tự lái](https://hashdork.com/vi/tesla-fsd-%E2%80%8B%E2%80%8Bbeta-v10/).

![Sơ đồ bộ điều khiển PID](images/image5.png)

### Cách sử dụng?

Bộ điều khiển PID sử dụng ba thuật ngữ điều khiển là ảnh hưởng tỷ lệ, tích phân và đạo hàm trên đầu ra của nó để áp dụng điều khiển chính xác và tối ưu.

Bộ điều khiển này liên tục tính toán một giá trị lỗi là sự khác biệt giữa điểm đặt mong muốn và một biến quá trình đo được.

Sau đó, nó áp dụng một hiệu chỉnh để giảm thiểu lỗi theo thời gian bằng cách điều chỉnh biến điều khiển.

# Đặc trưng của robot tự học

  * Khả năng học tăng cường (Reinforcement Learning): Robot khám phá hành động mới, nhận phản hồi từ môi trường để cải thiện chiến lược điều khiển.

  * Học chuyển giao (Transfer Learning): Kỹ năng học được ở một nhiệm vụ (ví dụ lắp ráp linh kiện) có thể chuyển sang nhiệm vụ tương tự khác, rút ngắn thời gian đào tạo.

  * Thị giác máy tính tích hợp: Camera 3D và cảm biến độ sâu giúp robot nhận diện vật thể, vị trí và hướng, cho phép gắp nhặt vật liệu không định hình.

  * Cảm biến xúc giác và lực: Giúp điều chỉnh lực cầm nắm, giảm nguy cơ hư hỏng sản phẩm.

  * Điện toán biên (Edge AI): Xử lý dữ liệu và ra quyết định trực tiếp tại robot, giảm độ trễ so với gửi dữ liệu lên đám mây.


# Ứng dụng trong nhà máy thông minh

  * Lắp ráp linh kiện phức tạp: Robot học từ mẫu và tự điều chỉnh quỹ đạo khi vị trí linh kiện thay đổi.

  * Hàn và sơn tự động: Học cách tối ưu đường hàn/sơn cho các sản phẩm có hình dạng khác nhau.

  * Đóng gói và phân loại: Sử dụng thị giác để phân loại hàng hóa theo kích thước, màu sắc, tình trạng bề mặt.

  * Bảo trì và kiểm tra: Robot tự di chuyển, quét cảm biến, phát hiện hỏng hóc trong dây chuyền.

  * Cộng tác người – máy (Cobots): Làm việc an toàn cùng công nhân, học cách phối hợp và chia sẻ nhiệm vụ.


# Lợi ích nổi bật

  * Linh hoạt sản xuất: Dễ dàng thích nghi khi thay đổi mẫu mã, số lượng sản phẩm.

  * Tăng năng suất: Giảm thời gian ngừng máy và sai sót do con người.

  * Tiết kiệm chi phí dài hạn: Dù đầu tư ban đầu cao, nhưng giảm chi phí bảo trì, đào tạo và lập trình về sau.

  * Cải thiện an toàn: Robot xử lý các nhiệm vụ nguy hiểm, giảm tai nạn lao động.


# Công nghệ nền tảng

  * Mạng nơ-ron sâu (Deep Neural Networks): Giúp robot nhận diện vật thể và lập kế hoạch đường đi tối ưu.

  * Học tự giám sát (Self-Supervised Learning): Cho phép robot tận dụng dữ liệu chưa gắn nhãn để học cách cầm nắm và di chuyển.

  * Mô phỏng thực tế ảo (Simulation-to-Real Transfer): Huấn luyện robot trong môi trường ảo rồi chuyển kỹ năng sang thế giới thực, giảm chi phí thử nghiệm.

  * Kết nối IoT công nghiệp: Robot liên tục trao đổi dữ liệu với hệ thống quản lý sản xuất (MES) và kho dữ liệu lớn.


# Thách thức

  * Độ tin cậy và an toàn: Robot phải bảo đảm an toàn tuyệt đối khi làm việc chung với con người.

  * Chi phí đầu tư ban đầu: Phần cứng, cảm biến và hệ thống AI chất lượng cao đòi hỏi vốn lớn.

  * Quản lý dữ liệu khổng lồ: Cần hạ tầng lưu trữ và xử lý dữ liệu mạnh mẽ.

  * Chuẩn hóa và tích hợp: Phải tương thích với nhiều hệ thống điều khiển và phần mềm nhà máy khác nhau.


# Tác động kinh tế – xã hội

  * Tái cấu trúc lực lượng lao động: Giảm công việc lặp lại nguy hiểm, nhưng đòi hỏi đào tạo lại nhân sự cho các vị trí quản lý và giám sát robot.

  * Tăng sức cạnh tranh toàn cầu: Doanh nghiệp có thể sản xuất với tốc độ cao, chất lượng ổn định, giảm chi phí xuất khẩu.

  * Hỗ trợ sản xuất bền vững: Robot tối ưu năng lượng, giảm lãng phí nguyên liệu.


# Xu hướng tương lai

  * Robot tự học đa kỹ năng: Chuyển đổi giữa nhiều tác vụ mà không cần lập trình lại.

  * Kết hợp với trí tuệ nhân tạo tạo sinh: Robot có thể tự đề xuất cách sắp xếp dây chuyền mới hoặc thiết kế công cụ tùy biến.

  * Liên kết đám mây – biên: Mô hình huấn luyện lớn trên đám mây, suy luận nhanh tại robot.

  * Cộng tác liên robot: Nhiều robot giao tiếp và học lẫn nhau, tối ưu toàn bộ quy trình sản xuất

# Public086

# Giới thiệu

Thành phố thông minh của tương lai cần một hệ thống năng lượng xanh, ổn định và bền vững, trong đó nguồn năng lượng tái tạo như điện mặt trời, gió, thủy triều và sinh khối đóng vai trò chủ lực. Tuy nhiên, đặc tính dao động và khó dự đoán của các nguồn này – như mây che mặt trời hay gió thay đổi – gây khó khăn lớn cho việc cân bằng cung cầu và đảm bảo chất lượng điện.

Trí tuệ nhân tạo (AI) cung cấp giải pháp đột phá, cho phép dự báo, tối ưu hóa và tự động điều phối năng lượng tái tạo trong thời gian thực. Hệ thống AI được triển khai từ cấp hộ gia đình đến lưới điện thành phố, giúp giảm chi phí, nâng cao hiệu suất và giảm phát thải carbon.

# Năng lượng tái tạo là gì, các loại năng lượng tái tạo bao gồm dạng nào?

Năng lượng tái tạo là các nguồn tự nhiên như ánh sáng mặt trời, mưa, gió, thủy triều, và được phân loại thành nhiều dạng như [năng lượng mặt trời](https://vuphong.vn/nang-luong-mat-troi-la-gi/), [năng lượng gió](https://vuphong.vn/thu-vi-ve-dien-gio/), năng lượng thủy triều, [năng lượng địa nhiệt](https://vuphong.vn/dien-dia-nhiet-huong-den-phat-trien-ben-vung/), [năng lượng sinh khối](https://vuphong.vn/uu-nhuoc-diem-cua-nang-luong-hoa-thach/), v.v. Đây là [nguồn năng lượng sạch](https://vuphong.vn/phat-trien-cac-nguon-nang-luong-sach/), thân thiện với môi trường và có tính bền [vững](https://vuphong.vn/vu-phong-quyet-tam-vung-buoc-chuyen-minh-vuon-tam-dai-chung/) cao.

Năng lượng tái tạo đang được xem là những **năng lượng sạch** nhất hành tinh và là tương lai của [ngành năng lượng](https://vuphong.vn/tong-quan-nganh-cong-nghiep-nang-luong-viet-nam/) toàn cầu. Chúng có nhiều thế mạnh so với năng lượng hóa thạch và tất nhiên cũng đi kèm một vài nhược điểm. Dưới đây là những ưu nhược điểm của năng lượng tái tạo:

# Ưu, nhược điểm của năng lượng tái tạo

## Ưu điểm của năng lượng tái tạo

Ưu điểm đầu tiên của năng lượng tái tạo là có thể tái tạo được, trữ lượng vô cùng lớn, có thể vô tận. Các dạng năng lượng như mặt trời, gió, [địa nhiệt,](https://vuphong.vn/dien-dia-nhiet-huong-den-phat-trien-ben-vung/) sóng biển, mưa… có sẵn và tự do sử dụng, không mất chi phí nhiên liệu. [Năng](https://vuphong.vn/uu-nhuoc-diem-cua-nang-luong-tai-tao/) lượng sinh khối cũng có trữ lượng lớn và chi phí nhiên liệu thấp. So với các nguồn năng lượng truyền thống như than đá, dầu mỏ, khí đốt tự nhiên… đang ngày càng cạn kiệt, chỉ đáp ứng nhu cầu năng lượng của con người thêm khoảng 50-70 năm, ưu điểm này là một thế mạnh vượt trội.

Nhiều số liệu cho thấy sử dụng nguồn năng lượng tái tạo để sản xuất điện mang lại hiệu quả cao hơn nhiều so với sử dụng năng lượng thông thường. Các dạng năng lượng thông thường để được chuyển hóa thành điện sẽ được đốt cháy quá quá trình phức tạp tại nhà máy nhiệt điện nhưng không bao giờ có thể chuyển hóa 100%. Thực tế một lượng lớn nhiệt sau khi được sinh ra sẽ bị phân tán và lãng phí. Ví dụ ở Anh, sản xuất điện từ khí gas, có đến 54% lượng nhiệt bị lãng phí trong quá trình sản xuất điện, lượng điện bị lãng phí trong sản xuất từ than đá là 66%, ở năng lượng hạt nhân là 65%… Còn ở năng lượng tái tạo, không hề lãng phí chút năng lượng nào trong quá trình sinh điện vì dù có hiệu suất thấp hơn nhưng chúng vô tận.

![chứng nhận ISO](images/image1.jpeg) _Năng lượng tái tạo sạch, vô tận, có thể khai thác rộng rãi ở mọi khu vực trên trái đất là những ưu điểm của năng lượng tái tạo (Ảnh minh họa internet)_

Các dạng năng lượng tái tạo đều là những năng lượng sạch, thân thiện với môi trường, phát[ thải](https://vuphong.vn/giam-khi-thai/) ít carbon trong quá trình sản xuất, chuyển đổi. Chính vì vậy, năng lượng tái tạo được biết đến là giải pháp chống lại sự biến đổi khí hậu đang ngày càng tác động nghiêm trọng đến cuộc sống của con người, giúp bảo vệ hệ sinh thái chung. Ít tác động đến môi trường tự nhiên, không gây ô nhiễm không khí, không làm gia tăng sự nóng lên của khí hậu toàn cầu, hiệu ứng nhà kính… là một ưu điểm của năng lượng tái tạo mà con người đang rất cần.

Ưu điểm thứ 3 của năng lượng tái tạo là phong phú, có thể khai thác rộng rãi ở mọi khu vực khác nhau trên trái đất. Ví dụ với năng lượng mặt trời, người ta có thể khai thác nó ở bất cứ nơi nào, miễn là nơi đó có ánh sáng mặt trời, có thể dùng để tạo ra nhiệt làm nước nóng, sưởi ấm, tạo điện nhờ [hệ thống điện mặt trời](https://vuphong.vn/dien-mat-troi/) với những [tấm pin năng lượng mặt trời](https://vuphong.vn/pin-nang-luong-mat-troi/)… Hay với [năng lượng gió](https://vuphong.vn/nha-may-dien-nang-luong-tai-tao/#section_two), nguồn năng lượng này đã được sử dụng hàng trăm năm nay để di chuyển thuyền buồm, khinh khí cầu, làm các cối xay gió cho hệ thống tưới tiêu… hay xu hướng hiện nay là [sản xuất điện năng](https://vuphong.vn/dien-nang-luong-mat-troi-lan-rong-khap-cac-vung-que/) từ gió ở rất nhiều quốc gia trên thế giới.

Ngoài ra, tùy vào từng dạng năng lượng tái tạo mà nó còn có những ưu điểm riêng, ví dụ như năng lượng gió chiếm rất ít không gian; sử dụng năng lượng sinh khối từ các phế phẩm nông nghiệp, công nghiệp giúp giảm các bãi chôn xử lý rác, việc phát triển các loại cây trồng cung cấp cho năng lượng sinh khối còn tăng lượng oxy, giảm [CO2](https://vuphong.vn/khi-co2-la-gi/) cho môi trường…

## Nhược điểm của năng lượng tái tạo

Tuy có nhiều ưu điểm lớn nhưng năng lượng tái tạo cũng tồn tại một số nhược điểm, chẳng hạn như:

Do chịu tác động từ tự nhiên nên năng lượng tái tạo có tính ổn định thấp hơn so với các nguồn năng lượng truyền thống. Chỉ có thể khai thác năng lượng mặt trời vào ban ngày vào những ngày có mặt trời, còn ban đêm hay những ngày trời âm u, mưa thì hệ thống sẽ không hoạt động. Hay với năng lượng gió, các tua-bin gió chỉ có thể sinh điện vào những thời điểm có tốc độ gió thổi trong khoảng 4-25 m/s. Tốc độ gió phải tối thiểu 4 m/s thì các tua-bin gió mới bắt đầu chạy đều và phát điện, nhưng nếu vượt qua 25 m/s thì các tua-bin sẽ ngừng hoạt động để tránh hỏng hóc trong điều kiện gió mạnh.

# Vai trò của AI trong quản lý năng lượng tái tạo

  * Dự báo sản lượng điện:

* Sử dụng mô hình học máy và học sâu (Deep Learning) để dự đoán sản lượng từ tấm pin mặt trời hoặc tuabin gió dựa trên dữ liệu thời tiết, độ bức xạ mặt trời, tốc độ gió.

* Cải thiện độ chính xác dự báo từ vài giờ đến nhiều ngày, giúp lên kế hoạch vận hành lưới điện.

  * Tối ưu hóa phân phối:

* AI phân tích tình trạng tải, giá điện, nhu cầu tiêu thụ để phân phối nguồn điện tái tạo tới các khu vực ưu tiên.

* Thuật toán tối ưu đa mục tiêu giảm thất thoát truyền tải và chi phí vận hành.

  * Quản lý lưu trữ năng lượng:

* Điều phối sạc/xả pin quy mô lớn để cân bằng cung cầu theo thời gian thực.

* Dự đoán tuổi thọ pin, tự động luân phiên để kéo dài tuổi thọ hệ thống.

  * Điều khiển lưới điện vi mô (Microgrid):

* AI cho phép từng khu vực tự quản lý năng lượng, hoạt động độc lập khi lưới chính gặp sự cố.

* Tự động chuyển đổi giữa nguồn tái tạo, pin lưu trữ và điện lưới truyền thống.


# Hạ tầng công nghệ

  * Mạng cảm biến IoT: Thu thập dữ liệu thời tiết, trạng thái pin, dòng điện và tiêu thụ của từng tòa nhà.

  * Điện toán biên (Edge Computing): Xử lý dữ liệu ngay tại trạm biến áp hoặc tòa nhà để phản ứng nhanh, giảm độ trễ.

  * Nền tảng đám mây: Lưu trữ và phân tích dữ liệu lớn, huấn luyện mô hình AI toàn thành phố.

  * Giao thức chuẩn mở: Đảm bảo các thiết bị từ nhiều nhà sản xuất giao tiếp trơn tru.


# Ứng dụng thực tế

  * Thành phố Masdar (UAE): AI tối ưu hóa hệ thống điện mặt trời kết hợp lưu trữ năng lượng, giảm 20% chi phí vận hành.

  * Singapore: Sử dụng AI để điều phối lưới điện thông minh, dự báo nhu cầu tiêu thụ từng khu dân cư.

  * Đan Mạch: AI dự báo sản lượng gió, cho phép quốc gia này đáp ứng hơn 50% nhu cầu điện từ năng lượng tái tạo.


# Lợi ích kinh tế – môi trường

  * Giảm phát thải CO₂: Sử dụng tối đa năng lượng tái tạo, giảm phụ thuộc nhiên liệu hóa thạch.

  * Ổn định lưới điện: Dự báo và điều phối tốt giúp giảm nguy cơ mất điện, tăng chất lượng điện năng.

  * Tiết kiệm chi phí: Tối ưu hóa vận hành, giảm chi phí bảo trì và nâng cấp hạ tầng.

  * Nâng cao chất lượng sống: Cung cấp nguồn điện bền vững cho giao thông công cộng, chiếu sáng thông minh và dịch vụ dân sinh.


# Thách thức triển khai

  * Bảo mật dữ liệu: Hệ thống IoT và AI cần bảo vệ trước tấn công mạng.

  * Độ tin cậy dự báo: Điều kiện thời tiết biến đổi bất thường có thể gây sai lệch.

  * Chi phí đầu tư ban đầu: Cần hạ tầng cảm biến, pin lưu trữ và máy chủ tính toán mạnh.

  * Quản lý chính sách: Cần khung pháp lý hỗ trợ chia sẻ dữ liệu và vận hành liên vùng.


# Xu hướng tương lai

  * AI tự thích nghi (Self-Adaptive AI): Học liên tục từ dữ liệu thời tiết, tiêu thụ điện và giá thị trường để tối ưu điều khiển.

  * Blockchain kết hợp AI: Giao dịch năng lượng ngang hàng (P2P) minh bạch và an toàn.

  * Tích hợp xe điện (Vehicle-to-Grid): Sử dụng pin xe điện như nguồn lưu trữ di động, AI điều phối sạc/xả thông minh.

  * Mô phỏng số toàn thành phố (Digital Twin): Tạo bản sao ảo của hệ thống năng lượng để dự báo và thử nghiệm trước khi triển khai.

# Public087

Ô nhiễm không khí hiện đang là một trong những thách thức môi trường nghiêm trọng nhất tại Việt Nam, đặc biệt tại các đô thị lớn như Hà Nội và Thành phố Hồ Chí Minh. Sự gia tăng nồng độ bụi mịn PM2.5 vượt ngưỡng cho phép tại nhiều khu vực không chỉ ảnh hưởng trực tiếp đến sức khỏe cộng đồng mà còn đe dọa sự phát triển kinh tế - xã hội bền vững. Trong bối cảnh toàn cầu đang ứng phó với biến đổi khí hậu và các hệ lụy của quá trình đô thị hóa nhanh, nhận diện rõ thực trạng, xác định chính xác nguyên nhân, đánh giá mức độ đóng góp của từng nguồn thải và hiệu quả các giải pháp đã triển khai là cơ sở quan trọng để xây dựng chính sách phù hợp, góp phần nâng cao hiệu lực quản lý chất lượng không khí quốc gia.

# Giới thiệu

Ô nhiễm không khí đô thị là một trong những thách thức nghiêm trọng nhất đối với sức khỏe cộng đồng và phát triển bền vững. Nồng độ bụi mịn (PM2.5, PM10), khí NO₂, SO₂, CO và O₃ gia tăng do giao thông dày đặc, công nghiệp, và biến đổi khí hậu. Các thành phố lớn thường phải đối mặt với tình trạng mù khói, gây ra hàng triệu ca tử vong sớm mỗi năm và thiệt hại kinh tế khổng lồ.

Để giảm thiểu tác động, cần hệ thống giám sát liên tục, dự báo chính xác và phản ứng nhanh. Trí tuệ nhân tạo (AI) đóng vai trò trung tâm, cho phép phân tích dữ liệu môi trường khổng lồ, dự đoán mức ô nhiễm, và đề xuất biện pháp điều tiết giao thông, công nghiệp một cách kịp thời.

# Đánh giá tổng quan về tình hình ô nhiễm không khí

Trong những năm gần đây, tình trạng ô nhiễm không khí tại Việt Nam có xu hướng gia tăng rõ rệt, đặc biệt tại các đô thị lớn và khu vực phát triển công nghiệp. Ô nhiễm bụi - đặc biệt là bụi mịn PM2.5 được ghi nhận là thành phần ô nhiễm chính, với nồng độ trung bình năm tại nhiều khu vực thường xuyên vượt giới hạn cho phép theo Quy chuẩn kỹ thuật quốc gia QCVN 05:2023/BTNMT. Điều này đặt ra những thách thức lớn đối với công tác quản lý môi trường không khí, nhất là trong bối cảnh phát triển kinh tế nhanh, mật độ dân số đô thị cao và hạ tầng chưa đồng bộ.

Dữ liệu quan trắc tự động, liên tục từ năm 2021 đến 2024 cho thấy, các trạm tại Hà Nội ghi nhận giá trị PM2.5 trung bình năm vượt từ 1,1 đến 2,1 lần giới hạn cho phép. Các đô thị lân cận như Bắc Ninh, Bắc Giang, Hà Nam, Hưng Yên, Hải Dương, Thái Nguyên và Thái Bình cũng có mức vượt từ 1,1 đến 2,0 lần. Trong khi đó, các đô thị miền Trung và Tây Nguyên nhìn chung vẫn đạt tiêu chuẩn, mặc dù một số ngày trong năm vẫn ghi nhận giá trị PM2.5 vượt ngưỡng trung bình 24 giờ. Tại TP. Hồ Chí Minh, năm 2024 cho thấy, giá trị trung bình năm đạt ngưỡng cho phép, nhưng trong giai đoạn 2021-2023, nồng độ tại trạm Lãnh sự quán Hoa Kỳ vẫn vượt khoảng 1,1 lần.

Tỷ lệ số ngày có nồng độ PM2.5 vượt giới hạn tại các đô thị miền Bắc cao hơn rõ rệt so với các khu vực miền Trung và miền Nam. Năm 2024, trạm 556 Nguyễn Văn Cừ (Hà Nội) ghi nhận 33,04% số ngày vượt chuẩn; các trạm Hùng Vương (Thái Nguyên), Phủ Lý (Hà Nam), Nguyễn Văn Linh (Hưng Yên) và một số trạm khác ghi nhận tỷ lệ dao động từ 18% đến 36%.

Ô nhiễm không khí có tính chu kỳ rõ rệt theo mùa. Tại miền Bắc, mức độ ô nhiễm tăng cao vào mùa đông và đầu xuân (từ tháng 10 đến tháng 3 năm sau), khi điều kiện khí tượng bất lợi như nghịch nhiệt xuất hiện thường xuyên, làm hạn chế khả năng khuếch tán các chất ô nhiễm. Tại miền Nam, ô nhiễm giảm mạnh trong mùa mưa và tăng trở lại vào mùa khô, trong khi tại miền Trung, sự dao động theo mùa ít rõ rệt hơn.

Về các thông số ô nhiễm khác, hầu hết giá trị trung bình năm của NO₂, SO₂ và trung bình 1 giờ của CO đều nằm trong giới hạn cho phép. Tuy nhiên, một số trạm ghi nhận giá trị O₃ trung bình 1 giờ vượt chuẩn, đặc biệt vào các thời điểm trưa nắng, phản ánh tác động của các phản ứng quang hóa trong điều kiện đô thị hóa cao.

# Hệ thống cảm biến và dữ liệu

  * Mạng lưới cảm biến IoT: Hàng nghìn cảm biến cố định và di động đặt trên cột đèn, phương tiện công cộng, tòa nhà.

  * Dữ liệu vệ tinh: Ảnh quang học và hồng ngoại từ các vệ tinh như Sentinel-5P, MODIS, cung cấp thông tin toàn thành phố và vùng lân cận.

  * Nguồn dữ liệu phụ trợ: Dữ liệu giao thông, thời tiết, hoạt động công nghiệp, dân số, và bản đồ địa hình.

  * Tích hợp đa tầng: AI kết hợp dữ liệu cảm biến mặt đất với dữ liệu vệ tinh và dự báo khí tượng để tạo bức tranh chất lượng không khí toàn diện.


# Vai trò của AI trong giám sát và dự báo

  * Dự báo ngắn và dài hạn:

* Mô hình học sâu (LSTM, Transformer) dự đoán nồng độ PM2.5, O₃ trong vài giờ hoặc vài ngày tới.

* Dự báo theo mùa, phát hiện xu hướng dài hạn liên quan đến biến đổi khí hậu.

  * Phát hiện bất thường:

* AI nhanh chóng xác định sự cố như cháy rừng, rò rỉ hóa chất, hoặc sự kiện giao thông đặc biệt.

* Cảnh báo tự động cho chính quyền và người dân.

  * Phân tích nguyên nhân và tối ưu chính sách:

* Mô hình học máy tìm mối liên hệ giữa nguồn phát thải và điều kiện khí tượng.

* Đề xuất giải pháp như hạn chế xe cá nhân, điều chỉnh giờ sản xuất công nghiệp.

  * Tối ưu hóa giao thông và năng lượng:

* AI điều khiển đèn tín hiệu, định tuyến giao thông để giảm ùn tắc và phát thải.

* Dự báo nhu cầu năng lượng, khuyến khích sử dụng điện từ nguồn tái tạo khi mức ô nhiễm cao.


# Ứng dụng thực tế

  * Bắc Kinh và Thượng Hải: AI dự báo ô nhiễm 72 giờ, hỗ trợ chính quyền đưa ra lệnh hạn chế phương tiện.

  * London: Hệ thống CityAir kết hợp cảm biến di động và AI để thông báo chất lượng không khí theo từng khu phố.

  * Los Angeles: AI phân tích dữ liệu giao thông và thời tiết, tối ưu hóa đèn tín hiệu nhằm giảm phát thải CO₂.


# Lợi ích

  * Bảo vệ sức khỏe cộng đồng: Cảnh báo sớm giúp người dân hạn chế hoạt động ngoài trời, giảm nguy cơ bệnh hô hấp.

  * Hỗ trợ hoạch định chính sách: Cung cấp dữ liệu đáng tin cậy cho chính phủ và các tổ chức môi trường.

  * Giảm chi phí y tế: Giảm gánh nặng bệnh tật liên quan đến ô nhiễm.

  * Tăng tính minh bạch: Người dân tiếp cận thông tin chất lượng không khí thời gian thực qua ứng dụng.


# Thách thức

  * Độ chính xác dữ liệu: Cảm biến giá rẻ có thể bị sai lệch, cần AI hiệu chỉnh liên tục.

  * Bảo mật và quyền riêng tư: Dữ liệu di động và vị trí người dân cần được bảo vệ.

  * Tính bền vững: Hệ thống cảm biến và máy chủ phải hoạt động liên tục, tiêu thụ năng lượng lớn.

  * Tích hợp đa ngành: Cần phối hợp giữa giao thông, công nghiệp, y tế, và chính quyền đô thị.


# Xu hướng tương lai

  * Digital Twin cho thành phố: Tạo bản sao ảo của đô thị để mô phỏng và thử nghiệm chính sách trước khi áp dụng thực tế.

  * AI tự thích nghi: Mô hình tự học liên tục từ dữ liệu mới để duy trì độ chính xác cao.

  * Kết hợp Blockchain: Đảm bảo tính toàn vẹn và minh bạch cho dữ liệu không khí công cộng.

  * Ứng dụng di động cá nhân hóa: AI cung cấp khuyến nghị sức khỏe cụ thể cho từng người dựa trên vị trí và tình trạng y tế.

# Public088

Tế bào gốc trong cơ thể người xử lý thông tin di truyền với độ tin cậy và tốc độ vượt trội. Để làm được điều này, chúng tiếp cận các đoạn DNA cụ thể trong nhân tế bào. Các nhà nghiên cứu tại Viện Công nghệ Karlsruhe (KIT) đã nghiên cứu cách thức hoạt động của quá trình xử lý thông tin dựa trên DNA. Kết quả của họ cho thấy quá trình này tương đương với các quy trình trong máy tính hiện đại và do đó có thể được dùng làm mô hình cho các chip máy tính mới dựa trên DNA. Bài báo được công bố trên Biên niên sử của Viện Hàn lâm Khoa học New York. (DOI: 10.1111/nyas.15415)

Tế bào người chứa khoảng 20.000 gen trên một chuỗi DNA dài hai mét - được cuộn chặt trong một nhân tế bào có kích thước khoảng mười micromet. Để so sánh, kích thước này tương đương với một sợi chỉ dài 40 km được nhét vào một quả bóng đá. Bất chấp không gian hạn chế này, tế bào gốc vẫn có thể tìm và kích hoạt đúng gen chỉ trong vài phút. Những gen này khác nhau tùy theo từng tế bào. Việc kích hoạt chính xác là rất quan trọng, vì sai sót trong việc lựa chọn gen có thể dẫn đến bệnh tật hoặc chết tế bào.

Các nghiên cứu của các nhà nghiên cứu KIT đã chỉ ra rằng ngưng tụ sinh học phân tử cho phép kích hoạt nhanh chóng nhưng đáng tin cậy các gen chính xác. "Ngưng tụ sinh học phân tử là những giọt nhỏ hình thành tại các vị trí cụ thể trên DNA – tương tự như những giọt nước đọng trên gương phòng tắm sau khi tắm nước nóng – và hoạt động giống như dầu trong nước", Giáo sư Lennart Hilbert từ Viện Hệ thống Sinh học và Hóa học KIT (IBCS) giải thích. "Chúng chứa các cỗ máy phân tử, tức là một tập hợp các phân tử cụ thể cần thiết cho việc kích hoạt gen." Quá trình này gợi nhớ đến một nguyên lý cốt lõi của khoa học máy tính làm nền tảng cho máy tính và điện thoại thông minh hiện đại: kiến ​​trúc Von Neumann. Trong kiến ​​trúc này, một bộ xử lý duy nhất có thể truy cập rất nhanh vào một địa chỉ duy nhất trong bộ nhớ lớn, thường được gọi là RAM. Các nhà nghiên cứu hiện muốn chuyển giao nguyên lý này sang các chip máy tính nhân tạo dựa trên DNA để có thể kiểm soát, ví dụ, các ứng dụng công nghệ sinh học và y sinh.

# Giới thiệu

Trong nhiều thập kỷ, ngành công nghệ thông tin phụ thuộc vào **silicon** và định luật Moore. Tuy nhiên, khi kích thước transistor chạm tới giới hạn vật lý, các nhà khoa học tìm đến những phương pháp tính toán hoàn toàn mới. **Máy tính sinh học dựa trên DNA** nổi lên như một bước ngoặt, khai thác khả năng lưu trữ và xử lý thông tin tự nhiên của phân tử sinh học.

DNA – với khả năng lưu trữ dữ liệu cực lớn và tự nhân bản – mở ra viễn cảnh các “máy tính sống” hoạt động bên trong tế bào, thực hiện tính toán, ra quyết định và thậm chí tự sửa chữa. Đây là nền tảng cho y học cá nhân hóa, công nghệ gene và các hệ thống thông minh có thể hoạt động ngay bên trong cơ thể con người.

# Máy tính sinh học: Định nghĩa và ý nghĩa

Máy tính sinh học (hay còn gọi là máy tính hữu cơ) là một lĩnh vực nghiên cứu đang phát triển, tập trung vào việc sử dụng các thành phần sinh học, như tế bào, protein, DNA để tạo ra các hệ thống tính toán. Nói một cách đơn giản, thay vì dựa vào các linh kiện điện tử như silicon, máy tính sinh học sử dụng các vật liệu và cơ chế của thế giới tự nhiên.

# Ưu điểm vượt trội của máy tính sinh học

So với máy tính truyền thống, máy tính sinh học sở hữu nhiều lợi thế độc đáo:

  * **Hiệu năng vượt trội:** Các tế bào thần kinh có thể hoạt động với tốc độ và hiệu quả cao hơn nhiều so với các vi mạch silicon. Điều này hứa hẹn tạo ra những máy tính với khả năng xử lý thông tin nhanh hơn, tiết kiệm năng lượng hơn.

  * **Khả năng tự sửa chữa:** Tế bào sống có khả năng tự tái tạo và sửa chữa các hư hỏng. Điều này giúp máy tính sinh học trở nên bền bỉ hơn, ít bị lỗi hỏng hơn so với máy tính truyền thống.

  * **Linh hoạt và thích nghi:** Máy tính sinh học có thể được thiết kế để thích nghi với các môi trường khắc nghiệt và biến đổi, điều mà các máy tính silicon khó có thể làm được.


# Nguyên lý cơ bản

  * **Đại diện dữ liệu:** Chuỗi nucleotide A, T, C, G của DNA đóng vai trò như “bit” sinh học, mỗi cặp base có thể mã hóa thông tin nhị phân.

  * **Xử lý thông tin:** Phản ứng hóa học như lai ghép (hybridization), tách chuỗi, hoặc enzyme cắt DNA đóng vai trò như các cổng logic (AND, OR, NOT).

  * **Tính toán song song tự nhiên:** Hàng tỷ phân tử DNA trong một ống nghiệm có thể thực hiện hàng tỷ phép tính đồng thời – khả năng song song vượt xa máy tính truyền thống.

  * **Tự nhân bản và sửa lỗi:** Khả năng sao chép của DNA cho phép nhân rộng dữ liệu và tự sửa chữa, nâng cao độ bền.


# Ưu thế nổi bật

  * **Mật độ lưu trữ khổng lồ:** 1 gram DNA có thể lưu trữ khoảng 215 petabyte dữ liệu – gấp hàng triệu lần ổ cứng hiện nay.

  * **Tiêu thụ năng lượng thấp:** Phản ứng hóa sinh tiêu tốn ít năng lượng hơn nhiều so với siêu máy tính.

  * **Độ bền vượt thời gian:** DNA có thể tồn tại hàng nghìn năm nếu bảo quản đúng điều kiện.

  * **Tính chất sinh học tự nhiên:** Có thể tương tác trực tiếp với môi trường sinh học, đặc biệt phù hợp cho ứng dụng y học.


# Ứng dụng trong y sinh học

  * **Chẩn đoán bệnh tại chỗ:** Máy tính DNA bên trong tế bào có thể phát hiện dấu hiệu bệnh (ví dụ: nồng độ protein, RNA đặc hiệu) và phát tín hiệu cảnh báo sớm.

  * **Điều trị chính xác:** Khi phát hiện tế bào ung thư, hệ thống DNA có thể giải phóng thuốc hoặc kích hoạt cơ chế tự hủy của tế bào bệnh.

  * **Theo dõi liên tục:** Các “sensor sinh học” chạy bằng DNA có thể giám sát nồng độ đường, hormone, hoặc chỉ số miễn dịch theo thời gian thực.

  * **Lưu trữ hồ sơ y tế:** DNA nhân tạo có thể lưu trữ lịch sử điều trị, xét nghiệm, và thông tin gen của bệnh nhân ngay trong cơ thể.


# Các thành tựu nghiên cứu nổi bật

  * **DNA Storage của Microsoft & University of Washington:** Lưu trữ dữ liệu số vào DNA nhân tạo và giải mã lại với độ chính xác cao.

  * **Máy tính DNA của Caltech:** Sử dụng phản ứng enzyme để giải bài toán logic phức tạp trong ống nghiệm.

  * **DNA Origami Nanorobot:** Robot nano bằng DNA có thể vận chuyển thuốc và mở ra khi gặp tín hiệu phân tử đặc hiệu.


# Thách thức triển khai

  * **Tốc độ tính toán:** Dù xử lý song song mạnh mẽ, thời gian phản ứng hóa học vẫn chậm so với điện tử học tốc độ cao.

  * **Độ chính xác và sai số:** Lỗi lai ghép hoặc đột biến có thể gây sai kết quả.

  * **Chi phí tổng hợp DNA:** Dù giảm nhanh, hiện vẫn cao cho ứng dụng quy mô lớn.

  * **An toàn sinh học:** Cần kiểm soát nghiêm ngặt để tránh rủi ro sinh học và lây nhiễm.

  * **Chuẩn hóa và tích hợp:** Chưa có chuẩn chung để kết nối máy tính DNA với hệ thống điện tử truyền thống.


# Tương lai và xu hướng

  * **Hybrid Bio-Electronic Systems:** Kết hợp vi mạch silicon với DNA để tận dụng cả tốc độ điện tử và mật độ lưu trữ sinh học.

  * **Y học cá nhân hóa:** Máy tính DNA hoạt động trong cơ thể để phát hiện và điều trị bệnh theo thời gian thực, giảm nhu cầu nhập viện.

  * **Tính toán lượng tử sinh học:** Nghiên cứu sự giao thoa giữa cơ học lượng tử và phản ứng sinh học để tăng tốc tính toán.

  * **Sản xuất quy mô lớn:** Công nghệ tổng hợp DNA tự động và giá rẻ sẽ đưa biocomputing vào các ứng dụng công nghiệp và thương mại.

# Public089

# Giới thiệu

Siêu dẫn là hiện tượng khi một vật liệu dẫn điện **không có điện trở** , nghĩa là dòng điện có thể chạy mãi mãi mà không mất năng lượng. Trong nhiều thập kỷ, các vật liệu siêu dẫn chỉ hoạt động ở nhiệt độ cực thấp (gần 0 K), đòi hỏi làm lạnh bằng heli lỏng đắt đỏ.

Tuy nhiên, những nghiên cứu gần đây đã cho thấy khả năng xuất hiện của **vật liệu siêu dẫn ở nhiệt độ phòng** , mở ra kỷ nguyên truyền tải điện **không tổn thất** , tăng hiệu suất cho lưới điện toàn cầu và cách mạng hóa các ngành công nghiệp từ y tế, năng lượng đến máy tính lượng tử.

# Vật liệu siêu dẫn là gì?

Siêu dẫn là một hiện tượng xảy ra khi vật thể ở nhiệt độ đủ thấp và từ trường đủ nhỏ. Lúc này mức điện trở của vật dẫn trở về bằng 0, khiến nội từ trường bị suy giảm theo hiệu ứng Meissner. 

Trong vật lý, để tạo ra hiện tượng siêu dẫn, người ta sẽ tạo ra một lực hút giữa các electron truyền dẫn. Từ đó làm sản sinh việc trao đổi phonon tạo ra từ cặp electron tương quan. 

Ngoài ra còn tồn tại một vật chất siêu dẫn có tính dẫn nhiệt cao hơn lý thuyết và thấp hơn so với nhiệt độ thường trong phòng. Tuy nhiên những nghiên cứu về chất siêu dẫn nhiệt độ cao vẫn chưa hoàn chỉnh.

# Lịch sử hình thành vật liệu siêu dẫn:

Năm 1911, trong một lần thực hiện thí nghiệm với thủy ngân, nhà vật lý Hà Lan – Maoneis đã vô tình phát hiện ra khi ở nhiệt độ -269°C, thuỷ ngân sẽ có điện trở bằng không. Lúc này ông gọi đó là tính siêu dẫn. 

Việc tìm ra được một hiện tượng mới lạ này đã mở ra các khám phá quan trọng trong ngành khoa học kỹ thuật. Các nhà khoa học bắt đầu sử dụng chất siêu dẫn để chế tạo ra các vật chất có từ tính mạnh. Với mục đích phục vụ cho các lĩnh vực khoa học kỹ thuật và sản xuất khác nhau trong đời sống. Tuy nhiên, “đời không như là mơ”, việc ứng dụng tính siêu dẫn lên các kim loại thuần khiết như chì, thiếc… lại cho từ trường rất nhỏ.

Đến những năm 30 của thế kỷ XX, sau nhiều năm nghiên cứu không ngừng, các nhà khoa học đã tìm ra được một loại nguyên tố mới nếu cho vào các kim loại thuần khiết sẽ tạo được một loại hợp kim mà ở đó cường độ dòng điện và cường độ từ trường được tăng lên nhiều.

Giai đoạn năm 1930, các nhà khoa học Liên Xô bắt tay vào chế tạo hợp kim siêu dẫn có giới hạn từ trường đạt 2 tesla. Hai hợp kim siêu dẫn này gọi là hợp kim niobi – ziriconi, và hợp kim vanđi – gali.

Ngoài ra, còn có một số oxit kim loại kiểu cấu trúc A – 15. Ưu điểm của các vật chất siêu dẫn ở giai đoạn này chính là không có điện trở, nhờ đó vừa có thể làm giảm tĩnh điện, không gây ra những tổn thất nhiệt, vừa có thể tích nhỏ và công suất lớn.

Tiếp đến là giai đoạn những năm 60 của thế kỷ XX, các nhà khoa học đã nghiên cứu và chế tạo được loại vật liệu siêu dẫn có từ trường đạt đến 10 tesla. Từ đó được ứng dụng rộng trong các lĩnh vực đòi hỏi công nghệ kỹ thuật cao như cộng hưởng từ hạt nhân, máy gia tốc, buồng bọt, máy phát điện… Thế nhưng một nhược điểm của vật liệu siêu dẫn chính là chỉ hoạt động hiệu quả ở điều kiện nhiệt độ rất thấp. Điều này khiến các kỹ sư đối mặt với nhiều thách thức như tốn nhiều chi phí để tạo nên môi trường có nhiệt độ.

Giai đoạn năm 1957, các nhà khoa học đưa ra lý thuyết BCS nhằm giải thích hiện tượng siêu dẫn. Theo đó, lý thuyết BCS cho rằng lý do dẫn đến hiện tượng siêu dẫn là do ở môi trường nhiệt độ cực thấp, các điện tử tự do trong chất siêu dẫn sẽ sắp xếp nối tiếp nhau tạo thành chuỗi dài. Lúc này, các điện tử sẽ chuyển động định hướng bên trong khiến chất siêu dẫn không còn lực trở của dòng điện tử, từ đó hình thành nên dòng điện không có trở lực.

Giai đoạn năm 1986, hai kỹ sư Muler và Bainos của công ty IBM Mỹ và Thụy Điển đã khám phá ra được oxit các kim loại lantan – bari – đồng có đặc tính siêu dẫn ở nhiệt độ tương đối cao ngay cả trong điều kiện phòng thí nghiệm. Chính những nghiên cứu này đã nhen nhóm một tia hy vọng về tương lai của việc ứng dụng vật liệu siêu dẫn trong sản xuất và đời sống.

Đến nay, có không ít các nhà khoa học ở nhiều nước triển khai nghiên cứu cách nâng cao giới hạn nhiệt độ siêu dẫn. Tiêu biểu trong số đó là nhà khoa học quốc tịch Mỹ gốc Hoa – Chu Kinh Hoà và nhà khoa học Trung Quốc – Triệu Trung Hiền.

# Nguyên lý siêu dẫn

  * **Điện trở bằng 0:** Khi vật liệu đạt trạng thái siêu dẫn, các electron ghép cặp thành **cặp Cooper** , di chuyển mà không va chạm.

  * **Hiệu ứng Meissner:** Vật liệu siêu dẫn đẩy từ trường ra ngoài, tạo hiện tượng “nổi” nam châm – nền tảng cho tàu đệm từ.

  * **Chuyển pha lượng tử:** Khi nhiệt độ, áp suất hoặc thành phần hóa học đạt điều kiện thích hợp, vật liệu chuyển từ trạng thái bình thường sang siêu dẫn.


# Tiến bộ mới trong vật liệu siêu dẫn nhiệt độ phòng

  * **Hydride giàu hydro:** Hợp chất lưu huỳnh-hydro hoặc carbon-hydro được nén ở áp suất hàng triệu atm đã cho thấy siêu dẫn ở ~15 °C.

  * **Siêu dẫn áp suất thấp:** Nghiên cứu mới hướng tới vật liệu hoạt động ở điều kiện gần áp suất khí quyển, giúp ứng dụng thực tế.

  * **Kết hợp với công nghệ tính toán AI:** Mô hình học sâu dự đoán cấu trúc tinh thể và tính chất điện tử, rút ngắn thời gian khám phá.


# Ứng dụng trong truyền tải điện

  * **Lưới điện không tổn thất:** Dây dẫn siêu dẫn truyền tải điện hàng nghìn km mà không mất mát, giảm lãng phí hàng tỷ USD mỗi năm.

  * **Trạm biến áp và máy phát:** Thiết bị nhỏ gọn, hiệu suất cao, giảm chi phí bảo trì.

  * **Lưu trữ năng lượng từ gió, mặt trời:** Vật liệu siêu dẫn hỗ trợ pin từ trường siêu dẫn (SMES), cho phép nạp/xả cực nhanh.


# Ứng dụng ngoài truyền tải điện

  * **Tàu đệm từ (Maglev):** Tốc độ trên 600 km/h, vận hành êm ái và tiết kiệm năng lượng.

  * **Máy cộng hưởng từ MRI:** Giảm chi phí vận hành khi không cần helium lỏng.

  * **Máy tính lượng tử:** Siêu dẫn nhiệt độ phòng giúp qubit ổn định hơn, giảm yêu cầu làm lạnh phức tạp.

  * **Động cơ điện công suất cao:** Cho hàng không, tàu thủy, giảm trọng lượng và nâng hiệu suất.


# Thách thức triển khai

  * **Ổn định vật liệu:** Giữ tính siêu dẫn ở điều kiện môi trường bình thường vẫn là bài toán khó.

  * **Sản xuất hàng loạt:** Quy trình chế tạo cần kiểm soát cấu trúc tinh thể và tạp chất ở mức nguyên tử.

  * **Chi phí đầu tư ban đầu:** Dù vận hành tiết kiệm, giai đoạn chuyển đổi hạ tầng đòi hỏi vốn lớn.

  * **Chuẩn hóa an toàn:** Vật liệu mới cần được kiểm chứng lâu dài trước khi đưa vào lưới điện quốc gia.


# Tác động kinh tế – xã hội

  * **Cách mạng năng lượng:** Giảm thất thoát truyền tải từ mức 8–10% hiện nay xuống gần 0%, tiết kiệm hàng trăm tỷ USD.

  * **Giảm phát thải carbon:** Hiệu suất cao đồng nghĩa với ít năng lượng hóa thạch hơn.

  * **Khuyến khích năng lượng tái tạo:** Truyền tải xa giúp điện gió, điện mặt trời từ vùng hẻo lánh đến đô thị dễ dàng.

  * **Tạo ngành công nghiệp mới:** Từ thiết bị y tế, giao thông, đến máy tính siêu hiệu năng.


# Xu hướng tương lai

  * **Khám phá vật liệu bằng AI:** Học sâu và tính toán lượng tử hỗ trợ tìm kiếm hợp chất siêu dẫn áp suất thấp.

  * **Kết hợp nano và 2D materials:** Graphene và các vật liệu lớp hứa hẹn tính siêu dẫn độc đáo.

  * **Hạ tầng lưới điện thế hệ mới:** Chuẩn hóa toàn cầu để tích hợp dây dẫn siêu dẫn vào mạng lưới hiện tại.

  * **Ứng dụng dân dụng:** Thiết bị gia dụng tiết kiệm điện, phương tiện cá nhân siêu hiệu quả.

# Public090

“Cách tốt nhất để dự đoán tương lai là tạo ra nó.” – Peter Drucker, nhà tư vấn quản lý và tác giả nổi tiếng.

Chúng ta đang chứng kiến ​​một sự thay đổi lớn trong lĩnh vực điện toán, hướng tới một phương pháp mới sao chép cách thức hoạt động của bộ não chúng ta. Lĩnh vực này, [tính toán neuromorphic](https://www.editverse.com/vi/t%C6%B0%C6%A1ng-lai-c%E1%BB%A7a-ai-trong-ch%E1%BA%A9n-%C4%91o%C3%A1n-y-t%E1%BA%BF-m%C3%A1y-m%C3%B3c-s%E1%BA%BD-thay-th%E1%BA%BF-b%C3%A1c-s%C4%A9/), có thể thay đổi cách chúng ta giải quyết các vấn đề phức tạp và sử dụng trí tuệ nhân tạo (AI).

Nó được lấy cảm hứng từ cấu trúc của bộ não và cách nó hoạt động. **Điện toán hình thần kinh** muốn tạo ra các mạch và hệ thống điện tử tốt hơn trong những việc như nhìn, đưa ra quyết định và học tập. Bằng cách sử dụng cách xử lý thông tin hiệu quả của bộ não, chúng ta có thể làm cho máy tính sử dụng ít năng lượng hơn và hoạt động tốt hơn trong nhiều nhiệm vụ.

# Giới thiệu

Trong khi máy tính truyền thống dựa trên kiến trúc Von Neumann (phân tách bộ xử lý và bộ nhớ), bộ não con người xử lý thông tin một cách song song, phân tán và cực kỳ tiết kiệm năng lượng. Máy tính neuromorphic được thiết kế để bắt chước cơ chế này, tạo ra các chip mô phỏng neuron và synapse sinh học, mở đường cho trí tuệ nhân tạo (AI) có khả năng học, suy nghĩ và thích nghi giống như não người nhưng tiêu thụ năng lượng chỉ bằng một phần nhỏ của siêu máy tính hiện đại.

# Điện toán mô phỏng thần kinh là gì?

Điện toán mô phỏng thần kinh là một lĩnh vực kết hợp sinh học, vật lý, toán học, khoa học máy tính và kỹ thuật. Nó nhằm mục đích tạo ra các hệ thống thần kinh nhân tạo hoạt động giống như bộ não con người. [Kỹ thuật cấu trúc thần kinh](https://www.techtarget.com/searchenterpriseai/definition/neuromorphic-computing) xem xét cấu trúc và chức năng của não có thể giúp tạo ra các hệ thống máy tính tốt hơn như thế nào.

# Định nghĩa và nguồn cảm hứng từ bộ não con người

Bộ não con người cực kỳ phức tạp, với hàng tỷ tế bào thần kinh và hàng nghìn tỷ kết nối. _Điện toán hình thần kinh_ cố gắng bắt chước cách xử lý thông tin của não. Nó tập trung vào cách các tế bào thần kinh làm việc cùng nhau và sử dụng [Mạng lưới thần kinh tăng đột biến](https://www.editverse.com/vi/tr%C3%AD-tu%E1%BB%87-nh%C3%A2n-t%E1%BA%A1o-v%C3%A0-h%E1%BB%8Dc-m%C3%A1y-c%C3%A1ch-m%E1%BA%A1ng-h%C3%B3a-s%E1%BB%B1-th%E1%BA%ADt-v%C3%A0-huy%E1%BB%81n-tho%E1%BA%A1i-v%E1%BB%81-ch%E1%BA%A9n-%C4%91o%C3%A1n-y-t%E1%BA%BF/) để xử lý các nhiệm vụ dựa trên thời gian.

  1. Các khía cạnh chính của kỹ thuật thần kinh


  * Mô phỏng tính chất tương tự của tính toán sinh học

  * Hiểu vai trò của tế bào thần kinh trong nhận thức

  * Bằng cách sử dụng **Mạng lưới thần kinh tăng đột biến** cho **tính toán thời gian**

  * Thiết kế _Kiến trúc lấy cảm hứng từ não_ cho hiệu quả và mạnh mẽ _Máy tính nhận thức_

  * Tận dụng _Mạng lưới thần kinh nhân tạo_ để tạo ra _Kỹ thuật thần kinh_ hệ thống


Hệ thống thần kinh được tạo ra để hoạt động giống như tế bào thần kinh và khớp thần kinh trong não. Điều này có thể làm cho chúng hoạt động hiệu quả hơn, dễ thích ứng hơn và có thể xử lý lỗi tốt hơn máy tính truyền thống.


| đặc tính | Điện toán thần kinh | Máy tính truyền thống |
| --- | --- | --- |
| Công suất tiêu thụ | Hiệu quả năng lượng cao, hoạt động chỉ bằng một phần năng lượng mà
các hệ thống truyền thống yêu cầu | Tốn nhiều năng lượng, với siêu máy tính nhanh nhất thế giới cần 21
triệu watt điện |
| Phương pháp tiếp cận xử lý | Tiến trình song song, với các nơ-ron và khớp thần
kinh xử lý đồng thời cả bộ nhớ và tính toán | Xử lý tuần tự, với kiến ​​trúc von Neumann tách biệt bộ nhớ và
CPU |
| Phản hồi thời gian thực | Có khả năng phản hồi “tức thời”, lý tưởng cho việc xử lý dữ liệu cảm
biến thời gian thực và các ứng dụng IoT | Thời gian phản hồi chậm hơn do chu kỳ liên tục giữa bộ xử lý và bộ
nhớ |
| Pattern Recognition | Vượt trội trong việc nhận dạng mẫu nhờxử lý song song ồ
ạtkhả năng | Khả năng nhận dạng mẫu hạn chế so với các hệ thống hình thái thần
kinh |

 

Bất chấp những thách thức như độ chính xác, hạn chế về phần mềm và các vấn đề về truy cập, _Điện toán thần kinh_ đang được khám phá cho nhiều mục đích sử dụng. Chúng bao gồm AI, hệ thống tự trị, chất bán dẫn mới và học sâu.

_“Câu hỏi về hiệu quả sử dụng năng lượng được cho là chìa khóa để giải mã những bí mật của bộ não và hiểu được cách nó đạt được mức độ hoạt động cao như vậy với mức tiêu thụ năng lượng tối thiểu.”_

# Sức mạnh siêu máy tính của bộ não

Bộ não con người là một kỳ quan thiên nhiên kỳ thú, hoạt động như một siêu máy tính. Nó chỉ sử dụng công suất 20 watt nhưng có thể thực hiện những nhiệm vụ đáng kinh ngạc. Những nhiệm vụ này bao gồm xử lý thông tin, nhận thức thế giới và đưa ra quyết định. Điều này hiệu quả hơn nhiều so với các siêu máy tính nhanh nhất thế giới vốn cần 21 triệu watt.

Các nhà khoa học rất quan tâm đến cách thức hoạt động của bộ não. Họ nghiên cứu các phương pháp tính toán của nó để cải thiện các thuật toán và máy tính trong tương lai. Bằng cách xem xét cách bộ não sử dụng [tiến trình song song](https://www.bbc.com/news/articles/cx99qv2w1ddo), _tính toán thời gian_ , và là _tiết kiệm năng lượng_ , họ hy vọng sẽ đạt được những tiến bộ lớn trong _Bộ não như siêu máy tính_.


| Máy tính thần kinh | HIỆU QUẢ | Công suất tiêu thụ |
| --- | --- | --- |
| Điểm Hala | 380 nghìn tỷ hoạt động khớp thần kinh mỗi giây | Tiết kiệm năng lượng gấp 100 lần so với máy thông thường |
| DeepSouth | 228 nghìn tỷ hoạt động khớp thần kinh mỗi giây | Chỉ chiếm sáu giá đỡ trong một thùng máy chủ tiêu chuẩn |
| Biên giới doanh nghiệp Hewlett Packard | Hơn một triệu tỷ phép tính mỗi giây | Có diện tích 680 mét vuông và cần 22.7 megawatt để chạy |

 

_Bộ não như siêu máy tính_ tiết kiệm năng lượng hơn nhiều so với các siêu máy tính cũ. Điều này cho thấy tiềm năng to lớn của điện toán mô phỏng thần kinh. Khi các nhà nghiên cứu tiếp tục cải tiến công nghệ này, chúng ta có thể mong đợi một tương lai nơi máy tính và AI hoạt động hiệu quả và mạnh mẽ hơn, lấy cảm hứng từ bộ não con người.

# Nguyên lý hoạt động

  * Neuron nhân tạo phần cứng: Các mạch điện mô phỏng điện thế màng, xung điện và quá trình kích hoạt của neuron sinh học.

  * Synapse điện tử: Dùng memristor hoặc các vật liệu có thể thay đổi điện trở để ghi nhớ trọng số kết nối – tương tự synapse thật.

  * Xử lý song song và sự kiện (event-driven): Dữ liệu được truyền khi có xung điện, giảm lãng phí năng lượng so với đồng hồ xung liên tục.

  * Tự học trong phần cứng: Học Hebbian và Spike-Timing Dependent Plasticity (STDP) cho phép chip tự điều chỉnh trọng số như não.


# Ưu thế vượt trội

  * Hiệu quả năng lượng cao: Tiêu thụ vài mW cho hàng triệu neuron, lý tưởng cho thiết bị di động hoặc cảm biến IoT.

  * Độ trễ thấp: Xử lý trực tiếp trong phần cứng, loại bỏ bottleneck giữa bộ nhớ và CPU.

  * Khả năng học trực tuyến: Thích nghi với dữ liệu mới mà không cần huấn luyện lại toàn bộ mạng.

  * Tích hợp cảm biến: Có thể đặt trực tiếp vào camera, robot, thiết bị y tế.


# Ứng dụng thực tế

  * Robot tự hành: Phản ứng nhanh với môi trường, nhận diện đối tượng và điều hướng với mức tiêu thụ điện cực thấp.

  * Thiết bị IoT thông minh: Cảm biến môi trường, thiết bị đeo sức khỏe hoạt động hàng tháng chỉ bằng pin nhỏ.

  * Thị giác máy tính thời gian thực: Nhận diện hình ảnh và âm thanh nhanh, hỗ trợ xe tự hành hoặc drone.

  * Y tế và cấy ghép thần kinh: Chip neuromorphic giao tiếp trực tiếp với hệ thần kinh, hỗ trợ phục hồi chức năng vận động.


# Công nghệ nền tảng

  * Memristor: Phần tử mạch điện có khả năng nhớ điện trở, lưu trữ trọng số synapse bền bỉ.

  * Vật liệu 2D: Graphene và oxide kim loại cho tốc độ và độ bền cao.

  * Hệ thống lập trình sự kiện: Ngôn ngữ và framework tối ưu cho mạng spiking neural network (SNN).

  * Chip tiên phong: Intel Loihi, IBM TrueNorth, BrainScaleS của châu Âu.


# Thách thức

  * Chuẩn hóa phần mềm: Cần công cụ lập trình và thuật toán tối ưu cho mạng neuron dạng spiking.

  * Sản xuất hàng loạt: Công nghệ memristor và vật liệu mới chưa phổ biến ở quy mô công nghiệp.

  * Khả năng mở rộng: Cần duy trì tính ổn định khi số lượng neuron đạt hàng tỷ.

  * Hệ sinh thái ứng dụng: Phải phát triển phần mềm, hệ điều hành và công cụ hỗ trợ tương thích.


# Tác động tương lai

  * AI tiết kiệm năng lượng: Tạo điều kiện cho hàng tỷ thiết bị AI biên hoạt động bền vững, không cần đám mây.

  * Điện toán giống não người: Mở đường cho các hệ thống nhận thức, suy luận gần với con người.

  * Kết hợp với học tự giám sát: Giúp chip học từ dòng dữ liệu liên tục mà không cần gắn nhãn.

  * Tích hợp trong y sinh: Thiết bị cấy ghép thần kinh và giao diện não–máy (BCI) trở nên khả thi và an toàn hơn.

# Public091

# Giới thiệu

Pin năng lượng rắn (Solid-State Battery – SSB) được xem là bước tiến quan trọng trong ngành lưu trữ năng lượng, hứa hẹn **mật độ năng lượng cao** , **độ an toàn vượt trội** và **tuổi thọ dài** so với pin lithium-ion truyền thống. Thay vì sử dụng chất điện phân lỏng dễ cháy, pin thể rắn dùng **chất điện phân rắn** , mở ra tương lai cho xe điện, thiết bị di động và lưới điện lưu trữ quy mô lớn.

# Pin thể rắn là gì?

**Pin thể rắn** (Solid-State Battery) là một bước tiến công nghệ đột phá trong ngành lưu trữ năng lượng, với cấu trúc hoàn toàn khác biệt so với pin truyền thống. Thay vì sử dụng chất điện phân dạng lỏng như trong pin Lithium-ion, pin thể rắn dùng chất điện phân ở trạng thái rắn – đây chính là điểm khác biệt cốt lõi tạo nên loạt lợi thế vượt trội về hiệu suất, độ an toàn và mật độ năng lượng.

Chất điện phân rắn có thể là các hợp chất gốm, polymer, sulfide hay oxide… đóng vai trò trung gian truyền dẫn các ion lithium giữa hai cực âm (anode) và cực dương (cathode). Trong quá trình sạc, ion lithium di chuyển từ cực dương sang cực âm, và ngược lại trong quá trình phóng điện – quy trình này sinh ra dòng điện cung cấp năng lượng cho thiết bị.

# Cấu trúc và nguyên lý hoạt động

  * **Cực dương (Cathode):** Thường làm từ oxit kim loại chứa lithium.

  * **Cực âm (Anode):** Có thể sử dụng lithium kim loại tinh khiết, tăng đáng kể dung lượng.

  * **Chất điện phân rắn:** Gốm, polymer hoặc sulfide dẫn ion, thay thế hoàn toàn dung dịch lỏng.

  * **Cơ chế truyền ion:** Ion lithium di chuyển qua chất điện phân rắn trong quá trình sạc/xả, tương tự pin truyền thống nhưng an toàn hơn và giảm kháng nội.


![Mô phỏng cấu tạo của pin thể rắn](images/image1.jpeg) _Hình ảnh mô phỏng cấu tạo của pin ở thể rắn_

# Ưu điểm vượt trội

  * **Mật độ năng lượng cao:** Có thể đạt mức 400–500 Wh/kg, tăng 50–80% so với pin lithium-ion.

  * **An toàn:** Không chứa dung dịch dễ cháy, giảm nguy cơ cháy nổ.

  * **Sạc nhanh:** Đặc tính điện hóa ổn định cho phép sạc đầy trong thời gian ngắn.

  * **Tuổi thọ dài:** Giảm hình thành dendrite, kéo dài số chu kỳ sạc lên hàng nghìn lần.

  * **Hoạt động trong dải nhiệt rộng:** Hiệu suất tốt ngay cả ở nhiệt độ thấp.


# Ứng dụng thực tế

  * **Xe điện (EV):** Gia tăng quãng đường di chuyển, giảm thời gian sạc và tăng độ an toàn.

  * **Thiết bị điện tử di động:** Kéo dài tuổi thọ pin cho điện thoại, laptop, thiết bị đeo.

  * **Lưu trữ năng lượng tái tạo:** Ổn định lưới điện, tích trữ điện từ gió và mặt trời với chi phí thấp hơn.

  * **Hàng không và vũ trụ:** Giảm trọng lượng và tăng độ tin cậy cho vệ tinh và máy bay điện.


# Thách thức triển khai

  * **Chi phí sản xuất cao:** Quy trình chế tạo và vật liệu tiên tiến (như gốm sulfide) đòi hỏi công nghệ phức tạp.

  * **Giao diện điện cực – điện phân:** Tiếp xúc kém có thể làm giảm hiệu suất và tuổi thọ pin.

  * **Quy mô công nghiệp:** Cần dây chuyền sản xuất hàng loạt ổn định và đồng nhất.

  * **Vấn đề dendrite:** Dù giảm nhiều, vẫn cần kiểm soát để ngăn lithium hình thành sợi dẫn điện gây chập.


# Tiến bộ nghiên cứu

  * **Toyota và QuantumScape:** Công bố pin thể rắn mẫu có mật độ năng lượng gấp đôi pin lithium-ion.

  * **Samsung Advanced Institute:** Thiết kế lớp phủ bạc-carbon để cải thiện tiếp xúc điện cực.

  * **Viện nghiên cứu châu Âu:** Khám phá chất điện phân sulfide cho khả năng dẫn ion cao và linh hoạt cơ học.


# Tác động kinh tế – xã hội

  * **Thúc đẩy xe điện toàn cầu:** Giảm chi phí và tăng phạm vi di chuyển, đẩy nhanh quá trình khử carbon.

  * **Giảm ô nhiễm môi trường:** Tuổi thọ dài và khả năng tái chế cao giảm rác thải pin.

  * **Ổn định lưới điện xanh:** Hỗ trợ tích hợp năng lượng tái tạo quy mô lớn, giảm phụ thuộc nhiên liệu hóa thạch.


# Pin thể rắn trong tương lai

Với ưu nhược điểm pin thể rắn, loại pin này đã và đang được cân nhắc ứng dụng trong nhiều lĩnh vực khác nhau trong cuộc sống. Trong đó, [pin thể rắn được kỳ vọng sẽ làm thay đổi ngành công nghiệp xe điện](https://vinfastauto.com/vn_vi/pin-the-ran-nguon-goc-huu-co-lam-thay-doi-tuong-lai-xe-dien). Nó cho phép xe điện thu gọn được tối đa diện tích và giảm trọng lượng của xe xuống tới mức thấp nhất. Ngoài ra, loại pin này còn giúp giảm thời gian sạc điện cũng như có độ an toàn và tin cậy cao hơn. Chính vì thế, sự ra đời của pin thể rắn dự kiến sẽ thúc đẩy mạnh ngành xe điện trên thế giới. 

Một nghiên cứu đáng chú ý gần đây về pin thể rắn đó chính là pin được làm từ muối do nhóm nghiên cứu đến từ Đại học Nottingham của Vương quốc Anh cùng 6 cơ quan nghiên cứu khác của Trung Quốc công bố. Theo đó, muối rắn sẽ được sử dụng làm chất điện phân và cả chất phân tách. Đây được xem là bước tiến mới cho tương lai sản xuất pin thể rắn, vì giảm giá thành pin và vô cùng thân thiện với môi trường.

![VinFast hợp tác ProLogium sản xuất pin thể rắn đầu tiên tại Việt Nam](images/image2.jpeg) _VinFast hợp tác ProLogium sản xuất pin thể rắn đầu tiên tại Việt Nam (Nguồn: Sưu tầm)_

Tại Việt Nam, nhận thấy những tiềm năng, ưu điểm của pin thể rắn, vào tháng 03/03/2021, [**nhà sản xuất xe máy ô tô điện hàng đầu VinFast**](https://vinfastauto.com/) đã ký kết biên bản hợp tác chiến lược với ProLogium (Đài Loan) - Công ty đầu tiên trên thế giới có dây chuyền thử nghiệm ứng dụng công nghệ pin thể rắn cho ô tô.

# Public092

Siêu vật liệu là vật liệu nhân tạo với cấu trúc vi mô hoặc nano, cho phép điều khiển sóng điện từ, âm học và cơ học nhờ tham số hiệu dụng bất thường. Đơn vị cấu trúc tuần hoàn của siêu vật liệu có kích thước nhỏ hơn bước sóng, cho phép thiết kế cloaking, superlens, anten siêu mỏng và các ứng dụng khác.

# Giới thiệu

Siêu vật liệu (Metamaterial) là một trong những lĩnh vực tiên phong nhất trong khoa học vật liệu và công nghệ sóng. Khác với vật liệu tự nhiên vốn có giới hạn về hằng số điện môi, từ tính hay tính dẫn điện, siêu vật liệu được tạo ra bằng cách thiết kế cấu trúc nhân tạo ở cấp độ nano và micro, cho phép kiểm soát sóng điện từ theo những cách “phi tự nhiên”.

Khi thế giới hướng tới mạng 6G, hoạt động ở dải tần Terahertz (0.1–10 THz), các kỹ thuật truyền thống như anten kim loại hay ăng-ten MIMO khổng lồ sẽ gặp giới hạn vật lý. Siêu vật liệu chính là giải pháp mang tính đột phá, cho phép tạo ra các anten thông minh, bề mặt phản xạ tái cấu hình (RIS) và các hệ thống điều khiển sóng điện từ linh hoạt, giúp hiện thực hóa tốc độ truyền dữ liệu hàng terabit/giây và độ trễ dưới 1 mili giây mà 6G đòi hỏi.

# Định nghĩa và phân loại

Siêu vật liệu được phân loại theo tính chất sóng mà chúng điều khiển:

  * **Siêu vật liệu điện từ (electromagnetic metamaterials):** cho phép thiết lập εeff và μeff âm hoặc không đồng nhất, ứng dụng trong cloaking và superlensing.

  * **Siêu vật liệu âm học (acoustic metamaterials):** sử dụng cấu trúc cộng hưởng Helmholtz hoặc ống dẫn âm để điều khiển tốc độ và hướng truyền sóng âm, phục vụ cách âm và cloaking âm.

  * **Siêu vật liệu cơ học (mechanical metamaterials):** sở hữu các đặc tính cơ học phi truyền thống như hệ số Poisson âm (auxetic) hoặc cứng/nhu mềm tùy biến.

  * **Siêu vật liệu quang học (optical metamaterials):** hoạt động ở bước sóng ánh sáng khả kiến và cận hồng ngoại, đòi hỏi cấu trúc nano với kích thước nhỏ hơn 100 nm để điều khiển giao thoa và phân cực ánh sáng.


Mỗi loại siêu vật liệu có cơ chế hoạt động và phạm vi ứng dụng riêng, nhưng đều dựa trên nguyên lý đồng nhất hóa (homogenization) để mô tả tính chất trung bình của môi trường nhân tạo thông qua các tham số hiệu dụng (effective parameters).

# Nguyên lý hoạt động và mô hình hóa

Nguyên lý cốt lõi của siêu vật liệu là sự cộng hưởng của đơn vị cấu trúc. Với siêu vật liệu điện từ, các split-ring resonator (SRR) và mảng dây kim loại (wire arrays) tạo ra cộng hưởng từ và điện, dẫn đến εeff hoặc μeff âm trong vùng tần số hẹp.

Mô hình hóa siêu vật liệu thường sử dụng các phương trình Maxwell hiệu dụng, trong đó các tham số εeff và μeff được tính từ đáp ứng của đơn vị cấu trúc. Phương trình phân tán (dispersion relation) xác định mối quan hệ giữa véc-tơ sóng k và tần số ω, cho phép dự đoán khoảng băng thông và tính ổn định của cộng hưởng.

  * **Công thức hiệu dụng:** εeff=f(χe), μeff=f(χm), trong đó χ là độ từ cảm và điện cảm.

  * **Dispersion relation:** k(ω) xác định tốc độ pha và tốc độ nhóm, ảnh hưởng đến khả năng truyền và hấp thụ sóng.

  * **Hiệu ứng cộng hưởng đa bậc:** thiết kế nhiều cộng hưởng để mở rộng băng thông và giảm tổn hao (losses).


# Các phương pháp chế tạo

Chế tạo siêu vật liệu đòi hỏi công nghệ vi chế tạo chính xác để tạo ra cấu trúc lặp lại tuần hoàn với kích thước từ micro đến nano. Các phương pháp chính gồm:

  1. **Gia công MEMS và photolithography:** sử dụng cho tần số vi sóng và THz, công nghệ CMOS-compatible cho phép tích hợp trên chip bán dẫn.

  2. **In 3D vi cấu trúc (two-photon polymerization):** cho phép chế tạo cấu trúc 3D phức tạp ở quy mô sub-micron, phục vụ siêu vật liệu quang học ([ScienceDirect](https://www.sciencedirect.com/science/article/pii/S0030401818301362)).

  3. **Tự tổ chức (self-assembly) và in phun nano:** sử dụng vật liệu block copolymers hoặc colloidal nanoparticles để tạo màng mỏng siêu vật liệu trên diện rộng với chi phí thấp.


| Phương pháp | Kích thước cấu trúc | Ưu điểm | Nhược điểm |
| --- | --- | --- | --- |
| Photolithography | 100 nm–10 µm | Độ chính xác cao, khả năng tích hợp | Chi phí cao, diện tích nhỏ |
| Two-photon polymerization | 100 nm–1 µm | Khả năng 3D phức tạp | Tốc độ chậm, đắt đỏ |
| Self-assembly | 10 nm–1 µm | Quy mô lớn, chi phí thấp | Độ đồng nhất hạn chế |

 

# Siêu vật liệu điện từ

Siêu vật liệu điện từ (electromagnetic metamaterials) tận dụng cấu trúc đơn vị cộng hưởng để mô phỏng tham số hiệu dụng εeff và μeff âm hoặc giá trị bất thường. Split-ring resonator (SRR) tạo cộng hưởng từ, trong khi mảng dây kim loại (wire array) tạo cộng hưởng điện, kết hợp để đạt được vùng tần số với khúc xạ âm ([Nature](https://www.nature.com/articles/35095038)).

Đặc tính phân tán (dispersion) của siêu vật liệu điện từ được mô tả bởi phương trình:

k2=ω2μeff(ω) εeff(ω)

Trong đó, k là véc-tơ sóng, ω là tần số, μeff(ω) và εeff(ω) thay đổi theo tần số, cho phép thiết kế băng thông cộng hưởng hẹp hoặc mở rộng bằng cách bố trí đa cộng hưởng trong một đơn vị cell.

  * **Negative refraction:** góc khúc xạ phản chiều với góc tới, cho phép chế tạo siêu ống kính (superlens) vượt giới hạn nhiễu xạ.

  * **Hyperbolic dispersion:** iso-frequency surface dạng hyperboloid hỗ trợ mật độ trạng thái quang học cao và truyền dẫn sóng evanescent.

  * **Metasurfaces:** siêu vật liệu hai chiều điều khiển pha ánh sáng theo mặt phẳng, ứng dụng trong điều chế sóng và quang học phẳng.


# Nguyên lý hoạt động

  * Cấu trúc siêu nhỏ: Siêu vật liệu gồm những phần tử lặp (unit cell) nhỏ hơn nhiều so với bước sóng tín hiệu. Nhờ vậy, thay vì chỉ hấp thụ hay phản xạ sóng như vật liệu thường, chúng có thể thay đổi pha, biên độ và hướng truyền theo thiết kế.

  * Chỉ số khúc xạ âm: Một trong những đặc điểm nổi bật là khả năng tạo ra chỉ số khúc xạ âm (negative refractive index), nghĩa là sóng có thể “bẻ cong” theo hướng ngược lại so với quy luật thông thường.

  * Metasurface: Thay vì khối 3D cồng kềnh, siêu vật liệu có thể được chế tạo thành các lớp mỏng 2D (metasurface), dày chỉ vài nanomet nhưng có khả năng kiểm soát sóng mạnh mẽ, dễ tích hợp lên thiết bị di động hoặc vệ tinh.

  * Điều khiển động (Dynamic Tuning): Với sự hỗ trợ của graphene và vật liệu 2D, các đặc tính điện từ có thể thay đổi theo điện áp, ánh sáng hay từ trường bên ngoài, tạo nên bề mặt thông minh có khả năng điều chỉnh theo thời gian thực.


# Ứng dụng trong mạng 6G

## Anten siêu vật liệu tái cấu hình:

  * Các anten 6G cần băng thông lớn, đa hướng và linh hoạt. Siêu vật liệu cho phép thiết kế anten có thể chuyển đổi mẫu bức xạ, tập trung sóng về hướng người dùng hoặc phân tán khi cần thiết.

  * Thay vì cần hàng trăm anten riêng lẻ, một anten phủ metasurface có thể thay thế toàn bộ nhờ khả năng lập trình.


## Bề mặt phản xạ thông minh (Reconfigurable Intelligent Surface – RIS):

  * Trong đô thị, tín hiệu thường bị tòa nhà che chắn. RIS phủ siêu vật liệu có thể “bẻ cong” sóng, chuyển hướng tín hiệu đến đúng người dùng.

  * Điều này giúp tăng vùng phủ sóng, giảm “điểm chết” và tiết kiệm năng lượng phát sóng.


## Lọc và bảo mật tín hiệu:

  * Siêu vật liệu cho phép tạo ra bộ lọc tần số hẹp và kênh truyền an toàn, giảm nguy cơ nghe lén.

  * Đây là bước quan trọng khi 6G được ứng dụng trong y tế từ xa, tài chính và quân sự.


## Giao tiếp Terahertz (THz):

  * Sóng THz dễ bị hấp thụ bởi môi trường, nhưng siêu vật liệu có thể tăng cường khả năng truyền và hội tụ.

  * Nhờ đó, liên lạc 6G có thể đạt tốc độ hàng trăm gigabit đến terabit/giây, đáp ứng cho metaverse và AI thời gian thực.


# Ứng dụng ngoài viễn thông

  * Tàng hình radar và sóng: Siêu vật liệu có thể khiến vật thể trở nên “vô hình” với radar bằng cách làm lệch hướng sóng, ứng dụng trong quân sự.

  * Thấu kính siêu phân giải (Superlens): Vượt giới hạn nhiễu xạ ánh sáng, cho phép quan sát chi tiết tế bào hoặc cấu trúc nano.

  * Pin mặt trời siêu hiệu quả: Tăng khả năng hấp thụ ánh sáng vào tế bào quang điện.

  * Cảm biến sinh học: Dùng cộng hưởng plasmon bề mặt để phát hiện virus, protein hoặc hóa chất ở nồng độ cực thấp.

  * Vật liệu cách âm: Không chỉ điều khiển sóng điện từ, siêu vật liệu còn ứng dụng trong điều khiển sóng âm, giảm tiếng ồn đô thị.


# Thách thức nghiên cứu và thương mại hóa

  * Sản xuất quy mô nano: Tạo cấu trúc nano đồng nhất ở diện tích lớn là cực kỳ khó khăn và tốn kém.

  * Độ bền vật liệu: Siêu vật liệu dễ bị hư hỏng khi tiếp xúc môi trường khắc nghiệt, cần cải tiến về cơ học.

  * Chi phí: Vật liệu graphene, vàng nano hay oxide hiếm đắt đỏ, chưa thể triển khai đại trà.

  * Tích hợp tiêu chuẩn 6G: Các hãng viễn thông cần thống nhất chuẩn RIS, metasurface để đảm bảo tính tương thích toàn cầu.

  * Điều khiển động: Dù ý tưởng metasurface động đã xuất hiện, việc chế tạo sản phẩm ổn định vẫn còn ở giai đoạn thử nghiệm.


# Xu hướng tương lai

  * Metamaterial lai (Hybrid): Kết hợp graphene với các oxide kim loại để vừa rẻ vừa hiệu quả.

  * Metasurface điều khiển AI: AI tối ưu hóa cách điều khiển RIS theo thời gian thực để đảm bảo kết nối tốt nhất.

  * Tích hợp trong vệ tinh và drone: Siêu vật liệu nhẹ, mỏng, phù hợp cho hệ thống viễn thông không gian.

  * Ứng dụng dân dụng: Anten thông minh cho smartphone, router Wi-Fi 7/8, và thiết bị IoT.

  * Kết hợp lượng tử: Siêu vật liệu có thể mở đường cho truyền thông lượng tử và các thiết bị quang học lượng tử thế hệ mới.


# Tác động kinh tế – xã hội

  * Mạng phủ sóng toàn diện: Giảm chi phí hạ tầng 6G khi cần ít trạm phát hơn.

  * Internet tốc độ siêu cao: Đáp ứng nhu cầu thực tế ảo, metaverse, và công nghiệp 4.0.

  * An ninh quốc gia: Hỗ trợ hệ thống radar tàng hình, thông tin quân sự bảo mật.

  * Y tế và giáo dục: Tạo môi trường ảo chất lượng cao cho phẫu thuật từ xa, học tập từ xa.

  * Kinh tế xanh: Giảm tiêu thụ năng lượng trong viễn thông nhờ tối ưu sóng

# Public093

# Giới thiệu

Máy tính điện tử truyền thống dựa trên electron đã đạt tới giới hạn về tốc độ và tiêu thụ năng lượng, đặc biệt khi xử lý các mô hình trí tuệ nhân tạo (AI) khổng lồ với hàng tỷ tham số. **Máy tính quang học (Photonic Computing)** nổi lên như một giải pháp đột phá, khai thác **photon** – hạt ánh sáng – để truyền và xử lý thông tin.

Photon di chuyển gần như **tức thời** và không sinh nhiệt đáng kể, giúp máy tính quang học đạt **tốc độ xử lý cao gấp hàng trăm lần** và giảm tiêu thụ năng lượng so với mạch điện tử. Công nghệ này được coi là nền tảng cho **AI thế hệ tiếp theo** , điện toán lượng tử lai và các trung tâm dữ liệu siêu hiệu suất.

# Vì sao lại là photon?

  * Photon – hạt ánh sáng – sở hữu nhiều ưu điểm vượt trội:

* Di chuyển nhanh gần như không tổn hao, dễ dàng truyền tải qua cáp quang và không cần làm lạnh đến nhiệt độ cực thấp như các qubit siêu dẫn.

* Khả năng chống nhiễu tốt, giúp duy trì trạng thái lượng tử (coherence) lâu hơn.

* Tích hợp hạ tầng viễn thông quang học sẵn có, mở ra tiềm năng ứng dụng rộng rãi trong mạng lượng tử và điện toán phân tán.


Cách hoạt động của máy tính lượng tử quang tử. Máy tính lượng tử quang tử không dựa trên mạch bán dẫn truyền thống, mà sử dụng:

  * **Qubit quang tử** : mã hóa thông tin vào trạng thái phân cực, pha hoặc số photon.

  * **Mạng lưới quang tử (photonic circuits)** : chip silicon tích hợp với bộ chia chùm (beam splitter), bộ dịch pha (phase shifter) để điều khiển photon.

  * **Phép đo lượng tử** : sử dụng cảm biến siêu nhạy để đọc kết quả tính toán.


# Nguyên lý hoạt động

  * **Truyền dữ liệu bằng photon:** Thay vì electron chạy qua dây dẫn, photon di chuyển qua các sợi quang hoặc mạch quang tích hợp.

  * **Tính toán trong miền quang:** Các phần tử như **bộ tách chùm, giao thoa kế Mach–Zehnder** và **lưới dẫn sóng silicon** thực hiện các phép nhân–cộng ma trận trực tiếp bằng ánh sáng.

  * **Xử lý song song tự nhiên:** Nhiều bước sóng (đa kênh) có thể truyền đồng thời trong một sợi quang, cho phép **tính toán song song khối lượng lớn**.

  * **Chuyển đổi quang–điện:** Kết hợp cảm biến quang và bộ tách tín hiệu điện để tương thích với hệ thống điện tử hiện có.


# Ưu thế vượt trội

  * **Tốc độ cực cao:** Truyền dữ liệu gần tốc độ ánh sáng, băng thông hàng terabit/giây.

  * **Tiêu thụ năng lượng thấp:** Giảm nhiệt và nhu cầu làm mát so với chip điện tử.

  * **Khả năng mở rộng:** Hỗ trợ mô hình AI lớn mà không tăng đột biến chi phí năng lượng.

  * **Xử lý song song:** Đa kênh quang cho phép tính toán đồng thời nhiều phép toán ma trận – cốt lõi của huấn luyện deep learning.


# Ứng dụng trong trí tuệ nhân tạo

  * **Huấn luyện mô hình lớn:** Giảm thời gian huấn luyện từ nhiều tuần xuống vài ngày.

  * **Suy luận thời gian thực:** Hỗ trợ AI biên (edge AI) và robot tự hành với độ trễ cực thấp.

  * **Xử lý hình ảnh và video:** Tăng tốc các mạng CNN và Transformer cho thị giác máy tính.

  * **Xử lý ngôn ngữ tự nhiên:** Đẩy nhanh các tác vụ như dịch tự động, tổng hợp văn bản.


# Hạ tầng công nghệ

  * **Mạch quang tích hợp (Photonic Integrated Circuit – PIC):** Kết hợp hàng nghìn linh kiện quang trên chip silicon.

  * **Laser bán dẫn siêu nhỏ:** Cung cấp nguồn photon ổn định cho tính toán.

  * **Vật liệu đặc biệt:** Silicon nitride, graphene và hợp chất III-V cho phép điều khiển ánh sáng chính xác.

  * **Ghép nối với điện toán lượng tử:** Photon có thể truyền qubit lượng tử bền vững hơn electron.


# Thách thức hiện tại

  * **Kích thước và độ chính xác chế tạo:** Yêu cầu công nghệ in nano chính xác cao.

  * **Tương thích với phần mềm:** Cần thư viện và thuật toán tối ưu cho mạch quang.

  * **Chi phí ban đầu:** Sản xuất chip quang vẫn đắt hơn silicon truyền thống.

  * **Chuyển đổi quang–điện:** Mỗi lần chuyển đổi làm giảm hiệu suất, cần giải pháp lai tối ưu.


# Tiến bộ nghiên cứu và thương mại hóa

  * **Lightmatter & Lightelligence:** Phát triển bộ gia tốc AI quang học, đạt hiệu năng vượt GPU cao cấp.

  * **MIT & Stanford:** Trình diễn mạng nơ-ron quang học trên chip, huấn luyện trực tiếp bằng ánh sáng.

  * **Google & Microsoft:** Nghiên cứu kết hợp quang học với điện toán lượng tử cho trung tâm dữ liệu.


# Tác động kinh tế – xã hội

  * **Trung tâm dữ liệu xanh:** Giảm tiêu thụ điện hàng tỷ kWh mỗi năm.

  * **Thúc đẩy AI khổng lồ:** Cho phép các mô hình ngôn ngữ, hình ảnh vượt mức hiện tại mà vẫn khả thi về chi phí.

  * **Y tế và khoa học:** Tăng tốc phân tích gen, mô phỏng thuốc, và xử lý hình ảnh y khoa.

  * **Viễn thông và tài chính:** Hỗ trợ giao dịch tốc độ cực cao và mạng 6G/7G tương lai.


# Xu hướng tương lai

  * **Chip quang – điện lai (Hybrid Photonic-Electronic):** Kết hợp điểm mạnh của cả hai thế giới.

  * **Vật liệu 2D:** Graphene và perovskite nâng cao độ bền và linh hoạt.

  * **AI tự tối ưu thiết kế mạch:** Dùng học sâu để bố trí linh kiện quang tối ưu cho từng tác vụ.

  * **Máy tính quang lượng tử:** Kết hợp tính chất photon và qubit cho siêu máy tính thế hệ mới.


#  **Tương lai gần**

  * Các công ty như PsiQuantum, Xanadu và QuiX Quantum đang đua nhau phát triển các nguyên mẫu máy tính lượng tử quang tử có thể mở rộng. Một số thử nghiệm đã chứng minh khả năng đạt “tính ưu việt lượng tử” (quantum advantage) trong những bài toán mẫu. Nếu vượt qua các thách thức kỹ thuật, đây có thể là con đường khả thi nhất để hiện thực hóa máy tính lượng tử thương mại trong thập kỷ tới.

  * Máy tính lượng tử quang tử chính là cuộc cách mạng dựa trên ánh sáng, có thể định hình lại toàn bộ ngành khoa học, công nghệ và nền kinh tế tri thức toàn cầu.

# Public094

# Giới thiệu

Vũ trụ học tính toán là lĩnh vực liên ngành kết hợp vật lý thiên văn, toán học, khoa học máy tính và trí tuệ nhân tạo để giải mã lịch sử hình thành và tiến hóa của vũ trụ. Nếu kính thiên văn cho chúng ta hình ảnh của bầu trời như nó hiện ra hôm nay, thì vũ trụ học tính toán cho phép “tua ngược thời gian”, tái dựng những giai đoạn sớm nhất của vũ trụ từ sau Vụ Nổ Lớn (Big Bang), đồng thời dự đoán tương lai hàng chục tỷ năm tới.

Các mô phỏng này tái hiện sự giãn nở không gian, tương tác của vật chất tối, năng lượng tối, và khí baryon để trả lời các câu hỏi cốt lõi: Làm thế nào các thiên hà đầu tiên hình thành? Vì sao chúng phân bố thành mạng lưới vũ trụ (cosmic web) khổng lồ? Và tương lai của vũ trụ – dãn nở vô hạn hay co sụp – sẽ ra sao?

# Bối cảnh lịch sử

  * Thập niên 1960–1980: Các mô phỏng đầu tiên chỉ xử lý vài trăm đến vài nghìn hạt, tập trung vào sự hình thành cụm thiên hà.

  * Thập niên 1990: Sự phát triển của siêu máy tính cho phép mô phỏng hàng triệu hạt, lần đầu tiên thể hiện mạng lưới vũ trụ giống quan sát thực.

  * Thế kỷ 21: Các dự án như Millennium Simulation và Illustris nâng quy mô lên hàng chục tỷ hạt, mô tả chi tiết hình thành thiên hà, lỗ đen siêu nặng, và luồng gió thiên hà.

  * Hiện nay: Với sức mạnh exascale (10¹⁸ phép tính/giây), mô phỏng có thể đồng thời theo dõi cấu trúc vĩ mô và các quá trình vi mô như sự hình thành sao, bùng nổ siêu tân tinh, và phản hồi của lỗ đen.


# Công nghệ và phương pháp

  * Phương trình Einstein: Mô tả sự giãn nở không gian-thời gian và ảnh hưởng của năng lượng tối.

  * Mô phỏng N-body: Tính toán lực hấp dẫn giữa hàng tỷ “hạt” đại diện cho cụm vật chất tối và thiên hà.

  * Thủy động lực học vũ trụ (Cosmological Hydrodynamics): Giải phương trình Navier–Stokes cho khí baryon, mô phỏng quá trình làm mát, hình thành sao, và gió thiên hà.

  * Thuật toán đa tỷ lệ: Kết hợp độ phân giải cao cho vùng thiên hà nhỏ và độ phân giải thấp cho không gian rộng để cân bằng độ chính xác và chi phí.

  * AI và Machine Learning: Tăng tốc mô phỏng, nén dữ liệu, và nhận dạng mẫu trong hàng petabyte dữ liệu.


# Học máy trong Vũ trụ học

Học máy là một lĩnh vực phát triển nhanh chóng và có tiềm năng tạo ra bước đột phá trong nghiên cứu vũ trụ học. Bằng cách áp dụng các thuật toán học máy vào các bộ dữ liệu khổng lồ, các nhà nghiên cứu có thể rút ra những hiểu biết và mô hình mà phương pháp truyền thống khó hoặc không thể phát hiện.

## Giới thiệu về Học máy trong Vũ trụ học

Trong vũ trụ học, học máy thường bao gồm việc sử dụng các thuật toán học có giám sát hoặc không giám sát để phân tích các tập dữ liệu lớn.

Học có giám sát: Huấn luyện mô hình trên tập dữ liệu đã gắn nhãn, nơi các nhãn là những đại lượng đã biết như tham số vũ trụ học hoặc đặc tính của thiên hà.

Học không giám sát: Tìm kiếm các mẫu hoặc cấu trúc trong dữ liệu mà không cần biết trước các nhãn.

Một trong những ứng dụng chính của học máy trong vũ trụ học là ước lượng các tham số vũ trụ học từ các tập dữ liệu lớn. Ví dụ, các thuật toán học máy có thể được dùng để phân tích sự phân bố của các thiên hà hoặc các đặc tính của bức xạ phông vi sóng vũ trụ (CMB) nhằm suy ra giá trị của các tham số như hằng số Hubble hoặc mật độ vật chất tối.

## Ứng dụng của Học máy trong Ước lượng Tham số Vũ trụ học

Học máy đã được áp dụng cho nhiều loại dữ liệu vũ trụ khác nhau, bao gồm bức xạ phông vi sóng vũ trụ, khảo sát thiên hà và quan sát thấu kính hấp dẫn. Một số ví dụ tiêu biểu:

Ước lượng tham số vũ trụ học: Sử dụng thuật toán học máy để ước lượng các tham số như hằng số Hubble, mật độ vật chất tối và mật độ năng lượng tối.

Phân loại thiên hà: Phân loại các thiên hà theo loại, chẳng hạn như thiên hà xoắn ốc hay thiên hà elip.

Phân tích thấu kính hấp dẫn: Phân tích đặc tính của các hệ thấu kính hấp dẫn, như phân bố khối lượng của các thiên hà đóng vai trò thấu kính.

## Hướng phát triển trong tương lai cho Học máy trong Vũ trụ học

Việc ứng dụng học máy vào vũ trụ học đang phát triển nhanh với nhiều triển vọng thú vị:

Kết hợp học máy với phương pháp truyền thống: Học máy có thể kết hợp với các phương pháp truyền thống như suy luận Bayes để nâng cao độ chính xác và độ tin cậy trong ước lượng tham số vũ trụ học.

Phân tích các bộ dữ liệu mới: Ứng dụng học máy cho các bộ dữ liệu sắp có như Square Kilometre Array (SKA) hay Kính thiên văn Khảo sát Bầu trời Lớn (LSST) để khám phá những mẫu hình và hiểu biết mới.

Phát triển thuật toán học máy mới: Thiết kế các thuật toán học máy được tối ưu hóa riêng cho nhu cầu của vũ trụ học, chẳng hạn như phân tích cấu trúc quy mô lớn hoặc nghiên cứu đặc tính của bức xạ phông vi sóng vũ trụ.

# 

# Siêu máy tính và dự án tiêu biểu

  * Illustris & IllustrisTNG: Mô phỏng hơn 30 tỷ hạt trong khối lập phương rộng 300 triệu năm ánh sáng, tái hiện chi tiết quá trình từ Big Bang tới hiện tại.

  * Millennium Simulation: Điểm mốc quan trọng trong việc nghiên cứu vai trò của vật chất tối và sự hình thành mạng lưới vũ trụ.

  * Frontier (Mỹ) & Fugaku (Nhật): Siêu máy tính exascale cho phép giải các mô hình vật lý phức tạp với độ chính xác chưa từng có, mở đường cho việc mô phỏng toàn bộ lịch sử vũ trụ với độ phân giải cao.


# Ứng dụng khoa học

  * Giải mã vật chất tối và năng lượng tối: So sánh mô phỏng với quan sát (như dữ liệu từ Kính James Webb, Euclid) để ước tính tỷ lệ và tính chất của các thành phần bí ẩn này.

  * Dự báo quan sát thiên văn: Giúp các nhà thiên văn lên kế hoạch cho các chiến dịch quan sát, tối ưu vị trí đặt kính và thời điểm chụp.

  * Nguồn gốc lỗ đen siêu nặng: Tái hiện quá trình các hạt khí sụp đổ thành lỗ đen khổng lồ ở tâm thiên hà.

  * Hình thành mạng lưới vũ trụ: Giải thích vì sao các thiên hà không phân bố đều mà kết thành sợi, nút, và khoảng trống khổng lồ.


# Thách thức

  * Khối lượng dữ liệu khổng lồ: Một mô phỏng hiện đại tạo ra hàng petabyte dữ liệu, đòi hỏi hệ thống lưu trữ và thuật toán nén tiên tiến.

  * Độ chính xác mô hình: Cần cân bằng giữa quy mô vũ trụ (hàng tỷ năm ánh sáng) và các quá trình nhỏ như bùng nổ siêu tân tinh.

  * Chi phí tính toán: Một mô phỏng quy mô lớn có thể tiêu tốn hàng triệu giờ CPU và hàng triệu USD chi phí vận hành.

  * Kết hợp dữ liệu quan sát: Việc đồng bộ với những phát hiện mới từ các kính thiên văn thế hệ tiếp theo (JWST, SKA) đòi hỏi mô hình linh hoạt.


# Tác động và tương lai

  * Kiến thức vũ trụ sâu hơn: Kiểm chứng hoặc bác bỏ các giả thuyết như Vũ trụ lạm phát, Big Rip, hoặc đa vũ trụ.

  * Giáo dục và phổ biến khoa học: Tạo phim 3D, thực tế ảo cho phép “du hành” trong mô phỏng vũ trụ, giúp công chúng hiểu về Big Bang và cấu trúc thiên hà.

  * Hợp tác liên ngành: Thúc đẩy phát triển thuật toán tính toán song song, lưu trữ dữ liệu khổng lồ, và trí tuệ nhân tạo.

  * Exascale và máy tính lượng tử: Kết hợp siêu máy tính exascale với điện toán lượng tử sẽ mở đường cho mô phỏng từng hạt nguyên tử trong thời kỳ vũ trụ sơ khai.

# Public095

# Giới thiệu

Terraforming là quá trình **cải tạo khí hậu, bề mặt và sinh quyển của một hành tinh** để biến nó trở nên giống Trái Đất, đủ điều kiện cho sự sống của con người và các loài sinh vật khác. Trong số các hành tinh của Hệ Mặt Trời, **Sao Hỏa** được coi là ứng viên tiềm năng nhất vì có ngày dài tương tự Trái Đất, sự hiện diện của nước đóng băng và bầu khí quyển mỏng nhưng giàu CO₂ – yếu tố quan trọng cho việc tạo hiệu ứng nhà kính.

Ý tưởng này không chỉ mang tính khoa học viễn tưởng mà còn là **kế hoạch dài hạn của nhân loại** để đảm bảo sự tồn tại khi Trái Đất đối mặt với khủng hoảng môi trường hoặc thảm họa vũ trụ.

# Định hướng hiện tại: Sao Hỏa

Ngày nay, hành tinh khả thi nhất cho việc cải tạo địa hình (terraforming) có vẻ là Sao Hỏa. Robert Zubrin, người sáng lập Mars Society, đã trình bày một kế hoạch chi tiết có tên **Mars Direct** , khởi đầu bằng một sứ mệnh đưa con người trở lại Sao Hỏa.  
Lý do chính cho việc cải tạo hành tinh là để tạo ra các thế giới thích hợp cho sự sinh sống của con người. Tuy nhiên, một số nhà nghiên cứu tin rằng việc xây dựng các **không gian sống nhân tạo trong vũ trụ (space habitats)** sẽ là giải pháp kinh tế hơn cho việc định cư không gian.

Nếu nghiên cứu về **công nghệ nano và các quy trình hóa học tiên tiến** tiếp tục phát triển, việc cải tạo toàn bộ hành tinh có thể trở nên khả thi trong vài thế kỷ thay vì hàng thiên niên kỷ. Ngược lại, có thể sẽ hợp lý hơn nếu **chỉnh sửa cơ thể con người** để họ không cần môi trường giàu oxy/nitơ và trọng lực 1G như Trái Đất, từ đó giảm nhu cầu cải tạo hành tinh hoặc ít nhất giảm mức độ cần thay đổi môi trường của các hành tinh khác.

( _Ghi chú_ : Vấn đề khí nhà kính hiện nay cũng cho thấy nhân loại vô tình đang “cải tạo” chính Trái Đất, đưa nồng độ CO₂ trở lại mức của hàng triệu năm trước.)

# Paraterraforming – Khái niệm “Worldhouse”

Paraterraforming, hay còn gọi là **“nhà toàn cầu”** , là ý tưởng xây dựng một mái che khổng lồ bao phủ dần phần lớn diện tích có thể sử dụng của một hành tinh. Cấu trúc này gồm:

  * **Mái trong suốt** được giữ ở độ cao từ một vài km trở lên.

  * **Áp suất khí quyển bên trong** đạt mức có thể thở, được cố định bằng các tháp và cáp neo định kỳ.


Công nghệ xây dựng kiểu này đã được biết đến từ thập niên 1960.

**Ưu điểm của Paraterraforming**

  * **Hiệu quả đầu tư tức thì** : Các khu vực được bao phủ có thể được sử dụng ngay từ đầu, mở rộng dần theo nhu cầu.

  * **Tính mô-đun cao** : Có thể phát triển từng phần, phù hợp với tốc độ tăng dân số hoặc nhu cầu cụ thể.

  * **Giảm yêu cầu khí quyển** : Vì có lớp mái rắn, ngay cả các thiên thể không thể giữ bầu khí quyển, như tiểu hành tinh, cũng có thể trở thành môi trường sống.


# Thách thức môi trường trên Sao Hỏa

  * **Áp suất khí quyển cực thấp:** Chỉ bằng 0,6% Trái Đất, không thể duy trì nước ở dạng lỏng.

  * **Nhiệt độ lạnh giá:** Trung bình -60 °C, đêm xuống có thể -125 °C.

  * **Thiếu từ trường:** Không có lớp bảo vệ chống bức xạ vũ trụ và gió Mặt Trời.

  * **Bầu khí quyển mỏng:** Chủ yếu CO₂, thiếu oxy cho hô hấp.

  * **Nước dạng băng:** Tồn tại ở cực và dưới bề mặt, cần khai thác quy mô lớn.


# Phương pháp cải tạo Sao Hỏa

## Tăng áp suất khí quyển:

  * Giải phóng CO₂ từ băng cực và đá carbonat bằng gương phản xạ Mặt Trời hoặc vụ nổ hạt nhân kiểm soát.

  * Mục tiêu tạo hiệu ứng nhà kính để làm ấm bề mặt.


## Gia nhiệt hành tinh:

  * Sử dụng gương không gian khổng lồ tập trung ánh sáng Mặt Trời.

  * Thả khí nhà kính nhân tạo (perfluorocarbons) để giữ nhiệt.


## Tạo từ trường nhân tạo:

  * Đặt nam châm khổng lồ tại điểm L1 (giữa Mặt Trời và Sao Hỏa) để che chắn gió Mặt Trời, giảm mất khí quyển.


## Sản xuất oxy và nước:

  * Ứng dụng công nghệ điện phân CO₂ để tách oxy.

  * Khai thác băng dưới bề mặt và vận chuyển băng từ các vệ tinh như Europa hoặc Enceladus.


## Giới thiệu sinh vật quang hợp:

  * Sử dụng vi khuẩn lam (cyanobacteria) và tảo chịu lạnh để tạo oxy tự nhiên và tăng độ dày khí quyển.


# Công nghệ hỗ trợ

  * **Robot tự động và AI:** Thực hiện khai thác tài nguyên, lắp đặt cơ sở hạ tầng trước khi con người định cư.

  * **In 3D quy mô lớn:** Xây dựng căn cứ, đường ống và các cấu trúc che chắn bức xạ.

  * **Lò phản ứng hạt nhân nhỏ gọn:** Cung cấp năng lượng liên tục cho các quá trình gia nhiệt và điện phân.

  * **Công nghệ sinh học tổng hợp:** Tạo vi khuẩn và cây trồng chịu điều kiện khí hậu khắc nghiệt.


# Tác động và rủi ro

  * **Khoa học và đạo đức:** Tranh luận về việc thay đổi hành tinh có thể phá hủy sự sống bản địa (nếu tồn tại).

  * **Chi phí khổng lồ:** Ước tính hàng nghìn tỷ USD và nhiều thập kỷ, thậm chí hàng thế kỷ.

  * **Rủi ro kỹ thuật:** Sự cố trong kiểm soát khí hậu có thể gây hiệu ứng không lường trước, như bão bụi toàn cầu hoặc mất ổn định quỹ đạo.

  * **Chính trị và pháp lý:** Cần thỏa thuận quốc tế để tránh tranh chấp sở hữu và khai thác tài nguyên.


# Lộ trình khả thi

  * **Giai đoạn 1 – Khảo sát và căn cứ tự cung tự cấp:** Sử dụng tàu vũ trụ chở hàng hóa và robot khai thác nước băng.

  * **Giai đoạn 2 – Gia tăng khí quyển cục bộ:** Xây dựng các mái vòm sinh sống, tăng áp suất bên trong trước khi mở rộng ra ngoài.

  * **Giai đoạn 3 – Cải tạo toàn cầu:** Khi công nghệ đủ trưởng thành, triển khai gương không gian, khí nhà kính và từ trường nhân tạo.

  * **Giai đoạn 4 – Định cư quy mô lớn:** Con người có thể sống ngoài mái vòm, trồng cây, thiết lập xã hội lâu dài.


# Địa kỹ thuật (Geoengineering) – “Terraforming” Trái Đất

**Địa kỹ thuật** là việc cố ý thay đổi môi trường Trái Đất trên quy mô lớn – một dạng “cải tạo” hành tinh của chính chúng ta. Nhiều tranh luận cho rằng nền văn minh nhân loại đã vô tình biến đổi khí hậu Trái Đất thông qua việc thải khí nhà kính công nghiệp, và đã có các đề xuất chủ động để đối phó, ví dụ:

  * **Gương khổng lồ ngoài quỹ đạo** : Điều chỉnh lượng bức xạ Mặt Trời (insolation) mà Trái Đất nhận được – tăng hoặc giảm tùy nhu cầu.

  * **Lưu trữ CO₂ quy mô lớn** : Tiêm hoặc chôn CO₂ vào các tầng địa chất hoặc trầm tích đáy biển.

  * **Thay đổi suất phản chiếu (albedo)** : Phủ vật liệu phản xạ hoặc hấp thụ lên bề mặt Trái Đất để điều chỉnh nhiệt lượng.

  * **Điều chỉnh lượng mưa** : Tạo ra các biển nhân tạo nhằm tác động đến mô hình khí hậu và lượng mưa.


# Tương lai lâu dài

Dù còn xa vời, tiến trình terraform Sao Hỏa mang lại **lợi ích khoa học và công nghệ khổng lồ** : từ phát triển năng lượng sạch, vật liệu siêu bền, tới đột phá về công nghệ sinh học. Những nghiên cứu này cũng giúp cải thiện hiểu biết về **biến đổi khí hậu trên Trái Đất** , cung cấp giải pháp đối phó với khủng hoảng môi trường toàn cầu.

# Public096

# Giới thiệu

Nhiệt hạch (fusion) là quá trình hai hạt nhân nhẹ kết hợp thành một hạt nhân nặng hơn, giải phóng năng lượng khổng lồ – cơ chế cung cấp ánh sáng và nhiệt của Mặt Trời. Khác với phân hạch (fission) trong các nhà máy điện hạt nhân hiện nay, nhiệt hạch không tạo ra chất thải phóng xạ lâu dài và tiềm ẩn nguy cơ tan chảy lõi thấp hơn nhiều.

Con người đã theo đuổi giấc mơ “mặt trời nhân tạo” hàng thập kỷ vì nó hứa hẹn nguồn năng lượng gần như vô hạn, an toàn và không phát thải carbon, có khả năng thay thế hoàn toàn nhiên liệu hóa thạch.

# Nguyên lý cơ bản

  * Phản ứng Deuterium–Tritium (D–T): Hai đồng vị của hydro (deuterium và tritium) hợp nhất ở nhiệt độ hơn 100 triệu °C, tạo ra helium và neutron năng lượng cao.

  * Điều kiện cần thiết:

* Nhiệt độ cực cao để các hạt nhân vượt qua lực đẩy Coulomb.

* Áp suất và mật độ đủ lớn để duy trì phản ứng.

* Thời gian giam giữ đủ lâu (Lawson Criterion) để năng lượng sinh ra nhiều hơn năng lượng đầu vào.


# Tại sao các nhà khoa học nghiên cứu năng lượng nhiệt hạch (nuclear fusion)?

Ngay từ khi lý thuyết về phản ứng nhiệt hạch được hiểu rõ vào những năm 1930, các nhà khoa học – và ngày càng nhiều kỹ sư – đã theo đuổi mục tiêu tái tạo và khai thác nguồn năng lượng này. Lý do là nếu có thể tái tạo phản ứng nhiệt hạch trên Trái Đất ở quy mô công nghiệp, nó có thể cung cấp nguồn năng lượng sạch, an toàn và gần như vô hạn với chi phí hợp lý để đáp ứng nhu cầu của thế giới.

Phản ứng nhiệt hạch có khả năng tạo ra năng lượng gấp **bốn lần so với phân hạch** (đang được dùng trong các nhà máy điện hạt nhân) và gần **bốn triệu lần so với việc đốt dầu hoặc than** tính theo cùng khối lượng nhiên liệu.

Hầu hết các thiết kế lò phản ứng nhiệt hạch đang được phát triển đều sử dụng **hỗn hợp deuteri và triti** – các nguyên tử hydro chứa thêm nơtron. Về lý thuyết, chỉ cần vài gram hai loại nhiên liệu này có thể tạo ra **1 terajoule năng lượng** , tương đương lượng năng lượng một người ở quốc gia phát triển cần dùng trong khoảng **60 năm**.

## Nguồn nhiên liệu dồi dào và an toàn

  * **Deuteri** có thể được chiết xuất từ nước biển với chi phí thấp.

  * **Triti** có thể được tạo ra từ phản ứng của nơtron sinh ra trong quá trình nhiệt hạch với lithium tự nhiên phong phú.


Nguồn nhiên liệu này đủ để cung cấp cho nhân loại **hàng triệu năm**. Các lò phản ứng nhiệt hạch tương lai cũng **an toàn về bản chất** và không được kỳ vọng tạo ra chất thải phóng xạ hoạt tính cao hay tồn tại lâu dài.  
Ngoài ra, do quá trình nhiệt hạch **khó khởi động và duy trì** , không có nguy cơ phản ứng dây chuyền ngoài tầm kiểm soát hay tan chảy lò. Nếu có sự cố, plasma sẽ **tự ngừng phản ứng** , mất năng lượng nhanh chóng và tắt trước khi gây hư hại nghiêm trọng cho lò.

Đáng chú ý, cũng giống như phân hạch, nhiệt hạch **không thải ra khí CO₂ hay khí nhà kính** , nên có thể trở thành **nguồn điện ít carbon lâu dài** từ nửa sau thế kỷ này.

![A diagram of a nuclear fusion AI-generated content may be incorrect.](images/image1.jpeg)

# Nóng hơn cả Mặt Trời

Trong khi lực hấp dẫn khổng lồ của Mặt Trời tự nhiên kích hoạt phản ứng nhiệt hạch, thì trên Trái Đất – **thiếu lực hấp dẫn này** – cần nhiệt độ **cao hơn cả lõi Mặt Trời** để phản ứng xảy ra.  
Cụ thể, chúng ta cần nhiệt độ trên **100 triệu độ C** để khiến deuteri và triti hợp nhất, đồng thời phải kiểm soát áp suất và lực từ tính để **giam giữ plasma ổn định** và duy trì phản ứng đủ lâu nhằm tạo ra **nhiều năng lượng hơn mức tiêu tốn để khởi động**.

Hiện nay, các thí nghiệm đã đạt được điều kiện rất gần với yêu cầu của lò phản ứng nhiệt hạch. Tuy nhiên, các nhà khoa học vẫn cần **cải thiện khả năng giam giữ và ổn định của plasma** để duy trì phản ứng lâu dài và tạo ra năng lượng bền vững.  
Các nhà khoa học và kỹ sư trên khắp thế giới tiếp tục nghiên cứu, phát triển **vật liệu mới** và thiết kế **công nghệ tiên tiến** nhằm đạt được mục tiêu **năng lượng nhiệt hạch ròng dương (net fusion energy)** trong tương lai.

# Công nghệ lò phản ứng

## Tokamak:

  * Sử dụng từ trường hình xuyến (donut) để giam giữ plasma siêu nóng.

  * Dự án tiêu biểu: ITER ở Pháp, hợp tác quốc tế với mục tiêu tạo ra 500 MW công suất từ 50 MW đầu vào.


## Stellarator:

  * Thiết kế từ trường xoắn phức tạp, giúp plasma ổn định hơn và vận hành liên tục.

  * Dự án: Wendelstein 7-X (Đức).


## Giam giữ quán tính (Inertial Confinement):

  * Sử dụng laser hoặc chùm ion cường độ cao nén viên nhiên liệu nhỏ đến mật độ cực lớn.

  * Dự án: National Ignition Facility (NIF) tại Mỹ, đã đạt bước đột phá “ignition” vào năm 2022.


## Khởi nghiệp thương mại:

  * Các công ty như Commonwealth Fusion Systems, Tokamak Energy, Helion Energy đang phát triển lò phản ứng nhỏ gọn, hứa hẹn thương mại hóa sớm hơn dự án quốc gia.


# Ưu điểm nổi bật

  * Nhiên liệu dồi dào: Deuterium có thể tách từ nước biển, tritium có thể sinh từ lithium – nguồn cung gần như vô hạn.

  * An toàn: Phản ứng dừng lại khi có sự cố, không xảy ra “meltdown” như phân hạch.

  * Không phát thải carbon: Gần như không tạo khí nhà kính.

  * Ít chất thải phóng xạ lâu dài: Vật liệu cấu trúc có thể tái chế sau vài thập kỷ.


# Thách thức kỹ thuật

  * Giam giữ plasma ổn định: Plasma ở 100 triệu °C khó kiểm soát, dễ gây nhiễu loạn.

  * Vật liệu chịu nhiệt và bức xạ: Tường buồng phản ứng phải chịu neutron năng lượng cao liên tục.

  * Hiệu suất kinh tế: Cần đạt “breakeven” – sản lượng năng lượng lớn hơn đầu vào – và chi phí cạnh tranh với điện gió, điện mặt trời.


# Tiến bộ gần đây

  * Kỷ lục NIF 2022: Lần đầu tiên năng lượng đầu ra lớn hơn đầu vào của laser, chứng minh tính khả thi của nhiệt hạch.

  * ITER: Dự kiến vận hành plasma đầu tiên vào cuối thập kỷ này, tạo nền tảng cho nhà máy điện thương mại.

  * Công nghệ nam châm siêu dẫn HTS: Cho phép tạo từ trường mạnh hơn, giảm kích thước lò tokamak và chi phí.


# Tác động kinh tế – xã hội

  * Nguồn năng lượng sạch toàn cầu: Có thể cung cấp điện liên tục 24/7, thay thế than, dầu, khí.

  * Giảm phụ thuộc nhiên liệu hóa thạch: Đảm bảo an ninh năng lượng quốc gia.

  * Ứng dụng khoa học: Plasma nhiệt hạch hỗ trợ nghiên cứu vật lý hạt, y học hạt nhân, và sản xuất vật liệu mới.

  * Thúc đẩy công nghệ cao: Từ siêu dẫn, vật liệu chịu nhiệt đến AI điều khiển plasma.


# Tương lai

Nếu các mục tiêu thương mại đạt được, trong vài thập kỷ tới, nhà máy nhiệt hạch có thể trở thành nguồn năng lượng chính của nhân loại. Sự kết hợp giữa AI điều khiển, vật liệu siêu bền, và máy tính lượng tử sẽ rút ngắn thời gian phát triển, đưa “mặt trời nhân tạo” từ phòng thí nghiệm ra thế giới.

# Public097

**Hydro (Hiđrô) – Nguyên tố đơn giản và phong phú nhất vũ trụ**

Hiđrô là nguyên tố đơn giản nhất và cũng phổ biến nhất trong vũ trụ. Nó là thành phần chính của **nước** , **dầu mỏ** , **khí tự nhiên** , và **mọi dạng sống**.  
Tuy nhiên, mặc dù rất đơn giản và phong phú, hiđrô hiếm khi tồn tại tự nhiên dưới dạng khí trên Trái Đất; nó gần như luôn **kết hợp với các nguyên tố khác**.

Hiđrô có thể được tạo ra từ:

  * **Dầu mỏ và khí tự nhiên**

  * **Sinh khối (biomass)**

  * Hoặc bằng cách **tách phân tử nước** (điện phân) sử dụng **năng lượng tái tạo** như điện mặt trời hay điện gió.


**Giải phóng năng lượng từ hiđrô**

Khi đã có hiđrô ở dạng phân tử (H₂), năng lượng chứa trong nó có thể được giải phóng bằng cách **phản ứng với oxy để tạo thành nước**. Việc này có thể thực hiện qua:

  * **Động cơ đốt trong truyền thống**

  * Hoặc **pin nhiên liệu (fuel cell)** : thiết bị chuyển đổi trực tiếp năng lượng của hiđrô thành **điện năng** với **hiệu suất cao** và **tổn thất năng lượng thấp**.


**Vai trò của hiđrô**

Do đó, **hiđrô là một chất mang năng lượng** – nó được dùng để **vận chuyển, lưu trữ và cung cấp năng lượng** được sản xuất từ các nguồn khác.  
Điều này khiến hiđrô trở thành một thành phần quan trọng trong các giải pháp năng lượng sạch và bền vững cho tương lai.

# Giới thiệu

Trong bối cảnh thế giới tìm kiếm giải pháp giảm phát thải carbon, hydro nổi lên như một nguồn năng lượng sạch đầy tiềm năng. Pin nhiên liệu hydro (Hydrogen Fuel Cell – HFC) chuyển hóa hydro và oxy thành điện năng, sản phẩm phụ duy nhất là nước tinh khiết, không thải khí CO₂.

Công nghệ này được kỳ vọng sẽ đóng vai trò quan trọng trong giao thông vận tải – từ xe hơi, xe tải, tàu biển đến hàng không – cũng như trong lưu trữ năng lượng quy mô lớn, góp phần hiện thực hóa mục tiêu trung hòa carbon toàn cầu.

# Nguyên lý hoạt động

  * Phản ứng điện hóa: Hydro (H₂) được đưa vào cực âm (anode), tách thành proton và electron.

  * Dòng electron: Electron di chuyển qua mạch ngoài, tạo ra dòng điện.

  * Tái hợp ở cực dương: Proton và electron kết hợp với oxy (O₂) tạo thành nước (H₂O).

  * Sản phẩm phụ: Chỉ có nước và nhiệt, hoàn toàn không phát thải carbon.


# Ưu điểm vượt trội

  * Không phát thải CO₂: Sản phẩm chỉ là nước, đáp ứng tiêu chuẩn khí thải nghiêm ngặt.

  * Năng lượng cao: Mật độ năng lượng của hydro cao hơn pin lithium-ion, thích hợp cho phương tiện di chuyển xa.

  * Sạc nhanh: Nạp hydro chỉ mất vài phút, tương tự tiếp nhiên liệu truyền thống.

  * Hoạt động trong điều kiện lạnh: Ít bị ảnh hưởng bởi nhiệt độ so với pin điện hóa thông thường.


# Ứng dụng trong giao thông

## Xe hơi và xe tải hạng nặng:

  * Các hãng như Toyota (Mirai), Hyundai (Nexo) đã thương mại hóa xe chạy pin nhiên liệu.

  * Xe tải đường dài của Nikola và Hyundai Xcient phục vụ vận tải xuyên quốc gia.


## Tàu biển:

  * Pin nhiên liệu cung cấp năng lượng cho tàu chở hàng, giảm ô nhiễm cảng biển.

  * Dự án Hydroville và các nghiên cứu của Maersk đang chứng minh tính khả thi.


## Hàng không:

  * Máy bay nhỏ chạy bằng pin nhiên liệu hydro đã bay thử nghiệm.

  * Các hãng như Airbus đặt mục tiêu ra mắt máy bay thương mại hydro vào năm 2035.


## Tàu hỏa và xe buýt đô thị:

  * Chạy tuyến dài, giảm tiếng ồn và không thải khí độc hại tại khu dân cư.


# Hạ tầng và công nghệ hỗ trợ

  * Sản xuất hydro xanh: Dùng điện tái tạo (gió, mặt trời) để điện phân nước, tạo hydro không phát thải.

  * Lưu trữ và vận chuyển: Công nghệ nén hoặc hóa lỏng hydro ở -253 °C, hoặc lưu trữ dưới dạng amoniac để dễ vận chuyển.

  * Trạm nạp hydro: Mạng lưới trạm tiếp nhiên liệu nhanh và an toàn, hiện đang mở rộng ở châu Âu, Mỹ, Nhật Bản.


# Thách thức hiện nay

  * Chi phí cao: Sản xuất hydro xanh và chế tạo pin nhiên liệu vẫn đắt hơn so với nhiên liệu hóa thạch.

  * Hạ tầng hạn chế: Số lượng trạm nạp hydro còn ít, khó đáp ứng nhu cầu đại trà.

  * Hiệu suất năng lượng: Quá trình sản xuất, lưu trữ, vận chuyển hydro làm giảm hiệu suất tổng thể so với điện trực tiếp.

  * An toàn: Hydro là khí nhẹ, dễ rò rỉ và dễ cháy, đòi hỏi quy trình lưu trữ nghiêm ngặt.


# Tiến bộ và triển vọng

  * Công nghệ điện phân giá rẻ: Giảm chi phí hydro xanh nhờ màng điện phân mới và năng lượng tái tạo rẻ hơn.

  * Pin nhiên liệu rắn: Tăng hiệu suất và độ bền.

  * Chính sách hỗ trợ: EU, Mỹ, Nhật, Hàn Quốc đầu tư hàng tỷ USD để phát triển “nền kinh tế hydro”.

  * Kết hợp với năng lượng tái tạo: Tận dụng hydro làm kho lưu trữ cho lưới điện gió và mặt trời.


# Tác động kinh tế – xã hội

  * Giảm phát thải giao thông: Đặc biệt quan trọng cho xe tải, tàu biển, hàng không – các lĩnh vực khó điện khí hóa hoàn toàn.

  * An ninh năng lượng: Giảm phụ thuộc vào dầu mỏ, tăng tính tự chủ năng lượng quốc gia.

  * Tạo việc làm công nghệ cao: Xây dựng trạm nạp, nhà máy hydro, và dây chuyền sản xuất pin nhiên liệu.


# Tương lai

Trong hai thập kỷ tới, khi chi phí hydro xanh giảm và hạ tầng mở rộng, pin nhiên liệu hydro có thể trở thành xương sống của giao thông sạch toàn cầu, bổ sung và cạnh tranh với xe điện pin lithium-ion, tạo ra hệ sinh thái năng lượng bền vững.

# Public098

# Giới thiệu

Siêu tụ điện (Supercapacitor hay Ultracapacitor) là thiết bị lưu trữ năng lượng điện hóa có khả năng sạc và xả cực nhanh, cung cấp công suất tức thì cao gấp nhiều lần pin truyền thống. Khác với pin lithium-ion vốn dựa trên phản ứng hóa học, siêu tụ điện lưu trữ năng lượng dưới dạng điện trường tĩnh, giúp chúng đạt tuổi thọ hàng triệu chu kỳ và hoạt động tốt trong dải nhiệt rộng.

Khi nhu cầu về giao thông bền vững tăng mạnh, siêu tụ điện trở thành giải pháp bổ sung hoặc thay thế pin trong xe điện, xe buýt đô thị, tàu điện, thậm chí máy bay cỡ nhỏ.

# Siêu tụ điện (Supercapacitors)

Siêu tụ điện là các thiết bị điện tử được dùng để **tích trữ lượng điện tích cực lớn**. Chúng còn được gọi là **tụ điện hai lớp (double-layer capacitors)** hoặc **ultracapacitors**.

## Cơ chế hoạt động

Khác với tụ điện thông thường sử dụng chất điện môi, siêu tụ điện lưu trữ năng lượng nhờ **hai cơ chế** :

  1. **Điện dung hai lớp (double-layer capacitance)** – có nguồn gốc **tĩnh điện**.

  2. **Giả điện dung (pseudocapacitance)** – có nguồn gốc **điện hóa học**.


Nhờ kết hợp cả hai, siêu tụ điện vừa hoạt động như **tụ điện** vừa giống **pin thông thường**.

## Thông số ấn tượng

  * **Điện dung cực lớn** : Có thể đạt tới **12.000 F**.

  * So sánh: **Điện dung tự thân của Trái Đất** chỉ khoảng **710 µF** , nhỏ hơn hơn 15 triệu lần so với một siêu tụ điện.

  * **Điện áp sạc tối đa** : Thường nằm trong khoảng **2,5 – 2,7 V** , thấp hơn so với tụ điện tĩnh điện thông thường.

  * **Tính phân cực** : Là thiết bị **có cực tính** , cần được đấu nối đúng chiều giống như tụ điện điện giải.


## Ứng dụng

Nhờ **tốc độ nạp và xả cực nhanh** , siêu tụ điện đặc biệt hữu ích trong các ứng dụng yêu cầu **cung cấp hoặc hấp thụ năng lượng tức thời**.  
Trong một số trường hợp, **siêu tụ điện có thể thay thế hoàn toàn pin** , đem lại ưu điểm về tuổi thọ cao và hiệu suất sạc/xả vượt trội.

# Nguyên lý hoạt động

  * Lớp điện kép (Electric Double-Layer): Năng lượng được lưu trữ nhờ sự tích tụ ion ở bề mặt điện cực, không xảy ra phản ứng hóa học.

  * Điện dung lớn: Vật liệu xốp như than hoạt tính, graphene tạo diện tích bề mặt khổng lồ, tăng khả năng tích điện.

  * Siêu tụ lai (Hybrid Supercapacitor): Kết hợp cơ chế tụ điện và pin để tăng mật độ năng lượng mà vẫn giữ khả năng sạc nhanh.


# Ưu điểm nổi bật

  * Sạc/xả cực nhanh: Chỉ vài giây đến vài phút để nạp đầy.

  * Tuổi thọ dài: Hơn 1 triệu chu kỳ, trong khi pin lithium-ion chỉ vài nghìn.

  * Công suất cao: Phát công suất lớn tức thì, lý tưởng cho các ứng dụng cần dòng điện đột ngột.

  * Hoạt động trong dải nhiệt rộng: -40 °C đến +65 °C mà ít suy giảm hiệu suất.

  * Bảo dưỡng thấp và an toàn: Không nguy cơ cháy nổ do phản ứng hóa học.


# Ứng dụng trong giao thông

  * Xe buýt điện đô thị: Siêu tụ điện sạc nhanh tại trạm dừng, đủ năng lượng cho chặng tiếp theo, giảm thời gian chờ.

  * Tàu điện và metro: Thu hồi năng lượng phanh (regenerative braking) và cung cấp công suất tăng tốc.

  * Xe hybrid và xe thể thao: Bổ sung năng lượng đột xuất khi tăng tốc, giảm tải cho pin chính.

  * Máy bay nhỏ và drone: Cung cấp công suất cao cho cất cánh, hạ cánh, và cơ động nhanh.

  * Xe đua Formula E: Sử dụng siêu tụ điện để lưu trữ và giải phóng năng lượng tái tạo từ phanh.


# Tích hợp với pin truyền thống

  * Hệ thống song song: Siêu tụ xử lý các xung công suất cao, trong khi pin đảm nhận lưu trữ năng lượng dài hạn.

  * Tăng tuổi thọ pin: Giảm căng thẳng dòng điện và nhiệt cho pin, kéo dài thời gian sử dụng.

  * Tối ưu hiệu suất năng lượng tái tạo: Kết hợp với pin lưu trữ trong lưới điện gió, mặt trời.


# Vật liệu tiên tiến

  * Graphene: Diện tích bề mặt lớn, dẫn điện cao, cải thiện đáng kể mật độ năng lượng.

  * Carbon aerogel: Khối lượng nhẹ, cấu trúc nano giúp tăng điện dung.

  * Siêu tụ điện lai lithium-ion: Kết hợp điện cực than hoạt tính và điện cực pin lithium để tăng mật độ năng lượng lên gần mức pin.


# Thách thức

  * Mật độ năng lượng thấp hơn pin: Hiện chỉ bằng khoảng 10–20% so với lithium-ion, hạn chế cho hành trình dài.

  * Chi phí vật liệu tiên tiến: Graphene chất lượng cao và quy trình sản xuất nano còn đắt đỏ.

  * Quản lý điện áp: Cần mạch điều khiển phức tạp để cân bằng và bảo vệ cell.


# Tác động kinh tế – xã hội

  * Giảm thời gian sạc phương tiện công cộng: Giúp xe buýt, tàu điện vận hành liên tục, giảm tắc nghẽn.

  * Bảo vệ môi trường: Tuổi thọ dài và khả năng tái chế tốt hơn pin hóa học, giảm rác thải độc hại.

  * Thúc đẩy công nghiệp vật liệu: Tạo động lực cho nghiên cứu graphene và công nghệ sản xuất nano.


# Tương lai

  * Siêu tụ năng lượng cao: Nghiên cứu vật liệu 2D và composite để đạt mật độ năng lượng gần ngang pin.

  * Sạc không dây công suất lớn: Hỗ trợ sạc nhanh cho xe điện đang di chuyển.

  * Kết hợp AI quản lý năng lượng: Tối ưu việc phân phối dòng điện giữa pin và siêu tụ, tăng hiệu suất toàn hệ thống.

  * Ứng dụng đại trà: Khi giá thành giảm, siêu tụ có thể trở thành giải pháp chính cho giao thông công cộng và thiết bị di động.

# Public099

# Giới thiệu

Sự bùng nổ của xe điện và lưu trữ năng lượng tái tạo khiến nhu cầu lithium tăng mạnh, kéo theo giá thành cao và rủi ro về nguồn cung. **Pin natri-ion (Sodium-Ion)** nổi lên như một giải pháp thay thế chiến lược nhờ **nguồn natri dồi dào** , giá rẻ và phân bố rộng rãi trên Trái Đất. Công nghệ này được xem là **lựa chọn quan trọng** để giảm phụ thuộc vào lithium và đáp ứng nhu cầu lưu trữ quy mô lớn cho lưới điện.

# Pin Natri-Ion (Sodium-Ion Battery) là gì?

Pin natri-ion là loại pin sử dụng **ion natri** (các hạt mang điện tích dương) thay vì **ion lithium** để lưu trữ và giải phóng năng lượng. Công nghệ này bắt đầu cho thấy tiềm năng thương mại từ những năm 1990 như một **giải pháp thay thế cho pin lithium-ion** , vốn đang phổ biến trong điện thoại và xe điện.

![Diagram showing negatively charged chlorine ions moving towards the ...](images/image1.jpeg)

# Cơ chế hoạt động của pin natri-ion

Giống như mọi loại pin, pin natri-ion (Na-ion) gồm ba thành phần chính:

  * **Cực dương và cực âm (cathode & anode)**

  * **Chất điện phân** : cho phép các ion (hạt mang điện tích) di chuyển giữa hai cực.


Pin natri-ion hoạt động tương tự pin lithium-ion, chỉ khác là **ion natri thay cho ion lithium**. Vật liệu làm **điện cực và điện phân** có ảnh hưởng lớn đến **hiệu suất và tuổi thọ** , nên các nhà nghiên cứu liên tục thử nghiệm các tổ hợp mới để tìm ra giải pháp tối ưu về **chi phí – hiệu năng – độ an toàn**. Thông thường, **cực dương (cathode)** và **chất điện phân** chứa natri.

![Sodium Ion Batteries UPSC.](images/image2.jpeg)

  * **Cấu trúc tương tự pin lithium-ion:** Bao gồm cực dương (cathode), cực âm (anode), chất điện phân và màng ngăn.

  * **Ion natri (Na⁺):** Di chuyển qua chất điện phân giữa hai cực trong quá trình sạc và xả.

  * **Khác biệt chính:** Bán kính ion natri lớn hơn lithium, đòi hỏi vật liệu điện cực và cấu trúc tối ưu để duy trì hiệu suất.


# Ưu điểm vượt trội

  * **Nguồn nguyên liệu dồi dào:** Natri chiếm ~2,3% lớp vỏ Trái Đất, khai thác rẻ hơn nhiều so với lithium.

  * **Chi phí thấp:** Giảm giá thành pin, đặc biệt quan trọng cho lưu trữ năng lượng lưới điện.

  * **Hiệu suất nhiệt độ thấp tốt:** Hoạt động ổn định ở môi trường lạnh hơn so với nhiều pin lithium-ion.

  * **Tính bền vững cao:** Giảm rủi ro địa chính trị liên quan đến khai thác lithium và cobalt.


# Ứng dụng

  * **Lưu trữ năng lượng tái tạo:** Dự trữ điện từ gió, mặt trời quy mô lớn với chi phí hợp lý.

  * **Xe điện đô thị:** Phù hợp cho xe tầm ngắn, xe máy điện, xe buýt thành phố.

  * **Thiết bị điện tử tiêu dùng:** Pin dự phòng, thiết bị IoT, nơi chi phí quan trọng hơn mật độ năng lượng.

  * **Lưới điện vi mô (Microgrid):** Giải pháp lưu trữ tại các vùng xa hoặc đảo, nơi cần chi phí thấp và tuổi thọ cao.


# Tiến bộ nghiên cứu

  * **CATL (Trung Quốc):** Giới thiệu pin natri-ion thương mại đầu tiên, mật độ năng lượng ~160 Wh/kg.

  * **Faradion (Anh):** Phát triển công nghệ an toàn, không cần hệ thống làm mát phức tạp.

  * **Hiện tượng kết hợp (Hybrid Systems):** Tích hợp natri-ion với lithium-ion để cân bằng chi phí và mật độ năng lượng.


# Thách thức

  * **Mật độ năng lượng thấp hơn lithium:** Hiện chỉ bằng 60–70% pin lithium-ion, hạn chế cho xe điện đường dài.

  * **Vật liệu điện cực:** Cần nghiên cứu anode/cathode mới để cải thiện dung lượng và tuổi thọ.

  * **Quy mô sản xuất:** Công nghệ mới, cần đầu tư lớn cho chuỗi cung ứng và nhà máy.

  * **Chuẩn hóa công nghiệp:** Chưa có tiêu chuẩn toàn cầu về kích thước và hiệu suất.


# Tác động kinh tế – xã hội

  * **Giảm phụ thuộc vào lithium và cobalt:** Giúp ổn định chuỗi cung ứng toàn cầu.

  * **Hạ giá thành lưu trữ năng lượng tái tạo:** Thúc đẩy điện gió, điện mặt trời, giảm phát thải carbon.

  * **Tạo việc làm mới:** Xây dựng nhà máy pin natri-ion và khai thác natri quy mô lớn.


# Tương lai

Trong 5–10 năm tới, khi công nghệ vật liệu cải thiện và quy mô sản xuất tăng, **pin natri-ion** có thể trở thành giải pháp chính cho lưu trữ năng lượng lưới điện và các phương tiện giao thông đô thị, bổ sung cho pin lithium-ion chứ không hoàn toàn thay thế.

# Public100

Trong các hệ thống công nghệ hiện đại, **máy móc có thể học về vị trí vật lý và thu thập dữ liệu** về cách con người di chuyển và hành xử trong không gian. Dữ liệu này được dùng để **tự động hóa và tối ưu hóa** nhiều nhiệm vụ của con người, tạo nền tảng cho sự phát triển của **công nghệ điện toán không gian (spatial computing)**.

Với sự hỗ trợ của công nghệ này, **máy tính và hệ thống có thể hòa nhập tự nhiên vào môi trường xung quanh**. Apple xem đây là **bước đột phá tiếp theo của ngành máy tính** , minh chứng qua việc tung ra **Apple Vision Pro** – hệ điều hành không gian và kính AR/VR tiên tiến.

# Giới thiệu

Điện toán không gian (Spatial Computing) là nền tảng kết hợp giữa thế giới vật lý và kỹ thuật số, cho phép con người tương tác với dữ liệu và môi trường ảo trong không gian 3D thực. Thay vì chỉ nhìn màn hình phẳng, người dùng trải nghiệm, thao tác và di chuyển trong môi trường số như thật.

Công nghệ này kết hợp thực tế ảo (VR), thực tế tăng cường (AR), cảm biến IoT, và AI nhận thức không gian, mở ra kỷ nguyên mới cho giáo dục, y tế, sản xuất, thương mại và giải trí.

# Spatial Computing là gì?

“Spatial computing” là khái niệm chỉ **giao diện người dùng ba chiều** , nơi công nghệ tạo ra một **lớp không gian số** để gửi và nhận dữ liệu, đồng thời tương tác với thế giới thực. Công nghệ này giúp con người **kết hợp thế giới số và thế giới thật** một cách tự nhiên, trực quan.

Spatial computing bao gồm nhiều công nghệ tiên tiến như:

  * **Thực tế hỗn hợp (Mixed Reality – MR)**

  * **Thực tế mở rộng (Extended Reality – XR)**

  * **Thực tế ảo (Virtual Reality – VR)**

  * **Thực tế tăng cường (Augmented Reality – AR)**


Trong nghiên cứu và phân tích không gian, phần mềm chuyên dụng có thể tạo **đồ thị không gian** từ các đỉnh (vertices) và cạnh (edges), phục vụ cho **hệ thống thông tin địa lý (GIS)** hay các phân tích dạng đồ thị.

# Cách hoạt động của Spatial Computing

  * **Computer Vision (Thị giác máy tính)** : Giúp phần mềm hiểu được nội dung hình ảnh, không chỉ dừng lại ở việc quét điểm ảnh.

  * **Machine Learning & AI**: Thu thập và phân tích dữ liệu không gian để phát hiện mẫu, tự động hóa quy trình và đưa ra phản hồi thông minh.

  * **Fusion of Sensors (Tích hợp cảm biến)** : Kết hợp dữ liệu từ nhiều cảm biến như camera, GPS để có thông tin đầy đủ.

  * **Spatial Mapping System** : Dùng dữ liệu từ camera/sensor để tạo **bản đồ 3D** của môi trường.

  * **Haptic System** : Phản hồi xúc giác (rung, chạm) giúp con người nhận biết tín hiệu từ thiết bị.

  * **Robotics System** : Robot sử dụng dữ liệu không gian để di chuyển, làm việc và hỗ trợ làm việc từ xa.

  * **Edge Computing** : Xử lý dữ liệu ngay tại “rìa” mạng, giảm phụ thuộc vào trung tâm dữ liệu.

  * **IoT (Internet of Things)** : Các thiết bị vật lý trong mạng nội bộ tận dụng dữ liệu không gian để hiểu môi trường và nâng cao trải nghiệm người dùng.


# Thiết bị đeo và Headset trong Spatial Computing

Headset là phần cứng quan trọng, **đeo quanh đầu và che mắt** , chiếu hình ảnh mô phỏng vào tầm nhìn. **Cảm biến chuyển động** nhận biết hướng nhìn để điều chỉnh hình ảnh theo thời gian thực.  
Các tính năng như **nhận diện giọng nói, cử chỉ tay, theo dõi ánh mắt** giúp tương tác tự nhiên hơn.

**Một số thiết bị tiêu biểu** :

  * **Microsoft HoloLens** : Công nghệ hologram tích hợp theo dõi mắt, giọng nói, cử chỉ và lập bản đồ không gian, phục vụ cộng tác doanh nghiệp.

  * **Apple Vision Pro** : Hệ điều hành không gian cho phép điều khiển bằng tay, mắt, giọng nói; hỗ trợ giải trí, ứng dụng, gọi video, trò chơi.

  * **Meta Quest Pro** : Kính MR cho trải nghiệm nhập vai trong game, giải trí, làm việc và kết nối cộng đồng.


# Thành phần cốt lõi

  * Thực tế ảo (VR): Tạo thế giới số hoàn toàn, người dùng nhập vai qua kính VR.

  * Thực tế tăng cường (AR): Chồng hình ảnh số lên môi trường thực, cho phép tương tác trực tiếp.

  * Cảm biến và định vị: Camera 3D, LiDAR, radar, GPS chính xác cao giúp ghi nhận chuyển động, cử chỉ và vị trí.

  * Điện toán biên (Edge Computing): Xử lý dữ liệu tại chỗ, giảm độ trễ cho trải nghiệm thời gian thực.

  * AI nhận thức không gian: Nhận diện đối tượng, lập bản đồ không gian, dự đoán hành vi.


# Ứng dụng tiêu biểu

  * Y tế và phẫu thuật từ xa: Bác sĩ thực hiện ca mổ trong môi trường 3D với dữ liệu bệnh nhân trực tiếp, hỗ trợ robot phẫu thuật.

  * Giáo dục và đào tạo: Lớp học ảo, thí nghiệm 3D, mô phỏng quy trình công nghiệp.

  * Công nghiệp và sản xuất: Hướng dẫn lắp ráp, bảo trì máy móc qua kính AR, giảm lỗi và tăng năng suất.

  * Kiến trúc và bất động sản: Trải nghiệm không gian ảo của tòa nhà trước khi xây dựng.

  * Thương mại và bán lẻ: Cửa hàng ảo cho phép khách hàng “thử” sản phẩm trong không gian thực của họ.

  * Giải trí và thể thao: Game nhập vai, buổi hòa nhạc ảo, sự kiện eSports sống động.


# Lợi ích kinh tế – xã hội

  * Tăng hiệu suất làm việc: Giảm thời gian thiết kế, thử nghiệm, đào tạo.

  * Tiết kiệm chi phí: Giảm nhu cầu di chuyển, vật liệu, và rủi ro khi mô phỏng quy trình phức tạp.

  * Tạo ngành nghề mới: Phát triển nội dung 3D, kỹ sư không gian ảo, thiết kế tương tác.

  * Nâng cao giáo dục và y tế: Cung cấp môi trường học tập và chăm sóc sức khỏe tiếp cận toàn cầu.


# Hạ tầng công nghệ

  * Thiết bị đeo: Kính AR/VR, găng tay xúc giác, bộ định vị toàn thân.

  * Mạng 5G/6G: Băng thông siêu cao, độ trễ thấp cho trải nghiệm mượt mà.

  * Điện toán đám mây: Lưu trữ và xử lý dữ liệu 3D khổng lồ.

  * Chuẩn dữ liệu mở: Tương thích đa nền tảng, cho phép chia sẻ và đồng bộ giữa các ứng dụng.


# Thách thức

  * Chi phí thiết bị: Kính VR/AR chất lượng cao vẫn đắt.

  * Độ trễ và băng thông: Cần mạng siêu tốc và hạ tầng mạnh để xử lý dữ liệu thời gian thực.

  * Quyền riêng tư và bảo mật: Dữ liệu vị trí và chuyển động cá nhân nhạy cảm, cần chính sách bảo vệ nghiêm ngặt.

  * Sáng tạo nội dung: Đòi hỏi kỹ năng thiết kế 3D và lập trình phức tạp.


# Xu hướng tương lai

  * Thiết bị nhẹ và gọn: Kính AR dạng kính mắt thông thường, pin lâu hơn.

  * Tích hợp AI và học máy: Tự động nhận diện và tái tạo môi trường thực với độ chính xác cao.

  * Tương tác đa giác quan: Hỗ trợ cảm giác chạm, âm thanh 3D, mùi hương.

  * Metaverse chuyên biệt: Ứng dụng cho giáo dục, y tế, thương mại chứ không chỉ giải trí.

  * Hợp tác từ xa nâng cao: Cuộc họp ảo với hình đại diện 3D chân thực, tăng tính kết nối toàn cầu.

### TASK QA
num_correct,answers
1,B
1,B
1,C
1,C
1,B
1,A
1,D
2,"A,B"
1,B
1,A
1,C
1,B
2,"B,C"
1,B
1,D
1,C
1,B
1,B
1,B
1,A
1,A
1,B
1,B
1,B
1,C
1,B
1,A
1,B
1,B
1,D
1,B
1,C
1,B
1,B
1,A
1,B
1,C
1,A
1,B
1,A
1,A
1,C
1,C
1,B
1,C
1,C
1,A
1,B
1,C
1,B
1,C
1,B
1,A
1,B
1,A
1,B
1,C
1,A
1,B
1,C
1,A
1,B
1,A
1,B
1,C
1,A
1,C
1,B
1,B
1,C
1,B
1,A
1,B
1,B
1,C
1,B
1,A
1,B
1,C
1,B
1,B
1,D
1,A
1,B
1,C
1,A
1,C
1,A
1,B
1,C
1,C
1,A
1,B
1,B
1,D
1,B
1,C
1,C
1,B
1,C
1,B
1,C
1,C
1,B
1,C
1,B
1,C
1,C
1,B
1,C
1,B
1,C
1,A
1,B
1,C
1,B
1,C
1,B
1,A
1,C
1,B
1,C
1,A
1,A
1,C
1,B
1,C
1,B
1,B
1,C
1,B
1,C
1,A
1,B
1,C
1,C
1,B
1,A
1,B
1,C
1,A
1,B
1,A
1,B
1,C
1,A
1,B
1,A
1,B
1,D
1,A
1,B
1,B
1,B
1,C
1,A
1,B
1,B
1,B
1,A
1,B
1,C
1,B
1,B
1,C
1,A
1,C
1,B
1,B
1,D
1,A
1,C
1,B
1,A
1,D
1,D
1,B
1,C
1,A
1,C
1,D
1,A
1,C
1,B
1,B
1,B
1,A
1,D
1,D
1,C
1,D
1,A
1,C
1,B
1,A
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,D
1,A
1,C
1,B
1,A
1,D
1,C
1,B
1,A
1,C
1,C
1,B
1,A
1,D
1,B
1,C
1,A
1,C
1,B
1,D
1,A
1,D
1,A
1,A
1,C
1,C
1,D
1,B
1,B
1,C
1,A
1,B
1,D
1,A
1,D
1,B
1,A
1,C
1,A
1,A
1,C
1,C
1,A
1,B
1,A
1,C
1,C
1,B
1,D
1,D
1,A
1,C
1,B
1,D
1,D
1,C
1,A
1,B
1,A
1,B
1,A
1,C
1,C
1,B
1,B
1,C
1,A
1,D
1,C
1,D
1,C
1,B
1,A
1,C
1,A
1,D
1,A
1,B
1,C
1,A
1,B
1,B
1,C
1,B
1,A
1,D
1,C
1,A
1,B
1,B
1,C
1,D
1,A
1,C
1,B
1,C
1,D
1,C
1,A
1,D
1,C
2,"B,C"
1,C
1,C
1,D
1,B
1,A
1,C
1,A
1,B
1,A
1,C
1,B
1,A
1,B
1,B
1,C
1,A
1,D
1,A
1,B
1,B
1,B
1,A
1,D
1,B
1,B
1,C
1,D
1,C
1,B
1,D
1,C
1,C
1,B
1,A
1,A
1,B
1,C
1,B
1,A
1,D
1,A
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,B
1,A
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,C
1,B
1,C
1,A
1,A
1,C
1,B
1,C
1,A
1,A
1,B
1,A
1,C
1,A
1,D
1,A
1,B
1,C
1,A
1,D
1,C
1,C
1,B
1,A
1,A
1,C
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,D
1,A
1,C
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,C
1,A
1,A
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,A
1,A
1,D
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,D
1,A
1,A
1,B
1,B
1,C
1,A
1,D
1,B
1,B
1,C
1,A
1,A
1,B